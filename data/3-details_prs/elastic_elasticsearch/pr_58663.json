{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxMzYzNTMy", "number": 58663, "title": "Add declarative parameters to FieldMappers", "bodyText": "The FieldMapper infrastructure currently has a bunch of shared parameters, many of which\nare only applicable to a subset of the 41 mapper implementations we ship with.  Merging,\nparsing and serialization of these parameters are spread around the class hierarchy, with\nmuch repetitive boilerplate code required.  It would be much easier to reason about these\nthings if we could declare the parameter set of each FieldMapper directly in the implementing\nclass, and share the parsing, merging and serialization logic instead.\nThis commit is a first effort at introducing a declarative parameter style.  It adds a new FieldMapper\nsubclass, ParametrizedFieldMapper, and refactors two mappers, Boolean and Binary, to use it.\nParameters are declared on Builder classes, with the declaration including the parameter name,\nwhether or not it is updateable, a default value, how to parse it from mappings, and how to\nextract it from another mapper at merge time.  Builders have a getParameters method, which\nreturns a list of the declared parameters; this is then used for parsing, merging and serialization.\nMerging is achieved by constructing a new Builder from the existing Mapper, and merging in\nvalues from the merging Mapper; conflicts are all caught at this point, and if none exist then a new,\nmerged, Mapper can be built from the Builder.  This allows all values on the Mapper to be final.\nOther mappers can be gradually migrated to this new style, and once they have all been refactored\nwe can merge ParametrizedFieldMapper and FieldMapper entirely.", "createdAt": "2020-06-29T12:05:31Z", "url": "https://github.com/elastic/elasticsearch/pull/58663", "merged": true, "mergeCommit": {"oid": "219b7dbd12fbd9e7438ca86d6ea7cd0bfdba866b"}, "closed": true, "closedAt": "2020-07-09T09:56:26Z", "author": {"login": "romseygeek"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuBy7kAH2gAyNDQxMzYzNTMyOjlkZGEyZjMyYjk5MGNmMmIzNTg4NWUwNThkNmMwM2UxNGEzNWJkNjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABczLectAFqTQ0NTQzNjU0NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9dda2f32b990cf2b35885e058d6c03e14a35bd60", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/9dda2f32b990cf2b35885e058d6c03e14a35bd60", "committedDate": "2020-06-23T09:12:08Z", "message": "First go: need to fix merging with BuilderContext"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c118f36f0d1a78a80a4b2a1a621efb1ac55a392", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/6c118f36f0d1a78a80a4b2a1a621efb1ac55a392", "committedDate": "2020-06-28T11:41:39Z", "message": "Merge remote-tracking branch 'origin/master' into mapper/mergebuilders"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56ad229abe0592f771626c5ea076894841680085", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/56ad229abe0592f771626c5ea076894841680085", "committedDate": "2020-06-29T11:24:58Z", "message": "dedicated tests for parametrized mapper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da0aca5066de8525dd97a03a76265e351566c021", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/da0aca5066de8525dd97a03a76265e351566c021", "committedDate": "2020-06-29T11:45:21Z", "message": "tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e99626bb19412788cb6f08a61291c7e573f1579", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/6e99626bb19412788cb6f08a61291c7e573f1579", "committedDate": "2020-06-29T11:53:00Z", "message": "precommit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7326c49ec1bee5377382e200f3489b86909b36d9", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/7326c49ec1bee5377382e200f3489b86909b36d9", "committedDate": "2020-06-29T12:58:42Z", "message": "meta parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae14ac5a30c1ccf9e448d7713943e46381abcebb", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/ae14ac5a30c1ccf9e448d7713943e46381abcebb", "committedDate": "2020-06-29T12:58:55Z", "message": "Merge remote-tracking branch 'origin/master' into mapper/mergebuilders"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MjY5MzE4", "url": "https://github.com/elastic/elasticsearch/pull/58663#pullrequestreview-439269318", "createdAt": "2020-06-29T15:38:47Z", "commit": {"oid": "ae14ac5a30c1ccf9e448d7713943e46381abcebb"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNTozODo0N1rOGqWwEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjowMDo0NFrOGqXrZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2NjEzMQ==", "bodyText": "Note to self - these were the defaults so they are safe to drop.", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447066131", "createdAt": "2020-06-29T15:38:47Z", "author": {"login": "nik9000"}, "path": "modules/percolator/src/main/java/org/elasticsearch/percolator/PercolatorFieldMapper.java", "diffHunk": "@@ -157,8 +157,6 @@ static KeywordFieldMapper createExtractQueryFieldBuilder(String name, BuilderCon\n         static BinaryFieldMapper createQueryBuilderFieldBuilder(BuilderContext context) {\n             BinaryFieldMapper.Builder builder = new BinaryFieldMapper.Builder(QUERY_BUILDER_FIELD_NAME);\n             builder.docValues(true);\n-            builder.indexOptions(IndexOptions.NONE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae14ac5a30c1ccf9e448d7713943e46381abcebb"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3MDEyMA==", "bodyText": "I think I'd import the inner class to make these a little shorter.", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447070120", "createdAt": "2020-06-29T15:44:21Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/ParametrizedMapperTests.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class ParametrizedMapperTests extends ESTestCase {\n+\n+    private static TestMapper toType(Mapper in) {\n+        return (TestMapper) in;\n+    }\n+\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        final ParametrizedFieldMapper.Parameter<Boolean> fixed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae14ac5a30c1ccf9e448d7713943e46381abcebb"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3MDM5OA==", "bodyText": "I know some folks hate importing inner classes but I don't really have hard and fast rules and think in this case it'd be easier to read.", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447070398", "createdAt": "2020-06-29T15:44:51Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/ParametrizedMapperTests.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class ParametrizedMapperTests extends ESTestCase {\n+\n+    private static TestMapper toType(Mapper in) {\n+        return (TestMapper) in;\n+    }\n+\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        final ParametrizedFieldMapper.Parameter<Boolean> fixed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3MDEyMA=="}, "originalCommit": {"oid": "ae14ac5a30c1ccf9e448d7713943e46381abcebb"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3NTI1NQ==", "bodyText": "These smell a little like our settings which have grown a bit difficult to read over the years. There, I think a builder pattern would have helped deal with how many optional things there are. But here I dunno.\nI think merger might need to take the current value so it can make a call on more complex stuff, right?\nIf a value isn't updateable do you need to define a merger at all?", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447075255", "createdAt": "2020-06-29T15:51:58Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/ParametrizedFieldMapper.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import joptsimple.internal.Strings;\n+import org.apache.lucene.document.FieldType;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+public abstract class ParametrizedFieldMapper extends FieldMapper {\n+\n+    protected ParametrizedFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, new FieldType(), mappedFieldType, multiFields, copyTo);\n+    }\n+\n+    public abstract ParametrizedFieldMapper.Builder getMergeBuilder();\n+\n+    @Override\n+    public final ParametrizedFieldMapper merge(Mapper mergeWith) {\n+\n+        if (mergeWith instanceof FieldMapper == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + mergeWith.getClass().getSimpleName() + \"]\");\n+        }\n+        if (Objects.equals(this.getClass(), mergeWith.getClass()) == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + ((FieldMapper) mergeWith).contentType() + \"]\");\n+        }\n+\n+        ParametrizedFieldMapper.Builder builder = getMergeBuilder();\n+        Conflicts conflicts = new Conflicts(name());\n+        builder.merge((FieldMapper) mergeWith, conflicts);\n+        conflicts.check();\n+        return builder.build(new BuilderContext(Settings.EMPTY, parentPath(name())));\n+    }\n+\n+    private static ContentPath parentPath(String name) {\n+        int endPos = name.lastIndexOf(\".\");\n+        if (endPos == -1) {\n+            return new ContentPath(0);\n+        }\n+        return new ContentPath(name.substring(endPos));\n+    }\n+\n+    @Override\n+    protected final void mergeOptions(FieldMapper other, List<String> conflicts) {\n+        // TODO remove when everything is parametrized\n+    }\n+\n+    @Override\n+    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject(simpleName());\n+        builder.field(\"type\", contentType());\n+        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n+        getMergeBuilder().toXContent(builder, includeDefaults);\n+        multiFields.toXContent(builder, params);\n+        copyTo.toXContent(builder, params);\n+        return builder.endObject();\n+    }\n+\n+    public static final class Parameter<T> {\n+\n+        private final T defaultValue;\n+        private final BiFunction<String, Object, T> parser;\n+        private final Function<FieldMapper, T> merger;\n+        public final String name;\n+        public final boolean updateable;\n+        private boolean acceptsNull = false;\n+        private T value;\n+        private boolean frozen = false;\n+\n+        public Parameter(String name, boolean updateable, T defaultValue,\n+                         BiFunction<String, Object, T> parser, Function<FieldMapper, T> merger) {\n+            this.name = name;\n+            this.defaultValue = defaultValue;\n+            this.value = defaultValue;\n+            this.parser = parser;\n+            this.merger = merger;\n+            this.updateable = updateable;\n+        }\n+\n+        public T getValue() {\n+            return value;\n+        }\n+\n+        public Parameter<T> acceptsNull() {\n+            this.acceptsNull = true;\n+            return this;\n+        }\n+\n+        public Parameter<T> init(FieldMapper toInit) {\n+            assert frozen == false;\n+            this.value = merger.apply(toInit);\n+            return this;\n+        }\n+\n+        public Parameter<T> update(T value) {\n+            this.value = value;\n+            return this;\n+        }\n+\n+        public Parameter<T> parse(String field, Object in) {\n+            assert frozen == false;\n+            this.value = parser.apply(field, in);\n+            return this;\n+        }\n+\n+        public Parameter<T> merge(FieldMapper toMerge, Conflicts conflicts) {\n+            T value = merger.apply(toMerge);\n+            if (frozen && Objects.equals(this.value, value) == false) {\n+                conflicts.addConflict(name, this.value.toString(), value.toString());\n+            } else {\n+                this.value = value;\n+            }\n+            return this;\n+        }\n+\n+        public Parameter<T> freeze() {\n+            this.frozen = true;\n+            return this;\n+        }\n+\n+        public XContentBuilder toXContent(XContentBuilder builder, boolean includeDefaults) throws IOException {\n+            if (includeDefaults || (Objects.equals(defaultValue, value) == false)) {\n+                builder.field(name, value);\n+            }\n+            return builder;\n+        }\n+\n+        public static Parameter<Boolean> boolParam(String name, boolean updateable,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae14ac5a30c1ccf9e448d7713943e46381abcebb"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3NjE0Mg==", "bodyText": "Do you think it'd be clearer if merge checked for updateable?", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447076142", "createdAt": "2020-06-29T15:53:24Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/ParametrizedFieldMapper.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import joptsimple.internal.Strings;\n+import org.apache.lucene.document.FieldType;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+public abstract class ParametrizedFieldMapper extends FieldMapper {\n+\n+    protected ParametrizedFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, new FieldType(), mappedFieldType, multiFields, copyTo);\n+    }\n+\n+    public abstract ParametrizedFieldMapper.Builder getMergeBuilder();\n+\n+    @Override\n+    public final ParametrizedFieldMapper merge(Mapper mergeWith) {\n+\n+        if (mergeWith instanceof FieldMapper == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + mergeWith.getClass().getSimpleName() + \"]\");\n+        }\n+        if (Objects.equals(this.getClass(), mergeWith.getClass()) == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + ((FieldMapper) mergeWith).contentType() + \"]\");\n+        }\n+\n+        ParametrizedFieldMapper.Builder builder = getMergeBuilder();\n+        Conflicts conflicts = new Conflicts(name());\n+        builder.merge((FieldMapper) mergeWith, conflicts);\n+        conflicts.check();\n+        return builder.build(new BuilderContext(Settings.EMPTY, parentPath(name())));\n+    }\n+\n+    private static ContentPath parentPath(String name) {\n+        int endPos = name.lastIndexOf(\".\");\n+        if (endPos == -1) {\n+            return new ContentPath(0);\n+        }\n+        return new ContentPath(name.substring(endPos));\n+    }\n+\n+    @Override\n+    protected final void mergeOptions(FieldMapper other, List<String> conflicts) {\n+        // TODO remove when everything is parametrized\n+    }\n+\n+    @Override\n+    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject(simpleName());\n+        builder.field(\"type\", contentType());\n+        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n+        getMergeBuilder().toXContent(builder, includeDefaults);\n+        multiFields.toXContent(builder, params);\n+        copyTo.toXContent(builder, params);\n+        return builder.endObject();\n+    }\n+\n+    public static final class Parameter<T> {\n+\n+        private final T defaultValue;\n+        private final BiFunction<String, Object, T> parser;\n+        private final Function<FieldMapper, T> merger;\n+        public final String name;\n+        public final boolean updateable;\n+        private boolean acceptsNull = false;\n+        private T value;\n+        private boolean frozen = false;\n+\n+        public Parameter(String name, boolean updateable, T defaultValue,\n+                         BiFunction<String, Object, T> parser, Function<FieldMapper, T> merger) {\n+            this.name = name;\n+            this.defaultValue = defaultValue;\n+            this.value = defaultValue;\n+            this.parser = parser;\n+            this.merger = merger;\n+            this.updateable = updateable;\n+        }\n+\n+        public T getValue() {\n+            return value;\n+        }\n+\n+        public Parameter<T> acceptsNull() {\n+            this.acceptsNull = true;\n+            return this;\n+        }\n+\n+        public Parameter<T> init(FieldMapper toInit) {\n+            assert frozen == false;\n+            this.value = merger.apply(toInit);\n+            return this;\n+        }\n+\n+        public Parameter<T> update(T value) {\n+            this.value = value;\n+            return this;\n+        }\n+\n+        public Parameter<T> parse(String field, Object in) {\n+            assert frozen == false;\n+            this.value = parser.apply(field, in);\n+            return this;\n+        }\n+\n+        public Parameter<T> merge(FieldMapper toMerge, Conflicts conflicts) {\n+            T value = merger.apply(toMerge);\n+            if (frozen && Objects.equals(this.value, value) == false) {\n+                conflicts.addConflict(name, this.value.toString(), value.toString());\n+            } else {\n+                this.value = value;\n+            }\n+            return this;\n+        }\n+\n+        public Parameter<T> freeze() {\n+            this.frozen = true;\n+            return this;\n+        }\n+\n+        public XContentBuilder toXContent(XContentBuilder builder, boolean includeDefaults) throws IOException {\n+            if (includeDefaults || (Objects.equals(defaultValue, value) == false)) {\n+                builder.field(name, value);\n+            }\n+            return builder;\n+        }\n+\n+        public static Parameter<Boolean> boolParam(String name, boolean updateable,\n+                                                   Function<FieldMapper, Boolean> merger, boolean defaultValue) {\n+            return new Parameter<>(name, updateable, defaultValue, (n, o) -> XContentMapValues.nodeBooleanValue(o), merger);\n+        }\n+\n+        public static Parameter<Float> floatParam(String name, boolean updateable,\n+                                                  Function<FieldMapper, Float> merger, float defaultValue) {\n+            return new Parameter<>(name, updateable, defaultValue, (n, o) -> XContentMapValues.nodeFloatValue(o), merger);\n+        }\n+\n+        public static Parameter<String> stringParam(String name, boolean updateable,\n+                                                    Function<FieldMapper, String> merger, String defaultValue) {\n+            return new Parameter<>(name, updateable, defaultValue, (n, o) -> XContentMapValues.nodeStringValue(o, defaultValue), merger);\n+        }\n+    }\n+\n+    public static final class Conflicts {\n+\n+        private final String mapperName;\n+        private final List<String> conflicts = new ArrayList<>();\n+\n+        public Conflicts(String mapperName) {\n+            this.mapperName = mapperName;\n+        }\n+\n+        public void addConflict(String parameter, String existing, String toMerge) {\n+            conflicts.add(\"Cannot update parameter [\" + parameter + \"] from [\" + existing + \"] to [\" + toMerge + \"]\");\n+        }\n+\n+        public void check() {\n+            if (conflicts.isEmpty()) {\n+                return;\n+            }\n+            String message = \"Mapper for [\" + mapperName + \"] conflicts with existing mapper:\\n\\t\"\n+                + Strings.join(conflicts, \"\\n\\t\");\n+            throw new IllegalArgumentException(message);\n+        }\n+\n+    }\n+\n+    public abstract static class Builder extends Mapper.Builder<Builder> {\n+\n+        protected final MultiFields.Builder multiFieldsBuilder = new MultiFields.Builder();\n+        protected CopyTo.Builder copyTo = new CopyTo.Builder();\n+\n+        protected final Parameter<Map<String, String>> meta\n+            = new Parameter<>(\"meta\", true, Collections.emptyMap(), TypeParsers::parseMeta, m -> m.fieldType().meta());\n+\n+        protected Builder(String name) {\n+            super(name);\n+        }\n+\n+        protected Builder init(FieldMapper base) {\n+            for (Parameter<?> param : getParameters()) {\n+                param.init(base);\n+            }\n+            for (Mapper subField : base.multiFields) {\n+                multiFieldsBuilder.add(subField);\n+            }\n+            return this;\n+        }\n+\n+        public final void merge(FieldMapper in, Conflicts conflicts) {\n+            for (Parameter<?> param : getParameters()) {\n+                if (param.updateable == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae14ac5a30c1ccf9e448d7713943e46381abcebb"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3ODQxOQ==", "bodyText": "This makes me think merger isn't really the right name for this, actually - it is more like read.", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447078419", "createdAt": "2020-06-29T15:56:39Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/ParametrizedFieldMapper.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import joptsimple.internal.Strings;\n+import org.apache.lucene.document.FieldType;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+public abstract class ParametrizedFieldMapper extends FieldMapper {\n+\n+    protected ParametrizedFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, new FieldType(), mappedFieldType, multiFields, copyTo);\n+    }\n+\n+    public abstract ParametrizedFieldMapper.Builder getMergeBuilder();\n+\n+    @Override\n+    public final ParametrizedFieldMapper merge(Mapper mergeWith) {\n+\n+        if (mergeWith instanceof FieldMapper == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + mergeWith.getClass().getSimpleName() + \"]\");\n+        }\n+        if (Objects.equals(this.getClass(), mergeWith.getClass()) == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + ((FieldMapper) mergeWith).contentType() + \"]\");\n+        }\n+\n+        ParametrizedFieldMapper.Builder builder = getMergeBuilder();\n+        Conflicts conflicts = new Conflicts(name());\n+        builder.merge((FieldMapper) mergeWith, conflicts);\n+        conflicts.check();\n+        return builder.build(new BuilderContext(Settings.EMPTY, parentPath(name())));\n+    }\n+\n+    private static ContentPath parentPath(String name) {\n+        int endPos = name.lastIndexOf(\".\");\n+        if (endPos == -1) {\n+            return new ContentPath(0);\n+        }\n+        return new ContentPath(name.substring(endPos));\n+    }\n+\n+    @Override\n+    protected final void mergeOptions(FieldMapper other, List<String> conflicts) {\n+        // TODO remove when everything is parametrized\n+    }\n+\n+    @Override\n+    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject(simpleName());\n+        builder.field(\"type\", contentType());\n+        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n+        getMergeBuilder().toXContent(builder, includeDefaults);\n+        multiFields.toXContent(builder, params);\n+        copyTo.toXContent(builder, params);\n+        return builder.endObject();\n+    }\n+\n+    public static final class Parameter<T> {\n+\n+        private final T defaultValue;\n+        private final BiFunction<String, Object, T> parser;\n+        private final Function<FieldMapper, T> merger;\n+        public final String name;\n+        public final boolean updateable;\n+        private boolean acceptsNull = false;\n+        private T value;\n+        private boolean frozen = false;\n+\n+        public Parameter(String name, boolean updateable, T defaultValue,\n+                         BiFunction<String, Object, T> parser, Function<FieldMapper, T> merger) {\n+            this.name = name;\n+            this.defaultValue = defaultValue;\n+            this.value = defaultValue;\n+            this.parser = parser;\n+            this.merger = merger;\n+            this.updateable = updateable;\n+        }\n+\n+        public T getValue() {\n+            return value;\n+        }\n+\n+        public Parameter<T> acceptsNull() {\n+            this.acceptsNull = true;\n+            return this;\n+        }\n+\n+        public Parameter<T> init(FieldMapper toInit) {\n+            assert frozen == false;\n+            this.value = merger.apply(toInit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae14ac5a30c1ccf9e448d7713943e46381abcebb"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3OTk5MA==", "bodyText": "Actually, looking above you use acceptsNull in a very bulder like way, which I'm cool with.\nI think it'd be good to make the \"for declaration\" method public with javadoc. And the \"for use by ParameterizedFieldMapper\" methods private or at least package private. That way it is more obvious what we can call when building the mappers.\nI'm sort of sad that this is bit of a parallel world to the xcontent parsers that we already have, but I know how we got here. And it is where we are. So, yeah, I'm +1 on building it.", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447079990", "createdAt": "2020-06-29T15:58:57Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/ParametrizedFieldMapper.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import joptsimple.internal.Strings;\n+import org.apache.lucene.document.FieldType;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+public abstract class ParametrizedFieldMapper extends FieldMapper {\n+\n+    protected ParametrizedFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, new FieldType(), mappedFieldType, multiFields, copyTo);\n+    }\n+\n+    public abstract ParametrizedFieldMapper.Builder getMergeBuilder();\n+\n+    @Override\n+    public final ParametrizedFieldMapper merge(Mapper mergeWith) {\n+\n+        if (mergeWith instanceof FieldMapper == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + mergeWith.getClass().getSimpleName() + \"]\");\n+        }\n+        if (Objects.equals(this.getClass(), mergeWith.getClass()) == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + ((FieldMapper) mergeWith).contentType() + \"]\");\n+        }\n+\n+        ParametrizedFieldMapper.Builder builder = getMergeBuilder();\n+        Conflicts conflicts = new Conflicts(name());\n+        builder.merge((FieldMapper) mergeWith, conflicts);\n+        conflicts.check();\n+        return builder.build(new BuilderContext(Settings.EMPTY, parentPath(name())));\n+    }\n+\n+    private static ContentPath parentPath(String name) {\n+        int endPos = name.lastIndexOf(\".\");\n+        if (endPos == -1) {\n+            return new ContentPath(0);\n+        }\n+        return new ContentPath(name.substring(endPos));\n+    }\n+\n+    @Override\n+    protected final void mergeOptions(FieldMapper other, List<String> conflicts) {\n+        // TODO remove when everything is parametrized\n+    }\n+\n+    @Override\n+    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject(simpleName());\n+        builder.field(\"type\", contentType());\n+        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n+        getMergeBuilder().toXContent(builder, includeDefaults);\n+        multiFields.toXContent(builder, params);\n+        copyTo.toXContent(builder, params);\n+        return builder.endObject();\n+    }\n+\n+    public static final class Parameter<T> {\n+\n+        private final T defaultValue;\n+        private final BiFunction<String, Object, T> parser;\n+        private final Function<FieldMapper, T> merger;\n+        public final String name;\n+        public final boolean updateable;\n+        private boolean acceptsNull = false;\n+        private T value;\n+        private boolean frozen = false;\n+\n+        public Parameter(String name, boolean updateable, T defaultValue,\n+                         BiFunction<String, Object, T> parser, Function<FieldMapper, T> merger) {\n+            this.name = name;\n+            this.defaultValue = defaultValue;\n+            this.value = defaultValue;\n+            this.parser = parser;\n+            this.merger = merger;\n+            this.updateable = updateable;\n+        }\n+\n+        public T getValue() {\n+            return value;\n+        }\n+\n+        public Parameter<T> acceptsNull() {\n+            this.acceptsNull = true;\n+            return this;\n+        }\n+\n+        public Parameter<T> init(FieldMapper toInit) {\n+            assert frozen == false;\n+            this.value = merger.apply(toInit);\n+            return this;\n+        }\n+\n+        public Parameter<T> update(T value) {\n+            this.value = value;\n+            return this;\n+        }\n+\n+        public Parameter<T> parse(String field, Object in) {\n+            assert frozen == false;\n+            this.value = parser.apply(field, in);\n+            return this;\n+        }\n+\n+        public Parameter<T> merge(FieldMapper toMerge, Conflicts conflicts) {\n+            T value = merger.apply(toMerge);\n+            if (frozen && Objects.equals(this.value, value) == false) {\n+                conflicts.addConflict(name, this.value.toString(), value.toString());\n+            } else {\n+                this.value = value;\n+            }\n+            return this;\n+        }\n+\n+        public Parameter<T> freeze() {\n+            this.frozen = true;\n+            return this;\n+        }\n+\n+        public XContentBuilder toXContent(XContentBuilder builder, boolean includeDefaults) throws IOException {\n+            if (includeDefaults || (Objects.equals(defaultValue, value) == false)) {\n+                builder.field(name, value);\n+            }\n+            return builder;\n+        }\n+\n+        public static Parameter<Boolean> boolParam(String name, boolean updateable,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3NTI1NQ=="}, "originalCommit": {"oid": "ae14ac5a30c1ccf9e448d7713943e46381abcebb"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA4MTMxOQ==", "bodyText": "If you make them package private that does a pretty good job implying they are only exposed for testing.", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447081319", "createdAt": "2020-06-29T16:00:44Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/BinaryFieldMapper.java", "diffHunk": "@@ -63,26 +61,34 @@\n         }\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    private static BinaryFieldMapper toType(FieldMapper in) {\n+        return (BinaryFieldMapper) in;\n+    }\n+\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        final Parameter<Boolean> stored = Parameter.boolParam(\"store\", false, m -> toType(m).stored, false);\n+        final Parameter<Boolean> hasDocValues = Parameter.boolParam(\"doc_values\", false, m -> toType(m).hasDocValues,  false);\n \n         public Builder(String name) {\n-            super(name, Defaults.FIELD_TYPE);\n-            hasDocValues = false;\n-            builder = this;\n+            super(name);\n+        }\n+\n+        // For testing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae14ac5a30c1ccf9e448d7713943e46381abcebb"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5bb39b2de4645b21b88b06959e24a1ccdbb0aadb", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/5bb39b2de4645b21b88b06959e24a1ccdbb0aadb", "committedDate": "2020-06-30T09:03:24Z", "message": "Use simple name in merge builder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a31b1a61c004292f517e70312c781ac8a0735262", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/a31b1a61c004292f517e70312c781ac8a0735262", "committedDate": "2020-06-30T12:51:45Z", "message": "Merge remote-tracking branch 'origin/master' into mapper/mergebuilders"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "928a15f9cb2ab75d65c1448d7d32c490abf32b93", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/928a15f9cb2ab75d65c1448d7d32c490abf32b93", "committedDate": "2020-06-30T13:53:54Z", "message": "feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47c17e4f522674030e4262425849411e60dc37ab", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/47c17e4f522674030e4262425849411e60dc37ab", "committedDate": "2020-06-30T14:04:00Z", "message": "checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMzEzNjcx", "url": "https://github.com/elastic/elasticsearch/pull/58663#pullrequestreview-440313671", "createdAt": "2020-06-30T19:16:44Z", "commit": {"oid": "47c17e4f522674030e4262425849411e60dc37ab"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxOToxNjo0NFrOGrK-dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxOToxOTowMVrOGrLC3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyMTc4MA==", "bodyText": "Without this we don't test store and stuff like that, right?", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447921780", "createdAt": "2020-06-30T19:16:44Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/BinaryFieldMapperTests.java", "diffHunk": "@@ -32,28 +32,18 @@\n import org.elasticsearch.common.xcontent.XContentFactory;\n import org.elasticsearch.common.xcontent.XContentType;\n import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n import org.elasticsearch.test.InternalSettingsPlugin;\n \n import java.io.IOException;\n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.Set;\n \n import static org.hamcrest.Matchers.containsString;\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.instanceOf;\n \n-public class BinaryFieldMapperTests extends FieldMapperTestCase<BinaryFieldMapper.Builder> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c17e4f522674030e4262425849411e60dc37ab"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyMTkyMw==", "bodyText": "Same here, right?", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447921923", "createdAt": "2020-06-30T19:17:03Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/BooleanFieldMapperTests.java", "diffHunk": "@@ -41,25 +41,21 @@\n import org.elasticsearch.index.mapper.MapperService.MergeReason;\n import org.elasticsearch.index.mapper.ParseContext.Document;\n import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n import org.elasticsearch.test.InternalSettingsPlugin;\n import org.junit.Before;\n \n import java.io.IOException;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Set;\n \n import static org.hamcrest.Matchers.containsString;\n \n-public class BooleanFieldMapperTests extends FieldMapperTestCase<BooleanFieldMapper.Builder> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c17e4f522674030e4262425849411e60dc37ab"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyMjkwOQ==", "bodyText": "Ah! So you have the tests in ParameterizedFieldTest for things like this. Do you think it is important to also test that the field merges here too? I guess not, but I'm worried about dropping something accidentally.", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447922909", "createdAt": "2020-06-30T19:19:01Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/BinaryFieldMapperTests.java", "diffHunk": "@@ -32,28 +32,18 @@\n import org.elasticsearch.common.xcontent.XContentFactory;\n import org.elasticsearch.common.xcontent.XContentType;\n import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n import org.elasticsearch.test.InternalSettingsPlugin;\n \n import java.io.IOException;\n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.Set;\n \n import static org.hamcrest.Matchers.containsString;\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.instanceOf;\n \n-public class BinaryFieldMapperTests extends FieldMapperTestCase<BinaryFieldMapper.Builder> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyMTc4MA=="}, "originalCommit": {"oid": "47c17e4f522674030e4262425849411e60dc37ab"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bf93273e7d22d56fd37e8fa15d8e2a75c713711", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/4bf93273e7d22d56fd37e8fa15d8e2a75c713711", "committedDate": "2020-07-01T12:26:36Z", "message": "wut"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3011064d8afe48485056fe7cc11ca36d50901749", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/3011064d8afe48485056fe7cc11ca36d50901749", "committedDate": "2020-07-02T14:00:41Z", "message": "Merge remote-tracking branch 'origin/master' into mapper/mergebuilders"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb35edaf9b835bb2ecfa561983b0f2e81d5f008f", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/bb35edaf9b835bb2ecfa561983b0f2e81d5f008f", "committedDate": "2020-07-02T16:33:26Z", "message": "fix object serialization; javadocs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyOTAwODU3", "url": "https://github.com/elastic/elasticsearch/pull/58663#pullrequestreview-442900857", "createdAt": "2020-07-06T09:06:14Z", "commit": {"oid": "bb35edaf9b835bb2ecfa561983b0f2e81d5f008f"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOTowNjoxNVrOGtPDAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToxNDoyNFrOGtPU9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4NTYzMg==", "bodyText": "seems like if the field is searchable and stored too, we end up adding two fields, while before we would only add one?", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r450085632", "createdAt": "2020-07-06T09:06:15Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/BooleanFieldMapper.java", "diffHunk": "@@ -250,8 +249,11 @@ protected void parseCreateField(ParseContext context) throws IOException {\n         if (value == null) {\n             return;\n         }\n-        if (fieldType().isSearchable() || fieldType.stored()) {\n-            context.doc().add(new Field(fieldType().name(), value ? \"T\" : \"F\", fieldType));\n+        if (fieldType().isSearchable()) {\n+            context.doc().add(new Field(fieldType().name(), value ? \"T\" : \"F\", Defaults.FIELD_TYPE));\n+        }\n+        if (stored) {\n+            context.doc().add(new StoredField(fieldType().name(), value ? \"T\" : \"F\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb35edaf9b835bb2ecfa561983b0f2e81d5f008f"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4Nzk1OA==", "bodyText": "I get confused here  that stored seems to be treated differently from e.g. doc_values. Why is that?", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r450087958", "createdAt": "2020-07-06T09:10:15Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/BooleanFieldMapper.java", "diffHunk": "@@ -71,25 +68,37 @@\n         public static final BytesRef FALSE = new BytesRef(\"F\");\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    private static BooleanFieldMapper toType(FieldMapper in) {\n+        return (BooleanFieldMapper) in;\n+    }\n+\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n \n-        private Boolean nullValue;\n+        private final Parameter<Float> boost = Parameter.floatParam(\"boost\", true, m -> m.fieldType().boost(), 1.0f);\n+        private final Parameter<Boolean> docValues\n+            = Parameter.boolParam(\"doc_values\", false, m -> m.fieldType().hasDocValues(),  true);\n+        private final Parameter<Boolean> indexed\n+            = Parameter.boolParam(\"index\", false, m -> m.fieldType().isSearchable(), true);\n+        private final Parameter<Boolean> nullValue\n+            = new Parameter<>(\"null_value\", false, null, (n, o) -> XContentMapValues.nodeBooleanValue(o), m -> toType(m).nullValue);\n+        private final Parameter<Boolean> stored = Parameter.boolParam(\"store\", false, m -> toType(m).stored, false);\n+        private final Parameter<Map<String, String>> meta\n+            = new Parameter<>(\"meta\", true, Collections.emptyMap(), TypeParsers::parseMeta, m -> m.fieldType().meta());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb35edaf9b835bb2ecfa561983b0f2e81d5f008f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5MDIyOA==", "bodyText": "this means that every field supports multi fields and copy_to, I think. But I think that runtime fields won't?", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r450090228", "createdAt": "2020-07-06T09:14:24Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/ParametrizedFieldMapper.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+/**\n+ * Defines how a particular field should be indexed and searched\n+ *\n+ * Configuration {@link Parameter}s for the mapper are defined on a {@link Builder} subclass,\n+ * and returned by its {@link Builder#getParameters()} method.  Merging, serialization\n+ * and parsing of the mapper are all mediated through this set of parameters.\n+ *\n+ * Subclasses should implement a {@link Builder} that is returned from the\n+ * {@link #getMergeBuilder()} method, initialised with the existing builder.\n+ */\n+public abstract class ParametrizedFieldMapper extends FieldMapper {\n+\n+    /**\n+     * Creates a new ParametrizedFieldMapper\n+     */\n+    protected ParametrizedFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, new FieldType(), mappedFieldType, multiFields, copyTo);\n+    }\n+\n+    /**\n+     * Returns a {@link Builder} to be used for merging and serialization\n+     *\n+     * Implement as follows:\n+     * {@code return new MyBuilder(simpleName()).init(this); }\n+     */\n+    public abstract ParametrizedFieldMapper.Builder getMergeBuilder();\n+\n+    @Override\n+    public final ParametrizedFieldMapper merge(Mapper mergeWith) {\n+\n+        if (mergeWith instanceof FieldMapper == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + mergeWith.getClass().getSimpleName() + \"]\");\n+        }\n+        if (Objects.equals(this.getClass(), mergeWith.getClass()) == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + ((FieldMapper) mergeWith).contentType() + \"]\");\n+        }\n+\n+        ParametrizedFieldMapper.Builder builder = getMergeBuilder();\n+        Conflicts conflicts = new Conflicts(name());\n+        builder.merge((FieldMapper) mergeWith, conflicts);\n+        conflicts.check();\n+        return builder.build(new BuilderContext(Settings.EMPTY, parentPath(name())));\n+    }\n+\n+    private static ContentPath parentPath(String name) {\n+        int endPos = name.lastIndexOf(\".\");\n+        if (endPos == -1) {\n+            return new ContentPath(0);\n+        }\n+        return new ContentPath(name.substring(0, endPos));\n+    }\n+\n+    @Override\n+    protected final void mergeOptions(FieldMapper other, List<String> conflicts) {\n+        // TODO remove when everything is parametrized\n+    }\n+\n+    @Override\n+    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject(simpleName());\n+        builder.field(\"type\", contentType());\n+        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n+        getMergeBuilder().toXContent(builder, includeDefaults);\n+        multiFields.toXContent(builder, params);\n+        copyTo.toXContent(builder, params);\n+        return builder.endObject();\n+    }\n+\n+    /**\n+     * A configurable parameter for a field mapper\n+     * @param <T> the type of the value the parameter holds\n+     */\n+    public static final class Parameter<T> {\n+\n+        public final String name;\n+        private final T defaultValue;\n+        private final BiFunction<String, Object, T> parser;\n+        private final Function<FieldMapper, T> initializer;\n+        private final boolean updateable;\n+        private boolean acceptsNull = false;\n+        private T value;\n+\n+        /**\n+         * Creates a new Parameter\n+         * @param name          the parameter name, used in parsing and serialization\n+         * @param updateable    whether the parameter can be updated with a new value during a mapping update\n+         * @param defaultValue  the default value for the parameter, used if unspecified in mappings\n+         * @param parser        a function that converts an object to a parameter value\n+         * @param initializer   a function that reads a parameter value from an existing mapper\n+         */\n+        public Parameter(String name, boolean updateable, T defaultValue,\n+                         BiFunction<String, Object, T> parser, Function<FieldMapper, T> initializer) {\n+            this.name = name;\n+            this.defaultValue = defaultValue;\n+            this.value = defaultValue;\n+            this.parser = parser;\n+            this.initializer = initializer;\n+            this.updateable = updateable;\n+        }\n+\n+        /**\n+         * Returns the current value of the parameter\n+         */\n+        public T getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Sets the current value of the parameter\n+         */\n+        public void setValue(T value) {\n+            this.value = value;\n+        }\n+\n+        /**\n+         * Allows the parameter to accept a {@code null} value\n+         */\n+        public Parameter<T> acceptsNull() {\n+            this.acceptsNull = true;\n+            return this;\n+        }\n+\n+        private void init(FieldMapper toInit) {\n+            this.value = initializer.apply(toInit);\n+        }\n+\n+        private void parse(String field, Object in) {\n+            this.value = parser.apply(field, in);\n+        }\n+\n+        private void merge(FieldMapper toMerge, Conflicts conflicts) {\n+            T value = initializer.apply(toMerge);\n+            if (updateable == false && Objects.equals(this.value, value) == false) {\n+                conflicts.addConflict(name, this.value.toString(), value.toString());\n+            } else {\n+                this.value = value;\n+            }\n+        }\n+\n+        private void toXContent(XContentBuilder builder, boolean includeDefaults) throws IOException {\n+            if (includeDefaults || (Objects.equals(defaultValue, value) == false)) {\n+                builder.field(name, value);\n+            }\n+        }\n+\n+        /**\n+         * Defines a parameter that takes the values {@code true} or {@code false}\n+         * @param name          the parameter name\n+         * @param updateable    whether the parameter can be changed by a mapping update\n+         * @param initializer   a function that reads the parameter value from an existing mapper\n+         * @param defaultValue  the default value, to be used if the parameter is undefined in a mapping\n+         */\n+        public static Parameter<Boolean> boolParam(String name, boolean updateable,\n+                                                   Function<FieldMapper, Boolean> initializer, boolean defaultValue) {\n+            return new Parameter<>(name, updateable, defaultValue, (n, o) -> XContentMapValues.nodeBooleanValue(o), initializer);\n+        }\n+\n+        /**\n+         * Defines a parameter that takes a float value\n+         * @param name          the parameter name\n+         * @param updateable    whether the parameter can be changed by a mapping update\n+         * @param initializer   a function that reads the parameter value from an existing mapper\n+         * @param defaultValue  the default value, to be used if the parameter is undefined in a mapping\n+         */\n+        public static Parameter<Float> floatParam(String name, boolean updateable,\n+                                                  Function<FieldMapper, Float> initializer, float defaultValue) {\n+            return new Parameter<>(name, updateable, defaultValue, (n, o) -> XContentMapValues.nodeFloatValue(o), initializer);\n+        }\n+\n+        /**\n+         * Defines a parameter that takes a string value\n+         * @param name          the parameter name\n+         * @param updateable    whether the parameter can be changed by a mapping update\n+         * @param initializer   a function that reads the parameter value from an existing mapper\n+         * @param defaultValue  the default value, to be used if the parameter is undefined in a mapping\n+         */\n+        public static Parameter<String> stringParam(String name, boolean updateable,\n+                                                    Function<FieldMapper, String> initializer, String defaultValue) {\n+            return new Parameter<>(name, updateable, defaultValue,\n+                (n, o) -> XContentMapValues.nodeStringValue(o), initializer);\n+        }\n+    }\n+\n+    private static final class Conflicts {\n+\n+        private final String mapperName;\n+        private final List<String> conflicts = new ArrayList<>();\n+\n+        Conflicts(String mapperName) {\n+            this.mapperName = mapperName;\n+        }\n+\n+        void addConflict(String parameter, String existing, String toMerge) {\n+            conflicts.add(\"Cannot update parameter [\" + parameter + \"] from [\" + existing + \"] to [\" + toMerge + \"]\");\n+        }\n+\n+        void check() {\n+            if (conflicts.isEmpty()) {\n+                return;\n+            }\n+            String message = \"Mapper for [\" + mapperName + \"] conflicts with existing mapper:\\n\\t\"\n+                + String.join(\"\\n\\t\", conflicts);\n+            throw new IllegalArgumentException(message);\n+        }\n+\n+    }\n+\n+    /**\n+     * A Builder for a ParametrizedFieldMapper\n+     */\n+    public abstract static class Builder extends Mapper.Builder<Builder> {\n+\n+        protected final MultiFields.Builder multiFieldsBuilder = new MultiFields.Builder();\n+        protected final CopyTo.Builder copyTo = new CopyTo.Builder();\n+\n+        /**\n+         * Creates a new Builder with a field name\n+         */\n+        protected Builder(String name) {\n+            super(name);\n+        }\n+\n+        /**\n+         * Initialises all parameters from an existing mapper\n+         */\n+        public Builder init(FieldMapper initializer) {\n+            for (Parameter<?> param : getParameters()) {\n+                param.init(initializer);\n+            }\n+            for (Mapper subField : initializer.multiFields) {\n+                multiFieldsBuilder.add(subField);\n+            }\n+            return this;\n+        }\n+\n+        private void merge(FieldMapper in, Conflicts conflicts) {\n+            for (Parameter<?> param : getParameters()) {\n+                param.merge(in, conflicts);\n+            }\n+            for (Mapper newSubField : in.multiFields) {\n+                multiFieldsBuilder.update(newSubField, parentPath(newSubField.name()));\n+            }\n+            this.copyTo.reset(in.copyTo);\n+        }\n+\n+        /**\n+         * @return the list of parameters defined for this mapper\n+         */\n+        protected abstract List<Parameter<?>> getParameters();\n+\n+        @Override\n+        public abstract ParametrizedFieldMapper build(BuilderContext context);\n+\n+        /**\n+         * Builds the full name of the field, taking into account parent objects\n+         */\n+        protected String buildFullName(BuilderContext context) {\n+            return context.path().pathAsText(name);\n+        }\n+\n+        private void toXContent(XContentBuilder builder, boolean includeDefaults) throws IOException {\n+            for (Parameter<?> parameter : getParameters()) {\n+                parameter.toXContent(builder, includeDefaults);\n+            }\n+        }\n+\n+        /**\n+         * Parse mapping parameters from a map of mappings\n+         * @param name              the field mapper name\n+         * @param parserContext     the parser context\n+         * @param fieldNode         the root node of the map of mappings for this field\n+         */\n+        public final void parse(String name, TypeParser.ParserContext parserContext, Map<String, Object> fieldNode) {\n+            Map<String, Parameter<?>> paramsMap = new HashMap<>();\n+            for (Parameter<?> param : getParameters()) {\n+                paramsMap.put(param.name, param);\n+            }\n+            String type = (String) fieldNode.remove(\"type\");\n+            for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                final String propName = entry.getKey();\n+                final Object propNode = entry.getValue();\n+                if (Objects.equals(\"fields\", propName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb35edaf9b835bb2ecfa561983b0f2e81d5f008f"}, "originalPosition": 321}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9dd287be2fa6d88e53a6508906ebf6c275321c4", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/b9dd287be2fa6d88e53a6508906ebf6c275321c4", "committedDate": "2020-07-07T13:40:34Z", "message": "Merge branch 'master' into mapper/mergebuilders"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MDg2MjI5", "url": "https://github.com/elastic/elasticsearch/pull/58663#pullrequestreview-444086229", "createdAt": "2020-07-07T17:03:09Z", "commit": {"oid": "b9dd287be2fa6d88e53a6508906ebf6c275321c4"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNzowMzowOVrOGuHrzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNzoxNTo1OVrOGuIJPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxMzU4MQ==", "bodyText": "Its probably worth adding javadoc about how this is different from Objects.toString.", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r451013581", "createdAt": "2020-07-07T17:03:09Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/xcontent/support/XContentMapValues.java", "diffHunk": "@@ -332,6 +332,13 @@ public static String nodeStringValue(Object node, String defaultValue) {\n         return node.toString();\n     }\n \n+    public static String nodeStringValue(Object node) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9dd287be2fa6d88e53a6508906ebf6c275321c4"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNDI0Mw==", "bodyText": "Do we plan to eventually move meta over to the FieldMapper?", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r451014243", "createdAt": "2020-07-07T17:04:16Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/BinaryFieldMapper.java", "diffHunk": "@@ -48,42 +46,39 @@\n import java.util.List;\n import java.util.Map;\n \n-import static org.elasticsearch.index.mapper.TypeParsers.parseField;\n-\n-public class BinaryFieldMapper extends FieldMapper {\n+public class BinaryFieldMapper extends ParametrizedFieldMapper {\n \n     public static final String CONTENT_TYPE = \"binary\";\n \n-    public static class Defaults {\n-        public static final FieldType FIELD_TYPE = new FieldType();\n-\n-        static {\n-            FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n-            FIELD_TYPE.setOmitNorms(true);\n-            FIELD_TYPE.freeze();\n-        }\n+    private static BinaryFieldMapper toType(FieldMapper in) {\n+        return (BinaryFieldMapper) in;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        private final Parameter<Boolean> stored = Parameter.boolParam(\"store\", false, m -> toType(m).stored, false);\n+        private final Parameter<Boolean> hasDocValues = Parameter.boolParam(\"doc_values\", false, m -> toType(m).hasDocValues,  false);\n+        private final Parameter<Map<String, String>> meta\n+            = new Parameter<>(\"meta\", true, Collections.emptyMap(), TypeParsers::parseMeta, m -> m.fieldType().meta());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9dd287be2fa6d88e53a6508906ebf6c275321c4"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNTYwNw==", "bodyText": "You made a boolean hasDocValues on BinaryFieldMapper for this. Is it worth making one here too?", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r451015607", "createdAt": "2020-07-07T17:06:37Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/BooleanFieldMapper.java", "diffHunk": "@@ -71,25 +68,37 @@\n         public static final BytesRef FALSE = new BytesRef(\"F\");\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    private static BooleanFieldMapper toType(FieldMapper in) {\n+        return (BooleanFieldMapper) in;\n+    }\n+\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n \n-        private Boolean nullValue;\n+        private final Parameter<Float> boost = Parameter.floatParam(\"boost\", true, m -> m.fieldType().boost(), 1.0f);\n+        private final Parameter<Boolean> docValues\n+            = Parameter.boolParam(\"doc_values\", false, m -> m.fieldType().hasDocValues(),  true);\n+        private final Parameter<Boolean> indexed\n+            = Parameter.boolParam(\"index\", false, m -> m.fieldType().isSearchable(), true);\n+        private final Parameter<Boolean> nullValue\n+            = new Parameter<>(\"null_value\", false, null, (n, o) -> XContentMapValues.nodeBooleanValue(o), m -> toType(m).nullValue);\n+        private final Parameter<Boolean> stored = Parameter.boolParam(\"store\", false, m -> toType(m).stored, false);\n+        private final Parameter<Map<String, String>> meta\n+            = new Parameter<>(\"meta\", true, Collections.emptyMap(), TypeParsers::parseMeta, m -> m.fieldType().meta());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4Nzk1OA=="}, "originalCommit": {"oid": "bb35edaf9b835bb2ecfa561983b0f2e81d5f008f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxOTcwMw==", "bodyText": "It was odd that we were using Field to get stored fields but doc values. Field just does a bunch of stuff.", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r451019703", "createdAt": "2020-07-07T17:13:49Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/BooleanFieldMapper.java", "diffHunk": "@@ -250,8 +249,11 @@ protected void parseCreateField(ParseContext context) throws IOException {\n         if (value == null) {\n             return;\n         }\n-        if (fieldType().isSearchable() || fieldType.stored()) {\n-            context.doc().add(new Field(fieldType().name(), value ? \"T\" : \"F\", fieldType));\n+        if (fieldType().isSearchable()) {\n+            context.doc().add(new Field(fieldType().name(), value ? \"T\" : \"F\", Defaults.FIELD_TYPE));\n+        }\n+        if (stored) {\n+            context.doc().add(new StoredField(fieldType().name(), value ? \"T\" : \"F\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4NTYzMg=="}, "originalCommit": {"oid": "bb35edaf9b835bb2ecfa561983b0f2e81d5f008f"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAyMTExNg==", "bodyText": "Every field does support multi fields and copy_to right now. I'm happy to juggle things for runtime fields in a follow up.", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r451021116", "createdAt": "2020-07-07T17:15:59Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/ParametrizedFieldMapper.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+/**\n+ * Defines how a particular field should be indexed and searched\n+ *\n+ * Configuration {@link Parameter}s for the mapper are defined on a {@link Builder} subclass,\n+ * and returned by its {@link Builder#getParameters()} method.  Merging, serialization\n+ * and parsing of the mapper are all mediated through this set of parameters.\n+ *\n+ * Subclasses should implement a {@link Builder} that is returned from the\n+ * {@link #getMergeBuilder()} method, initialised with the existing builder.\n+ */\n+public abstract class ParametrizedFieldMapper extends FieldMapper {\n+\n+    /**\n+     * Creates a new ParametrizedFieldMapper\n+     */\n+    protected ParametrizedFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, new FieldType(), mappedFieldType, multiFields, copyTo);\n+    }\n+\n+    /**\n+     * Returns a {@link Builder} to be used for merging and serialization\n+     *\n+     * Implement as follows:\n+     * {@code return new MyBuilder(simpleName()).init(this); }\n+     */\n+    public abstract ParametrizedFieldMapper.Builder getMergeBuilder();\n+\n+    @Override\n+    public final ParametrizedFieldMapper merge(Mapper mergeWith) {\n+\n+        if (mergeWith instanceof FieldMapper == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + mergeWith.getClass().getSimpleName() + \"]\");\n+        }\n+        if (Objects.equals(this.getClass(), mergeWith.getClass()) == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + ((FieldMapper) mergeWith).contentType() + \"]\");\n+        }\n+\n+        ParametrizedFieldMapper.Builder builder = getMergeBuilder();\n+        Conflicts conflicts = new Conflicts(name());\n+        builder.merge((FieldMapper) mergeWith, conflicts);\n+        conflicts.check();\n+        return builder.build(new BuilderContext(Settings.EMPTY, parentPath(name())));\n+    }\n+\n+    private static ContentPath parentPath(String name) {\n+        int endPos = name.lastIndexOf(\".\");\n+        if (endPos == -1) {\n+            return new ContentPath(0);\n+        }\n+        return new ContentPath(name.substring(0, endPos));\n+    }\n+\n+    @Override\n+    protected final void mergeOptions(FieldMapper other, List<String> conflicts) {\n+        // TODO remove when everything is parametrized\n+    }\n+\n+    @Override\n+    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject(simpleName());\n+        builder.field(\"type\", contentType());\n+        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n+        getMergeBuilder().toXContent(builder, includeDefaults);\n+        multiFields.toXContent(builder, params);\n+        copyTo.toXContent(builder, params);\n+        return builder.endObject();\n+    }\n+\n+    /**\n+     * A configurable parameter for a field mapper\n+     * @param <T> the type of the value the parameter holds\n+     */\n+    public static final class Parameter<T> {\n+\n+        public final String name;\n+        private final T defaultValue;\n+        private final BiFunction<String, Object, T> parser;\n+        private final Function<FieldMapper, T> initializer;\n+        private final boolean updateable;\n+        private boolean acceptsNull = false;\n+        private T value;\n+\n+        /**\n+         * Creates a new Parameter\n+         * @param name          the parameter name, used in parsing and serialization\n+         * @param updateable    whether the parameter can be updated with a new value during a mapping update\n+         * @param defaultValue  the default value for the parameter, used if unspecified in mappings\n+         * @param parser        a function that converts an object to a parameter value\n+         * @param initializer   a function that reads a parameter value from an existing mapper\n+         */\n+        public Parameter(String name, boolean updateable, T defaultValue,\n+                         BiFunction<String, Object, T> parser, Function<FieldMapper, T> initializer) {\n+            this.name = name;\n+            this.defaultValue = defaultValue;\n+            this.value = defaultValue;\n+            this.parser = parser;\n+            this.initializer = initializer;\n+            this.updateable = updateable;\n+        }\n+\n+        /**\n+         * Returns the current value of the parameter\n+         */\n+        public T getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Sets the current value of the parameter\n+         */\n+        public void setValue(T value) {\n+            this.value = value;\n+        }\n+\n+        /**\n+         * Allows the parameter to accept a {@code null} value\n+         */\n+        public Parameter<T> acceptsNull() {\n+            this.acceptsNull = true;\n+            return this;\n+        }\n+\n+        private void init(FieldMapper toInit) {\n+            this.value = initializer.apply(toInit);\n+        }\n+\n+        private void parse(String field, Object in) {\n+            this.value = parser.apply(field, in);\n+        }\n+\n+        private void merge(FieldMapper toMerge, Conflicts conflicts) {\n+            T value = initializer.apply(toMerge);\n+            if (updateable == false && Objects.equals(this.value, value) == false) {\n+                conflicts.addConflict(name, this.value.toString(), value.toString());\n+            } else {\n+                this.value = value;\n+            }\n+        }\n+\n+        private void toXContent(XContentBuilder builder, boolean includeDefaults) throws IOException {\n+            if (includeDefaults || (Objects.equals(defaultValue, value) == false)) {\n+                builder.field(name, value);\n+            }\n+        }\n+\n+        /**\n+         * Defines a parameter that takes the values {@code true} or {@code false}\n+         * @param name          the parameter name\n+         * @param updateable    whether the parameter can be changed by a mapping update\n+         * @param initializer   a function that reads the parameter value from an existing mapper\n+         * @param defaultValue  the default value, to be used if the parameter is undefined in a mapping\n+         */\n+        public static Parameter<Boolean> boolParam(String name, boolean updateable,\n+                                                   Function<FieldMapper, Boolean> initializer, boolean defaultValue) {\n+            return new Parameter<>(name, updateable, defaultValue, (n, o) -> XContentMapValues.nodeBooleanValue(o), initializer);\n+        }\n+\n+        /**\n+         * Defines a parameter that takes a float value\n+         * @param name          the parameter name\n+         * @param updateable    whether the parameter can be changed by a mapping update\n+         * @param initializer   a function that reads the parameter value from an existing mapper\n+         * @param defaultValue  the default value, to be used if the parameter is undefined in a mapping\n+         */\n+        public static Parameter<Float> floatParam(String name, boolean updateable,\n+                                                  Function<FieldMapper, Float> initializer, float defaultValue) {\n+            return new Parameter<>(name, updateable, defaultValue, (n, o) -> XContentMapValues.nodeFloatValue(o), initializer);\n+        }\n+\n+        /**\n+         * Defines a parameter that takes a string value\n+         * @param name          the parameter name\n+         * @param updateable    whether the parameter can be changed by a mapping update\n+         * @param initializer   a function that reads the parameter value from an existing mapper\n+         * @param defaultValue  the default value, to be used if the parameter is undefined in a mapping\n+         */\n+        public static Parameter<String> stringParam(String name, boolean updateable,\n+                                                    Function<FieldMapper, String> initializer, String defaultValue) {\n+            return new Parameter<>(name, updateable, defaultValue,\n+                (n, o) -> XContentMapValues.nodeStringValue(o), initializer);\n+        }\n+    }\n+\n+    private static final class Conflicts {\n+\n+        private final String mapperName;\n+        private final List<String> conflicts = new ArrayList<>();\n+\n+        Conflicts(String mapperName) {\n+            this.mapperName = mapperName;\n+        }\n+\n+        void addConflict(String parameter, String existing, String toMerge) {\n+            conflicts.add(\"Cannot update parameter [\" + parameter + \"] from [\" + existing + \"] to [\" + toMerge + \"]\");\n+        }\n+\n+        void check() {\n+            if (conflicts.isEmpty()) {\n+                return;\n+            }\n+            String message = \"Mapper for [\" + mapperName + \"] conflicts with existing mapper:\\n\\t\"\n+                + String.join(\"\\n\\t\", conflicts);\n+            throw new IllegalArgumentException(message);\n+        }\n+\n+    }\n+\n+    /**\n+     * A Builder for a ParametrizedFieldMapper\n+     */\n+    public abstract static class Builder extends Mapper.Builder<Builder> {\n+\n+        protected final MultiFields.Builder multiFieldsBuilder = new MultiFields.Builder();\n+        protected final CopyTo.Builder copyTo = new CopyTo.Builder();\n+\n+        /**\n+         * Creates a new Builder with a field name\n+         */\n+        protected Builder(String name) {\n+            super(name);\n+        }\n+\n+        /**\n+         * Initialises all parameters from an existing mapper\n+         */\n+        public Builder init(FieldMapper initializer) {\n+            for (Parameter<?> param : getParameters()) {\n+                param.init(initializer);\n+            }\n+            for (Mapper subField : initializer.multiFields) {\n+                multiFieldsBuilder.add(subField);\n+            }\n+            return this;\n+        }\n+\n+        private void merge(FieldMapper in, Conflicts conflicts) {\n+            for (Parameter<?> param : getParameters()) {\n+                param.merge(in, conflicts);\n+            }\n+            for (Mapper newSubField : in.multiFields) {\n+                multiFieldsBuilder.update(newSubField, parentPath(newSubField.name()));\n+            }\n+            this.copyTo.reset(in.copyTo);\n+        }\n+\n+        /**\n+         * @return the list of parameters defined for this mapper\n+         */\n+        protected abstract List<Parameter<?>> getParameters();\n+\n+        @Override\n+        public abstract ParametrizedFieldMapper build(BuilderContext context);\n+\n+        /**\n+         * Builds the full name of the field, taking into account parent objects\n+         */\n+        protected String buildFullName(BuilderContext context) {\n+            return context.path().pathAsText(name);\n+        }\n+\n+        private void toXContent(XContentBuilder builder, boolean includeDefaults) throws IOException {\n+            for (Parameter<?> parameter : getParameters()) {\n+                parameter.toXContent(builder, includeDefaults);\n+            }\n+        }\n+\n+        /**\n+         * Parse mapping parameters from a map of mappings\n+         * @param name              the field mapper name\n+         * @param parserContext     the parser context\n+         * @param fieldNode         the root node of the map of mappings for this field\n+         */\n+        public final void parse(String name, TypeParser.ParserContext parserContext, Map<String, Object> fieldNode) {\n+            Map<String, Parameter<?>> paramsMap = new HashMap<>();\n+            for (Parameter<?> param : getParameters()) {\n+                paramsMap.put(param.name, param);\n+            }\n+            String type = (String) fieldNode.remove(\"type\");\n+            for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                final String propName = entry.getKey();\n+                final Object propNode = entry.getValue();\n+                if (Objects.equals(\"fields\", propName)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5MDIyOA=="}, "originalCommit": {"oid": "bb35edaf9b835bb2ecfa561983b0f2e81d5f008f"}, "originalPosition": 321}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f1853f6dfbb45168d12e18a0ad994e094a83d0d", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/8f1853f6dfbb45168d12e18a0ad994e094a83d0d", "committedDate": "2020-07-08T08:27:42Z", "message": "Merge remote-tracking branch 'origin/master' into mapper/mergebuilders"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37ea8d669e95c7d3311218779d1f525ccaa224f6", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/37ea8d669e95c7d3311218779d1f525ccaa224f6", "committedDate": "2020-07-08T08:54:33Z", "message": "feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzkzMDQz", "url": "https://github.com/elastic/elasticsearch/pull/58663#pullrequestreview-444793043", "createdAt": "2020-07-08T13:58:39Z", "commit": {"oid": "37ea8d669e95c7d3311218779d1f525ccaa224f6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDM2NTQ1", "url": "https://github.com/elastic/elasticsearch/pull/58663#pullrequestreview-445436545", "createdAt": "2020-07-09T09:18:26Z", "commit": {"oid": "37ea8d669e95c7d3311218779d1f525ccaa224f6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2531, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}