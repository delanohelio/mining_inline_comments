{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4ODI5MjE0", "number": 64900, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMDowNDo0OVrOE6vn2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxODo1MTo0MlrOE7Mezg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMDMzMTEyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/ClusterModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMDowNDo0OVrOH1_9fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxOTowODo1MFrOH2th6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM4NDUwOA==", "bodyText": "Exposing Build here seems wrong, as does duplicating this check.  I think we should wrap this whole conditional up in a RollupV2.enabled() method that just returns a boolean.", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r526384508", "createdAt": "2020-11-18T20:04:49Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/cluster/ClusterModule.java", "diffHunk": "@@ -143,7 +144,8 @@ public ClusterModule(Settings settings, ClusterService clusterService, List<Clus\n             ComposableIndexTemplateMetadata::readDiffFrom);\n         registerMetadataCustom(entries, DataStreamMetadata.TYPE, DataStreamMetadata::new, DataStreamMetadata::readDiffFrom);\n \n-        if (RollupV2.ROLLUPV2_FEATURE_FLAG_REGISTERED != null && RollupV2.ROLLUPV2_FEATURE_FLAG_REGISTERED) {\n+        if (Build.CURRENT.isSnapshot() ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be90dd3ac889ed116777f997bc76de6d27eefb3c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMTExMw==", "bodyText": "\ud83d\udc4d will clean that up", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r527131113", "createdAt": "2020-11-19T19:08:50Z", "author": {"login": "talevy"}, "path": "server/src/main/java/org/elasticsearch/cluster/ClusterModule.java", "diffHunk": "@@ -143,7 +144,8 @@ public ClusterModule(Settings settings, ClusterService clusterService, List<Clus\n             ComposableIndexTemplateMetadata::readDiffFrom);\n         registerMetadataCustom(entries, DataStreamMetadata.TYPE, DataStreamMetadata::new, DataStreamMetadata::readDiffFrom);\n \n-        if (RollupV2.ROLLUPV2_FEATURE_FLAG_REGISTERED != null && RollupV2.ROLLUPV2_FEATURE_FLAG_REGISTERED) {\n+        if (Build.CURRENT.isSnapshot() ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM4NDUwOA=="}, "originalCommit": {"oid": "be90dd3ac889ed116777f997bc76de6d27eefb3c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMDQxMjExOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/v2/RollupV2Action.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMDoyNTowMlrOH2AxJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDoyMDozNVrOH2wFZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5NzczNA==", "bodyText": "asking more for my own knowledge than anything else - is this functionally different than return rollupConfig.hashCode();?", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r526397734", "createdAt": "2020-11-18T20:25:02Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/v2/RollupV2Action.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.rollup.v2;\n+\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestBuilder;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.client.ElasticsearchClient;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskId;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class RollupV2Action extends ActionType<RollupV2Action.Response> {\n+\n+    public static final RollupV2Action INSTANCE = new RollupV2Action();\n+    public static final String NAME = \"cluster:admin/xpack/rollupV2\";\n+\n+    private RollupV2Action() {\n+        super(NAME, RollupV2Action.Response::new);\n+    }\n+\n+    public static class Request extends ActionRequest implements ToXContentObject {\n+        private RollupV2Config rollupConfig;\n+\n+        public Request(RollupV2Config rollupConfig) {\n+            this.rollupConfig = rollupConfig;\n+        }\n+\n+        public Request() {}\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            rollupConfig = new RollupV2Config(in);\n+        }\n+\n+        @Override\n+        public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {\n+            return new RollupV2Task(id, type, action, parentTaskId, rollupConfig, headers);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            rollupConfig.writeTo(out);\n+        }\n+\n+        public RollupV2Config getRollupConfig() {\n+            return rollupConfig;\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            rollupConfig.toXContent(builder, params);\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(rollupConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be90dd3ac889ed116777f997bc76de6d27eefb3c"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMTkyOQ==", "bodyText": "functionally, no. I just like the consistency of calling Objects#hash, more-so when there are multiple instance variables to hash. For this reason, I chose to go with calling that method from Objects.", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r527131929", "createdAt": "2020-11-19T19:10:07Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/v2/RollupV2Action.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.rollup.v2;\n+\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestBuilder;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.client.ElasticsearchClient;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskId;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class RollupV2Action extends ActionType<RollupV2Action.Response> {\n+\n+    public static final RollupV2Action INSTANCE = new RollupV2Action();\n+    public static final String NAME = \"cluster:admin/xpack/rollupV2\";\n+\n+    private RollupV2Action() {\n+        super(NAME, RollupV2Action.Response::new);\n+    }\n+\n+    public static class Request extends ActionRequest implements ToXContentObject {\n+        private RollupV2Config rollupConfig;\n+\n+        public Request(RollupV2Config rollupConfig) {\n+            this.rollupConfig = rollupConfig;\n+        }\n+\n+        public Request() {}\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            rollupConfig = new RollupV2Config(in);\n+        }\n+\n+        @Override\n+        public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {\n+            return new RollupV2Task(id, type, action, parentTaskId, rollupConfig, headers);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            rollupConfig.writeTo(out);\n+        }\n+\n+        public RollupV2Config getRollupConfig() {\n+            return rollupConfig;\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            rollupConfig.toXContent(builder, params);\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(rollupConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5NzczNA=="}, "originalCommit": {"oid": "be90dd3ac889ed116777f997bc76de6d27eefb3c"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMjM2OA==", "bodyText": "Also, not that rollupConfig can be null, but if it could, then calling Objects#hash is safer w.r.t. NPE", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r527132368", "createdAt": "2020-11-19T19:10:51Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/v2/RollupV2Action.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.rollup.v2;\n+\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestBuilder;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.client.ElasticsearchClient;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskId;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class RollupV2Action extends ActionType<RollupV2Action.Response> {\n+\n+    public static final RollupV2Action INSTANCE = new RollupV2Action();\n+    public static final String NAME = \"cluster:admin/xpack/rollupV2\";\n+\n+    private RollupV2Action() {\n+        super(NAME, RollupV2Action.Response::new);\n+    }\n+\n+    public static class Request extends ActionRequest implements ToXContentObject {\n+        private RollupV2Config rollupConfig;\n+\n+        public Request(RollupV2Config rollupConfig) {\n+            this.rollupConfig = rollupConfig;\n+        }\n+\n+        public Request() {}\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            rollupConfig = new RollupV2Config(in);\n+        }\n+\n+        @Override\n+        public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {\n+            return new RollupV2Task(id, type, action, parentTaskId, rollupConfig, headers);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            rollupConfig.writeTo(out);\n+        }\n+\n+        public RollupV2Config getRollupConfig() {\n+            return rollupConfig;\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            rollupConfig.toXContent(builder, params);\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(rollupConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5NzczNA=="}, "originalCommit": {"oid": "be90dd3ac889ed116777f997bc76de6d27eefb3c"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE3Mjk2Ng==", "bodyText": "Cool, makes sense.", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r527172966", "createdAt": "2020-11-19T20:20:35Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/v2/RollupV2Action.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.rollup.v2;\n+\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestBuilder;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.client.ElasticsearchClient;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskId;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class RollupV2Action extends ActionType<RollupV2Action.Response> {\n+\n+    public static final RollupV2Action INSTANCE = new RollupV2Action();\n+    public static final String NAME = \"cluster:admin/xpack/rollupV2\";\n+\n+    private RollupV2Action() {\n+        super(NAME, RollupV2Action.Response::new);\n+    }\n+\n+    public static class Request extends ActionRequest implements ToXContentObject {\n+        private RollupV2Config rollupConfig;\n+\n+        public Request(RollupV2Config rollupConfig) {\n+            this.rollupConfig = rollupConfig;\n+        }\n+\n+        public Request() {}\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            rollupConfig = new RollupV2Config(in);\n+        }\n+\n+        @Override\n+        public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {\n+            return new RollupV2Task(id, type, action, parentTaskId, rollupConfig, headers);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            rollupConfig.writeTo(out);\n+        }\n+\n+        public RollupV2Config getRollupConfig() {\n+            return rollupConfig;\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            rollupConfig.toXContent(builder, params);\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(rollupConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5NzczNA=="}, "originalCommit": {"oid": "be90dd3ac889ed116777f997bc76de6d27eefb3c"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMDQxNzA1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/v2/RollupV2Action.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMDoyNjoyN1rOH2A0Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDoyMToxMlrOH2wGuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5ODU2Ng==", "bodyText": "Shouldn't this cast to RollupV2Action here?", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r526398566", "createdAt": "2020-11-18T20:26:27Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/v2/RollupV2Action.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.rollup.v2;\n+\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestBuilder;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.client.ElasticsearchClient;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskId;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class RollupV2Action extends ActionType<RollupV2Action.Response> {\n+\n+    public static final RollupV2Action INSTANCE = new RollupV2Action();\n+    public static final String NAME = \"cluster:admin/xpack/rollupV2\";\n+\n+    private RollupV2Action() {\n+        super(NAME, RollupV2Action.Response::new);\n+    }\n+\n+    public static class Request extends ActionRequest implements ToXContentObject {\n+        private RollupV2Config rollupConfig;\n+\n+        public Request(RollupV2Config rollupConfig) {\n+            this.rollupConfig = rollupConfig;\n+        }\n+\n+        public Request() {}\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            rollupConfig = new RollupV2Config(in);\n+        }\n+\n+        @Override\n+        public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {\n+            return new RollupV2Task(id, type, action, parentTaskId, rollupConfig, headers);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            rollupConfig.writeTo(out);\n+        }\n+\n+        public RollupV2Config getRollupConfig() {\n+            return rollupConfig;\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            rollupConfig.toXContent(builder, params);\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(rollupConfig);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            Request other = (Request) obj;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be90dd3ac889ed116777f997bc76de6d27eefb3c"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzODU0NQ==", "bodyText": "this is a subclass of RollupV2Action \u2014 RollupV2Action.Request", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r527138545", "createdAt": "2020-11-19T19:21:05Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/v2/RollupV2Action.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.rollup.v2;\n+\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestBuilder;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.client.ElasticsearchClient;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskId;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class RollupV2Action extends ActionType<RollupV2Action.Response> {\n+\n+    public static final RollupV2Action INSTANCE = new RollupV2Action();\n+    public static final String NAME = \"cluster:admin/xpack/rollupV2\";\n+\n+    private RollupV2Action() {\n+        super(NAME, RollupV2Action.Response::new);\n+    }\n+\n+    public static class Request extends ActionRequest implements ToXContentObject {\n+        private RollupV2Config rollupConfig;\n+\n+        public Request(RollupV2Config rollupConfig) {\n+            this.rollupConfig = rollupConfig;\n+        }\n+\n+        public Request() {}\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            rollupConfig = new RollupV2Config(in);\n+        }\n+\n+        @Override\n+        public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {\n+            return new RollupV2Task(id, type, action, parentTaskId, rollupConfig, headers);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            rollupConfig.writeTo(out);\n+        }\n+\n+        public RollupV2Config getRollupConfig() {\n+            return rollupConfig;\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            rollupConfig.toXContent(builder, params);\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(rollupConfig);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            Request other = (Request) obj;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5ODU2Ng=="}, "originalCommit": {"oid": "be90dd3ac889ed116777f997bc76de6d27eefb3c"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE3MzMwNQ==", "bodyText": "ah, that makes more sense.  Sorry for the noise.", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r527173305", "createdAt": "2020-11-19T20:21:12Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/v2/RollupV2Action.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.rollup.v2;\n+\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestBuilder;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.client.ElasticsearchClient;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskId;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class RollupV2Action extends ActionType<RollupV2Action.Response> {\n+\n+    public static final RollupV2Action INSTANCE = new RollupV2Action();\n+    public static final String NAME = \"cluster:admin/xpack/rollupV2\";\n+\n+    private RollupV2Action() {\n+        super(NAME, RollupV2Action.Response::new);\n+    }\n+\n+    public static class Request extends ActionRequest implements ToXContentObject {\n+        private RollupV2Config rollupConfig;\n+\n+        public Request(RollupV2Config rollupConfig) {\n+            this.rollupConfig = rollupConfig;\n+        }\n+\n+        public Request() {}\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            rollupConfig = new RollupV2Config(in);\n+        }\n+\n+        @Override\n+        public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {\n+            return new RollupV2Task(id, type, action, parentTaskId, rollupConfig, headers);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            rollupConfig.writeTo(out);\n+        }\n+\n+        public RollupV2Config getRollupConfig() {\n+            return rollupConfig;\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            rollupConfig.toXContent(builder, params);\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(rollupConfig);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            Request other = (Request) obj;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5ODU2Ng=="}, "originalCommit": {"oid": "be90dd3ac889ed116777f997bc76de6d27eefb3c"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTA1OTM0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/rollup/src/main/java/org/elasticsearch/xpack/rollup/v2/TransportRollupV2Action.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxODo1MTo0MlrOH2s6Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxOToyMTozNFrOH2uADQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEyMDk0Ng==", "bodyText": "We're bleeding implementation details here a bit.  I feel like we should just create an empty RollupGroup and then use the RollupGroup#add(indexName, dateInterval, ZoneId) method you used in the other branch of this conditional.  Seems weird to me that this method decides the concrete map implementation the RollupGroup is using, for example.", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r527120946", "createdAt": "2020-11-19T18:51:42Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/rollup/src/main/java/org/elasticsearch/xpack/rollup/v2/TransportRollupV2Action.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.rollup.v2;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateUpdateTask;\n+import org.elasticsearch.cluster.metadata.DataStream;\n+import org.elasticsearch.cluster.metadata.IndexAbstraction;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.metadata.RollupGroup;\n+import org.elasticsearch.cluster.metadata.RollupMetadata;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.time.WriteableZoneId;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramInterval;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.indexing.IndexerState;\n+import org.elasticsearch.xpack.core.rollup.job.DateHistogramGroupConfig;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupV2Action;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupV2Task;\n+import org.elasticsearch.xpack.rollup.Rollup;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+// TODO(talevy): enforce that rollup-indices of indices backing a datastream must be hidden\n+public class TransportRollupV2Action extends HandledTransportAction<RollupV2Action.Request, RollupV2Action.Response> {\n+    private final Client client;\n+    private final ThreadPool threadPool;\n+    private final ClusterService clusterService;\n+\n+    @Inject\n+    public TransportRollupV2Action(\n+            final Client client,\n+            final ClusterService clusterService,\n+            final ThreadPool threadPool,\n+            final TransportService transportService,\n+            final ActionFilters actionFilters\n+    ) {\n+        super(RollupV2Action.NAME, transportService, actionFilters, RollupV2Action.Request::new);\n+        this.client = client;\n+        this.threadPool = threadPool;\n+        this.clusterService = clusterService;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, RollupV2Action.Request request, ActionListener<RollupV2Action.Response> listener) {\n+        RollupV2Task rollupV2Task = (RollupV2Task) task;\n+        RollupV2Indexer indexer = new RollupV2Indexer(client, threadPool, Rollup.TASK_THREAD_POOL_NAME,\n+            rollupV2Task.config(), rollupV2Task.headers(), ActionListener.wrap(c -> {\n+            // update Rollup metadata to include this index\n+            clusterService.submitStateUpdateTask(\"update-rollup-metadata\", new ClusterStateUpdateTask() {\n+\n+                @Override\n+                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n+                    listener.onResponse(new RollupV2Action.Response(true));\n+                }\n+\n+                @Override\n+                public ClusterState execute(ClusterState currentState) throws Exception {\n+                    String rollupIndexName = rollupV2Task.config().getRollupIndex();\n+                    IndexMetadata rollupIndexMetadata = currentState.getMetadata().index(rollupIndexName);\n+                    Index rollupIndex = rollupIndexMetadata.getIndex();\n+                    // TODO(talevy): find better spot to get the original index name\n+                    // extract created rollup index original index name to be used as metadata key\n+                    String originalIndexName = rollupV2Task.config().getSourceIndex();\n+                    Map<String, String> idxMetadata = currentState.getMetadata().index(originalIndexName)\n+                        .getCustomData(RollupMetadata.TYPE);\n+                    String rollupGroupKeyName = (idxMetadata == null) ?\n+                        originalIndexName : idxMetadata.get(RollupMetadata.SOURCE_INDEX_NAME_META_FIELD);\n+                    Map<String, String> rollupIndexRollupMetadata = new HashMap<>();\n+                    rollupIndexRollupMetadata.put(RollupMetadata.SOURCE_INDEX_NAME_META_FIELD, rollupGroupKeyName);\n+                    final RollupMetadata rollupMetadata = currentState.metadata().custom(RollupMetadata.TYPE);\n+                    final Map<String, RollupGroup> rollupGroups;\n+                    if (rollupMetadata == null) {\n+                        rollupGroups = new HashMap<>();\n+                    } else {\n+                        rollupGroups = new HashMap<>(rollupMetadata.rollupGroups());\n+                    }\n+                    DateHistogramGroupConfig dateConfig = rollupV2Task.config().getGroupConfig().getDateHistogram();\n+                    WriteableZoneId rollupDateZoneId = WriteableZoneId.of(dateConfig.getTimeZone());\n+                    if (rollupGroups.containsKey(rollupGroupKeyName)) {\n+                        RollupGroup group = rollupGroups.get(rollupGroupKeyName);\n+                        group.add(rollupIndexName, dateConfig.getInterval(), rollupDateZoneId);\n+                    } else {\n+                        List<String> indices = new ArrayList<>();\n+                        Map<String, DateHistogramInterval> intervals = new HashMap<>();\n+                        Map<String, WriteableZoneId> timezones = new HashMap<>();\n+                        indices.add(rollupIndexName);\n+                        intervals.put(rollupIndexName, dateConfig.getInterval());\n+                        timezones.put(rollupIndexName, rollupDateZoneId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3e115eda1859d25f5aa3fd6701b05a1045c61c"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzODgyOQ==", "bodyText": "good point. I'll work to clean this up", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r527138829", "createdAt": "2020-11-19T19:21:34Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/rollup/src/main/java/org/elasticsearch/xpack/rollup/v2/TransportRollupV2Action.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.rollup.v2;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateUpdateTask;\n+import org.elasticsearch.cluster.metadata.DataStream;\n+import org.elasticsearch.cluster.metadata.IndexAbstraction;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.metadata.RollupGroup;\n+import org.elasticsearch.cluster.metadata.RollupMetadata;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.time.WriteableZoneId;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramInterval;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.indexing.IndexerState;\n+import org.elasticsearch.xpack.core.rollup.job.DateHistogramGroupConfig;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupV2Action;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupV2Task;\n+import org.elasticsearch.xpack.rollup.Rollup;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+// TODO(talevy): enforce that rollup-indices of indices backing a datastream must be hidden\n+public class TransportRollupV2Action extends HandledTransportAction<RollupV2Action.Request, RollupV2Action.Response> {\n+    private final Client client;\n+    private final ThreadPool threadPool;\n+    private final ClusterService clusterService;\n+\n+    @Inject\n+    public TransportRollupV2Action(\n+            final Client client,\n+            final ClusterService clusterService,\n+            final ThreadPool threadPool,\n+            final TransportService transportService,\n+            final ActionFilters actionFilters\n+    ) {\n+        super(RollupV2Action.NAME, transportService, actionFilters, RollupV2Action.Request::new);\n+        this.client = client;\n+        this.threadPool = threadPool;\n+        this.clusterService = clusterService;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, RollupV2Action.Request request, ActionListener<RollupV2Action.Response> listener) {\n+        RollupV2Task rollupV2Task = (RollupV2Task) task;\n+        RollupV2Indexer indexer = new RollupV2Indexer(client, threadPool, Rollup.TASK_THREAD_POOL_NAME,\n+            rollupV2Task.config(), rollupV2Task.headers(), ActionListener.wrap(c -> {\n+            // update Rollup metadata to include this index\n+            clusterService.submitStateUpdateTask(\"update-rollup-metadata\", new ClusterStateUpdateTask() {\n+\n+                @Override\n+                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n+                    listener.onResponse(new RollupV2Action.Response(true));\n+                }\n+\n+                @Override\n+                public ClusterState execute(ClusterState currentState) throws Exception {\n+                    String rollupIndexName = rollupV2Task.config().getRollupIndex();\n+                    IndexMetadata rollupIndexMetadata = currentState.getMetadata().index(rollupIndexName);\n+                    Index rollupIndex = rollupIndexMetadata.getIndex();\n+                    // TODO(talevy): find better spot to get the original index name\n+                    // extract created rollup index original index name to be used as metadata key\n+                    String originalIndexName = rollupV2Task.config().getSourceIndex();\n+                    Map<String, String> idxMetadata = currentState.getMetadata().index(originalIndexName)\n+                        .getCustomData(RollupMetadata.TYPE);\n+                    String rollupGroupKeyName = (idxMetadata == null) ?\n+                        originalIndexName : idxMetadata.get(RollupMetadata.SOURCE_INDEX_NAME_META_FIELD);\n+                    Map<String, String> rollupIndexRollupMetadata = new HashMap<>();\n+                    rollupIndexRollupMetadata.put(RollupMetadata.SOURCE_INDEX_NAME_META_FIELD, rollupGroupKeyName);\n+                    final RollupMetadata rollupMetadata = currentState.metadata().custom(RollupMetadata.TYPE);\n+                    final Map<String, RollupGroup> rollupGroups;\n+                    if (rollupMetadata == null) {\n+                        rollupGroups = new HashMap<>();\n+                    } else {\n+                        rollupGroups = new HashMap<>(rollupMetadata.rollupGroups());\n+                    }\n+                    DateHistogramGroupConfig dateConfig = rollupV2Task.config().getGroupConfig().getDateHistogram();\n+                    WriteableZoneId rollupDateZoneId = WriteableZoneId.of(dateConfig.getTimeZone());\n+                    if (rollupGroups.containsKey(rollupGroupKeyName)) {\n+                        RollupGroup group = rollupGroups.get(rollupGroupKeyName);\n+                        group.add(rollupIndexName, dateConfig.getInterval(), rollupDateZoneId);\n+                    } else {\n+                        List<String> indices = new ArrayList<>();\n+                        Map<String, DateHistogramInterval> intervals = new HashMap<>();\n+                        Map<String, WriteableZoneId> timezones = new HashMap<>();\n+                        indices.add(rollupIndexName);\n+                        intervals.put(rollupIndexName, dateConfig.getInterval());\n+                        timezones.put(rollupIndexName, rollupDateZoneId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEyMDk0Ng=="}, "originalCommit": {"oid": "1a3e115eda1859d25f5aa3fd6701b05a1045c61c"}, "originalPosition": 105}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3083, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}