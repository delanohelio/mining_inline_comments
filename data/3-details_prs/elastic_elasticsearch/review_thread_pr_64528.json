{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0NzQ0OTc2", "number": 64528, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo1MToxN1rOE8Wd9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNzoyNjowNVrOE_unnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzE4MTMyOnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo1MToxN1rOH4a9WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMDoxNTo0MVrOH44OVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyMzk5Mw==", "bodyText": "We need to make this lenient. Calling get() here will throw an exception if that extra property isn't defined, which it may not be for external users of this plugin. We need to check for its existance first.", "url": "https://github.com/elastic/elasticsearch/pull/64528#discussion_r528923993", "createdAt": "2020-11-23T18:51:17Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java", "diffHunk": "@@ -968,31 +970,58 @@ private void logFileContents(String description, Path from) {\n                 }\n             }\n         } catch (IOException e) {\n-            throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            if (tailLogs) {\n+                throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            }\n+            return;\n         }\n \n-        if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n-            LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n-        }\n-        if (errorsAndWarnings.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n-            errorsAndWarnings.forEach((message, count) -> {\n-                LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                if (count > 1) {\n-                    LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n-                }\n-            });\n+        boolean foundNettyLeaks = false;\n+        for (String logLine : errorsAndWarnings.keySet()) {\n+            if (logLine.contains(\"ResourceLeakDetector]\")) {\n+                tailLogs = true;\n+                foundNettyLeaks = true;\n+                break;\n+            }\n         }\n+        if (tailLogs) {\n+            if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n+                LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n+            }\n+            if (errorsAndWarnings.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n+                errorsAndWarnings.forEach((message, count) -> {\n+                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    if (count > 1) {\n+                        LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n+                    }\n+                });\n+            }\n \n-        ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n+            ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n \n-        if (ring.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n-            ring.forEach(message -> {\n-                if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n-                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                }\n-            });\n+            if (ring.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n+                ring.forEach(message -> {\n+                    if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n+                        LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    }\n+                });\n+            }\n+        }\n+        if (foundNettyLeaks) {\n+            final boolean leakTestsEnabled = (Boolean) project.getExtensions().getExtraProperties().get(\"netty_leak_tests_enabled\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc7c5fe9ea8d9c8b242be0567610b001921d137b"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQwMzQ3Nw==", "bodyText": "Fixed :)", "url": "https://github.com/elastic/elasticsearch/pull/64528#discussion_r529403477", "createdAt": "2020-11-24T10:15:41Z", "author": {"login": "original-brownbear"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java", "diffHunk": "@@ -968,31 +970,58 @@ private void logFileContents(String description, Path from) {\n                 }\n             }\n         } catch (IOException e) {\n-            throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            if (tailLogs) {\n+                throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            }\n+            return;\n         }\n \n-        if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n-            LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n-        }\n-        if (errorsAndWarnings.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n-            errorsAndWarnings.forEach((message, count) -> {\n-                LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                if (count > 1) {\n-                    LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n-                }\n-            });\n+        boolean foundNettyLeaks = false;\n+        for (String logLine : errorsAndWarnings.keySet()) {\n+            if (logLine.contains(\"ResourceLeakDetector]\")) {\n+                tailLogs = true;\n+                foundNettyLeaks = true;\n+                break;\n+            }\n         }\n+        if (tailLogs) {\n+            if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n+                LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n+            }\n+            if (errorsAndWarnings.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n+                errorsAndWarnings.forEach((message, count) -> {\n+                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    if (count > 1) {\n+                        LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n+                    }\n+                });\n+            }\n \n-        ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n+            ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n \n-        if (ring.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n-            ring.forEach(message -> {\n-                if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n-                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                }\n-            });\n+            if (ring.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n+                ring.forEach(message -> {\n+                    if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n+                        LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    }\n+                });\n+            }\n+        }\n+        if (foundNettyLeaks) {\n+            final boolean leakTestsEnabled = (Boolean) project.getExtensions().getExtraProperties().get(\"netty_leak_tests_enabled\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyMzk5Mw=="}, "originalCommit": {"oid": "bc7c5fe9ea8d9c8b242be0567610b001921d137b"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjczOTE0OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java", "isResolved": false, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxOTowMzowNFrOH5RILg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwOTowNjo0OFrOH9Q5Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgxMTUwMg==", "bodyText": "I think we want this to be final boolean leakTestsEnabled = extension.has(\"netty_leak_tests_enabled\") && (Boolean) extension.get(\"netty_leak_tests_enabled\");. For external plugin authors we want this disabled by default.", "url": "https://github.com/elastic/elasticsearch/pull/64528#discussion_r529811502", "createdAt": "2020-11-24T19:03:04Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java", "diffHunk": "@@ -968,31 +971,60 @@ private void logFileContents(String description, Path from) {\n                 }\n             }\n         } catch (IOException e) {\n-            throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            if (tailLogs) {\n+                throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            }\n+            return;\n         }\n \n-        if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n-            LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n-        }\n-        if (errorsAndWarnings.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n-            errorsAndWarnings.forEach((message, count) -> {\n-                LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                if (count > 1) {\n-                    LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n-                }\n-            });\n+        boolean foundNettyLeaks = false;\n+        for (String logLine : errorsAndWarnings.keySet()) {\n+            if (logLine.contains(\"ResourceLeakDetector]\")) {\n+                tailLogs = true;\n+                foundNettyLeaks = true;\n+                break;\n+            }\n         }\n+        if (tailLogs) {\n+            if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n+                LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n+            }\n+            if (errorsAndWarnings.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n+                errorsAndWarnings.forEach((message, count) -> {\n+                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    if (count > 1) {\n+                        LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n+                    }\n+                });\n+            }\n \n-        ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n+            ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n \n-        if (ring.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n-            ring.forEach(message -> {\n-                if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n-                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                }\n-            });\n+            if (ring.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n+                ring.forEach(message -> {\n+                    if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n+                        LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    }\n+                });\n+            }\n+        }\n+        if (foundNettyLeaks) {\n+            final ExtraPropertiesExtension extension = project.getExtensions().getExtraProperties();\n+            final boolean leakTestsEnabled = extension.has(\"netty_leak_tests_enabled\") == false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccf33333310b5dddf48a0d514f68d88be718b00b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgxNTMxNw==", "bodyText": "Are we sure about that? Anything they build that has Netty leaks will be broken from the get-go, why deny them this functionality by default (I don't see how we would document it in a way that would make people aware of its existence).\n<=> I basically chose defaulting to true because this is a pretty catastrophic issue.", "url": "https://github.com/elastic/elasticsearch/pull/64528#discussion_r529815317", "createdAt": "2020-11-24T19:09:46Z", "author": {"login": "original-brownbear"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java", "diffHunk": "@@ -968,31 +971,60 @@ private void logFileContents(String description, Path from) {\n                 }\n             }\n         } catch (IOException e) {\n-            throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            if (tailLogs) {\n+                throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            }\n+            return;\n         }\n \n-        if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n-            LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n-        }\n-        if (errorsAndWarnings.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n-            errorsAndWarnings.forEach((message, count) -> {\n-                LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                if (count > 1) {\n-                    LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n-                }\n-            });\n+        boolean foundNettyLeaks = false;\n+        for (String logLine : errorsAndWarnings.keySet()) {\n+            if (logLine.contains(\"ResourceLeakDetector]\")) {\n+                tailLogs = true;\n+                foundNettyLeaks = true;\n+                break;\n+            }\n         }\n+        if (tailLogs) {\n+            if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n+                LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n+            }\n+            if (errorsAndWarnings.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n+                errorsAndWarnings.forEach((message, count) -> {\n+                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    if (count > 1) {\n+                        LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n+                    }\n+                });\n+            }\n \n-        ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n+            ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n \n-        if (ring.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n-            ring.forEach(message -> {\n-                if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n-                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                }\n-            });\n+            if (ring.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n+                ring.forEach(message -> {\n+                    if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n+                        LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    }\n+                });\n+            }\n+        }\n+        if (foundNettyLeaks) {\n+            final ExtraPropertiesExtension extension = project.getExtensions().getExtraProperties();\n+            final boolean leakTestsEnabled = extension.has(\"netty_leak_tests_enabled\") == false", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgxMTUwMg=="}, "originalCommit": {"oid": "ccf33333310b5dddf48a0d514f68d88be718b00b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgxNzcxMw==", "bodyText": "I'll defer to @rjernst on this one since it has plugin authoring implications.", "url": "https://github.com/elastic/elasticsearch/pull/64528#discussion_r529817713", "createdAt": "2020-11-24T19:14:08Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java", "diffHunk": "@@ -968,31 +971,60 @@ private void logFileContents(String description, Path from) {\n                 }\n             }\n         } catch (IOException e) {\n-            throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            if (tailLogs) {\n+                throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            }\n+            return;\n         }\n \n-        if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n-            LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n-        }\n-        if (errorsAndWarnings.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n-            errorsAndWarnings.forEach((message, count) -> {\n-                LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                if (count > 1) {\n-                    LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n-                }\n-            });\n+        boolean foundNettyLeaks = false;\n+        for (String logLine : errorsAndWarnings.keySet()) {\n+            if (logLine.contains(\"ResourceLeakDetector]\")) {\n+                tailLogs = true;\n+                foundNettyLeaks = true;\n+                break;\n+            }\n         }\n+        if (tailLogs) {\n+            if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n+                LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n+            }\n+            if (errorsAndWarnings.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n+                errorsAndWarnings.forEach((message, count) -> {\n+                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    if (count > 1) {\n+                        LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n+                    }\n+                });\n+            }\n \n-        ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n+            ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n \n-        if (ring.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n-            ring.forEach(message -> {\n-                if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n-                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                }\n-            });\n+            if (ring.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n+                ring.forEach(message -> {\n+                    if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n+                        LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    }\n+                });\n+            }\n+        }\n+        if (foundNettyLeaks) {\n+            final ExtraPropertiesExtension extension = project.getExtensions().getExtraProperties();\n+            final boolean leakTestsEnabled = extension.has(\"netty_leak_tests_enabled\") == false", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgxMTUwMg=="}, "originalCommit": {"oid": "ccf33333310b5dddf48a0d514f68d88be718b00b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk4NzQ0MQ==", "bodyText": "In the past we have erred on the side of forcing anything we deem relevant to our plugins/modules to be used by all plugin authors. I think we have found this to be to burdensome on those users as the vast majority don't care about our internal rules. I would say do not force this on plugin authors at first.\nI'm also wondering if this is something we should have on for all builds, but instead have as another CI job? It makes sense to set it for tests inside the netty module, since that is testing our netty code, but forcing this on all developers seems like a step backwards towards the old pattern of \"lets make everything an integration test and we will naturally catch distributed bugs\". The cost is high when developers outside the distributed area hit an issue.  I also do not think we should reuse the build.gradle based setting like with bwc tests, as that was specifically added to enable back ports, while this seems like a general switch to disable the testing globally \"just in case\", which to me indicates it should be an isolated test run periodically.", "url": "https://github.com/elastic/elasticsearch/pull/64528#discussion_r532987441", "createdAt": "2020-12-01T00:13:36Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java", "diffHunk": "@@ -968,31 +971,60 @@ private void logFileContents(String description, Path from) {\n                 }\n             }\n         } catch (IOException e) {\n-            throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            if (tailLogs) {\n+                throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            }\n+            return;\n         }\n \n-        if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n-            LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n-        }\n-        if (errorsAndWarnings.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n-            errorsAndWarnings.forEach((message, count) -> {\n-                LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                if (count > 1) {\n-                    LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n-                }\n-            });\n+        boolean foundNettyLeaks = false;\n+        for (String logLine : errorsAndWarnings.keySet()) {\n+            if (logLine.contains(\"ResourceLeakDetector]\")) {\n+                tailLogs = true;\n+                foundNettyLeaks = true;\n+                break;\n+            }\n         }\n+        if (tailLogs) {\n+            if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n+                LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n+            }\n+            if (errorsAndWarnings.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n+                errorsAndWarnings.forEach((message, count) -> {\n+                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    if (count > 1) {\n+                        LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n+                    }\n+                });\n+            }\n \n-        ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n+            ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n \n-        if (ring.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n-            ring.forEach(message -> {\n-                if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n-                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                }\n-            });\n+            if (ring.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n+                ring.forEach(message -> {\n+                    if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n+                        LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    }\n+                });\n+            }\n+        }\n+        if (foundNettyLeaks) {\n+            final ExtraPropertiesExtension extension = project.getExtensions().getExtraProperties();\n+            final boolean leakTestsEnabled = extension.has(\"netty_leak_tests_enabled\") == false", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgxMTUwMg=="}, "originalCommit": {"oid": "ccf33333310b5dddf48a0d514f68d88be718b00b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwMDQ5Ng==", "bodyText": "I think we have found this to be to burdensome on those users as the vast majority don't care about our internal rules.\n\nThis isn't an arbitrary code style rule though? Anything you build that leaks Netty buffers will be fundamentally broken and OOM eventually. Also note that EsTestCase does similar checks for both Netty and our self-managed buffer pool by default for all unit tests so I don't see why being more lax about this in integration tests would be necessary?\n\nthis seems like a general switch to disable the testing globally \"just in case\", which to me indicates it should be an isolated test run periodically.\n\nThe thing is, running this in a periodic job makes it a lot less useful. David's argument here #64528 (comment) makes a lot of sense and also, as explained above in the real world this is expected to fail at an incredibly low rate (currently I'm seeing leak warnings in Cloud logs at a frequency of less than 10 globally per day and an even lower rate for 7.x versions). Again, if this triggers at any meaningful frequency something is very broken.", "url": "https://github.com/elastic/elasticsearch/pull/64528#discussion_r533000496", "createdAt": "2020-12-01T00:50:53Z", "author": {"login": "original-brownbear"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java", "diffHunk": "@@ -968,31 +971,60 @@ private void logFileContents(String description, Path from) {\n                 }\n             }\n         } catch (IOException e) {\n-            throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            if (tailLogs) {\n+                throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            }\n+            return;\n         }\n \n-        if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n-            LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n-        }\n-        if (errorsAndWarnings.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n-            errorsAndWarnings.forEach((message, count) -> {\n-                LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                if (count > 1) {\n-                    LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n-                }\n-            });\n+        boolean foundNettyLeaks = false;\n+        for (String logLine : errorsAndWarnings.keySet()) {\n+            if (logLine.contains(\"ResourceLeakDetector]\")) {\n+                tailLogs = true;\n+                foundNettyLeaks = true;\n+                break;\n+            }\n         }\n+        if (tailLogs) {\n+            if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n+                LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n+            }\n+            if (errorsAndWarnings.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n+                errorsAndWarnings.forEach((message, count) -> {\n+                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    if (count > 1) {\n+                        LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n+                    }\n+                });\n+            }\n \n-        ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n+            ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n \n-        if (ring.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n-            ring.forEach(message -> {\n-                if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n-                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                }\n-            });\n+            if (ring.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n+                ring.forEach(message -> {\n+                    if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n+                        LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    }\n+                });\n+            }\n+        }\n+        if (foundNettyLeaks) {\n+            final ExtraPropertiesExtension extension = project.getExtensions().getExtraProperties();\n+            final boolean leakTestsEnabled = extension.has(\"netty_leak_tests_enabled\") == false", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgxMTUwMg=="}, "originalCommit": {"oid": "ccf33333310b5dddf48a0d514f68d88be718b00b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3MzIyMw==", "bodyText": "This isn't an arbitrary code style rule though? Anything you build that leaks Netty buffers will be fundamentally broken and OOM eventually.\n\nTrue, but we can't anticipate all plugin authors use cases or intentions. What if they are testing something that purposefully creates a leak, etc. Now they can't build their plugin. I vote for disabling this externally only because we've been so disruptive in the past and I don't want to risk any more side-effects from stuff like this. Of course, external plugin authors that are doing bytebuf allocation in their plugins (probably not common) should have leak-detection enabled, but I agree with Ryan that we should lean towards being less prescriptive there, simply because historically it has caused lots of problem.", "url": "https://github.com/elastic/elasticsearch/pull/64528#discussion_r533673223", "createdAt": "2020-12-01T19:39:46Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java", "diffHunk": "@@ -968,31 +971,60 @@ private void logFileContents(String description, Path from) {\n                 }\n             }\n         } catch (IOException e) {\n-            throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            if (tailLogs) {\n+                throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            }\n+            return;\n         }\n \n-        if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n-            LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n-        }\n-        if (errorsAndWarnings.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n-            errorsAndWarnings.forEach((message, count) -> {\n-                LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                if (count > 1) {\n-                    LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n-                }\n-            });\n+        boolean foundNettyLeaks = false;\n+        for (String logLine : errorsAndWarnings.keySet()) {\n+            if (logLine.contains(\"ResourceLeakDetector]\")) {\n+                tailLogs = true;\n+                foundNettyLeaks = true;\n+                break;\n+            }\n         }\n+        if (tailLogs) {\n+            if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n+                LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n+            }\n+            if (errorsAndWarnings.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n+                errorsAndWarnings.forEach((message, count) -> {\n+                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    if (count > 1) {\n+                        LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n+                    }\n+                });\n+            }\n \n-        ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n+            ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n \n-        if (ring.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n-            ring.forEach(message -> {\n-                if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n-                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                }\n-            });\n+            if (ring.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n+                ring.forEach(message -> {\n+                    if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n+                        LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    }\n+                });\n+            }\n+        }\n+        if (foundNettyLeaks) {\n+            final ExtraPropertiesExtension extension = project.getExtensions().getExtraProperties();\n+            final boolean leakTestsEnabled = extension.has(\"netty_leak_tests_enabled\") == false", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgxMTUwMg=="}, "originalCommit": {"oid": "ccf33333310b5dddf48a0d514f68d88be718b00b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3MzU0NQ==", "bodyText": "RE: the periodic job, we can start with doing this across the board and then potentially move it into a periodic job if it becomes too disruptive or costly.", "url": "https://github.com/elastic/elasticsearch/pull/64528#discussion_r533673545", "createdAt": "2020-12-01T19:40:18Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java", "diffHunk": "@@ -968,31 +971,60 @@ private void logFileContents(String description, Path from) {\n                 }\n             }\n         } catch (IOException e) {\n-            throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            if (tailLogs) {\n+                throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            }\n+            return;\n         }\n \n-        if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n-            LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n-        }\n-        if (errorsAndWarnings.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n-            errorsAndWarnings.forEach((message, count) -> {\n-                LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                if (count > 1) {\n-                    LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n-                }\n-            });\n+        boolean foundNettyLeaks = false;\n+        for (String logLine : errorsAndWarnings.keySet()) {\n+            if (logLine.contains(\"ResourceLeakDetector]\")) {\n+                tailLogs = true;\n+                foundNettyLeaks = true;\n+                break;\n+            }\n         }\n+        if (tailLogs) {\n+            if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n+                LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n+            }\n+            if (errorsAndWarnings.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n+                errorsAndWarnings.forEach((message, count) -> {\n+                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    if (count > 1) {\n+                        LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n+                    }\n+                });\n+            }\n \n-        ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n+            ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n \n-        if (ring.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n-            ring.forEach(message -> {\n-                if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n-                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                }\n-            });\n+            if (ring.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n+                ring.forEach(message -> {\n+                    if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n+                        LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    }\n+                });\n+            }\n+        }\n+        if (foundNettyLeaks) {\n+            final ExtraPropertiesExtension extension = project.getExtensions().getExtraProperties();\n+            final boolean leakTestsEnabled = extension.has(\"netty_leak_tests_enabled\") == false", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgxMTUwMg=="}, "originalCommit": {"oid": "ccf33333310b5dddf48a0d514f68d88be718b00b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3NzA1NA==", "bodyText": "I'm fine with moving to a periodic job as necessary, but then I don't think we should have an escape hatch. If it is problematic, let's move it at that time, rather than try to proactively allow for disabling across the board.", "url": "https://github.com/elastic/elasticsearch/pull/64528#discussion_r533677054", "createdAt": "2020-12-01T19:46:26Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java", "diffHunk": "@@ -968,31 +971,60 @@ private void logFileContents(String description, Path from) {\n                 }\n             }\n         } catch (IOException e) {\n-            throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            if (tailLogs) {\n+                throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            }\n+            return;\n         }\n \n-        if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n-            LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n-        }\n-        if (errorsAndWarnings.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n-            errorsAndWarnings.forEach((message, count) -> {\n-                LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                if (count > 1) {\n-                    LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n-                }\n-            });\n+        boolean foundNettyLeaks = false;\n+        for (String logLine : errorsAndWarnings.keySet()) {\n+            if (logLine.contains(\"ResourceLeakDetector]\")) {\n+                tailLogs = true;\n+                foundNettyLeaks = true;\n+                break;\n+            }\n         }\n+        if (tailLogs) {\n+            if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n+                LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n+            }\n+            if (errorsAndWarnings.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n+                errorsAndWarnings.forEach((message, count) -> {\n+                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    if (count > 1) {\n+                        LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n+                    }\n+                });\n+            }\n \n-        ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n+            ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n \n-        if (ring.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n-            ring.forEach(message -> {\n-                if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n-                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                }\n-            });\n+            if (ring.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n+                ring.forEach(message -> {\n+                    if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n+                        LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    }\n+                });\n+            }\n+        }\n+        if (foundNettyLeaks) {\n+            final ExtraPropertiesExtension extension = project.getExtensions().getExtraProperties();\n+            final boolean leakTestsEnabled = extension.has(\"netty_leak_tests_enabled\") == false", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgxMTUwMg=="}, "originalCommit": {"oid": "ccf33333310b5dddf48a0d514f68d88be718b00b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3ODIxNw==", "bodyText": "I think \"problematic\" needs to take into consideration the existence of an escape hatch. Just as we do for BWC testing (which is included in the pr/merge workflow). We would not add any check to the build that we could not somehow mute temporarily, and this is no different.\nMuting temporarily does not mean it's problematic. It's a necessary tool to keep work flowing. If this becomes the norm (i.e. it's disable more often than it isn't) then that's very different.", "url": "https://github.com/elastic/elasticsearch/pull/64528#discussion_r533678217", "createdAt": "2020-12-01T19:48:37Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java", "diffHunk": "@@ -968,31 +971,60 @@ private void logFileContents(String description, Path from) {\n                 }\n             }\n         } catch (IOException e) {\n-            throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            if (tailLogs) {\n+                throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            }\n+            return;\n         }\n \n-        if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n-            LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n-        }\n-        if (errorsAndWarnings.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n-            errorsAndWarnings.forEach((message, count) -> {\n-                LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                if (count > 1) {\n-                    LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n-                }\n-            });\n+        boolean foundNettyLeaks = false;\n+        for (String logLine : errorsAndWarnings.keySet()) {\n+            if (logLine.contains(\"ResourceLeakDetector]\")) {\n+                tailLogs = true;\n+                foundNettyLeaks = true;\n+                break;\n+            }\n         }\n+        if (tailLogs) {\n+            if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n+                LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n+            }\n+            if (errorsAndWarnings.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n+                errorsAndWarnings.forEach((message, count) -> {\n+                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    if (count > 1) {\n+                        LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n+                    }\n+                });\n+            }\n \n-        ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n+            ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n \n-        if (ring.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n-            ring.forEach(message -> {\n-                if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n-                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                }\n-            });\n+            if (ring.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n+                ring.forEach(message -> {\n+                    if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n+                        LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    }\n+                });\n+            }\n+        }\n+        if (foundNettyLeaks) {\n+            final ExtraPropertiesExtension extension = project.getExtensions().getExtraProperties();\n+            final boolean leakTestsEnabled = extension.has(\"netty_leak_tests_enabled\") == false", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgxMTUwMg=="}, "originalCommit": {"oid": "ccf33333310b5dddf48a0d514f68d88be718b00b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAwMTk1MA==", "bodyText": "Alright :) disabled the check by default now so that plugin authors. I'd still rather not make this a separate CI task for previously stated reasons. Let me know what you think", "url": "https://github.com/elastic/elasticsearch/pull/64528#discussion_r534001950", "createdAt": "2020-12-02T09:06:48Z", "author": {"login": "original-brownbear"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java", "diffHunk": "@@ -968,31 +971,60 @@ private void logFileContents(String description, Path from) {\n                 }\n             }\n         } catch (IOException e) {\n-            throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            if (tailLogs) {\n+                throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            }\n+            return;\n         }\n \n-        if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n-            LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n-        }\n-        if (errorsAndWarnings.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n-            errorsAndWarnings.forEach((message, count) -> {\n-                LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                if (count > 1) {\n-                    LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n-                }\n-            });\n+        boolean foundNettyLeaks = false;\n+        for (String logLine : errorsAndWarnings.keySet()) {\n+            if (logLine.contains(\"ResourceLeakDetector]\")) {\n+                tailLogs = true;\n+                foundNettyLeaks = true;\n+                break;\n+            }\n         }\n+        if (tailLogs) {\n+            if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n+                LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n+            }\n+            if (errorsAndWarnings.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n+                errorsAndWarnings.forEach((message, count) -> {\n+                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    if (count > 1) {\n+                        LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n+                    }\n+                });\n+            }\n \n-        ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n+            ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n \n-        if (ring.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n-            ring.forEach(message -> {\n-                if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n-                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                }\n-            });\n+            if (ring.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n+                ring.forEach(message -> {\n+                    if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n+                        LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    }\n+                });\n+            }\n+        }\n+        if (foundNettyLeaks) {\n+            final ExtraPropertiesExtension extension = project.getExtensions().getExtraProperties();\n+            final boolean leakTestsEnabled = extension.has(\"netty_leak_tests_enabled\") == false", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgxMTUwMg=="}, "originalCommit": {"oid": "ccf33333310b5dddf48a0d514f68d88be718b00b"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MjU5NTQ4OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNzoyNjowNVrOH9mBmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNzoyNjowNVrOH9mBmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0ODE4Ng==", "bodyText": "Let's log this at warn level since we aren't failing the build.", "url": "https://github.com/elastic/elasticsearch/pull/64528#discussion_r534348186", "createdAt": "2020-12-02T17:26:05Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java", "diffHunk": "@@ -985,31 +988,58 @@ private void logFileContents(String description, Path from) {\n                 }\n             }\n         } catch (IOException e) {\n-            throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            if (tailLogs) {\n+                throw new UncheckedIOException(\"Failed to tail log \" + this, e);\n+            }\n+            return;\n         }\n \n-        if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n-            LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n-        }\n-        if (errorsAndWarnings.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n-            errorsAndWarnings.forEach((message, count) -> {\n-                LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                if (count > 1) {\n-                    LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n-                }\n-            });\n+        boolean foundNettyLeaks = false;\n+        for (String logLine : errorsAndWarnings.keySet()) {\n+            if (logLine.contains(\"ResourceLeakDetector]\")) {\n+                tailLogs = true;\n+                foundNettyLeaks = true;\n+                break;\n+            }\n         }\n+        if (tailLogs) {\n+            if (errorsAndWarnings.isEmpty() == false || ring.isEmpty() == false) {\n+                LOGGER.error(\"\\n=== {} `{}` ===\", description, this);\n+            }\n+            if (errorsAndWarnings.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\\n\u00bb    \u2193 errors and warnings from \" + from + \" \u2193\");\n+                errorsAndWarnings.forEach((message, count) -> {\n+                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    if (count > 1) {\n+                        LOGGER.lifecycle(\"\u00bb   \u2191 repeated \" + count + \" times \u2191\");\n+                    }\n+                });\n+            }\n \n-        ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n+            ring.removeIf(line -> MESSAGES_WE_DONT_CARE_ABOUT.stream().anyMatch(line::contains));\n \n-        if (ring.isEmpty() == false) {\n-            LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n-            ring.forEach(message -> {\n-                if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n-                    LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n-                }\n-            });\n+            if (ring.isEmpty() == false) {\n+                LOGGER.lifecycle(\"\u00bb   \u2193 last \" + TAIL_LOG_MESSAGES_COUNT + \" non error or warning messages from \" + from + \" \u2193\");\n+                ring.forEach(message -> {\n+                    if (errorsAndWarnings.containsKey(normalizeLogLine(message)) == false) {\n+                        LOGGER.lifecycle(\"\u00bb \" + message.replace(\"\\n\", \"\\n\u00bb  \"));\n+                    }\n+                });\n+            }\n+        }\n+        if (foundNettyLeaks) {\n+            final ExtraPropertiesExtension extension = project.getExtensions().getExtraProperties();\n+            if (extension.has(\"netty_leak_tests_enabled\") && (Boolean) extension.get(\"netty_leak_tests_enabled\")) {\n+                throw new TestClustersException(\n+                    \"Found Netty ByteBuf leaks in node logs. In order to temporarily mute this check, set \"\n+                        + \"\\\"netty_leak_tests_enabled\\\" to false in the root level build.gradle file\"\n+                );\n+            } else {\n+                LOGGER.error(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6b6007734c3b450439abde3a6f8240b4c5593e6"}, "originalPosition": 119}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4050, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}