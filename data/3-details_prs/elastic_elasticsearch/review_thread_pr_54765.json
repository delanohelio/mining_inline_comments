{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4NjMzNjUx", "number": 54765, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQxMzo0NDozMFrODu4NZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwOToyOTowNlrODvCyvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNDgyMDIzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/delete/TransportDeleteSnapshotAction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQxMzo0NDozMFrOGBAIbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQxMzo0NDozMFrOGBAIbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzcwMzkxNg==", "bodyText": "No need to fork to the generic pool here any more, we instantly move to the cluster state thread now in the snapshots service. We'll use the generic pool there once we have to inspect the repository data", "url": "https://github.com/elastic/elasticsearch/pull/54765#discussion_r403703916", "createdAt": "2020-04-05T13:44:30Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/delete/TransportDeleteSnapshotAction.java", "diffHunk": "@@ -54,7 +54,7 @@ public TransportDeleteSnapshotAction(TransportService transportService, ClusterS\n \n     @Override\n     protected String executor() {\n-        return ThreadPool.Names.GENERIC;\n+        return ThreadPool.Names.SAME;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0cdd17a1869f684b169a427ee5686dd21652f6b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjAzNTEzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzowNzoyOFrOGBKUpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODozODoxNlrOGBNUEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg3MDg4Nw==", "bodyText": "should we also log an info-level message once we have successfully completed the deletion?", "url": "https://github.com/elastic/elasticsearch/pull/54765#discussion_r403870887", "createdAt": "2020-04-06T07:07:28Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -970,61 +970,168 @@ private void failSnapshotCompletionListeners(Snapshot snapshot, Exception e) {\n     }\n \n     /**\n-     * Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting.\n-     * If the snapshot is still running cancels the snapshot first and then deletes it from the repository.\n+     * Deletes a snapshot from the repository or aborts a running snapshot.\n+     * First checks if the snapshot is still running and if so cancels the snapshot and then deletes it from the repository.\n+     * If the snapshot is not running, moves to trying to find a matching {@link Snapshot} for the given name in the repository and if\n+     * one is found deletes it by invoking {@link #deleteCompletedSnapshot}.\n      *\n      * @param repositoryName  repositoryName\n      * @param snapshotName    snapshotName\n      * @param listener        listener\n      */\n-    public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,\n-                               final boolean immediatePriority) {\n-        // First, look for the snapshot in the repository\n-        final Repository repository = repositoriesService.repository(repositoryName);\n-        repository.getRepositoryData(ActionListener.wrap(repositoryData -> {\n-            Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()\n-                .stream()\n-                .filter(s -> s.getName().equals(snapshotName))\n-                .findFirst();\n-            // if nothing found by the same name, then look in the cluster state for current in progress snapshots\n-            long repoGenId = repositoryData.getGenId();\n-            if (matchedEntry.isPresent() == false) {\n-                Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(\n-                    clusterService.state().custom(SnapshotsInProgress.TYPE), repositoryName, Collections.emptyList()).stream()\n-                    .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst();\n-                if (matchedInProgress.isPresent()) {\n-                    matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId());\n-                    // Derive repository generation if a snapshot is in progress because it will increment the generation when it finishes\n-                    repoGenId = matchedInProgress.get().repositoryStateId() + 1L;\n+    public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener) {\n+        logger.info(\"deleting snapshot [{}] from repository [{}]\", snapshotName, repositoryName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0cdd17a1869f684b169a427ee5686dd21652f6b"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkxOTg4OA==", "bodyText": "Jup added one for abort and one for the actual delete if it happened now.", "url": "https://github.com/elastic/elasticsearch/pull/54765#discussion_r403919888", "createdAt": "2020-04-06T08:38:16Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -970,61 +970,168 @@ private void failSnapshotCompletionListeners(Snapshot snapshot, Exception e) {\n     }\n \n     /**\n-     * Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting.\n-     * If the snapshot is still running cancels the snapshot first and then deletes it from the repository.\n+     * Deletes a snapshot from the repository or aborts a running snapshot.\n+     * First checks if the snapshot is still running and if so cancels the snapshot and then deletes it from the repository.\n+     * If the snapshot is not running, moves to trying to find a matching {@link Snapshot} for the given name in the repository and if\n+     * one is found deletes it by invoking {@link #deleteCompletedSnapshot}.\n      *\n      * @param repositoryName  repositoryName\n      * @param snapshotName    snapshotName\n      * @param listener        listener\n      */\n-    public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,\n-                               final boolean immediatePriority) {\n-        // First, look for the snapshot in the repository\n-        final Repository repository = repositoriesService.repository(repositoryName);\n-        repository.getRepositoryData(ActionListener.wrap(repositoryData -> {\n-            Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()\n-                .stream()\n-                .filter(s -> s.getName().equals(snapshotName))\n-                .findFirst();\n-            // if nothing found by the same name, then look in the cluster state for current in progress snapshots\n-            long repoGenId = repositoryData.getGenId();\n-            if (matchedEntry.isPresent() == false) {\n-                Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(\n-                    clusterService.state().custom(SnapshotsInProgress.TYPE), repositoryName, Collections.emptyList()).stream()\n-                    .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst();\n-                if (matchedInProgress.isPresent()) {\n-                    matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId());\n-                    // Derive repository generation if a snapshot is in progress because it will increment the generation when it finishes\n-                    repoGenId = matchedInProgress.get().repositoryStateId() + 1L;\n+    public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener) {\n+        logger.info(\"deleting snapshot [{}] from repository [{}]\", snapshotName, repositoryName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg3MDg4Nw=="}, "originalCommit": {"oid": "a0cdd17a1869f684b169a427ee5686dd21652f6b"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjA0MjM1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotDeletionsInProgress.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzowOTo0MVrOGBKYqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzowOTo0MVrOGBKYqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg3MTkxNQ==", "bodyText": "We would incorrectly get a -1 (empty repo gen) here when we deleted/aborted an initializing snapshot (because the repo gen is at -2 during the snapshot INIT stage). This wouldn't have caused any corruption and only made deletes fail but still, this assertion would've avoided not catching this race for so long :)", "url": "https://github.com/elastic/elasticsearch/pull/54765#discussion_r403871915", "createdAt": "2020-04-06T07:09:41Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotDeletionsInProgress.java", "diffHunk": "@@ -174,6 +175,8 @@ public Entry(Snapshot snapshot, long startTime, long repositoryStateId) {\n             this.snapshot = snapshot;\n             this.startTime = startTime;\n             this.repositoryStateId = repositoryStateId;\n+            assert repositoryStateId > RepositoryData.EMPTY_REPO_GEN :", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0cdd17a1869f684b169a427ee5686dd21652f6b"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjA0NzgxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzoxMTozN1rOGBKb3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODozODoyOVrOGBNUvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg3MjczNA==", "bodyText": "maybe add this a helper method to SnapshotsInProgress similar to public Entry snapshot(final Snapshot snapshot)", "url": "https://github.com/elastic/elasticsearch/pull/54765#discussion_r403872734", "createdAt": "2020-04-06T07:11:37Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -970,61 +970,168 @@ private void failSnapshotCompletionListeners(Snapshot snapshot, Exception e) {\n     }\n \n     /**\n-     * Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting.\n-     * If the snapshot is still running cancels the snapshot first and then deletes it from the repository.\n+     * Deletes a snapshot from the repository or aborts a running snapshot.\n+     * First checks if the snapshot is still running and if so cancels the snapshot and then deletes it from the repository.\n+     * If the snapshot is not running, moves to trying to find a matching {@link Snapshot} for the given name in the repository and if\n+     * one is found deletes it by invoking {@link #deleteCompletedSnapshot}.\n      *\n      * @param repositoryName  repositoryName\n      * @param snapshotName    snapshotName\n      * @param listener        listener\n      */\n-    public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,\n-                               final boolean immediatePriority) {\n-        // First, look for the snapshot in the repository\n-        final Repository repository = repositoriesService.repository(repositoryName);\n-        repository.getRepositoryData(ActionListener.wrap(repositoryData -> {\n-            Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()\n-                .stream()\n-                .filter(s -> s.getName().equals(snapshotName))\n-                .findFirst();\n-            // if nothing found by the same name, then look in the cluster state for current in progress snapshots\n-            long repoGenId = repositoryData.getGenId();\n-            if (matchedEntry.isPresent() == false) {\n-                Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(\n-                    clusterService.state().custom(SnapshotsInProgress.TYPE), repositoryName, Collections.emptyList()).stream()\n-                    .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst();\n-                if (matchedInProgress.isPresent()) {\n-                    matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId());\n-                    // Derive repository generation if a snapshot is in progress because it will increment the generation when it finishes\n-                    repoGenId = matchedInProgress.get().repositoryStateId() + 1L;\n+    public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener) {\n+        logger.info(\"deleting snapshot [{}] from repository [{}]\", snapshotName, repositoryName);\n+\n+        clusterService.submitStateUpdateTask(\"delete snapshot\", new ClusterStateUpdateTask(Priority.NORMAL) {\n+\n+            Snapshot runningSnapshot;\n+\n+            boolean abortedDuringInit = false;\n+\n+            @Override\n+            public ClusterState execute(ClusterState currentState) {\n+                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n+                SnapshotsInProgress.Entry snapshotEntry = null;\n+                if (snapshots != null) {\n+                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0cdd17a1869f684b169a427ee5686dd21652f6b"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkyMDA2MQ==", "bodyText": "Sure extracted that logic :)", "url": "https://github.com/elastic/elasticsearch/pull/54765#discussion_r403920061", "createdAt": "2020-04-06T08:38:29Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -970,61 +970,168 @@ private void failSnapshotCompletionListeners(Snapshot snapshot, Exception e) {\n     }\n \n     /**\n-     * Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting.\n-     * If the snapshot is still running cancels the snapshot first and then deletes it from the repository.\n+     * Deletes a snapshot from the repository or aborts a running snapshot.\n+     * First checks if the snapshot is still running and if so cancels the snapshot and then deletes it from the repository.\n+     * If the snapshot is not running, moves to trying to find a matching {@link Snapshot} for the given name in the repository and if\n+     * one is found deletes it by invoking {@link #deleteCompletedSnapshot}.\n      *\n      * @param repositoryName  repositoryName\n      * @param snapshotName    snapshotName\n      * @param listener        listener\n      */\n-    public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,\n-                               final boolean immediatePriority) {\n-        // First, look for the snapshot in the repository\n-        final Repository repository = repositoriesService.repository(repositoryName);\n-        repository.getRepositoryData(ActionListener.wrap(repositoryData -> {\n-            Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()\n-                .stream()\n-                .filter(s -> s.getName().equals(snapshotName))\n-                .findFirst();\n-            // if nothing found by the same name, then look in the cluster state for current in progress snapshots\n-            long repoGenId = repositoryData.getGenId();\n-            if (matchedEntry.isPresent() == false) {\n-                Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(\n-                    clusterService.state().custom(SnapshotsInProgress.TYPE), repositoryName, Collections.emptyList()).stream()\n-                    .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst();\n-                if (matchedInProgress.isPresent()) {\n-                    matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId());\n-                    // Derive repository generation if a snapshot is in progress because it will increment the generation when it finishes\n-                    repoGenId = matchedInProgress.get().repositoryStateId() + 1L;\n+    public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener) {\n+        logger.info(\"deleting snapshot [{}] from repository [{}]\", snapshotName, repositoryName);\n+\n+        clusterService.submitStateUpdateTask(\"delete snapshot\", new ClusterStateUpdateTask(Priority.NORMAL) {\n+\n+            Snapshot runningSnapshot;\n+\n+            boolean abortedDuringInit = false;\n+\n+            @Override\n+            public ClusterState execute(ClusterState currentState) {\n+                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n+                SnapshotsInProgress.Entry snapshotEntry = null;\n+                if (snapshots != null) {\n+                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg3MjczNA=="}, "originalCommit": {"oid": "a0cdd17a1869f684b169a427ee5686dd21652f6b"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjA1OTgzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzoxNTozOFrOGBKjNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODozOTo0MFrOGBNXqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg3NDYxMw==", "bodyText": "I know that this was already the case before, but if we were to allow concurrent snapshots, this line here would be silently removing other snapshots. Let's make sure to preserve other snapshots so that we don't get nasty surprises in the future.", "url": "https://github.com/elastic/elasticsearch/pull/54765#discussion_r403874613", "createdAt": "2020-04-06T07:15:38Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -970,61 +970,168 @@ private void failSnapshotCompletionListeners(Snapshot snapshot, Exception e) {\n     }\n \n     /**\n-     * Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting.\n-     * If the snapshot is still running cancels the snapshot first and then deletes it from the repository.\n+     * Deletes a snapshot from the repository or aborts a running snapshot.\n+     * First checks if the snapshot is still running and if so cancels the snapshot and then deletes it from the repository.\n+     * If the snapshot is not running, moves to trying to find a matching {@link Snapshot} for the given name in the repository and if\n+     * one is found deletes it by invoking {@link #deleteCompletedSnapshot}.\n      *\n      * @param repositoryName  repositoryName\n      * @param snapshotName    snapshotName\n      * @param listener        listener\n      */\n-    public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,\n-                               final boolean immediatePriority) {\n-        // First, look for the snapshot in the repository\n-        final Repository repository = repositoriesService.repository(repositoryName);\n-        repository.getRepositoryData(ActionListener.wrap(repositoryData -> {\n-            Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()\n-                .stream()\n-                .filter(s -> s.getName().equals(snapshotName))\n-                .findFirst();\n-            // if nothing found by the same name, then look in the cluster state for current in progress snapshots\n-            long repoGenId = repositoryData.getGenId();\n-            if (matchedEntry.isPresent() == false) {\n-                Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(\n-                    clusterService.state().custom(SnapshotsInProgress.TYPE), repositoryName, Collections.emptyList()).stream()\n-                    .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst();\n-                if (matchedInProgress.isPresent()) {\n-                    matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId());\n-                    // Derive repository generation if a snapshot is in progress because it will increment the generation when it finishes\n-                    repoGenId = matchedInProgress.get().repositoryStateId() + 1L;\n+    public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener) {\n+        logger.info(\"deleting snapshot [{}] from repository [{}]\", snapshotName, repositoryName);\n+\n+        clusterService.submitStateUpdateTask(\"delete snapshot\", new ClusterStateUpdateTask(Priority.NORMAL) {\n+\n+            Snapshot runningSnapshot;\n+\n+            boolean abortedDuringInit = false;\n+\n+            @Override\n+            public ClusterState execute(ClusterState currentState) {\n+                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n+                SnapshotsInProgress.Entry snapshotEntry = null;\n+                if (snapshots != null) {\n+                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {\n+                        if (entry.repository().equals(repositoryName)\n+                            && entry.snapshot().getSnapshotId().getName().equals(snapshotName)) {\n+                            snapshotEntry = entry;\n+                            break;\n+                        }\n+                    }\n+                }\n+                if (snapshotEntry == null) {\n+                    return currentState;\n                 }\n+                runningSnapshot = snapshotEntry.snapshot();\n+                final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards;\n+\n+                final State state = snapshotEntry.state();\n+                final String failure;\n+                if (state == State.INIT) {\n+                    // snapshot is still initializing, mark it as aborted\n+                    shards = snapshotEntry.shards();\n+                    assert shards.isEmpty();\n+                    failure = \"Snapshot was aborted during initialization\";\n+                    abortedDuringInit = true;\n+                } else if (state == State.STARTED) {\n+                    // snapshot is started - mark every non completed shard as aborted\n+                    final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder();\n+                    for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {\n+                        ShardSnapshotStatus status = shardEntry.value;\n+                        if (status.state().completed() == false) {\n+                            status = new ShardSnapshotStatus(\n+                                status.nodeId(), ShardState.ABORTED, \"aborted by snapshot deletion\", status.generation());\n+                        }\n+                        shardsBuilder.put(shardEntry.key, status);\n+                    }\n+                    shards = shardsBuilder.build();\n+                    failure = \"Snapshot was aborted by deletion\";\n+                } else {\n+                    boolean hasUncompletedShards = false;\n+                    // Cleanup in case a node gone missing and snapshot wasn't updated for some reason\n+                    for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {\n+                        // Check if we still have shard running on existing nodes\n+                        if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null\n+                            && currentState.nodes().get(shardStatus.value.nodeId()) != null) {\n+                            hasUncompletedShards = true;\n+                            break;\n+                        }\n+                    }\n+                    if (hasUncompletedShards) {\n+                        // snapshot is being finalized - wait for shards to complete finalization process\n+                        logger.debug(\"trying to delete completed snapshot - should wait for shards to finalize on all nodes\");\n+                        return currentState;\n+                    } else {\n+                        // no shards to wait for but a node is gone - this is the only case\n+                        // where we force to finish the snapshot\n+                        logger.debug(\"trying to delete completed snapshot with no finalizing shards - can delete immediately\");\n+                        shards = snapshotEntry.shards();\n+                    }\n+                    failure = snapshotEntry.failure();\n+                }\n+                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE,\n+                    new SnapshotsInProgress(new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards, failure))).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0cdd17a1869f684b169a427ee5686dd21652f6b"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkyMDgwOQ==", "bodyText": "Sure, this logic looks somewhat different in the concurrent deletes branch already but at least this keeps the diff smaller logically later on :)", "url": "https://github.com/elastic/elasticsearch/pull/54765#discussion_r403920809", "createdAt": "2020-04-06T08:39:40Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -970,61 +970,168 @@ private void failSnapshotCompletionListeners(Snapshot snapshot, Exception e) {\n     }\n \n     /**\n-     * Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting.\n-     * If the snapshot is still running cancels the snapshot first and then deletes it from the repository.\n+     * Deletes a snapshot from the repository or aborts a running snapshot.\n+     * First checks if the snapshot is still running and if so cancels the snapshot and then deletes it from the repository.\n+     * If the snapshot is not running, moves to trying to find a matching {@link Snapshot} for the given name in the repository and if\n+     * one is found deletes it by invoking {@link #deleteCompletedSnapshot}.\n      *\n      * @param repositoryName  repositoryName\n      * @param snapshotName    snapshotName\n      * @param listener        listener\n      */\n-    public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,\n-                               final boolean immediatePriority) {\n-        // First, look for the snapshot in the repository\n-        final Repository repository = repositoriesService.repository(repositoryName);\n-        repository.getRepositoryData(ActionListener.wrap(repositoryData -> {\n-            Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()\n-                .stream()\n-                .filter(s -> s.getName().equals(snapshotName))\n-                .findFirst();\n-            // if nothing found by the same name, then look in the cluster state for current in progress snapshots\n-            long repoGenId = repositoryData.getGenId();\n-            if (matchedEntry.isPresent() == false) {\n-                Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(\n-                    clusterService.state().custom(SnapshotsInProgress.TYPE), repositoryName, Collections.emptyList()).stream()\n-                    .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst();\n-                if (matchedInProgress.isPresent()) {\n-                    matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId());\n-                    // Derive repository generation if a snapshot is in progress because it will increment the generation when it finishes\n-                    repoGenId = matchedInProgress.get().repositoryStateId() + 1L;\n+    public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener) {\n+        logger.info(\"deleting snapshot [{}] from repository [{}]\", snapshotName, repositoryName);\n+\n+        clusterService.submitStateUpdateTask(\"delete snapshot\", new ClusterStateUpdateTask(Priority.NORMAL) {\n+\n+            Snapshot runningSnapshot;\n+\n+            boolean abortedDuringInit = false;\n+\n+            @Override\n+            public ClusterState execute(ClusterState currentState) {\n+                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n+                SnapshotsInProgress.Entry snapshotEntry = null;\n+                if (snapshots != null) {\n+                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {\n+                        if (entry.repository().equals(repositoryName)\n+                            && entry.snapshot().getSnapshotId().getName().equals(snapshotName)) {\n+                            snapshotEntry = entry;\n+                            break;\n+                        }\n+                    }\n+                }\n+                if (snapshotEntry == null) {\n+                    return currentState;\n                 }\n+                runningSnapshot = snapshotEntry.snapshot();\n+                final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards;\n+\n+                final State state = snapshotEntry.state();\n+                final String failure;\n+                if (state == State.INIT) {\n+                    // snapshot is still initializing, mark it as aborted\n+                    shards = snapshotEntry.shards();\n+                    assert shards.isEmpty();\n+                    failure = \"Snapshot was aborted during initialization\";\n+                    abortedDuringInit = true;\n+                } else if (state == State.STARTED) {\n+                    // snapshot is started - mark every non completed shard as aborted\n+                    final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder();\n+                    for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {\n+                        ShardSnapshotStatus status = shardEntry.value;\n+                        if (status.state().completed() == false) {\n+                            status = new ShardSnapshotStatus(\n+                                status.nodeId(), ShardState.ABORTED, \"aborted by snapshot deletion\", status.generation());\n+                        }\n+                        shardsBuilder.put(shardEntry.key, status);\n+                    }\n+                    shards = shardsBuilder.build();\n+                    failure = \"Snapshot was aborted by deletion\";\n+                } else {\n+                    boolean hasUncompletedShards = false;\n+                    // Cleanup in case a node gone missing and snapshot wasn't updated for some reason\n+                    for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {\n+                        // Check if we still have shard running on existing nodes\n+                        if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null\n+                            && currentState.nodes().get(shardStatus.value.nodeId()) != null) {\n+                            hasUncompletedShards = true;\n+                            break;\n+                        }\n+                    }\n+                    if (hasUncompletedShards) {\n+                        // snapshot is being finalized - wait for shards to complete finalization process\n+                        logger.debug(\"trying to delete completed snapshot - should wait for shards to finalize on all nodes\");\n+                        return currentState;\n+                    } else {\n+                        // no shards to wait for but a node is gone - this is the only case\n+                        // where we force to finish the snapshot\n+                        logger.debug(\"trying to delete completed snapshot with no finalizing shards - can delete immediately\");\n+                        shards = snapshotEntry.shards();\n+                    }\n+                    failure = snapshotEntry.failure();\n+                }\n+                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE,\n+                    new SnapshotsInProgress(new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards, failure))).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg3NDYxMw=="}, "originalCommit": {"oid": "a0cdd17a1869f684b169a427ee5686dd21652f6b"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjA2NjUyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzoxNzo1MlrOGBKnOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoxNTowMFrOGBMemQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg3NTY0Mw==", "bodyText": "why is method defined at the previous cluster state update task level? I think I would prefer explicitly passing in the listener, and moving it up", "url": "https://github.com/elastic/elasticsearch/pull/54765#discussion_r403875643", "createdAt": "2020-04-06T07:17:52Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -970,61 +970,168 @@ private void failSnapshotCompletionListeners(Snapshot snapshot, Exception e) {\n     }\n \n     /**\n-     * Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting.\n-     * If the snapshot is still running cancels the snapshot first and then deletes it from the repository.\n+     * Deletes a snapshot from the repository or aborts a running snapshot.\n+     * First checks if the snapshot is still running and if so cancels the snapshot and then deletes it from the repository.\n+     * If the snapshot is not running, moves to trying to find a matching {@link Snapshot} for the given name in the repository and if\n+     * one is found deletes it by invoking {@link #deleteCompletedSnapshot}.\n      *\n      * @param repositoryName  repositoryName\n      * @param snapshotName    snapshotName\n      * @param listener        listener\n      */\n-    public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,\n-                               final boolean immediatePriority) {\n-        // First, look for the snapshot in the repository\n-        final Repository repository = repositoriesService.repository(repositoryName);\n-        repository.getRepositoryData(ActionListener.wrap(repositoryData -> {\n-            Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()\n-                .stream()\n-                .filter(s -> s.getName().equals(snapshotName))\n-                .findFirst();\n-            // if nothing found by the same name, then look in the cluster state for current in progress snapshots\n-            long repoGenId = repositoryData.getGenId();\n-            if (matchedEntry.isPresent() == false) {\n-                Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(\n-                    clusterService.state().custom(SnapshotsInProgress.TYPE), repositoryName, Collections.emptyList()).stream()\n-                    .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst();\n-                if (matchedInProgress.isPresent()) {\n-                    matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId());\n-                    // Derive repository generation if a snapshot is in progress because it will increment the generation when it finishes\n-                    repoGenId = matchedInProgress.get().repositoryStateId() + 1L;\n+    public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener) {\n+        logger.info(\"deleting snapshot [{}] from repository [{}]\", snapshotName, repositoryName);\n+\n+        clusterService.submitStateUpdateTask(\"delete snapshot\", new ClusterStateUpdateTask(Priority.NORMAL) {\n+\n+            Snapshot runningSnapshot;\n+\n+            boolean abortedDuringInit = false;\n+\n+            @Override\n+            public ClusterState execute(ClusterState currentState) {\n+                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n+                SnapshotsInProgress.Entry snapshotEntry = null;\n+                if (snapshots != null) {\n+                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {\n+                        if (entry.repository().equals(repositoryName)\n+                            && entry.snapshot().getSnapshotId().getName().equals(snapshotName)) {\n+                            snapshotEntry = entry;\n+                            break;\n+                        }\n+                    }\n+                }\n+                if (snapshotEntry == null) {\n+                    return currentState;\n                 }\n+                runningSnapshot = snapshotEntry.snapshot();\n+                final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards;\n+\n+                final State state = snapshotEntry.state();\n+                final String failure;\n+                if (state == State.INIT) {\n+                    // snapshot is still initializing, mark it as aborted\n+                    shards = snapshotEntry.shards();\n+                    assert shards.isEmpty();\n+                    failure = \"Snapshot was aborted during initialization\";\n+                    abortedDuringInit = true;\n+                } else if (state == State.STARTED) {\n+                    // snapshot is started - mark every non completed shard as aborted\n+                    final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder();\n+                    for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {\n+                        ShardSnapshotStatus status = shardEntry.value;\n+                        if (status.state().completed() == false) {\n+                            status = new ShardSnapshotStatus(\n+                                status.nodeId(), ShardState.ABORTED, \"aborted by snapshot deletion\", status.generation());\n+                        }\n+                        shardsBuilder.put(shardEntry.key, status);\n+                    }\n+                    shards = shardsBuilder.build();\n+                    failure = \"Snapshot was aborted by deletion\";\n+                } else {\n+                    boolean hasUncompletedShards = false;\n+                    // Cleanup in case a node gone missing and snapshot wasn't updated for some reason\n+                    for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {\n+                        // Check if we still have shard running on existing nodes\n+                        if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null\n+                            && currentState.nodes().get(shardStatus.value.nodeId()) != null) {\n+                            hasUncompletedShards = true;\n+                            break;\n+                        }\n+                    }\n+                    if (hasUncompletedShards) {\n+                        // snapshot is being finalized - wait for shards to complete finalization process\n+                        logger.debug(\"trying to delete completed snapshot - should wait for shards to finalize on all nodes\");\n+                        return currentState;\n+                    } else {\n+                        // no shards to wait for but a node is gone - this is the only case\n+                        // where we force to finish the snapshot\n+                        logger.debug(\"trying to delete completed snapshot with no finalizing shards - can delete immediately\");\n+                        shards = snapshotEntry.shards();\n+                    }\n+                    failure = snapshotEntry.failure();\n+                }\n+                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE,\n+                    new SnapshotsInProgress(new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards, failure))).build();\n+            }\n+\n+            @Override\n+            public void onFailure(String source, Exception e) {\n+                listener.onFailure(e);\n             }\n-            if (matchedEntry.isPresent() == false) {\n-                throw new SnapshotMissingException(repositoryName, snapshotName);\n+\n+            @Override\n+            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n+                if (runningSnapshot == null) {\n+                    tryDeleteExisting(Priority.NORMAL);\n+                    return;\n+                }\n+                logger.trace(\"adding snapshot completion listener to wait for deleted snapshot to finish\");\n+                addListener(runningSnapshot, ActionListener.wrap(\n+                    snapshotInfo -> {\n+                        logger.debug(\"deleted snapshot completed - deleting files\");\n+                        tryDeleteExisting(Priority.IMMEDIATE);\n+                    },\n+                    e -> {\n+                        if (abortedDuringInit) {\n+                            logger.debug(() -> new ParameterizedMessage(\"Snapshot [{}] was aborted during INIT\", runningSnapshot), e);\n+                            listener.onResponse(null);\n+                        } else {\n+                            if (ExceptionsHelper.unwrap(e, NotMasterException.class, FailedToCommitClusterStateException.class)\n+                                != null) {\n+                                logger.warn(\"master failover before deleted snapshot could complete\", e);\n+                                // Just pass the exception to the transport handler as is so it is retried on the new master\n+                                listener.onFailure(e);\n+                            } else {\n+                                logger.warn(\"deleted snapshot failed\", e);\n+                                listener.onFailure(\n+                                    new SnapshotMissingException(runningSnapshot.getRepository(), runningSnapshot.getSnapshotId(), e));\n+                            }\n+                        }\n+                    }\n+                ));\n             }\n-            deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repoGenId, immediatePriority);\n-        }, listener::onFailure));\n+\n+            private void tryDeleteExisting(Priority priority) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0cdd17a1869f684b169a427ee5686dd21652f6b"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkwNjIwMQ==", "bodyText": "I mainly put it here to make it perfectly clear that we're only running this after trying to abort.  Also, we have the logic around the runningSnapshot field here so we can still log the Waited for snapshot ... warning. To me it just gets more confusing if we pull that to the top level because annoyingly enough it's still somewhat connected logically to what happened during the CS update.", "url": "https://github.com/elastic/elasticsearch/pull/54765#discussion_r403906201", "createdAt": "2020-04-06T08:15:00Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -970,61 +970,168 @@ private void failSnapshotCompletionListeners(Snapshot snapshot, Exception e) {\n     }\n \n     /**\n-     * Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting.\n-     * If the snapshot is still running cancels the snapshot first and then deletes it from the repository.\n+     * Deletes a snapshot from the repository or aborts a running snapshot.\n+     * First checks if the snapshot is still running and if so cancels the snapshot and then deletes it from the repository.\n+     * If the snapshot is not running, moves to trying to find a matching {@link Snapshot} for the given name in the repository and if\n+     * one is found deletes it by invoking {@link #deleteCompletedSnapshot}.\n      *\n      * @param repositoryName  repositoryName\n      * @param snapshotName    snapshotName\n      * @param listener        listener\n      */\n-    public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,\n-                               final boolean immediatePriority) {\n-        // First, look for the snapshot in the repository\n-        final Repository repository = repositoriesService.repository(repositoryName);\n-        repository.getRepositoryData(ActionListener.wrap(repositoryData -> {\n-            Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()\n-                .stream()\n-                .filter(s -> s.getName().equals(snapshotName))\n-                .findFirst();\n-            // if nothing found by the same name, then look in the cluster state for current in progress snapshots\n-            long repoGenId = repositoryData.getGenId();\n-            if (matchedEntry.isPresent() == false) {\n-                Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(\n-                    clusterService.state().custom(SnapshotsInProgress.TYPE), repositoryName, Collections.emptyList()).stream()\n-                    .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst();\n-                if (matchedInProgress.isPresent()) {\n-                    matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId());\n-                    // Derive repository generation if a snapshot is in progress because it will increment the generation when it finishes\n-                    repoGenId = matchedInProgress.get().repositoryStateId() + 1L;\n+    public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener) {\n+        logger.info(\"deleting snapshot [{}] from repository [{}]\", snapshotName, repositoryName);\n+\n+        clusterService.submitStateUpdateTask(\"delete snapshot\", new ClusterStateUpdateTask(Priority.NORMAL) {\n+\n+            Snapshot runningSnapshot;\n+\n+            boolean abortedDuringInit = false;\n+\n+            @Override\n+            public ClusterState execute(ClusterState currentState) {\n+                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n+                SnapshotsInProgress.Entry snapshotEntry = null;\n+                if (snapshots != null) {\n+                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {\n+                        if (entry.repository().equals(repositoryName)\n+                            && entry.snapshot().getSnapshotId().getName().equals(snapshotName)) {\n+                            snapshotEntry = entry;\n+                            break;\n+                        }\n+                    }\n+                }\n+                if (snapshotEntry == null) {\n+                    return currentState;\n                 }\n+                runningSnapshot = snapshotEntry.snapshot();\n+                final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards;\n+\n+                final State state = snapshotEntry.state();\n+                final String failure;\n+                if (state == State.INIT) {\n+                    // snapshot is still initializing, mark it as aborted\n+                    shards = snapshotEntry.shards();\n+                    assert shards.isEmpty();\n+                    failure = \"Snapshot was aborted during initialization\";\n+                    abortedDuringInit = true;\n+                } else if (state == State.STARTED) {\n+                    // snapshot is started - mark every non completed shard as aborted\n+                    final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder();\n+                    for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {\n+                        ShardSnapshotStatus status = shardEntry.value;\n+                        if (status.state().completed() == false) {\n+                            status = new ShardSnapshotStatus(\n+                                status.nodeId(), ShardState.ABORTED, \"aborted by snapshot deletion\", status.generation());\n+                        }\n+                        shardsBuilder.put(shardEntry.key, status);\n+                    }\n+                    shards = shardsBuilder.build();\n+                    failure = \"Snapshot was aborted by deletion\";\n+                } else {\n+                    boolean hasUncompletedShards = false;\n+                    // Cleanup in case a node gone missing and snapshot wasn't updated for some reason\n+                    for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {\n+                        // Check if we still have shard running on existing nodes\n+                        if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null\n+                            && currentState.nodes().get(shardStatus.value.nodeId()) != null) {\n+                            hasUncompletedShards = true;\n+                            break;\n+                        }\n+                    }\n+                    if (hasUncompletedShards) {\n+                        // snapshot is being finalized - wait for shards to complete finalization process\n+                        logger.debug(\"trying to delete completed snapshot - should wait for shards to finalize on all nodes\");\n+                        return currentState;\n+                    } else {\n+                        // no shards to wait for but a node is gone - this is the only case\n+                        // where we force to finish the snapshot\n+                        logger.debug(\"trying to delete completed snapshot with no finalizing shards - can delete immediately\");\n+                        shards = snapshotEntry.shards();\n+                    }\n+                    failure = snapshotEntry.failure();\n+                }\n+                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE,\n+                    new SnapshotsInProgress(new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards, failure))).build();\n+            }\n+\n+            @Override\n+            public void onFailure(String source, Exception e) {\n+                listener.onFailure(e);\n             }\n-            if (matchedEntry.isPresent() == false) {\n-                throw new SnapshotMissingException(repositoryName, snapshotName);\n+\n+            @Override\n+            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n+                if (runningSnapshot == null) {\n+                    tryDeleteExisting(Priority.NORMAL);\n+                    return;\n+                }\n+                logger.trace(\"adding snapshot completion listener to wait for deleted snapshot to finish\");\n+                addListener(runningSnapshot, ActionListener.wrap(\n+                    snapshotInfo -> {\n+                        logger.debug(\"deleted snapshot completed - deleting files\");\n+                        tryDeleteExisting(Priority.IMMEDIATE);\n+                    },\n+                    e -> {\n+                        if (abortedDuringInit) {\n+                            logger.debug(() -> new ParameterizedMessage(\"Snapshot [{}] was aborted during INIT\", runningSnapshot), e);\n+                            listener.onResponse(null);\n+                        } else {\n+                            if (ExceptionsHelper.unwrap(e, NotMasterException.class, FailedToCommitClusterStateException.class)\n+                                != null) {\n+                                logger.warn(\"master failover before deleted snapshot could complete\", e);\n+                                // Just pass the exception to the transport handler as is so it is retried on the new master\n+                                listener.onFailure(e);\n+                            } else {\n+                                logger.warn(\"deleted snapshot failed\", e);\n+                                listener.onFailure(\n+                                    new SnapshotMissingException(runningSnapshot.getRepository(), runningSnapshot.getSnapshotId(), e));\n+                            }\n+                        }\n+                    }\n+                ));\n             }\n-            deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repoGenId, immediatePriority);\n-        }, listener::onFailure));\n+\n+            private void tryDeleteExisting(Priority priority) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg3NTY0Mw=="}, "originalCommit": {"oid": "a0cdd17a1869f684b169a427ee5686dd21652f6b"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjA4MzQ0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzoyMzowOFrOGBKxUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzoyMzowOFrOGBKxUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg3ODIyNA==", "bodyText": "same here as before, let's preserve other deletions", "url": "https://github.com/elastic/elasticsearch/pull/54765#discussion_r403878224", "createdAt": "2020-04-06T07:23:08Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1050,81 +1157,15 @@ public ClusterState execute(ClusterState currentState) {\n                         }\n                     }\n                 }\n-                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState);\n                 SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n-                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null;\n-                if (snapshotEntry == null) {\n-                    // This snapshot is not running - delete\n-                    if (snapshots != null && !snapshots.entries().isEmpty()) {\n-                        // However other snapshots are running - cannot continue\n-                        throw new ConcurrentSnapshotExecutionException(snapshot, \"another snapshot is currently running cannot delete\");\n-                    }\n-                    // add the snapshot deletion to the cluster state\n-                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(\n-                        snapshot,\n-                        threadPool.absoluteTimeInMillis(),\n-                        repositoryStateId\n-                    );\n-                    if (deletionsInProgress != null) {\n-                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry);\n-                    } else {\n-                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry);\n-                    }\n-                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress);\n-                } else {\n-                    // This snapshot is currently running - stopping shards first\n-                    waitForSnapshot = true;\n-\n-                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards;\n-\n-                    final State state = snapshotEntry.state();\n-                    final String failure;\n-                    if (state == State.INIT) {\n-                        // snapshot is still initializing, mark it as aborted\n-                        shards = snapshotEntry.shards();\n-                        assert shards.isEmpty();\n-                        failure = \"Snapshot was aborted during initialization\";\n-                        abortedDuringInit = true;\n-                    } else if (state == State.STARTED) {\n-                        // snapshot is started - mark every non completed shard as aborted\n-                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder();\n-                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {\n-                            ShardSnapshotStatus status = shardEntry.value;\n-                            if (status.state().completed() == false) {\n-                                status = new ShardSnapshotStatus(\n-                                    status.nodeId(), ShardState.ABORTED, \"aborted by snapshot deletion\", status.generation());\n-                            }\n-                            shardsBuilder.put(shardEntry.key, status);\n-                        }\n-                        shards = shardsBuilder.build();\n-                        failure = \"Snapshot was aborted by deletion\";\n-                    } else {\n-                        boolean hasUncompletedShards = false;\n-                        // Cleanup in case a node gone missing and snapshot wasn't updated for some reason\n-                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {\n-                            // Check if we still have shard running on existing nodes\n-                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null\n-                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {\n-                                hasUncompletedShards = true;\n-                                break;\n-                            }\n-                        }\n-                        if (hasUncompletedShards) {\n-                            // snapshot is being finalized - wait for shards to complete finalization process\n-                            logger.debug(\"trying to delete completed snapshot - should wait for shards to finalize on all nodes\");\n-                            return currentState;\n-                        } else {\n-                            // no shards to wait for but a node is gone - this is the only case\n-                            // where we force to finish the snapshot\n-                            logger.debug(\"trying to delete completed snapshot with no finalizing shards - can delete immediately\");\n-                            shards = snapshotEntry.shards();\n-                        }\n-                        failure = snapshotEntry.failure();\n-                    }\n-                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards, failure);\n-                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(newSnapshot));\n+                if (snapshots != null && snapshots.entries().isEmpty() == false) {\n+                    // However other snapshots are running - cannot continue\n+                    throw new ConcurrentSnapshotExecutionException(snapshot, \"another snapshot is currently running cannot delete\");\n                 }\n-                return clusterStateBuilder.build();\n+                // add the snapshot deletion to the cluster state\n+                return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0cdd17a1869f684b169a427ee5686dd21652f6b"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjU1NDIzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwOToyOTowNlrOGBPQMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwOToyOTowNlrOGBPQMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk1MTY2Nw==", "bodyText": "there is also a list construcutor, so no need for the array conversion.", "url": "https://github.com/elastic/elasticsearch/pull/54765#discussion_r403951667", "createdAt": "2020-04-06T09:29:06Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1042,7 +1043,12 @@ public ClusterState execute(ClusterState currentState) {\n                     failure = snapshotEntry.failure();\n                 }\n                 return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE,\n-                    new SnapshotsInProgress(new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards, failure))).build();\n+                    new SnapshotsInProgress(snapshots.entries().stream().map(existing -> {\n+                        if (existing.equals(snapshotEntry)) {\n+                            return new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards, failure);\n+                        }\n+                        return existing;\n+                    }).toArray(SnapshotsInProgress.Entry[]::new))).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecd90a56cd099a6427d038b1a7d9ebd0d2180b60"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1346, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}