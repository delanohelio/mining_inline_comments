{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4NzYxMDUy", "number": 56842, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxOToxOTozN1rOD8_SAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo1MDoyMFrOD9iBeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1Mjc3OTU0OnYy", "diffSide": "LEFT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxOToxOTozN1rOGWRElQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxOToxOTozN1rOGWRElQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwMTU1Nw==", "bodyText": "@andreidan I had to remove this wrapping because the simulated documents came back with the _doc parameter in the mappings, and they can't be sent as new component or index templates with _doc in the mappings", "url": "https://github.com/elastic/elasticsearch/pull/56842#discussion_r426001557", "createdAt": "2020-05-15T19:19:37Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "diffHunk": "@@ -99,30 +98,51 @@ protected SimulateIndexTemplateResponse read(StreamInput in) throws IOException\n     @Override\n     protected void masterOperation(Task task, SimulateIndexTemplateRequest request, ClusterState state,\n                                    ActionListener<SimulateIndexTemplateResponse> listener) throws Exception {\n-        ClusterState simulateOnClusterState = state;\n+        final ClusterState stateWithTemplate;\n         if (request.getIndexTemplateRequest() != null) {\n             // we'll \"locally\" add the template defined by the user in the cluster state (as if it existed in the system)\n-            String simulateTemplateToAdd = \"simulate_new_template_\" + UUIDs.randomBase64UUID().toLowerCase(Locale.ROOT);\n-            simulateOnClusterState = indexTemplateService.addIndexTemplateV2(state, request.getIndexTemplateRequest().create(),\n+            String simulateTemplateToAdd = \"simulate_index_template_\" + UUIDs.randomBase64UUID().toLowerCase(Locale.ROOT);\n+            // Perform validation for things like typos in component template names\n+            MetadataIndexTemplateService.validateV2TemplateRequest(state.metadata(), simulateTemplateToAdd,\n+                request.getIndexTemplateRequest().indexTemplate());\n+            stateWithTemplate = indexTemplateService.addIndexTemplateV2(state, request.getIndexTemplateRequest().create(),\n                 simulateTemplateToAdd, request.getIndexTemplateRequest().indexTemplate());\n+        } else {\n+            stateWithTemplate = state;\n         }\n \n-        String matchingTemplate = findV2Template(simulateOnClusterState.metadata(), request.getIndexName(), false);\n+        String matchingTemplate = findV2Template(stateWithTemplate.metadata(), request.getIndexName(), false);\n         if (matchingTemplate == null) {\n             listener.onResponse(new SimulateIndexTemplateResponse(null, null));\n             return;\n         }\n-        Settings settings = resolveSettings(simulateOnClusterState.metadata(), matchingTemplate);\n \n-        // empty request mapping as the user can't specify any explicit mappings via the simulate api\n-        Map<String, Object> mappings = resolveV2Mappings(\"{}\", simulateOnClusterState, matchingTemplate, xContentRegistry);\n-        String mappingsJson = Strings.toString(XContentFactory.jsonBuilder()\n-            .startObject()\n-            .field(MapperService.SINGLE_MAPPING_NAME, mappings)\n-            .endObject());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "581d635cad4aca06996a84c06cb6579e35a2aa69"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NjI2MzY4OnYy", "diffSide": "RIGHT", "path": "docs/reference/indices/index-templates.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwOTo0Nzo0N1rOGWvqvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwOTo0Nzo0N1rOGWvqvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUwMjg0NQ==", "bodyText": "Should we also include the merged templates to illustrate the index template composition? (ie. the result of the _simulate* calls?)", "url": "https://github.com/elastic/elasticsearch/pull/56842#discussion_r426502845", "createdAt": "2020-05-18T09:47:47Z", "author": {"login": "andreidan"}, "path": "docs/reference/indices/index-templates.asciidoc", "diffHunk": "@@ -291,6 +291,96 @@ PUT /_index_template/template_1\n In this case, an index matching `t*` will have three primary shards. If the order of composed\n templates were reversed, the index would have two primary shards.\n \n+\n+[[simulating-templates]]\n+===== Simulating template composition\n+\n+Since templates can be composed not only of multiple component templates, but also the index\n+template itself, there are two simulation APIs to determine what the resulting index settings will\n+be.\n+\n+To simulate the settings that would be applied to a matching index name:\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_index_template/_simulate_index/myindex\n+--------------------------------------------------\n+\n+To simulate the settings that would be applied from a particular template:\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_index_template/_simulate/template_1\n+\n+POST /_index_template/_simulate\n+{\n+  \"index_patterns\": [\"foo\"],\n+  \"template\": {\n+    \"settings\": {\n+      \"number_of_replicas\": 0\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+\n+Here's an example demonstrating simulating both an index name and template name:\n+\n+[source,console]\n+--------------------------------------------------\n+PUT /_component_template/ct1 <1>\n+{\n+  \"template\": {\n+    \"settings\": {\n+      \"index.number_of_shards\": 2\n+    }\n+  }\n+}\n+\n+PUT /_component_template/ct2 <2>\n+{\n+  \"template\": {\n+    \"settings\": {\n+      \"index.number_of_replicas\": 0\n+    },\n+    \"mappings\": {\n+      \"properties\": {\n+        \"@timestamp\": {\n+          \"type\": \"date\"\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+PUT /_index_template/final-template <3>\n+{\n+  \"index_patterns\": [\"logdata-*\"],\n+  \"composed_of\": [\"ct1\", \"ct2\"],\n+  \"priority\": 5\n+}\n+\n+POST /_index_template/_simulate_index/logdata-2019-02-01 <4>\n+\n+POST /_index_template/_simulate/final-template <5>\n+\n+POST /_index_template/_simulate <6>\n+{\n+  \"index_patterns\": [\"mydata-*\"],\n+  \"composed_of\": [\"ct2\"],\n+  \"priority\": 10\n+}\n+--------------------------------------------------\n+<1> Creating a component template (ct1) setting the number of shards to two\n+<2> Creating another component template (ct2) setting the number of replicas to zero with mappings\n+<3> Creating an index template called \"final\" template using ct1 and ct2\n+<4> Simulate the settings that would be applied for a new index \"logdata-2019-02-01\"\n+<5> Simulate the settings composed using the \"final-template\" index template\n+<6> Simulate the settings composed using a custom specified template\n+\n+When simulating a template and specifying a template in the body of the request, the simulated\n+template is not added to the existing templates, it is only used for the simulation.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ff715f461fc3f79babeec70b0977c717ceacb52"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NjM3NDQ5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateTemplateAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMDoxNzo0NVrOGWwwaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMDoxNzo0NVrOGWwwaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUyMDY4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        listener.onFailure(new IllegalArgumentException(\"unable to find a matching template\"));\n          \n          \n            \n                        listener.onFailure(new IllegalArgumentException(\"a template name to match or a new template body must be specified\"));", "url": "https://github.com/elastic/elasticsearch/pull/56842#discussion_r426520683", "createdAt": "2020-05-18T10:17:45Z", "author": {"login": "andreidan"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateTemplateAction.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeReadAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.AliasValidator;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.IndexTemplateV2;\n+import org.elasticsearch.cluster.metadata.MetadataIndexTemplateService;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV1Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV2Templates;\n+\n+/**\n+ * Handles simulating an index template either by name (looking it up in the\n+ * cluster state), or by a provided template configuration\n+ */\n+public class TransportSimulateTemplateAction\n+    extends TransportMasterNodeReadAction<SimulateTemplateAction.Request, SimulateIndexTemplateResponse> {\n+\n+    private final MetadataIndexTemplateService indexTemplateService;\n+    private final NamedXContentRegistry xContentRegistry;\n+    private final IndicesService indicesService;\n+    private AliasValidator aliasValidator;\n+\n+    @Inject\n+    public TransportSimulateTemplateAction(TransportService transportService, ClusterService clusterService,\n+                                           ThreadPool threadPool, MetadataIndexTemplateService indexTemplateService,\n+                                           ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver,\n+                                           NamedXContentRegistry xContentRegistry, IndicesService indicesService) {\n+        super(SimulateTemplateAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            SimulateTemplateAction.Request::new, indexNameExpressionResolver);\n+        this.indexTemplateService = indexTemplateService;\n+        this.xContentRegistry = xContentRegistry;\n+        this.indicesService = indicesService;\n+        this.aliasValidator = new AliasValidator();\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        return ThreadPool.Names.SAME;\n+    }\n+\n+    @Override\n+    protected SimulateIndexTemplateResponse read(StreamInput in) throws IOException {\n+        return new SimulateIndexTemplateResponse(in);\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, SimulateTemplateAction.Request request, ClusterState state,\n+                                   ActionListener<SimulateIndexTemplateResponse> listener) throws Exception {\n+        String uuid = UUIDs.randomBase64UUID().toLowerCase(Locale.ROOT);\n+        final String temporaryIndexName = \"simulate_template_index_\" + uuid;\n+        final ClusterState stateWithTemplate;\n+        final String simulateTemplateToAdd;\n+\n+        // First, if a template body was requested, we need to \"fake add\" that template to the\n+        // cluster state, so it can be used when we resolved settings/etc\n+        if (request.getIndexTemplateRequest() != null) {\n+            // we'll \"locally\" add the template defined by the user in the cluster state (as if it existed in the system)\n+            simulateTemplateToAdd = \"simulate_template_\" + uuid;\n+            // Perform validation for things like typos in component template names\n+            MetadataIndexTemplateService.validateV2TemplateRequest(state.metadata(), simulateTemplateToAdd,\n+                request.getIndexTemplateRequest().indexTemplate());\n+            stateWithTemplate = indexTemplateService.addIndexTemplateV2(state, request.getIndexTemplateRequest().create(),\n+                simulateTemplateToAdd, request.getIndexTemplateRequest().indexTemplate());\n+        } else {\n+            simulateTemplateToAdd = null;\n+            stateWithTemplate = state;\n+        }\n+\n+        // We also need the name of the template we're going to resolve, so if they specified a\n+        // name, use that, otherwise use the name of the template that was \"fake added\" in the previous block\n+        final String matchingTemplate;\n+        if (request.getTemplateName() == null) {\n+            // Automatically match the template that was added\n+            matchingTemplate = simulateTemplateToAdd;\n+        } else {\n+            matchingTemplate = request.getTemplateName();\n+        }\n+\n+        // If they didn't either specify a name that existed or a template body, we cannot simulate anything!\n+        if (matchingTemplate == null) {\n+            // They should have specified either a template name or the body of a template, but neither were specified\n+            listener.onFailure(new IllegalArgumentException(\"unable to find a matching template\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ff715f461fc3f79babeec70b0977c717ceacb52"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODQ3MTYwOnYy", "diffSide": "RIGHT", "path": "docs/reference/indices/index-templates.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo1MDoyMFrOGXFU4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo1MDoyMFrOGXFU4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1NzY5OQ==", "bodyText": "I think it's worth explaining why this isn't a composite of number_of_replicas and number_of_shards either inline or linking to some docs that explain the merging strategy we've chosen. Otherwise I can see people being confused and possibly thinking this is a typo.", "url": "https://github.com/elastic/elasticsearch/pull/56842#discussion_r426857699", "createdAt": "2020-05-18T19:50:20Z", "author": {"login": "cjcenizal"}, "path": "docs/reference/indices/index-templates.asciidoc", "diffHunk": "@@ -291,6 +291,127 @@ PUT /_index_template/template_1\n In this case, an index matching `t*` will have three primary shards. If the order of composed\n templates were reversed, the index would have two primary shards.\n \n+\n+[[simulating-templates]]\n+===== Simulating template composition\n+\n+Since templates can be composed not only of multiple component templates, but also the index\n+template itself, there are two simulation APIs to determine what the resulting index settings will\n+be.\n+\n+To simulate the settings that would be applied to a matching index name:\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_index_template/_simulate_index/myindex\n+--------------------------------------------------\n+\n+To simulate the settings that would be applied from a particular template:\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_index_template/_simulate/template_1\n+\n+POST /_index_template/_simulate\n+{\n+  \"index_patterns\": [\"foo\"],\n+  \"template\": {\n+    \"settings\": {\n+      \"number_of_replicas\": 0\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+\n+Here's an example demonstrating simulating both an index name and template name:\n+\n+[source,console]\n+--------------------------------------------------\n+PUT /_component_template/ct1 <1>\n+{\n+  \"template\": {\n+    \"settings\": {\n+      \"index.number_of_shards\": 2\n+    }\n+  }\n+}\n+\n+PUT /_component_template/ct2 <2>\n+{\n+  \"template\": {\n+    \"settings\": {\n+      \"index.number_of_replicas\": 0\n+    },\n+    \"mappings\": {\n+      \"properties\": {\n+        \"@timestamp\": {\n+          \"type\": \"date\"\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+PUT /_index_template/final-template <3>\n+{\n+  \"index_patterns\": [\"logdata-*\"],\n+  \"composed_of\": [\"ct1\", \"ct2\"],\n+  \"priority\": 5\n+}\n+\n+POST /_index_template/_simulate_index/logdata-2019-02-01 <4>\n+\n+POST /_index_template/_simulate/final-template <5>\n+\n+POST /_index_template/_simulate <6>\n+{\n+  \"index_patterns\": [\"logdata-*\"],\n+  \"composed_of\": [\"ct2\"],\n+  \"priority\": 10\n+}\n+--------------------------------------------------\n+<1> Creating a component template (ct1) setting the number of shards to two\n+<2> Creating another component template (ct2) setting the number of replicas to zero with mappings\n+<3> Creating an index template called \"final\" template using ct1 and ct2\n+<4> Simulate the settings that would be applied for a new index \"logdata-2019-02-01\"\n+<5> Simulate the settings composed using the \"final-template\" index template\n+<6> Simulate the settings composed using a custom specified template\n+\n+The output of the simulate API looks like:\n+\n+[source,console-result]\n+---------------------------------------------------------\n+{\n+  \"template\" : {\n+    \"settings\" : {\n+      \"index\" : {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f0c4ca6372f2c3ee2165a240b5cc411db730642"}, "originalPosition": 107}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 311, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}