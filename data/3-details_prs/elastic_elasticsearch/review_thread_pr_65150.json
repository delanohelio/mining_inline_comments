{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyNTQwOTI4", "number": 65150, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMToxODozMlrOE6TYcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMjozNTo1NFrOE7hgKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTcwNDE5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/UrlPartsProcessor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMToxODozMlrOH1SCQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzoyNjo0MVrOH15BbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzMjA2NA==", "bodyText": "Are there limitations on which schemes that this can parse? Would these parse?\n\nftp://ftp.is.co.za/rfc/rfc1808.txt\nldap://[2001:db8::7]/c=GB?objectClass?one\ntelnet://192.0.2.16:80/\n\nPerhaps using java.net.URI would be more forgiving and not require a URLStreamHandler to be loaded.", "url": "https://github.com/elastic/elasticsearch/pull/65150#discussion_r525632064", "createdAt": "2020-11-18T01:18:32Z", "author": {"login": "andrewkroh"}, "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/UrlPartsProcessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ingest;\n+\n+import org.elasticsearch.ingest.AbstractProcessor;\n+import org.elasticsearch.ingest.ConfigurationUtils;\n+import org.elasticsearch.ingest.IngestDocument;\n+import org.elasticsearch.ingest.Processor;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class UrlPartsProcessor extends AbstractProcessor {\n+\n+    public static final String TYPE = \"url_parts\";\n+\n+    private final String field;\n+    private final String targetField;\n+    private final boolean removeIfSuccessful;\n+    private final boolean keepOriginal;\n+\n+    UrlPartsProcessor(String tag, String description, String field, String targetField, boolean removeIfSuccessful, boolean keepOriginal) {\n+        super(tag, description);\n+        this.field = field;\n+        this.targetField = targetField;\n+        this.removeIfSuccessful = removeIfSuccessful;\n+        this.keepOriginal = keepOriginal;\n+    }\n+\n+    public String getField() {\n+        return field;\n+    }\n+\n+    public String getTargetField() {\n+        return targetField;\n+    }\n+\n+    public boolean getRemoveIfSuccessful() {\n+        return removeIfSuccessful;\n+    }\n+\n+    public boolean getKeepOriginal() {\n+        return keepOriginal;\n+    }\n+\n+    @Override\n+    public IngestDocument execute(IngestDocument ingestDocument) throws Exception {\n+        String value = ingestDocument.getFieldValue(field, String.class);\n+\n+        URL url;\n+        try {\n+            url = new URL(value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caf2715201ea493f835e8e013e86dd2cc58de363"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzNzI1Ng==", "bodyText": "Similarly parts of the URL are required for parsing to work?", "url": "https://github.com/elastic/elasticsearch/pull/65150#discussion_r525637256", "createdAt": "2020-11-18T01:34:27Z", "author": {"login": "andrewkroh"}, "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/UrlPartsProcessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ingest;\n+\n+import org.elasticsearch.ingest.AbstractProcessor;\n+import org.elasticsearch.ingest.ConfigurationUtils;\n+import org.elasticsearch.ingest.IngestDocument;\n+import org.elasticsearch.ingest.Processor;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class UrlPartsProcessor extends AbstractProcessor {\n+\n+    public static final String TYPE = \"url_parts\";\n+\n+    private final String field;\n+    private final String targetField;\n+    private final boolean removeIfSuccessful;\n+    private final boolean keepOriginal;\n+\n+    UrlPartsProcessor(String tag, String description, String field, String targetField, boolean removeIfSuccessful, boolean keepOriginal) {\n+        super(tag, description);\n+        this.field = field;\n+        this.targetField = targetField;\n+        this.removeIfSuccessful = removeIfSuccessful;\n+        this.keepOriginal = keepOriginal;\n+    }\n+\n+    public String getField() {\n+        return field;\n+    }\n+\n+    public String getTargetField() {\n+        return targetField;\n+    }\n+\n+    public boolean getRemoveIfSuccessful() {\n+        return removeIfSuccessful;\n+    }\n+\n+    public boolean getKeepOriginal() {\n+        return keepOriginal;\n+    }\n+\n+    @Override\n+    public IngestDocument execute(IngestDocument ingestDocument) throws Exception {\n+        String value = ingestDocument.getFieldValue(field, String.class);\n+\n+        URL url;\n+        try {\n+            url = new URL(value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzMjA2NA=="}, "originalCommit": {"oid": "caf2715201ea493f835e8e013e86dd2cc58de363"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI3MDgyOA==", "bodyText": "@andrewkroh, thanks for looking it over and commenting. I switched over to java.net.URI which does support more schemes including all three of the examples you list above.\nRight now, no parts of a URI are required beyond what java.net.URI needs to construct an instance. Is that what you would prefer?", "url": "https://github.com/elastic/elasticsearch/pull/65150#discussion_r526270828", "createdAt": "2020-11-18T17:26:41Z", "author": {"login": "danhermann"}, "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/UrlPartsProcessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ingest;\n+\n+import org.elasticsearch.ingest.AbstractProcessor;\n+import org.elasticsearch.ingest.ConfigurationUtils;\n+import org.elasticsearch.ingest.IngestDocument;\n+import org.elasticsearch.ingest.Processor;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class UrlPartsProcessor extends AbstractProcessor {\n+\n+    public static final String TYPE = \"url_parts\";\n+\n+    private final String field;\n+    private final String targetField;\n+    private final boolean removeIfSuccessful;\n+    private final boolean keepOriginal;\n+\n+    UrlPartsProcessor(String tag, String description, String field, String targetField, boolean removeIfSuccessful, boolean keepOriginal) {\n+        super(tag, description);\n+        this.field = field;\n+        this.targetField = targetField;\n+        this.removeIfSuccessful = removeIfSuccessful;\n+        this.keepOriginal = keepOriginal;\n+    }\n+\n+    public String getField() {\n+        return field;\n+    }\n+\n+    public String getTargetField() {\n+        return targetField;\n+    }\n+\n+    public boolean getRemoveIfSuccessful() {\n+        return removeIfSuccessful;\n+    }\n+\n+    public boolean getKeepOriginal() {\n+        return keepOriginal;\n+    }\n+\n+    @Override\n+    public IngestDocument execute(IngestDocument ingestDocument) throws Exception {\n+        String value = ingestDocument.getFieldValue(field, String.class);\n+\n+        URL url;\n+        try {\n+            url = new URL(value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzMjA2NA=="}, "originalCommit": {"oid": "caf2715201ea493f835e8e013e86dd2cc58de363"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTcyNjc3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/UrlPartsProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMToyODo0MFrOH1SPZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjo0ODozOFrOH13Q4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzNTQyOQ==", "bodyText": "ECS isn't clear on what's correct here, but what does getHost return for bracked IPv6 addresses?\n@elastic/ecs Should url.domain include the brackets that are required when using IPv6 addresses in URLs? https://www.ietf.org/rfc/rfc2732.txt", "url": "https://github.com/elastic/elasticsearch/pull/65150#discussion_r525635429", "createdAt": "2020-11-18T01:28:40Z", "author": {"login": "andrewkroh"}, "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/UrlPartsProcessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ingest;\n+\n+import org.elasticsearch.ingest.AbstractProcessor;\n+import org.elasticsearch.ingest.ConfigurationUtils;\n+import org.elasticsearch.ingest.IngestDocument;\n+import org.elasticsearch.ingest.Processor;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class UrlPartsProcessor extends AbstractProcessor {\n+\n+    public static final String TYPE = \"url_parts\";\n+\n+    private final String field;\n+    private final String targetField;\n+    private final boolean removeIfSuccessful;\n+    private final boolean keepOriginal;\n+\n+    UrlPartsProcessor(String tag, String description, String field, String targetField, boolean removeIfSuccessful, boolean keepOriginal) {\n+        super(tag, description);\n+        this.field = field;\n+        this.targetField = targetField;\n+        this.removeIfSuccessful = removeIfSuccessful;\n+        this.keepOriginal = keepOriginal;\n+    }\n+\n+    public String getField() {\n+        return field;\n+    }\n+\n+    public String getTargetField() {\n+        return targetField;\n+    }\n+\n+    public boolean getRemoveIfSuccessful() {\n+        return removeIfSuccessful;\n+    }\n+\n+    public boolean getKeepOriginal() {\n+        return keepOriginal;\n+    }\n+\n+    @Override\n+    public IngestDocument execute(IngestDocument ingestDocument) throws Exception {\n+        String value = ingestDocument.getFieldValue(field, String.class);\n+\n+        URL url;\n+        try {\n+            url = new URL(value);\n+        } catch (MalformedURLException e) {\n+            throw new IllegalArgumentException(\"unable to parse URL [\" + value + \"]\");\n+        }\n+        var urlParts = new HashMap<String, Object>();\n+        urlParts.put(\"domain\", url.getHost());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caf2715201ea493f835e8e013e86dd2cc58de363"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI0MjAxOQ==", "bodyText": "Per this source, getHost() will return the IPv6 address enclosed in the brackets.\nSince brackets are required with a literal IPv6 address, url.domain should include the brackets. We can improve the description of url.domain in the ECS docs to clarify.", "url": "https://github.com/elastic/elasticsearch/pull/65150#discussion_r526242019", "createdAt": "2020-11-18T16:48:38Z", "author": {"login": "ebeahan"}, "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/UrlPartsProcessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ingest;\n+\n+import org.elasticsearch.ingest.AbstractProcessor;\n+import org.elasticsearch.ingest.ConfigurationUtils;\n+import org.elasticsearch.ingest.IngestDocument;\n+import org.elasticsearch.ingest.Processor;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class UrlPartsProcessor extends AbstractProcessor {\n+\n+    public static final String TYPE = \"url_parts\";\n+\n+    private final String field;\n+    private final String targetField;\n+    private final boolean removeIfSuccessful;\n+    private final boolean keepOriginal;\n+\n+    UrlPartsProcessor(String tag, String description, String field, String targetField, boolean removeIfSuccessful, boolean keepOriginal) {\n+        super(tag, description);\n+        this.field = field;\n+        this.targetField = targetField;\n+        this.removeIfSuccessful = removeIfSuccessful;\n+        this.keepOriginal = keepOriginal;\n+    }\n+\n+    public String getField() {\n+        return field;\n+    }\n+\n+    public String getTargetField() {\n+        return targetField;\n+    }\n+\n+    public boolean getRemoveIfSuccessful() {\n+        return removeIfSuccessful;\n+    }\n+\n+    public boolean getKeepOriginal() {\n+        return keepOriginal;\n+    }\n+\n+    @Override\n+    public IngestDocument execute(IngestDocument ingestDocument) throws Exception {\n+        String value = ingestDocument.getFieldValue(field, String.class);\n+\n+        URL url;\n+        try {\n+            url = new URL(value);\n+        } catch (MalformedURLException e) {\n+            throw new IllegalArgumentException(\"unable to parse URL [\" + value + \"]\");\n+        }\n+        var urlParts = new HashMap<String, Object>();\n+        urlParts.put(\"domain\", url.getHost());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzNTQyOQ=="}, "originalCommit": {"oid": "caf2715201ea493f835e8e013e86dd2cc58de363"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODUwMzQ3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/UriPartsProcessor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMjozNTo1NFrOH3N_aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDo0Mzo0MFrOH3SlhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY2Mjk1NQ==", "bodyText": "would this fail with IndexOutOfBounds for http://user:@www.google.com:80/blarg.gif#ref ? (no password)\nShall we add a test for this?", "url": "https://github.com/elastic/elasticsearch/pull/65150#discussion_r527662955", "createdAt": "2020-11-20T12:35:54Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/UriPartsProcessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ingest;\n+\n+import org.elasticsearch.ingest.AbstractProcessor;\n+import org.elasticsearch.ingest.ConfigurationUtils;\n+import org.elasticsearch.ingest.IngestDocument;\n+import org.elasticsearch.ingest.Processor;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class UriPartsProcessor extends AbstractProcessor {\n+\n+    public static final String TYPE = \"uri_parts\";\n+\n+    private final String field;\n+    private final String targetField;\n+    private final boolean removeIfSuccessful;\n+    private final boolean keepOriginal;\n+\n+    UriPartsProcessor(String tag, String description, String field, String targetField, boolean removeIfSuccessful, boolean keepOriginal) {\n+        super(tag, description);\n+        this.field = field;\n+        this.targetField = targetField;\n+        this.removeIfSuccessful = removeIfSuccessful;\n+        this.keepOriginal = keepOriginal;\n+    }\n+\n+    public String getField() {\n+        return field;\n+    }\n+\n+    public String getTargetField() {\n+        return targetField;\n+    }\n+\n+    public boolean getRemoveIfSuccessful() {\n+        return removeIfSuccessful;\n+    }\n+\n+    public boolean getKeepOriginal() {\n+        return keepOriginal;\n+    }\n+\n+    @Override\n+    public IngestDocument execute(IngestDocument ingestDocument) throws Exception {\n+        String value = ingestDocument.getFieldValue(field, String.class);\n+\n+        URI uri;\n+        try {\n+            uri = new URI(value);\n+        } catch (URISyntaxException e) {\n+            throw new IllegalArgumentException(\"unable to parse URI [\" + value + \"]\");\n+        }\n+        var uriParts = new HashMap<String, Object>();\n+        uriParts.put(\"domain\", uri.getHost());\n+        if (uri.getFragment() != null) {\n+            uriParts.put(\"fragment\", uri.getFragment());\n+        }\n+        if (keepOriginal) {\n+            uriParts.put(\"original\", value);\n+        }\n+        final String path = uri.getPath();\n+        if (path != null) {\n+            uriParts.put(\"path\", path);\n+            if (path.contains(\".\")) {\n+                int periodIndex = path.lastIndexOf('.');\n+                uriParts.put(\"extension\", periodIndex < path.length() ? path.substring(periodIndex + 1) : \"\");\n+            }\n+        }\n+        if (uri.getPort() != -1) {\n+            uriParts.put(\"port\", uri.getPort());\n+        }\n+        if (uri.getQuery() != null) {\n+            uriParts.put(\"query\", uri.getQuery());\n+        }\n+        uriParts.put(\"scheme\", uri.getScheme());\n+        final String userInfo = uri.getUserInfo();\n+        if (userInfo != null) {\n+            uriParts.put(\"user_info\", userInfo);\n+            if (userInfo.contains(\":\")) {\n+                int colonIndex = userInfo.indexOf(\":\");\n+                uriParts.put(\"username\", userInfo.substring(0, colonIndex));\n+                uriParts.put(\"password\", colonIndex < userInfo.length() ? userInfo.substring(colonIndex + 1) : \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b052cb443611b0d00552408350ad7192562ea62"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwNDI1MQ==", "bodyText": "In that case, the password is set to an empty string. I'll add another test case to make that clear.", "url": "https://github.com/elastic/elasticsearch/pull/65150#discussion_r527704251", "createdAt": "2020-11-20T13:53:07Z", "author": {"login": "danhermann"}, "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/UriPartsProcessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ingest;\n+\n+import org.elasticsearch.ingest.AbstractProcessor;\n+import org.elasticsearch.ingest.ConfigurationUtils;\n+import org.elasticsearch.ingest.IngestDocument;\n+import org.elasticsearch.ingest.Processor;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class UriPartsProcessor extends AbstractProcessor {\n+\n+    public static final String TYPE = \"uri_parts\";\n+\n+    private final String field;\n+    private final String targetField;\n+    private final boolean removeIfSuccessful;\n+    private final boolean keepOriginal;\n+\n+    UriPartsProcessor(String tag, String description, String field, String targetField, boolean removeIfSuccessful, boolean keepOriginal) {\n+        super(tag, description);\n+        this.field = field;\n+        this.targetField = targetField;\n+        this.removeIfSuccessful = removeIfSuccessful;\n+        this.keepOriginal = keepOriginal;\n+    }\n+\n+    public String getField() {\n+        return field;\n+    }\n+\n+    public String getTargetField() {\n+        return targetField;\n+    }\n+\n+    public boolean getRemoveIfSuccessful() {\n+        return removeIfSuccessful;\n+    }\n+\n+    public boolean getKeepOriginal() {\n+        return keepOriginal;\n+    }\n+\n+    @Override\n+    public IngestDocument execute(IngestDocument ingestDocument) throws Exception {\n+        String value = ingestDocument.getFieldValue(field, String.class);\n+\n+        URI uri;\n+        try {\n+            uri = new URI(value);\n+        } catch (URISyntaxException e) {\n+            throw new IllegalArgumentException(\"unable to parse URI [\" + value + \"]\");\n+        }\n+        var uriParts = new HashMap<String, Object>();\n+        uriParts.put(\"domain\", uri.getHost());\n+        if (uri.getFragment() != null) {\n+            uriParts.put(\"fragment\", uri.getFragment());\n+        }\n+        if (keepOriginal) {\n+            uriParts.put(\"original\", value);\n+        }\n+        final String path = uri.getPath();\n+        if (path != null) {\n+            uriParts.put(\"path\", path);\n+            if (path.contains(\".\")) {\n+                int periodIndex = path.lastIndexOf('.');\n+                uriParts.put(\"extension\", periodIndex < path.length() ? path.substring(periodIndex + 1) : \"\");\n+            }\n+        }\n+        if (uri.getPort() != -1) {\n+            uriParts.put(\"port\", uri.getPort());\n+        }\n+        if (uri.getQuery() != null) {\n+            uriParts.put(\"query\", uri.getQuery());\n+        }\n+        uriParts.put(\"scheme\", uri.getScheme());\n+        final String userInfo = uri.getUserInfo();\n+        if (userInfo != null) {\n+            uriParts.put(\"user_info\", userInfo);\n+            if (userInfo.contains(\":\")) {\n+                int colonIndex = userInfo.indexOf(\":\");\n+                uriParts.put(\"username\", userInfo.substring(0, colonIndex));\n+                uriParts.put(\"password\", colonIndex < userInfo.length() ? userInfo.substring(colonIndex + 1) : \"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY2Mjk1NQ=="}, "originalCommit": {"oid": "6b052cb443611b0d00552408350ad7192562ea62"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzczODI0NA==", "bodyText": "Thanks for the review, @andreidan!", "url": "https://github.com/elastic/elasticsearch/pull/65150#discussion_r527738244", "createdAt": "2020-11-20T14:43:40Z", "author": {"login": "danhermann"}, "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/UriPartsProcessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ingest;\n+\n+import org.elasticsearch.ingest.AbstractProcessor;\n+import org.elasticsearch.ingest.ConfigurationUtils;\n+import org.elasticsearch.ingest.IngestDocument;\n+import org.elasticsearch.ingest.Processor;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class UriPartsProcessor extends AbstractProcessor {\n+\n+    public static final String TYPE = \"uri_parts\";\n+\n+    private final String field;\n+    private final String targetField;\n+    private final boolean removeIfSuccessful;\n+    private final boolean keepOriginal;\n+\n+    UriPartsProcessor(String tag, String description, String field, String targetField, boolean removeIfSuccessful, boolean keepOriginal) {\n+        super(tag, description);\n+        this.field = field;\n+        this.targetField = targetField;\n+        this.removeIfSuccessful = removeIfSuccessful;\n+        this.keepOriginal = keepOriginal;\n+    }\n+\n+    public String getField() {\n+        return field;\n+    }\n+\n+    public String getTargetField() {\n+        return targetField;\n+    }\n+\n+    public boolean getRemoveIfSuccessful() {\n+        return removeIfSuccessful;\n+    }\n+\n+    public boolean getKeepOriginal() {\n+        return keepOriginal;\n+    }\n+\n+    @Override\n+    public IngestDocument execute(IngestDocument ingestDocument) throws Exception {\n+        String value = ingestDocument.getFieldValue(field, String.class);\n+\n+        URI uri;\n+        try {\n+            uri = new URI(value);\n+        } catch (URISyntaxException e) {\n+            throw new IllegalArgumentException(\"unable to parse URI [\" + value + \"]\");\n+        }\n+        var uriParts = new HashMap<String, Object>();\n+        uriParts.put(\"domain\", uri.getHost());\n+        if (uri.getFragment() != null) {\n+            uriParts.put(\"fragment\", uri.getFragment());\n+        }\n+        if (keepOriginal) {\n+            uriParts.put(\"original\", value);\n+        }\n+        final String path = uri.getPath();\n+        if (path != null) {\n+            uriParts.put(\"path\", path);\n+            if (path.contains(\".\")) {\n+                int periodIndex = path.lastIndexOf('.');\n+                uriParts.put(\"extension\", periodIndex < path.length() ? path.substring(periodIndex + 1) : \"\");\n+            }\n+        }\n+        if (uri.getPort() != -1) {\n+            uriParts.put(\"port\", uri.getPort());\n+        }\n+        if (uri.getQuery() != null) {\n+            uriParts.put(\"query\", uri.getQuery());\n+        }\n+        uriParts.put(\"scheme\", uri.getScheme());\n+        final String userInfo = uri.getUserInfo();\n+        if (userInfo != null) {\n+            uriParts.put(\"user_info\", userInfo);\n+            if (userInfo.contains(\":\")) {\n+                int colonIndex = userInfo.indexOf(\":\");\n+                uriParts.put(\"username\", userInfo.substring(0, colonIndex));\n+                uriParts.put(\"password\", colonIndex < userInfo.length() ? userInfo.substring(colonIndex + 1) : \"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY2Mjk1NQ=="}, "originalCommit": {"oid": "6b052cb443611b0d00552408350ad7192562ea62"}, "originalPosition": 91}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2930, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}