{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3NTI4MjU0", "number": 61827, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOToyMDowNVrOEfm8RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjo0Mzo1MlrOEhcIGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTc5MzMyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/rest/action/search/RestSearchAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOToyMDowNVrOHL_EOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOToxNToxMFrOHPWGOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMyOTY1OA==", "bodyText": "I think we should still accept the param if it is set to false ?", "url": "https://github.com/elastic/elasticsearch/pull/61827#discussion_r482329658", "createdAt": "2020-09-02T19:20:05Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/rest/action/search/RestSearchAction.java", "diffHunk": "@@ -308,6 +309,11 @@ static void preparePointInTime(SearchRequest request, NamedWriteableRegistry nam\n         if (request.preference() != null) {\n             validationException = addValidationError(\"[preference] cannot be used with point in time\", validationException);\n         }\n+        if (restRequest.hasParam(\"ccs_minimize_roundtrips\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81d6b49be1c7be37bf2af420555d3a059c156d85"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MjczMA==", "bodyText": "Fixed in 44f14d3", "url": "https://github.com/elastic/elasticsearch/pull/61827#discussion_r485852730", "createdAt": "2020-09-09T19:15:10Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/rest/action/search/RestSearchAction.java", "diffHunk": "@@ -308,6 +309,11 @@ static void preparePointInTime(SearchRequest request, NamedWriteableRegistry nam\n         if (request.preference() != null) {\n             validationException = addValidationError(\"[preference] cannot be used with point in time\", validationException);\n         }\n+        if (restRequest.hasParam(\"ccs_minimize_roundtrips\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMyOTY1OA=="}, "originalCommit": {"oid": "81d6b49be1c7be37bf2af420555d3a059c156d85"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTc5NjE1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/search/action/TransportOpenPointInTimeAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOToyMDozN1rOHL_F-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOToxNzowNFrOHPWKGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMzMDEwNg==", "bodyText": "Why is it needed ?", "url": "https://github.com/elastic/elasticsearch/pull/61827#discussion_r482330106", "createdAt": "2020-09-02T19:20:37Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/search/action/TransportOpenPointInTimeAction.java", "diffHunk": "@@ -72,6 +72,7 @@ protected void doExecute(Task task, OpenPointInTimeRequest request, ActionListen\n             .preference(request.preference())\n             .routing(request.routing())\n             .allowPartialSearchResults(false);\n+        searchRequest.setCcsMinimizeRoundtrips(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81d6b49be1c7be37bf2af420555d3a059c156d85"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MzcyMw==", "bodyText": "We need to disable ccs_minimize_roundtrips because we don't know how to merge a point in time from multiple sub-search requests.", "url": "https://github.com/elastic/elasticsearch/pull/61827#discussion_r485853723", "createdAt": "2020-09-09T19:17:04Z", "author": {"login": "dnhatn"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/search/action/TransportOpenPointInTimeAction.java", "diffHunk": "@@ -72,6 +72,7 @@ protected void doExecute(Task task, OpenPointInTimeRequest request, ActionListen\n             .preference(request.preference())\n             .routing(request.routing())\n             .allowPartialSearchResults(false);\n+        searchRequest.setCcsMinimizeRoundtrips(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMzMDEwNg=="}, "originalCommit": {"oid": "81d6b49be1c7be37bf2af420555d3a059c156d85"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDk5MjkxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjo0Mzo1MlrOHOwZ3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOTowMzo1MlrOHPVtvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzNTE2NA==", "bodyText": "While this is something that we'll need in the future I don't think we can afford adding replicas other than the original one now. There's no chance that the query succeeds there so that's confusing for users (and could faild some tests) if we return a search context missing exception every time there's an exception on the matching node.", "url": "https://github.com/elastic/elasticsearch/pull/61827#discussion_r485235164", "createdAt": "2020-09-08T22:43:52Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java", "diffHunk": "@@ -535,13 +567,33 @@ private void executeLocalSearch(Task task, SearchTimeProvider timeProvider, Sear\n                 remoteShardIterators.add(shardIterator);\n             }\n         }\n-        return (clusterAlias, nodeId) -> {\n-                Map<String, DiscoveryNode> clusterNodes = clusterToNode.get(clusterAlias);\n-                if (clusterNodes == null) {\n-                    throw new IllegalArgumentException(\"unknown remote cluster: \" + clusterAlias);\n+        return remoteShardIterators;\n+    }\n+\n+    static List<SearchShardIterator> getRemoteShardsIteratorFromPointInTime(Map<String, ClusterSearchShardsResponse> searchShardsResponses,\n+                                                                            SearchContextId searchContextId,\n+                                                                            TimeValue searchContextKeepAlive,\n+                                                                            Map<String, OriginalIndices> remoteClusterIndices) {\n+        final List<SearchShardIterator> remoteShardIterators = new ArrayList<>();\n+        for (Map.Entry<String, ClusterSearchShardsResponse> entry : searchShardsResponses.entrySet()) {\n+            for (ClusterSearchShardsGroup group : entry.getValue().getGroups()) {\n+                final ShardId shardId = group.getShardId();\n+                final String clusterAlias = entry.getKey();\n+                final SearchContextIdForNode perNode = searchContextId.shards().get(shardId);\n+                assert clusterAlias.equals(perNode.getClusterAlias()) : clusterAlias + \" != \" + perNode.getClusterAlias();\n+                final List<String> nodeIds = new ArrayList<>();\n+                nodeIds.add(perNode.getNode()); // always search with the matching node first\n+                for (ShardRouting shard : group.getShards()) {\n+                    if (perNode.getNode().equals(shard.currentNodeId()) == false) {\n+                        nodeIds.add(shard.currentNodeId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "293869407ae0e9bcb89c8e93ecc03a0821aa8652"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0NjQ2MQ==", "bodyText": "++. Let's reintroduce this when we implement the retry. See: 0a99df6", "url": "https://github.com/elastic/elasticsearch/pull/61827#discussion_r485846461", "createdAt": "2020-09-09T19:03:52Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java", "diffHunk": "@@ -535,13 +567,33 @@ private void executeLocalSearch(Task task, SearchTimeProvider timeProvider, Sear\n                 remoteShardIterators.add(shardIterator);\n             }\n         }\n-        return (clusterAlias, nodeId) -> {\n-                Map<String, DiscoveryNode> clusterNodes = clusterToNode.get(clusterAlias);\n-                if (clusterNodes == null) {\n-                    throw new IllegalArgumentException(\"unknown remote cluster: \" + clusterAlias);\n+        return remoteShardIterators;\n+    }\n+\n+    static List<SearchShardIterator> getRemoteShardsIteratorFromPointInTime(Map<String, ClusterSearchShardsResponse> searchShardsResponses,\n+                                                                            SearchContextId searchContextId,\n+                                                                            TimeValue searchContextKeepAlive,\n+                                                                            Map<String, OriginalIndices> remoteClusterIndices) {\n+        final List<SearchShardIterator> remoteShardIterators = new ArrayList<>();\n+        for (Map.Entry<String, ClusterSearchShardsResponse> entry : searchShardsResponses.entrySet()) {\n+            for (ClusterSearchShardsGroup group : entry.getValue().getGroups()) {\n+                final ShardId shardId = group.getShardId();\n+                final String clusterAlias = entry.getKey();\n+                final SearchContextIdForNode perNode = searchContextId.shards().get(shardId);\n+                assert clusterAlias.equals(perNode.getClusterAlias()) : clusterAlias + \" != \" + perNode.getClusterAlias();\n+                final List<String> nodeIds = new ArrayList<>();\n+                nodeIds.add(perNode.getNode()); // always search with the matching node first\n+                for (ShardRouting shard : group.getShards()) {\n+                    if (perNode.getNode().equals(shard.currentNodeId()) == false) {\n+                        nodeIds.add(shard.currentNodeId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzNTE2NA=="}, "originalCommit": {"oid": "293869407ae0e9bcb89c8e93ecc03a0821aa8652"}, "originalPosition": 129}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1826, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}