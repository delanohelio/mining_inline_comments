{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0MTkzMTgw", "number": 56291, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNTozMTozNVrOD6Tclg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNTozMjoyNVrOD6Td2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNDYyNjE0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNTozMTozNVrOGSEOig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNTozMTozNVrOGSEOig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU5NjgxMA==", "bodyText": "I think we can encapsulate this logic into a method to make it a bit clearer what's going on, perhaps something like:\nnonProperties = removeDuplicatedDynamicTemplates(nonProperties, innerTemplateNonProperties);\n\nThen the same method can be used below (where these lines are almost identical except for the maps passed in).", "url": "https://github.com/elastic/elasticsearch/pull/56291#discussion_r421596810", "createdAt": "2020-05-07T15:31:35Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -576,6 +577,18 @@ private ClusterState applyCreateIndexRequestWithExistingMetadata(final ClusterSt\n                 Map<String, Object> innerTemplateNonProperties = new HashMap<>(innerTemplateMapping);\n                 Map<String, Object> maybeProperties = (Map<String, Object>) innerTemplateNonProperties.remove(\"properties\");\n \n+                List<Map<String, Object>> innerTemplateDynamicTemplates = (List<Map<String, Object>>) innerTemplateNonProperties.get(\n+                    \"dynamic_templates\");\n+                List<Map<String, Object>> previouslySeenDynamicTemplates =\n+                    (List<Map<String, Object>>) nonProperties.get(\"dynamic_templates\");\n+                // we want \"later\" defined dynamic templates to override the previously seen ones with the same name\n+                List<Map<String, Object>> filteredDefaultDynamicTemplates =\n+                    removeAll(previouslySeenDynamicTemplates, innerTemplateDynamicTemplates);\n+\n+                if (filteredDefaultDynamicTemplates != previouslySeenDynamicTemplates) {\n+                    nonProperties.put(\"dynamic_templates\", filteredDefaultDynamicTemplates);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27b528d8ebf1f8e104a768733d2eb91637d5232a"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNDYyOTM2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNTozMjoyNVrOGSEQoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNTozMjoyNVrOGSEQoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU5NzM0NQ==", "bodyText": "Maybe call this removeOverlapping to make it a bit clearer what it's doing?", "url": "https://github.com/elastic/elasticsearch/pull/56291#discussion_r421597345", "createdAt": "2020-05-07T15:32:25Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -598,11 +623,78 @@ private ClusterState applyCreateIndexRequestWithExistingMetadata(final ClusterSt\n             }\n         }\n \n-        Map<String, Object> finalMappings = new HashMap<>(nonProperties);\n+        Map<String, Object> finalMappings = dedupDynamicTemplates(nonProperties);\n         finalMappings.put(\"properties\", properties);\n         return Collections.singletonMap(MapperService.SINGLE_MAPPING_NAME, finalMappings);\n     }\n \n+    /**\n+     * Removes all the items from the first list that are already present in the second list\n+     *\n+     * Similar to {@link List#removeAll(Collection)} but the list parameters are not modified.\n+     *\n+     * This expects both list values to be Maps of size one and the \"contains\" operation that will determine if a value\n+     * from the second list is present in the first list (and be removed from the first list) is based on key name.\n+     *\n+     * eg.\n+     *      removeAll([ {\"key1\" : {}}, {\"key2\" : {}} ], [ {\"key1\" : {}}, {\"key3\" : {}} ])\n+     * Returns:\n+     *     [ {\"key2\" : {}} ]\n+     */\n+    private static List<Map<String, Object>> removeAll(List<Map<String, Object>> first, List<Map<String, Object>> second) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27b528d8ebf1f8e104a768733d2eb91637d5232a"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 682, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}