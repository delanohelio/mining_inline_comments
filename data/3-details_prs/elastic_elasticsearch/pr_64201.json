{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwNjUxNTk0", "number": 64201, "title": "Add CacheFile#fsync() method to ensure cached data are written on disk", "bodyText": "This pull request adds a new CacheFile.fsync() method to fsync the cache file on disk. This method uses the utility method IOUtils.fsync(Path, boolean) that executes a FileChannel.force() call under the hood.", "createdAt": "2020-10-27T10:41:30Z", "url": "https://github.com/elastic/elasticsearch/pull/64201", "merged": true, "mergeCommit": {"oid": "34fc3033c8a8ceb3f646d0a2c0d488aebf7816a6"}, "closed": true, "closedAt": "2020-11-03T14:08:55Z", "author": {"login": "tlrx"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdWmfHggH2gAyNTEwNjUxNTk0OjMxNDIxMmJhNmYzNjhkNTBkOTk4OTY1OTcwODY0MWU4ZWQ0OTg3ZGU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdY42NpgH2gAyNTEwNjUxNTk0OmQ4ZmRhYWEyYWFiMjVlNzgwMzM5MDZmMmZhOGM5NTZhNmUzNDA0NDE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "314212ba6f368d50d9989659708641e8ed4987de", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/314212ba6f368d50d9989659708641e8ed4987de", "committedDate": "2020-10-27T10:33:57Z", "message": "Add CacheFile#fsync() method to ensure cached data are written on disk"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3NTYxOTE2", "url": "https://github.com/elastic/elasticsearch/pull/64201#pullrequestreview-517561916", "createdAt": "2020-10-27T10:42:26Z", "commit": {"oid": "314212ba6f368d50d9989659708641e8ed4987de"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxMDo0MjoyNlrOHo1kug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxMDo0MjoyNlrOHo1kug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU4Mjg0Mg==", "bodyText": "This method is intended to be called periodically by a task that will fsync all cache files of a given shard before fsyncing the parent directory.", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r512582842", "createdAt": "2020-10-27T10:42:26Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -398,4 +406,52 @@ private FileChannelReference acquireFileChannelReference() {\n         ensureOpen();\n         return tracker.getAbsentRangeWithin(start, end);\n     }\n+\n+    // used in tests\n+    boolean isFSynced() {\n+        return fsynced.get();\n+    }\n+\n+    /**\n+     * Ensure that all ranges of data written to the cache file are written to the storage device that contains it. This method returns the\n+     * list of all successfully written ranges of data since the creation of the cache file.\n+     *\n+     * @return the list of ranges of data available in cache at the time this method is invoked\n+     * @throws IOException                       if the cache file failed to be fsync\n+     * @throws AlreadyClosedException            if the cache file is evicted\n+     * @throws java.nio.file.NoSuchFileException if the cache file does not exist\n+     */\n+    public List<Tuple<Long, Long>> fsync() throws IOException {\n+        ensureOpen();\n+        if (refCounter.tryIncRef()) {\n+            try {\n+                // Capture the completed ranges before fsyncing; ranges that are completed after this point won't be considered as\n+                // persisted on disk by the caller of this method, even if they are fully written to disk at the time the file\n+                // fsync is effectively executed\n+                final List<Tuple<Long, Long>> completedRanges = tracker.getCompletedRanges();\n+                assert completedRanges != null;\n+\n+                if (fsynced.compareAndSet(false, true)) {\n+                    boolean success = false;\n+                    try {\n+                        // check again if the file is evicted before doing expensive I/O\n+                        ensureOpen();\n+                        IOUtils.fsync(file, false); // TODO don't forget to fsync parent directory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "314212ba6f368d50d9989659708641e8ed4987de"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3NjA0MzI2", "url": "https://github.com/elastic/elasticsearch/pull/64201#pullrequestreview-517604326", "createdAt": "2020-10-27T11:35:01Z", "commit": {"oid": "314212ba6f368d50d9989659708641e8ed4987de"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxMTozNTowMVrOHo3pYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxMjoyMzo0MFrOHo5jXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYxNjgwMA==", "bodyText": "I wonder, can't we just call force on the file channel that we already have open if we have one and avoid fsync if we don't have one by fsyncing before closing the channel (would have to enhance acquireFileChannelReference to return null in case there's no eviction listeners on the current instance I guess)? No need to get a new file descriptor here maybe is there?", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r512616800", "createdAt": "2020-10-27T11:35:01Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -398,4 +406,52 @@ private FileChannelReference acquireFileChannelReference() {\n         ensureOpen();\n         return tracker.getAbsentRangeWithin(start, end);\n     }\n+\n+    // used in tests\n+    boolean isFSynced() {\n+        return fsynced.get();\n+    }\n+\n+    /**\n+     * Ensure that all ranges of data written to the cache file are written to the storage device that contains it. This method returns the\n+     * list of all successfully written ranges of data since the creation of the cache file.\n+     *\n+     * @return the list of ranges of data available in cache at the time this method is invoked\n+     * @throws IOException                       if the cache file failed to be fsync\n+     * @throws AlreadyClosedException            if the cache file is evicted\n+     * @throws java.nio.file.NoSuchFileException if the cache file does not exist\n+     */\n+    public List<Tuple<Long, Long>> fsync() throws IOException {\n+        ensureOpen();\n+        if (refCounter.tryIncRef()) {\n+            try {\n+                // Capture the completed ranges before fsyncing; ranges that are completed after this point won't be considered as\n+                // persisted on disk by the caller of this method, even if they are fully written to disk at the time the file\n+                // fsync is effectively executed\n+                final List<Tuple<Long, Long>> completedRanges = tracker.getCompletedRanges();\n+                assert completedRanges != null;\n+\n+                if (fsynced.compareAndSet(false, true)) {\n+                    boolean success = false;\n+                    try {\n+                        // check again if the file is evicted before doing expensive I/O\n+                        ensureOpen();\n+                        IOUtils.fsync(file, false); // TODO don't forget to fsync parent directory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "314212ba6f368d50d9989659708641e8ed4987de"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY0ODAyOA==", "bodyText": "Might be better to set this false as early as possible (i.e. directly after the write to the file) to reduce contention statistically speaking? (since fsync and write will always be blocking each other anyway even if we do use multiple FileChannel instances I think).", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r512648028", "createdAt": "2020-10-27T12:23:40Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -305,6 +312,7 @@ protected void doRun() throws Exception {\n                             reference.decRef();\n                         }\n                         gap.onCompletion();\n+                        fsynced.set(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "314212ba6f368d50d9989659708641e8ed4987de"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3NjY1NDg4", "url": "https://github.com/elastic/elasticsearch/pull/64201#pullrequestreview-517665488", "createdAt": "2020-10-27T12:50:35Z", "commit": {"oid": "314212ba6f368d50d9989659708641e8ed4987de"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NjE0MDcz", "url": "https://github.com/elastic/elasticsearch/pull/64201#pullrequestreview-518614073", "createdAt": "2020-10-28T12:38:39Z", "commit": {"oid": "314212ba6f368d50d9989659708641e8ed4987de"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMjozODozOVrOHpn9og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMzoxMzo0MlrOHppUzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQwODQxOA==", "bodyText": "I think there is an assumption of only ever going here in one thread, since otherwise we risk a concurrent thread seeing the completedRanges. I think that is fair, but perhaps for safety we should either lock the entire method or assert something to capture this?", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r513408418", "createdAt": "2020-10-28T12:38:39Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -398,4 +406,52 @@ private FileChannelReference acquireFileChannelReference() {\n         ensureOpen();\n         return tracker.getAbsentRangeWithin(start, end);\n     }\n+\n+    // used in tests\n+    boolean isFSynced() {\n+        return fsynced.get();\n+    }\n+\n+    /**\n+     * Ensure that all ranges of data written to the cache file are written to the storage device that contains it. This method returns the\n+     * list of all successfully written ranges of data since the creation of the cache file.\n+     *\n+     * @return the list of ranges of data available in cache at the time this method is invoked\n+     * @throws IOException                       if the cache file failed to be fsync\n+     * @throws AlreadyClosedException            if the cache file is evicted\n+     * @throws java.nio.file.NoSuchFileException if the cache file does not exist\n+     */\n+    public List<Tuple<Long, Long>> fsync() throws IOException {\n+        ensureOpen();\n+        if (refCounter.tryIncRef()) {\n+            try {\n+                // Capture the completed ranges before fsyncing; ranges that are completed after this point won't be considered as\n+                // persisted on disk by the caller of this method, even if they are fully written to disk at the time the file\n+                // fsync is effectively executed\n+                final List<Tuple<Long, Long>> completedRanges = tracker.getCompletedRanges();\n+                assert completedRanges != null;\n+\n+                if (fsynced.compareAndSet(false, true)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "314212ba6f368d50d9989659708641e8ed4987de"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQwODg1Mg==", "bodyText": "This also fsync's the metadata of the file. I think that is unnecessary?", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r513408852", "createdAt": "2020-10-28T12:39:23Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -398,4 +406,52 @@ private FileChannelReference acquireFileChannelReference() {\n         ensureOpen();\n         return tracker.getAbsentRangeWithin(start, end);\n     }\n+\n+    // used in tests\n+    boolean isFSynced() {\n+        return fsynced.get();\n+    }\n+\n+    /**\n+     * Ensure that all ranges of data written to the cache file are written to the storage device that contains it. This method returns the\n+     * list of all successfully written ranges of data since the creation of the cache file.\n+     *\n+     * @return the list of ranges of data available in cache at the time this method is invoked\n+     * @throws IOException                       if the cache file failed to be fsync\n+     * @throws AlreadyClosedException            if the cache file is evicted\n+     * @throws java.nio.file.NoSuchFileException if the cache file does not exist\n+     */\n+    public List<Tuple<Long, Long>> fsync() throws IOException {\n+        ensureOpen();\n+        if (refCounter.tryIncRef()) {\n+            try {\n+                // Capture the completed ranges before fsyncing; ranges that are completed after this point won't be considered as\n+                // persisted on disk by the caller of this method, even if they are fully written to disk at the time the file\n+                // fsync is effectively executed\n+                final List<Tuple<Long, Long>> completedRanges = tracker.getCompletedRanges();\n+                assert completedRanges != null;\n+\n+                if (fsynced.compareAndSet(false, true)) {\n+                    boolean success = false;\n+                    try {\n+                        // check again if the file is evicted before doing expensive I/O\n+                        ensureOpen();\n+                        IOUtils.fsync(file, false); // TODO don't forget to fsync parent directory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "314212ba6f368d50d9989659708641e8ed4987de"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQxNzU3OQ==", "bodyText": "I think counting the file as not fsync'ed when just created could lead to fsync'ing the empty file - which I think is unnecessary? We care mostly about the data, not the files.", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r513417579", "createdAt": "2020-10-28T12:53:42Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/CacheFileTests.java", "diffHunk": "@@ -171,6 +196,151 @@ public void testConcurrentAccess() throws Exception {\n         }\n     }\n \n+    public void testFSyncOnNonExistentFile() {\n+        try (FSyncTrackingFileSystemProvider fileSystem = setupFSyncCountingFileSystem()) {\n+            final CacheFile cacheFile = new CacheFile(\"test\", randomNonNegativeLong(), fileSystem.resolve(\"test\"));\n+            expectThrows(NoSuchFileException.class, cacheFile::fsync);\n+        }\n+    }\n+\n+    public void testFSync() throws Exception {\n+        try (FSyncTrackingFileSystemProvider fileSystem = setupFSyncCountingFileSystem()) {\n+            final CacheFile cacheFile = new CacheFile(\"test\", randomLongBetween(100, 1000), fileSystem.resolve(\"test\"));\n+            assertFalse(cacheFile.isFSynced());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "314212ba6f368d50d9989659708641e8ed4987de"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyMDQ0NA==", "bodyText": "Would be good to also verify multiple populateAndRead calls within one fsync?", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r513420444", "createdAt": "2020-10-28T12:58:00Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/CacheFileTests.java", "diffHunk": "@@ -171,6 +196,151 @@ public void testConcurrentAccess() throws Exception {\n         }\n     }\n \n+    public void testFSyncOnNonExistentFile() {\n+        try (FSyncTrackingFileSystemProvider fileSystem = setupFSyncCountingFileSystem()) {\n+            final CacheFile cacheFile = new CacheFile(\"test\", randomNonNegativeLong(), fileSystem.resolve(\"test\"));\n+            expectThrows(NoSuchFileException.class, cacheFile::fsync);\n+        }\n+    }\n+\n+    public void testFSync() throws Exception {\n+        try (FSyncTrackingFileSystemProvider fileSystem = setupFSyncCountingFileSystem()) {\n+            final CacheFile cacheFile = new CacheFile(\"test\", randomLongBetween(100, 1000), fileSystem.resolve(\"test\"));\n+            assertFalse(cacheFile.isFSynced());\n+\n+            final TestEvictionListener listener = new TestEvictionListener();\n+            cacheFile.acquire(listener);\n+\n+            List<Tuple<Long, Long>> completedRanges = cacheFile.fsync();\n+            assertNumberOfFSyncs(cacheFile.getFile(), equalTo(1L));\n+            assertThat(completedRanges, hasSize(0));\n+            assertTrue(cacheFile.isFSynced());\n+\n+            final TestThreadPool threadPool = new TestThreadPool(getTestName());\n+            try {\n+                final Set<Tuple<Long, Long>> expectedCompletedRanges = new TreeSet<>(Comparator.comparingLong(Tuple::v1));\n+\n+                for (long i = 0L; i < between(1, 10); i++) {\n+                    if (randomBoolean()) {\n+                        final long position = i * 10L; // simplify the test by completing small non-contiguous ranges\n+                        final Tuple<Long, Long> range = Tuple.tuple(position, position + 1L);\n+                        cacheFile.populateAndRead(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "314212ba6f368d50d9989659708641e8ed4987de"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyNDg1OA==", "bodyText": "Should this return a SortedSet instead to signal the expected order verified by the test, as well as uniqueness?", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r513424858", "createdAt": "2020-10-28T13:04:56Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -398,4 +406,52 @@ private FileChannelReference acquireFileChannelReference() {\n         ensureOpen();\n         return tracker.getAbsentRangeWithin(start, end);\n     }\n+\n+    // used in tests\n+    boolean isFSynced() {\n+        return fsynced.get();\n+    }\n+\n+    /**\n+     * Ensure that all ranges of data written to the cache file are written to the storage device that contains it. This method returns the\n+     * list of all successfully written ranges of data since the creation of the cache file.\n+     *\n+     * @return the list of ranges of data available in cache at the time this method is invoked\n+     * @throws IOException                       if the cache file failed to be fsync\n+     * @throws AlreadyClosedException            if the cache file is evicted\n+     * @throws java.nio.file.NoSuchFileException if the cache file does not exist\n+     */\n+    public List<Tuple<Long, Long>> fsync() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "314212ba6f368d50d9989659708641e8ed4987de"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyNjE0MQ==", "bodyText": "This can definitely be handled in a follow-up instead when you start using it. But it might be more appropriate to just return the empty set of ranges in this case, since we essentially having nothing cached for it, rather than have to exception handle in the fsync'er thread?", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r513426141", "createdAt": "2020-10-28T13:06:51Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/CacheFileTests.java", "diffHunk": "@@ -171,6 +196,151 @@ public void testConcurrentAccess() throws Exception {\n         }\n     }\n \n+    public void testFSyncOnNonExistentFile() {\n+        try (FSyncTrackingFileSystemProvider fileSystem = setupFSyncCountingFileSystem()) {\n+            final CacheFile cacheFile = new CacheFile(\"test\", randomNonNegativeLong(), fileSystem.resolve(\"test\"));\n+            expectThrows(NoSuchFileException.class, cacheFile::fsync);\n+        }\n+    }\n+\n+    public void testFSync() throws Exception {\n+        try (FSyncTrackingFileSystemProvider fileSystem = setupFSyncCountingFileSystem()) {\n+            final CacheFile cacheFile = new CacheFile(\"test\", randomLongBetween(100, 1000), fileSystem.resolve(\"test\"));\n+            assertFalse(cacheFile.isFSynced());\n+\n+            final TestEvictionListener listener = new TestEvictionListener();\n+            cacheFile.acquire(listener);\n+\n+            List<Tuple<Long, Long>> completedRanges = cacheFile.fsync();\n+            assertNumberOfFSyncs(cacheFile.getFile(), equalTo(1L));\n+            assertThat(completedRanges, hasSize(0));\n+            assertTrue(cacheFile.isFSynced());\n+\n+            final TestThreadPool threadPool = new TestThreadPool(getTestName());\n+            try {\n+                final Set<Tuple<Long, Long>> expectedCompletedRanges = new TreeSet<>(Comparator.comparingLong(Tuple::v1));\n+\n+                for (long i = 0L; i < between(1, 10); i++) {\n+                    if (randomBoolean()) {\n+                        final long position = i * 10L; // simplify the test by completing small non-contiguous ranges\n+                        final Tuple<Long, Long> range = Tuple.tuple(position, position + 1L);\n+                        cacheFile.populateAndRead(\n+                            range,\n+                            range,\n+                            channel -> Math.toIntExact(range.v2() - range.v1()),\n+                            (channel, from, to, progressUpdater) -> progressUpdater.accept(to),\n+                            threadPool.generic()\n+                        );\n+\n+                        waitForGenericThreadPool(threadPool, expectedCompletedRanges.size() + 1L);\n+                        assertTrue(expectedCompletedRanges.add(range));\n+                        assertFalse(cacheFile.isFSynced());\n+                    }\n+\n+                    completedRanges = cacheFile.fsync();\n+                    assertNumberOfFSyncs(cacheFile.getFile(), equalTo(1L + expectedCompletedRanges.size()));\n+                    assertThat(completedRanges.size(), equalTo(expectedCompletedRanges.size()));\n+                    assertTrue(cacheFile.isFSynced());\n+                }\n+\n+                assertArrayEquals(cacheFile.fsync().toArray(Tuple[]::new), expectedCompletedRanges.toArray(Tuple[]::new));\n+            } finally {\n+                cacheFile.release(listener);\n+                terminate(threadPool);\n+            }\n+        }\n+    }\n+\n+    public void testFSyncOnEvictedFile() throws Exception {\n+        try (FSyncTrackingFileSystemProvider fileSystem = setupFSyncCountingFileSystem()) {\n+            final CacheFile cacheFile = new CacheFile(\"test\", randomNonNegativeLong(), fileSystem.resolve(\"test\"));\n+            assertFalse(cacheFile.isFSynced());\n+\n+            final TestEvictionListener listener = new TestEvictionListener();\n+            cacheFile.acquire(listener);\n+\n+            final TestThreadPool threadPool = new TestThreadPool(getTestName());\n+            try {\n+                final boolean completeRangeBeforeEviction = randomBoolean();\n+                if (completeRangeBeforeEviction) {\n+                    final long start = randomLongBetween(0L, Math.max(0L, cacheFile.getLength() - 1L));\n+                    final long end = randomLongBetween(start, cacheFile.getLength());\n+                    final Tuple<Long, Long> range = Tuple.tuple(start, end);\n+                    cacheFile.populateAndRead(\n+                        range,\n+                        range,\n+                        channel -> Math.toIntExact(end - start),\n+                        (channel, from, to, progressUpdater) -> progressUpdater.accept(to),\n+                        threadPool.generic()\n+                    );\n+\n+                    waitForGenericThreadPool(threadPool, 1L);\n+                    assertFalse(cacheFile.isFSynced());\n+\n+                    final List<Tuple<Long, Long>> completedRanges = cacheFile.fsync();\n+                    assertNumberOfFSyncs(cacheFile.getFile(), equalTo(1L));\n+                    assertThat(completedRanges, hasSize(1));\n+                    assertTrue(cacheFile.isFSynced());\n+                }\n+\n+                cacheFile.startEviction();\n+                expectThrows(AlreadyClosedException.class, cacheFile::fsync);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "314212ba6f368d50d9989659708641e8ed4987de"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzMDczNQ==", "bodyText": "I wonder if this is necessary, since there is no waiting above?", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r513430735", "createdAt": "2020-10-28T13:13:42Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -398,4 +406,52 @@ private FileChannelReference acquireFileChannelReference() {\n         ensureOpen();\n         return tracker.getAbsentRangeWithin(start, end);\n     }\n+\n+    // used in tests\n+    boolean isFSynced() {\n+        return fsynced.get();\n+    }\n+\n+    /**\n+     * Ensure that all ranges of data written to the cache file are written to the storage device that contains it. This method returns the\n+     * list of all successfully written ranges of data since the creation of the cache file.\n+     *\n+     * @return the list of ranges of data available in cache at the time this method is invoked\n+     * @throws IOException                       if the cache file failed to be fsync\n+     * @throws AlreadyClosedException            if the cache file is evicted\n+     * @throws java.nio.file.NoSuchFileException if the cache file does not exist\n+     */\n+    public List<Tuple<Long, Long>> fsync() throws IOException {\n+        ensureOpen();\n+        if (refCounter.tryIncRef()) {\n+            try {\n+                // Capture the completed ranges before fsyncing; ranges that are completed after this point won't be considered as\n+                // persisted on disk by the caller of this method, even if they are fully written to disk at the time the file\n+                // fsync is effectively executed\n+                final List<Tuple<Long, Long>> completedRanges = tracker.getCompletedRanges();\n+                assert completedRanges != null;\n+\n+                if (fsynced.compareAndSet(false, true)) {\n+                    boolean success = false;\n+                    try {\n+                        // check again if the file is evicted before doing expensive I/O", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "314212ba6f368d50d9989659708641e8ed4987de"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6eea9006cc32def270240126785637afad5a3720", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/6eea9006cc32def270240126785637afad5a3720", "committedDate": "2020-11-02T10:14:26Z", "message": "fsynced no metadata"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f8b0e71553feb8c3e6212b4abf0f9ba25c08b22", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/2f8b0e71553feb8c3e6212b4abf0f9ba25c08b22", "committedDate": "2020-11-02T10:15:13Z", "message": "fsynced at creation time"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b3590edaa921b328efb5bd5c97162f9795b1c55", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/7b3590edaa921b328efb5bd5c97162f9795b1c55", "committedDate": "2020-11-02T10:25:10Z", "message": "sorted set"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d55278ebf5c6f6ccac3e7af06f3124700215a347", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/d55278ebf5c6f6ccac3e7af06f3124700215a347", "committedDate": "2020-11-02T12:11:08Z", "message": "feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f5d13b63718c425dbe72e58e0663e1e801df5d7", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/8f5d13b63718c425dbe72e58e0663e1e801df5d7", "committedDate": "2020-11-02T12:53:41Z", "message": "Merge branch 'master' into add-cache-file-fsync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0c3cbeaba8a51ed27910f0659053fe2950c8a8a", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/f0c3cbeaba8a51ed27910f0659053fe2950c8a8a", "committedDate": "2020-11-03T07:32:02Z", "message": "Merge branch 'master' into add-cache-file-fsync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d43e5b87144aaed017e43d745d2541620d3550c", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/0d43e5b87144aaed017e43d745d2541620d3550c", "committedDate": "2020-11-03T10:13:07Z", "message": "Merge branch 'master' into add-cache-file-fsync"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNDMwMjkw", "url": "https://github.com/elastic/elasticsearch/pull/64201#pullrequestreview-522430290", "createdAt": "2020-11-03T12:04:20Z", "commit": {"oid": "0d43e5b87144aaed017e43d745d2541620d3550c"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMjowNDoyMFrOHsr0YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMjowNDoyMFrOHsr0YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYxNzMxMw==", "bodyText": "I wonder if calling this needsFsync (and reverting the boolean) would be slightly more intuitive?\nWith the current name, a reader would be inclined to think the boolean is only true when the file is fsync'ed, but this is not true (it is also still true while writing and completing the gap).", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r516617313", "createdAt": "2020-11-03T12:04:20Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -67,6 +70,14 @@ protected void closeInternal() {\n \n     private final Set<EvictionListener> listeners = new HashSet<>();\n \n+    /**\n+     * Indicates whether the cache file has been synchronized with the storage device that contains it, since the last time data\n+     * were written in cache (or since the creation of the file if no cached data have been written yet). An empty cache file is\n+     * considered as fsynced (the initialization value is {@code true}) when it is created; and writing new data to the cache file\n+     * will toggle the flag to {@code false}.\n+     **/\n+    private final AtomicBoolean fsynced = new AtomicBoolean(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d43e5b87144aaed017e43d745d2541620d3550c"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8fdaaa2aab25e78033906f2fa8c956a6e340441", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/d8fdaaa2aab25e78033906f2fa8c956a6e340441", "committedDate": "2020-11-03T13:05:19Z", "message": "needsFsync"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 998, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}