{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5Nzk5MjMz", "number": 55834, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjozMjoyNlrOD3R_gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjo0Mzo0MVrOD3SR6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MjkzMDU3OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjozMjoyNlrOGNc0Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjozMjoyNlrOGNc0Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1Njc1NQ==", "bodyText": "We should probably name this variable testCompileConfig.", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416756755", "createdAt": "2020-04-28T16:32:26Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02807869f9a5d418a6d66993d98bc31b57e61aa4"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MjkzNzkyOnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjozNDoxM1rOGNc4pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjo1NTo1MFrOGNdyXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1NzkyNQ==", "bodyText": "FWIW, I recently found out you can just do project.getExtensions().getExtraProperties() as a convenience for getting the ExtraPropertiesExtension.", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416757925", "createdAt": "2020-04-28T16:34:13Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        compileConfig.extendsFrom(compileOnlyConfig);\n+\n+        // we are not shipping these jars, we act like dumb consumers of these things\n+        if (project.getPath().startsWith(\":test:fixtures\") || project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+        // fail on any conflicting dependency versions\n+        project.getConfigurations().all(configuration -> {\n+            if (configuration.getName().endsWith(\"Fixture\")) {\n+                // just a self contained test-fixture configuration, likely transitive and hellacious\n+                return;\n+            }\n+            configuration.resolutionStrategy(ResolutionStrategy::failOnVersionConflict);\n+        });\n+\n+        // force all dependencies added directly to compile/testCompile to be non-transitive, except for ES itself\n+        Consumer<String> disableTransitiveDeps = configName -> {\n+            Configuration config = project.getConfigurations().getByName(configName);\n+            config.getDependencies().all(dep -> {\n+                if (dep instanceof ModuleDependency\n+                    && dep instanceof ProjectDependency == false\n+                    && dep.getGroup().startsWith(\"org.elasticsearch\") == false) {\n+                    ((ModuleDependency) dep).setTransitive(false);\n+                }\n+            });\n+        };\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.RUNTIME_ONLY_CONFIGURATION_NAME);\n+    }\n+\n+    /** Adds compiler settings to the project */\n+    public static void configureCompile(Project project) {\n+        ExtraPropertiesExtension ext = project.getExtensions().getByType(ExtraPropertiesExtension.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02807869f9a5d418a6d66993d98bc31b57e61aa4"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3MjcwMw==", "bodyText": "Nice! very useful", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416772703", "createdAt": "2020-04-28T16:55:50Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        compileConfig.extendsFrom(compileOnlyConfig);\n+\n+        // we are not shipping these jars, we act like dumb consumers of these things\n+        if (project.getPath().startsWith(\":test:fixtures\") || project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+        // fail on any conflicting dependency versions\n+        project.getConfigurations().all(configuration -> {\n+            if (configuration.getName().endsWith(\"Fixture\")) {\n+                // just a self contained test-fixture configuration, likely transitive and hellacious\n+                return;\n+            }\n+            configuration.resolutionStrategy(ResolutionStrategy::failOnVersionConflict);\n+        });\n+\n+        // force all dependencies added directly to compile/testCompile to be non-transitive, except for ES itself\n+        Consumer<String> disableTransitiveDeps = configName -> {\n+            Configuration config = project.getConfigurations().getByName(configName);\n+            config.getDependencies().all(dep -> {\n+                if (dep instanceof ModuleDependency\n+                    && dep instanceof ProjectDependency == false\n+                    && dep.getGroup().startsWith(\"org.elasticsearch\") == false) {\n+                    ((ModuleDependency) dep).setTransitive(false);\n+                }\n+            });\n+        };\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.RUNTIME_ONLY_CONFIGURATION_NAME);\n+    }\n+\n+    /** Adds compiler settings to the project */\n+    public static void configureCompile(Project project) {\n+        ExtraPropertiesExtension ext = project.getExtensions().getByType(ExtraPropertiesExtension.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1NzkyNQ=="}, "originalCommit": {"oid": "02807869f9a5d418a6d66993d98bc31b57e61aa4"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5Mjk0MDU2OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjozNDo1NFrOGNc6UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjo1Njo1NFrOGNd1XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1ODM1Mw==", "bodyText": "This seems like something we'd want to throw in one of our util classes.", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416758353", "createdAt": "2020-04-28T16:34:54Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        compileConfig.extendsFrom(compileOnlyConfig);\n+\n+        // we are not shipping these jars, we act like dumb consumers of these things\n+        if (project.getPath().startsWith(\":test:fixtures\") || project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+        // fail on any conflicting dependency versions\n+        project.getConfigurations().all(configuration -> {\n+            if (configuration.getName().endsWith(\"Fixture\")) {\n+                // just a self contained test-fixture configuration, likely transitive and hellacious\n+                return;\n+            }\n+            configuration.resolutionStrategy(ResolutionStrategy::failOnVersionConflict);\n+        });\n+\n+        // force all dependencies added directly to compile/testCompile to be non-transitive, except for ES itself\n+        Consumer<String> disableTransitiveDeps = configName -> {\n+            Configuration config = project.getConfigurations().getByName(configName);\n+            config.getDependencies().all(dep -> {\n+                if (dep instanceof ModuleDependency\n+                    && dep instanceof ProjectDependency == false\n+                    && dep.getGroup().startsWith(\"org.elasticsearch\") == false) {\n+                    ((ModuleDependency) dep).setTransitive(false);\n+                }\n+            });\n+        };\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.RUNTIME_ONLY_CONFIGURATION_NAME);\n+    }\n+\n+    /** Adds compiler settings to the project */\n+    public static void configureCompile(Project project) {\n+        ExtraPropertiesExtension ext = project.getExtensions().getByType(ExtraPropertiesExtension.class);\n+        ext.set(\"compactProfile\", \"full\");\n+\n+        JavaPluginExtension java = project.getExtensions().getByType(JavaPluginExtension.class);\n+        java.setSourceCompatibility(BuildParams.getMinimumRuntimeVersion());\n+        java.setTargetCompatibility(BuildParams.getMinimumRuntimeVersion());\n+\n+        Function<File, String> canonicalPath = file -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02807869f9a5d418a6d66993d98bc31b57e61aa4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3MzQ2OQ==", "bodyText": "Possibly, but I'd rather add it there once we have more uses.", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416773469", "createdAt": "2020-04-28T16:56:54Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        compileConfig.extendsFrom(compileOnlyConfig);\n+\n+        // we are not shipping these jars, we act like dumb consumers of these things\n+        if (project.getPath().startsWith(\":test:fixtures\") || project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+        // fail on any conflicting dependency versions\n+        project.getConfigurations().all(configuration -> {\n+            if (configuration.getName().endsWith(\"Fixture\")) {\n+                // just a self contained test-fixture configuration, likely transitive and hellacious\n+                return;\n+            }\n+            configuration.resolutionStrategy(ResolutionStrategy::failOnVersionConflict);\n+        });\n+\n+        // force all dependencies added directly to compile/testCompile to be non-transitive, except for ES itself\n+        Consumer<String> disableTransitiveDeps = configName -> {\n+            Configuration config = project.getConfigurations().getByName(configName);\n+            config.getDependencies().all(dep -> {\n+                if (dep instanceof ModuleDependency\n+                    && dep instanceof ProjectDependency == false\n+                    && dep.getGroup().startsWith(\"org.elasticsearch\") == false) {\n+                    ((ModuleDependency) dep).setTransitive(false);\n+                }\n+            });\n+        };\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.RUNTIME_ONLY_CONFIGURATION_NAME);\n+    }\n+\n+    /** Adds compiler settings to the project */\n+    public static void configureCompile(Project project) {\n+        ExtraPropertiesExtension ext = project.getExtensions().getByType(ExtraPropertiesExtension.class);\n+        ext.set(\"compactProfile\", \"full\");\n+\n+        JavaPluginExtension java = project.getExtensions().getByType(JavaPluginExtension.class);\n+        java.setSourceCompatibility(BuildParams.getMinimumRuntimeVersion());\n+        java.setTargetCompatibility(BuildParams.getMinimumRuntimeVersion());\n+\n+        Function<File, String> canonicalPath = file -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1ODM1Mw=="}, "originalCommit": {"oid": "02807869f9a5d418a6d66993d98bc31b57e61aa4"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5Mjk1MTc1OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjozNzozNlrOGNdBfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjo1Nzo0OFrOGNd3vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MDE5MQ==", "bodyText": "I'm wondering why we need afterEvaluate here. Is it strictly necessary? If anything, shouldn't any config in the build script take precedence over these conventions?", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416760191", "createdAt": "2020-04-28T16:37:36Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        compileConfig.extendsFrom(compileOnlyConfig);\n+\n+        // we are not shipping these jars, we act like dumb consumers of these things\n+        if (project.getPath().startsWith(\":test:fixtures\") || project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+        // fail on any conflicting dependency versions\n+        project.getConfigurations().all(configuration -> {\n+            if (configuration.getName().endsWith(\"Fixture\")) {\n+                // just a self contained test-fixture configuration, likely transitive and hellacious\n+                return;\n+            }\n+            configuration.resolutionStrategy(ResolutionStrategy::failOnVersionConflict);\n+        });\n+\n+        // force all dependencies added directly to compile/testCompile to be non-transitive, except for ES itself\n+        Consumer<String> disableTransitiveDeps = configName -> {\n+            Configuration config = project.getConfigurations().getByName(configName);\n+            config.getDependencies().all(dep -> {\n+                if (dep instanceof ModuleDependency\n+                    && dep instanceof ProjectDependency == false\n+                    && dep.getGroup().startsWith(\"org.elasticsearch\") == false) {\n+                    ((ModuleDependency) dep).setTransitive(false);\n+                }\n+            });\n+        };\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.RUNTIME_ONLY_CONFIGURATION_NAME);\n+    }\n+\n+    /** Adds compiler settings to the project */\n+    public static void configureCompile(Project project) {\n+        ExtraPropertiesExtension ext = project.getExtensions().getByType(ExtraPropertiesExtension.class);\n+        ext.set(\"compactProfile\", \"full\");\n+\n+        JavaPluginExtension java = project.getExtensions().getByType(JavaPluginExtension.class);\n+        java.setSourceCompatibility(BuildParams.getMinimumRuntimeVersion());\n+        java.setTargetCompatibility(BuildParams.getMinimumRuntimeVersion());\n+\n+        Function<File, String> canonicalPath = file -> {\n+            try {\n+                return file.getCanonicalPath();\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to get canonical path for \" + file, e);\n+            }\n+        };\n+        // common options to both java and groovy\n+        Consumer<CompileOptions> configureFork = compileOptions -> {\n+            // we only fork if the Gradle JDK is not the same as the compiler JDK\n+            String compilerJavaHome = canonicalPath.apply(BuildParams.getCompilerJavaHome());\n+            String currentJavaHome = canonicalPath.apply(Jvm.current().getJavaHome());\n+            if (compilerJavaHome.equals(currentJavaHome)) {\n+                compileOptions.setFork(false);\n+            } else {\n+                compileOptions.setFork(true);\n+                compileOptions.getForkOptions().setJavaHome(BuildParams.getCompilerJavaHome());\n+            }\n+        };\n+\n+        project.afterEvaluate(p -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02807869f9a5d418a6d66993d98bc31b57e61aa4"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3NDA3OQ==", "bodyText": "I'm not sure how necessary it is, but I'd like to defer this until after this PR, so that any behavior changes can be isolated.", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416774079", "createdAt": "2020-04-28T16:57:48Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        compileConfig.extendsFrom(compileOnlyConfig);\n+\n+        // we are not shipping these jars, we act like dumb consumers of these things\n+        if (project.getPath().startsWith(\":test:fixtures\") || project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+        // fail on any conflicting dependency versions\n+        project.getConfigurations().all(configuration -> {\n+            if (configuration.getName().endsWith(\"Fixture\")) {\n+                // just a self contained test-fixture configuration, likely transitive and hellacious\n+                return;\n+            }\n+            configuration.resolutionStrategy(ResolutionStrategy::failOnVersionConflict);\n+        });\n+\n+        // force all dependencies added directly to compile/testCompile to be non-transitive, except for ES itself\n+        Consumer<String> disableTransitiveDeps = configName -> {\n+            Configuration config = project.getConfigurations().getByName(configName);\n+            config.getDependencies().all(dep -> {\n+                if (dep instanceof ModuleDependency\n+                    && dep instanceof ProjectDependency == false\n+                    && dep.getGroup().startsWith(\"org.elasticsearch\") == false) {\n+                    ((ModuleDependency) dep).setTransitive(false);\n+                }\n+            });\n+        };\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.RUNTIME_ONLY_CONFIGURATION_NAME);\n+    }\n+\n+    /** Adds compiler settings to the project */\n+    public static void configureCompile(Project project) {\n+        ExtraPropertiesExtension ext = project.getExtensions().getByType(ExtraPropertiesExtension.class);\n+        ext.set(\"compactProfile\", \"full\");\n+\n+        JavaPluginExtension java = project.getExtensions().getByType(JavaPluginExtension.class);\n+        java.setSourceCompatibility(BuildParams.getMinimumRuntimeVersion());\n+        java.setTargetCompatibility(BuildParams.getMinimumRuntimeVersion());\n+\n+        Function<File, String> canonicalPath = file -> {\n+            try {\n+                return file.getCanonicalPath();\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to get canonical path for \" + file, e);\n+            }\n+        };\n+        // common options to both java and groovy\n+        Consumer<CompileOptions> configureFork = compileOptions -> {\n+            // we only fork if the Gradle JDK is not the same as the compiler JDK\n+            String compilerJavaHome = canonicalPath.apply(BuildParams.getCompilerJavaHome());\n+            String currentJavaHome = canonicalPath.apply(Jvm.current().getJavaHome());\n+            if (compilerJavaHome.equals(currentJavaHome)) {\n+                compileOptions.setFork(false);\n+            } else {\n+                compileOptions.setFork(true);\n+                compileOptions.getForkOptions().setJavaHome(BuildParams.getCompilerJavaHome());\n+            }\n+        };\n+\n+        project.afterEvaluate(p -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MDE5MQ=="}, "originalCommit": {"oid": "02807869f9a5d418a6d66993d98bc31b57e61aa4"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5Mjk2MjE2OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjo0MDoxNVrOGNdIJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjo0MDoxNVrOGNdIJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MTg5NA==", "bodyText": "Let's ditch this and just use BuildParams.inFipsJvm(). No need to have this implemented twice.", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416761894", "createdAt": "2020-04-28T16:40:15Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        compileConfig.extendsFrom(compileOnlyConfig);\n+\n+        // we are not shipping these jars, we act like dumb consumers of these things\n+        if (project.getPath().startsWith(\":test:fixtures\") || project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+        // fail on any conflicting dependency versions\n+        project.getConfigurations().all(configuration -> {\n+            if (configuration.getName().endsWith(\"Fixture\")) {\n+                // just a self contained test-fixture configuration, likely transitive and hellacious\n+                return;\n+            }\n+            configuration.resolutionStrategy(ResolutionStrategy::failOnVersionConflict);\n+        });\n+\n+        // force all dependencies added directly to compile/testCompile to be non-transitive, except for ES itself\n+        Consumer<String> disableTransitiveDeps = configName -> {\n+            Configuration config = project.getConfigurations().getByName(configName);\n+            config.getDependencies().all(dep -> {\n+                if (dep instanceof ModuleDependency\n+                    && dep instanceof ProjectDependency == false\n+                    && dep.getGroup().startsWith(\"org.elasticsearch\") == false) {\n+                    ((ModuleDependency) dep).setTransitive(false);\n+                }\n+            });\n+        };\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.RUNTIME_ONLY_CONFIGURATION_NAME);\n+    }\n+\n+    /** Adds compiler settings to the project */\n+    public static void configureCompile(Project project) {\n+        ExtraPropertiesExtension ext = project.getExtensions().getByType(ExtraPropertiesExtension.class);\n+        ext.set(\"compactProfile\", \"full\");\n+\n+        JavaPluginExtension java = project.getExtensions().getByType(JavaPluginExtension.class);\n+        java.setSourceCompatibility(BuildParams.getMinimumRuntimeVersion());\n+        java.setTargetCompatibility(BuildParams.getMinimumRuntimeVersion());\n+\n+        Function<File, String> canonicalPath = file -> {\n+            try {\n+                return file.getCanonicalPath();\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to get canonical path for \" + file, e);\n+            }\n+        };\n+        // common options to both java and groovy\n+        Consumer<CompileOptions> configureFork = compileOptions -> {\n+            // we only fork if the Gradle JDK is not the same as the compiler JDK\n+            String compilerJavaHome = canonicalPath.apply(BuildParams.getCompilerJavaHome());\n+            String currentJavaHome = canonicalPath.apply(Jvm.current().getJavaHome());\n+            if (compilerJavaHome.equals(currentJavaHome)) {\n+                compileOptions.setFork(false);\n+            } else {\n+                compileOptions.setFork(true);\n+                compileOptions.getForkOptions().setJavaHome(BuildParams.getCompilerJavaHome());\n+            }\n+        };\n+\n+        project.afterEvaluate(p -> {\n+            project.getTasks().withType(JavaCompile.class).configureEach(compileTask -> {\n+                CompileOptions compileOptions = compileTask.getOptions();\n+\n+                configureFork.accept(compileOptions);\n+                /*\n+                 * -path because gradle will send in paths that don't always exist.\n+                 * -missing because we have tons of missing @returns and @param.\n+                 * -serial because we don't use java serialization.\n+                 */\n+                // don't even think about passing args with -J-xxx, oracle will ask you to submit a bug report :)\n+                // fail on all javac warnings\n+                List<String> compilerArgs = compileOptions.getCompilerArgs();\n+                compilerArgs.add(\"-Werror\");\n+                compilerArgs.add(\"-Xlint:all,-path,-serial,-options,-deprecation,-try\");\n+                compilerArgs.add(\"-Xdoclint:all\");\n+                compilerArgs.add(\"-Xdoclint:-missing\");\n+\n+                // either disable annotation processor completely (default) or allow to enable them if an annotation processor is explicitly\n+                // defined\n+                if (compilerArgs.contains(\"-processor\") == false) {\n+                    compilerArgs.add(\"-proc:none\");\n+                }\n+\n+                compileOptions.setEncoding(\"UTF-8\");\n+                compileOptions.setIncremental(true);\n+\n+                // TODO: use native Gradle support for --release when available (cf. https://github.com/gradle/gradle/issues/2510)\n+                final JavaVersion targetCompatibilityVersion = JavaVersion.toVersion(compileTask.getTargetCompatibility());\n+                compilerArgs.add(\"--release\");\n+                compilerArgs.add(targetCompatibilityVersion.getMajorVersion());\n+\n+            });\n+            // also apply release flag to groovy, which is used in build-tools\n+            project.getTasks().withType(GroovyCompile.class).configureEach(compileTask -> {\n+                configureFork.accept(compileTask.getOptions());\n+\n+                // TODO: this probably shouldn't apply to groovy at all?\n+                // TODO: use native Gradle support for --release when available (cf. https://github.com/gradle/gradle/issues/2510)\n+                final JavaVersion targetCompatibilityVersion = JavaVersion.toVersion(compileTask.getTargetCompatibility());\n+                final List<String> compilerArgs = compileTask.getOptions().getCompilerArgs();\n+                compilerArgs.add(\"--release\");\n+                compilerArgs.add(targetCompatibilityVersion.getMajorVersion());\n+            });\n+        });\n+\n+        project.getPluginManager().withPlugin(\"com.github.johnrengelman.shadow\", plugin -> {\n+            // Ensure that when we are compiling against the \"original\" JAR that we also include any \"shadow\" dependencies on the compile\n+            // classpath\n+            Configuration shadowConfig = project.getConfigurations().getByName(ShadowBasePlugin.getCONFIGURATION_NAME());\n+            Configuration apiConfig = project.getConfigurations().getByName(JavaPlugin.API_ELEMENTS_CONFIGURATION_NAME);\n+            shadowConfig.getDependencies().all(dependency -> apiConfig.getDependencies().add(dependency));\n+        });\n+    }\n+\n+    /**\n+     * Apply runtime classpath input normalization so that changes in JAR manifests don't break build cacheability\n+     */\n+    public static void configureInputNormalization(Project project) {\n+        project.getNormalization().getRuntimeClasspath().ignore(\"META-INF/MANIFEST.MF\");\n+    }\n+\n+    public static void configureTestTasks(Project project) {\n+        // Default test task should run only unit tests\n+        maybeConfigure(project.getTasks(), \"test\", Test.class, task -> task.include(\"**/*Tests.class\"));\n+\n+        // none of this stuff is applicable to the `:buildSrc` project tests\n+        if (project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+\n+        File heapdumpDir = new File(project.getBuildDir(), \"heapdump\");\n+\n+        project.getTasks().withType(Test.class).configureEach(test -> {\n+            File testOutputDir = new File(test.getReports().getJunitXml().getDestination(), \"output\");\n+\n+            ErrorReportingTestListener listener = new ErrorReportingTestListener(test.getTestLogging(), testOutputDir);\n+            test.getExtensions().add(\"errorReportingTestListener\", listener);\n+            test.addTestOutputListener(listener);\n+            test.addTestListener(listener);\n+\n+            /*\n+             * We use lazy-evaluated strings in order to configure system properties whose value will not be known until\n+             * execution time (e.g. cluster port numbers). Adding these via the normal DSL doesn't work as these get treated\n+             * as task inputs and therefore Gradle attempts to snapshot them before/after task execution. This fails due\n+             * to the GStrings containing references to non-serializable objects.\n+             *\n+             * We bypass this by instead passing this system properties vi a CommandLineArgumentProvider. This has the added\n+             * side-effect that these properties are NOT treated as inputs, therefore they don't influence things like the\n+             * build cache key or up to date checking.\n+             */\n+            SystemPropertyCommandLineArgumentProvider nonInputProperties = new SystemPropertyCommandLineArgumentProvider();\n+\n+            test.doFirst(t -> {\n+                project.mkdir(testOutputDir);\n+                project.mkdir(heapdumpDir);\n+                project.mkdir(test.getWorkingDir());\n+                project.mkdir(test.getWorkingDir().toPath().resolve(\"temp\"));\n+\n+                // TODO remove once jvm.options are added to test system properties\n+                test.systemProperty(\"java.locale.providers\", \"SPI,COMPAT\");\n+            });\n+            if (inFipsJvm()) {\n+                project.getDependencies().add(\"testRuntimeOnly\", \"org.bouncycastle:bc-fips:1.0.1\");\n+                project.getDependencies().add(\"testRuntimeOnly\", \"org.bouncycastle:bctls-fips:1.0.9\");\n+            }\n+            test.getJvmArgumentProviders().add(nonInputProperties);\n+            test.getExtensions().add(\"nonInputProperties\", nonInputProperties);\n+\n+            test.setWorkingDir(project.file(project.getBuildDir() + \"/testrun/\" + test.getName()));\n+            test.setMaxParallelForks(Integer.parseInt(System.getProperty(\"tests.jvms\", BuildParams.getDefaultParallel().toString())));\n+\n+            test.exclude(\"**/*$*.class\");\n+\n+            test.jvmArgs(\n+                \"-Xmx\" + System.getProperty(\"tests.heap.size\", \"512m\"),\n+                \"-Xms\" + System.getProperty(\"tests.heap.size\", \"512m\"),\n+                \"--illegal-access=warn\",\n+                \"-XX:+HeapDumpOnOutOfMemoryError\"\n+            );\n+\n+            test.getJvmArgumentProviders().add(() -> List.of(\"-XX:HeapDumpPath=$heapdumpDir\"));\n+\n+            String argline = System.getProperty(\"tests.jvm.argline\");\n+            if (argline != null) {\n+                test.jvmArgs((Object[]) argline.split(\" \"));\n+            }\n+\n+            if (Boolean.parseBoolean(System.getProperty(\"tests.asserts\", \"true\"))) {\n+                test.jvmArgs(\"-ea\", \"-esa\");\n+            }\n+\n+            Map<String, String> sysprops = Map.of(\n+                \"java.awt.headless\",\n+                \"true\",\n+                \"tests.gradle\",\n+                \"true\",\n+                \"tests.artifact\",\n+                project.getName(),\n+                \"tests.task\",\n+                test.getPath(),\n+                \"tests.security.manager\",\n+                \"true\",\n+                \"jna.nosys\",\n+                \"true\"\n+            );\n+            test.systemProperties(sysprops);\n+\n+            // ignore changing test seed when build is passed -Dignore.tests.seed for cacheability experimentation\n+            if (System.getProperty(\"ignore.tests.seed\") != null) {\n+                nonInputProperties.systemProperty(\"tests.seed\", BuildParams.getTestSeed());\n+            } else {\n+                test.systemProperty(\"tests.seed\", BuildParams.getTestSeed());\n+            }\n+\n+            // don't track these as inputs since they contain absolute paths and break cache relocatability\n+            File gradleHome = project.getGradle().getGradleUserHomeDir();\n+            String gradleVersion = project.getGradle().getGradleVersion();\n+            nonInputProperties.systemProperty(\"gradle.dist.lib\", new File(project.getGradle().getGradleHomeDir(), \"lib\"));\n+            nonInputProperties.systemProperty(\n+                \"gradle.worker.jar\",\n+                gradleHome + \"/caches/\" + gradleVersion + \"/workerMain/gradle-worker.jar\"\n+            );\n+            nonInputProperties.systemProperty(\"gradle.user.home\", gradleHome);\n+            // we use 'temp' relative to CWD since this is per JVM and tests are forbidden from writing to CWD\n+            nonInputProperties.systemProperty(\"java.io.tmpdir\", test.getWorkingDir().toPath().resolve(\"temp\"));\n+\n+            nonInputProperties.systemProperty(\"compiler.java\", BuildParams.getCompilerJavaVersion().getMajorVersion());\n+            nonInputProperties.systemProperty(\"runtime.java\", BuildParams.getRuntimeJavaVersion().getMajorVersion());\n+\n+            // TODO: remove setting logging level via system property\n+            test.systemProperty(\"tests.logger.level\", \"WARN\");\n+            System.getProperties().entrySet().forEach(entry -> {\n+                if ((entry.getKey().toString().startsWith(\"tests.\") || entry.getKey().toString().startsWith(\"es.\"))) {\n+                    test.systemProperty(entry.getKey().toString(), entry.getValue());\n+                }\n+            });\n+\n+            // TODO: remove this once ctx isn't added to update script params in 7.0\n+            test.systemProperty(\"es.scripting.update.ctx_in_params\", \"false\");\n+\n+            // TODO: remove this property in 8.0\n+            test.systemProperty(\"es.search.rewrite_sort\", \"true\");\n+\n+            // TODO: remove this once cname is prepended to transport.publish_address by default in 8.0\n+            test.systemProperty(\"es.transport.cname_in_publish_address\", \"true\");\n+\n+            // Set netty system properties to the properties we configure in jvm.options\n+            test.systemProperty(\"io.netty.noUnsafe\", \"true\");\n+            test.systemProperty(\"io.netty.noKeySetOptimization\", \"true\");\n+            test.systemProperty(\"io.netty.recycler.maxCapacityPerThread\", \"0\");\n+\n+            test.testLogging(logging -> {\n+                logging.setShowExceptions(true);\n+                logging.setShowCauses(true);\n+                logging.setExceptionFormat(\"full\");\n+            });\n+\n+            if (OS.current().equals(OS.WINDOWS) && System.getProperty(\"tests.timeoutSuite\") == null) {\n+                // override the suite timeout to 30 mins for windows, because it has the most inefficient filesystem known to man\n+                test.systemProperty(\"tests.timeoutSuite\", \"1800000!\");\n+            }\n+\n+            /*\n+             *  If this project builds a shadow JAR than any unit tests should test against that artifact instead of\n+             *  compiled class output and dependency jars. This better emulates the runtime environment of consumers.\n+             */\n+            project.getPluginManager().withPlugin(\"com.github.johnrengelman.shadow\", p -> {\n+                // Remove output class files and any other dependencies from the test classpath, since the shadow JAR includes these\n+                FileCollection mainRuntime = project.getExtensions()\n+                    .getByType(SourceSetContainer.class)\n+                    .getByName(SourceSet.MAIN_SOURCE_SET_NAME)\n+                    .getRuntimeClasspath();\n+                // Add any \"shadow\" dependencies. These are dependencies that are *not* bundled into the shadow JAR\n+                Configuration shadowConfig = project.getConfigurations().getByName(ShadowBasePlugin.getCONFIGURATION_NAME());\n+                // Add the shadow JAR artifact itself\n+                FileCollection shadowJar = project.files(project.getTasks().named(\"shadowJar\"));\n+\n+                test.setClasspath(test.getClasspath().minus(mainRuntime).plus(shadowConfig).plus(shadowJar));\n+            });\n+        });\n+    }\n+\n+    private static boolean inFipsJvm() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02807869f9a5d418a6d66993d98bc31b57e61aa4"}, "originalPosition": 375}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5Mjk3MDc5OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjo0MjowMlrOGNdNPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjo0MjowMlrOGNdNPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MzE5OA==", "bodyText": "We should probably start replacing these with Util.getBooleanProperty for consistent bahavior.", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416763198", "createdAt": "2020-04-28T16:42:02Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        compileConfig.extendsFrom(compileOnlyConfig);\n+\n+        // we are not shipping these jars, we act like dumb consumers of these things\n+        if (project.getPath().startsWith(\":test:fixtures\") || project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+        // fail on any conflicting dependency versions\n+        project.getConfigurations().all(configuration -> {\n+            if (configuration.getName().endsWith(\"Fixture\")) {\n+                // just a self contained test-fixture configuration, likely transitive and hellacious\n+                return;\n+            }\n+            configuration.resolutionStrategy(ResolutionStrategy::failOnVersionConflict);\n+        });\n+\n+        // force all dependencies added directly to compile/testCompile to be non-transitive, except for ES itself\n+        Consumer<String> disableTransitiveDeps = configName -> {\n+            Configuration config = project.getConfigurations().getByName(configName);\n+            config.getDependencies().all(dep -> {\n+                if (dep instanceof ModuleDependency\n+                    && dep instanceof ProjectDependency == false\n+                    && dep.getGroup().startsWith(\"org.elasticsearch\") == false) {\n+                    ((ModuleDependency) dep).setTransitive(false);\n+                }\n+            });\n+        };\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.RUNTIME_ONLY_CONFIGURATION_NAME);\n+    }\n+\n+    /** Adds compiler settings to the project */\n+    public static void configureCompile(Project project) {\n+        ExtraPropertiesExtension ext = project.getExtensions().getByType(ExtraPropertiesExtension.class);\n+        ext.set(\"compactProfile\", \"full\");\n+\n+        JavaPluginExtension java = project.getExtensions().getByType(JavaPluginExtension.class);\n+        java.setSourceCompatibility(BuildParams.getMinimumRuntimeVersion());\n+        java.setTargetCompatibility(BuildParams.getMinimumRuntimeVersion());\n+\n+        Function<File, String> canonicalPath = file -> {\n+            try {\n+                return file.getCanonicalPath();\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to get canonical path for \" + file, e);\n+            }\n+        };\n+        // common options to both java and groovy\n+        Consumer<CompileOptions> configureFork = compileOptions -> {\n+            // we only fork if the Gradle JDK is not the same as the compiler JDK\n+            String compilerJavaHome = canonicalPath.apply(BuildParams.getCompilerJavaHome());\n+            String currentJavaHome = canonicalPath.apply(Jvm.current().getJavaHome());\n+            if (compilerJavaHome.equals(currentJavaHome)) {\n+                compileOptions.setFork(false);\n+            } else {\n+                compileOptions.setFork(true);\n+                compileOptions.getForkOptions().setJavaHome(BuildParams.getCompilerJavaHome());\n+            }\n+        };\n+\n+        project.afterEvaluate(p -> {\n+            project.getTasks().withType(JavaCompile.class).configureEach(compileTask -> {\n+                CompileOptions compileOptions = compileTask.getOptions();\n+\n+                configureFork.accept(compileOptions);\n+                /*\n+                 * -path because gradle will send in paths that don't always exist.\n+                 * -missing because we have tons of missing @returns and @param.\n+                 * -serial because we don't use java serialization.\n+                 */\n+                // don't even think about passing args with -J-xxx, oracle will ask you to submit a bug report :)\n+                // fail on all javac warnings\n+                List<String> compilerArgs = compileOptions.getCompilerArgs();\n+                compilerArgs.add(\"-Werror\");\n+                compilerArgs.add(\"-Xlint:all,-path,-serial,-options,-deprecation,-try\");\n+                compilerArgs.add(\"-Xdoclint:all\");\n+                compilerArgs.add(\"-Xdoclint:-missing\");\n+\n+                // either disable annotation processor completely (default) or allow to enable them if an annotation processor is explicitly\n+                // defined\n+                if (compilerArgs.contains(\"-processor\") == false) {\n+                    compilerArgs.add(\"-proc:none\");\n+                }\n+\n+                compileOptions.setEncoding(\"UTF-8\");\n+                compileOptions.setIncremental(true);\n+\n+                // TODO: use native Gradle support for --release when available (cf. https://github.com/gradle/gradle/issues/2510)\n+                final JavaVersion targetCompatibilityVersion = JavaVersion.toVersion(compileTask.getTargetCompatibility());\n+                compilerArgs.add(\"--release\");\n+                compilerArgs.add(targetCompatibilityVersion.getMajorVersion());\n+\n+            });\n+            // also apply release flag to groovy, which is used in build-tools\n+            project.getTasks().withType(GroovyCompile.class).configureEach(compileTask -> {\n+                configureFork.accept(compileTask.getOptions());\n+\n+                // TODO: this probably shouldn't apply to groovy at all?\n+                // TODO: use native Gradle support for --release when available (cf. https://github.com/gradle/gradle/issues/2510)\n+                final JavaVersion targetCompatibilityVersion = JavaVersion.toVersion(compileTask.getTargetCompatibility());\n+                final List<String> compilerArgs = compileTask.getOptions().getCompilerArgs();\n+                compilerArgs.add(\"--release\");\n+                compilerArgs.add(targetCompatibilityVersion.getMajorVersion());\n+            });\n+        });\n+\n+        project.getPluginManager().withPlugin(\"com.github.johnrengelman.shadow\", plugin -> {\n+            // Ensure that when we are compiling against the \"original\" JAR that we also include any \"shadow\" dependencies on the compile\n+            // classpath\n+            Configuration shadowConfig = project.getConfigurations().getByName(ShadowBasePlugin.getCONFIGURATION_NAME());\n+            Configuration apiConfig = project.getConfigurations().getByName(JavaPlugin.API_ELEMENTS_CONFIGURATION_NAME);\n+            shadowConfig.getDependencies().all(dependency -> apiConfig.getDependencies().add(dependency));\n+        });\n+    }\n+\n+    /**\n+     * Apply runtime classpath input normalization so that changes in JAR manifests don't break build cacheability\n+     */\n+    public static void configureInputNormalization(Project project) {\n+        project.getNormalization().getRuntimeClasspath().ignore(\"META-INF/MANIFEST.MF\");\n+    }\n+\n+    public static void configureTestTasks(Project project) {\n+        // Default test task should run only unit tests\n+        maybeConfigure(project.getTasks(), \"test\", Test.class, task -> task.include(\"**/*Tests.class\"));\n+\n+        // none of this stuff is applicable to the `:buildSrc` project tests\n+        if (project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+\n+        File heapdumpDir = new File(project.getBuildDir(), \"heapdump\");\n+\n+        project.getTasks().withType(Test.class).configureEach(test -> {\n+            File testOutputDir = new File(test.getReports().getJunitXml().getDestination(), \"output\");\n+\n+            ErrorReportingTestListener listener = new ErrorReportingTestListener(test.getTestLogging(), testOutputDir);\n+            test.getExtensions().add(\"errorReportingTestListener\", listener);\n+            test.addTestOutputListener(listener);\n+            test.addTestListener(listener);\n+\n+            /*\n+             * We use lazy-evaluated strings in order to configure system properties whose value will not be known until\n+             * execution time (e.g. cluster port numbers). Adding these via the normal DSL doesn't work as these get treated\n+             * as task inputs and therefore Gradle attempts to snapshot them before/after task execution. This fails due\n+             * to the GStrings containing references to non-serializable objects.\n+             *\n+             * We bypass this by instead passing this system properties vi a CommandLineArgumentProvider. This has the added\n+             * side-effect that these properties are NOT treated as inputs, therefore they don't influence things like the\n+             * build cache key or up to date checking.\n+             */\n+            SystemPropertyCommandLineArgumentProvider nonInputProperties = new SystemPropertyCommandLineArgumentProvider();\n+\n+            test.doFirst(t -> {\n+                project.mkdir(testOutputDir);\n+                project.mkdir(heapdumpDir);\n+                project.mkdir(test.getWorkingDir());\n+                project.mkdir(test.getWorkingDir().toPath().resolve(\"temp\"));\n+\n+                // TODO remove once jvm.options are added to test system properties\n+                test.systemProperty(\"java.locale.providers\", \"SPI,COMPAT\");\n+            });\n+            if (inFipsJvm()) {\n+                project.getDependencies().add(\"testRuntimeOnly\", \"org.bouncycastle:bc-fips:1.0.1\");\n+                project.getDependencies().add(\"testRuntimeOnly\", \"org.bouncycastle:bctls-fips:1.0.9\");\n+            }\n+            test.getJvmArgumentProviders().add(nonInputProperties);\n+            test.getExtensions().add(\"nonInputProperties\", nonInputProperties);\n+\n+            test.setWorkingDir(project.file(project.getBuildDir() + \"/testrun/\" + test.getName()));\n+            test.setMaxParallelForks(Integer.parseInt(System.getProperty(\"tests.jvms\", BuildParams.getDefaultParallel().toString())));\n+\n+            test.exclude(\"**/*$*.class\");\n+\n+            test.jvmArgs(\n+                \"-Xmx\" + System.getProperty(\"tests.heap.size\", \"512m\"),\n+                \"-Xms\" + System.getProperty(\"tests.heap.size\", \"512m\"),\n+                \"--illegal-access=warn\",\n+                \"-XX:+HeapDumpOnOutOfMemoryError\"\n+            );\n+\n+            test.getJvmArgumentProviders().add(() -> List.of(\"-XX:HeapDumpPath=$heapdumpDir\"));\n+\n+            String argline = System.getProperty(\"tests.jvm.argline\");\n+            if (argline != null) {\n+                test.jvmArgs((Object[]) argline.split(\" \"));\n+            }\n+\n+            if (Boolean.parseBoolean(System.getProperty(\"tests.asserts\", \"true\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02807869f9a5d418a6d66993d98bc31b57e61aa4"}, "originalPosition": 280}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5Mjk3NzY4OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjo0Mzo0MVrOGNdRpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzowMjowOVrOGNeC-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2NDMyNw==", "bodyText": "This seems to be in the old impl too, but what's with the ! suffix?", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416764327", "createdAt": "2020-04-28T16:43:41Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        compileConfig.extendsFrom(compileOnlyConfig);\n+\n+        // we are not shipping these jars, we act like dumb consumers of these things\n+        if (project.getPath().startsWith(\":test:fixtures\") || project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+        // fail on any conflicting dependency versions\n+        project.getConfigurations().all(configuration -> {\n+            if (configuration.getName().endsWith(\"Fixture\")) {\n+                // just a self contained test-fixture configuration, likely transitive and hellacious\n+                return;\n+            }\n+            configuration.resolutionStrategy(ResolutionStrategy::failOnVersionConflict);\n+        });\n+\n+        // force all dependencies added directly to compile/testCompile to be non-transitive, except for ES itself\n+        Consumer<String> disableTransitiveDeps = configName -> {\n+            Configuration config = project.getConfigurations().getByName(configName);\n+            config.getDependencies().all(dep -> {\n+                if (dep instanceof ModuleDependency\n+                    && dep instanceof ProjectDependency == false\n+                    && dep.getGroup().startsWith(\"org.elasticsearch\") == false) {\n+                    ((ModuleDependency) dep).setTransitive(false);\n+                }\n+            });\n+        };\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.RUNTIME_ONLY_CONFIGURATION_NAME);\n+    }\n+\n+    /** Adds compiler settings to the project */\n+    public static void configureCompile(Project project) {\n+        ExtraPropertiesExtension ext = project.getExtensions().getByType(ExtraPropertiesExtension.class);\n+        ext.set(\"compactProfile\", \"full\");\n+\n+        JavaPluginExtension java = project.getExtensions().getByType(JavaPluginExtension.class);\n+        java.setSourceCompatibility(BuildParams.getMinimumRuntimeVersion());\n+        java.setTargetCompatibility(BuildParams.getMinimumRuntimeVersion());\n+\n+        Function<File, String> canonicalPath = file -> {\n+            try {\n+                return file.getCanonicalPath();\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to get canonical path for \" + file, e);\n+            }\n+        };\n+        // common options to both java and groovy\n+        Consumer<CompileOptions> configureFork = compileOptions -> {\n+            // we only fork if the Gradle JDK is not the same as the compiler JDK\n+            String compilerJavaHome = canonicalPath.apply(BuildParams.getCompilerJavaHome());\n+            String currentJavaHome = canonicalPath.apply(Jvm.current().getJavaHome());\n+            if (compilerJavaHome.equals(currentJavaHome)) {\n+                compileOptions.setFork(false);\n+            } else {\n+                compileOptions.setFork(true);\n+                compileOptions.getForkOptions().setJavaHome(BuildParams.getCompilerJavaHome());\n+            }\n+        };\n+\n+        project.afterEvaluate(p -> {\n+            project.getTasks().withType(JavaCompile.class).configureEach(compileTask -> {\n+                CompileOptions compileOptions = compileTask.getOptions();\n+\n+                configureFork.accept(compileOptions);\n+                /*\n+                 * -path because gradle will send in paths that don't always exist.\n+                 * -missing because we have tons of missing @returns and @param.\n+                 * -serial because we don't use java serialization.\n+                 */\n+                // don't even think about passing args with -J-xxx, oracle will ask you to submit a bug report :)\n+                // fail on all javac warnings\n+                List<String> compilerArgs = compileOptions.getCompilerArgs();\n+                compilerArgs.add(\"-Werror\");\n+                compilerArgs.add(\"-Xlint:all,-path,-serial,-options,-deprecation,-try\");\n+                compilerArgs.add(\"-Xdoclint:all\");\n+                compilerArgs.add(\"-Xdoclint:-missing\");\n+\n+                // either disable annotation processor completely (default) or allow to enable them if an annotation processor is explicitly\n+                // defined\n+                if (compilerArgs.contains(\"-processor\") == false) {\n+                    compilerArgs.add(\"-proc:none\");\n+                }\n+\n+                compileOptions.setEncoding(\"UTF-8\");\n+                compileOptions.setIncremental(true);\n+\n+                // TODO: use native Gradle support for --release when available (cf. https://github.com/gradle/gradle/issues/2510)\n+                final JavaVersion targetCompatibilityVersion = JavaVersion.toVersion(compileTask.getTargetCompatibility());\n+                compilerArgs.add(\"--release\");\n+                compilerArgs.add(targetCompatibilityVersion.getMajorVersion());\n+\n+            });\n+            // also apply release flag to groovy, which is used in build-tools\n+            project.getTasks().withType(GroovyCompile.class).configureEach(compileTask -> {\n+                configureFork.accept(compileTask.getOptions());\n+\n+                // TODO: this probably shouldn't apply to groovy at all?\n+                // TODO: use native Gradle support for --release when available (cf. https://github.com/gradle/gradle/issues/2510)\n+                final JavaVersion targetCompatibilityVersion = JavaVersion.toVersion(compileTask.getTargetCompatibility());\n+                final List<String> compilerArgs = compileTask.getOptions().getCompilerArgs();\n+                compilerArgs.add(\"--release\");\n+                compilerArgs.add(targetCompatibilityVersion.getMajorVersion());\n+            });\n+        });\n+\n+        project.getPluginManager().withPlugin(\"com.github.johnrengelman.shadow\", plugin -> {\n+            // Ensure that when we are compiling against the \"original\" JAR that we also include any \"shadow\" dependencies on the compile\n+            // classpath\n+            Configuration shadowConfig = project.getConfigurations().getByName(ShadowBasePlugin.getCONFIGURATION_NAME());\n+            Configuration apiConfig = project.getConfigurations().getByName(JavaPlugin.API_ELEMENTS_CONFIGURATION_NAME);\n+            shadowConfig.getDependencies().all(dependency -> apiConfig.getDependencies().add(dependency));\n+        });\n+    }\n+\n+    /**\n+     * Apply runtime classpath input normalization so that changes in JAR manifests don't break build cacheability\n+     */\n+    public static void configureInputNormalization(Project project) {\n+        project.getNormalization().getRuntimeClasspath().ignore(\"META-INF/MANIFEST.MF\");\n+    }\n+\n+    public static void configureTestTasks(Project project) {\n+        // Default test task should run only unit tests\n+        maybeConfigure(project.getTasks(), \"test\", Test.class, task -> task.include(\"**/*Tests.class\"));\n+\n+        // none of this stuff is applicable to the `:buildSrc` project tests\n+        if (project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+\n+        File heapdumpDir = new File(project.getBuildDir(), \"heapdump\");\n+\n+        project.getTasks().withType(Test.class).configureEach(test -> {\n+            File testOutputDir = new File(test.getReports().getJunitXml().getDestination(), \"output\");\n+\n+            ErrorReportingTestListener listener = new ErrorReportingTestListener(test.getTestLogging(), testOutputDir);\n+            test.getExtensions().add(\"errorReportingTestListener\", listener);\n+            test.addTestOutputListener(listener);\n+            test.addTestListener(listener);\n+\n+            /*\n+             * We use lazy-evaluated strings in order to configure system properties whose value will not be known until\n+             * execution time (e.g. cluster port numbers). Adding these via the normal DSL doesn't work as these get treated\n+             * as task inputs and therefore Gradle attempts to snapshot them before/after task execution. This fails due\n+             * to the GStrings containing references to non-serializable objects.\n+             *\n+             * We bypass this by instead passing this system properties vi a CommandLineArgumentProvider. This has the added\n+             * side-effect that these properties are NOT treated as inputs, therefore they don't influence things like the\n+             * build cache key or up to date checking.\n+             */\n+            SystemPropertyCommandLineArgumentProvider nonInputProperties = new SystemPropertyCommandLineArgumentProvider();\n+\n+            test.doFirst(t -> {\n+                project.mkdir(testOutputDir);\n+                project.mkdir(heapdumpDir);\n+                project.mkdir(test.getWorkingDir());\n+                project.mkdir(test.getWorkingDir().toPath().resolve(\"temp\"));\n+\n+                // TODO remove once jvm.options are added to test system properties\n+                test.systemProperty(\"java.locale.providers\", \"SPI,COMPAT\");\n+            });\n+            if (inFipsJvm()) {\n+                project.getDependencies().add(\"testRuntimeOnly\", \"org.bouncycastle:bc-fips:1.0.1\");\n+                project.getDependencies().add(\"testRuntimeOnly\", \"org.bouncycastle:bctls-fips:1.0.9\");\n+            }\n+            test.getJvmArgumentProviders().add(nonInputProperties);\n+            test.getExtensions().add(\"nonInputProperties\", nonInputProperties);\n+\n+            test.setWorkingDir(project.file(project.getBuildDir() + \"/testrun/\" + test.getName()));\n+            test.setMaxParallelForks(Integer.parseInt(System.getProperty(\"tests.jvms\", BuildParams.getDefaultParallel().toString())));\n+\n+            test.exclude(\"**/*$*.class\");\n+\n+            test.jvmArgs(\n+                \"-Xmx\" + System.getProperty(\"tests.heap.size\", \"512m\"),\n+                \"-Xms\" + System.getProperty(\"tests.heap.size\", \"512m\"),\n+                \"--illegal-access=warn\",\n+                \"-XX:+HeapDumpOnOutOfMemoryError\"\n+            );\n+\n+            test.getJvmArgumentProviders().add(() -> List.of(\"-XX:HeapDumpPath=$heapdumpDir\"));\n+\n+            String argline = System.getProperty(\"tests.jvm.argline\");\n+            if (argline != null) {\n+                test.jvmArgs((Object[]) argline.split(\" \"));\n+            }\n+\n+            if (Boolean.parseBoolean(System.getProperty(\"tests.asserts\", \"true\"))) {\n+                test.jvmArgs(\"-ea\", \"-esa\");\n+            }\n+\n+            Map<String, String> sysprops = Map.of(\n+                \"java.awt.headless\",\n+                \"true\",\n+                \"tests.gradle\",\n+                \"true\",\n+                \"tests.artifact\",\n+                project.getName(),\n+                \"tests.task\",\n+                test.getPath(),\n+                \"tests.security.manager\",\n+                \"true\",\n+                \"jna.nosys\",\n+                \"true\"\n+            );\n+            test.systemProperties(sysprops);\n+\n+            // ignore changing test seed when build is passed -Dignore.tests.seed for cacheability experimentation\n+            if (System.getProperty(\"ignore.tests.seed\") != null) {\n+                nonInputProperties.systemProperty(\"tests.seed\", BuildParams.getTestSeed());\n+            } else {\n+                test.systemProperty(\"tests.seed\", BuildParams.getTestSeed());\n+            }\n+\n+            // don't track these as inputs since they contain absolute paths and break cache relocatability\n+            File gradleHome = project.getGradle().getGradleUserHomeDir();\n+            String gradleVersion = project.getGradle().getGradleVersion();\n+            nonInputProperties.systemProperty(\"gradle.dist.lib\", new File(project.getGradle().getGradleHomeDir(), \"lib\"));\n+            nonInputProperties.systemProperty(\n+                \"gradle.worker.jar\",\n+                gradleHome + \"/caches/\" + gradleVersion + \"/workerMain/gradle-worker.jar\"\n+            );\n+            nonInputProperties.systemProperty(\"gradle.user.home\", gradleHome);\n+            // we use 'temp' relative to CWD since this is per JVM and tests are forbidden from writing to CWD\n+            nonInputProperties.systemProperty(\"java.io.tmpdir\", test.getWorkingDir().toPath().resolve(\"temp\"));\n+\n+            nonInputProperties.systemProperty(\"compiler.java\", BuildParams.getCompilerJavaVersion().getMajorVersion());\n+            nonInputProperties.systemProperty(\"runtime.java\", BuildParams.getRuntimeJavaVersion().getMajorVersion());\n+\n+            // TODO: remove setting logging level via system property\n+            test.systemProperty(\"tests.logger.level\", \"WARN\");\n+            System.getProperties().entrySet().forEach(entry -> {\n+                if ((entry.getKey().toString().startsWith(\"tests.\") || entry.getKey().toString().startsWith(\"es.\"))) {\n+                    test.systemProperty(entry.getKey().toString(), entry.getValue());\n+                }\n+            });\n+\n+            // TODO: remove this once ctx isn't added to update script params in 7.0\n+            test.systemProperty(\"es.scripting.update.ctx_in_params\", \"false\");\n+\n+            // TODO: remove this property in 8.0\n+            test.systemProperty(\"es.search.rewrite_sort\", \"true\");\n+\n+            // TODO: remove this once cname is prepended to transport.publish_address by default in 8.0\n+            test.systemProperty(\"es.transport.cname_in_publish_address\", \"true\");\n+\n+            // Set netty system properties to the properties we configure in jvm.options\n+            test.systemProperty(\"io.netty.noUnsafe\", \"true\");\n+            test.systemProperty(\"io.netty.noKeySetOptimization\", \"true\");\n+            test.systemProperty(\"io.netty.recycler.maxCapacityPerThread\", \"0\");\n+\n+            test.testLogging(logging -> {\n+                logging.setShowExceptions(true);\n+                logging.setShowCauses(true);\n+                logging.setExceptionFormat(\"full\");\n+            });\n+\n+            if (OS.current().equals(OS.WINDOWS) && System.getProperty(\"tests.timeoutSuite\") == null) {\n+                // override the suite timeout to 30 mins for windows, because it has the most inefficient filesystem known to man\n+                test.systemProperty(\"tests.timeoutSuite\", \"1800000!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02807869f9a5d418a6d66993d98bc31b57e61aa4"}, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3Njk1Mw==", "bodyText": "From our own contributing docs, it seems the exclamation is important, although I have not found documentation on how it works. I'd like to leave this as a followup.", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416776953", "createdAt": "2020-04-28T17:02:09Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        compileConfig.extendsFrom(compileOnlyConfig);\n+\n+        // we are not shipping these jars, we act like dumb consumers of these things\n+        if (project.getPath().startsWith(\":test:fixtures\") || project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+        // fail on any conflicting dependency versions\n+        project.getConfigurations().all(configuration -> {\n+            if (configuration.getName().endsWith(\"Fixture\")) {\n+                // just a self contained test-fixture configuration, likely transitive and hellacious\n+                return;\n+            }\n+            configuration.resolutionStrategy(ResolutionStrategy::failOnVersionConflict);\n+        });\n+\n+        // force all dependencies added directly to compile/testCompile to be non-transitive, except for ES itself\n+        Consumer<String> disableTransitiveDeps = configName -> {\n+            Configuration config = project.getConfigurations().getByName(configName);\n+            config.getDependencies().all(dep -> {\n+                if (dep instanceof ModuleDependency\n+                    && dep instanceof ProjectDependency == false\n+                    && dep.getGroup().startsWith(\"org.elasticsearch\") == false) {\n+                    ((ModuleDependency) dep).setTransitive(false);\n+                }\n+            });\n+        };\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.RUNTIME_ONLY_CONFIGURATION_NAME);\n+    }\n+\n+    /** Adds compiler settings to the project */\n+    public static void configureCompile(Project project) {\n+        ExtraPropertiesExtension ext = project.getExtensions().getByType(ExtraPropertiesExtension.class);\n+        ext.set(\"compactProfile\", \"full\");\n+\n+        JavaPluginExtension java = project.getExtensions().getByType(JavaPluginExtension.class);\n+        java.setSourceCompatibility(BuildParams.getMinimumRuntimeVersion());\n+        java.setTargetCompatibility(BuildParams.getMinimumRuntimeVersion());\n+\n+        Function<File, String> canonicalPath = file -> {\n+            try {\n+                return file.getCanonicalPath();\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to get canonical path for \" + file, e);\n+            }\n+        };\n+        // common options to both java and groovy\n+        Consumer<CompileOptions> configureFork = compileOptions -> {\n+            // we only fork if the Gradle JDK is not the same as the compiler JDK\n+            String compilerJavaHome = canonicalPath.apply(BuildParams.getCompilerJavaHome());\n+            String currentJavaHome = canonicalPath.apply(Jvm.current().getJavaHome());\n+            if (compilerJavaHome.equals(currentJavaHome)) {\n+                compileOptions.setFork(false);\n+            } else {\n+                compileOptions.setFork(true);\n+                compileOptions.getForkOptions().setJavaHome(BuildParams.getCompilerJavaHome());\n+            }\n+        };\n+\n+        project.afterEvaluate(p -> {\n+            project.getTasks().withType(JavaCompile.class).configureEach(compileTask -> {\n+                CompileOptions compileOptions = compileTask.getOptions();\n+\n+                configureFork.accept(compileOptions);\n+                /*\n+                 * -path because gradle will send in paths that don't always exist.\n+                 * -missing because we have tons of missing @returns and @param.\n+                 * -serial because we don't use java serialization.\n+                 */\n+                // don't even think about passing args with -J-xxx, oracle will ask you to submit a bug report :)\n+                // fail on all javac warnings\n+                List<String> compilerArgs = compileOptions.getCompilerArgs();\n+                compilerArgs.add(\"-Werror\");\n+                compilerArgs.add(\"-Xlint:all,-path,-serial,-options,-deprecation,-try\");\n+                compilerArgs.add(\"-Xdoclint:all\");\n+                compilerArgs.add(\"-Xdoclint:-missing\");\n+\n+                // either disable annotation processor completely (default) or allow to enable them if an annotation processor is explicitly\n+                // defined\n+                if (compilerArgs.contains(\"-processor\") == false) {\n+                    compilerArgs.add(\"-proc:none\");\n+                }\n+\n+                compileOptions.setEncoding(\"UTF-8\");\n+                compileOptions.setIncremental(true);\n+\n+                // TODO: use native Gradle support for --release when available (cf. https://github.com/gradle/gradle/issues/2510)\n+                final JavaVersion targetCompatibilityVersion = JavaVersion.toVersion(compileTask.getTargetCompatibility());\n+                compilerArgs.add(\"--release\");\n+                compilerArgs.add(targetCompatibilityVersion.getMajorVersion());\n+\n+            });\n+            // also apply release flag to groovy, which is used in build-tools\n+            project.getTasks().withType(GroovyCompile.class).configureEach(compileTask -> {\n+                configureFork.accept(compileTask.getOptions());\n+\n+                // TODO: this probably shouldn't apply to groovy at all?\n+                // TODO: use native Gradle support for --release when available (cf. https://github.com/gradle/gradle/issues/2510)\n+                final JavaVersion targetCompatibilityVersion = JavaVersion.toVersion(compileTask.getTargetCompatibility());\n+                final List<String> compilerArgs = compileTask.getOptions().getCompilerArgs();\n+                compilerArgs.add(\"--release\");\n+                compilerArgs.add(targetCompatibilityVersion.getMajorVersion());\n+            });\n+        });\n+\n+        project.getPluginManager().withPlugin(\"com.github.johnrengelman.shadow\", plugin -> {\n+            // Ensure that when we are compiling against the \"original\" JAR that we also include any \"shadow\" dependencies on the compile\n+            // classpath\n+            Configuration shadowConfig = project.getConfigurations().getByName(ShadowBasePlugin.getCONFIGURATION_NAME());\n+            Configuration apiConfig = project.getConfigurations().getByName(JavaPlugin.API_ELEMENTS_CONFIGURATION_NAME);\n+            shadowConfig.getDependencies().all(dependency -> apiConfig.getDependencies().add(dependency));\n+        });\n+    }\n+\n+    /**\n+     * Apply runtime classpath input normalization so that changes in JAR manifests don't break build cacheability\n+     */\n+    public static void configureInputNormalization(Project project) {\n+        project.getNormalization().getRuntimeClasspath().ignore(\"META-INF/MANIFEST.MF\");\n+    }\n+\n+    public static void configureTestTasks(Project project) {\n+        // Default test task should run only unit tests\n+        maybeConfigure(project.getTasks(), \"test\", Test.class, task -> task.include(\"**/*Tests.class\"));\n+\n+        // none of this stuff is applicable to the `:buildSrc` project tests\n+        if (project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+\n+        File heapdumpDir = new File(project.getBuildDir(), \"heapdump\");\n+\n+        project.getTasks().withType(Test.class).configureEach(test -> {\n+            File testOutputDir = new File(test.getReports().getJunitXml().getDestination(), \"output\");\n+\n+            ErrorReportingTestListener listener = new ErrorReportingTestListener(test.getTestLogging(), testOutputDir);\n+            test.getExtensions().add(\"errorReportingTestListener\", listener);\n+            test.addTestOutputListener(listener);\n+            test.addTestListener(listener);\n+\n+            /*\n+             * We use lazy-evaluated strings in order to configure system properties whose value will not be known until\n+             * execution time (e.g. cluster port numbers). Adding these via the normal DSL doesn't work as these get treated\n+             * as task inputs and therefore Gradle attempts to snapshot them before/after task execution. This fails due\n+             * to the GStrings containing references to non-serializable objects.\n+             *\n+             * We bypass this by instead passing this system properties vi a CommandLineArgumentProvider. This has the added\n+             * side-effect that these properties are NOT treated as inputs, therefore they don't influence things like the\n+             * build cache key or up to date checking.\n+             */\n+            SystemPropertyCommandLineArgumentProvider nonInputProperties = new SystemPropertyCommandLineArgumentProvider();\n+\n+            test.doFirst(t -> {\n+                project.mkdir(testOutputDir);\n+                project.mkdir(heapdumpDir);\n+                project.mkdir(test.getWorkingDir());\n+                project.mkdir(test.getWorkingDir().toPath().resolve(\"temp\"));\n+\n+                // TODO remove once jvm.options are added to test system properties\n+                test.systemProperty(\"java.locale.providers\", \"SPI,COMPAT\");\n+            });\n+            if (inFipsJvm()) {\n+                project.getDependencies().add(\"testRuntimeOnly\", \"org.bouncycastle:bc-fips:1.0.1\");\n+                project.getDependencies().add(\"testRuntimeOnly\", \"org.bouncycastle:bctls-fips:1.0.9\");\n+            }\n+            test.getJvmArgumentProviders().add(nonInputProperties);\n+            test.getExtensions().add(\"nonInputProperties\", nonInputProperties);\n+\n+            test.setWorkingDir(project.file(project.getBuildDir() + \"/testrun/\" + test.getName()));\n+            test.setMaxParallelForks(Integer.parseInt(System.getProperty(\"tests.jvms\", BuildParams.getDefaultParallel().toString())));\n+\n+            test.exclude(\"**/*$*.class\");\n+\n+            test.jvmArgs(\n+                \"-Xmx\" + System.getProperty(\"tests.heap.size\", \"512m\"),\n+                \"-Xms\" + System.getProperty(\"tests.heap.size\", \"512m\"),\n+                \"--illegal-access=warn\",\n+                \"-XX:+HeapDumpOnOutOfMemoryError\"\n+            );\n+\n+            test.getJvmArgumentProviders().add(() -> List.of(\"-XX:HeapDumpPath=$heapdumpDir\"));\n+\n+            String argline = System.getProperty(\"tests.jvm.argline\");\n+            if (argline != null) {\n+                test.jvmArgs((Object[]) argline.split(\" \"));\n+            }\n+\n+            if (Boolean.parseBoolean(System.getProperty(\"tests.asserts\", \"true\"))) {\n+                test.jvmArgs(\"-ea\", \"-esa\");\n+            }\n+\n+            Map<String, String> sysprops = Map.of(\n+                \"java.awt.headless\",\n+                \"true\",\n+                \"tests.gradle\",\n+                \"true\",\n+                \"tests.artifact\",\n+                project.getName(),\n+                \"tests.task\",\n+                test.getPath(),\n+                \"tests.security.manager\",\n+                \"true\",\n+                \"jna.nosys\",\n+                \"true\"\n+            );\n+            test.systemProperties(sysprops);\n+\n+            // ignore changing test seed when build is passed -Dignore.tests.seed for cacheability experimentation\n+            if (System.getProperty(\"ignore.tests.seed\") != null) {\n+                nonInputProperties.systemProperty(\"tests.seed\", BuildParams.getTestSeed());\n+            } else {\n+                test.systemProperty(\"tests.seed\", BuildParams.getTestSeed());\n+            }\n+\n+            // don't track these as inputs since they contain absolute paths and break cache relocatability\n+            File gradleHome = project.getGradle().getGradleUserHomeDir();\n+            String gradleVersion = project.getGradle().getGradleVersion();\n+            nonInputProperties.systemProperty(\"gradle.dist.lib\", new File(project.getGradle().getGradleHomeDir(), \"lib\"));\n+            nonInputProperties.systemProperty(\n+                \"gradle.worker.jar\",\n+                gradleHome + \"/caches/\" + gradleVersion + \"/workerMain/gradle-worker.jar\"\n+            );\n+            nonInputProperties.systemProperty(\"gradle.user.home\", gradleHome);\n+            // we use 'temp' relative to CWD since this is per JVM and tests are forbidden from writing to CWD\n+            nonInputProperties.systemProperty(\"java.io.tmpdir\", test.getWorkingDir().toPath().resolve(\"temp\"));\n+\n+            nonInputProperties.systemProperty(\"compiler.java\", BuildParams.getCompilerJavaVersion().getMajorVersion());\n+            nonInputProperties.systemProperty(\"runtime.java\", BuildParams.getRuntimeJavaVersion().getMajorVersion());\n+\n+            // TODO: remove setting logging level via system property\n+            test.systemProperty(\"tests.logger.level\", \"WARN\");\n+            System.getProperties().entrySet().forEach(entry -> {\n+                if ((entry.getKey().toString().startsWith(\"tests.\") || entry.getKey().toString().startsWith(\"es.\"))) {\n+                    test.systemProperty(entry.getKey().toString(), entry.getValue());\n+                }\n+            });\n+\n+            // TODO: remove this once ctx isn't added to update script params in 7.0\n+            test.systemProperty(\"es.scripting.update.ctx_in_params\", \"false\");\n+\n+            // TODO: remove this property in 8.0\n+            test.systemProperty(\"es.search.rewrite_sort\", \"true\");\n+\n+            // TODO: remove this once cname is prepended to transport.publish_address by default in 8.0\n+            test.systemProperty(\"es.transport.cname_in_publish_address\", \"true\");\n+\n+            // Set netty system properties to the properties we configure in jvm.options\n+            test.systemProperty(\"io.netty.noUnsafe\", \"true\");\n+            test.systemProperty(\"io.netty.noKeySetOptimization\", \"true\");\n+            test.systemProperty(\"io.netty.recycler.maxCapacityPerThread\", \"0\");\n+\n+            test.testLogging(logging -> {\n+                logging.setShowExceptions(true);\n+                logging.setShowCauses(true);\n+                logging.setExceptionFormat(\"full\");\n+            });\n+\n+            if (OS.current().equals(OS.WINDOWS) && System.getProperty(\"tests.timeoutSuite\") == null) {\n+                // override the suite timeout to 30 mins for windows, because it has the most inefficient filesystem known to man\n+                test.systemProperty(\"tests.timeoutSuite\", \"1800000!\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2NDMyNw=="}, "originalCommit": {"oid": "02807869f9a5d418a6d66993d98bc31b57e61aa4"}, "originalPosition": 352}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2632, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}