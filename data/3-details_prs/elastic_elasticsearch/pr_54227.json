{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzNzkyODc4", "number": 54227, "title": "EQL: Sequence/Join parsing and model", "bodyText": "PR that parses the grammar for EQL join and sequence and creates their respective domain model.\nThe physical plan and execution will follow-up up in a separate PR.", "createdAt": "2020-03-25T19:47:50Z", "url": "https://github.com/elastic/elasticsearch/pull/54227", "merged": true, "mergeCommit": {"oid": "9e9632d41a39877256c68634ab18e441f4b67fe8"}, "closed": true, "closedAt": "2020-04-06T20:15:06Z", "author": {"login": "costin"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTI17JgBqjMxODQ5NzQxMzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcU_j5qAFqTM4ODI5OTgyMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "09ef12b3f90a0aa606ee82a592554751a5c0e909", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/09ef12b3f90a0aa606ee82a592554751a5c0e909", "committedDate": "2020-03-22T13:05:58Z", "message": "wip"}, "afterCommit": {"oid": "c5d7a3f213b53d5a623796818f23d64c539a4e73", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/c5d7a3f213b53d5a623796818f23d64c539a4e73", "committedDate": "2020-03-31T20:03:20Z", "message": "Initial model and parsing for Join"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b7dfeac1ea7b4af379342fcad761de4c5787432", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/9b7dfeac1ea7b4af379342fcad761de4c5787432", "committedDate": "2020-04-02T12:13:58Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f00e6f088f14f7bc0cfa8ca77a5c31215bd9391c", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/f00e6f088f14f7bc0cfa8ca77a5c31215bd9391c", "committedDate": "2020-04-02T12:13:58Z", "message": "Initial model and parsing for Join"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96550c11222b5738628c6ac6cd3589bd5ff199d7", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/96550c11222b5738628c6ac6cd3589bd5ff199d7", "committedDate": "2020-04-02T12:13:59Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "adfa27c40a0979a139bf2cb97464652ce811443f", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/adfa27c40a0979a139bf2cb97464652ce811443f", "committedDate": "2020-04-02T13:01:25Z", "message": "Done with parsing, need to improve the test suite."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c5d7a3f213b53d5a623796818f23d64c539a4e73", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/c5d7a3f213b53d5a623796818f23d64c539a4e73", "committedDate": "2020-03-31T20:03:20Z", "message": "Initial model and parsing for Join"}, "afterCommit": {"oid": "adfa27c40a0979a139bf2cb97464652ce811443f", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/adfa27c40a0979a139bf2cb97464652ce811443f", "committedDate": "2020-04-02T13:01:25Z", "message": "Done with parsing, need to improve the test suite."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d4d3948fc845b28153537d4d6a3bd47ac5f5b43", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/6d4d3948fc845b28153537d4d6a3bd47ac5f5b43", "committedDate": "2020-04-03T21:28:40Z", "message": "Add more parsing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d344373133fbd0f261bb5e2292bea65193d1b75", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/1d344373133fbd0f261bb5e2292bea65193d1b75", "committedDate": "2020-04-03T21:29:24Z", "message": "Merge remote-tracking branch 'remotes/upstream/master' into eql/sequence"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NjE3NTUz", "url": "https://github.com/elastic/elasticsearch/pull/54227#pullrequestreview-387617553", "createdAt": "2020-04-03T22:34:44Z", "commit": {"oid": "1d344373133fbd0f261bb5e2292bea65193d1b75"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QyMjozNDo0NFrOGArogA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QyMjozNDo0NFrOGArogA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM2ODA2NA==", "bodyText": "I added #54760 to track an issue for removing unknown time units and only supporting ones that are recognized by range queries.", "url": "https://github.com/elastic/elasticsearch/pull/54227#discussion_r403368064", "createdAt": "2020-04-03T22:34:44Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LogicalPlanBuilder.java", "diffHunk": "@@ -44,11 +61,157 @@ public LogicalPlan visitEventQuery(EqlBaseParser.EventQueryContext ctx) {\n             condition = new And(source, eventMatch, condition);\n         }\n \n-        Filter filter = new Filter(source, new UnresolvedRelation(Source.EMPTY, null, \"\", false, \"\"), condition);\n-        // add implicit sorting - when pipes are added, this would better seat there (as a default pipe)\n+        Filter filter = new Filter(source, RELATION, condition);\n+        // add implicit sorting - when pipes are added, this would better sit there (as a default pipe)\n         Order order = new Order(source, new UnresolvedAttribute(source, params.fieldTimestamp()), Order.OrderDirection.ASC,\n                 Order.NullsPosition.FIRST);\n         OrderBy orderBy = new OrderBy(source, filter, singletonList(order));\n         return orderBy;\n     }\n-}\n+\n+    @Override\n+    public Join visitJoin(JoinContext ctx) {\n+        List<Expression> parentJoinKeys = visitJoinKeys(ctx.by);\n+\n+        LogicalPlan until;\n+        \n+        if (ctx.until != null) {\n+            until = visitJoinTerm(ctx.until, parentJoinKeys);\n+        } else {\n+            // no until declared means the condition never gets executed and thus folds to false\n+            until = new Filter(source(ctx), RELATION, new Literal(source(ctx), Boolean.FALSE, DataTypes.BOOLEAN));\n+        }\n+        \n+        int numberOfKeys = -1;\n+        List<LogicalPlan> queries = new ArrayList<>(ctx.joinTerm().size());\n+\n+        for (JoinTermContext joinTermCtx : ctx.joinTerm()) {\n+            KeyedFilter joinTerm = visitJoinTerm(joinTermCtx, parentJoinKeys);\n+            int keySize = joinTerm.keys().size();\n+            if (numberOfKeys < 0) {\n+                numberOfKeys = keySize;\n+            } else {\n+                if (numberOfKeys != keySize) {\n+                    Source src = source(joinTermCtx.by != null ? joinTermCtx.by : joinTermCtx);\n+                    int expected = numberOfKeys - parentJoinKeys.size();\n+                    int found = keySize - parentJoinKeys.size();\n+                    throw new ParsingException(src, \"Inconsistent number of join keys specified; expected [{}] but found [{}]\", expected,\n+                            found);\n+                }\n+                queries.add(joinTerm);\n+            }\n+        }\n+\n+        return new Join(source(ctx), queries, until);\n+    }\n+\n+    public KeyedFilter visitJoinTerm(JoinTermContext ctx, List<Expression> joinKeys) {\n+        List<Expression> keys = CollectionUtils.combine(joinKeys, visitJoinKeys(ctx.by));\n+        return new KeyedFilter(source(ctx), visitEventQuery(ctx.subquery().eventQuery()), keys);\n+    }\n+\n+    @Override\n+    public Sequence visitSequence(SequenceContext ctx) {\n+        List<Expression> parentJoinKeys = visitJoinKeys(ctx.by);\n+\n+        TimeValue maxSpan = visitSequenceParams(ctx.sequenceParams());\n+\n+        LogicalPlan until;\n+\n+        if (ctx.until != null) {\n+            until = visitSequenceTerm(ctx.until, parentJoinKeys);\n+        } else {\n+            // no until declared means the condition never gets executed and thus folds to false\n+            until = new Filter(source(ctx), RELATION, new Literal(source(ctx), Boolean.FALSE, DataTypes.BOOLEAN));\n+        }\n+\n+        int numberOfKeys = -1;\n+        List<LogicalPlan> queries = new ArrayList<>(ctx.sequenceTerm().size());\n+\n+        for (SequenceTermContext sequenceTermCtx : ctx.sequenceTerm()) {\n+            KeyedFilter sequenceTerm = visitSequenceTerm(sequenceTermCtx, parentJoinKeys);\n+            int keySize = sequenceTerm.keys().size();\n+            if (numberOfKeys < 0) {\n+                numberOfKeys = keySize;\n+            } else {\n+                if (numberOfKeys != keySize) {\n+                    Source src = source(sequenceTermCtx.by != null ? sequenceTermCtx.by : sequenceTermCtx);\n+                    int expected = numberOfKeys - parentJoinKeys.size();\n+                    int found = keySize - parentJoinKeys.size();\n+                    throw new ParsingException(src, \"Inconsistent number of join keys specified; expected [{}] but found [{}]\", expected,\n+                            found);\n+                }\n+                queries.add(sequenceTerm);\n+            }\n+        }\n+\n+        return new Sequence(source(ctx), queries, until, maxSpan);\n+    }\n+\n+    public KeyedFilter visitSequenceTerm(SequenceTermContext ctx, List<Expression> joinKeys) {\n+        if (ctx.FORK() != null) {\n+            throw new ParsingException(source(ctx.FORK()), \"sequence fork is unsupported\");\n+        }\n+\n+        List<Expression> keys = CollectionUtils.combine(joinKeys, visitJoinKeys(ctx.by));\n+        return new KeyedFilter(source(ctx), visitEventQuery(ctx.subquery().eventQuery()), keys);\n+    }\n+\n+    @Override\n+    public TimeValue visitSequenceParams(SequenceParamsContext ctx) {\n+        if (ctx == null) {\n+            return TimeValue.MINUS_ONE;\n+        }\n+\n+        NumberContext numberCtx = ctx.timeUnit().number();\n+        if (numberCtx instanceof IntegerLiteralContext) {\n+            Number number = (Number) visitIntegerLiteral((IntegerLiteralContext) numberCtx).fold();\n+            long value = number.longValue();\n+            \n+            if (value <= 0) {\n+                throw new ParsingException(source(numberCtx), \"A positive maxspan value is required; found [{}]\", value);\n+            }\n+            \n+            String timeString = text(ctx.timeUnit().IDENTIFIER());\n+            TimeUnit timeUnit = TimeUnit.SECONDS;\n+            if (timeString != null) {\n+                switch (timeString) {\n+                    case \"\":\n+                    case \"s\":\n+                    case \"sec\":\n+                    case \"secs\":\n+                    case \"second\":\n+                    case \"seconds\":\n+                        timeUnit = TimeUnit.SECONDS;\n+                        break;\n+                    case \"m\":\n+                    case \"min\":\n+                    case \"mins\":\n+                    case \"minute\":\n+                    case \"minutes\":\n+                        timeUnit = TimeUnit.MINUTES;\n+                        break;\n+                    case \"h\":\n+                    case \"hs\":\n+                    case \"hour\":\n+                    case \"hours\":\n+                        timeUnit = TimeUnit.HOURS;\n+                        break;\n+                    case \"d\":\n+                    case \"ds\":\n+                    case \"day\":\n+                    case \"days\":\n+                        timeUnit = TimeUnit.DAYS;\n+                        break;\n+                    default:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d344373133fbd0f261bb5e2292bea65193d1b75"}, "originalPosition": 186}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fb96ca04c34bc556ffad4ceacd5bb76a56e3fc3", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/0fb96ca04c34bc556ffad4ceacd5bb76a56e3fc3", "committedDate": "2020-04-04T18:54:56Z", "message": "Merge branch 'master' into eql/sequence"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08bd9240399c22446d61512d8c70431d97e09318", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/08bd9240399c22446d61512d8c70431d97e09318", "committedDate": "2020-04-05T17:11:38Z", "message": "Merge branch 'master' into eql/sequence"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4Mjk5ODIz", "url": "https://github.com/elastic/elasticsearch/pull/54227#pullrequestreview-388299823", "createdAt": "2020-04-06T14:22:26Z", "commit": {"oid": "08bd9240399c22446d61512d8c70431d97e09318"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDoyMjoyNlrOGBaMHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDoyMjoyNlrOGBaMHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEzMDg0Ng==", "bodyText": "does the sequence of 0 timespan make sense at all?", "url": "https://github.com/elastic/elasticsearch/pull/54227#discussion_r404130846", "createdAt": "2020-04-06T14:22:26Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LogicalPlanBuilder.java", "diffHunk": "@@ -44,11 +61,157 @@ public LogicalPlan visitEventQuery(EqlBaseParser.EventQueryContext ctx) {\n             condition = new And(source, eventMatch, condition);\n         }\n \n-        Filter filter = new Filter(source, new UnresolvedRelation(Source.EMPTY, null, \"\", false, \"\"), condition);\n-        // add implicit sorting - when pipes are added, this would better seat there (as a default pipe)\n+        Filter filter = new Filter(source, RELATION, condition);\n+        // add implicit sorting - when pipes are added, this would better sit there (as a default pipe)\n         Order order = new Order(source, new UnresolvedAttribute(source, params.fieldTimestamp()), Order.OrderDirection.ASC,\n                 Order.NullsPosition.FIRST);\n         OrderBy orderBy = new OrderBy(source, filter, singletonList(order));\n         return orderBy;\n     }\n-}\n+\n+    @Override\n+    public Join visitJoin(JoinContext ctx) {\n+        List<Expression> parentJoinKeys = visitJoinKeys(ctx.by);\n+\n+        LogicalPlan until;\n+        \n+        if (ctx.until != null) {\n+            until = visitJoinTerm(ctx.until, parentJoinKeys);\n+        } else {\n+            // no until declared means the condition never gets executed and thus folds to false\n+            until = new Filter(source(ctx), RELATION, new Literal(source(ctx), Boolean.FALSE, DataTypes.BOOLEAN));\n+        }\n+        \n+        int numberOfKeys = -1;\n+        List<LogicalPlan> queries = new ArrayList<>(ctx.joinTerm().size());\n+\n+        for (JoinTermContext joinTermCtx : ctx.joinTerm()) {\n+            KeyedFilter joinTerm = visitJoinTerm(joinTermCtx, parentJoinKeys);\n+            int keySize = joinTerm.keys().size();\n+            if (numberOfKeys < 0) {\n+                numberOfKeys = keySize;\n+            } else {\n+                if (numberOfKeys != keySize) {\n+                    Source src = source(joinTermCtx.by != null ? joinTermCtx.by : joinTermCtx);\n+                    int expected = numberOfKeys - parentJoinKeys.size();\n+                    int found = keySize - parentJoinKeys.size();\n+                    throw new ParsingException(src, \"Inconsistent number of join keys specified; expected [{}] but found [{}]\", expected,\n+                            found);\n+                }\n+                queries.add(joinTerm);\n+            }\n+        }\n+\n+        return new Join(source(ctx), queries, until);\n+    }\n+\n+    public KeyedFilter visitJoinTerm(JoinTermContext ctx, List<Expression> joinKeys) {\n+        List<Expression> keys = CollectionUtils.combine(joinKeys, visitJoinKeys(ctx.by));\n+        return new KeyedFilter(source(ctx), visitEventQuery(ctx.subquery().eventQuery()), keys);\n+    }\n+\n+    @Override\n+    public Sequence visitSequence(SequenceContext ctx) {\n+        List<Expression> parentJoinKeys = visitJoinKeys(ctx.by);\n+\n+        TimeValue maxSpan = visitSequenceParams(ctx.sequenceParams());\n+\n+        LogicalPlan until;\n+\n+        if (ctx.until != null) {\n+            until = visitSequenceTerm(ctx.until, parentJoinKeys);\n+        } else {\n+            // no until declared means the condition never gets executed and thus folds to false\n+            until = new Filter(source(ctx), RELATION, new Literal(source(ctx), Boolean.FALSE, DataTypes.BOOLEAN));\n+        }\n+\n+        int numberOfKeys = -1;\n+        List<LogicalPlan> queries = new ArrayList<>(ctx.sequenceTerm().size());\n+\n+        for (SequenceTermContext sequenceTermCtx : ctx.sequenceTerm()) {\n+            KeyedFilter sequenceTerm = visitSequenceTerm(sequenceTermCtx, parentJoinKeys);\n+            int keySize = sequenceTerm.keys().size();\n+            if (numberOfKeys < 0) {\n+                numberOfKeys = keySize;\n+            } else {\n+                if (numberOfKeys != keySize) {\n+                    Source src = source(sequenceTermCtx.by != null ? sequenceTermCtx.by : sequenceTermCtx);\n+                    int expected = numberOfKeys - parentJoinKeys.size();\n+                    int found = keySize - parentJoinKeys.size();\n+                    throw new ParsingException(src, \"Inconsistent number of join keys specified; expected [{}] but found [{}]\", expected,\n+                            found);\n+                }\n+                queries.add(sequenceTerm);\n+            }\n+        }\n+\n+        return new Sequence(source(ctx), queries, until, maxSpan);\n+    }\n+\n+    public KeyedFilter visitSequenceTerm(SequenceTermContext ctx, List<Expression> joinKeys) {\n+        if (ctx.FORK() != null) {\n+            throw new ParsingException(source(ctx.FORK()), \"sequence fork is unsupported\");\n+        }\n+\n+        List<Expression> keys = CollectionUtils.combine(joinKeys, visitJoinKeys(ctx.by));\n+        return new KeyedFilter(source(ctx), visitEventQuery(ctx.subquery().eventQuery()), keys);\n+    }\n+\n+    @Override\n+    public TimeValue visitSequenceParams(SequenceParamsContext ctx) {\n+        if (ctx == null) {\n+            return TimeValue.MINUS_ONE;\n+        }\n+\n+        NumberContext numberCtx = ctx.timeUnit().number();\n+        if (numberCtx instanceof IntegerLiteralContext) {\n+            Number number = (Number) visitIntegerLiteral((IntegerLiteralContext) numberCtx).fold();\n+            long value = number.longValue();\n+            \n+            if (value <= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08bd9240399c22446d61512d8c70431d97e09318"}, "originalPosition": 151}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1583, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}