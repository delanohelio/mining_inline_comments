{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2NzAzMDE5", "number": 52483, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNjo0NTozOVrODgxVOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNTo0MjowMlrODhkzlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1Njg5Mjc0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/AggregationResultUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNjo0NTozOVrOFrKC9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxMTo0NTo0OVrOFrlInw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NzY4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            nested.put(subAgg.getName(), getExtractor(subAgg).value(subAgg, fieldTypeMap.get(agg.getName()), fieldTypeMap));\n          \n          \n            \n                            nested.put(subAgg.getName(), getExtractor(subAgg).value(subAgg, fieldTypeMap.get(subAgg.getName()), fieldTypeMap));\n          \n      \n    \n    \n  \n\nWe should use the subAgg field type no? If we just used the parent agg's type, we could pass fieldType", "url": "https://github.com/elastic/elasticsearch/pull/52483#discussion_r380797686", "createdAt": "2020-02-18T16:45:39Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/AggregationResultUtils.java", "diffHunk": "@@ -211,17 +215,35 @@ public Object value(Aggregation agg, String fieldType) {\n         }\n     }\n \n+    static class SingleBucketAggExtractor implements AggValueExtractor {\n+        @Override\n+        public Object value(Aggregation agg, String fieldType, Map<String, String> fieldTypeMap) {\n+            SingleBucketAggregation aggregation = (SingleBucketAggregation) agg;\n+\n+            if (aggregation.getAggregations().iterator().hasNext() == false) {\n+                return aggregation.getDocCount();\n+            }\n+\n+            HashMap<String, Object> nested = new HashMap<>();\n+            for (Aggregation subAgg : aggregation.getAggregations()) {\n+                nested.put(subAgg.getName(), getExtractor(subAgg).value(subAgg, fieldTypeMap.get(agg.getName()), fieldTypeMap));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78b63e334cd3c10cfcf3b399048cd453d22734ef"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwMTM4Mg==", "bodyText": "\ud83e\udd14\nDoes this actually work? It seems like we should recursively supply the String fieldName or something and then read that from fieldTypeMap.\nThat way we can continually append the field name.\nSomething like\nnested.put(subAgg.getName(), getExtractor(subAgg).value(subAgg, fieldName + \".\" + subAgg.getName(), fieldTypeMap));\n\nAnd those that worry about fieldType can get it from the fieldTypeMap", "url": "https://github.com/elastic/elasticsearch/pull/52483#discussion_r380801382", "createdAt": "2020-02-18T16:51:34Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/AggregationResultUtils.java", "diffHunk": "@@ -211,17 +215,35 @@ public Object value(Aggregation agg, String fieldType) {\n         }\n     }\n \n+    static class SingleBucketAggExtractor implements AggValueExtractor {\n+        @Override\n+        public Object value(Aggregation agg, String fieldType, Map<String, String> fieldTypeMap) {\n+            SingleBucketAggregation aggregation = (SingleBucketAggregation) agg;\n+\n+            if (aggregation.getAggregations().iterator().hasNext() == false) {\n+                return aggregation.getDocCount();\n+            }\n+\n+            HashMap<String, Object> nested = new HashMap<>();\n+            for (Aggregation subAgg : aggregation.getAggregations()) {\n+                nested.put(subAgg.getName(), getExtractor(subAgg).value(subAgg, fieldTypeMap.get(agg.getName()), fieldTypeMap));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NzY4Ng=="}, "originalCommit": {"oid": "78b63e334cd3c10cfcf3b399048cd453d22734ef"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI0MTUwMw==", "bodyText": "good catch! I think that makes sense.\nIn order to fix this, I will create a test combines both mapping deduction and value extraction, both are tested individually at the moment which makes it hard to discover bugs like this.", "url": "https://github.com/elastic/elasticsearch/pull/52483#discussion_r381241503", "createdAt": "2020-02-19T11:45:49Z", "author": {"login": "hendrikmuhs"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/AggregationResultUtils.java", "diffHunk": "@@ -211,17 +215,35 @@ public Object value(Aggregation agg, String fieldType) {\n         }\n     }\n \n+    static class SingleBucketAggExtractor implements AggValueExtractor {\n+        @Override\n+        public Object value(Aggregation agg, String fieldType, Map<String, String> fieldTypeMap) {\n+            SingleBucketAggregation aggregation = (SingleBucketAggregation) agg;\n+\n+            if (aggregation.getAggregations().iterator().hasNext() == false) {\n+                return aggregation.getDocCount();\n+            }\n+\n+            HashMap<String, Object> nested = new HashMap<>();\n+            for (Aggregation subAgg : aggregation.getAggregations()) {\n+                nested.put(subAgg.getName(), getExtractor(subAgg).value(subAgg, fieldTypeMap.get(agg.getName()), fieldTypeMap));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NzY4Ng=="}, "originalCommit": {"oid": "78b63e334cd3c10cfcf3b399048cd453d22734ef"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTMyNjMwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/AggregationResultUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNTo0MjowMlrOFsYdwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNTo0MjowMlrOFsYdwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA4MjQ5Nw==", "bodyText": "It strikes me that supplying fieldType is no longer necessary.\nAnything that desires to know fieldType could look it up via its own agg name combined with the prefix (if not empty).", "url": "https://github.com/elastic/elasticsearch/pull/52483#discussion_r382082497", "createdAt": "2020-02-20T15:42:02Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/AggregationResultUtils.java", "diffHunk": "@@ -211,17 +215,44 @@ public Object value(Aggregation agg, String fieldType) {\n         }\n     }\n \n+    static class SingleBucketAggExtractor implements AggValueExtractor {\n+        @Override\n+        public Object value(Aggregation agg, String fieldType, Map<String, String> fieldTypeMap, String lookupFieldPrefix) {\n+            SingleBucketAggregation aggregation = (SingleBucketAggregation) agg;\n+\n+            if (aggregation.getAggregations().iterator().hasNext() == false) {\n+                return aggregation.getDocCount();\n+            }\n+\n+            HashMap<String, Object> nested = new HashMap<>();\n+            for (Aggregation subAgg : aggregation.getAggregations()) {\n+                String subLookupFieldPrefix = lookupFieldPrefix.isEmpty() ? agg.getName() : lookupFieldPrefix + \".\" + agg.getName();\n+                nested.put(\n+                    subAgg.getName(),\n+                    getExtractor(subAgg).value(\n+                        subAgg,\n+                        fieldTypeMap.get(subLookupFieldPrefix + \".\" + subAgg.getName()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3279744e53c6a532ee6c23c710a7dd0ab8c665b"}, "originalPosition": 78}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3949, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}