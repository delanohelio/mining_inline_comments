{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5MTUwMzI2", "number": 53592, "reviewThreads": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDowNzo1N1rODoWN8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMDoxMjo0MlrODpcdOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNjMzNjQ4OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDowNzo1N1rOF21t2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzoxNTozNVrOF3QNEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0NzUxNQ==", "bodyText": "We should probably not force users to remember to set this to false, although true seems to be the default. I wonder if we shold either\n\nset the value to false automatically for every SearchRequest once it is set for an AsyncSearchRequest\nignore this parameter as request parameter when sending the request\nignore this paramter on the receiving Rest action regardless of how it is set in the client (maybe warn)\nfail on the client side already when validating the request. This would still require the user to always set the property to \"false\" manually", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393047515", "createdAt": "2020-03-16T14:07:57Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchRequest searchRequest = new SearchRequest(index);\n+        // TODO either check that in client request validation already or set it automatically?\n+        searchRequest.setCcsMinimizeRoundtrips(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a147c41b8b1da4a853fdcae748d1e6b301b9131a"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5ODA5MQ==", "bodyText": "Can we copy the original SubmitAsyncSearchRequest that creates the SearchRequest internally and sets the default appropriately. We can then add a validation client side if needed or let the server-side validation throw error if users override the ccs option ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393098091", "createdAt": "2020-03-16T15:12:06Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchRequest searchRequest = new SearchRequest(index);\n+        // TODO either check that in client request validation already or set it automatically?\n+        searchRequest.setCcsMinimizeRoundtrips(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0NzUxNQ=="}, "originalCommit": {"oid": "a147c41b8b1da4a853fdcae748d1e6b301b9131a"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3Nzk2OA==", "bodyText": "Thanks, I didn't see we implicitely set the defaulfs in the server side org.elasticsearch.xpack.core.search.action.SubmitAsyncSearchRequest we should do that on the client side as well then. Also see we're overwriting these properties:\nrequest.setPreFilterShardSize(1);\nrequest.setBatchedReduceSize(5);\nrequest.requestCache(true);\n\nI assume we also want to do that then on the client side as well?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393177968", "createdAt": "2020-03-16T17:04:03Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchRequest searchRequest = new SearchRequest(index);\n+        // TODO either check that in client request validation already or set it automatically?\n+        searchRequest.setCcsMinimizeRoundtrips(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0NzUxNQ=="}, "originalCommit": {"oid": "a147c41b8b1da4a853fdcae748d1e6b301b9131a"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4NDQ3OQ==", "bodyText": "yes", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393184479", "createdAt": "2020-03-16T17:13:13Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchRequest searchRequest = new SearchRequest(index);\n+        // TODO either check that in client request validation already or set it automatically?\n+        searchRequest.setCcsMinimizeRoundtrips(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0NzUxNQ=="}, "originalCommit": {"oid": "a147c41b8b1da4a853fdcae748d1e6b301b9131a"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTQ4OA==", "bodyText": "This can be removed now that we set these values automatically in the ctr ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393481488", "createdAt": "2020-03-17T07:15:35Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchRequest searchRequest = new SearchRequest(index);\n+        // TODO either check that in client request validation already or set it automatically?\n+        searchRequest.setCcsMinimizeRoundtrips(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0NzUxNQ=="}, "originalCommit": {"oid": "a147c41b8b1da4a853fdcae748d1e6b301b9131a"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNjQ5Nzk1OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDozODoxMFrOF23ULw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzoxMzoxOVrOF2-FGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3MzcxMQ==", "bodyText": "Is it required to extend TimedRequest ? What's the advantage of doing so ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393073711", "createdAt": "2020-03-16T14:38:10Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.TimedRequest;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Objects;\n+\n+public class SubmitAsyncSearchRequest extends TimedRequest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebf54280526c314dcd9dbff1782d4ecff54804e2"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3OTMyNA==", "bodyText": "It gives \"timeout\" and \"master_timeout\" parameters, but I guess on the submit request they don't make much sense. Removing.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393179324", "createdAt": "2020-03-16T17:05:36Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.TimedRequest;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Objects;\n+\n+public class SubmitAsyncSearchRequest extends TimedRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3MzcxMQ=="}, "originalCommit": {"oid": "ebf54280526c314dcd9dbff1782d4ecff54804e2"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4NDUzNg==", "bodyText": "+1", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393184536", "createdAt": "2020-03-16T17:13:19Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.TimedRequest;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Objects;\n+\n+public class SubmitAsyncSearchRequest extends TimedRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3MzcxMQ=="}, "originalCommit": {"oid": "ebf54280526c314dcd9dbff1782d4ecff54804e2"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNjUwMDA1OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDozODo0NFrOF23VmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDozODo0NFrOF23VmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3NDA3Mw==", "bodyText": "Can you add javadocs for the options ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393074073", "createdAt": "2020-03-16T14:38:44Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.TimedRequest;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Objects;\n+\n+public class SubmitAsyncSearchRequest extends TimedRequest {\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    public SubmitAsyncSearchRequest(SearchRequest searchRequest) {\n+        this.searchRequest = searchRequest;\n+}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebf54280526c314dcd9dbff1782d4ecff54804e2"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNjUxNDIxOnYy", "diffSide": "LEFT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchResponse.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDo0MTo0OFrOF23egA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNjo1NDowN1rOF29H3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3NjM1Mg==", "bodyText": "Can we try to avoid this change ? Maybe using a custom parser in the root object parser for the response field ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393076352", "createdAt": "2020-03-16T14:41:48Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchResponse.java", "diffHunk": "@@ -255,8 +255,12 @@ public XContentBuilder innerToXContent(XContentBuilder builder, Params params) t\n     }\n \n     public static SearchResponse fromXContent(XContentParser parser) throws IOException {\n-        ensureExpectedToken(Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        parser.nextToken();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebf54280526c314dcd9dbff1782d4ecff54804e2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA4MjQ5Mg==", "bodyText": "I did that at first but found the change in the server object is cleaner. Happy to change to the other solution though, but I think its working around something that we can fix better here.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393082492", "createdAt": "2020-03-16T14:50:23Z", "author": {"login": "cbuescher"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchResponse.java", "diffHunk": "@@ -255,8 +255,12 @@ public XContentBuilder innerToXContent(XContentBuilder builder, Params params) t\n     }\n \n     public static SearchResponse fromXContent(XContentParser parser) throws IOException {\n-        ensureExpectedToken(Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        parser.nextToken();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3NjM1Mg=="}, "originalCommit": {"oid": "ebf54280526c314dcd9dbff1782d4ecff54804e2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5OTY2Nw==", "bodyText": "We can also split into fromXContent and fromXContentFragment, the former would consume the start object and delegate to fromXContentFragment ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393099667", "createdAt": "2020-03-16T15:14:30Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchResponse.java", "diffHunk": "@@ -255,8 +255,12 @@ public XContentBuilder innerToXContent(XContentBuilder builder, Params params) t\n     }\n \n     public static SearchResponse fromXContent(XContentParser parser) throws IOException {\n-        ensureExpectedToken(Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        parser.nextToken();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3NjM1Mg=="}, "originalCommit": {"oid": "ebf54280526c314dcd9dbff1782d4ecff54804e2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2ODg2MQ==", "bodyText": "We already have innerFromXContent which in an earlier version of this PR I exposed and used from the client side, but then we have to explain that there. I'll change the PR back to that version so you can see the options.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393168861", "createdAt": "2020-03-16T16:54:07Z", "author": {"login": "cbuescher"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchResponse.java", "diffHunk": "@@ -255,8 +255,12 @@ public XContentBuilder innerToXContent(XContentBuilder builder, Params params) t\n     }\n \n     public static SearchResponse fromXContent(XContentParser parser) throws IOException {\n-        ensureExpectedToken(Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        parser.nextToken();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3NjM1Mg=="}, "originalCommit": {"oid": "ebf54280526c314dcd9dbff1782d4ecff54804e2"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTAzNTM5OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchResponse.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzoxMjo0NVrOF3QJbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwOToyODowOFrOF3UDZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MDU1Ng==", "bodyText": "The response is shared with the get api so can you rename like the original AsyncSearchResponse ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393480556", "createdAt": "2020-03-17T07:12:45Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class SubmitAsyncSearchResponse implements ToXContentObject  {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87a4f928060b6a239d156859681b36fe56698d53"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU0NDU1MA==", "bodyText": "+1. Already did that in a follow up PR but I will also do it here already then.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393544550", "createdAt": "2020-03-17T09:28:08Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class SubmitAsyncSearchResponse implements ToXContentObject  {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MDU1Ng=="}, "originalCommit": {"oid": "87a4f928060b6a239d156859681b36fe56698d53"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTAzODQwOnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzoxNDoxOFrOF3QLbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMToyNToyNlrOF3YA9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTA3MA==", "bodyText": "The original request takes the indices to search in the constructor rather than the SearchRequest that is created internally. Can you adapt it to match the behavior of the transport request ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393481070", "createdAt": "2020-03-17T07:14:18Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Create a request to submit an async search.\n+     * Target indices, queries and all other search related options should be set on\n+     * the input {@link SearchRequest}.\n+     * @param searchRequest the actual search request to submit\n+     */\n+    public SubmitAsyncSearchRequest(SearchRequest searchRequest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87a4f928060b6a239d156859681b36fe56698d53"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU2NjcyNw==", "bodyText": "I thought about it but decided against it. The transport requests signature  public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) doesn't allow setting things in the SearchRequest thats constructed internally, like e.g. search_type or routing.\nYou probably would need to do sth. like this on the client side which I find cumbersome:\nSearchSourceBuilder sourceBuilder = new SearchSourceBuilder()....;        \nSubmitAsyncSearchRequest submitRequest = new SubmitAsyncSearchRequest(indices, sourceBuilder);\nsubmitRequest.getSearchRequest().routing(). \n\nI think on the client side its easier for the user to pass in the full SearchRequest rather than having to do things like this. Wdyt?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393566727", "createdAt": "2020-03-17T10:05:57Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Create a request to submit an async search.\n+     * Target indices, queries and all other search related options should be set on\n+     * the input {@link SearchRequest}.\n+     * @param searchRequest the actual search request to submit\n+     */\n+    public SubmitAsyncSearchRequest(SearchRequest searchRequest) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTA3MA=="}, "originalCommit": {"oid": "87a4f928060b6a239d156859681b36fe56698d53"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU4NTI1Mg==", "bodyText": "Then maybe we should expose the search request options that we allow to modify directly in the SubmitAsyncSearchRequest and hide the internal searchRequest ? Whatever we do here I'd prefer to have the same signature between hlrc and transport since they should be equivalent.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393585252", "createdAt": "2020-03-17T10:39:11Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Create a request to submit an async search.\n+     * Target indices, queries and all other search related options should be set on\n+     * the input {@link SearchRequest}.\n+     * @param searchRequest the actual search request to submit\n+     */\n+    public SubmitAsyncSearchRequest(SearchRequest searchRequest) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTA3MA=="}, "originalCommit": {"oid": "87a4f928060b6a239d156859681b36fe56698d53"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYwNDA4NA==", "bodyText": "here I'd prefer to have the same signature between hlrc and transport since they should be equivalent.\n\nI'm open to adding a bunch of setters to the client side SubmitAsyncSearchRequest but I wonder if its really necessary. Why do the transport and the client side request ctors need to be equivalent? With the transport client gone I only see the transport request used internally, everything else would go through the RestSubmitAsyncSearchAction which handles creating the transport request, or am I missing something? Maybe @javanna has some ideas here as well.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393604084", "createdAt": "2020-03-17T11:14:47Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Create a request to submit an async search.\n+     * Target indices, queries and all other search related options should be set on\n+     * the input {@link SearchRequest}.\n+     * @param searchRequest the actual search request to submit\n+     */\n+    public SubmitAsyncSearchRequest(SearchRequest searchRequest) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTA3MA=="}, "originalCommit": {"oid": "87a4f928060b6a239d156859681b36fe56698d53"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYwOTQ2MA==", "bodyText": "I agree but in an ideal world we'd have a single class here so I prefer if we don't diverge in the hlrc. Exposing the search request directly is tricky since some of the options are not allowed (scroll, ccs) and we change the default internally. Hiding the search request entirely behind direct setters and getters seems safer and would avoid the confusion when building an async search request ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393609460", "createdAt": "2020-03-17T11:25:26Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Create a request to submit an async search.\n+     * Target indices, queries and all other search related options should be set on\n+     * the input {@link SearchRequest}.\n+     * @param searchRequest the actual search request to submit\n+     */\n+    public SubmitAsyncSearchRequest(SearchRequest searchRequest) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTA3MA=="}, "originalCommit": {"oid": "87a4f928060b6a239d156859681b36fe56698d53"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTAzODgyOnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzoxNDozMVrOF3QLvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzoxNDozMVrOF3QLvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTE1MQ==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393481151", "createdAt": "2020-03-17T07:14:31Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class SubmitAsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    private SearchResponse searchResponse;\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link SubmitAsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    SubmitAsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;\n+    }\n+\n+    /**\n+     * Returns the failure reason or null if the query is running or has completed normally.\n+     */\n+    public ElasticsearchException getFailure() {\n+        return error;\n+    }\n+\n+    /**\n+     * Sets the optional failure property, use by parser and tests\n+     */\n+    void setFailure(ElasticsearchException error) {\n+        this.error = error;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the {@link SearchResponse} contains partial\n+     * results computed from a subset of the total shards.\n+     */\n+    public boolean isPartial() {\n+        return isPartial;\n+    }\n+\n+    /**\n+     * Whether the search is still running in the cluster.\n+     *\n+     * A value of <code>false</code> indicates that the response is final\n+     * even if {@link #isPartial()} returns <code>true</code>. In such case,\n+     * the partial response represents the status of the search before a\n+     * non-recoverable failure.\n+     */\n+    public boolean isRunning() {\n+        return isRunning;\n+    }\n+\n+    /**\n+     * When this response was created as a timestamp in milliseconds since epoch.\n+     */\n+    public long getStartTime() {\n+        return startTimeMillis;\n+    }\n+\n+    /**\n+     * When this response will expired as a timestamp in milliseconds since epoch.\n+     */\n+    public long getExpirationTime() {\n+        return expirationTimeMillis;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (id != null) {\n+            builder.field(\"id\", id);\n+        }\n+        builder.field(\"version\", version);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"start_time_in_millis\", startTimeMillis);\n+        builder.field(\"expiration_time_in_millis\", expirationTimeMillis);\n+\n+        if (searchResponse != null) {\n+            builder.field(\"response\");\n+            searchResponse.toXContent(builder, params);\n+        }\n+        if (error != null) {\n+            builder.startObject(\"error\");\n+            error.toXContent(builder, params);\n+            builder.endObject();\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public static final ParseField ID_FIELD = new ParseField(\"id\");\n+    public static final ParseField VERSION_FIELD = new ParseField(\"version\");\n+    public static final ParseField IS_PARTIAL_FIELD = new ParseField(\"is_partial\");\n+    public static final ParseField IS_RUNNING_FIELD = new ParseField(\"is_running\");\n+    public static final ParseField START_TIME_FIELD = new ParseField(\"start_time_in_millis\");\n+    public static final ParseField EXPIRATION_FIELD = new ParseField(\"expiration_time_in_millis\");\n+    public static final ParseField RESPONSE_FIELD = new ParseField(\"response\");\n+    public static final ParseField ERROR_FIELD = new ParseField(\"error\");\n+\n+    public static final ConstructingObjectParser<SubmitAsyncSearchResponse, Void> PARSER = new ConstructingObjectParser<>(\n+            \"submit_async_search_response\", true,\n+            args -> new SubmitAsyncSearchResponse(\n+                    (int) args[0],\n+                    (boolean) args[1],\n+                    (boolean) args[2],\n+                    (long) args[3],\n+                    (long) args[4]));\n+    static {\n+        PARSER.declareInt(ConstructingObjectParser.constructorArg(), VERSION_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_PARTIAL_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_RUNNING_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), START_TIME_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), EXPIRATION_FIELD);\n+        PARSER.declareString(SubmitAsyncSearchResponse::setId, ID_FIELD);\n+        PARSER.declareObject(SubmitAsyncSearchResponse::setSearchResponse, (p, c) -> SubmitAsyncSearchResponse.parseSearchResponse(p),\n+                RESPONSE_FIELD);\n+        PARSER.declareObject(SubmitAsyncSearchResponse::setFailure, (p, c) -> ElasticsearchException.fromXContent(p), ERROR_FIELD);\n+    }\n+\n+    private static SearchResponse parseSearchResponse(XContentParser p) throws IOException {\n+        // we should be before the opening START_OBJECT of the response\n+        ensureExpectedToken(Token.START_OBJECT, p.currentToken(), p::getTokenLocation);\n+        p.nextToken();\n+        return SearchResponse.innerFromXContent(p);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87a4f928060b6a239d156859681b36fe56698d53"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDY3NzE3OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNTowNzo0N1rOF3giiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNzo1MTowMFrOF3nf0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc0OTEyOA==", "bodyText": "We should also expose batchedReduceSize since that's the option to use to change the granularity of the progress ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393749128", "createdAt": "2020-03-17T15:07:47Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {\n+        return searchRequest;\n+    }\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void routing(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void routing(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void preference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void indicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void searchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void allowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94083b6e6b5585d92c3960be5dbdc4de54b22362"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgxNDI5Nw==", "bodyText": "Sure, I didn't add that because we implicitely set it to 5 in the ctor now, so thought its something we don't want the user to set.\nWhat about PreFilterShardSize and requestCache then, those I also didn't add since we set them to fixed values internally?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393814297", "createdAt": "2020-03-17T16:36:27Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {\n+        return searchRequest;\n+    }\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void routing(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void routing(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void preference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void indicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void searchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void allowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc0OTEyOA=="}, "originalCommit": {"oid": "94083b6e6b5585d92c3960be5dbdc4de54b22362"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2MzEyMg==", "bodyText": "I would expose batchedReduceSize and requestCache only, preFilterShardSize is not necessary imo (we want to always run the can_match phase in async search).", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393863122", "createdAt": "2020-03-17T17:51:00Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {\n+        return searchRequest;\n+    }\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void routing(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void routing(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void preference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void indicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void searchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void allowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc0OTEyOA=="}, "originalCommit": {"oid": "94083b6e6b5585d92c3960be5dbdc4de54b22362"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MzYyNzE5OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMDowMjo1N1rOF3922Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMzozNzo0MVrOF4FRqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIyOTQ2NQ==", "bodyText": "I wonder if we need to expose this async async method. Is there a reason why people would call an async API asynchronously?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394229465", "createdAt": "2020-03-18T10:02:57Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchClient.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.asyncsearch.SubmitAsyncSearchRequest;\n+import org.elasticsearch.client.asyncsearch.AsyncSearchResponse;\n+\n+import java.io.IOException;\n+\n+import static java.util.Collections.emptySet;\n+\n+public class AsyncSearchClient {\n+    private final RestHighLevelClient restHighLevelClient;\n+\n+    AsyncSearchClient(RestHighLevelClient restHighLevelClient) {\n+        this.restHighLevelClient = restHighLevelClient;\n+    }\n+\n+    // TODO add docs url\n+    /**\n+     * Submit a new async search request.\n+     * See <a href=\"todo\"> the docs</a> for more.\n+     * @param request the request\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @return the response\n+     * @throws IOException in case there is a problem sending the request or parsing back the response\n+     */\n+    public AsyncSearchResponse submitAsyncSearch(SubmitAsyncSearchRequest request, RequestOptions options) throws IOException {\n+        return restHighLevelClient.performRequestAndParseEntity(request, AsyncSearchRequestConverters::submitAsyncSearch, options,\n+                AsyncSearchResponse::fromXContent, emptySet());\n+    }\n+\n+    // TODO add docs url\n+    /**\n+     * Asynchronously submit a new async search request.\n+     * See <a href=\"todo\"> the docs</a> for more.\n+     * <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-ilm-ilm-get-lifecycle-policy.html\">\n+     * the docs</a> for more.\n+     * @param request the request\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @param listener the listener to be notified upon request completion\n+     * @return cancellable that may be used to cancel the request\n+     */\n+    public Cancellable submitAsyncSearchAsync(SubmitAsyncSearchRequest request, RequestOptions options,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMzODkwMw==", "bodyText": "Please correct me, but as far as I understand it, this is not about the asynchronism of the search request, but the submit request itself. While the _async_search request controlls when and whether it returns by waitForCompletion / keepAlive, this method allows using a listener for wait for the response instead of blocking. So say, a user sends and \"_async_search\" with waitForCompletion=10s because thats how long its okay for the search to initially take with the first responses, but wants the client call to return immediately nevertheless? I think having this method also makes sense in terms of consistency of the API with other client methods.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394338903", "createdAt": "2020-03-18T13:19:18Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchClient.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.asyncsearch.SubmitAsyncSearchRequest;\n+import org.elasticsearch.client.asyncsearch.AsyncSearchResponse;\n+\n+import java.io.IOException;\n+\n+import static java.util.Collections.emptySet;\n+\n+public class AsyncSearchClient {\n+    private final RestHighLevelClient restHighLevelClient;\n+\n+    AsyncSearchClient(RestHighLevelClient restHighLevelClient) {\n+        this.restHighLevelClient = restHighLevelClient;\n+    }\n+\n+    // TODO add docs url\n+    /**\n+     * Submit a new async search request.\n+     * See <a href=\"todo\"> the docs</a> for more.\n+     * @param request the request\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @return the response\n+     * @throws IOException in case there is a problem sending the request or parsing back the response\n+     */\n+    public AsyncSearchResponse submitAsyncSearch(SubmitAsyncSearchRequest request, RequestOptions options) throws IOException {\n+        return restHighLevelClient.performRequestAndParseEntity(request, AsyncSearchRequestConverters::submitAsyncSearch, options,\n+                AsyncSearchResponse::fromXContent, emptySet());\n+    }\n+\n+    // TODO add docs url\n+    /**\n+     * Asynchronously submit a new async search request.\n+     * See <a href=\"todo\"> the docs</a> for more.\n+     * <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-ilm-ilm-get-lifecycle-policy.html\">\n+     * the docs</a> for more.\n+     * @param request the request\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @param listener the listener to be notified upon request completion\n+     * @return cancellable that may be used to cancel the request\n+     */\n+    public Cancellable submitAsyncSearchAsync(SubmitAsyncSearchRequest request, RequestOptions options,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIyOTQ2NQ=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM1MTAxOA==", "bodyText": "ok lets leave it.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394351018", "createdAt": "2020-03-18T13:37:41Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchClient.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.asyncsearch.SubmitAsyncSearchRequest;\n+import org.elasticsearch.client.asyncsearch.AsyncSearchResponse;\n+\n+import java.io.IOException;\n+\n+import static java.util.Collections.emptySet;\n+\n+public class AsyncSearchClient {\n+    private final RestHighLevelClient restHighLevelClient;\n+\n+    AsyncSearchClient(RestHighLevelClient restHighLevelClient) {\n+        this.restHighLevelClient = restHighLevelClient;\n+    }\n+\n+    // TODO add docs url\n+    /**\n+     * Submit a new async search request.\n+     * See <a href=\"todo\"> the docs</a> for more.\n+     * @param request the request\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @return the response\n+     * @throws IOException in case there is a problem sending the request or parsing back the response\n+     */\n+    public AsyncSearchResponse submitAsyncSearch(SubmitAsyncSearchRequest request, RequestOptions options) throws IOException {\n+        return restHighLevelClient.performRequestAndParseEntity(request, AsyncSearchRequestConverters::submitAsyncSearch, options,\n+                AsyncSearchResponse::fromXContent, emptySet());\n+    }\n+\n+    // TODO add docs url\n+    /**\n+     * Asynchronously submit a new async search request.\n+     * See <a href=\"todo\"> the docs</a> for more.\n+     * <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-ilm-ilm-get-lifecycle-policy.html\">\n+     * the docs</a> for more.\n+     * @param request the request\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @param listener the listener to be notified upon request completion\n+     * @return cancellable that may be used to cancel the request\n+     */\n+    public Cancellable submitAsyncSearchAsync(SubmitAsyncSearchRequest request, RequestOptions options,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIyOTQ2NQ=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MzY1ODI1OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/RequestConverters.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMDoxMTo0NFrOF3-K9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMDoxMTo0NFrOF3-K9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzNDYxMw==", "bodyText": "good catch, looks like search was not supporting this parameter.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394234613", "createdAt": "2020-03-18T10:11:44Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/RequestConverters.java", "diffHunk": "@@ -403,13 +403,14 @@ static Request search(SearchRequest searchRequest, String searchEndpoint) throws\n         return request;\n     }\n \n-    private static void addSearchRequestParams(Params params, SearchRequest searchRequest) {\n+    static void addSearchRequestParams(Params params, SearchRequest searchRequest) {\n         params.putParam(RestSearchAction.TYPED_KEYS_PARAM, \"true\");\n         params.withRouting(searchRequest.routing());\n         params.withPreference(searchRequest.preference());\n         params.withIndicesOptions(searchRequest.indicesOptions());\n         params.putParam(\"search_type\", searchRequest.searchType().name().toLowerCase(Locale.ROOT));\n         params.putParam(\"ccs_minimize_roundtrips\", Boolean.toString(searchRequest.isCcsMinimizeRoundtrips()));\n+        params.putParam(\"pre_filter_shard_size\", Integer.toString(searchRequest.getPreFilterShardSize()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MzY2NDY2OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMDoxMzoxOFrOF3-O_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMDoxMzoxOFrOF3-O_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzNTY0Ng==", "bodyText": "maybe this should be nullable too?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394235646", "createdAt": "2020-03-18T10:13:18Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    private SearchResponse searchResponse;\n+    private ElasticsearchException error;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MzY4NDQxOnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "isResolved": false, "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMDoxODoyNVrOF3-bdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODoyNTo0MVrOF4RsfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg==", "bodyText": "I see that whether or not to expose the inner search request was discussed in previous reviews. I am confused though on what direction was chosen. I see that the getters and setters from the search request are copied to the async request, but the inner search request is still exposed through this getter and can be modified directly. Didn't we want to rather hide it from users?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394238836", "createdAt": "2020-03-18T10:18:25Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0MDkyMw==", "bodyText": "+1 to hide", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394340923", "createdAt": "2020-03-18T13:22:26Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM1MzE0MQ==", "bodyText": "Okay, I will look into that. Will make testing a bit more awkward though because I can't reuse some existing infra then.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394353141", "createdAt": "2020-03-18T13:40:50Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM5MzM2Mw==", "bodyText": "package protected ? ;)", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394393363", "createdAt": "2020-03-18T14:35:18Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQyODY5NQ==", "bodyText": "Would work but then I need to move some classes around. I'd prefer that to adding all those getters to the submit request.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394428695", "createdAt": "2020-03-18T15:20:54Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzODA4Nw==", "bodyText": "I think that if we can do without the getter, even better. The changes you had to make to remove it don't look so bad. The problem with keeping it package protected is that theoretically some stuff can still be set directly to the search request, then we need to validate parameters that are not even supported.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394438087", "createdAt": "2020-03-18T15:33:10Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3OTgxOA==", "bodyText": "package protected ? ;)\n\nThis is proving to be tricky. I cannot easily move the AsyncSearchRequestConverters out of the org.elasticsearch.client package since they need package private infra from RequestConverters. I can probably move the SubmitAsyncSearchRequest into that package though, will take a look what that would change.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394479818", "createdAt": "2020-03-18T16:28:21Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5NTU1MQ==", "bodyText": "I pushed f686a50 which moves the new request and response classes into org.elasticsearch.client to be able to use a package protected getSearchRequest() to avoid all the boilerplate getters on the new request. I'm unsure what I like best, take a look and let me know which direction you are leaning.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394495551", "createdAt": "2020-03-18T16:51:36Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUwNTY1NA==", "bodyText": "I  think no getter is  safer. We also do have extra protection on the server side for unsupported values but I think the client should never allow to send unsupported values.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394505654", "createdAt": "2020-03-18T17:06:31Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU0MjM5NA==", "bodyText": "I agree with Luca, we should avoid the getter on the search request. However, we should have a getter for all options that we expose so I don't see why you want to avoid them ? If we have a setter, we need to provide a way to access the value.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394542394", "createdAt": "2020-03-18T18:04:40Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU1NDQ5Mw==", "bodyText": "Ok, I reverted that change back to the one where I removed getSearchRequest and added a bunch of getters.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394554493", "createdAt": "2020-03-18T18:25:41Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MzY4NzEzOnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMDoxOToxN1rOF3-dQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMDoxOToxN1rOF3-dQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzOTI5OA==", "bodyText": "annoying nit: I see that some getters and setters use the get and set prefix in this class, while others don't. I get why, but shall we unify the style at least throughout this one class?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394239298", "createdAt": "2020-03-18T10:19:17Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {\n+        return searchRequest;\n+    }\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void routing(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void routing(String... routings) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MzcyMjEzOnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMDoyOToxMlrOF3-z9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMzo0MDoxMVrOF4FYPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI0NTExMQ==", "bodyText": "this should work but it's also risky. What other options we have?\n\nincrease the timeout even more to really make sure it's enough, though what is enough\naccept that we may get a response while the search is still running, in which case is_partial and is_final will have a different value? Maybe don't set cleanOnCompletion and assert that when the id is returned the search is running, and when the id is not returned, both flags are false.\n\nI am not sure either way, maybe  I would go for option 1.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394245111", "createdAt": "2020-03-18T10:29:12Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery());\n+        SubmitAsyncSearchRequest request = new SubmitAsyncSearchRequest(sourceBuilder, index);\n+        // 2 sec should be enough to make sure we always complete right away\n+        request.setWaitForCompletion(new TimeValue(2, TimeUnit.SECONDS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0MjE3Nw==", "bodyText": "We can also have a loop here when get is implemented that submits the initial request and use get until isRunning is false on the response ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394342177", "createdAt": "2020-03-18T13:24:22Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery());\n+        SubmitAsyncSearchRequest request = new SubmitAsyncSearchRequest(sourceBuilder, index);\n+        // 2 sec should be enough to make sure we always complete right away\n+        request.setWaitForCompletion(new TimeValue(2, TimeUnit.SECONDS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI0NTExMQ=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0NzIzNw==", "bodyText": "I'll go with 1.) then, staying on the save side. I will keep cleanOnCompletion though, currently thats the only way I can see to actually get an Id and I'd like to tests its deserialization etc... here if possible (will also need ids in a follow-up PR around get-API)", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394347237", "createdAt": "2020-03-18T13:32:04Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery());\n+        SubmitAsyncSearchRequest request = new SubmitAsyncSearchRequest(sourceBuilder, index);\n+        // 2 sec should be enough to make sure we always complete right away\n+        request.setWaitForCompletion(new TimeValue(2, TimeUnit.SECONDS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI0NTExMQ=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0OTU1OQ==", "bodyText": "sorry, missed the previous comment. Loop sounds okay as well, getting a response thats not running any more isn't actually the problem, the oposite is tricky (getting a response with an Id, as I mentioned earlier). I don't need that here so will remove it but will need it later for get/delete API tests.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394349559", "createdAt": "2020-03-18T13:35:28Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery());\n+        SubmitAsyncSearchRequest request = new SubmitAsyncSearchRequest(sourceBuilder, index);\n+        // 2 sec should be enough to make sure we always complete right away\n+        request.setWaitForCompletion(new TimeValue(2, TimeUnit.SECONDS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI0NTExMQ=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM1MTk1MQ==", "bodyText": "Just also realize I haven't implemented get yet in this PR, we could change this later to a loop with get if you agree?\nI don't see the benefits over a long-enough wait time though, quite the oposite. I never got this call to not finish in the first call, neither locally nor on CI which is even faster.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394351951", "createdAt": "2020-03-18T13:39:00Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery());\n+        SubmitAsyncSearchRequest request = new SubmitAsyncSearchRequest(sourceBuilder, index);\n+        // 2 sec should be enough to make sure we always complete right away\n+        request.setWaitForCompletion(new TimeValue(2, TimeUnit.SECONDS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI0NTExMQ=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM1MjE1MQ==", "bodyText": "I like the loop idea if it does not make things too complicated, it sounds doable.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394352151", "createdAt": "2020-03-18T13:39:21Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery());\n+        SubmitAsyncSearchRequest request = new SubmitAsyncSearchRequest(sourceBuilder, index);\n+        // 2 sec should be enough to make sure we always complete right away\n+        request.setWaitForCompletion(new TimeValue(2, TimeUnit.SECONDS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI0NTExMQ=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM1MjcwMg==", "bodyText": "it's fine to make this a loop later ;)", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394352702", "createdAt": "2020-03-18T13:40:11Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery());\n+        SubmitAsyncSearchRequest request = new SubmitAsyncSearchRequest(sourceBuilder, index);\n+        // 2 sec should be enough to make sure we always complete right away\n+        request.setWaitForCompletion(new TimeValue(2, TimeUnit.SECONDS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI0NTExMQ=="}, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NDg0NTM1OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNToyMzoyNVrOF4KI2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjoyODowMlrOF4NH7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMDY4MA==", "bodyText": "we may want to expose a setter for the source too. Not so important but I guess users would argue that once set at the constructor it can never be reset. Search request allows to set it.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394430680", "createdAt": "2020-03-18T15:23:25Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }\n+\n+    /**\n+     * Gets if the source of the {@link SearchSourceBuilder} initially used on this request.\n+     */\n+    public SearchSourceBuilder getSearchSource() {\n+        return this.searchRequest.source();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ1ODA0NA==", "bodyText": "Sorry, I don't follow. Why would you want to change the source when you are constructing the request in the client? You can get it and change the various parts of it if you like. Why aim for parity with SearchRequest? This would mean allowing the user to reach down into a thing we want to hide (the SearchRequest) and make changes there. I don't see how thats useful.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394458044", "createdAt": "2020-03-18T15:58:15Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }\n+\n+    /**\n+     * Gets if the source of the {@link SearchSourceBuilder} initially used on this request.\n+     */\n+    public SearchSourceBuilder getSearchSource() {\n+        return this.searchRequest.source();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMDY4MA=="}, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3OTU5OA==", "bodyText": "I would have replied the same way to this comment :) it is just a comment that I got in the past with these client requests. People expect to be able to reset stuff, while here once you set the source you can not go back to the initial state. Though you can modify it. I am fine with doing without the setter though, it is not that useful.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394479598", "createdAt": "2020-03-18T16:28:02Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }\n+\n+    /**\n+     * Gets if the source of the {@link SearchSourceBuilder} initially used on this request.\n+     */\n+    public SearchSourceBuilder getSearchSource() {\n+        return this.searchRequest.source();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMDY4MA=="}, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NDg0NzI4OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNToyMzo0OVrOF4KKJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODoyNDo1NVrOF4Rq4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMTAxNQ==", "bodyText": "how about maxConcurrentShardRequests? Was it left out on purpose?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394431015", "createdAt": "2020-03-18T15:23:49Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ1OTc4Mg==", "bodyText": "Good one, I think that parameter is also missing from the regular RequestConverters.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394459782", "createdAt": "2020-03-18T16:00:21Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMTAxNQ=="}, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3NjE2Ng==", "bodyText": "I pulled adding this parameter (and the previously mentioned pre_filter_shard_size) to the regular RequestConverters into #53745 to get this in independently of this PR.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394476166", "createdAt": "2020-03-18T16:23:17Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMTAxNQ=="}, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3ODQ5MA==", "bodyText": "sounds good thanks", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394478490", "createdAt": "2020-03-18T16:26:29Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMTAxNQ=="}, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU1NDA4Mg==", "bodyText": "Cherry-picked that PR and added support for max_concurrent_shard_requests", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394554082", "createdAt": "2020-03-18T18:24:55Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMTAxNQ=="}, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NDg1NjA2OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNToyNTo1OFrOF4KQIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNTo1Nzo1MVrOF4LyQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMjU0NQ==", "bodyText": "some of these checks become redundant once the search request is hidden. Are we going to be able to remove the getter for the search request, or will it be package protected? I guess that will play a role in whether these values are at least theoretically settable from the same package, or not at all.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394432545", "createdAt": "2020-03-18T15:25:58Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }\n+\n+    /**\n+     * Gets if the source of the {@link SearchSourceBuilder} initially used on this request.\n+     */\n+    public SearchSourceBuilder getSearchSource() {\n+        return this.searchRequest.source();\n+    }\n+\n+    @Override\n+    public Optional<ValidationException> validate() {\n+        final ValidationException validationException = new ValidationException();\n+        if (searchRequest.scroll() != null) {\n+            validationException.addValidationError(\"[scroll] queries are not supported\");\n+        }\n+        if (searchRequest.isSuggestOnly()) {\n+            validationException.addValidationError(\"suggest-only queries are not supported\");\n+        }\n+        if (searchRequest.isCcsMinimizeRoundtrips()) {\n+            validationException.addValidationError(\"[ccs_minimize_roundtrips] is not supported on async search queries\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0MjAzMg==", "bodyText": "That getter can probably go, other need to be accessible from the AsyncRequestConverters, which currently need to stay in org.elasticsearch.client to work with existing infra in RequestConverters. Moving the former proved to be difficult. I think I can remove the validation checks for \"ccs_minimize_roundtrips\" and \"scroll\" though because now they should not be settable any more (and there is an extra layer of protection on the REST layer later.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394442032", "createdAt": "2020-03-18T15:38:19Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }\n+\n+    /**\n+     * Gets if the source of the {@link SearchSourceBuilder} initially used on this request.\n+     */\n+    public SearchSourceBuilder getSearchSource() {\n+        return this.searchRequest.source();\n+    }\n+\n+    @Override\n+    public Optional<ValidationException> validate() {\n+        final ValidationException validationException = new ValidationException();\n+        if (searchRequest.scroll() != null) {\n+            validationException.addValidationError(\"[scroll] queries are not supported\");\n+        }\n+        if (searchRequest.isSuggestOnly()) {\n+            validationException.addValidationError(\"suggest-only queries are not supported\");\n+        }\n+        if (searchRequest.isCcsMinimizeRoundtrips()) {\n+            validationException.addValidationError(\"[ccs_minimize_roundtrips] is not supported on async search queries\");\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMjU0NQ=="}, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ1NzY2NQ==", "bodyText": "there should be no setters/getters for scroll and ccs_minimize_roundtrips anymore now so I removed the validation.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394457665", "createdAt": "2020-03-18T15:57:51Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }\n+\n+    /**\n+     * Gets if the source of the {@link SearchSourceBuilder} initially used on this request.\n+     */\n+    public SearchSourceBuilder getSearchSource() {\n+        return this.searchRequest.source();\n+    }\n+\n+    @Override\n+    public Optional<ValidationException> validate() {\n+        final ValidationException validationException = new ValidationException();\n+        if (searchRequest.scroll() != null) {\n+            validationException.addValidationError(\"[scroll] queries are not supported\");\n+        }\n+        if (searchRequest.isSuggestOnly()) {\n+            validationException.addValidationError(\"suggest-only queries are not supported\");\n+        }\n+        if (searchRequest.isCcsMinimizeRoundtrips()) {\n+            validationException.addValidationError(\"[ccs_minimize_roundtrips] is not supported on async search queries\");\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMjU0NQ=="}, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NDg2MzU2OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchRequestConverters.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNToyNzoyOVrOF4KUyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNTo1NjowMVrOF4LsGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMzczNg==", "bodyText": "should this be there given that we don't allow to set it directly and we support only one value for it?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394433736", "createdAt": "2020-03-18T15:27:29Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchRequestConverters.java", "diffHunk": "@@ -56,4 +55,21 @@ static Request submitAsyncSearch(SubmitAsyncSearchRequest asyncSearchRequest) th\n         request.addParameters(params.asMap());\n         return request;\n     }\n+\n+    static void addSearchRequestParams(Params params, SubmitAsyncSearchRequest request) {\n+        params.putParam(RestSearchAction.TYPED_KEYS_PARAM, \"true\");\n+        params.withRouting(request.getRouting());\n+        params.withPreference(request.getPreference());\n+        params.withIndicesOptions(request.getIndicesOptions());\n+        params.putParam(\"search_type\", request.getSearchType().name().toLowerCase(Locale.ROOT));\n+        if (request.getRequestCache() != null) {\n+            params.putParam(\"request_cache\", Boolean.toString(request.getRequestCache()));\n+        }\n+        if (request.getAllowPartialSearchResults() != null) {\n+            params.putParam(\"allow_partial_search_results\", Boolean.toString(request.getAllowPartialSearchResults()));\n+        }\n+        params.putParam(\"batched_reduce_size\", Integer.toString(request.getBatchedReduceSize()));\n+        params.putParam(\"pre_filter_shard_size\", Integer.toString(SubmitAsyncSearchRequest.DEFAULT_PRE_FILTER_SHARD_SIZE));\n+        params.putParam(\"ccs_minimize_roundtrips\", Boolean.toString(SubmitAsyncSearchRequest.DEFAULT_CCS_MINIMIZE_ROUNDTRIPS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0Mjc3MQ==", "bodyText": "Yes, wee need to send those values (the onse we set on the ctor) via HTTP because they are different than the defaults in SearchRequest.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394442771", "createdAt": "2020-03-18T15:39:18Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchRequestConverters.java", "diffHunk": "@@ -56,4 +55,21 @@ static Request submitAsyncSearch(SubmitAsyncSearchRequest asyncSearchRequest) th\n         request.addParameters(params.asMap());\n         return request;\n     }\n+\n+    static void addSearchRequestParams(Params params, SubmitAsyncSearchRequest request) {\n+        params.putParam(RestSearchAction.TYPED_KEYS_PARAM, \"true\");\n+        params.withRouting(request.getRouting());\n+        params.withPreference(request.getPreference());\n+        params.withIndicesOptions(request.getIndicesOptions());\n+        params.putParam(\"search_type\", request.getSearchType().name().toLowerCase(Locale.ROOT));\n+        if (request.getRequestCache() != null) {\n+            params.putParam(\"request_cache\", Boolean.toString(request.getRequestCache()));\n+        }\n+        if (request.getAllowPartialSearchResults() != null) {\n+            params.putParam(\"allow_partial_search_results\", Boolean.toString(request.getAllowPartialSearchResults()));\n+        }\n+        params.putParam(\"batched_reduce_size\", Integer.toString(request.getBatchedReduceSize()));\n+        params.putParam(\"pre_filter_shard_size\", Integer.toString(SubmitAsyncSearchRequest.DEFAULT_PRE_FILTER_SHARD_SIZE));\n+        params.putParam(\"ccs_minimize_roundtrips\", Boolean.toString(SubmitAsyncSearchRequest.DEFAULT_CCS_MINIMIZE_ROUNDTRIPS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMzczNg=="}, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0NzkxNA==", "bodyText": "Okay, upon rechecking the code in RestSearchAction#prepareRequest, we set those values in the ctor on the server side to the defaults and shold only send those that the user can still modify, like batchedReduceSize and requestCache(see #53592 (comment))", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394447914", "createdAt": "2020-03-18T15:45:59Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchRequestConverters.java", "diffHunk": "@@ -56,4 +55,21 @@ static Request submitAsyncSearch(SubmitAsyncSearchRequest asyncSearchRequest) th\n         request.addParameters(params.asMap());\n         return request;\n     }\n+\n+    static void addSearchRequestParams(Params params, SubmitAsyncSearchRequest request) {\n+        params.putParam(RestSearchAction.TYPED_KEYS_PARAM, \"true\");\n+        params.withRouting(request.getRouting());\n+        params.withPreference(request.getPreference());\n+        params.withIndicesOptions(request.getIndicesOptions());\n+        params.putParam(\"search_type\", request.getSearchType().name().toLowerCase(Locale.ROOT));\n+        if (request.getRequestCache() != null) {\n+            params.putParam(\"request_cache\", Boolean.toString(request.getRequestCache()));\n+        }\n+        if (request.getAllowPartialSearchResults() != null) {\n+            params.putParam(\"allow_partial_search_results\", Boolean.toString(request.getAllowPartialSearchResults()));\n+        }\n+        params.putParam(\"batched_reduce_size\", Integer.toString(request.getBatchedReduceSize()));\n+        params.putParam(\"pre_filter_shard_size\", Integer.toString(SubmitAsyncSearchRequest.DEFAULT_PRE_FILTER_SHARD_SIZE));\n+        params.putParam(\"ccs_minimize_roundtrips\", Boolean.toString(SubmitAsyncSearchRequest.DEFAULT_CCS_MINIMIZE_ROUNDTRIPS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMzczNg=="}, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ1NjA4OQ==", "bodyText": "Removing \"pre_filter_shard_size\" and \"ccs_minimize_roundtrips\" from the http serialization", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394456089", "createdAt": "2020-03-18T15:56:01Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchRequestConverters.java", "diffHunk": "@@ -56,4 +55,21 @@ static Request submitAsyncSearch(SubmitAsyncSearchRequest asyncSearchRequest) th\n         request.addParameters(params.asMap());\n         return request;\n     }\n+\n+    static void addSearchRequestParams(Params params, SubmitAsyncSearchRequest request) {\n+        params.putParam(RestSearchAction.TYPED_KEYS_PARAM, \"true\");\n+        params.withRouting(request.getRouting());\n+        params.withPreference(request.getPreference());\n+        params.withIndicesOptions(request.getIndicesOptions());\n+        params.putParam(\"search_type\", request.getSearchType().name().toLowerCase(Locale.ROOT));\n+        if (request.getRequestCache() != null) {\n+            params.putParam(\"request_cache\", Boolean.toString(request.getRequestCache()));\n+        }\n+        if (request.getAllowPartialSearchResults() != null) {\n+            params.putParam(\"allow_partial_search_results\", Boolean.toString(request.getAllowPartialSearchResults()));\n+        }\n+        params.putParam(\"batched_reduce_size\", Integer.toString(request.getBatchedReduceSize()));\n+        params.putParam(\"pre_filter_shard_size\", Integer.toString(SubmitAsyncSearchRequest.DEFAULT_PRE_FILTER_SHARD_SIZE));\n+        params.putParam(\"ccs_minimize_roundtrips\", Boolean.toString(SubmitAsyncSearchRequest.DEFAULT_CCS_MINIMIZE_ROUNDTRIPS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMzczNg=="}, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NDg2NjMwOnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchRequestConverters.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNToyODowNFrOF4KWdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNToyODowNFrOF4KWdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzNDE2Ng==", "bodyText": "I think we can remove it. it is not in the spec and we don't allow to set it directly", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394434166", "createdAt": "2020-03-18T15:28:04Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchRequestConverters.java", "diffHunk": "@@ -56,4 +55,21 @@ static Request submitAsyncSearch(SubmitAsyncSearchRequest asyncSearchRequest) th\n         request.addParameters(params.asMap());\n         return request;\n     }\n+\n+    static void addSearchRequestParams(Params params, SubmitAsyncSearchRequest request) {\n+        params.putParam(RestSearchAction.TYPED_KEYS_PARAM, \"true\");\n+        params.withRouting(request.getRouting());\n+        params.withPreference(request.getPreference());\n+        params.withIndicesOptions(request.getIndicesOptions());\n+        params.putParam(\"search_type\", request.getSearchType().name().toLowerCase(Locale.ROOT));\n+        if (request.getRequestCache() != null) {\n+            params.putParam(\"request_cache\", Boolean.toString(request.getRequestCache()));\n+        }\n+        if (request.getAllowPartialSearchResults() != null) {\n+            params.putParam(\"allow_partial_search_results\", Boolean.toString(request.getAllowPartialSearchResults()));\n+        }\n+        params.putParam(\"batched_reduce_size\", Integer.toString(request.getBatchedReduceSize()));\n+        params.putParam(\"pre_filter_shard_size\", Integer.toString(SubmitAsyncSearchRequest.DEFAULT_PRE_FILTER_SHARD_SIZE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NjQyOTc5OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQyMzoxNDowNFrOF4aDwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwOTo1MDoyMlrOF4nDOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5MTUyMg==", "bodyText": "docs link should be https://www.elastic.co/guide/en/elasticsearch/reference/current/async-search.html PR is open but not merged yet: #53675", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394691522", "createdAt": "2020-03-18T23:14:04Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchClient.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.asyncsearch.SubmitAsyncSearchRequest;\n+import org.elasticsearch.client.asyncsearch.AsyncSearchResponse;\n+\n+import java.io.IOException;\n+\n+import static java.util.Collections.emptySet;\n+\n+public class AsyncSearchClient {\n+    private final RestHighLevelClient restHighLevelClient;\n+\n+    AsyncSearchClient(RestHighLevelClient restHighLevelClient) {\n+        this.restHighLevelClient = restHighLevelClient;\n+    }\n+\n+    // TODO add docs url", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "220e6a89f0600570717081089cba70acf412c3c4"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkwNDM3Nw==", "bodyText": "done, see ebd1906", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394904377", "createdAt": "2020-03-19T09:50:22Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchClient.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.asyncsearch.SubmitAsyncSearchRequest;\n+import org.elasticsearch.client.asyncsearch.AsyncSearchResponse;\n+\n+import java.io.IOException;\n+\n+import static java.util.Collections.emptySet;\n+\n+public class AsyncSearchClient {\n+    private final RestHighLevelClient restHighLevelClient;\n+\n+    AsyncSearchClient(RestHighLevelClient restHighLevelClient) {\n+        this.restHighLevelClient = restHighLevelClient;\n+    }\n+\n+    // TODO add docs url", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5MTUyMg=="}, "originalCommit": {"oid": "220e6a89f0600570717081089cba70acf412c3c4"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NjQzMTQ3OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchRequestConverters.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQyMzoxNTowMFrOF4aE8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwOTo1MDo0MFrOF4nD9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5MTgyNQ==", "bodyText": "nit: maybe given they are now used in two places we could add the with* methods for these params too?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394691825", "createdAt": "2020-03-18T23:15:00Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchRequestConverters.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client;\n+\n+import org.apache.http.client.methods.HttpPost;\n+import org.elasticsearch.client.RequestConverters.Params;\n+import org.elasticsearch.client.asyncsearch.SubmitAsyncSearchRequest;\n+import org.elasticsearch.rest.action.search.RestSearchAction;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.client.RequestConverters.REQUEST_BODY_CONTENT_TYPE;\n+\n+final class AsyncSearchRequestConverters {\n+\n+    static Request submitAsyncSearch(SubmitAsyncSearchRequest asyncSearchRequest) throws IOException {\n+        String endpoint = new RequestConverters.EndpointBuilder().addCommaSeparatedPathParts(\n+                asyncSearchRequest.getIndices())\n+                .addPathPartAsIs(\"_async_search\").build();\n+        Request request = new Request(HttpPost.METHOD_NAME, endpoint);\n+        Params params = new RequestConverters.Params();\n+        // add all typical search params and search request source as body\n+        addSearchRequestParams(params, asyncSearchRequest);\n+        if (asyncSearchRequest.getSearchSource() != null) {\n+            request.setEntity(RequestConverters.createEntity(asyncSearchRequest.getSearchSource(), REQUEST_BODY_CONTENT_TYPE));\n+        }\n+        // set async search submit specific parameters\n+        if (asyncSearchRequest.isCleanOnCompletion() != null) {\n+            params.putParam(\"clean_on_completion\", asyncSearchRequest.isCleanOnCompletion().toString());\n+        }\n+        if (asyncSearchRequest.getKeepAlive() != null) {\n+            params.putParam(\"keep_alive\", asyncSearchRequest.getKeepAlive().getStringRep());\n+        }\n+        if (asyncSearchRequest.getWaitForCompletion() != null) {\n+            params.putParam(\"wait_for_completion\", asyncSearchRequest.getWaitForCompletion().getStringRep());\n+        }\n+        request.addParameters(params.asMap());\n+        return request;\n+    }\n+\n+    static void addSearchRequestParams(Params params, SubmitAsyncSearchRequest request) {\n+        params.putParam(RestSearchAction.TYPED_KEYS_PARAM, \"true\");\n+        params.withRouting(request.getRouting());\n+        params.withPreference(request.getPreference());\n+        params.withIndicesOptions(request.getIndicesOptions());\n+        params.putParam(\"search_type\", request.getSearchType().name().toLowerCase(Locale.ROOT));\n+        params.putParam(\"max_concurrent_shard_requests\", Integer.toString(request.getMaxConcurrentShardRequests()));\n+        if (request.getRequestCache() != null) {\n+            params.putParam(\"request_cache\", Boolean.toString(request.getRequestCache()));\n+        }\n+        if (request.getAllowPartialSearchResults() != null) {\n+            params.putParam(\"allow_partial_search_results\", Boolean.toString(request.getAllowPartialSearchResults()));\n+        }\n+        params.putParam(\"batched_reduce_size\", Integer.toString(request.getBatchedReduceSize()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "220e6a89f0600570717081089cba70acf412c3c4"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkwNDU2Ng==", "bodyText": "done in f65cf82", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394904566", "createdAt": "2020-03-19T09:50:40Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchRequestConverters.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client;\n+\n+import org.apache.http.client.methods.HttpPost;\n+import org.elasticsearch.client.RequestConverters.Params;\n+import org.elasticsearch.client.asyncsearch.SubmitAsyncSearchRequest;\n+import org.elasticsearch.rest.action.search.RestSearchAction;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.client.RequestConverters.REQUEST_BODY_CONTENT_TYPE;\n+\n+final class AsyncSearchRequestConverters {\n+\n+    static Request submitAsyncSearch(SubmitAsyncSearchRequest asyncSearchRequest) throws IOException {\n+        String endpoint = new RequestConverters.EndpointBuilder().addCommaSeparatedPathParts(\n+                asyncSearchRequest.getIndices())\n+                .addPathPartAsIs(\"_async_search\").build();\n+        Request request = new Request(HttpPost.METHOD_NAME, endpoint);\n+        Params params = new RequestConverters.Params();\n+        // add all typical search params and search request source as body\n+        addSearchRequestParams(params, asyncSearchRequest);\n+        if (asyncSearchRequest.getSearchSource() != null) {\n+            request.setEntity(RequestConverters.createEntity(asyncSearchRequest.getSearchSource(), REQUEST_BODY_CONTENT_TYPE));\n+        }\n+        // set async search submit specific parameters\n+        if (asyncSearchRequest.isCleanOnCompletion() != null) {\n+            params.putParam(\"clean_on_completion\", asyncSearchRequest.isCleanOnCompletion().toString());\n+        }\n+        if (asyncSearchRequest.getKeepAlive() != null) {\n+            params.putParam(\"keep_alive\", asyncSearchRequest.getKeepAlive().getStringRep());\n+        }\n+        if (asyncSearchRequest.getWaitForCompletion() != null) {\n+            params.putParam(\"wait_for_completion\", asyncSearchRequest.getWaitForCompletion().getStringRep());\n+        }\n+        request.addParameters(params.asMap());\n+        return request;\n+    }\n+\n+    static void addSearchRequestParams(Params params, SubmitAsyncSearchRequest request) {\n+        params.putParam(RestSearchAction.TYPED_KEYS_PARAM, \"true\");\n+        params.withRouting(request.getRouting());\n+        params.withPreference(request.getPreference());\n+        params.withIndicesOptions(request.getIndicesOptions());\n+        params.putParam(\"search_type\", request.getSearchType().name().toLowerCase(Locale.ROOT));\n+        params.putParam(\"max_concurrent_shard_requests\", Integer.toString(request.getMaxConcurrentShardRequests()));\n+        if (request.getRequestCache() != null) {\n+            params.putParam(\"request_cache\", Boolean.toString(request.getRequestCache()));\n+        }\n+        if (request.getAllowPartialSearchResults() != null) {\n+            params.putParam(\"allow_partial_search_results\", Boolean.toString(request.getAllowPartialSearchResults()));\n+        }\n+        params.putParam(\"batched_reduce_size\", Integer.toString(request.getBatchedReduceSize()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5MTgyNQ=="}, "originalCommit": {"oid": "220e6a89f0600570717081089cba70acf412c3c4"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NzgzMTA0OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/RequestConverters.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMDowODo1M1rOF4nvYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMDowODo1M1rOF4nvYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNTY4Mg==", "bodyText": "nit: rename to  withAllowPartialResults ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394915682", "createdAt": "2020-03-19T10:08:53Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/RequestConverters.java", "diffHunk": "@@ -860,6 +860,26 @@ Params withPreference(String preference) {\n             return putParam(\"preference\", preference);\n         }\n \n+        Params withSearchType(String searchType) {\n+            return putParam(\"search_type\", searchType);\n+        }\n+\n+        Params withMaxConcurrentShardRequests(int maxConcurrentShardRequests) {\n+            return putParam(\"max_concurrent_shard_requests\", Integer.toString(maxConcurrentShardRequests));\n+        }\n+\n+        Params withBatchedReduceSize(int batchedReduceSize) {\n+            return putParam(\"batched_reduce_size\", Integer.toString(batchedReduceSize));\n+        }\n+\n+        Params withRequestCache(boolean requestCache) {\n+            return putParam(\"request_cache\", Boolean.toString(requestCache));\n+        }\n+\n+        Params withPartialResults(boolean allowPartialSearchResults) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NzgzNDkyOnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMDoxMDowN1rOF4nx4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMzoyMzowM1rOF4uIJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNjMyMw==", "bodyText": "Why can't this be a constructor arg ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394916323", "createdAt": "2020-03-19T10:10:07Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;\n+    }\n+\n+    /**\n+     * Returns the failure reason or null if the query is running or has completed normally.\n+     */\n+    public ElasticsearchException getFailure() {\n+        return error;\n+    }\n+\n+    /**\n+     * Sets the optional failure property, use by parser and tests\n+     */\n+    void setFailure(ElasticsearchException error) {\n+        this.error = error;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the {@link SearchResponse} contains partial\n+     * results computed from a subset of the total shards.\n+     */\n+    public boolean isPartial() {\n+        return isPartial;\n+    }\n+\n+    /**\n+     * Whether the search is still running in the cluster.\n+     *\n+     * A value of <code>false</code> indicates that the response is final\n+     * even if {@link #isPartial()} returns <code>true</code>. In such case,\n+     * the partial response represents the status of the search before a\n+     * non-recoverable failure.\n+     */\n+    public boolean isRunning() {\n+        return isRunning;\n+    }\n+\n+    /**\n+     * When this response was created as a timestamp in milliseconds since epoch.\n+     */\n+    public long getStartTime() {\n+        return startTimeMillis;\n+    }\n+\n+    /**\n+     * When this response will expired as a timestamp in milliseconds since epoch.\n+     */\n+    public long getExpirationTime() {\n+        return expirationTimeMillis;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (id != null) {\n+            builder.field(\"id\", id);\n+        }\n+        builder.field(\"version\", version);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"start_time_in_millis\", startTimeMillis);\n+        builder.field(\"expiration_time_in_millis\", expirationTimeMillis);\n+\n+        if (searchResponse != null) {\n+            builder.field(\"response\");\n+            searchResponse.toXContent(builder, params);\n+        }\n+        if (error != null) {\n+            builder.startObject(\"error\");\n+            error.toXContent(builder, params);\n+            builder.endObject();\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public static final ParseField ID_FIELD = new ParseField(\"id\");\n+    public static final ParseField VERSION_FIELD = new ParseField(\"version\");\n+    public static final ParseField IS_PARTIAL_FIELD = new ParseField(\"is_partial\");\n+    public static final ParseField IS_RUNNING_FIELD = new ParseField(\"is_running\");\n+    public static final ParseField START_TIME_FIELD = new ParseField(\"start_time_in_millis\");\n+    public static final ParseField EXPIRATION_FIELD = new ParseField(\"expiration_time_in_millis\");\n+    public static final ParseField RESPONSE_FIELD = new ParseField(\"response\");\n+    public static final ParseField ERROR_FIELD = new ParseField(\"error\");\n+\n+    public static final ConstructingObjectParser<AsyncSearchResponse, Void> PARSER = new ConstructingObjectParser<>(\n+            \"submit_async_search_response\", true,\n+            args -> new AsyncSearchResponse(\n+                    (int) args[0],\n+                    (boolean) args[1],\n+                    (boolean) args[2],\n+                    (long) args[3],\n+                    (long) args[4]));\n+    static {\n+        PARSER.declareInt(ConstructingObjectParser.constructorArg(), VERSION_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_PARTIAL_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_RUNNING_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), START_TIME_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), EXPIRATION_FIELD);\n+        PARSER.declareString(AsyncSearchResponse::setId, ID_FIELD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAwNDA0OQ==", "bodyText": "True, this could be an optionalConstructorArg(). I think I did this via setters because I disklike too many optional ctor args that can be null and made the setters for them package private. I can even make them private (the setters), would that be okay with you? I don't remember exactly if more ctor args somehow slow down ConstructingObjectParser since they need to be buffered before object creation but I guess that would be a minor disadvantage.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r395004049", "createdAt": "2020-03-19T12:56:05Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;\n+    }\n+\n+    /**\n+     * Returns the failure reason or null if the query is running or has completed normally.\n+     */\n+    public ElasticsearchException getFailure() {\n+        return error;\n+    }\n+\n+    /**\n+     * Sets the optional failure property, use by parser and tests\n+     */\n+    void setFailure(ElasticsearchException error) {\n+        this.error = error;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the {@link SearchResponse} contains partial\n+     * results computed from a subset of the total shards.\n+     */\n+    public boolean isPartial() {\n+        return isPartial;\n+    }\n+\n+    /**\n+     * Whether the search is still running in the cluster.\n+     *\n+     * A value of <code>false</code> indicates that the response is final\n+     * even if {@link #isPartial()} returns <code>true</code>. In such case,\n+     * the partial response represents the status of the search before a\n+     * non-recoverable failure.\n+     */\n+    public boolean isRunning() {\n+        return isRunning;\n+    }\n+\n+    /**\n+     * When this response was created as a timestamp in milliseconds since epoch.\n+     */\n+    public long getStartTime() {\n+        return startTimeMillis;\n+    }\n+\n+    /**\n+     * When this response will expired as a timestamp in milliseconds since epoch.\n+     */\n+    public long getExpirationTime() {\n+        return expirationTimeMillis;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (id != null) {\n+            builder.field(\"id\", id);\n+        }\n+        builder.field(\"version\", version);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"start_time_in_millis\", startTimeMillis);\n+        builder.field(\"expiration_time_in_millis\", expirationTimeMillis);\n+\n+        if (searchResponse != null) {\n+            builder.field(\"response\");\n+            searchResponse.toXContent(builder, params);\n+        }\n+        if (error != null) {\n+            builder.startObject(\"error\");\n+            error.toXContent(builder, params);\n+            builder.endObject();\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public static final ParseField ID_FIELD = new ParseField(\"id\");\n+    public static final ParseField VERSION_FIELD = new ParseField(\"version\");\n+    public static final ParseField IS_PARTIAL_FIELD = new ParseField(\"is_partial\");\n+    public static final ParseField IS_RUNNING_FIELD = new ParseField(\"is_running\");\n+    public static final ParseField START_TIME_FIELD = new ParseField(\"start_time_in_millis\");\n+    public static final ParseField EXPIRATION_FIELD = new ParseField(\"expiration_time_in_millis\");\n+    public static final ParseField RESPONSE_FIELD = new ParseField(\"response\");\n+    public static final ParseField ERROR_FIELD = new ParseField(\"error\");\n+\n+    public static final ConstructingObjectParser<AsyncSearchResponse, Void> PARSER = new ConstructingObjectParser<>(\n+            \"submit_async_search_response\", true,\n+            args -> new AsyncSearchResponse(\n+                    (int) args[0],\n+                    (boolean) args[1],\n+                    (boolean) args[2],\n+                    (long) args[3],\n+                    (long) args[4]));\n+    static {\n+        PARSER.declareInt(ConstructingObjectParser.constructorArg(), VERSION_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_PARTIAL_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_RUNNING_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), START_TIME_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), EXPIRATION_FIELD);\n+        PARSER.declareString(AsyncSearchResponse::setId, ID_FIELD);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNjMyMw=="}, "originalCommit": {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAyMDMyNw==", "bodyText": "I pushed some changes and went with optionalConstructorArg to avoid more unnecessary roundtrips on this, in the end I don't care that much.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r395020327", "createdAt": "2020-03-19T13:23:03Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;\n+    }\n+\n+    /**\n+     * Returns the failure reason or null if the query is running or has completed normally.\n+     */\n+    public ElasticsearchException getFailure() {\n+        return error;\n+    }\n+\n+    /**\n+     * Sets the optional failure property, use by parser and tests\n+     */\n+    void setFailure(ElasticsearchException error) {\n+        this.error = error;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the {@link SearchResponse} contains partial\n+     * results computed from a subset of the total shards.\n+     */\n+    public boolean isPartial() {\n+        return isPartial;\n+    }\n+\n+    /**\n+     * Whether the search is still running in the cluster.\n+     *\n+     * A value of <code>false</code> indicates that the response is final\n+     * even if {@link #isPartial()} returns <code>true</code>. In such case,\n+     * the partial response represents the status of the search before a\n+     * non-recoverable failure.\n+     */\n+    public boolean isRunning() {\n+        return isRunning;\n+    }\n+\n+    /**\n+     * When this response was created as a timestamp in milliseconds since epoch.\n+     */\n+    public long getStartTime() {\n+        return startTimeMillis;\n+    }\n+\n+    /**\n+     * When this response will expired as a timestamp in milliseconds since epoch.\n+     */\n+    public long getExpirationTime() {\n+        return expirationTimeMillis;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (id != null) {\n+            builder.field(\"id\", id);\n+        }\n+        builder.field(\"version\", version);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"start_time_in_millis\", startTimeMillis);\n+        builder.field(\"expiration_time_in_millis\", expirationTimeMillis);\n+\n+        if (searchResponse != null) {\n+            builder.field(\"response\");\n+            searchResponse.toXContent(builder, params);\n+        }\n+        if (error != null) {\n+            builder.startObject(\"error\");\n+            error.toXContent(builder, params);\n+            builder.endObject();\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public static final ParseField ID_FIELD = new ParseField(\"id\");\n+    public static final ParseField VERSION_FIELD = new ParseField(\"version\");\n+    public static final ParseField IS_PARTIAL_FIELD = new ParseField(\"is_partial\");\n+    public static final ParseField IS_RUNNING_FIELD = new ParseField(\"is_running\");\n+    public static final ParseField START_TIME_FIELD = new ParseField(\"start_time_in_millis\");\n+    public static final ParseField EXPIRATION_FIELD = new ParseField(\"expiration_time_in_millis\");\n+    public static final ParseField RESPONSE_FIELD = new ParseField(\"response\");\n+    public static final ParseField ERROR_FIELD = new ParseField(\"error\");\n+\n+    public static final ConstructingObjectParser<AsyncSearchResponse, Void> PARSER = new ConstructingObjectParser<>(\n+            \"submit_async_search_response\", true,\n+            args -> new AsyncSearchResponse(\n+                    (int) args[0],\n+                    (boolean) args[1],\n+                    (boolean) args[2],\n+                    (long) args[3],\n+                    (long) args[4]));\n+    static {\n+        PARSER.declareInt(ConstructingObjectParser.constructorArg(), VERSION_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_PARTIAL_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_RUNNING_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), START_TIME_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), EXPIRATION_FIELD);\n+        PARSER.declareString(AsyncSearchResponse::setId, ID_FIELD);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNjMyMw=="}, "originalCommit": {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NzgzNTM3OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMDoxMDoxNVrOF4nyMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMDoxMDoxNVrOF4nyMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNjQwMA==", "bodyText": "Same here ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394916400", "createdAt": "2020-03-19T10:10:15Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;\n+    }\n+\n+    /**\n+     * Returns the failure reason or null if the query is running or has completed normally.\n+     */\n+    public ElasticsearchException getFailure() {\n+        return error;\n+    }\n+\n+    /**\n+     * Sets the optional failure property, use by parser and tests\n+     */\n+    void setFailure(ElasticsearchException error) {\n+        this.error = error;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the {@link SearchResponse} contains partial\n+     * results computed from a subset of the total shards.\n+     */\n+    public boolean isPartial() {\n+        return isPartial;\n+    }\n+\n+    /**\n+     * Whether the search is still running in the cluster.\n+     *\n+     * A value of <code>false</code> indicates that the response is final\n+     * even if {@link #isPartial()} returns <code>true</code>. In such case,\n+     * the partial response represents the status of the search before a\n+     * non-recoverable failure.\n+     */\n+    public boolean isRunning() {\n+        return isRunning;\n+    }\n+\n+    /**\n+     * When this response was created as a timestamp in milliseconds since epoch.\n+     */\n+    public long getStartTime() {\n+        return startTimeMillis;\n+    }\n+\n+    /**\n+     * When this response will expired as a timestamp in milliseconds since epoch.\n+     */\n+    public long getExpirationTime() {\n+        return expirationTimeMillis;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (id != null) {\n+            builder.field(\"id\", id);\n+        }\n+        builder.field(\"version\", version);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"start_time_in_millis\", startTimeMillis);\n+        builder.field(\"expiration_time_in_millis\", expirationTimeMillis);\n+\n+        if (searchResponse != null) {\n+            builder.field(\"response\");\n+            searchResponse.toXContent(builder, params);\n+        }\n+        if (error != null) {\n+            builder.startObject(\"error\");\n+            error.toXContent(builder, params);\n+            builder.endObject();\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public static final ParseField ID_FIELD = new ParseField(\"id\");\n+    public static final ParseField VERSION_FIELD = new ParseField(\"version\");\n+    public static final ParseField IS_PARTIAL_FIELD = new ParseField(\"is_partial\");\n+    public static final ParseField IS_RUNNING_FIELD = new ParseField(\"is_running\");\n+    public static final ParseField START_TIME_FIELD = new ParseField(\"start_time_in_millis\");\n+    public static final ParseField EXPIRATION_FIELD = new ParseField(\"expiration_time_in_millis\");\n+    public static final ParseField RESPONSE_FIELD = new ParseField(\"response\");\n+    public static final ParseField ERROR_FIELD = new ParseField(\"error\");\n+\n+    public static final ConstructingObjectParser<AsyncSearchResponse, Void> PARSER = new ConstructingObjectParser<>(\n+            \"submit_async_search_response\", true,\n+            args -> new AsyncSearchResponse(\n+                    (int) args[0],\n+                    (boolean) args[1],\n+                    (boolean) args[2],\n+                    (long) args[3],\n+                    (long) args[4]));\n+    static {\n+        PARSER.declareInt(ConstructingObjectParser.constructorArg(), VERSION_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_PARTIAL_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_RUNNING_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), START_TIME_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), EXPIRATION_FIELD);\n+        PARSER.declareString(AsyncSearchResponse::setId, ID_FIELD);\n+        PARSER.declareObject(AsyncSearchResponse::setSearchResponse, (p, c) -> AsyncSearchResponse.parseSearchResponse(p),\n+                RESPONSE_FIELD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NzgzNTgwOnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMDoxMDoyM1rOF4nyhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMDoxMDoyM1rOF4nyhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNjQ4Ng==", "bodyText": "And here ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394916486", "createdAt": "2020-03-19T10:10:23Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;\n+    }\n+\n+    /**\n+     * Returns the failure reason or null if the query is running or has completed normally.\n+     */\n+    public ElasticsearchException getFailure() {\n+        return error;\n+    }\n+\n+    /**\n+     * Sets the optional failure property, use by parser and tests\n+     */\n+    void setFailure(ElasticsearchException error) {\n+        this.error = error;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the {@link SearchResponse} contains partial\n+     * results computed from a subset of the total shards.\n+     */\n+    public boolean isPartial() {\n+        return isPartial;\n+    }\n+\n+    /**\n+     * Whether the search is still running in the cluster.\n+     *\n+     * A value of <code>false</code> indicates that the response is final\n+     * even if {@link #isPartial()} returns <code>true</code>. In such case,\n+     * the partial response represents the status of the search before a\n+     * non-recoverable failure.\n+     */\n+    public boolean isRunning() {\n+        return isRunning;\n+    }\n+\n+    /**\n+     * When this response was created as a timestamp in milliseconds since epoch.\n+     */\n+    public long getStartTime() {\n+        return startTimeMillis;\n+    }\n+\n+    /**\n+     * When this response will expired as a timestamp in milliseconds since epoch.\n+     */\n+    public long getExpirationTime() {\n+        return expirationTimeMillis;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (id != null) {\n+            builder.field(\"id\", id);\n+        }\n+        builder.field(\"version\", version);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"start_time_in_millis\", startTimeMillis);\n+        builder.field(\"expiration_time_in_millis\", expirationTimeMillis);\n+\n+        if (searchResponse != null) {\n+            builder.field(\"response\");\n+            searchResponse.toXContent(builder, params);\n+        }\n+        if (error != null) {\n+            builder.startObject(\"error\");\n+            error.toXContent(builder, params);\n+            builder.endObject();\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public static final ParseField ID_FIELD = new ParseField(\"id\");\n+    public static final ParseField VERSION_FIELD = new ParseField(\"version\");\n+    public static final ParseField IS_PARTIAL_FIELD = new ParseField(\"is_partial\");\n+    public static final ParseField IS_RUNNING_FIELD = new ParseField(\"is_running\");\n+    public static final ParseField START_TIME_FIELD = new ParseField(\"start_time_in_millis\");\n+    public static final ParseField EXPIRATION_FIELD = new ParseField(\"expiration_time_in_millis\");\n+    public static final ParseField RESPONSE_FIELD = new ParseField(\"response\");\n+    public static final ParseField ERROR_FIELD = new ParseField(\"error\");\n+\n+    public static final ConstructingObjectParser<AsyncSearchResponse, Void> PARSER = new ConstructingObjectParser<>(\n+            \"submit_async_search_response\", true,\n+            args -> new AsyncSearchResponse(\n+                    (int) args[0],\n+                    (boolean) args[1],\n+                    (boolean) args[2],\n+                    (long) args[3],\n+                    (long) args[4]));\n+    static {\n+        PARSER.declareInt(ConstructingObjectParser.constructorArg(), VERSION_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_PARTIAL_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_RUNNING_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), START_TIME_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), EXPIRATION_FIELD);\n+        PARSER.declareString(AsyncSearchResponse::setId, ID_FIELD);\n+        PARSER.declareObject(AsyncSearchResponse::setSearchResponse, (p, c) -> AsyncSearchResponse.parseSearchResponse(p),\n+                RESPONSE_FIELD);\n+        PARSER.declareObject(AsyncSearchResponse::setFailure, (p, c) -> ElasticsearchException.fromXContent(p), ERROR_FIELD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0Nzg0NDAzOnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMDoxMjozNVrOF4n3xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMDoxMjozNVrOF4n3xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNzgzMQ==", "bodyText": "This can be set in the ctr ? It should be final too.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394917831", "createdAt": "2020-03-19T10:12:35Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0Nzg0NDQwOnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMDoxMjo0MlrOF4n3_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMDoxMjo0MlrOF4n3_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNzg4NQ==", "bodyText": "same here", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394917885", "createdAt": "2020-03-19T10:12:42Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68"}, "originalPosition": 104}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3268, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}