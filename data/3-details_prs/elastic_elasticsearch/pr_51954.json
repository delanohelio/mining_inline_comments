{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxNDkyNTgy", "number": 51954, "title": "Move specialized execute method code into an external phase", "bodyText": "This change moves almost all of the customized code required to decorate the execute method into an external phase. This external phase operates only on the ir tree after the user tree has generated the initial ir tree from user specified code. The external phase uses ir nodes to create the necessary customized code instead of writing asm directly. This is a first example of modifying the ir tree to customize it specifically for Elasticsearch and leaves the ir nodes in a more generic state.\nAnother change required for this was to remove the notion of auto-return from the ir tree completely. The user tree is now responsible for generating appropriate ir tree nodes to support auto-return. This is the first example of divergent user and ir trees as the user tree is intended to be higher level while the ir tree is supposed to provide lower level translation into asm.\nRelates to #49869\nRelates to #51841", "createdAt": "2020-02-05T17:18:37Z", "url": "https://github.com/elastic/elasticsearch/pull/51954", "merged": true, "mergeCommit": {"oid": "026474d5de2f72d23d1bee4d0b9abcabfb7df53b"}, "closed": true, "closedAt": "2020-02-11T20:37:31Z", "author": {"login": "jdconrad"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBJ-zagH2gAyMzcxNDkyNTgyOjZlNmFhMzIwYTRlODZmYzYxZjk3YzNmNjg4MjhiNjk4ODY2NjI0MTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcDUciyAH2gAyMzcxNDkyNTgyOjEwZDg3NTdhMWFlMGU0NTcyNTFlYmM0YmM1YWU5MDU2YzcxMjY5NzE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6e6aa320a4e86fc61f97c3f68828b69886662415", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/6e6aa320a4e86fc61f97c3f68828b69886662415", "committedDate": "2020-02-04T23:17:45Z", "message": "removed scopes for functions to see used variables"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f8f2db1681620b7a4ff8b4fb6f1a5c85cde3c7b", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/0f8f2db1681620b7a4ff8b4fb6f1a5c85cde3c7b", "committedDate": "2020-02-04T23:40:15Z", "message": "change scoping to track variables in all scopes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92281afdd77398b9928520621d4410a1cc0d0c92", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/92281afdd77398b9928520621d4410a1cc0d0c92", "committedDate": "2020-02-04T23:43:52Z", "message": "partially removed execute method exceptino customization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1dfeda725afc5bc5e615d9aa0d99492923f929b", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/d1dfeda725afc5bc5e615d9aa0d99492923f929b", "committedDate": "2020-02-05T00:11:35Z", "message": "move autoreturn out of ir nodes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65147708c75fc0c16023c7576b2aa9ba52b1980a", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/65147708c75fc0c16023c7576b2aa9ba52b1980a", "committedDate": "2020-02-05T16:56:42Z", "message": "add es specific exceptions in decorate execute phase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6115179c2b5b9bb6ab690212f35babfb7ed6103f", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/6115179c2b5b9bb6ab690212f35babfb7ed6103f", "committedDate": "2020-02-05T17:09:10Z", "message": "remove commented out code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57feda775fd8e006aa5d29f6a6494e75449d3f2d", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/57feda775fd8e006aa5d29f6a6494e75449d3f2d", "committedDate": "2020-02-05T22:34:25Z", "message": "Merge branch 'master' into trees6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84f5754ffb2b867554eea9ae42d116231e67555c", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/84f5754ffb2b867554eea9ae42d116231e67555c", "committedDate": "2020-02-10T22:09:50Z", "message": "Merge branch 'master' into trees6"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MzU0NzM0", "url": "https://github.com/elastic/elasticsearch/pull/51954#pullrequestreview-356354734", "createdAt": "2020-02-11T00:11:25Z", "commit": {"oid": "84f5754ffb2b867554eea9ae42d116231e67555c"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMDoxMToyNlrOFn6I2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMDo0ODozOFrOFn6wJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5MTMyMQ==", "bodyText": "typo: to for -> for", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377391321", "createdAt": "2020-02-11T00:11:26Z", "author": {"login": "rjernst"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/DecorateExecutePhase.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless;\n+\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.CallNode;\n+import org.elasticsearch.painless.ir.CallSubNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.UnboundCallNode;\n+import org.elasticsearch.painless.ir.UnboundFieldNode;\n+import org.elasticsearch.painless.ir.VariableNode;\n+import org.elasticsearch.painless.lookup.PainlessLookup;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+import org.elasticsearch.script.ScriptException;\n+import org.objectweb.asm.commons.Method;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+/**\n+ * This injects additional ir nodes required to for", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84f5754ffb2b867554eea9ae42d116231e67555c"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5NTk0Mg==", "bodyText": "this could be a class constant, like ERRORS_TO_CATCH?", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377395942", "createdAt": "2020-02-11T00:28:26Z", "author": {"login": "rjernst"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/DecorateExecutePhase.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless;\n+\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.CallNode;\n+import org.elasticsearch.painless.ir.CallSubNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.UnboundCallNode;\n+import org.elasticsearch.painless.ir.UnboundFieldNode;\n+import org.elasticsearch.painless.ir.VariableNode;\n+import org.elasticsearch.painless.lookup.PainlessLookup;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+import org.elasticsearch.script.ScriptException;\n+import org.objectweb.asm.commons.Method;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+/**\n+ * This injects additional ir nodes required to for\n+ * the \"execute\" method. This includes injection of ir nodes\n+ * to convert get methods into local variables for those\n+ * that are used and adds additional sandboxing by wrapping\n+ * the main \"execute\" block with several exceptions.\n+ */\n+public class DecorateExecutePhase {\n+\n+    public static void phase(ScriptRoot scriptRoot, ClassNode classNode) {\n+        FunctionNode executeFunctionNode = null;\n+\n+        // look up the execute method for decoration\n+        for (FunctionNode functionNode : classNode.getFunctionsNodes()) {\n+            if (\"execute\".equals(functionNode.getName())) {\n+                executeFunctionNode = functionNode;\n+                break;\n+            }\n+        }\n+\n+        BlockNode blockNode = executeFunctionNode.getBlockNode();\n+\n+        // convert gets methods to a new set of inserted ir nodes as necessary -\n+        // requires the gets method name be modified from \"getExample\" to \"example\"\n+        // if a get method variable isn't used it's declaration node is removed from\n+        // the ir tree permanently so there is no frivolous variable slotting\n+        int statementIndex = 0;\n+\n+        while (statementIndex < blockNode.getStatementsNodes().size()) {\n+            StatementNode statementNode = blockNode.getStatementsNodes().get(statementIndex);\n+\n+            if (statementNode instanceof DeclarationNode) {\n+                DeclarationNode declarationNode = (DeclarationNode)statementNode;\n+                boolean isRemoved = false;\n+\n+                for (int getIndex = 0; getIndex < scriptRoot.getScriptClassInfo().getGetMethods().size(); ++getIndex) {\n+                    Class<?> returnType = scriptRoot.getScriptClassInfo().getGetReturns().get(getIndex);\n+                    Method getMethod = scriptRoot.getScriptClassInfo().getGetMethods().get(getIndex);\n+                    String name = getMethod.getName().substring(3);\n+                    name = Character.toLowerCase(name.charAt(0)) + name.substring(1);\n+\n+                    if (name.equals(declarationNode.getName())) {\n+                        if (scriptRoot.getUsedVariables().contains(name)) {\n+                                UnboundCallNode unboundCallNode = new UnboundCallNode();\n+                                unboundCallNode.setLocation(declarationNode.getLocation());\n+                                unboundCallNode.setExpressionType(declarationNode.getDeclarationType());\n+                                unboundCallNode.setLocalFunction(new LocalFunction(\n+                                        getMethod.getName(), returnType, Collections.emptyList(), true, false));\n+                                declarationNode.setExpressionNode(unboundCallNode);\n+                        } else {\n+                            blockNode.getStatementsNodes().remove(statementIndex);\n+                            isRemoved = true;\n+                        }\n+\n+                        break;\n+                    }\n+                }\n+\n+                if (isRemoved == false) {\n+                    ++statementIndex;\n+                }\n+            } else {\n+                ++statementIndex;\n+            }\n+        }\n+\n+        // decorate the execute method with nodes to wrap the user statements with\n+        // the sandboxed errors as follows:\n+        // } catch (PainlessExplainError e) {\n+        //     throw this.convertToScriptException(e, e.getHeaders($DEFINITION))\n+        // }\n+        // and\n+        // } catch (PainlessError | BootstrapMethodError | OutOfMemoryError | StackOverflowError | Exception e) {\n+        //     throw this.convertToScriptException(e, e.getHeaders())\n+        // }\n+        try {\n+            Location internalLocation = new Location(\"<internal>\", 0);\n+\n+            TryNode tryNode = new TryNode();\n+            tryNode.setLocation(internalLocation);\n+            tryNode.setBlockNode(blockNode);\n+\n+            CatchNode catchNode = new CatchNode();\n+            catchNode.setLocation(internalLocation);\n+\n+            tryNode.addCatchNode(catchNode);\n+\n+            DeclarationNode declarationNode = new DeclarationNode();\n+            declarationNode.setLocation(internalLocation);\n+            declarationNode.setDeclarationType(PainlessExplainError.class);\n+            declarationNode.setName(\"#painlessExplainError\");\n+            declarationNode.setRequiresDefault(false);\n+\n+            catchNode.setDeclarationNode(declarationNode);\n+\n+            BlockNode catchBlockNode = new BlockNode();\n+            catchBlockNode.setLocation(internalLocation);\n+            catchBlockNode.setAllEscape(true);\n+            catchBlockNode.setStatementCount(1);\n+\n+            catchNode.setBlockNode(catchBlockNode);\n+\n+            ThrowNode throwNode = new ThrowNode();\n+            throwNode.setLocation(internalLocation);\n+\n+            catchBlockNode.addStatementNode(throwNode);\n+\n+            UnboundCallNode unboundCallNode = new UnboundCallNode();\n+            unboundCallNode.setLocation(internalLocation);\n+            unboundCallNode.setExpressionType(ScriptException.class);\n+            unboundCallNode.setLocalFunction(new LocalFunction(\n+                            \"convertToScriptException\",\n+                            ScriptException.class,\n+                            Arrays.asList(Throwable.class, Map.class),\n+                            true,\n+                            false\n+                    )\n+            );\n+\n+            throwNode.setExpressionNode(unboundCallNode);\n+\n+            VariableNode variableNode = new VariableNode();\n+            variableNode.setLocation(internalLocation);\n+            variableNode.setExpressionType(ScriptException.class);\n+            variableNode.setName(\"#painlessExplainError\");\n+\n+            unboundCallNode.addArgumentNode(variableNode);\n+\n+            CallNode callNode = new CallNode();\n+            callNode.setLocation(internalLocation);\n+            callNode.setExpressionType(Map.class);\n+\n+            unboundCallNode.addArgumentNode(callNode);\n+\n+            variableNode = new VariableNode();\n+            variableNode.setLocation(internalLocation);\n+            variableNode.setExpressionType(PainlessExplainError.class);\n+            variableNode.setName(\"#painlessExplainError\");\n+\n+            callNode.setLeftNode(variableNode);\n+\n+            CallSubNode callSubNode = new CallSubNode();\n+            callSubNode.setLocation(internalLocation);\n+            callSubNode.setExpressionType(Map.class);\n+            callSubNode.setBox(PainlessExplainError.class);\n+            callSubNode.setMethod(new PainlessMethod(\n+                    PainlessExplainError.class.getMethod(\n+                            \"getHeaders\",\n+                            PainlessLookup.class),\n+                    PainlessExplainError.class,\n+                    null,\n+                    Collections.emptyList(),\n+                    null,\n+                    null,\n+                    null\n+            ));\n+\n+            callNode.setRightNode(callSubNode);\n+\n+            UnboundFieldNode unboundFieldNode = new UnboundFieldNode();\n+            unboundFieldNode.setLocation(internalLocation);\n+            unboundFieldNode.setExpressionType(PainlessLookup.class);\n+            unboundFieldNode.setName(\"$DEFINITION\");\n+            unboundFieldNode.setStatic(true);\n+\n+            callSubNode.addArgumentNode(unboundFieldNode);\n+\n+            for (Class<?> throwable : new Class<?>[] {\n+                    PainlessError.class, BootstrapMethodError.class, OutOfMemoryError.class, StackOverflowError.class, Exception.class}) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84f5754ffb2b867554eea9ae42d116231e67555c"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5NjA2NQ==", "bodyText": "this can be private, no need to construct right?", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377396065", "createdAt": "2020-02-11T00:28:54Z", "author": {"login": "rjernst"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/DecorateExecutePhase.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless;\n+\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.CallNode;\n+import org.elasticsearch.painless.ir.CallSubNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.UnboundCallNode;\n+import org.elasticsearch.painless.ir.UnboundFieldNode;\n+import org.elasticsearch.painless.ir.VariableNode;\n+import org.elasticsearch.painless.lookup.PainlessLookup;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+import org.elasticsearch.script.ScriptException;\n+import org.objectweb.asm.commons.Method;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+/**\n+ * This injects additional ir nodes required to for\n+ * the \"execute\" method. This includes injection of ir nodes\n+ * to convert get methods into local variables for those\n+ * that are used and adds additional sandboxing by wrapping\n+ * the main \"execute\" block with several exceptions.\n+ */\n+public class DecorateExecutePhase {\n+\n+    public static void phase(ScriptRoot scriptRoot, ClassNode classNode) {\n+        FunctionNode executeFunctionNode = null;\n+\n+        // look up the execute method for decoration\n+        for (FunctionNode functionNode : classNode.getFunctionsNodes()) {\n+            if (\"execute\".equals(functionNode.getName())) {\n+                executeFunctionNode = functionNode;\n+                break;\n+            }\n+        }\n+\n+        BlockNode blockNode = executeFunctionNode.getBlockNode();\n+\n+        // convert gets methods to a new set of inserted ir nodes as necessary -\n+        // requires the gets method name be modified from \"getExample\" to \"example\"\n+        // if a get method variable isn't used it's declaration node is removed from\n+        // the ir tree permanently so there is no frivolous variable slotting\n+        int statementIndex = 0;\n+\n+        while (statementIndex < blockNode.getStatementsNodes().size()) {\n+            StatementNode statementNode = blockNode.getStatementsNodes().get(statementIndex);\n+\n+            if (statementNode instanceof DeclarationNode) {\n+                DeclarationNode declarationNode = (DeclarationNode)statementNode;\n+                boolean isRemoved = false;\n+\n+                for (int getIndex = 0; getIndex < scriptRoot.getScriptClassInfo().getGetMethods().size(); ++getIndex) {\n+                    Class<?> returnType = scriptRoot.getScriptClassInfo().getGetReturns().get(getIndex);\n+                    Method getMethod = scriptRoot.getScriptClassInfo().getGetMethods().get(getIndex);\n+                    String name = getMethod.getName().substring(3);\n+                    name = Character.toLowerCase(name.charAt(0)) + name.substring(1);\n+\n+                    if (name.equals(declarationNode.getName())) {\n+                        if (scriptRoot.getUsedVariables().contains(name)) {\n+                                UnboundCallNode unboundCallNode = new UnboundCallNode();\n+                                unboundCallNode.setLocation(declarationNode.getLocation());\n+                                unboundCallNode.setExpressionType(declarationNode.getDeclarationType());\n+                                unboundCallNode.setLocalFunction(new LocalFunction(\n+                                        getMethod.getName(), returnType, Collections.emptyList(), true, false));\n+                                declarationNode.setExpressionNode(unboundCallNode);\n+                        } else {\n+                            blockNode.getStatementsNodes().remove(statementIndex);\n+                            isRemoved = true;\n+                        }\n+\n+                        break;\n+                    }\n+                }\n+\n+                if (isRemoved == false) {\n+                    ++statementIndex;\n+                }\n+            } else {\n+                ++statementIndex;\n+            }\n+        }\n+\n+        // decorate the execute method with nodes to wrap the user statements with\n+        // the sandboxed errors as follows:\n+        // } catch (PainlessExplainError e) {\n+        //     throw this.convertToScriptException(e, e.getHeaders($DEFINITION))\n+        // }\n+        // and\n+        // } catch (PainlessError | BootstrapMethodError | OutOfMemoryError | StackOverflowError | Exception e) {\n+        //     throw this.convertToScriptException(e, e.getHeaders())\n+        // }\n+        try {\n+            Location internalLocation = new Location(\"<internal>\", 0);\n+\n+            TryNode tryNode = new TryNode();\n+            tryNode.setLocation(internalLocation);\n+            tryNode.setBlockNode(blockNode);\n+\n+            CatchNode catchNode = new CatchNode();\n+            catchNode.setLocation(internalLocation);\n+\n+            tryNode.addCatchNode(catchNode);\n+\n+            DeclarationNode declarationNode = new DeclarationNode();\n+            declarationNode.setLocation(internalLocation);\n+            declarationNode.setDeclarationType(PainlessExplainError.class);\n+            declarationNode.setName(\"#painlessExplainError\");\n+            declarationNode.setRequiresDefault(false);\n+\n+            catchNode.setDeclarationNode(declarationNode);\n+\n+            BlockNode catchBlockNode = new BlockNode();\n+            catchBlockNode.setLocation(internalLocation);\n+            catchBlockNode.setAllEscape(true);\n+            catchBlockNode.setStatementCount(1);\n+\n+            catchNode.setBlockNode(catchBlockNode);\n+\n+            ThrowNode throwNode = new ThrowNode();\n+            throwNode.setLocation(internalLocation);\n+\n+            catchBlockNode.addStatementNode(throwNode);\n+\n+            UnboundCallNode unboundCallNode = new UnboundCallNode();\n+            unboundCallNode.setLocation(internalLocation);\n+            unboundCallNode.setExpressionType(ScriptException.class);\n+            unboundCallNode.setLocalFunction(new LocalFunction(\n+                            \"convertToScriptException\",\n+                            ScriptException.class,\n+                            Arrays.asList(Throwable.class, Map.class),\n+                            true,\n+                            false\n+                    )\n+            );\n+\n+            throwNode.setExpressionNode(unboundCallNode);\n+\n+            VariableNode variableNode = new VariableNode();\n+            variableNode.setLocation(internalLocation);\n+            variableNode.setExpressionType(ScriptException.class);\n+            variableNode.setName(\"#painlessExplainError\");\n+\n+            unboundCallNode.addArgumentNode(variableNode);\n+\n+            CallNode callNode = new CallNode();\n+            callNode.setLocation(internalLocation);\n+            callNode.setExpressionType(Map.class);\n+\n+            unboundCallNode.addArgumentNode(callNode);\n+\n+            variableNode = new VariableNode();\n+            variableNode.setLocation(internalLocation);\n+            variableNode.setExpressionType(PainlessExplainError.class);\n+            variableNode.setName(\"#painlessExplainError\");\n+\n+            callNode.setLeftNode(variableNode);\n+\n+            CallSubNode callSubNode = new CallSubNode();\n+            callSubNode.setLocation(internalLocation);\n+            callSubNode.setExpressionType(Map.class);\n+            callSubNode.setBox(PainlessExplainError.class);\n+            callSubNode.setMethod(new PainlessMethod(\n+                    PainlessExplainError.class.getMethod(\n+                            \"getHeaders\",\n+                            PainlessLookup.class),\n+                    PainlessExplainError.class,\n+                    null,\n+                    Collections.emptyList(),\n+                    null,\n+                    null,\n+                    null\n+            ));\n+\n+            callNode.setRightNode(callSubNode);\n+\n+            UnboundFieldNode unboundFieldNode = new UnboundFieldNode();\n+            unboundFieldNode.setLocation(internalLocation);\n+            unboundFieldNode.setExpressionType(PainlessLookup.class);\n+            unboundFieldNode.setName(\"$DEFINITION\");\n+            unboundFieldNode.setStatic(true);\n+\n+            callSubNode.addArgumentNode(unboundFieldNode);\n+\n+            for (Class<?> throwable : new Class<?>[] {\n+                    PainlessError.class, BootstrapMethodError.class, OutOfMemoryError.class, StackOverflowError.class, Exception.class}) {\n+\n+                String name = throwable.getSimpleName();\n+                name = \"#\" + Character.toLowerCase(name.charAt(0)) + name.substring(1);\n+\n+                catchNode = new CatchNode();\n+                catchNode.setLocation(internalLocation);\n+\n+                tryNode.addCatchNode(catchNode);\n+\n+                declarationNode = new DeclarationNode();\n+                declarationNode.setLocation(internalLocation);\n+                declarationNode.setDeclarationType(throwable);\n+                declarationNode.setName(name);\n+                declarationNode.setRequiresDefault(false);\n+\n+                catchNode.setDeclarationNode(declarationNode);\n+\n+                catchBlockNode = new BlockNode();\n+                catchBlockNode.setLocation(internalLocation);\n+                catchBlockNode.setAllEscape(true);\n+                catchBlockNode.setStatementCount(1);\n+\n+                catchNode.setBlockNode(catchBlockNode);\n+\n+                throwNode = new ThrowNode();\n+                throwNode.setLocation(internalLocation);\n+\n+                catchBlockNode.addStatementNode(throwNode);\n+\n+                unboundCallNode = new UnboundCallNode();\n+                unboundCallNode.setLocation(internalLocation);\n+                unboundCallNode.setExpressionType(ScriptException.class);\n+                unboundCallNode.setLocalFunction(new LocalFunction(\n+                                \"convertToScriptException\",\n+                                ScriptException.class,\n+                                Arrays.asList(Throwable.class, Map.class),\n+                                true,\n+                                false\n+                        )\n+                );\n+\n+                throwNode.setExpressionNode(unboundCallNode);\n+\n+                variableNode = new VariableNode();\n+                variableNode.setLocation(internalLocation);\n+                variableNode.setExpressionType(ScriptException.class);\n+                variableNode.setName(name);\n+\n+                unboundCallNode.addArgumentNode(variableNode);\n+\n+                callNode = new CallNode();\n+                callNode.setLocation(internalLocation);\n+                callNode.setExpressionType(Map.class);\n+\n+                unboundCallNode.addArgumentNode(callNode);\n+\n+                StaticNode staticNode = new StaticNode();\n+                staticNode.setLocation(internalLocation);\n+                staticNode.setExpressionType(Collections.class);\n+\n+                callNode.setLeftNode(staticNode);\n+\n+                callSubNode = new CallSubNode();\n+                callSubNode.setLocation(internalLocation);\n+                callSubNode.setExpressionType(Map.class);\n+                callSubNode.setBox(Collections.class);\n+                callSubNode.setMethod(new PainlessMethod(\n+                        Collections.class.getMethod(\"emptyMap\"),\n+                        Collections.class,\n+                        null,\n+                        Collections.emptyList(),\n+                        null,\n+                        null,\n+                        null\n+                ));\n+\n+                callNode.setRightNode(callSubNode);\n+            }\n+\n+            blockNode = new BlockNode();\n+            blockNode.setLocation(blockNode.getLocation());\n+            blockNode.setAllEscape(blockNode.doAllEscape());\n+            blockNode.setStatementCount(blockNode.getStatementCount());\n+            blockNode.addStatementNode(tryNode);\n+\n+            executeFunctionNode.setBlockNode(blockNode);\n+        } catch (Exception exception) {\n+            throw new RuntimeException(exception);\n+        }\n+    }\n+\n+    protected DecorateExecutePhase() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84f5754ffb2b867554eea9ae42d116231e67555c"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5OTE3NQ==", "bodyText": "Would MemberFieldNode be a better name here?", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377399175", "createdAt": "2020-02-11T00:40:04Z", "author": {"login": "rjernst"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/UnboundFieldNode.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.ir;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.Globals;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.symbol.ScopeTable;\n+\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+\n+public class UnboundFieldNode extends ExpressionNode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84f5754ffb2b867554eea9ae42d116231e67555c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5OTQ3OA==", "bodyText": "Maybe we should rename this to MemberCallNode? The meaning of unbound is unclear", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377399478", "createdAt": "2020-02-11T00:41:15Z", "author": {"login": "rjernst"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/DecorateExecutePhase.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless;\n+\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.CallNode;\n+import org.elasticsearch.painless.ir.CallSubNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.UnboundCallNode;\n+import org.elasticsearch.painless.ir.UnboundFieldNode;\n+import org.elasticsearch.painless.ir.VariableNode;\n+import org.elasticsearch.painless.lookup.PainlessLookup;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+import org.elasticsearch.script.ScriptException;\n+import org.objectweb.asm.commons.Method;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+/**\n+ * This injects additional ir nodes required to for\n+ * the \"execute\" method. This includes injection of ir nodes\n+ * to convert get methods into local variables for those\n+ * that are used and adds additional sandboxing by wrapping\n+ * the main \"execute\" block with several exceptions.\n+ */\n+public class DecorateExecutePhase {\n+\n+    public static void phase(ScriptRoot scriptRoot, ClassNode classNode) {\n+        FunctionNode executeFunctionNode = null;\n+\n+        // look up the execute method for decoration\n+        for (FunctionNode functionNode : classNode.getFunctionsNodes()) {\n+            if (\"execute\".equals(functionNode.getName())) {\n+                executeFunctionNode = functionNode;\n+                break;\n+            }\n+        }\n+\n+        BlockNode blockNode = executeFunctionNode.getBlockNode();\n+\n+        // convert gets methods to a new set of inserted ir nodes as necessary -\n+        // requires the gets method name be modified from \"getExample\" to \"example\"\n+        // if a get method variable isn't used it's declaration node is removed from\n+        // the ir tree permanently so there is no frivolous variable slotting\n+        int statementIndex = 0;\n+\n+        while (statementIndex < blockNode.getStatementsNodes().size()) {\n+            StatementNode statementNode = blockNode.getStatementsNodes().get(statementIndex);\n+\n+            if (statementNode instanceof DeclarationNode) {\n+                DeclarationNode declarationNode = (DeclarationNode)statementNode;\n+                boolean isRemoved = false;\n+\n+                for (int getIndex = 0; getIndex < scriptRoot.getScriptClassInfo().getGetMethods().size(); ++getIndex) {\n+                    Class<?> returnType = scriptRoot.getScriptClassInfo().getGetReturns().get(getIndex);\n+                    Method getMethod = scriptRoot.getScriptClassInfo().getGetMethods().get(getIndex);\n+                    String name = getMethod.getName().substring(3);\n+                    name = Character.toLowerCase(name.charAt(0)) + name.substring(1);\n+\n+                    if (name.equals(declarationNode.getName())) {\n+                        if (scriptRoot.getUsedVariables().contains(name)) {\n+                                UnboundCallNode unboundCallNode = new UnboundCallNode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84f5754ffb2b867554eea9ae42d116231e67555c"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwMTM4MA==", "bodyText": "This isn't really decorating execute (well the try/catch is, but it's still not decorating, it's wrapping in that case?). In the other case we have variables being converted to this.getXXX() calls...they seem unrelated, maybe they should be separate classes? In both these cases these seem to be things we need for correctness in the IR tree, so to me should be part of the creation of the IR tree, rather than phases operating on it. But I also appreciate this is just a step towards the overarching refactor, so if this frees up space to move towards that future, I'm fine with this as is for now.", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377401380", "createdAt": "2020-02-11T00:48:38Z", "author": {"login": "rjernst"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/DecorateExecutePhase.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless;\n+\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.CallNode;\n+import org.elasticsearch.painless.ir.CallSubNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.UnboundCallNode;\n+import org.elasticsearch.painless.ir.UnboundFieldNode;\n+import org.elasticsearch.painless.ir.VariableNode;\n+import org.elasticsearch.painless.lookup.PainlessLookup;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+import org.elasticsearch.script.ScriptException;\n+import org.objectweb.asm.commons.Method;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+/**\n+ * This injects additional ir nodes required to for\n+ * the \"execute\" method. This includes injection of ir nodes\n+ * to convert get methods into local variables for those\n+ * that are used and adds additional sandboxing by wrapping\n+ * the main \"execute\" block with several exceptions.\n+ */\n+public class DecorateExecutePhase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84f5754ffb2b867554eea9ae42d116231e67555c"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb4e48c3e0c301a294151a92dcaf69672801dd0c", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/bb4e48c3e0c301a294151a92dcaf69672801dd0c", "committedDate": "2020-02-11T16:02:33Z", "message": "Merge branch 'master' into trees6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10d8757a1ae0e457251ebc4bc5ae9056c7126971", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/10d8757a1ae0e457251ebc4bc5ae9056c7126971", "committedDate": "2020-02-11T16:37:08Z", "message": "response to PR comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2834, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}