{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1Mzk1Mjg5", "number": 64591, "title": "Centralize cache service instances creation in tests", "bodyText": "This pull request centralizes the creation of CacheService instances in Searchable Snapshot tests. It cleans up a bit the tests and it will make the tests more easily adaptable when the creation of CacheService will be more complex due to the future persistent cache.", "createdAt": "2020-11-04T13:45:05Z", "url": "https://github.com/elastic/elasticsearch/pull/64591", "merged": true, "mergeCommit": {"oid": "61a2d0050c98b9aa84ef5abf96cbd5a8c974e980"}, "closed": true, "closedAt": "2020-11-05T08:18:46Z", "author": {"login": "tlrx"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZNzRxgH2gAyNTE1Mzk1Mjg5OmVmOTUxOGVlYzJmNzE3ODBhODVhNTUwNWNkOTc3NGZjNzc0MGVhN2Y=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZQZGFAH2gAyNTE1Mzk1Mjg5OmFmYTNjNmJjMDYzN2NiODEwYzNmZDZkMWMyZjdiOGMyYzYzYmIxM2U=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ef9518eec2f71780a85a5505cd9774fc7740ea7f", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/ef9518eec2f71780a85a5505cd9774fc7740ea7f", "committedDate": "2020-11-04T13:30:07Z", "message": "Mutualize cache service creation in tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNDUwNDI4", "url": "https://github.com/elastic/elasticsearch/pull/64591#pullrequestreview-523450428", "createdAt": "2020-11-04T15:06:32Z", "commit": {"oid": "ef9518eec2f71780a85a5505cd9774fc7740ea7f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowNjozMlrOHtcSvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowNjozMlrOHtcSvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxMTUxNg==", "bodyText": "The method this replaces in some spots used a 30s timeout. When I created it I just copied those 30s from previous code so I don't know if we actually need the long of a timeout here, but maybe we do and should put I back here?", "url": "https://github.com/elastic/elasticsearch/pull/64591#discussion_r517411516", "createdAt": "2020-11-04T15:06:32Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/AbstractSearchableSnapshotsTestCase.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.TestShardRouting;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.lucene.store.ESIndexInputTestCase;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.indices.recovery.RecoveryState;\n+import org.elasticsearch.indices.recovery.SearchableSnapshotRecoveryState;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.snapshots.Snapshot;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.threadpool.ThreadPoolStats;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+public abstract class AbstractSearchableSnapshotsTestCase extends ESIndexInputTestCase {\n+\n+    protected ThreadPool threadPool;\n+\n+    @Before\n+    public void setUpTest() {\n+        threadPool = new TestThreadPool(getTestName(), SearchableSnapshots.executorBuilders());\n+    }\n+\n+    @After\n+    public void tearDownTest() {\n+        assertTrue(ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * @return a new {@link CacheService} instance configured with default settings\n+     */\n+    protected CacheService defaultCacheService() {\n+        return new CacheService(AbstractSearchableSnapshotsTestCase::noOpCacheCleaner, Settings.EMPTY);\n+    }\n+\n+    /**\n+     * @return a new {@link CacheService} instance configured with random cache size and cache range size settings\n+     */\n+    protected CacheService randomCacheService() {\n+        final Settings.Builder cacheSettings = Settings.builder();\n+        if (randomBoolean()) {\n+            cacheSettings.put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), randomCacheSize());\n+        }\n+        if (randomBoolean()) {\n+            cacheSettings.put(CacheService.SNAPSHOT_CACHE_RANGE_SIZE_SETTING.getKey(), randomCacheRangeSize());\n+        }\n+        return new CacheService(AbstractSearchableSnapshotsTestCase::noOpCacheCleaner, cacheSettings.build());\n+    }\n+\n+    /**\n+     * @return a new {@link CacheService} instance configured with the given cache size and cache range size settings\n+     */\n+    protected CacheService createCacheService(final ByteSizeValue cacheSize, final ByteSizeValue cacheRangeSize) {\n+        return new CacheService(\n+            AbstractSearchableSnapshotsTestCase::noOpCacheCleaner,\n+            Settings.builder()\n+                .put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), cacheSize)\n+                .put(CacheService.SNAPSHOT_CACHE_RANGE_SIZE_SETTING.getKey(), cacheRangeSize)\n+                .build()\n+        );\n+    }\n+\n+    protected static void noOpCacheCleaner() {}\n+\n+    /**\n+     * @return a random {@link ByteSizeValue} that can be used to set {@link CacheService#SNAPSHOT_CACHE_SIZE_SETTING}.\n+     * Note that it can return a cache size of 0.\n+     */\n+    protected static ByteSizeValue randomCacheSize() {\n+        return new ByteSizeValue(randomNonNegativeLong());\n+    }\n+\n+    /**\n+     * @return a random {@link ByteSizeValue} that can be used to set {@link CacheService#SNAPSHOT_CACHE_RANGE_SIZE_SETTING}\n+     */\n+    protected static ByteSizeValue randomCacheRangeSize() {\n+        return new ByteSizeValue(\n+            randomLongBetween(CacheService.MIN_SNAPSHOT_CACHE_RANGE_SIZE.getBytes(), CacheService.MAX_SNAPSHOT_CACHE_RANGE_SIZE.getBytes())\n+        );\n+    }\n+\n+    protected static SearchableSnapshotRecoveryState createRecoveryState() {\n+        ShardRouting shardRouting = TestShardRouting.newShardRouting(\n+            new ShardId(randomAlphaOfLength(10), randomAlphaOfLength(10), 0),\n+            randomAlphaOfLength(10),\n+            true,\n+            ShardRoutingState.INITIALIZING,\n+            new RecoverySource.SnapshotRecoverySource(\n+                UUIDs.randomBase64UUID(),\n+                new Snapshot(\"repo\", new SnapshotId(randomAlphaOfLength(8), UUIDs.randomBase64UUID())),\n+                Version.CURRENT,\n+                new IndexId(\"some_index\", UUIDs.randomBase64UUID(random()))\n+            )\n+        );\n+        DiscoveryNode targetNode = new DiscoveryNode(\"local\", buildNewFakeTransportAddress(), Version.CURRENT);\n+        SearchableSnapshotRecoveryState recoveryState = new SearchableSnapshotRecoveryState(shardRouting, targetNode, null);\n+\n+        recoveryState.setStage(RecoveryState.Stage.INIT)\n+            .setStage(RecoveryState.Stage.INDEX)\n+            .setStage(RecoveryState.Stage.VERIFY_INDEX)\n+            .setStage(RecoveryState.Stage.TRANSLOG);\n+        recoveryState.getIndex().setFileDetailsComplete();\n+        recoveryState.setStage(RecoveryState.Stage.FINALIZE).setStage(RecoveryState.Stage.DONE);\n+\n+        return recoveryState;\n+    }\n+\n+    /**\n+     * Wait for all operations on the threadpool to complete\n+     */\n+    protected static void assertThreadPoolNotBusy(ThreadPool threadPool) throws Exception {\n+        assertBusy(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef9518eec2f71780a85a5505cd9774fc7740ea7f"}, "originalPosition": 131}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afa3c6bc0637cb810c3fd6d1c2f7b8c2c63bb13e", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/afa3c6bc0637cb810c3fd6d1c2f7b8c2c63bb13e", "committedDate": "2020-11-04T16:31:14Z", "message": "30s"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 815, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}