{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxMTg2ODk1", "number": 50823, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwOTozMzozMFrODXGM4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMDo0Nzo0OVrODYdkOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1NTQ1NDQzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/build.gradle", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwOTozMzozMFrOFcOmUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwOTozMzozMFrOFcOmUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE0MzYzNA==", "bodyText": "Unfortunately this creates a runtime issue as plugins that are not marked as extensible (such as Painless) cannot have their classes imported into a different project.\nIn other words the FlatObjectFieldMapper.CONTENT_TYPE won't be available which would result in a CNFE.\nAs such as I would simply declare the String constant internally and use it verbatim instead of linking to it.", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r365143634", "createdAt": "2020-01-10T09:33:30Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/build.gradle", "diffHunk": "@@ -39,6 +39,7 @@ check.dependsOn internalClusterTest\n \n dependencies {\n   compileOnly project(path: xpackModule('core'), configuration: 'default')\n+  compileOnly project(path: xpackModule('mapper-flattened'))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "920e14334928482f0d8cd9dae57385c058133c9b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1NTQ1OTE1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/index/IndexResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwOTozNToxM1rOFcOpMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwOTozNToxM1rOFcOpMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE0NDM3MQ==", "bodyText": "I wonder if we cannot make this a bit generic by looking for field names that have leaves starting with _ and if so, look at their type  - if its not recognized, mark the field as unsupported.", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r365144371", "createdAt": "2020-01-10T09:35:13Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/index/IndexResolver.java", "diffHunk": "@@ -493,6 +495,12 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n                 if (typeEntry.getKey().startsWith(\"_\") && typeCap.getType().startsWith(\"_\")) {\n                     continue;\n                 }\n+                \n+                // skip the \"flattened\" type of field's \"_keyed\" subfield", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "920e14334928482f0d8cd9dae57385c058133c9b"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NDEwNzg1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNzowNDoxN1rOFdfAnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNzowNDoxN1rOFdfAnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2MTA4NA==", "bodyText": "minor: extra new line", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r366461084", "createdAt": "2020-01-14T17:04:17Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -495,6 +501,7 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n                 if (typeEntry.getKey().startsWith(\"_\") && typeCap.getType().startsWith(\"_\")) {\n                     continue;\n                 }\n+                ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44cf2049aacaec835df2d0b487f316cc41b5706a"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTczODU2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMDozNzo1NFrOFeVA0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMDozNzo1NFrOFeVA0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0NTg3Mw==", "bodyText": "The whole block can be further simplified by\nesField = new UnsupportedEsField(esField.getName(), type, inherited != null ? inherited : unsupportedParent.getName(), esField.getProperties());", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r367345873", "createdAt": "2020-01-16T10:37:54Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -387,7 +388,22 @@ private static EsField createField(String fieldName, Map<String, Map<String, Fie\n         }\n \n         EsField esField = field.apply(fieldName);\n-        \n+\n+        if (parent != null && parent instanceof UnsupportedEsField) {\n+            UnsupportedEsField unsupportedParent = (UnsupportedEsField) parent;\n+            String inherited = unsupportedParent.getInherited();\n+            String type = unsupportedParent.getOriginalType();\n+            \n+            if (inherited == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e92964d51ee46440627913aa6fb3aca81401c8"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTc0NTQ0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/type/Types.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMDo0MDowM1rOFeVE1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMDo0MDowM1rOFeVE1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0NjkwMQ==", "bodyText": "Why is the if needed - the result will be the same regardless of whether field is UnsupportedEsField or not.", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r367346901", "createdAt": "2020-01-16T10:40:03Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/type/Types.java", "diffHunk": "@@ -113,4 +114,21 @@ private static boolean boolSetting(Object value, boolean defaultValue) {\n     private static int intSetting(Object value, int defaultValue) {\n         return value == null ? defaultValue : Integer.parseInt(value.toString());\n     }\n+    \n+    private static void propagateUnsupportedType(String inherited, String originalType, Map<String, EsField> properties) {\n+        if (properties != null && properties.isEmpty() == false) {\n+            for (Entry<String, EsField> entry : properties.entrySet()) {\n+                EsField field = entry.getValue();\n+                UnsupportedEsField u;\n+                if (field instanceof UnsupportedEsField) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e92964d51ee46440627913aa6fb3aca81401c8"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTc1NzU5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMDo0NDoxOVrOFeVMbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMDo0NDoxOVrOFeVMbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0ODg0NA==", "bodyText": "Since the message is the same in the branch, simply do the if on the prefix\nString inheritedMessage = \"\";\nif (unsupportedField.hasInherited()) {\n   inheritedMessage = format(\"in hierarchy (field [{}\"], unsupportedField.getInherited()));\n}\nnamed = u.withUnresolvedMessage(... + inheritedMessage);\n\nFurther more replace the string concatenation in the message with MessageFormat.format to trim it a bit.", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r367348844", "createdAt": "2020-01-16T10:44:19Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java", "diffHunk": "@@ -217,8 +217,14 @@ private static Attribute handleSpecialFields(UnresolvedAttribute u, Attribute na\n             // unsupported types\n             else if (DataTypes.isUnsupported(fa.dataType())) {\n                 UnsupportedEsField unsupportedField = (UnsupportedEsField) fa.field();\n-                named = u.withUnresolvedMessage(\n-                        \"Cannot use field [\" + fa.name() + \"] type [\" + unsupportedField.getOriginalType() + \"] as is unsupported\");\n+                if (unsupportedField.hasInherited()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e92964d51ee46440627913aa6fb3aca81401c8"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTc2ODI0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/type/Types.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMDo0Nzo0OVrOFeVSyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNjo1MDo1MlrOFewKtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1MDQ3Mg==", "bodyText": "Why is propagated needed? The parents should always be discovered before children which means an unsupported parent will discovered before its children, which in turn, will already know their parent is unsupported and thus become unsupported as well.", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r367350472", "createdAt": "2020-01-16T10:47:49Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/type/Types.java", "diffHunk": "@@ -91,7 +91,8 @@ private static void walkMapping(String name, Object value, Map<String, EsField>\n                     break;\n                 case UNSUPPORTED:\n                     String type = content.get(\"type\").toString();\n-                    field = new UnsupportedEsField(name, type);\n+                    field = new UnsupportedEsField(name, type, null, properties);\n+                    propagateUnsupportedType(name, type, properties);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e92964d51ee46440627913aa6fb3aca81401c8"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1OTcxMw==", "bodyText": "@costin  If I remember well, the method pair startWalking-walkMapping does the discovery the other way around: start with a mapping looking like parent=[child=[another_child=[type:keyword]], type:text], type:foobar]], get the parent, look at properties like \"it's nested\", or \"it's object\", or \"has sub-fields\" here, if yes, dig into those and so on and so forth.\nThen after discovering all the children, create the parent itself here. So, by the time the algorithm finds out that a root field is unsupported, the children already have some types (their own).", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r367359713", "createdAt": "2020-01-16T11:09:44Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/type/Types.java", "diffHunk": "@@ -91,7 +91,8 @@ private static void walkMapping(String name, Object value, Map<String, EsField>\n                     break;\n                 case UNSUPPORTED:\n                     String type = content.get(\"type\").toString();\n-                    field = new UnsupportedEsField(name, type);\n+                    field = new UnsupportedEsField(name, type, null, properties);\n+                    propagateUnsupportedType(name, type, properties);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1MDQ3Mg=="}, "originalCommit": {"oid": "a9e92964d51ee46440627913aa6fb3aca81401c8"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5MDc3Mw==", "bodyText": "This approach is used only in the case of some tests that use a .json file with mappings. I made this change because I wanted to also test the error message (here) that gets printed out from the Analyzer.", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r367790773", "createdAt": "2020-01-17T06:50:52Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/type/Types.java", "diffHunk": "@@ -91,7 +91,8 @@ private static void walkMapping(String name, Object value, Map<String, EsField>\n                     break;\n                 case UNSUPPORTED:\n                     String type = content.get(\"type\").toString();\n-                    field = new UnsupportedEsField(name, type);\n+                    field = new UnsupportedEsField(name, type, null, properties);\n+                    propagateUnsupportedType(name, type, properties);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1MDQ3Mg=="}, "originalCommit": {"oid": "a9e92964d51ee46440627913aa6fb3aca81401c8"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4809, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}