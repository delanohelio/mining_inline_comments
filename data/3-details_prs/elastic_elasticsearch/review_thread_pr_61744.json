{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc2NDE0MjI2", "number": 61744, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzo1NTo0M1rOEeyKBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzo1NTo0M1rOEeyKBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzE0NTAwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/translog/TranslogWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzo1NTo0M1rOHKqWfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODo0Nzo1MFrOHKsa9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk0MTY5NA==", "bodyText": "What's a bit subtle here is that we assume callers to not have any concurrent access to this method. Also we assume that once an exception occurs, this method is no more called on the same FileChannel. The surrounding context currently correctly implements this, but it is easy to break and can have disastrous effects. Is there a way we can strengthen these assumptions via assertions?  I was also wondering if we should use positional writes (see FileChannel.write(ByteBuffer src, long position), to ensure we truly always write starting with offset 0 in all cases, and move the positioning logic to the Checkpoint.write method.", "url": "https://github.com/elastic/elasticsearch/pull/61744#discussion_r480941694", "createdAt": "2020-09-01T07:55:43Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/index/translog/TranslogWriter.java", "diffHunk": "@@ -414,10 +427,12 @@ protected void readBytes(ByteBuffer targetBuffer, long position) throws IOExcept\n     }\n \n     private static void writeCheckpoint(\n-            final ChannelFactory channelFactory,\n-            final Path translogFile,\n-            final Checkpoint checkpoint) throws IOException {\n-        Checkpoint.write(channelFactory, translogFile.resolve(Translog.CHECKPOINT_FILE_NAME), checkpoint, StandardOpenOption.WRITE);\n+        final FileChannel fileChannel,\n+        final Path checkpointFile,\n+        final Checkpoint checkpoint) throws IOException {\n+        // Since we used a fixed size checkpoint, we overwrite the checkpoint each time.\n+        fileChannel.position(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4d2f5b8f5d4cf6d4171f4da72ba2b47984f4bc8"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk3NTYwNA==", "bodyText": "++ to using positional writes, those should technically be slightly faster as well I think because we only have to lock the internal positionLock in the file channel once.", "url": "https://github.com/elastic/elasticsearch/pull/61744#discussion_r480975604", "createdAt": "2020-09-01T08:47:50Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/index/translog/TranslogWriter.java", "diffHunk": "@@ -414,10 +427,12 @@ protected void readBytes(ByteBuffer targetBuffer, long position) throws IOExcept\n     }\n \n     private static void writeCheckpoint(\n-            final ChannelFactory channelFactory,\n-            final Path translogFile,\n-            final Checkpoint checkpoint) throws IOException {\n-        Checkpoint.write(channelFactory, translogFile.resolve(Translog.CHECKPOINT_FILE_NAME), checkpoint, StandardOpenOption.WRITE);\n+        final FileChannel fileChannel,\n+        final Path checkpointFile,\n+        final Checkpoint checkpoint) throws IOException {\n+        // Since we used a fixed size checkpoint, we overwrite the checkpoint each time.\n+        fileChannel.position(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk0MTY5NA=="}, "originalCommit": {"oid": "b4d2f5b8f5d4cf6d4171f4da72ba2b47984f4bc8"}, "originalPosition": 118}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1880, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}