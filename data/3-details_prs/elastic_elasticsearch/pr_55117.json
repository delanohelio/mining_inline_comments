{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyNzA0MTIy", "number": 55117, "title": "Validate REST specs against schema", "bodyText": "A JSON schema was recently introduced for the REST API specification. #54252\nThis PR introduces a 3rd party validation tool to ensure that the\nREST specification conforms the schema.\nThe task is applied to the 3 projects that contain REST API specifications.\nThe plugin wires this task into the precommit commit task, and should be\nconsidered as part of the public API for the build tools for any plugin\ndeveloper to contribute their plugin's specification.\nAn ignore parameter has been introduced for the task to allow specific\nfile to be ignored from the validation. The ignored files in this PR\nwill soon get issues logged and a link so they can be fixed.\nCloses #54314", "createdAt": "2020-04-13T15:45:19Z", "url": "https://github.com/elastic/elasticsearch/pull/55117", "merged": true, "mergeCommit": {"oid": "2b0900d33ba3f879a235f79414bc51d593accc36"}, "closed": true, "closedAt": "2020-04-21T23:18:19Z", "author": {"login": "jakelandis"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXQoUyAH2gAyNDAyNzA0MTIyOmU3NDQ0NjMwZDRhNGI3OTcyOWYwZTFhZDhmY2E3NTBlMDBlMDZmNDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZ5esNAH2gAyNDAyNzA0MTIyOjE0MzExOTEzNGNiMTAxZGNlZWQ0NDM0OTRkMWNjOTUzMzM5NzE1YWE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e7444630d4a4b79729f0e1ad8fca750e00e06f44", "author": {"user": {"login": "jakelandis", "name": "Jake Landis"}}, "url": "https://github.com/elastic/elasticsearch/commit/e7444630d4a4b79729f0e1ad8fca750e00e06f44", "committedDate": "2020-04-13T15:28:52Z", "message": "new validateRestSpec task and plugin\n\nA JSON schema was recently introduced for the REST API specification. #54252\nThis PR introduces a 3rd party validation tool to ensure that the\nREST specification conforms the schema.\n\nThe task is applied to the 3 projects that contain REST API specifications.\nThe plugin wires this task into the precommit commit task, and should be\nconsidered as part of the public API for the build tools for any plugin\ndeveloper to contribute their plugin's specification.\n\nAn ignore parameter has been introduced for the task to allow specific\nfile to be ignored from the validation. The ignored files in this PR\nwill soon get issues logged and a link so they can be fixed.\n\nCloses #54314"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b8bdf055fff6b309875a544386a6b857778bf57", "author": {"user": {"login": "jakelandis", "name": "Jake Landis"}}, "url": "https://github.com/elastic/elasticsearch/commit/7b8bdf055fff6b309875a544386a6b857778bf57", "committedDate": "2020-04-13T16:54:37Z", "message": "fix javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b34ba76ffad406a205bd110a10ecfa80a4d02a46", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/b34ba76ffad406a205bd110a10ecfa80a4d02a46", "committedDate": "2020-04-13T18:01:36Z", "message": "Merge branch 'master' into validate_rest_spec"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNDM3MTAx", "url": "https://github.com/elastic/elasticsearch/pull/55117#pullrequestreview-392437101", "createdAt": "2020-04-13T21:02:22Z", "commit": {"oid": "b34ba76ffad406a205bd110a10ecfa80a4d02a46"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTowMjoyMlrOGE1Ncw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTozNjozMVrOGE2OqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxOTI4Mw==", "bodyText": "This should probably be called getInputFiles() or similar.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407719283", "createdAt": "2020-04-13T21:02:22Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {\n+\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STARS = \"**\"; // checkstyle thinks this is an empty javadoc statement, so string concat instead\n+    private static final String JSON_SPEC_PATTERN_INCLUDE = DOUBLE_STARS + \"/rest-api-spec/api/\" + DOUBLE_STARS + \"/*.json\";\n+    private static final String JSON_SPEC_PATTERN_EXCLUDE = DOUBLE_STARS + \"/_common.json\";\n+    private static final String JSON_SCHEMA_PATTERN = DOUBLE_STARS + \"/schema.json\";\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+\n+    @SkipWhenEmpty\n+    @InputFiles\n+    public FileTree getInputDir() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b34ba76ffad406a205bd110a10ecfa80a4d02a46"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxOTU0MQ==", "bodyText": "How long does this thing take to run? Should we make it cacheable?", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407719541", "createdAt": "2020-04-13T21:02:52Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b34ba76ffad406a205bd110a10ecfa80a4d02a46"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMDk0NA==", "bodyText": "We should not directly access the schema from the task implementation. We should do this in the plugin and pass them in as an input to the task. Two reasons for this:\n\nThis logic simply shouldn't exist in the task. This \"wiring\" should be done by plugins. This makes the tasks more reusable and composable.\nThe schema isn't tracked as an input. Which means, if it changes we won't correctly flag this task as out of date.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407720944", "createdAt": "2020-04-13T21:05:37Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {\n+\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STARS = \"**\"; // checkstyle thinks this is an empty javadoc statement, so string concat instead\n+    private static final String JSON_SPEC_PATTERN_INCLUDE = DOUBLE_STARS + \"/rest-api-spec/api/\" + DOUBLE_STARS + \"/*.json\";\n+    private static final String JSON_SPEC_PATTERN_EXCLUDE = DOUBLE_STARS + \"/_common.json\";\n+    private static final String JSON_SCHEMA_PATTERN = DOUBLE_STARS + \"/schema.json\";\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+\n+    @SkipWhenEmpty\n+    @InputFiles\n+    public FileTree getInputDir() {\n+        // if null results in in NO-SOURCE\n+        return Util.getJavaTestAndMainSourceResources(\n+            getProject(),\n+            Util.filterByPatterns(\n+                getPatternSetFactory().create(),\n+                Collections.singletonList(JSON_SPEC_PATTERN_INCLUDE),\n+                Collections.singletonList(JSON_SPEC_PATTERN_EXCLUDE)\n+            )\n+        );\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @Inject\n+    protected Factory<PatternSet> getPatternSetFactory() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @TaskAction\n+    public void validate() throws IOException {\n+        // load schema\n+        JsonSchema jsonSchema;\n+        FileTree jsonSchemas = Util.getJavaMainSourceResources(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b34ba76ffad406a205bd110a10ecfa80a4d02a46"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMTM5NA==", "bodyText": "All this stuff should be in the plugin. These are conventions specific to our project. We should be able to easily reuse this task to validate something else. Right now that would be impossible do to these conventions being hard-coded into the task implementation.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407721394", "createdAt": "2020-04-13T21:06:34Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {\n+\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STARS = \"**\"; // checkstyle thinks this is an empty javadoc statement, so string concat instead\n+    private static final String JSON_SPEC_PATTERN_INCLUDE = DOUBLE_STARS + \"/rest-api-spec/api/\" + DOUBLE_STARS + \"/*.json\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b34ba76ffad406a205bd110a10ecfa80a4d02a46"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMjI0NA==", "bodyText": "Again, this should be in the plugin. We should be just add a setInputFiles(FileCollection files) that we pass exactly what we want to validate. Then the plugin can do all this source set stuff. Also the plugin should confirm these source sets exist (or apply the plugin that creates them) so things don't explode.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407722244", "createdAt": "2020-04-13T21:08:18Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {\n+\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STARS = \"**\"; // checkstyle thinks this is an empty javadoc statement, so string concat instead\n+    private static final String JSON_SPEC_PATTERN_INCLUDE = DOUBLE_STARS + \"/rest-api-spec/api/\" + DOUBLE_STARS + \"/*.json\";\n+    private static final String JSON_SPEC_PATTERN_EXCLUDE = DOUBLE_STARS + \"/_common.json\";\n+    private static final String JSON_SCHEMA_PATTERN = DOUBLE_STARS + \"/schema.json\";\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+\n+    @SkipWhenEmpty\n+    @InputFiles\n+    public FileTree getInputDir() {\n+        // if null results in in NO-SOURCE\n+        return Util.getJavaTestAndMainSourceResources(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b34ba76ffad406a205bd110a10ecfa80a4d02a46"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzMzNQ==", "bodyText": "I wonder if it's worth doing any kind of caching here, or if the schema stuff does this internally? We want to avoid parsing the schema over and over if possible.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407723335", "createdAt": "2020-04-13T21:10:27Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {\n+\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STARS = \"**\"; // checkstyle thinks this is an empty javadoc statement, so string concat instead\n+    private static final String JSON_SPEC_PATTERN_INCLUDE = DOUBLE_STARS + \"/rest-api-spec/api/\" + DOUBLE_STARS + \"/*.json\";\n+    private static final String JSON_SPEC_PATTERN_EXCLUDE = DOUBLE_STARS + \"/_common.json\";\n+    private static final String JSON_SCHEMA_PATTERN = DOUBLE_STARS + \"/schema.json\";\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+\n+    @SkipWhenEmpty\n+    @InputFiles\n+    public FileTree getInputDir() {\n+        // if null results in in NO-SOURCE\n+        return Util.getJavaTestAndMainSourceResources(\n+            getProject(),\n+            Util.filterByPatterns(\n+                getPatternSetFactory().create(),\n+                Collections.singletonList(JSON_SPEC_PATTERN_INCLUDE),\n+                Collections.singletonList(JSON_SPEC_PATTERN_EXCLUDE)\n+            )\n+        );\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @Inject\n+    protected Factory<PatternSet> getPatternSetFactory() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @TaskAction\n+    public void validate() throws IOException {\n+        // load schema\n+        JsonSchema jsonSchema;\n+        FileTree jsonSchemas = Util.getJavaMainSourceResources(\n+            getProject().findProject(SCHEMA_PROJECT),\n+            Util.filterByPatterns(getPatternSetFactory().create(), Collections.singletonList(JSON_SCHEMA_PATTERN), null)\n+        );\n+        if (jsonSchemas == null || jsonSchemas.getFiles().size() != 1) {\n+            throw new IllegalStateException(\n+                String.format(\n+                    \"Could not find the schema file from glob pattern [%s] and project [%s] for JSON spec validation\",\n+                    JSON_SCHEMA_PATTERN,\n+                    SCHEMA_PROJECT\n+                )\n+            );\n+        }\n+        File jsonSchemaOnDisk = jsonSchemas.iterator().next();\n+        getLogger().debug(\"JSON schema for REST spec: [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+        JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+        jsonSchema = factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b34ba76ffad406a205bd110a10ecfa80a4d02a46"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNDU2OA==", "bodyText": "Bonus points if we make this task incremental so we only revalidate changed files \ud83d\ude09. This is a prime candidate for that kind of thing because each file can be independently validated.\nhttps://docs.gradle.org/current/userguide/custom_tasks.html#incremental_tasks", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407724568", "createdAt": "2020-04-13T21:13:00Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {\n+\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STARS = \"**\"; // checkstyle thinks this is an empty javadoc statement, so string concat instead\n+    private static final String JSON_SPEC_PATTERN_INCLUDE = DOUBLE_STARS + \"/rest-api-spec/api/\" + DOUBLE_STARS + \"/*.json\";\n+    private static final String JSON_SPEC_PATTERN_EXCLUDE = DOUBLE_STARS + \"/_common.json\";\n+    private static final String JSON_SCHEMA_PATTERN = DOUBLE_STARS + \"/schema.json\";\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+\n+    @SkipWhenEmpty\n+    @InputFiles\n+    public FileTree getInputDir() {\n+        // if null results in in NO-SOURCE\n+        return Util.getJavaTestAndMainSourceResources(\n+            getProject(),\n+            Util.filterByPatterns(\n+                getPatternSetFactory().create(),\n+                Collections.singletonList(JSON_SPEC_PATTERN_INCLUDE),\n+                Collections.singletonList(JSON_SPEC_PATTERN_EXCLUDE)\n+            )\n+        );\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @Inject\n+    protected Factory<PatternSet> getPatternSetFactory() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @TaskAction\n+    public void validate() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b34ba76ffad406a205bd110a10ecfa80a4d02a46"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzcyNg==", "bodyText": "Let's avoid smashing the output of this task in an exception message. Instead let's follow the example of other core Gradle tasks which is to simply log the errors in the task using logger and then throw an exception message that says something like \"There were errors, refer to task output.\". We can (and should) include a summary in the exception (ex: \"Validation failed: 3 files contained 8 violations\"), but details should be in task output.\nFor example, here's a checkstyle error: https://gradle-enterprise.elastic.co/s/ixyvqw455k6m6/failure?openFailures=WzBd&openStackTraces=WzFd#top=0", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407727726", "createdAt": "2020-04-13T21:19:06Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {\n+\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STARS = \"**\"; // checkstyle thinks this is an empty javadoc statement, so string concat instead\n+    private static final String JSON_SPEC_PATTERN_INCLUDE = DOUBLE_STARS + \"/rest-api-spec/api/\" + DOUBLE_STARS + \"/*.json\";\n+    private static final String JSON_SPEC_PATTERN_EXCLUDE = DOUBLE_STARS + \"/_common.json\";\n+    private static final String JSON_SCHEMA_PATTERN = DOUBLE_STARS + \"/schema.json\";\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+\n+    @SkipWhenEmpty\n+    @InputFiles\n+    public FileTree getInputDir() {\n+        // if null results in in NO-SOURCE\n+        return Util.getJavaTestAndMainSourceResources(\n+            getProject(),\n+            Util.filterByPatterns(\n+                getPatternSetFactory().create(),\n+                Collections.singletonList(JSON_SPEC_PATTERN_INCLUDE),\n+                Collections.singletonList(JSON_SPEC_PATTERN_EXCLUDE)\n+            )\n+        );\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @Inject\n+    protected Factory<PatternSet> getPatternSetFactory() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @TaskAction\n+    public void validate() throws IOException {\n+        // load schema\n+        JsonSchema jsonSchema;\n+        FileTree jsonSchemas = Util.getJavaMainSourceResources(\n+            getProject().findProject(SCHEMA_PROJECT),\n+            Util.filterByPatterns(getPatternSetFactory().create(), Collections.singletonList(JSON_SCHEMA_PATTERN), null)\n+        );\n+        if (jsonSchemas == null || jsonSchemas.getFiles().size() != 1) {\n+            throw new IllegalStateException(\n+                String.format(\n+                    \"Could not find the schema file from glob pattern [%s] and project [%s] for JSON spec validation\",\n+                    JSON_SCHEMA_PATTERN,\n+                    SCHEMA_PROJECT\n+                )\n+            );\n+        }\n+        File jsonSchemaOnDisk = jsonSchemas.iterator().next();\n+        getLogger().debug(\"JSON schema for REST spec: [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+        JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+        jsonSchema = factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);\n+        // validate input files\n+        FileTree specs = getInputDir();\n+        Map<File, Set<ValidationMessage>> errors = new HashMap<>();\n+        for (File file : specs.getFiles()) {\n+            if (ignore.contains(file.getName())) {\n+                getLogger().info(\"Ignoring file [{}] due to configuration\", file.getName());\n+                continue;\n+            }\n+            // validate all files and hold on to errors for a complete report if there are failures\n+            getLogger().debug(\"Validating REST spec [{}]\", file.getName());\n+            Set<ValidationMessage> validationMessages = jsonSchema.validate(mapper.readTree(file));\n+            for (ValidationMessage validationMessage : validationMessages) {\n+                errors.computeIfAbsent(file, k -> new HashSet<>()).add(validationMessage);\n+            }\n+        }\n+        if (errors.isEmpty()) {\n+            Files.write(getSuccessMarker().toPath(), new byte[] {}, StandardOpenOption.CREATE);\n+        } else {\n+            // build output and throw exception\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Error validating REST specification.\");\n+            sb.append(System.lineSeparator());\n+            sb.append(String.format(\"Schema: %s\", jsonSchemaOnDisk));\n+            sb.append(System.lineSeparator());\n+            errors.forEach((file, error) -> {\n+                sb.append(System.lineSeparator());\n+                sb.append(String.format(\"File: %s\", file.getName()));\n+                sb.append(System.lineSeparator());\n+                sb.append(\"----------------------\");\n+                sb.append(System.lineSeparator());\n+                error.forEach(message -> {\n+                    sb.append(message);\n+                    sb.append(System.lineSeparator());\n+                });\n+            });\n+            throw new JsonSchemaException(sb.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b34ba76ffad406a205bd110a10ecfa80a4d02a46"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODg1MQ==", "bodyText": "I think the more idiomatic thing is to use Optional.empty() here.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407728851", "createdAt": "2020-04-13T21:21:30Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/util/Util.java", "diffHunk": "@@ -75,4 +84,91 @@ public static URI getBuildSrcCodeSource() {\n             throw new GradleException(\"Error determining build tools JAR location\", e);\n         }\n     }\n+\n+    public static Function<FileTree, FileTree> filterByPatterns(\n+        PatternSet patternSet,\n+        @Nullable List<String> includePatterns,\n+        @Nullable List<String> excludePatterns\n+    ) {\n+        return inFiles -> {\n+            if (inFiles != null && inFiles.isEmpty() == false) {\n+                if (includePatterns != null) {\n+                    patternSet.include(includePatterns);\n+                }\n+                if (excludePatterns != null) {\n+                    patternSet.exclude(excludePatterns);\n+                }\n+                return inFiles.getAsFileTree().matching(patternSet);\n+            } else {\n+                return null;\n+            }\n+        };\n+    }\n+\n+    /**\n+     * @param project The project to look for resources.\n+     * @param filter  Optional filter function to filter the returned resources\n+     * @return Returns the {@link FileTree} for main resources from Java projects. Returns null if no files exist.\n+     */\n+    @Nullable\n+    public static FileTree getJavaMainSourceResources(Project project, @Nullable Function<FileTree, FileTree> filter) {\n+        if (filter == null) {\n+            filter = Function.identity();\n+        }\n+        final Optional<FileTree> mainFileTree = getJavaMainSourceSet(project).map(SourceSet::getResources).map(FileTree::getAsFileTree);\n+        return filter.apply(mainFileTree.orElse(null));\n+    }\n+\n+    /**\n+     * @param project The project to look for resources.\n+     * @param filter  Optional filter function to filter the returned resources\n+     * @return Returns the {@link FileTree} for test resources from Java projects. Returns null if no files exist.\n+     */\n+    @Nullable\n+    public static FileTree getJavaTestSourceResources(Project project, @Nullable Function<FileTree, FileTree> filter) {\n+        if (filter == null) {\n+            filter = Function.identity();\n+        }\n+        final Optional<FileTree> testFileTree = getJavaTestSourceSet(project).map(SourceSet::getResources).map(FileTree::getAsFileTree);\n+        return filter.apply(testFileTree.orElse(null));\n+    }\n+\n+    /**\n+     * @param project The project to look for resources.\n+     * @param filter  Optional filter function to filter the returned resources\n+     * @return Returns the combined {@link FileTree} for test and main resources from Java projects. Returns null if no files exist.\n+     */\n+    @Nullable\n+    public static FileTree getJavaTestAndMainSourceResources(Project project, @Nullable Function<FileTree, FileTree> filter) {\n+        if (filter == null) {\n+            filter = Function.identity();\n+        }\n+        final Optional<FileTree> testFileTree = getJavaTestSourceSet(project).map(SourceSet::getResources).map(FileTree::getAsFileTree);\n+        final Optional<FileTree> mainFileTree = getJavaMainSourceSet(project).map(SourceSet::getResources).map(FileTree::getAsFileTree);\n+        if (testFileTree.isPresent() && mainFileTree.isPresent()) {\n+            return filter.apply(testFileTree.get().plus(mainFileTree.get()));\n+        } else {\n+            return filter.apply(testFileTree.orElse(mainFileTree.orElse(null)));\n+        }\n+    }\n+\n+    /**\n+     * @param project The project to look for test Java resources.\n+     * @return An Optional that contains the Java test SourceSet if it exists.\n+     */\n+    public static Optional<SourceSet> getJavaTestSourceSet(Project project) {\n+        return project.getConvention().findPlugin(JavaPluginConvention.class) == null\n+            ? Optional.ofNullable(null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b34ba76ffad406a205bd110a10ecfa80a4d02a46"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODk1Mw==", "bodyText": "Use Optional.empty().", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407728953", "createdAt": "2020-04-13T21:21:41Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/util/Util.java", "diffHunk": "@@ -75,4 +84,91 @@ public static URI getBuildSrcCodeSource() {\n             throw new GradleException(\"Error determining build tools JAR location\", e);\n         }\n     }\n+\n+    public static Function<FileTree, FileTree> filterByPatterns(\n+        PatternSet patternSet,\n+        @Nullable List<String> includePatterns,\n+        @Nullable List<String> excludePatterns\n+    ) {\n+        return inFiles -> {\n+            if (inFiles != null && inFiles.isEmpty() == false) {\n+                if (includePatterns != null) {\n+                    patternSet.include(includePatterns);\n+                }\n+                if (excludePatterns != null) {\n+                    patternSet.exclude(excludePatterns);\n+                }\n+                return inFiles.getAsFileTree().matching(patternSet);\n+            } else {\n+                return null;\n+            }\n+        };\n+    }\n+\n+    /**\n+     * @param project The project to look for resources.\n+     * @param filter  Optional filter function to filter the returned resources\n+     * @return Returns the {@link FileTree} for main resources from Java projects. Returns null if no files exist.\n+     */\n+    @Nullable\n+    public static FileTree getJavaMainSourceResources(Project project, @Nullable Function<FileTree, FileTree> filter) {\n+        if (filter == null) {\n+            filter = Function.identity();\n+        }\n+        final Optional<FileTree> mainFileTree = getJavaMainSourceSet(project).map(SourceSet::getResources).map(FileTree::getAsFileTree);\n+        return filter.apply(mainFileTree.orElse(null));\n+    }\n+\n+    /**\n+     * @param project The project to look for resources.\n+     * @param filter  Optional filter function to filter the returned resources\n+     * @return Returns the {@link FileTree} for test resources from Java projects. Returns null if no files exist.\n+     */\n+    @Nullable\n+    public static FileTree getJavaTestSourceResources(Project project, @Nullable Function<FileTree, FileTree> filter) {\n+        if (filter == null) {\n+            filter = Function.identity();\n+        }\n+        final Optional<FileTree> testFileTree = getJavaTestSourceSet(project).map(SourceSet::getResources).map(FileTree::getAsFileTree);\n+        return filter.apply(testFileTree.orElse(null));\n+    }\n+\n+    /**\n+     * @param project The project to look for resources.\n+     * @param filter  Optional filter function to filter the returned resources\n+     * @return Returns the combined {@link FileTree} for test and main resources from Java projects. Returns null if no files exist.\n+     */\n+    @Nullable\n+    public static FileTree getJavaTestAndMainSourceResources(Project project, @Nullable Function<FileTree, FileTree> filter) {\n+        if (filter == null) {\n+            filter = Function.identity();\n+        }\n+        final Optional<FileTree> testFileTree = getJavaTestSourceSet(project).map(SourceSet::getResources).map(FileTree::getAsFileTree);\n+        final Optional<FileTree> mainFileTree = getJavaMainSourceSet(project).map(SourceSet::getResources).map(FileTree::getAsFileTree);\n+        if (testFileTree.isPresent() && mainFileTree.isPresent()) {\n+            return filter.apply(testFileTree.get().plus(mainFileTree.get()));\n+        } else {\n+            return filter.apply(testFileTree.orElse(mainFileTree.orElse(null)));\n+        }\n+    }\n+\n+    /**\n+     * @param project The project to look for test Java resources.\n+     * @return An Optional that contains the Java test SourceSet if it exists.\n+     */\n+    public static Optional<SourceSet> getJavaTestSourceSet(Project project) {\n+        return project.getConvention().findPlugin(JavaPluginConvention.class) == null\n+            ? Optional.ofNullable(null)\n+            : Optional.ofNullable(GradleUtils.getJavaSourceSets(project).findByName(SourceSet.TEST_SOURCE_SET_NAME));\n+    }\n+\n+    /**\n+     * @param project The project to look for main Java resources.\n+     * @return An Optional that contains the Java main SourceSet if it exists.\n+     */\n+    public static Optional<SourceSet> getJavaMainSourceSet(Project project) {\n+        return project.getConvention().findPlugin(JavaPluginConvention.class) == null\n+            ? Optional.ofNullable(null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b34ba76ffad406a205bd110a10ecfa80a4d02a46"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMjQ5Mw==", "bodyText": "This is a bit of an awkward way of defining a filter. Instead of creating a function that takes a FileTree and returns another FileTree why not model the filter as an Action<? super PatternFilterable>? Then your methods that take this could just look like:\ngetJavaMainSourceResources(project, spec -> spec.include(**/foo/**))\n\nThis also avoids the need to create a PatternSet via PatternSetFactory which is technically an internal API.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407732493", "createdAt": "2020-04-13T21:29:06Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/util/Util.java", "diffHunk": "@@ -75,4 +84,91 @@ public static URI getBuildSrcCodeSource() {\n             throw new GradleException(\"Error determining build tools JAR location\", e);\n         }\n     }\n+\n+    public static Function<FileTree, FileTree> filterByPatterns(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b34ba76ffad406a205bd110a10ecfa80a4d02a46"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTA5Ng==", "bodyText": "Does this file ever get validated?", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407735096", "createdAt": "2020-04-13T21:34:33Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {\n+\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STARS = \"**\"; // checkstyle thinks this is an empty javadoc statement, so string concat instead\n+    private static final String JSON_SPEC_PATTERN_INCLUDE = DOUBLE_STARS + \"/rest-api-spec/api/\" + DOUBLE_STARS + \"/*.json\";\n+    private static final String JSON_SPEC_PATTERN_EXCLUDE = DOUBLE_STARS + \"/_common.json\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b34ba76ffad406a205bd110a10ecfa80a4d02a46"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTk3Ng==", "bodyText": "Also would alleviate the need for a bunch of null-checking logic on the filter.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407735976", "createdAt": "2020-04-13T21:36:31Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/util/Util.java", "diffHunk": "@@ -75,4 +84,91 @@ public static URI getBuildSrcCodeSource() {\n             throw new GradleException(\"Error determining build tools JAR location\", e);\n         }\n     }\n+\n+    public static Function<FileTree, FileTree> filterByPatterns(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMjQ5Mw=="}, "originalCommit": {"oid": "b34ba76ffad406a205bd110a10ecfa80a4d02a46"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b2fadc390e08611c44f7a1c53ba16e20f73a975", "author": {"user": {"login": "jakelandis", "name": "Jake Landis"}}, "url": "https://github.com/elastic/elasticsearch/commit/4b2fadc390e08611c44f7a1c53ba16e20f73a975", "committedDate": "2020-04-19T22:50:22Z", "message": "review updates (still missing report)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d89f406be2c56c8bab8f556753457a1bdf36edd", "author": {"user": {"login": "jakelandis", "name": "Jake Landis"}}, "url": "https://github.com/elastic/elasticsearch/commit/9d89f406be2c56c8bab8f556753457a1bdf36edd", "committedDate": "2020-04-19T22:50:23Z", "message": "checkstyle/spotless and new report"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c7e1a376b559353ad855354586362077d1dc9a8", "author": {"user": {"login": "jakelandis", "name": "Jake Landis"}}, "url": "https://github.com/elastic/elasticsearch/commit/6c7e1a376b559353ad855354586362077d1dc9a8", "committedDate": "2020-04-19T22:54:14Z", "message": "Merge remote-tracking branch 'upstream/master' into validate_rest_spec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86b8a77baf338551ffbcb33c144b3f72835903b6", "author": {"user": {"login": "jakelandis", "name": "Jake Landis"}}, "url": "https://github.com/elastic/elasticsearch/commit/86b8a77baf338551ffbcb33c144b3f72835903b6", "committedDate": "2020-04-19T22:56:42Z", "message": "minor wording changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0918c9a25c136c0b4af6bf1bf8df277ef63e4d50", "author": {"user": {"login": "jakelandis", "name": "Jake Landis"}}, "url": "https://github.com/elastic/elasticsearch/commit/0918c9a25c136c0b4af6bf1bf8df277ef63e4d50", "committedDate": "2020-04-19T23:13:20Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a25b26c569a3448a42634a6f281f9f45a6ae95a", "author": {"user": {"login": "jakelandis", "name": "Jake Landis"}}, "url": "https://github.com/elastic/elasticsearch/commit/6a25b26c569a3448a42634a6f281f9f45a6ae95a", "committedDate": "2020-04-19T23:19:35Z", "message": "add another ignore"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTY3MTcw", "url": "https://github.com/elastic/elasticsearch/pull/55117#pullrequestreview-396567170", "createdAt": "2020-04-20T15:32:05Z", "commit": {"oid": "6a25b26c569a3448a42634a6f281f9f45a6ae95a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTozMjowNVrOGIacZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTozMjowNVrOGIacZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ3NTA0Ng==", "bodyText": "oops... this isn't effective across multiple tasks.  Will remove this, or move out to the plugin.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411475046", "createdAt": "2020-04-20T15:32:05Z", "author": {"login": "jakelandis"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+    // no need to rebuild the JsonSchema multiple times per build\n+    private static ConcurrentHashMap<File, JsonSchema> cache = new ConcurrentHashMap<>(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a25b26c569a3448a42634a6f281f9f45a6ae95a"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e06e43456333730868a2a24a14c427d23796d054", "author": {"user": {"login": "jakelandis", "name": "Jake Landis"}}, "url": "https://github.com/elastic/elasticsearch/commit/e06e43456333730868a2a24a14c427d23796d054", "committedDate": "2020-04-20T19:48:16Z", "message": "remove unecessary 'cache'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6090fbafe059f95885918d9d6705abe663623c31", "author": {"user": {"login": "jakelandis", "name": "Jake Landis"}}, "url": "https://github.com/elastic/elasticsearch/commit/6090fbafe059f95885918d9d6705abe663623c31", "committedDate": "2020-04-20T19:54:58Z", "message": "use default task instead of precommit task"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NzI5NTYy", "url": "https://github.com/elastic/elasticsearch/pull/55117#pullrequestreview-396729562", "createdAt": "2020-04-20T19:00:43Z", "commit": {"oid": "6a25b26c569a3448a42634a6f281f9f45a6ae95a"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxOTowMDo0NFrOGIjJhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo1MTo0NFrOGInK_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYxNzY3MA==", "bodyText": "Let's remove static here. I realize there's some overhead in allocating these but the potential for weird memory leaks in the daemon is probalby not worth it. The Gradle daemon is long-lived and also caches classloaders. Static references can cause weird issues with leaking classloaders which can cause daemons to eventually OOM.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411617670", "createdAt": "2020-04-20T19:00:44Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a25b26c569a3448a42634a6f281f9f45a6ae95a"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyMDY4Ng==", "bodyText": "There's no concurrency that I can see here. We are simply validating each input file serially on the task execution thread. Also, we should probably use a map implementation that maintains insertion order like LinkedHashMap so that in cases with multiple errors the ordering makes sense (all errors for the same file in the same place in line order).", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411620686", "createdAt": "2020-04-20T19:05:54Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+    // no need to rebuild the JsonSchema multiple times per build\n+    private static ConcurrentHashMap<File, JsonSchema> cache = new ConcurrentHashMap<>(1);\n+\n+    @Incremental\n+    @InputFiles\n+    public FileTree getInputFiles() {\n+        return inputFiles;\n+    }\n+\n+    public void setInputFiles(FileTree inputFiles) {\n+        this.inputFiles = inputFiles;\n+    }\n+\n+    @InputFile\n+    public File getJsonSchema() {\n+        return jsonSchema;\n+    }\n+\n+    public void setJsonSchema(File jsonSchema) {\n+        this.jsonSchema = jsonSchema;\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @OutputFile\n+    public File getErrorReport() {\n+        return new File(getProject().getBuildDir(), \"reports/validateJson.txt\");\n+    }\n+\n+    @TaskAction\n+    public void validate(InputChanges inputChanges) throws IOException {\n+        File jsonSchemaOnDisk = getJsonSchema();\n+        getLogger().debug(\"JSON schema : [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        JsonSchema jsonSchema = cache.computeIfAbsent(getJsonSchema(), k -> {\n+            SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+            JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+            try {\n+                return factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        ConcurrentHashMap<File, Set<String>> errors = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a25b26c569a3448a42634a6f281f9f45a6ae95a"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyMTQ4Mw==", "bodyText": "Keep in mind here that fileChange could be a removed file. In which case we'd fail here as we'd try to validate a file that has been deleted. We should filter those out.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411621483", "createdAt": "2020-04-20T19:07:14Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+    // no need to rebuild the JsonSchema multiple times per build\n+    private static ConcurrentHashMap<File, JsonSchema> cache = new ConcurrentHashMap<>(1);\n+\n+    @Incremental\n+    @InputFiles\n+    public FileTree getInputFiles() {\n+        return inputFiles;\n+    }\n+\n+    public void setInputFiles(FileTree inputFiles) {\n+        this.inputFiles = inputFiles;\n+    }\n+\n+    @InputFile\n+    public File getJsonSchema() {\n+        return jsonSchema;\n+    }\n+\n+    public void setJsonSchema(File jsonSchema) {\n+        this.jsonSchema = jsonSchema;\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @OutputFile\n+    public File getErrorReport() {\n+        return new File(getProject().getBuildDir(), \"reports/validateJson.txt\");\n+    }\n+\n+    @TaskAction\n+    public void validate(InputChanges inputChanges) throws IOException {\n+        File jsonSchemaOnDisk = getJsonSchema();\n+        getLogger().debug(\"JSON schema : [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        JsonSchema jsonSchema = cache.computeIfAbsent(getJsonSchema(), k -> {\n+            SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+            JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+            try {\n+                return factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        ConcurrentHashMap<File, Set<String>> errors = new ConcurrentHashMap<>();\n+        // incrementally evaluate input files\n+        inputChanges.getFileChanges(getInputFiles()).forEach(fileChange -> {\n+            File file = fileChange.getFile();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a25b26c569a3448a42634a6f281f9f45a6ae95a"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyMzAyNA==", "bodyText": "I think we might be able to simplify things by just making this a FileCollection instead of a FileTree. There's no reason to keep a tree structure here as ignores are done of a file name basis and file paths are completely irrelevant for the purposes of validation.\nThis considerably simplifies things like adding input files from completely disparate directories. You can do this with file trees but it ends up creating a UnionFileTree which can have some funky behavior.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411623024", "createdAt": "2020-04-20T19:09:50Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+    // no need to rebuild the JsonSchema multiple times per build\n+    private static ConcurrentHashMap<File, JsonSchema> cache = new ConcurrentHashMap<>(1);\n+\n+    @Incremental\n+    @InputFiles\n+    public FileTree getInputFiles() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a25b26c569a3448a42634a6f281f9f45a6ae95a"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyNDMwNw==", "bodyText": "There's no need to use String.format here as the Logger.error() method supports formatting strings using {} as a placeholder.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411624307", "createdAt": "2020-04-20T19:12:04Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+    // no need to rebuild the JsonSchema multiple times per build\n+    private static ConcurrentHashMap<File, JsonSchema> cache = new ConcurrentHashMap<>(1);\n+\n+    @Incremental\n+    @InputFiles\n+    public FileTree getInputFiles() {\n+        return inputFiles;\n+    }\n+\n+    public void setInputFiles(FileTree inputFiles) {\n+        this.inputFiles = inputFiles;\n+    }\n+\n+    @InputFile\n+    public File getJsonSchema() {\n+        return jsonSchema;\n+    }\n+\n+    public void setJsonSchema(File jsonSchema) {\n+        this.jsonSchema = jsonSchema;\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @OutputFile\n+    public File getErrorReport() {\n+        return new File(getProject().getBuildDir(), \"reports/validateJson.txt\");\n+    }\n+\n+    @TaskAction\n+    public void validate(InputChanges inputChanges) throws IOException {\n+        File jsonSchemaOnDisk = getJsonSchema();\n+        getLogger().debug(\"JSON schema : [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        JsonSchema jsonSchema = cache.computeIfAbsent(getJsonSchema(), k -> {\n+            SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+            JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+            try {\n+                return factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        ConcurrentHashMap<File, Set<String>> errors = new ConcurrentHashMap<>();\n+        // incrementally evaluate input files\n+        inputChanges.getFileChanges(getInputFiles()).forEach(fileChange -> {\n+            File file = fileChange.getFile();\n+            if (ignore.contains(file.getName())) {\n+                getLogger().debug(\"Ignoring file [{}] due to configuration\", file.getName());\n+            } else if (file.isDirectory() == false) {\n+                // validate all files and hold on to errors for a complete report if there are failures\n+                getLogger().debug(\"Validating JSON [{}]\", file.getName());\n+                try {\n+                    Set<ValidationMessage> validationMessages = jsonSchema.validate(mapper.readTree(file));\n+                    maybeLogAndCollectError(validationMessages, errors, file);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+        });\n+\n+        if (errors.isEmpty()) {\n+            Files.write(getSuccessMarker().toPath(), new byte[] {}, StandardOpenOption.CREATE);\n+        } else {\n+            // build output and throw exception\n+            Files.writeString(getErrorReport().toPath(), String.format(\"Schema: %s\", jsonSchemaOnDisk), StandardOpenOption.CREATE);\n+            Files.writeString(\n+                getErrorReport().toPath(),\n+                System.lineSeparator() + \"----------Validation Errors-----------\" + System.lineSeparator(),\n+                StandardOpenOption.APPEND\n+            );\n+            Files.write(\n+                getErrorReport().toPath(),\n+                errors.values().stream().flatMap(Collection::stream).collect(Collectors.toList()),\n+                StandardOpenOption.APPEND\n+            );\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Error validating JSON. See the report at: \");\n+            sb.append(getErrorReport().toURI().toASCIIString());\n+            sb.append(System.lineSeparator());\n+            sb.append(\n+                String.format(\"JSON validation failed: %d files contained %d violations\", errors.keySet().size(), errors.values().size())\n+            );\n+            throw new JsonSchemaException(sb.toString());\n+        }\n+    }\n+\n+    private void maybeLogAndCollectError(Set<ValidationMessage> messages, ConcurrentHashMap<File, Set<String>> errors, File file) {\n+        for (ValidationMessage message : messages) {\n+            String error = String.format(\"[validate JSON][ERROR][%s][%s]\", file.getName(), message.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a25b26c569a3448a42634a6f281f9f45a6ae95a"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyNTM0OA==", "bodyText": "Same as above, let's use a set implementation that maintains ordering so we don't potentially print an error for line 50 before one on line 30 in the report.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411625348", "createdAt": "2020-04-20T19:13:45Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+    // no need to rebuild the JsonSchema multiple times per build\n+    private static ConcurrentHashMap<File, JsonSchema> cache = new ConcurrentHashMap<>(1);\n+\n+    @Incremental\n+    @InputFiles\n+    public FileTree getInputFiles() {\n+        return inputFiles;\n+    }\n+\n+    public void setInputFiles(FileTree inputFiles) {\n+        this.inputFiles = inputFiles;\n+    }\n+\n+    @InputFile\n+    public File getJsonSchema() {\n+        return jsonSchema;\n+    }\n+\n+    public void setJsonSchema(File jsonSchema) {\n+        this.jsonSchema = jsonSchema;\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @OutputFile\n+    public File getErrorReport() {\n+        return new File(getProject().getBuildDir(), \"reports/validateJson.txt\");\n+    }\n+\n+    @TaskAction\n+    public void validate(InputChanges inputChanges) throws IOException {\n+        File jsonSchemaOnDisk = getJsonSchema();\n+        getLogger().debug(\"JSON schema : [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        JsonSchema jsonSchema = cache.computeIfAbsent(getJsonSchema(), k -> {\n+            SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+            JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+            try {\n+                return factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        ConcurrentHashMap<File, Set<String>> errors = new ConcurrentHashMap<>();\n+        // incrementally evaluate input files\n+        inputChanges.getFileChanges(getInputFiles()).forEach(fileChange -> {\n+            File file = fileChange.getFile();\n+            if (ignore.contains(file.getName())) {\n+                getLogger().debug(\"Ignoring file [{}] due to configuration\", file.getName());\n+            } else if (file.isDirectory() == false) {\n+                // validate all files and hold on to errors for a complete report if there are failures\n+                getLogger().debug(\"Validating JSON [{}]\", file.getName());\n+                try {\n+                    Set<ValidationMessage> validationMessages = jsonSchema.validate(mapper.readTree(file));\n+                    maybeLogAndCollectError(validationMessages, errors, file);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+        });\n+\n+        if (errors.isEmpty()) {\n+            Files.write(getSuccessMarker().toPath(), new byte[] {}, StandardOpenOption.CREATE);\n+        } else {\n+            // build output and throw exception\n+            Files.writeString(getErrorReport().toPath(), String.format(\"Schema: %s\", jsonSchemaOnDisk), StandardOpenOption.CREATE);\n+            Files.writeString(\n+                getErrorReport().toPath(),\n+                System.lineSeparator() + \"----------Validation Errors-----------\" + System.lineSeparator(),\n+                StandardOpenOption.APPEND\n+            );\n+            Files.write(\n+                getErrorReport().toPath(),\n+                errors.values().stream().flatMap(Collection::stream).collect(Collectors.toList()),\n+                StandardOpenOption.APPEND\n+            );\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Error validating JSON. See the report at: \");\n+            sb.append(getErrorReport().toURI().toASCIIString());\n+            sb.append(System.lineSeparator());\n+            sb.append(\n+                String.format(\"JSON validation failed: %d files contained %d violations\", errors.keySet().size(), errors.values().size())\n+            );\n+            throw new JsonSchemaException(sb.toString());\n+        }\n+    }\n+\n+    private void maybeLogAndCollectError(Set<ValidationMessage> messages, ConcurrentHashMap<File, Set<String>> errors, File file) {\n+        for (ValidationMessage message : messages) {\n+            String error = String.format(\"[validate JSON][ERROR][%s][%s]\", file.getName(), message.toString());\n+            getLogger().error(error);\n+            try {\n+                errors.computeIfAbsent(file, k -> new HashSet<>())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a25b26c569a3448a42634a6f281f9f45a6ae95a"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyNjk4NQ==", "bodyText": "I feel like we should probably just create a single PrintWriter and do all this stuff in one go. Each call to Files.write* is going to have to open and then close a stream on that file. Let's just do this once.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411626985", "createdAt": "2020-04-20T19:16:34Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+    // no need to rebuild the JsonSchema multiple times per build\n+    private static ConcurrentHashMap<File, JsonSchema> cache = new ConcurrentHashMap<>(1);\n+\n+    @Incremental\n+    @InputFiles\n+    public FileTree getInputFiles() {\n+        return inputFiles;\n+    }\n+\n+    public void setInputFiles(FileTree inputFiles) {\n+        this.inputFiles = inputFiles;\n+    }\n+\n+    @InputFile\n+    public File getJsonSchema() {\n+        return jsonSchema;\n+    }\n+\n+    public void setJsonSchema(File jsonSchema) {\n+        this.jsonSchema = jsonSchema;\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @OutputFile\n+    public File getErrorReport() {\n+        return new File(getProject().getBuildDir(), \"reports/validateJson.txt\");\n+    }\n+\n+    @TaskAction\n+    public void validate(InputChanges inputChanges) throws IOException {\n+        File jsonSchemaOnDisk = getJsonSchema();\n+        getLogger().debug(\"JSON schema : [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        JsonSchema jsonSchema = cache.computeIfAbsent(getJsonSchema(), k -> {\n+            SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+            JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+            try {\n+                return factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        ConcurrentHashMap<File, Set<String>> errors = new ConcurrentHashMap<>();\n+        // incrementally evaluate input files\n+        inputChanges.getFileChanges(getInputFiles()).forEach(fileChange -> {\n+            File file = fileChange.getFile();\n+            if (ignore.contains(file.getName())) {\n+                getLogger().debug(\"Ignoring file [{}] due to configuration\", file.getName());\n+            } else if (file.isDirectory() == false) {\n+                // validate all files and hold on to errors for a complete report if there are failures\n+                getLogger().debug(\"Validating JSON [{}]\", file.getName());\n+                try {\n+                    Set<ValidationMessage> validationMessages = jsonSchema.validate(mapper.readTree(file));\n+                    maybeLogAndCollectError(validationMessages, errors, file);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+        });\n+\n+        if (errors.isEmpty()) {\n+            Files.write(getSuccessMarker().toPath(), new byte[] {}, StandardOpenOption.CREATE);\n+        } else {\n+            // build output and throw exception\n+            Files.writeString(getErrorReport().toPath(), String.format(\"Schema: %s\", jsonSchemaOnDisk), StandardOpenOption.CREATE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a25b26c569a3448a42634a6f281f9f45a6ae95a"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyODQxNA==", "bodyText": "Is it strictly necessary to resolve the canonical file path here? I mean, if folks are working in some kind linked workspace folder wouldn't it be friendlier to report that path instead of the resolved one?", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411628414", "createdAt": "2020-04-20T19:18:54Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+    // no need to rebuild the JsonSchema multiple times per build\n+    private static ConcurrentHashMap<File, JsonSchema> cache = new ConcurrentHashMap<>(1);\n+\n+    @Incremental\n+    @InputFiles\n+    public FileTree getInputFiles() {\n+        return inputFiles;\n+    }\n+\n+    public void setInputFiles(FileTree inputFiles) {\n+        this.inputFiles = inputFiles;\n+    }\n+\n+    @InputFile\n+    public File getJsonSchema() {\n+        return jsonSchema;\n+    }\n+\n+    public void setJsonSchema(File jsonSchema) {\n+        this.jsonSchema = jsonSchema;\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @OutputFile\n+    public File getErrorReport() {\n+        return new File(getProject().getBuildDir(), \"reports/validateJson.txt\");\n+    }\n+\n+    @TaskAction\n+    public void validate(InputChanges inputChanges) throws IOException {\n+        File jsonSchemaOnDisk = getJsonSchema();\n+        getLogger().debug(\"JSON schema : [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        JsonSchema jsonSchema = cache.computeIfAbsent(getJsonSchema(), k -> {\n+            SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+            JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+            try {\n+                return factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        ConcurrentHashMap<File, Set<String>> errors = new ConcurrentHashMap<>();\n+        // incrementally evaluate input files\n+        inputChanges.getFileChanges(getInputFiles()).forEach(fileChange -> {\n+            File file = fileChange.getFile();\n+            if (ignore.contains(file.getName())) {\n+                getLogger().debug(\"Ignoring file [{}] due to configuration\", file.getName());\n+            } else if (file.isDirectory() == false) {\n+                // validate all files and hold on to errors for a complete report if there are failures\n+                getLogger().debug(\"Validating JSON [{}]\", file.getName());\n+                try {\n+                    Set<ValidationMessage> validationMessages = jsonSchema.validate(mapper.readTree(file));\n+                    maybeLogAndCollectError(validationMessages, errors, file);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+        });\n+\n+        if (errors.isEmpty()) {\n+            Files.write(getSuccessMarker().toPath(), new byte[] {}, StandardOpenOption.CREATE);\n+        } else {\n+            // build output and throw exception\n+            Files.writeString(getErrorReport().toPath(), String.format(\"Schema: %s\", jsonSchemaOnDisk), StandardOpenOption.CREATE);\n+            Files.writeString(\n+                getErrorReport().toPath(),\n+                System.lineSeparator() + \"----------Validation Errors-----------\" + System.lineSeparator(),\n+                StandardOpenOption.APPEND\n+            );\n+            Files.write(\n+                getErrorReport().toPath(),\n+                errors.values().stream().flatMap(Collection::stream).collect(Collectors.toList()),\n+                StandardOpenOption.APPEND\n+            );\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Error validating JSON. See the report at: \");\n+            sb.append(getErrorReport().toURI().toASCIIString());\n+            sb.append(System.lineSeparator());\n+            sb.append(\n+                String.format(\"JSON validation failed: %d files contained %d violations\", errors.keySet().size(), errors.values().size())\n+            );\n+            throw new JsonSchemaException(sb.toString());\n+        }\n+    }\n+\n+    private void maybeLogAndCollectError(Set<ValidationMessage> messages, ConcurrentHashMap<File, Set<String>> errors, File file) {\n+        for (ValidationMessage message : messages) {\n+            String error = String.format(\"[validate JSON][ERROR][%s][%s]\", file.getName(), message.toString());\n+            getLogger().error(error);\n+            try {\n+                errors.computeIfAbsent(file, k -> new HashSet<>())\n+                    .add(String.format(\"%s: %s\", file.getCanonicalFile(), message.toString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a25b26c569a3448a42634a6f281f9f45a6ae95a"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MzEzNw==", "bodyText": "Firstly, project configuration is never done in parallel, so there's no need for the thread safety stuff here. Second, I think this is overly complex. Instead of all this nastiness to try and find the file, let's just go ahead and have the project configure its location. It's one file, and it's rarely if every going to move. Doing a bunch of work at configuraiton time to scan for this file seems unnecessary.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411683137", "createdAt": "2020-04-20T20:50:56Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecPlugin.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.provider.Provider;\n+\n+import java.io.File;\n+\n+public class ValidateRestSpecPlugin implements Plugin<Project> {\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STAR = \"**\"; // checkstyle thinks these are javadocs :(\n+    // no need to find this file multiple times\n+    private static volatile File jsonSchema;\n+\n+    @Override\n+    public void apply(Project project) {\n+        if (jsonSchema == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6090fbafe059f95885918d9d6705abe663623c31"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MzU4MQ==", "bodyText": "What's the reason to ignore these files? Do they fail validation? If so, shouldn't we fix the failures so it doesn't break the clients team?", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411683581", "createdAt": "2020-04-20T20:51:44Z", "author": {"login": "mark-vieira"}, "path": "x-pack/plugin/build.gradle", "diffHunk": "@@ -109,3 +110,15 @@ testClusters.integTest {\n   extraConfigFile nodeCert.name, nodeCert\n   extraConfigFile 'roles.yml', file('src/test/resources/roles.yml')\n }\n+\n+validateRestSpec {\n+  ignore 'searchable_snapshots.mount.json'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6090fbafe059f95885918d9d6705abe663623c31"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9dd8917d69a7e041f580ceff86f17d3c040e9b6", "author": {"user": {"login": "jakelandis", "name": "Jake Landis"}}, "url": "https://github.com/elastic/elasticsearch/commit/e9dd8917d69a7e041f580ceff86f17d3c040e9b6", "committedDate": "2020-04-20T22:10:36Z", "message": "review updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "323e4d047e239757254c0cfb2403a1e4f3760ce4", "author": {"user": {"login": "jakelandis", "name": "Jake Landis"}}, "url": "https://github.com/elastic/elasticsearch/commit/323e4d047e239757254c0cfb2403a1e4f3760ce4", "committedDate": "2020-04-20T22:25:03Z", "message": "remove unnecessary FileWriter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1768c6d21bd38ec6d3064b5d33ed69937c97fde2", "author": {"user": {"login": "jakelandis", "name": "Jake Landis"}}, "url": "https://github.com/elastic/elasticsearch/commit/1768c6d21bd38ec6d3064b5d33ed69937c97fde2", "committedDate": "2020-04-20T22:31:35Z", "message": "hard code schema location"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODYxMjU5", "url": "https://github.com/elastic/elasticsearch/pull/55117#pullrequestreview-396861259", "createdAt": "2020-04-20T22:38:33Z", "commit": {"oid": "1768c6d21bd38ec6d3064b5d33ed69937c97fde2"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjozODozM1rOGIqhxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo0MDoxOVrOGIqk9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczODU2Ng==", "bodyText": "nit: I think just writing this as f.getChangeType() != ChangeType.REMOVED is simpler yes? Does our stance on using == false in the codebase mean avoid != as well in cases where using .equals() is unnecessary?", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411738566", "createdAt": "2020-04-20T22:38:33Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.DefaultTask;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.ChangeType;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends DefaultTask {\n+\n+    private final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+\n+    @Incremental\n+    @InputFiles\n+    public FileCollection getInputFiles() {\n+        return inputFiles;\n+    }\n+\n+    public void setInputFiles(FileTree inputFiles) {\n+        this.inputFiles = inputFiles;\n+    }\n+\n+    @InputFile\n+    public File getJsonSchema() {\n+        return jsonSchema;\n+    }\n+\n+    public void setJsonSchema(File jsonSchema) {\n+        this.jsonSchema = jsonSchema;\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @OutputFile\n+    public File getReport() {\n+        return new File(getProject().getBuildDir(), \"reports/validateJson.txt\");\n+    }\n+\n+    @TaskAction\n+    public void validate(InputChanges inputChanges) throws IOException {\n+        File jsonSchemaOnDisk = getJsonSchema();\n+        getLogger().debug(\"JSON schema : [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+        JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+        JsonSchema jsonSchema = factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);\n+        Map<File, Set<String>> errors = new LinkedHashMap<>();\n+        // incrementally evaluate input files\n+        StreamSupport.stream(inputChanges.getFileChanges(getInputFiles()).spliterator(), false)\n+            .filter(f -> ChangeType.REMOVED.equals(f.getChangeType()) == false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1768c6d21bd38ec6d3064b5d33ed69937c97fde2"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczOTM4Mw==", "bodyText": "Setter should be FileCollection as well. Also the field should be updated.", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411739383", "createdAt": "2020-04-20T22:40:19Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.DefaultTask;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.ChangeType;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends DefaultTask {\n+\n+    private final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+\n+    @Incremental\n+    @InputFiles\n+    public FileCollection getInputFiles() {\n+        return inputFiles;\n+    }\n+\n+    public void setInputFiles(FileTree inputFiles) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1768c6d21bd38ec6d3064b5d33ed69937c97fde2"}, "originalPosition": 73}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b11efbd2b5decf6c8dd5e7548e9664b8ca9e981e", "author": {"user": {"login": "jakelandis", "name": "Jake Landis"}}, "url": "https://github.com/elastic/elasticsearch/commit/b11efbd2b5decf6c8dd5e7548e9664b8ca9e981e", "committedDate": "2020-04-20T22:51:35Z", "message": "review changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "143119134cb101dceed443494d1cc953339715aa", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/143119134cb101dceed443494d1cc953339715aa", "committedDate": "2020-04-21T20:12:18Z", "message": "Merge branch 'master' into validate_rest_spec"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3518, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}