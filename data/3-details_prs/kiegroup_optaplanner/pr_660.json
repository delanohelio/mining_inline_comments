{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1Nzk1NTkz", "number": 660, "title": "PLANNER-1615 ifExists() for UniStream", "bodyText": "This is a PoC of the ifExists() implementation. If accepted, I will add ifNotExists() similarly and move on to bi/tri/quad.", "createdAt": "2020-01-22T11:10:23Z", "url": "https://github.com/kiegroup/optaplanner/pull/660", "merged": true, "mergeCommit": {"oid": "35a262af37f04fd82ed739db8c53a7f0d4d03829"}, "closed": true, "closedAt": "2020-01-24T09:11:34Z", "author": {"login": "triceo"}, "timelineItems": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb8zxeZgH2gAyMzY1Nzk1NTkzOjU0YTg5YjJmMjcwNTA2ZGE5YjY0ODYwNTc5NTdhMDllMmE2ODZkYjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb9bGVgAH2gAyMzY1Nzk1NTkzOjJkM2E3ZjY2YWNmZjNmODk5MmY0NjYxZjU4YzRiODY1MDNmNTU3NTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "54a89b2f270506da9b6486057957a09e2a686db7", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/54a89b2f270506da9b6486057957a09e2a686db7", "committedDate": "2020-01-22T11:09:35Z", "message": "Add filtering bi joiner"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b2be44cbc5626e36c8ec559547645765530791d", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/7b2be44cbc5626e36c8ec559547645765530791d", "committedDate": "2020-01-22T12:08:07Z", "message": "Add the API"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96b193d6cba9bf5906aae34211a6e711a5f077b1", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/96b193d6cba9bf5906aae34211a6e711a5f077b1", "committedDate": "2020-01-22T13:53:07Z", "message": "Implement UniCondition support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e216f1fd2fe523c2e6fbd91717d51da4acfe8d3e", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/e216f1fd2fe523c2e6fbd91717d51da4acfe8d3e", "committedDate": "2020-01-22T15:32:43Z", "message": "Make the rule structure cleaner"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da0b31ccf0636889493522c5e662e1481297f67f", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/da0b31ccf0636889493522c5e662e1481297f67f", "committedDate": "2020-01-22T16:56:44Z", "message": "Finalize the PoC"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NzU4NjIw", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-346758620", "createdAt": "2020-01-22T17:12:25Z", "commit": {"oid": "da0b31ccf0636889493522c5e662e1481297f67f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNzoxMjoyNlrOFgkIyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNzoxMjoyNlrOFgkIyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDgyNQ==", "bodyText": "Suggested solution: add a default ifExists(Class<B> otherClass, BiJoiner<A,B>... joiners); that callsifExists(Class otherClass, List joiners)`\ndefault <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n    ifExists(otherClass, Arrays.asList(joiners));\n}\n\n<B>  UniConstraintStream<A> ifExists(Class<B> otherClass, List<BiJoiner<A, B>> joiners);", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369690825", "createdAt": "2020-01-22T17:12:26Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -218,6 +218,88 @@\n         return joined.filter(resultingFilter);\n     }\n \n+    // ************************************************************************\n+    // If Exists\n+    // ************************************************************************\n+\n+    /**\n+     * Create a new {@link UniConstraintStream} for every A, if B exists.\n+     * @param otherClass never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where a B exists\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass) {\n+        return ifExists(otherClass, new NoneBiJoiner<>());\n+    }\n+\n+    /**\n+     * Create a new {@link UniConstraintStream} for every A where B exists for which the {@link BiJoiner} is true\n+     * (for the properties it extracts from both facts).\n+     * <p>\n+     * This method has overloaded methods with multiple {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where B exists for which the {@link BiJoiner} is true\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B> joiner) {\n+        return ifExists(otherClass, new BiJoiner[] { joiner });\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where B exists for which all the {@link BiJoiner}s are true\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2) {\n+        return ifExists(otherClass, new BiJoiner[] {joiner1, joiner2});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where B exists for which all the {@link BiJoiner}s are true\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2,\n+            BiJoiner<A, B> joiner3) {\n+        return ifExists(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param joiner4 never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where B exists for which all the {@link BiJoiner}s are true\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2,\n+            BiJoiner<A, B> joiner3, BiJoiner<A, B> joiner4) {\n+        return ifExists(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3, joiner4});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, BiJoiner)}.\n+     * <p>\n+     * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n+     * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n+     * Therefore, there are overloaded methods with up to 4 {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiners never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where B exists for which all the {@link BiJoiner}s are true\n+     */\n+    <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B>... joiners);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da0b31ccf0636889493522c5e662e1481297f67f"}, "originalPosition": 112}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebc17999f69bee8cf60d40305f54dc10f4dd3313", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/ebc17999f69bee8cf60d40305f54dc10f4dd3313", "committedDate": "2020-01-22T18:07:50Z", "message": "Finalize the PoC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd40b48f6c7f95fa4486c3d9aa3ca4eaa07259d6", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/fd40b48f6c7f95fa4486c3d9aa3ca4eaa07259d6", "committedDate": "2020-01-22T20:50:55Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db919f28fc18ce0d7f3f8cf59e19e1f5151d6591", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/db919f28fc18ce0d7f3f8cf59e19e1f5151d6591", "committedDate": "2020-01-22T21:17:13Z", "message": "Fix Revapi"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "committedDate": "2020-01-22T21:23:41Z", "message": "Actually fix Revapi"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTEzNzMx", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347113731", "createdAt": "2020-01-23T08:07:34Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODowNzozNFrOFg1gzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODowNzozNFrOFg1gzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3NTUwMA==", "bodyText": "This is handy! I've had need of it a few times, but never thought about this simple solution.", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369975500", "createdAt": "2020-01-23T08:07:34Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -41,6 +44,10 @@\n     // BiJoiner\n     // ************************************************************************\n \n+    public static <A> BiJoiner<A, A> equal() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTE1MjEw", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347115210", "createdAt": "2020-01-23T08:11:11Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODoxMToxMVrOFg1lgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODoxMToxMVrOFg1lgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3NjcwNQ==", "bodyText": "Will notEqual be indexed?\nIf it's not indexed and therefore syntactic sugar for filtering(), there must be fail-fast if any indexed joiner is behind it (so only notEquals and filtering() can come after it).\nIf it is indexed, it could be slower is some cases. Should the user be able to choose between indexed vs non-indexed non-equality? Would that choose be using notEquals() vs filtering(a!=b)?", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369976705", "createdAt": "2020-01-23T08:11:11Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -50,6 +57,19 @@\n         return new SingleBiJoiner<>(leftMapping, JoinerType.EQUAL, rightMapping);\n     }\n \n+    public static <A> BiJoiner<A, A> notEqual() {\n+        return notEqual(Function.identity());\n+    }\n+\n+    public static <A, Property_> BiJoiner<A, A> notEqual(Function<A, Property_> mapping) {\n+        return notEqual(mapping, mapping);\n+    }\n+\n+    public static <A, B, Property_> BiJoiner<A, B> notEqual(Function<A, Property_> leftMapping,\n+            Function <B, Property_> rightMapping) {\n+        return new SingleBiJoiner<>(leftMapping, JoinerType.NOT_EQUAL, rightMapping);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTE3MDk4", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347117098", "createdAt": "2020-01-23T08:15:18Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODoxNToxOVrOFg1rAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODoxNToxOVrOFg1rAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3ODExMw==", "bodyText": "Similar to the javadoc of that filter() method, this javadoc should mention the lack of indexing.", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369978113", "createdAt": "2020-01-23T08:15:19Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -89,6 +109,18 @@\n         return new SingleBiJoiner<>(leftMapping, JoinerType.GREATER_THAN_OR_EQUAL, rightMapping);\n     }\n \n+    /**\n+     * Applies a filter to the joined tuple, with the semantics of {@link BiConstraintStream#filter(BiPredicate)}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTE3MjY0", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347117264", "createdAt": "2020-01-23T08:15:43Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODoxNTo0M1rOFg1reg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODoxNTo0M1rOFg1reg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3ODIzNA==", "bodyText": "always start with \"never null\" or \"sometimes null\". (in this case never null)", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369978234", "createdAt": "2020-01-23T08:15:43Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -89,6 +109,18 @@\n         return new SingleBiJoiner<>(leftMapping, JoinerType.GREATER_THAN_OR_EQUAL, rightMapping);\n     }\n \n+    /**\n+     * Applies a filter to the joined tuple, with the semantics of {@link BiConstraintStream#filter(BiPredicate)}.\n+     *\n+     * @param filter filter to apply", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTE3Mzc2", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347117376", "createdAt": "2020-01-23T08:15:57Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODoxNTo1N1rOFg1r1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODoxNTo1N1rOFg1r1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3ODMyNw==", "bodyText": "never null or sometimes null?", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369978327", "createdAt": "2020-01-23T08:15:57Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -89,6 +109,18 @@\n         return new SingleBiJoiner<>(leftMapping, JoinerType.GREATER_THAN_OR_EQUAL, rightMapping);\n     }\n \n+    /**\n+     * Applies a filter to the joined tuple, with the semantics of {@link BiConstraintStream#filter(BiPredicate)}.\n+     *\n+     * @param filter filter to apply\n+     * @param <A> type of the first fact in the tuple\n+     * @param <B> type of the second fact in the tuple\n+     * @return the joiner", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTIwMzcx", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347120371", "createdAt": "2020-01-23T08:22:29Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODoyMjoyOVrOFg10oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODoyMjoyOVrOFg10oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MDU3Ng==", "bodyText": "There is a join(Class<B>, joiners) and a join(Uni<B>, joiners).\nDo both support filtering() joiners now? Isn't this new code below here duplicated between them?\nIt feels to me like we want to extract these new lines below into a separate non-public method if possible.", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369980576", "createdAt": "2020-01-23T08:22:29Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTIwNjQ4", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347120648", "createdAt": "2020-01-23T08:23:02Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODoyMzowMlrOFg11gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODoyMzowMlrOFg11gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MDgwMg==", "bodyText": "\"Only found indexing joiners.\" is not a sentence, don't end with \".\"", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369980802", "createdAt": "2020-01-23T08:23:02Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                        + joiners[indexOfFirstFilter] + \").\");\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTIzODQ0", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347123844", "createdAt": "2020-01-23T08:29:34Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODoyOTozNVrOFg1_5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODoyOTozNVrOFg1_5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MzQ2MQ==", "bodyText": "For readability I'd turn these if's order and avoid the boolean hasAFilter:\nif (indexOfFirstFilter >= 0) {\n      if (joiner instanceof FilteringBiJoiner) {\n        throw ...\n      }\n} else if (joiner instanceof FilteringBiJoiner) {\n    indexOfFirstFilter = i;\n}\n\nMost of OptaPlanner's code has the style to first check the fail fasts, before doing the code. I've found this is more readable, because when reading you can skip the fail-fasts, reducing the lines to grok (fail-fast's are usually easy to recognize based on their \"throw\" keyword).", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369983461", "createdAt": "2020-01-23T08:29:35Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                        + joiners[indexOfFirstFilter] + \").\");\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTI1NjMz", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347125633", "createdAt": "2020-01-23T08:33:18Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODozMzoxOVrOFg2Fzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODozMzoxOVrOFg2Fzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4NDk3NQ==", "bodyText": "Don't create this \"always true\" predicate:\n\nIf there is no filtering, don't call filter().\nIf there is only 1 filter, let's say Foo::isReady, don't create a wrapper predicate of an always true predicate combined with foo.isReady(), just use `Foo::isReady``directly.\nSame reasoning for 2 filters (don't make it 3)\n...", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369984975", "createdAt": "2020-01-23T08:33:19Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                        + joiners[indexOfFirstFilter] + \").\");\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.\n+            return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        }\n+        // Assemble the join stream.\n+        BiConstraintStream<A, B> joined = indexOfFirstFilter == 0 ?\n+                join(otherClass) :\n+                join(otherClass, Arrays.copyOf(joiners, indexOfFirstFilter));\n+        // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.\n+        BiPredicate<A, B> resultingFilter = (a, b) -> true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTM1MjE0", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347135214", "createdAt": "2020-01-23T08:51:31Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODo1MTozMlrOFg2jPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODo1MTozMlrOFg2jPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk5MjUwOQ==", "bodyText": "join(Class) and join(Class, joiner) are very commonly used, so they don't use \"As defined by\" in the javadocs (the extra click might have some people not read it). They are an exception, because using \"as defined by\" reduces maintenance.\nI'd argue that \"joinOther(Class)\" can use \"As defined by join(Class)\" and then something like \"With the additional joiner than they are not equal\" (but better written).\nSame for \"joinOther(Class, Joiner)\" => \"As defined by join(Class, Joiner) with the additional joiner than they are not equal\"\nBut indeed for joinOther(Class, Joiner, Joiner) and more, I 'd keep using \"As defined by joinOther(Class, Joiner, Joiner)\" (so no need of \"with the additional ...\" because it references joinOther, not join).\nMotivation: users that use \"joinOther\" are likely already to know \"join\", so it's even better for them (= quicker to understand) if we say \"whatever you already know from join() plus they are not equal\"\nWdyt?", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369992509", "createdAt": "2020-01-23T08:51:32Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                        + joiners[indexOfFirstFilter] + \").\");\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.\n+            return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        }\n+        // Assemble the join stream.\n+        BiConstraintStream<A, B> joined = indexOfFirstFilter == 0 ?\n+                join(otherClass) :\n+                join(otherClass, Arrays.copyOf(joiners, indexOfFirstFilter));\n+        // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.\n+        BiPredicate<A, B> resultingFilter = (a, b) -> true;\n+        for (int i = indexOfFirstFilter; i < joinerCount; i++) {\n+            FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiners[i];\n+            resultingFilter = resultingFilter.and(filteringJoiner.getFilter());\n+        }\n+        return joined.filter(resultingFilter);\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every two different A.\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @return a stream that matches every combination of A and a different A\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream) {\n+        return join(otherStream, Joiners.notEqual());\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 126}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTM3NzE2", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347137716", "createdAt": "2020-01-23T08:56:03Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODo1NjowM1rOFg2q8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODo1NjowM1rOFg2q8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk5NDQ4Mg==", "bodyText": "If nonEquals is indexed, does this merge make sure that if we do:\njoinOther(Foo.class, equal(getType), filtering(a, b -> a.getAge * b.getAge == 42))\nit is syntactic sugar for:\njoin(Foo.class, equal(getType), notEqual(), filtering(a, b -> a.getAge * b.getAge == 42))\nSo the first joiner remained the first joiner, but the second joiner became third joiner, because it's the first non-indexed joiner.", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369994482", "createdAt": "2020-01-23T08:56:03Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                        + joiners[indexOfFirstFilter] + \").\");\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.\n+            return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        }\n+        // Assemble the join stream.\n+        BiConstraintStream<A, B> joined = indexOfFirstFilter == 0 ?\n+                join(otherClass) :\n+                join(otherClass, Arrays.copyOf(joiners, indexOfFirstFilter));\n+        // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.\n+        BiPredicate<A, B> resultingFilter = (a, b) -> true;\n+        for (int i = indexOfFirstFilter; i < joinerCount; i++) {\n+            FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiners[i];\n+            resultingFilter = resultingFilter.and(filteringJoiner.getFilter());\n+        }\n+        return joined.filter(resultingFilter);\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every two different A.\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @return a stream that matches every combination of A and a different A\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream) {\n+        return join(otherStream, Joiners.notEqual());\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @param joiner never null\n+     * @return a stream that matches every combination of A and a different A for which the {@link BiJoiner} is true\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream, BiJoiner<A, A> joiner) {\n+        if (joiner instanceof NoneBiJoiner) {\n+            return join(otherStream, Joiners.notEqual());\n+        } else {\n+            return join(otherStream, AbstractBiJoiner.merge(Joiners.notEqual(), joiner));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 135}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTM4ODI5", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347138829", "createdAt": "2020-01-23T08:58:03Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODo1ODowNFrOFg2uVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODo1ODowNFrOFg2uVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk5NTM1MA==", "bodyText": "The order of joiners gets changed here:\njoinOther(Foo.class, x, y z) should be join(Foo.class, x, y, z, notEquals())\nThat's currently not the case.", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369995350", "createdAt": "2020-01-23T08:58:04Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                        + joiners[indexOfFirstFilter] + \").\");\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.\n+            return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        }\n+        // Assemble the join stream.\n+        BiConstraintStream<A, B> joined = indexOfFirstFilter == 0 ?\n+                join(otherClass) :\n+                join(otherClass, Arrays.copyOf(joiners, indexOfFirstFilter));\n+        // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.\n+        BiPredicate<A, B> resultingFilter = (a, b) -> true;\n+        for (int i = indexOfFirstFilter; i < joinerCount; i++) {\n+            FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiners[i];\n+            resultingFilter = resultingFilter.and(filteringJoiner.getFilter());\n+        }\n+        return joined.filter(resultingFilter);\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every two different A.\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @return a stream that matches every combination of A and a different A\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream) {\n+        return join(otherStream, Joiners.notEqual());\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @param joiner never null\n+     * @return a stream that matches every combination of A and a different A for which the {@link BiJoiner} is true\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream, BiJoiner<A, A> joiner) {\n+        if (joiner instanceof NoneBiJoiner) {\n+            return join(otherStream, Joiners.notEqual());\n+        } else {\n+            return join(otherStream, AbstractBiJoiner.merge(Joiners.notEqual(), joiner));\n+        }\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: {@link BiConstraintStream#filter(BiPredicate) Filtering} this is slower and less scalable\n+     * than a {@link #join(Class, BiJoiner)},\n+     * because it doesn't apply hashing and/or indexing on the properties,\n+     * so it creates and checks every combination of A and B.\n+     * <p>\n+     * This method is syntactic sugar for {@link #joinOther(UniConstraintStream)}.\n+     * @param otherClass never null\n+     * @return a stream that matches every combination of A and a different A\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass) {\n+        return join(otherClass, Joiners.notEqual());\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which thefor which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #join(Class) join}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * <p>\n+     * This method is syntactic sugar for {@link #join(UniConstraintStream, BiJoiner)}.\n+     * <p>\n+     * This method has overloaded methods with multiple {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @return a stream that matches every combination of A and a different A for which all the {@link BiJoiner joiner}\n+     * is true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner) {\n+        if (joiner instanceof FilteringBiJoiner) {\n+            FilteringBiJoiner<A, A> filteringJoiner = (FilteringBiJoiner<A, A>) joiner;\n+            return joinOther(otherClass)\n+                    .filter(filteringJoiner.getFilter());\n+        } else {\n+            return joinOther(getConstraintFactory().from(otherClass), joiner);\n+        }\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2,\n+            BiJoiner<A, A> joiner3) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param joiner4 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2,\n+            BiJoiner<A, A> joiner3, BiJoiner<A, A> joiner4) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3, joiner4});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * <p>\n+     * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n+     * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n+     * Therefore, there are overloaded methods with up to 4 {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiners never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A>... joiners) {\n+        BiJoiner<A, A> otherness = Joiners.notEqual();\n+        BiJoiner[] allJoiners = Stream.concat(Stream.of(otherness), Arrays.stream(joiners))\n+                .toArray(BiJoiner[]::new);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 238}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTQxOTg2", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347141986", "createdAt": "2020-01-23T09:03:58Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOTowMzo1OFrOFg233Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOTowMzo1OFrOFg233Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk5Nzc4OQ==", "bodyText": "Is this method ever going to be useful?\nWhat is the specification? If we have A1, A2, A3, ..., A100 they will match (= survive) if in these cases:\n\nthere is a B1\nthere is a B1, B2\nthere is a B1, B2, ..., 100\n\nbut not if\n\nthere not a single B.\n\nTheory: \"Nobody's every going to need this method.\" When in doubt, leave it out. Let the users tell us that they need and we 'll add it. Or let us feel the need for it in an example and let's then add it. But meanwhile, let's leave it out. Wydt?", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369997789", "createdAt": "2020-01-23T09:03:58Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                        + joiners[indexOfFirstFilter] + \").\");\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.\n+            return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        }\n+        // Assemble the join stream.\n+        BiConstraintStream<A, B> joined = indexOfFirstFilter == 0 ?\n+                join(otherClass) :\n+                join(otherClass, Arrays.copyOf(joiners, indexOfFirstFilter));\n+        // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.\n+        BiPredicate<A, B> resultingFilter = (a, b) -> true;\n+        for (int i = indexOfFirstFilter; i < joinerCount; i++) {\n+            FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiners[i];\n+            resultingFilter = resultingFilter.and(filteringJoiner.getFilter());\n+        }\n+        return joined.filter(resultingFilter);\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every two different A.\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @return a stream that matches every combination of A and a different A\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream) {\n+        return join(otherStream, Joiners.notEqual());\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @param joiner never null\n+     * @return a stream that matches every combination of A and a different A for which the {@link BiJoiner} is true\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream, BiJoiner<A, A> joiner) {\n+        if (joiner instanceof NoneBiJoiner) {\n+            return join(otherStream, Joiners.notEqual());\n+        } else {\n+            return join(otherStream, AbstractBiJoiner.merge(Joiners.notEqual(), joiner));\n+        }\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: {@link BiConstraintStream#filter(BiPredicate) Filtering} this is slower and less scalable\n+     * than a {@link #join(Class, BiJoiner)},\n+     * because it doesn't apply hashing and/or indexing on the properties,\n+     * so it creates and checks every combination of A and B.\n+     * <p>\n+     * This method is syntactic sugar for {@link #joinOther(UniConstraintStream)}.\n+     * @param otherClass never null\n+     * @return a stream that matches every combination of A and a different A\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass) {\n+        return join(otherClass, Joiners.notEqual());\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which thefor which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #join(Class) join}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * <p>\n+     * This method is syntactic sugar for {@link #join(UniConstraintStream, BiJoiner)}.\n+     * <p>\n+     * This method has overloaded methods with multiple {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @return a stream that matches every combination of A and a different A for which all the {@link BiJoiner joiner}\n+     * is true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner) {\n+        if (joiner instanceof FilteringBiJoiner) {\n+            FilteringBiJoiner<A, A> filteringJoiner = (FilteringBiJoiner<A, A>) joiner;\n+            return joinOther(otherClass)\n+                    .filter(filteringJoiner.getFilter());\n+        } else {\n+            return joinOther(getConstraintFactory().from(otherClass), joiner);\n+        }\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2,\n+            BiJoiner<A, A> joiner3) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param joiner4 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2,\n+            BiJoiner<A, A> joiner3, BiJoiner<A, A> joiner4) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3, joiner4});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * <p>\n+     * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n+     * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n+     * Therefore, there are overloaded methods with up to 4 {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiners never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A>... joiners) {\n+        BiJoiner<A, A> otherness = Joiners.notEqual();\n+        BiJoiner[] allJoiners = Stream.concat(Stream.of(otherness), Arrays.stream(joiners))\n+                .toArray(BiJoiner[]::new);\n+        return join(otherClass, allJoiners);\n+    }\n+\n+    // ************************************************************************\n+    // If Exists\n+    // ************************************************************************\n+\n+    /**\n+     * Create a new {@link UniConstraintStream} for every A, if B exists.\n+     * @param otherClass never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where a B exists\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 252}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTQ4NjQ2", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347148646", "createdAt": "2020-01-23T09:15:30Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOToxNTozMFrOFg3L7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOToxNTozMFrOFg3L7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwMjkyNw==", "bodyText": "Start with \"never null\"? so \"@return never null, a stream that ...\" I see the join() javadocs fail to do that too, they should.", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370002927", "createdAt": "2020-01-23T09:15:30Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                        + joiners[indexOfFirstFilter] + \").\");\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.\n+            return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        }\n+        // Assemble the join stream.\n+        BiConstraintStream<A, B> joined = indexOfFirstFilter == 0 ?\n+                join(otherClass) :\n+                join(otherClass, Arrays.copyOf(joiners, indexOfFirstFilter));\n+        // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.\n+        BiPredicate<A, B> resultingFilter = (a, b) -> true;\n+        for (int i = indexOfFirstFilter; i < joinerCount; i++) {\n+            FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiners[i];\n+            resultingFilter = resultingFilter.and(filteringJoiner.getFilter());\n+        }\n+        return joined.filter(resultingFilter);\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every two different A.\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @return a stream that matches every combination of A and a different A\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream) {\n+        return join(otherStream, Joiners.notEqual());\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @param joiner never null\n+     * @return a stream that matches every combination of A and a different A for which the {@link BiJoiner} is true\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream, BiJoiner<A, A> joiner) {\n+        if (joiner instanceof NoneBiJoiner) {\n+            return join(otherStream, Joiners.notEqual());\n+        } else {\n+            return join(otherStream, AbstractBiJoiner.merge(Joiners.notEqual(), joiner));\n+        }\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: {@link BiConstraintStream#filter(BiPredicate) Filtering} this is slower and less scalable\n+     * than a {@link #join(Class, BiJoiner)},\n+     * because it doesn't apply hashing and/or indexing on the properties,\n+     * so it creates and checks every combination of A and B.\n+     * <p>\n+     * This method is syntactic sugar for {@link #joinOther(UniConstraintStream)}.\n+     * @param otherClass never null\n+     * @return a stream that matches every combination of A and a different A\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass) {\n+        return join(otherClass, Joiners.notEqual());\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which thefor which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #join(Class) join}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * <p>\n+     * This method is syntactic sugar for {@link #join(UniConstraintStream, BiJoiner)}.\n+     * <p>\n+     * This method has overloaded methods with multiple {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @return a stream that matches every combination of A and a different A for which all the {@link BiJoiner joiner}\n+     * is true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner) {\n+        if (joiner instanceof FilteringBiJoiner) {\n+            FilteringBiJoiner<A, A> filteringJoiner = (FilteringBiJoiner<A, A>) joiner;\n+            return joinOther(otherClass)\n+                    .filter(filteringJoiner.getFilter());\n+        } else {\n+            return joinOther(getConstraintFactory().from(otherClass), joiner);\n+        }\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2,\n+            BiJoiner<A, A> joiner3) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param joiner4 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2,\n+            BiJoiner<A, A> joiner3, BiJoiner<A, A> joiner4) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3, joiner4});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * <p>\n+     * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n+     * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n+     * Therefore, there are overloaded methods with up to 4 {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiners never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A>... joiners) {\n+        BiJoiner<A, A> otherness = Joiners.notEqual();\n+        BiJoiner[] allJoiners = Stream.concat(Stream.of(otherness), Arrays.stream(joiners))\n+                .toArray(BiJoiner[]::new);\n+        return join(otherClass, allJoiners);\n+    }\n+\n+    // ************************************************************************\n+    // If Exists\n+    // ************************************************************************\n+\n+    /**\n+     * Create a new {@link UniConstraintStream} for every A, if B exists.\n+     * @param otherClass never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where a B exists\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass) {\n+        return ifExists(otherClass, new NoneBiJoiner<>());\n+    }\n+\n+    /**\n+     * Create a new {@link UniConstraintStream} for every A where B exists for which the {@link BiJoiner} is true\n+     * (for the properties it extracts from both facts).\n+     * <p>\n+     * This method has overloaded methods with multiple {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where B exists for which the {@link BiJoiner} is true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 264}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTU1NTgy", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347155582", "createdAt": "2020-01-23T09:27:10Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOToyNzoxMFrOFg3hsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOToyNzoxMFrOFg3hsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwODQ5Nw==", "bodyText": "Who's responsible for creaming off the FilteringBiJoiner? Is it UniConstraintStream or the Drools/BavetAbstractUniConstraintStream? currently I see code doing this in both the Uni as the BavetUni (and probably the DroolsUni too).\nCan we extra some of this into seperate method?", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370008497", "createdAt": "2020-01-23T09:27:10Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/uni/BavetAbstractUniConstraintStream.java", "diffHunk": "@@ -90,8 +91,23 @@ public void addChildStream(BavetAbstractUniConstraintStream<Solution_, A> childS\n         }\n         if (!(joiner instanceof AbstractBiJoiner)) {\n             throw new IllegalArgumentException(\"The joiner class (\" + joiner.getClass() + \") is not supported.\");\n+        } else if (joiner instanceof FilteringBiJoiner) {\n+            return join(otherStream)\n+                    .filter(((FilteringBiJoiner<A, B>) joiner).getFilter());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTU2OTY4", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347156968", "createdAt": "2020-01-23T09:29:21Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOToyOToyMVrOFg3mAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOToyOToyMVrOFg3mAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwOTYwMA==", "bodyText": "Please add a Exceptions message that starts with \"Impossible state:\" (which indicates to the user: you should never see this, this is an OptaPlanner bug, this is not your fault). For example \"Impossible state: this joiner should never be treated like a normal joiner internally.\"", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370009600", "createdAt": "2020-01-23T09:29:21Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bi/FilteringBiJoiner.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.bi;\n+\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.impl.score.stream.common.JoinerType;\n+\n+public final class FilteringBiJoiner<A, B> extends AbstractBiJoiner<A, B> {\n+\n+    public FilteringBiJoiner(BiPredicate<A, B> filter) {\n+        super(filter);\n+    }\n+\n+    @Override\n+    public Function<A, Object> getLeftMapping(int joinerId) {\n+        throw new UnsupportedOperationException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTY3MjQ4", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347167248", "createdAt": "2020-01-23T09:46:01Z", "commit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOTo0NjowMVrOFg4GMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOTo0NjowMVrOFg4GMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAxNzg0Mg==", "bodyText": "This exception and the expected order of joiners should be probably described in a javadoc.\nThis fail-fast is not a super trivial check of inputs - it establishes a contract regarding in which order users are supposed to register joiners of different kinds. There should be a test for it.", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370017842", "createdAt": "2020-01-23T09:46:01Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5d7eba4c75d1148c7eca52f3a4b24b6d96d948a", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/a5d7eba4c75d1148c7eca52f3a4b24b6d96d948a", "committedDate": "2020-01-23T10:27:42Z", "message": "joinOther() is gone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b149ec15424ab0c6491bacbd68831dcad836141", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/1b149ec15424ab0c6491bacbd68831dcad836141", "committedDate": "2020-01-23T15:25:54Z", "message": "Remove Joiners.notEquals()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98fc116df718591207dc6881067aaaf8c3cb0798", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/98fc116df718591207dc6881067aaaf8c3cb0798", "committedDate": "2020-01-23T16:24:50Z", "message": "Solve review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95", "committedDate": "2020-01-23T16:47:21Z", "message": "Add a leftover"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3ODAxNjcx", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347801671", "createdAt": "2020-01-24T08:23:44Z", "commit": {"oid": "d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwODoyMzo0NFrOFhWfiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwODoyMzo0NFrOFhWfiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxNTg0OA==", "bodyText": "Why do we need to handle the FilteringJoiner here already?\nThe join(UniStream, BiJoiner) method must also deal with wether or not that BiJoiner is a FilteringBiJoiner?\nI believe you can keep the original code on this change. And if that fails the test, then the problem is not in this method, but in the delegating method.", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370515848", "createdAt": "2020-01-24T08:23:44Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -121,66 +125,268 @@\n      * @param otherClass never null\n      * @param joiner never null\n      * @param <B> the type of the second matched fact\n-     * @return a stream that matches every combination of A and B for which the {@link BiJoiner} is true\n+     * @return never null, a stream that matches every combination of A and B for which the {@link BiJoiner} is true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B> joiner) {\n-        return join(getConstraintFactory().from(otherClass), joiner);\n+        if (joiner instanceof FilteringBiJoiner) {\n+            FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiner;\n+            return join(otherClass)\n+                    .filter(filteringJoiner.getFilter());\n+        } else {\n+            return join(getConstraintFactory().from(otherClass), joiner);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3ODA0NzY5", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347804769", "createdAt": "2020-01-24T08:31:28Z", "commit": {"oid": "d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwODozMToyOFrOFhWpbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwODozMToyOFrOFhWpbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxODM4MQ==", "bodyText": "This puts the vararg method front-and-center. This has 2 issues:\n1)The vararg method suffers from \"Unchecked generics array creation for varargs parameter\" JDK warnings, which we can only fix by making the method non-abstract (which is obviously impossible). Therefore, I see the method as a necessary evil: not something we want to put front-and-center.\n2) This javadoc delegates to the vararg method javadoc, which in turn delegates to the single joiner method. Every extra click through looses users. Yet we do delegates due to reduce maintenance burden - and to make users that already know the base method, be able to \"start from there\". For varargs that latest approach doesn't work.\n3) vararg's javadoc is NOT a subset of this javadocs. For example, that warning doesn't apply here at all.", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370518381", "createdAt": "2020-01-24T08:31:28Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -121,66 +125,268 @@\n      * @param otherClass never null\n      * @param joiner never null\n      * @param <B> the type of the second matched fact\n-     * @return a stream that matches every combination of A and B for which the {@link BiJoiner} is true\n+     * @return never null, a stream that matches every combination of A and B for which the {@link BiJoiner} is true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B> joiner) {\n-        return join(getConstraintFactory().from(otherClass), joiner);\n+        if (joiner instanceof FilteringBiJoiner) {\n+            FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiner;\n+            return join(otherClass)\n+                    .filter(filteringJoiner.getFilter());\n+        } else {\n+            return join(getConstraintFactory().from(otherClass), joiner);\n+        }\n     }\n \n     /**\n-     * As defined by {@link #join(Class, BiJoiner)}.\n+     * As defined by {@link #join(Class, BiJoiner...)}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3ODEwMDIx", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347810021", "createdAt": "2020-01-24T08:44:02Z", "commit": {"oid": "d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwODo0NDowMlrOFhW5fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwODo0NDowMlrOFhW5fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUyMjQ5NQ==", "bodyText": "Due to Lambda identity, I'd implement this slight different. Let me explain:\nThese 2 statements use the same lambda instance:\n\nfrom(A.class).join(B.class).filter(Objects::equal)\nfrom(A.class).join(B.class).filter(Objects::equal)\n\nThese 2 statements do NOT use the lambda instance:\n\nfrom(C.class).join(D.class).filter((c, d) -> c.equals(d))\nfrom(C.class).join(D.class).filter((c, d) -> c.equals(d))\n\nYou can try this out by printing System.systemHashCode() on those BiPredicates.\nNow, why do we care about that? Because of node sharing in Drools AND Bavet.\nIf its the same lambda instance, node sharing work guaranteed.\nIf it isn't, Bavet won't see it and Drools has some dirty ASM magic that might or might not recognize they are the same code.\nUnfortunately, there is no Objects.notEquals in java.util.Objects.\nApache commons-lang3 does have ObjectUtils.notEqual, presuming we want to use that, I would write:\nreturn ifExists(otherClass, Joiners.filtering(ObjectUtils::notEqual);", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370522495", "createdAt": "2020-01-24T08:44:02Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -121,66 +125,268 @@\n      * @param otherClass never null\n      * @param joiner never null\n      * @param <B> the type of the second matched fact\n-     * @return a stream that matches every combination of A and B for which the {@link BiJoiner} is true\n+     * @return never null, a stream that matches every combination of A and B for which the {@link BiJoiner} is true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B> joiner) {\n-        return join(getConstraintFactory().from(otherClass), joiner);\n+        if (joiner instanceof FilteringBiJoiner) {\n+            FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiner;\n+            return join(otherClass)\n+                    .filter(filteringJoiner.getFilter());\n+        } else {\n+            return join(getConstraintFactory().from(otherClass), joiner);\n+        }\n     }\n \n     /**\n-     * As defined by {@link #join(Class, BiJoiner)}.\n+     * As defined by {@link #join(Class, BiJoiner...)}.\n      * @param otherClass never null\n      * @param joiner1 never null\n      * @param joiner2 never null\n      * @param <B> the type of the second matched fact\n-     * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n+     * @return never null, a stream that matches every combination of A and B for which all the {@link BiJoiner joiners}\n+     * are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiner1, joiner2));\n+        return join(otherClass, new BiJoiner[] {joiner1, joiner2});\n     }\n \n     /**\n-     * As defined by {@link #join(Class, BiJoiner)}.\n+     * As defined by {@link #join(Class, BiJoiner...)}.\n      * @param otherClass never null\n      * @param joiner1 never null\n      * @param joiner2 never null\n      * @param joiner3 never null\n      * @param <B> the type of the second matched fact\n-     * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n+     * @return never null, a stream that matches every combination of A and B for which all the {@link BiJoiner joiners}\n+     * are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2,\n             BiJoiner<A, B> joiner3) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiner1, joiner2, joiner3));\n+        return join(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3});\n     }\n \n     /**\n-     * As defined by {@link #join(Class, BiJoiner)}.\n+     * As defined by {@link #join(Class, BiJoiner...)}.\n      * @param otherClass never null\n      * @param joiner1 never null\n      * @param joiner2 never null\n      * @param joiner3 never null\n      * @param joiner4 never null\n      * @param <B> the type of the second matched fact\n-     * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n+     * @return never null, a stream that matches every combination of A and B for which all the {@link BiJoiner joiners}\n+     * are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2,\n             BiJoiner<A, B> joiner3, BiJoiner<A, B> joiner4) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiner1, joiner2, joiner3, joiner4));\n+        return join(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3, joiner4});\n     }\n \n     /**\n-     * As defined by {@link #join(Class, BiJoiner)}.\n+     * As defined by {@link #join(Class, BiJoiner)}. If multiple {@link BiJoiner}s are provided, for performance\n+     * reasons, the indexing joiners must be placed before filtering joiners.\n      * <p>\n      * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n      * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n      * Therefore, there are overloaded methods with up to 4 {@link BiJoiner} parameters.\n      * @param otherClass never null\n      * @param joiners never null\n      * @param <B> the type of the second matched fact\n-     * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n+     * @return never null, a stream that matches every combination of A and B for which all the {@link BiJoiner joiners}\n+     * are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        // Make sure all indexing joiners, if any, come before filtering joiners. This is necessary for performance.\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            if (indexOfFirstFilter >= 0) {\n+                if (!(joiner instanceof FilteringBiJoiner)) {\n+                    throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow \" +\n+                            \"a filtering joiner (\" + joiners[indexOfFirstFilter] + \").\\n\" +\n+                            \"Maybe reorder the joiners such that filtering() joiners are later in the parameter list.\");\n+                }\n+            } else {\n+                if (joiner instanceof FilteringBiJoiner) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.\n+            return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        }\n+        // Assemble the join stream that may be followed by filter stream.\n+        BiConstraintStream<A, B> joined = indexOfFirstFilter == 0 ?\n+                join(otherClass) :\n+                join(otherClass, Arrays.copyOf(joiners, indexOfFirstFilter));\n+        int filterCount = joinerCount - indexOfFirstFilter;\n+        if (filterCount == 0) { // No filters, return the original join stream.\n+            return joined;\n+        }\n+        // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.\n+        FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiners[indexOfFirstFilter];\n+        BiPredicate<A, B> resultingFilter = filteringJoiner.getFilter();\n+        for (int i = indexOfFirstFilter + 1; i < joinerCount; i++) {\n+            FilteringBiJoiner<A, B> anoterFilteringJoiner = (FilteringBiJoiner<A, B>) joiners[i];\n+            resultingFilter = resultingFilter.and(anoterFilteringJoiner.getFilter());\n+        }\n+        return joined.filter(resultingFilter);\n+    }\n+\n+    // ************************************************************************\n+    // If Exists\n+    // ************************************************************************\n+\n+    /**\n+     * Create a new {@link UniConstraintStream} for every A where B exists for which the {@link BiJoiner} is true\n+     * (for the properties it extracts from both facts).\n+     * <p>\n+     * This method has overloaded methods with multiple {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @param <B> the type of the second matched fact\n+     * @return never null, a stream that matches every A where B exists for which the {@link BiJoiner} is true\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B> joiner) {\n+        return ifExists(otherClass, new BiJoiner[] { joiner });\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, BiJoiner...)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param <B> the type of the second matched fact\n+     * @return never null, a stream that matches every A where B exists for which all the {@link BiJoiner}s are true\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2) {\n+        return ifExists(otherClass, new BiJoiner[] {joiner1, joiner2});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, BiJoiner...)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param <B> the type of the second matched fact\n+     * @return never null, a stream that matches every A where B exists for which all the {@link BiJoiner}s are true\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2,\n+            BiJoiner<A, B> joiner3) {\n+        return ifExists(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, BiJoiner...)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param joiner4 never null\n+     * @param <B> the type of the second matched fact\n+     * @return never null, a stream that matches every A where B exists for which all the {@link BiJoiner}s are true\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2,\n+            BiJoiner<A, B> joiner3, BiJoiner<A, B> joiner4) {\n+        return ifExists(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3, joiner4});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, BiJoiner...)}.\n+     * <p>\n+     * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n+     * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n+     * Therefore, there are overloaded methods with up to 4 {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiners never null\n+     * @param <B> the type of the second matched fact\n+     * @return never null, a stream that matches every A where B exists for which all the {@link BiJoiner}s are true\n+     */\n+    <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B>... joiners);\n+\n+    /**\n+     * Create a new {@link UniConstraintStream} for every A, if another A exists that does not {@link #equals(Object)}\n+     * the first. If multiple {@link BiJoiner}s are provided, for performance reasons, the indexing joiners must be\n+     * placed before filtering joiners.\n+     * @param otherClass never null\n+     * @return never null, a stream that matches every A where a different A exists\n+     */\n+    default UniConstraintStream<A> ifExistsOther(Class<A> otherClass) {\n+        return ifExists(otherClass, Joiners.filtering((a, b) -> !a.equals(b)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95"}, "originalPosition": 261}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3ODE0MzMw", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347814330", "createdAt": "2020-01-24T08:53:37Z", "commit": {"oid": "d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwODo1MzozN1rOFhXGwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwODo1MzozN1rOFhXGwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUyNTg5MA==", "bodyText": "Just noticed (not a problem in this PR). This joinerId is not an ID, it's an index, for CombinedBiJoiners. That variable should be renamed to joinerIndex or just index (I 'd say the latter). Again, doesn't need to happen in this PR.\nWhat the different between an ID and and index?\nID's have gaps, as elements get deleted. Examples of ID's: 0, 1, 2, 4, 7\nIndexes don't have gaps, they would naturally change if elements get deleted (ussually they won't): Examples of index: 0, 1, 2, 3, 4, 5", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370525890", "createdAt": "2020-01-24T08:53:37Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bi/FilteringBiJoiner.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.bi;\n+\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.impl.score.stream.common.JoinerType;\n+\n+public final class FilteringBiJoiner<A, B> extends AbstractBiJoiner<A, B> {\n+\n+    public FilteringBiJoiner(BiPredicate<A, B> filter) {\n+        super(filter);\n+    }\n+\n+    @Override\n+    public Function<A, Object> getLeftMapping(int joinerId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3ODE1ODAw", "url": "https://github.com/kiegroup/optaplanner/pull/660#pullrequestreview-347815800", "createdAt": "2020-01-24T08:56:40Z", "commit": {"oid": "d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d3a7f66acff3f8992f4661f58c4b86503f55758", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/2d3a7f66acff3f8992f4661f58c4b86503f55758", "committedDate": "2020-01-24T08:58:40Z", "message": "Address the final review comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3044, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}