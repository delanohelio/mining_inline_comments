{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NTcyMzc2", "number": 664, "title": "Solver manager docs", "bodyText": "All feedback welcome, but \"Suggestion\" github comments extra welcome (easier to apply :))", "createdAt": "2020-01-27T16:03:37Z", "url": "https://github.com/kiegroup/optaplanner/pull/664", "merged": true, "mergeCommit": {"oid": "bf64e8c3c078543f291d2ba3b8be787bc0e9fde2"}, "closed": true, "closedAt": "2020-02-03T15:20:47Z", "author": {"login": "ge0ffrey"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb7MudWAH2gAyMzY3NTcyMzc2OjQ2ZjEyOTc1YjRmZjllMTVlZWU3MjYzOWEyNjRkYjQ3NzkxYWIxOWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb_xL8SgFqTM1MTU5NzI2Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "46f12975b4ff9e15eee72639a264db47791ab19e", "author": {"user": {"login": "ge0ffrey", "name": "Geoffrey De Smet"}}, "url": "https://github.com/kiegroup/optaplanner/commit/46f12975b4ff9e15eee72639a264db47791ab19e", "committedDate": "2020-01-17T11:06:04Z", "message": "Spring Starter docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe25e8747ec70a42c85793ffa5e1b3a3f6dc89bf", "author": {"user": {"login": "ge0ffrey", "name": "Geoffrey De Smet"}}, "url": "https://github.com/kiegroup/optaplanner/commit/fe25e8747ec70a42c85793ffa5e1b3a3f6dc89bf", "committedDate": "2020-01-24T15:20:11Z", "message": "docs: Do not use the deprecated Solution class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edcb09940f1e362d835fe4a77b5677b457115a91", "author": {"user": {"login": "ge0ffrey", "name": "Geoffrey De Smet"}}, "url": "https://github.com/kiegroup/optaplanner/commit/edcb09940f1e362d835fe4a77b5677b457115a91", "committedDate": "2020-01-27T16:03:08Z", "message": "docs: SolverManager"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MzI0Nzg4", "url": "https://github.com/kiegroup/optaplanner/pull/664#pullrequestreview-349324788", "createdAt": "2020-01-28T12:07:50Z", "commit": {"oid": "edcb09940f1e362d835fe4a77b5677b457115a91"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxMjowNzo1MFrOFiiq0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDoxNTozNlrOFimfCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc2MzkyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A `Solver` should only be accessed from a single thread, except for the methods that are specifically javadocced as being thread-safe.\n          \n          \n            \n            A `Solver` should only be accessed from a single thread, except for the methods that are specifically documented in javadoc as being thread-safe.", "url": "https://github.com/kiegroup/optaplanner/pull/664#discussion_r371763922", "createdAt": "2020-01-28T12:07:50Z", "author": {"login": "rsynek"}, "path": "optaplanner-docs/src/main/asciidoc/PlannerConfiguration/PlannerConfiguration-chapter.adoc", "diffHunk": "@@ -1479,22 +1482,27 @@ public interface Solver<Solution_> {\n ----\n \n A `Solver` can only solve one planning problem instance at a time.\n-A `Solver` should only be accessed from a single thread, except for the methods that are specifically javadocced as being thread-safe.\n It is built with a ``SolverFactory``, there is no need to implement it yourself.\n \n+A `Solver` should only be accessed from a single thread, except for the methods that are specifically javadocced as being thread-safe.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edcb09940f1e362d835fe4a77b5677b457115a91"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgxODc0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            At night, batch solving a great approach to deliver solid plans by breakfast, because:\n          \n          \n            \n            At night, batch solving is a great approach to deliver solid plans by breakfast, because:", "url": "https://github.com/kiegroup/optaplanner/pull/664#discussion_r371818743", "createdAt": "2020-01-28T14:02:24Z", "author": {"login": "rsynek"}, "path": "optaplanner-docs/src/main/asciidoc/PlannerConfiguration/PlannerConfiguration-chapter.adoc", "diffHunk": "@@ -1790,3 +1799,143 @@ The following types are supported:\n \n For most use cases, the randomType has no significant impact on the average quality of the best solution on multiple datasets.\n If you want to confirm this on your use case, use the <<benchmarker,benchmarker>>.\n+\n+\n+[[solverManager]]\n+== SolverManager\n+\n+A `SolverManager` is a facade for one or more `Solver` instances.\n+Its `solve(...)` methods differ from the normal `Solver.solve(...)` method, such that:\n+\n+* *`SolverManager.solve(...)` returns immediately*: it schedules a problem for asynchronous solving without blocking the calling thread.\n+* *`SolverManager.solve(...)` solves multiple planning problems* of the same domain, in parallel.\n+\n+Internally a `SolverManager` manages a thread pool of solver threads, which call `Solver.solve(...)`,\n+and a thread pool of consumer threads, which handle best solution changed events.\n+\n+In <<integrationWithQuarkus,Quarkus>> and <<integrationWithSpringBoot,Spring Boot>>,\n+the `SolverManager` instance is automatically injected in your code.\n+Otherwise, build a `SolverManager` instance with the `create(...)` method:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+SolverConfig solverConfig = SolverConfig.createFromXmlResource(\".../cloudBalancingSolverConfig.xml\");\n+SolverManager<CloudBalance, UUID> solverManager = SolverManager.create(solverConfig, new SolverManagerConfig());\n+----\n+\n+Each problem submitted to the `SolverManager.solve(...)` methods needs a unique problem ID,\n+to distinguish with other problems in other calls,\n+such as `getSolverStatus(problemId)` and `terminateEarly(problemId)`.\n+The problem ID must be an immutable class, such as `Long`, `String` or `java.util.UUID`.\n+\n+The `SolverManagerConfig` class has a `parallelSolverCount` property,\n+that controls how many solvers are run in parallel.\n+For example, if set to `4`, submitting five problems\n+has four problems solving immediately, and the fifth one starts when another one ends.\n+So if those problems solve for 5 minutes each, the fifth problem takes 10 minutes to finish.\n+By default, `parallelSolverCount` is set to `AUTO`, which resolves to half the CPU cores,\n+regardless of the <<multithreadedSolving,`moveThreadCount`>> of the solvers.\n+\n+To retrieve the best solution, after solving terminates normally, use `SolverJob.getFinalBestSolution()`:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+CloudBalance problem1 = ...;\n+UUID problemId = UUID.randomUUID();\n+// Returns immediately\n+SolverJob<CloudBalance, UUID> solverJob = solverManager.solve(problemId, problem1);\n+...\n+CloudBalance solution1;\n+try {\n+    // Returns only after solving terminates\n+    solution1 = solverJob.getFinalBestSolution();\n+} catch (InterruptedException | ExecutionException e) {\n+    throw ...;\n+}\n+----\n+\n+However, there are better approaches, both for solving batch problems before an end-user needs the solution\n+as well as for live solving while an end-user is actively waiting for the solution, as explained below.\n+\n+The current `SolverManager` implementation runs on a single computer node,\n+but future work aims to distribute solver loads across a cloud.\n+\n+\n+[[solverManagerSolveBatch]]\n+=== Solve batch problems\n+\n+At night, batch solving a great approach to deliver solid plans by breakfast, because:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edcb09940f1e362d835fe4a77b5677b457115a91"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgyMjMyMw==", "bodyText": "How about something like:\n\"When the solver is running in an interactive application, end-users need to be kept updated about best solution available and best score attained so far.\nTo handle intermediate best solutions...\"\n?\nSorry to put it this way, but suggestions don't work on multi-line comments.", "url": "https://github.com/kiegroup/optaplanner/pull/664#discussion_r371822323", "createdAt": "2020-01-28T14:08:48Z", "author": {"login": "rsynek"}, "path": "optaplanner-docs/src/main/asciidoc/PlannerConfiguration/PlannerConfiguration-chapter.adoc", "diffHunk": "@@ -1790,3 +1799,143 @@ The following types are supported:\n \n For most use cases, the randomType has no significant impact on the average quality of the best solution on multiple datasets.\n If you want to confirm this on your use case, use the <<benchmarker,benchmarker>>.\n+\n+\n+[[solverManager]]\n+== SolverManager\n+\n+A `SolverManager` is a facade for one or more `Solver` instances.\n+Its `solve(...)` methods differ from the normal `Solver.solve(...)` method, such that:\n+\n+* *`SolverManager.solve(...)` returns immediately*: it schedules a problem for asynchronous solving without blocking the calling thread.\n+* *`SolverManager.solve(...)` solves multiple planning problems* of the same domain, in parallel.\n+\n+Internally a `SolverManager` manages a thread pool of solver threads, which call `Solver.solve(...)`,\n+and a thread pool of consumer threads, which handle best solution changed events.\n+\n+In <<integrationWithQuarkus,Quarkus>> and <<integrationWithSpringBoot,Spring Boot>>,\n+the `SolverManager` instance is automatically injected in your code.\n+Otherwise, build a `SolverManager` instance with the `create(...)` method:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+SolverConfig solverConfig = SolverConfig.createFromXmlResource(\".../cloudBalancingSolverConfig.xml\");\n+SolverManager<CloudBalance, UUID> solverManager = SolverManager.create(solverConfig, new SolverManagerConfig());\n+----\n+\n+Each problem submitted to the `SolverManager.solve(...)` methods needs a unique problem ID,\n+to distinguish with other problems in other calls,\n+such as `getSolverStatus(problemId)` and `terminateEarly(problemId)`.\n+The problem ID must be an immutable class, such as `Long`, `String` or `java.util.UUID`.\n+\n+The `SolverManagerConfig` class has a `parallelSolverCount` property,\n+that controls how many solvers are run in parallel.\n+For example, if set to `4`, submitting five problems\n+has four problems solving immediately, and the fifth one starts when another one ends.\n+So if those problems solve for 5 minutes each, the fifth problem takes 10 minutes to finish.\n+By default, `parallelSolverCount` is set to `AUTO`, which resolves to half the CPU cores,\n+regardless of the <<multithreadedSolving,`moveThreadCount`>> of the solvers.\n+\n+To retrieve the best solution, after solving terminates normally, use `SolverJob.getFinalBestSolution()`:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+CloudBalance problem1 = ...;\n+UUID problemId = UUID.randomUUID();\n+// Returns immediately\n+SolverJob<CloudBalance, UUID> solverJob = solverManager.solve(problemId, problem1);\n+...\n+CloudBalance solution1;\n+try {\n+    // Returns only after solving terminates\n+    solution1 = solverJob.getFinalBestSolution();\n+} catch (InterruptedException | ExecutionException e) {\n+    throw ...;\n+}\n+----\n+\n+However, there are better approaches, both for solving batch problems before an end-user needs the solution\n+as well as for live solving while an end-user is actively waiting for the solution, as explained below.\n+\n+The current `SolverManager` implementation runs on a single computer node,\n+but future work aims to distribute solver loads across a cloud.\n+\n+\n+[[solverManagerSolveBatch]]\n+=== Solve batch problems\n+\n+At night, batch solving a great approach to deliver solid plans by breakfast, because:\n+\n+* There are typically few or no problem changes in the middle of the night.\n+Some organizations even enforce a deadline, for example, _submit all day off requests before midnight_.\n+* The solvers can run for much longer, often hours, because nobody's waiting for it and CPU resources are often cheaper.\n+\n+To solve a multiple datasets in parallel (limited by `parallelSolverCount`),\n+call `solve(...)` for each dataset:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+public class TimeTableService {\n+\n+    private SolverManager<TimeTable, Long> solverManager;\n+\n+    // Returns immediately, call it for every dataset\n+    public void solveBatch(Long timeTableId) {\n+        solverManager.solve(timeTableId,\n+                // Called once, when solving starts\n+                this::findById,\n+                // Called once, when solving ends\n+                this::save);\n+    }\n+\n+    public TimeTable findById(Long id) {...}\n+\n+    public void save(TimeTable timeTable) {...}\n+\n+}\n+----\n+\n+A solid plan delivered by breakfast is great,\n+even if you need to react on problem changes during the day.\n+\n+\n+[[solverManagerSolveAndListen]]\n+=== Solve and listen to show progress to the end-user\n+\n+When the solver is running and an end-user is waiting for that solution,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edcb09940f1e362d835fe4a77b5677b457115a91"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgyMzcwMA==", "bodyText": "\"Tired of waiting\" sounds like OptaPlanner is tiresomely slow in getting new best solutions :)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            and tired of waiting for a better one, call `SolverManager.terminateEarly(problemId)`.\n          \n          \n            \n            and does not want to wait for a better one, call `SolverManager.terminateEarly(problemId)`.", "url": "https://github.com/kiegroup/optaplanner/pull/664#discussion_r371823700", "createdAt": "2020-01-28T14:10:54Z", "author": {"login": "rsynek"}, "path": "optaplanner-docs/src/main/asciidoc/PlannerConfiguration/PlannerConfiguration-chapter.adoc", "diffHunk": "@@ -1790,3 +1799,143 @@ The following types are supported:\n \n For most use cases, the randomType has no significant impact on the average quality of the best solution on multiple datasets.\n If you want to confirm this on your use case, use the <<benchmarker,benchmarker>>.\n+\n+\n+[[solverManager]]\n+== SolverManager\n+\n+A `SolverManager` is a facade for one or more `Solver` instances.\n+Its `solve(...)` methods differ from the normal `Solver.solve(...)` method, such that:\n+\n+* *`SolverManager.solve(...)` returns immediately*: it schedules a problem for asynchronous solving without blocking the calling thread.\n+* *`SolverManager.solve(...)` solves multiple planning problems* of the same domain, in parallel.\n+\n+Internally a `SolverManager` manages a thread pool of solver threads, which call `Solver.solve(...)`,\n+and a thread pool of consumer threads, which handle best solution changed events.\n+\n+In <<integrationWithQuarkus,Quarkus>> and <<integrationWithSpringBoot,Spring Boot>>,\n+the `SolverManager` instance is automatically injected in your code.\n+Otherwise, build a `SolverManager` instance with the `create(...)` method:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+SolverConfig solverConfig = SolverConfig.createFromXmlResource(\".../cloudBalancingSolverConfig.xml\");\n+SolverManager<CloudBalance, UUID> solverManager = SolverManager.create(solverConfig, new SolverManagerConfig());\n+----\n+\n+Each problem submitted to the `SolverManager.solve(...)` methods needs a unique problem ID,\n+to distinguish with other problems in other calls,\n+such as `getSolverStatus(problemId)` and `terminateEarly(problemId)`.\n+The problem ID must be an immutable class, such as `Long`, `String` or `java.util.UUID`.\n+\n+The `SolverManagerConfig` class has a `parallelSolverCount` property,\n+that controls how many solvers are run in parallel.\n+For example, if set to `4`, submitting five problems\n+has four problems solving immediately, and the fifth one starts when another one ends.\n+So if those problems solve for 5 minutes each, the fifth problem takes 10 minutes to finish.\n+By default, `parallelSolverCount` is set to `AUTO`, which resolves to half the CPU cores,\n+regardless of the <<multithreadedSolving,`moveThreadCount`>> of the solvers.\n+\n+To retrieve the best solution, after solving terminates normally, use `SolverJob.getFinalBestSolution()`:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+CloudBalance problem1 = ...;\n+UUID problemId = UUID.randomUUID();\n+// Returns immediately\n+SolverJob<CloudBalance, UUID> solverJob = solverManager.solve(problemId, problem1);\n+...\n+CloudBalance solution1;\n+try {\n+    // Returns only after solving terminates\n+    solution1 = solverJob.getFinalBestSolution();\n+} catch (InterruptedException | ExecutionException e) {\n+    throw ...;\n+}\n+----\n+\n+However, there are better approaches, both for solving batch problems before an end-user needs the solution\n+as well as for live solving while an end-user is actively waiting for the solution, as explained below.\n+\n+The current `SolverManager` implementation runs on a single computer node,\n+but future work aims to distribute solver loads across a cloud.\n+\n+\n+[[solverManagerSolveBatch]]\n+=== Solve batch problems\n+\n+At night, batch solving a great approach to deliver solid plans by breakfast, because:\n+\n+* There are typically few or no problem changes in the middle of the night.\n+Some organizations even enforce a deadline, for example, _submit all day off requests before midnight_.\n+* The solvers can run for much longer, often hours, because nobody's waiting for it and CPU resources are often cheaper.\n+\n+To solve a multiple datasets in parallel (limited by `parallelSolverCount`),\n+call `solve(...)` for each dataset:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+public class TimeTableService {\n+\n+    private SolverManager<TimeTable, Long> solverManager;\n+\n+    // Returns immediately, call it for every dataset\n+    public void solveBatch(Long timeTableId) {\n+        solverManager.solve(timeTableId,\n+                // Called once, when solving starts\n+                this::findById,\n+                // Called once, when solving ends\n+                this::save);\n+    }\n+\n+    public TimeTable findById(Long id) {...}\n+\n+    public void save(TimeTable timeTable) {...}\n+\n+}\n+----\n+\n+A solid plan delivered by breakfast is great,\n+even if you need to react on problem changes during the day.\n+\n+\n+[[solverManagerSolveAndListen]]\n+=== Solve and listen to show progress to the end-user\n+\n+When the solver is running and an end-user is waiting for that solution,\n+it's vital to show progress to the end-user.\n+Display the best score so far and visualize the best solution so far.\n+\n+To handle intermediate best solutions, use `solveAndListen(...)`:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+public class TimeTableService {\n+\n+    private SolverManager<TimeTable, Long> solverManager;\n+\n+    // Returns immediately\n+    public void solveLive(Long timeTableId) {\n+        solverManager.solveAndListen(timeTableId,\n+                // Called once, when solving starts\n+                this::findById,\n+                // Called multiple times, for every best solution change\n+                this::save);\n+    }\n+\n+    public TimeTable findById(Long id) {...}\n+\n+    public void save(TimeTable timeTable) {...}\n+\n+    public void stopSolving(Long timeTableId) {\n+        solverManager.terminateEarly(timeTableId);\n+    }\n+\n+}\n+----\n+\n+This implementation is using the database to communicate with the UI, which polls the database.\n+More advanced implementations push the best solutions directly to the UI or a messaging queue.\n+\n+If the user is satisfied with the intermediate best solution\n+and tired of waiting for a better one, call `SolverManager.terminateEarly(problemId)`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edcb09940f1e362d835fe4a77b5677b457115a91"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgyNjA4OA==", "bodyText": "The sentence is too long, let's break it into two shorter ones.", "url": "https://github.com/kiegroup/optaplanner/pull/664#discussion_r371826088", "createdAt": "2020-01-28T14:15:01Z", "author": {"login": "rsynek"}, "path": "optaplanner-docs/src/main/asciidoc/PlannerConfiguration/PlannerConfiguration-chapter.adoc", "diffHunk": "@@ -1790,3 +1799,143 @@ The following types are supported:\n \n For most use cases, the randomType has no significant impact on the average quality of the best solution on multiple datasets.\n If you want to confirm this on your use case, use the <<benchmarker,benchmarker>>.\n+\n+\n+[[solverManager]]\n+== SolverManager\n+\n+A `SolverManager` is a facade for one or more `Solver` instances.\n+Its `solve(...)` methods differ from the normal `Solver.solve(...)` method, such that:\n+\n+* *`SolverManager.solve(...)` returns immediately*: it schedules a problem for asynchronous solving without blocking the calling thread.\n+* *`SolverManager.solve(...)` solves multiple planning problems* of the same domain, in parallel.\n+\n+Internally a `SolverManager` manages a thread pool of solver threads, which call `Solver.solve(...)`,\n+and a thread pool of consumer threads, which handle best solution changed events.\n+\n+In <<integrationWithQuarkus,Quarkus>> and <<integrationWithSpringBoot,Spring Boot>>,\n+the `SolverManager` instance is automatically injected in your code.\n+Otherwise, build a `SolverManager` instance with the `create(...)` method:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+SolverConfig solverConfig = SolverConfig.createFromXmlResource(\".../cloudBalancingSolverConfig.xml\");\n+SolverManager<CloudBalance, UUID> solverManager = SolverManager.create(solverConfig, new SolverManagerConfig());\n+----\n+\n+Each problem submitted to the `SolverManager.solve(...)` methods needs a unique problem ID,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edcb09940f1e362d835fe4a77b5677b457115a91"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgyNjQ0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            So if those problems solve for 5 minutes each, the fifth problem takes 10 minutes to finish.\n          \n          \n            \n            If those problems solve for 5 minutes each, the fifth problem takes 10 minutes to finish.", "url": "https://github.com/kiegroup/optaplanner/pull/664#discussion_r371826440", "createdAt": "2020-01-28T14:15:36Z", "author": {"login": "rsynek"}, "path": "optaplanner-docs/src/main/asciidoc/PlannerConfiguration/PlannerConfiguration-chapter.adoc", "diffHunk": "@@ -1790,3 +1799,143 @@ The following types are supported:\n \n For most use cases, the randomType has no significant impact on the average quality of the best solution on multiple datasets.\n If you want to confirm this on your use case, use the <<benchmarker,benchmarker>>.\n+\n+\n+[[solverManager]]\n+== SolverManager\n+\n+A `SolverManager` is a facade for one or more `Solver` instances.\n+Its `solve(...)` methods differ from the normal `Solver.solve(...)` method, such that:\n+\n+* *`SolverManager.solve(...)` returns immediately*: it schedules a problem for asynchronous solving without blocking the calling thread.\n+* *`SolverManager.solve(...)` solves multiple planning problems* of the same domain, in parallel.\n+\n+Internally a `SolverManager` manages a thread pool of solver threads, which call `Solver.solve(...)`,\n+and a thread pool of consumer threads, which handle best solution changed events.\n+\n+In <<integrationWithQuarkus,Quarkus>> and <<integrationWithSpringBoot,Spring Boot>>,\n+the `SolverManager` instance is automatically injected in your code.\n+Otherwise, build a `SolverManager` instance with the `create(...)` method:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+SolverConfig solverConfig = SolverConfig.createFromXmlResource(\".../cloudBalancingSolverConfig.xml\");\n+SolverManager<CloudBalance, UUID> solverManager = SolverManager.create(solverConfig, new SolverManagerConfig());\n+----\n+\n+Each problem submitted to the `SolverManager.solve(...)` methods needs a unique problem ID,\n+to distinguish with other problems in other calls,\n+such as `getSolverStatus(problemId)` and `terminateEarly(problemId)`.\n+The problem ID must be an immutable class, such as `Long`, `String` or `java.util.UUID`.\n+\n+The `SolverManagerConfig` class has a `parallelSolverCount` property,\n+that controls how many solvers are run in parallel.\n+For example, if set to `4`, submitting five problems\n+has four problems solving immediately, and the fifth one starts when another one ends.\n+So if those problems solve for 5 minutes each, the fifth problem takes 10 minutes to finish.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edcb09940f1e362d835fe4a77b5677b457115a91"}, "originalPosition": 185}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1275b5e5338b691b56157aae8b4cb3983b8b6fe", "author": {"user": {"login": "ge0ffrey", "name": "Geoffrey De Smet"}}, "url": "https://github.com/kiegroup/optaplanner/commit/e1275b5e5338b691b56157aae8b4cb3983b8b6fe", "committedDate": "2020-01-28T21:40:55Z", "message": "Update optaplanner-docs/src/main/asciidoc/PlannerConfiguration/PlannerConfiguration-chapter.adoc\n\nCo-Authored-By: Radovan Synek <rsynek@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f44c640dedd8ad52e5ef56dd71abf866d40ffdd1", "author": {"user": {"login": "ge0ffrey", "name": "Geoffrey De Smet"}}, "url": "https://github.com/kiegroup/optaplanner/commit/f44c640dedd8ad52e5ef56dd71abf866d40ffdd1", "committedDate": "2020-01-28T21:41:04Z", "message": "Update optaplanner-docs/src/main/asciidoc/PlannerConfiguration/PlannerConfiguration-chapter.adoc\n\nCo-Authored-By: Radovan Synek <rsynek@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f006a238fa9667f2a6af6550537f1d2fc1e3af6", "author": {"user": {"login": "ge0ffrey", "name": "Geoffrey De Smet"}}, "url": "https://github.com/kiegroup/optaplanner/commit/6f006a238fa9667f2a6af6550537f1d2fc1e3af6", "committedDate": "2020-01-28T21:41:35Z", "message": "Update optaplanner-docs/src/main/asciidoc/PlannerConfiguration/PlannerConfiguration-chapter.adoc\n\nCo-Authored-By: Radovan Synek <rsynek@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ddac0472fc5e6b5a4efdb1df23fdf79f670bbb8", "author": {"user": {"login": "ge0ffrey", "name": "Geoffrey De Smet"}}, "url": "https://github.com/kiegroup/optaplanner/commit/4ddac0472fc5e6b5a4efdb1df23fdf79f670bbb8", "committedDate": "2020-01-28T21:41:46Z", "message": "Update optaplanner-docs/src/main/asciidoc/PlannerConfiguration/PlannerConfiguration-chapter.adoc\n\nCo-Authored-By: Radovan Synek <rsynek@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9bc221b55791ab6d1c084e8adc1d376256d83e9", "author": {"user": {"login": "ge0ffrey", "name": "Geoffrey De Smet"}}, "url": "https://github.com/kiegroup/optaplanner/commit/c9bc221b55791ab6d1c084e8adc1d376256d83e9", "committedDate": "2020-01-29T08:21:21Z", "message": "Radovan's suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e94ae12c431731bcc84ac36a745ac46a8c8f4a3e", "author": {"user": {"login": "ge0ffrey", "name": "Geoffrey De Smet"}}, "url": "https://github.com/kiegroup/optaplanner/commit/e94ae12c431731bcc84ac36a745ac46a8c8f4a3e", "committedDate": "2020-01-29T08:25:49Z", "message": "docs: SolverManager - better base explanation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac05212fc14f9fc0b3f9927fe359427583393a21", "author": {"user": {"login": "ge0ffrey", "name": "Geoffrey De Smet"}}, "url": "https://github.com/kiegroup/optaplanner/commit/ac05212fc14f9fc0b3f9927fe359427583393a21", "committedDate": "2020-01-29T08:28:24Z", "message": "docs: SolverManager: id -> timeTableId"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf6d0c9d8ef80b8a493149848726682eac4b5cf0", "author": {"user": {"login": "ge0ffrey", "name": "Geoffrey De Smet"}}, "url": "https://github.com/kiegroup/optaplanner/commit/cf6d0c9d8ef80b8a493149848726682eac4b5cf0", "committedDate": "2020-01-29T09:18:34Z", "message": "docs: SolverManager - small improvements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxNTk3MjY2", "url": "https://github.com/kiegroup/optaplanner/pull/664#pullrequestreview-351597266", "createdAt": "2020-01-31T15:50:33Z", "commit": {"oid": "cf6d0c9d8ef80b8a493149848726682eac4b5cf0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3051, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}