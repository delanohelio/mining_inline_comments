{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2NDc4NTc1", "number": 661, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzo1Njo1NVrODblFxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwODo1MjowNlrODd82yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMjQ1ODMxOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzo1Njo1NVrOFjJN0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzo1Njo1NVrOFjJN0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5NTQ3Mg==", "bodyText": "Just a nitpicking: the condition can be put in the while clause to avoid break in the middle of the loop", "url": "https://github.com/kiegroup/optaplanner/pull/661#discussion_r372395472", "createdAt": "2020-01-29T13:56:55Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "diffHunk": "@@ -240,4 +245,90 @@ public void skipAhead() throws ExecutionException, InterruptedException {\n         assertTrue(eventCount.get() < 4);\n     }\n \n+    /**\n+     * In order to effectively test the terminateEarly() and close() methods there had to be a way how to make the job\n+     * status change deterministic while solving jobs on a separate thread. The test waits for a status change in\n+     * a loop and time-outs when it doesn't reach it's expected status.\n+     */\n+    @Test\n+    public void terminateEarlyAndClose() throws InterruptedException {\n+        final SolverConfig solverConfig = PlannerTestUtils.buildSolverConfig(TestdataSolution.class, TestdataEntity.class)\n+                .withPhases(new ConstructionHeuristicPhaseConfig(), new LocalSearchPhaseConfig());\n+\n+        // Having only one solver running at the same time is important for predicting solver status behaviour.\n+        SolverManager<TestdataSolution, Long> solverManager =\n+                SolverManager.create(solverConfig, new SolverManagerConfig().withParallelSolverCount(\"1\"));\n+\n+        Long firstProblemId = 1L;\n+        Long secondProblemId = 2L;\n+\n+        // Submit the first problem. Status changes from SOLVING_SCHEDULED to SOLVING_ACTIVE.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Second problem not yet submitted to solverManager, tries to terminate it leading to a debug output:\n+        // DEBUG Ignoring terminateEarly() call because problemId (1) is not solving.\n+        // Asserting a logger message was determined as being too complex for using only on this\n+        // one occurrence and would result in cluttering up the code. The output was checked manually.\n+        solverManager.terminateEarly(secondProblemId);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(secondProblemId));\n+        // Did not affect the actively solving job.\n+        assertSame(SolverStatus.SOLVING_ACTIVE, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Schedule second job while waiting for the first job to finish. It stays in the SOLVING_SCHEDULED status.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        // Terminate second job which is in scheduled status. The status changes from SOLVING_SCHEDULED to NOT_SOLVING\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+\n+        // Reschedule second job. It reintroduces it to the solverManager by changing status from NOT_SOLVING to\n+        // SOLVING_SCHEDULED in which it stays.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_SCHEDULED);\n+\n+        // Terminate the first job which triggers it to change it's status from SOLVING_ACTIVE to NOT_SOLVING.\n+        // Automatically starts working on the second job. Its status changes from STATUS_SCHEDULED to STATUS_ACTIVE.\n+        solverManager.terminateEarly(firstProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Terminate the second job, its status changes from SOLVING_ACTIVE to NOT_SOLVING. Both jobs stopped solving.\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Reintroduce the problems to solverManager and attempt to close them all at once using solverManager.close().\n+        // The first job's status changes from SOLVING_ACTIVE to NOT_SOLVING.\n+        // The second job's status changes from SOLVING_SCHEDULED to NOT_SOLVING.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        solverManager.close();\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+    }\n+\n+    private void waitForJobStatusChangeOrTimeout(SolverManager<TestdataSolution, Long> solverManager, Long problemId, SolverStatus expectedStatusChange) throws InterruptedException {\n+        long t = System.currentTimeMillis();\n+        long end = t + 5000;\n+        // Checks every 5 milliseconds for solverJob status change for 5 seconds at maximum, otherwise time-outs and fails.\n+        while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dae818e6baba1868cec9719a2a38cd7f7774f12"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwOTIzOTE4OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMjo0OTozM1rOFkKZ7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxODoxN1rOFoPgsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2MzUzMw==", "bodyText": "If this test fails (as it reproduces an issue), let's mark it as ignored with a link to that issue and get this merged. Once the issue is fixed, it will be enabled.", "url": "https://github.com/kiegroup/optaplanner/pull/661#discussion_r373463533", "createdAt": "2020-01-31T12:49:33Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "diffHunk": "@@ -240,4 +245,86 @@ public void skipAhead() throws ExecutionException, InterruptedException {\n         assertTrue(eventCount.get() < 4);\n     }\n \n+    /**\n+     * In order to effectively test the terminateEarly() and close() methods there had to be a way how to make the job\n+     * status change deterministic while solving jobs on a separate thread. The test waits for a status change in\n+     * a loop and time-outs when it doesn't reach it's expected status.\n+     */\n+    @Test\n+    public void terminateEarlyAndClose() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6290c643f7f1d42d4741c95e172efe6deaf5e95e"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MTQ4OA==", "bodyText": "This timeout approach is not race condition free. If we activate this test, it will cause randomly failing unit tests (which is never acceptable). I am going to refactor this to use Latches.", "url": "https://github.com/kiegroup/optaplanner/pull/661#discussion_r377741488", "createdAt": "2020-02-11T16:18:17Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "diffHunk": "@@ -240,4 +245,86 @@ public void skipAhead() throws ExecutionException, InterruptedException {\n         assertTrue(eventCount.get() < 4);\n     }\n \n+    /**\n+     * In order to effectively test the terminateEarly() and close() methods there had to be a way how to make the job\n+     * status change deterministic while solving jobs on a separate thread. The test waits for a status change in\n+     * a loop and time-outs when it doesn't reach it's expected status.\n+     */\n+    @Test\n+    public void terminateEarlyAndClose() throws InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2MzUzMw=="}, "originalCommit": {"oid": "6290c643f7f1d42d4741c95e172efe6deaf5e95e"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzMxNDYzOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwODo0ODoyN1rOFm19Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwODo0ODoyN1rOFm19Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI3NDIxNQ==", "bodyText": "Above the sleep, can you add these comments?\n// Quick polling (not a Test Thread Sleep anti-pattern)\n// Test is still fast on fast machines and doesn't randomly fail on slow machines.\n\nMotivation: the use of Thread.sleep() is a red flag in tests, because it's often used in a catch 22 situation: wait long enough to succeed on the slow machine, but don't wait long so the tests run quickly. This comment makes it clear that this code is doing it correctly.", "url": "https://github.com/kiegroup/optaplanner/pull/661#discussion_r376274215", "createdAt": "2020-02-07T08:48:27Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "diffHunk": "@@ -240,4 +245,87 @@ public void skipAhead() throws ExecutionException, InterruptedException {\n         assertTrue(eventCount.get() < 4);\n     }\n \n+    /**\n+     * In order to effectively test the terminateEarly() and close() methods there had to be a way how to make the job\n+     * status change in a deterministic way while solving jobs on separate threads. The test waits for a status change in\n+     * a loop and time-outs when it doesn't reach it's expected status.\n+     */\n+    @Ignore(\"https://issues.redhat.com/browse/PLANNER-1836\")\n+    @Test\n+    public void terminateEarlyAndClose() throws InterruptedException {\n+        final SolverConfig solverConfig = PlannerTestUtils.buildSolverConfig(TestdataSolution.class, TestdataEntity.class)\n+                .withPhases(new ConstructionHeuristicPhaseConfig(), new LocalSearchPhaseConfig());\n+\n+        // Having only one solver running at the same time is important for predicting solver status behaviour.\n+        SolverManager<TestdataSolution, Long> solverManager =\n+                SolverManager.create(solverConfig, new SolverManagerConfig().withParallelSolverCount(\"1\"));\n+\n+        Long firstProblemId = 1L;\n+        Long secondProblemId = 2L;\n+\n+        // Submit the first problem. Status changes from SOLVING_SCHEDULED to SOLVING_ACTIVE.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Second problem not yet submitted to solverManager, tries to terminate it leading to a debug output:\n+        // DEBUG Ignoring terminateEarly() call because problemId (1) is not solving.\n+        // Asserting a logger message was determined as being too complex for using only on this\n+        // one occurrence and would result in cluttering up the code. The output was checked manually.\n+        solverManager.terminateEarly(secondProblemId);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(secondProblemId));\n+        // Did not affect the actively solving job.\n+        assertSame(SolverStatus.SOLVING_ACTIVE, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Schedule second job while waiting for the first job to finish. It stays in the SOLVING_SCHEDULED status.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        // Terminate second job which is in scheduled status. The status changes from SOLVING_SCHEDULED to NOT_SOLVING\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+\n+        // Reschedule second job. It reintroduces it to the solverManager by changing status from NOT_SOLVING to\n+        // SOLVING_SCHEDULED in which it stays.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_SCHEDULED);\n+\n+        // Terminate the first job which triggers it to change it's status from SOLVING_ACTIVE to NOT_SOLVING.\n+        // Automatically starts working on the second job. Its status changes from STATUS_SCHEDULED to STATUS_ACTIVE.\n+        solverManager.terminateEarly(firstProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Terminate the second job, its status changes from SOLVING_ACTIVE to NOT_SOLVING. Both jobs stopped solving.\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Reintroduce the problems to solverManager and attempt to close them all at once using solverManager.close().\n+        // The first job's status changes from SOLVING_ACTIVE to NOT_SOLVING.\n+        // The second job's status changes from SOLVING_SCHEDULED to NOT_SOLVING.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        solverManager.close();\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+    }\n+\n+    private void waitForJobStatusChangeOrTimeout(SolverManager<TestdataSolution, Long> solverManager, Long problemId, SolverStatus expectedStatusChange) throws InterruptedException {\n+        long t = System.currentTimeMillis();\n+        long end = t + 5000;\n+        // Check every 5 milliseconds for solverJob status change for 5 seconds at maximum, otherwise time-out and fail.\n+        while (t < end) {\n+            if (solverManager.getSolverStatus(problemId) == expectedStatusChange) {\n+                return;\n+            }\n+            TimeUnit.MILLISECONDS.sleep(5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2566379e64bda368a86542664992e017edc5d24e"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzMyMzYyOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwODo1MjowNlrOFm2Ctg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxMTo1M1rOFoPQiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI3NTYzOA==", "bodyText": "5000 is risky on our slow jenkins machines (or a community user compiling while something else is running on his/her machine).\nI recommend just adding a @Timeout(600_000) on the test itself and do\nwhile (solverManager.getSolverStatus(problemId) != expectedStatusChange) {\n   Thread.sleep(100L);\n}\nreturn;\n\nCalling currentTimeMillis() every 5 milliseconds might not be as cheap as one would expect. And questionable on Windows that has a 17 millisecond clock granularity :)", "url": "https://github.com/kiegroup/optaplanner/pull/661#discussion_r376275638", "createdAt": "2020-02-07T08:52:06Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "diffHunk": "@@ -240,4 +245,87 @@ public void skipAhead() throws ExecutionException, InterruptedException {\n         assertTrue(eventCount.get() < 4);\n     }\n \n+    /**\n+     * In order to effectively test the terminateEarly() and close() methods there had to be a way how to make the job\n+     * status change in a deterministic way while solving jobs on separate threads. The test waits for a status change in\n+     * a loop and time-outs when it doesn't reach it's expected status.\n+     */\n+    @Ignore(\"https://issues.redhat.com/browse/PLANNER-1836\")\n+    @Test\n+    public void terminateEarlyAndClose() throws InterruptedException {\n+        final SolverConfig solverConfig = PlannerTestUtils.buildSolverConfig(TestdataSolution.class, TestdataEntity.class)\n+                .withPhases(new ConstructionHeuristicPhaseConfig(), new LocalSearchPhaseConfig());\n+\n+        // Having only one solver running at the same time is important for predicting solver status behaviour.\n+        SolverManager<TestdataSolution, Long> solverManager =\n+                SolverManager.create(solverConfig, new SolverManagerConfig().withParallelSolverCount(\"1\"));\n+\n+        Long firstProblemId = 1L;\n+        Long secondProblemId = 2L;\n+\n+        // Submit the first problem. Status changes from SOLVING_SCHEDULED to SOLVING_ACTIVE.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Second problem not yet submitted to solverManager, tries to terminate it leading to a debug output:\n+        // DEBUG Ignoring terminateEarly() call because problemId (1) is not solving.\n+        // Asserting a logger message was determined as being too complex for using only on this\n+        // one occurrence and would result in cluttering up the code. The output was checked manually.\n+        solverManager.terminateEarly(secondProblemId);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(secondProblemId));\n+        // Did not affect the actively solving job.\n+        assertSame(SolverStatus.SOLVING_ACTIVE, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Schedule second job while waiting for the first job to finish. It stays in the SOLVING_SCHEDULED status.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        // Terminate second job which is in scheduled status. The status changes from SOLVING_SCHEDULED to NOT_SOLVING\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+\n+        // Reschedule second job. It reintroduces it to the solverManager by changing status from NOT_SOLVING to\n+        // SOLVING_SCHEDULED in which it stays.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_SCHEDULED);\n+\n+        // Terminate the first job which triggers it to change it's status from SOLVING_ACTIVE to NOT_SOLVING.\n+        // Automatically starts working on the second job. Its status changes from STATUS_SCHEDULED to STATUS_ACTIVE.\n+        solverManager.terminateEarly(firstProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Terminate the second job, its status changes from SOLVING_ACTIVE to NOT_SOLVING. Both jobs stopped solving.\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Reintroduce the problems to solverManager and attempt to close them all at once using solverManager.close().\n+        // The first job's status changes from SOLVING_ACTIVE to NOT_SOLVING.\n+        // The second job's status changes from SOLVING_SCHEDULED to NOT_SOLVING.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        solverManager.close();\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+    }\n+\n+    private void waitForJobStatusChangeOrTimeout(SolverManager<TestdataSolution, Long> solverManager, Long problemId, SolverStatus expectedStatusChange) throws InterruptedException {\n+        long t = System.currentTimeMillis();\n+        long end = t + 5000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2566379e64bda368a86542664992e017edc5d24e"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI4MzI1Mw==", "bodyText": "@rsynek @triceo  That 100 milliseconds, I pulled out of thin air. But I presume michal did the same with the 5 milliseconds. We should figure out a good standard for that number for for such \"quick polling\" patterns used in tests.\nI wouldn't make it less than 20 milliseconds due to clock granularity on common machines. But 100ms is probably too long, now that I think about it. Having 200 tests that do quick polling with 100ms, means they run at least for 20 seconds.\nHow about we use 20ms as the quick polling standard? Wdyt?", "url": "https://github.com/kiegroup/optaplanner/pull/661#discussion_r376283253", "createdAt": "2020-02-07T09:10:00Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "diffHunk": "@@ -240,4 +245,87 @@ public void skipAhead() throws ExecutionException, InterruptedException {\n         assertTrue(eventCount.get() < 4);\n     }\n \n+    /**\n+     * In order to effectively test the terminateEarly() and close() methods there had to be a way how to make the job\n+     * status change in a deterministic way while solving jobs on separate threads. The test waits for a status change in\n+     * a loop and time-outs when it doesn't reach it's expected status.\n+     */\n+    @Ignore(\"https://issues.redhat.com/browse/PLANNER-1836\")\n+    @Test\n+    public void terminateEarlyAndClose() throws InterruptedException {\n+        final SolverConfig solverConfig = PlannerTestUtils.buildSolverConfig(TestdataSolution.class, TestdataEntity.class)\n+                .withPhases(new ConstructionHeuristicPhaseConfig(), new LocalSearchPhaseConfig());\n+\n+        // Having only one solver running at the same time is important for predicting solver status behaviour.\n+        SolverManager<TestdataSolution, Long> solverManager =\n+                SolverManager.create(solverConfig, new SolverManagerConfig().withParallelSolverCount(\"1\"));\n+\n+        Long firstProblemId = 1L;\n+        Long secondProblemId = 2L;\n+\n+        // Submit the first problem. Status changes from SOLVING_SCHEDULED to SOLVING_ACTIVE.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Second problem not yet submitted to solverManager, tries to terminate it leading to a debug output:\n+        // DEBUG Ignoring terminateEarly() call because problemId (1) is not solving.\n+        // Asserting a logger message was determined as being too complex for using only on this\n+        // one occurrence and would result in cluttering up the code. The output was checked manually.\n+        solverManager.terminateEarly(secondProblemId);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(secondProblemId));\n+        // Did not affect the actively solving job.\n+        assertSame(SolverStatus.SOLVING_ACTIVE, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Schedule second job while waiting for the first job to finish. It stays in the SOLVING_SCHEDULED status.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        // Terminate second job which is in scheduled status. The status changes from SOLVING_SCHEDULED to NOT_SOLVING\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+\n+        // Reschedule second job. It reintroduces it to the solverManager by changing status from NOT_SOLVING to\n+        // SOLVING_SCHEDULED in which it stays.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_SCHEDULED);\n+\n+        // Terminate the first job which triggers it to change it's status from SOLVING_ACTIVE to NOT_SOLVING.\n+        // Automatically starts working on the second job. Its status changes from STATUS_SCHEDULED to STATUS_ACTIVE.\n+        solverManager.terminateEarly(firstProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Terminate the second job, its status changes from SOLVING_ACTIVE to NOT_SOLVING. Both jobs stopped solving.\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Reintroduce the problems to solverManager and attempt to close them all at once using solverManager.close().\n+        // The first job's status changes from SOLVING_ACTIVE to NOT_SOLVING.\n+        // The second job's status changes from SOLVING_SCHEDULED to NOT_SOLVING.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        solverManager.close();\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+    }\n+\n+    private void waitForJobStatusChangeOrTimeout(SolverManager<TestdataSolution, Long> solverManager, Long problemId, SolverStatus expectedStatusChange) throws InterruptedException {\n+        long t = System.currentTimeMillis();\n+        long end = t + 5000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI3NTYzOA=="}, "originalCommit": {"oid": "2566379e64bda368a86542664992e017edc5d24e"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI4Mzg2MA==", "bodyText": "How long does calling a REST method take? That polling should not be able to DDOS a slow rest service.", "url": "https://github.com/kiegroup/optaplanner/pull/661#discussion_r376283860", "createdAt": "2020-02-07T09:11:11Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "diffHunk": "@@ -240,4 +245,87 @@ public void skipAhead() throws ExecutionException, InterruptedException {\n         assertTrue(eventCount.get() < 4);\n     }\n \n+    /**\n+     * In order to effectively test the terminateEarly() and close() methods there had to be a way how to make the job\n+     * status change in a deterministic way while solving jobs on separate threads. The test waits for a status change in\n+     * a loop and time-outs when it doesn't reach it's expected status.\n+     */\n+    @Ignore(\"https://issues.redhat.com/browse/PLANNER-1836\")\n+    @Test\n+    public void terminateEarlyAndClose() throws InterruptedException {\n+        final SolverConfig solverConfig = PlannerTestUtils.buildSolverConfig(TestdataSolution.class, TestdataEntity.class)\n+                .withPhases(new ConstructionHeuristicPhaseConfig(), new LocalSearchPhaseConfig());\n+\n+        // Having only one solver running at the same time is important for predicting solver status behaviour.\n+        SolverManager<TestdataSolution, Long> solverManager =\n+                SolverManager.create(solverConfig, new SolverManagerConfig().withParallelSolverCount(\"1\"));\n+\n+        Long firstProblemId = 1L;\n+        Long secondProblemId = 2L;\n+\n+        // Submit the first problem. Status changes from SOLVING_SCHEDULED to SOLVING_ACTIVE.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Second problem not yet submitted to solverManager, tries to terminate it leading to a debug output:\n+        // DEBUG Ignoring terminateEarly() call because problemId (1) is not solving.\n+        // Asserting a logger message was determined as being too complex for using only on this\n+        // one occurrence and would result in cluttering up the code. The output was checked manually.\n+        solverManager.terminateEarly(secondProblemId);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(secondProblemId));\n+        // Did not affect the actively solving job.\n+        assertSame(SolverStatus.SOLVING_ACTIVE, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Schedule second job while waiting for the first job to finish. It stays in the SOLVING_SCHEDULED status.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        // Terminate second job which is in scheduled status. The status changes from SOLVING_SCHEDULED to NOT_SOLVING\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+\n+        // Reschedule second job. It reintroduces it to the solverManager by changing status from NOT_SOLVING to\n+        // SOLVING_SCHEDULED in which it stays.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_SCHEDULED);\n+\n+        // Terminate the first job which triggers it to change it's status from SOLVING_ACTIVE to NOT_SOLVING.\n+        // Automatically starts working on the second job. Its status changes from STATUS_SCHEDULED to STATUS_ACTIVE.\n+        solverManager.terminateEarly(firstProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Terminate the second job, its status changes from SOLVING_ACTIVE to NOT_SOLVING. Both jobs stopped solving.\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Reintroduce the problems to solverManager and attempt to close them all at once using solverManager.close().\n+        // The first job's status changes from SOLVING_ACTIVE to NOT_SOLVING.\n+        // The second job's status changes from SOLVING_SCHEDULED to NOT_SOLVING.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        solverManager.close();\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+    }\n+\n+    private void waitForJobStatusChangeOrTimeout(SolverManager<TestdataSolution, Long> solverManager, Long problemId, SolverStatus expectedStatusChange) throws InterruptedException {\n+        long t = System.currentTimeMillis();\n+        long end = t + 5000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI3NTYzOA=="}, "originalCommit": {"oid": "2566379e64bda368a86542664992e017edc5d24e"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczNzM1NQ==", "bodyText": "@rsynek These comments didn't make it in (nor have a comment to reject them), I 'll provide a Pr for it together with the issue itself.", "url": "https://github.com/kiegroup/optaplanner/pull/661#discussion_r377737355", "createdAt": "2020-02-11T16:11:53Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "diffHunk": "@@ -240,4 +245,87 @@ public void skipAhead() throws ExecutionException, InterruptedException {\n         assertTrue(eventCount.get() < 4);\n     }\n \n+    /**\n+     * In order to effectively test the terminateEarly() and close() methods there had to be a way how to make the job\n+     * status change in a deterministic way while solving jobs on separate threads. The test waits for a status change in\n+     * a loop and time-outs when it doesn't reach it's expected status.\n+     */\n+    @Ignore(\"https://issues.redhat.com/browse/PLANNER-1836\")\n+    @Test\n+    public void terminateEarlyAndClose() throws InterruptedException {\n+        final SolverConfig solverConfig = PlannerTestUtils.buildSolverConfig(TestdataSolution.class, TestdataEntity.class)\n+                .withPhases(new ConstructionHeuristicPhaseConfig(), new LocalSearchPhaseConfig());\n+\n+        // Having only one solver running at the same time is important for predicting solver status behaviour.\n+        SolverManager<TestdataSolution, Long> solverManager =\n+                SolverManager.create(solverConfig, new SolverManagerConfig().withParallelSolverCount(\"1\"));\n+\n+        Long firstProblemId = 1L;\n+        Long secondProblemId = 2L;\n+\n+        // Submit the first problem. Status changes from SOLVING_SCHEDULED to SOLVING_ACTIVE.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Second problem not yet submitted to solverManager, tries to terminate it leading to a debug output:\n+        // DEBUG Ignoring terminateEarly() call because problemId (1) is not solving.\n+        // Asserting a logger message was determined as being too complex for using only on this\n+        // one occurrence and would result in cluttering up the code. The output was checked manually.\n+        solverManager.terminateEarly(secondProblemId);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(secondProblemId));\n+        // Did not affect the actively solving job.\n+        assertSame(SolverStatus.SOLVING_ACTIVE, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Schedule second job while waiting for the first job to finish. It stays in the SOLVING_SCHEDULED status.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        // Terminate second job which is in scheduled status. The status changes from SOLVING_SCHEDULED to NOT_SOLVING\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+\n+        // Reschedule second job. It reintroduces it to the solverManager by changing status from NOT_SOLVING to\n+        // SOLVING_SCHEDULED in which it stays.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_SCHEDULED);\n+\n+        // Terminate the first job which triggers it to change it's status from SOLVING_ACTIVE to NOT_SOLVING.\n+        // Automatically starts working on the second job. Its status changes from STATUS_SCHEDULED to STATUS_ACTIVE.\n+        solverManager.terminateEarly(firstProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Terminate the second job, its status changes from SOLVING_ACTIVE to NOT_SOLVING. Both jobs stopped solving.\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Reintroduce the problems to solverManager and attempt to close them all at once using solverManager.close().\n+        // The first job's status changes from SOLVING_ACTIVE to NOT_SOLVING.\n+        // The second job's status changes from SOLVING_SCHEDULED to NOT_SOLVING.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        solverManager.close();\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+    }\n+\n+    private void waitForJobStatusChangeOrTimeout(SolverManager<TestdataSolution, Long> solverManager, Long problemId, SolverStatus expectedStatusChange) throws InterruptedException {\n+        long t = System.currentTimeMillis();\n+        long end = t + 5000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI3NTYzOA=="}, "originalCommit": {"oid": "2566379e64bda368a86542664992e017edc5d24e"}, "originalPosition": 105}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4581, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}