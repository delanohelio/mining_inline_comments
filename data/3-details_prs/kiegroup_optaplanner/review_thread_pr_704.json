{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5NTkyODMw", "number": 704, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzo0ODowNFrODitSDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNDozOTozN1rOEEU4ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzIwMDc2OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzo0ODowNFrOFuGqHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMToyNjo0M1rOFun9uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4NzkwMA==", "bodyText": "Let's not include DRL code in here. (Also applies below.) But I appreciate the effort to make the review easier. :-)", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383887900", "createdAt": "2020-02-25T13:48:04Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzMzU5NQ==", "bodyText": "Yes, that was meant as a help for myself and potentially the reviewer. I will remove it after I fix all the issues.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r384433595", "createdAt": "2020-02-26T11:26:43Z", "author": {"login": "michaltomco"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4NzkwMA=="}, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzIwNDY1OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzo0ODo1OVrOFuGsSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzo0ODo1OVrOFuGsSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4ODQ1OA==", "bodyText": "Don't you get this automatically? from() only gives you initialized entities by default.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383888458", "createdAt": "2020-02-25T13:48:59Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzIwNjY3OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzo0OTozMlrOFuGtcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzo0OTozMlrOFuGtcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4ODc1Mg==", "bodyText": "In this case,  .join(Exam.class, equal(Exam::getPeriod)) is a useful shorthand.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383888752", "createdAt": "2020-02-25T13:49:32Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzIyMDMyOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzo1MzowMVrOFuG1pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoyODoxNVrOFuIIWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5MDg1Mg==", "bodyText": "I don't see Period actually used anywhere in this constraint. Maybe you're just interested in knowing if there is a Period that has an Exam? If so, use ifExists() - will work miracles for performance of the constraint.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383890852", "createdAt": "2020-02-25T13:53:01Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxMjAyNQ==", "bodyText": "Most likely it's a bug, though. The period is actually used in the DRL. Could it be better to start the stream with from(Period.class) instead? It would match the DRL more naturally then.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383912025", "createdAt": "2020-02-25T14:28:15Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5MDg1Mg=="}, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzI2NTE0OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDowNTowN1rOFuHRLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDowNTowN1rOFuHRLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5NzkwMA==", "bodyText": "This is no longer necessary, right. leftExam.getPeriod() already isn't null, and rightExam.getPeriod() is joined where equal.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383897900", "createdAt": "2020-02-25T14:05:07Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzI3MjMzOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDowNzowN1rOFuHVpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDowNzowN1rOFuHVpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5OTA0Ng==", "bodyText": "Can  getPeriod() be null if getPeriodIndex() already worked fine?", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383899046", "createdAt": "2020-02-25T14:07:07Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzI3OTczOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDowODo1NVrOFuHZ-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDowODo1NVrOFuHZ-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwMDE1NQ==", "bodyText": "Can't you do this using Joiners.equal() within the preceding join()?", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383900155", "createdAt": "2020-02-25T14:08:55Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic))\n+                .filter((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null)\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .filter((roomPenalty, leftExam, rightExam) -> leftExam.getTopic().equals(rightExam.getTopic()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzMwMzExOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoxNTowNVrOFuHoLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDozMjowNlrOFuIRog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwMzc5MA==", "bodyText": "You use this Math.abs(...) >/= 1 construct frequently. I'd extract it to a separate method and reuse.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383903790", "createdAt": "2020-02-25T14:15:05Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic))\n+                .filter((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null)\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .filter((roomPenalty, leftExam, rightExam) -> leftExam.getTopic().equals(rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    // Two exams in a row which share students\n+//    rule \"twoExamsInARow\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) == 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) == 1)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT, (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Two exams in a day which share students\n+//    rule \"twoExamsInADay\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) > 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)\n+                .penalize(\"Two exams in a day\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Exams which share students have to few periods between them\n+//    rule \"periodSpread\"\n+//    when\n+//    $constraintConfiguration : ExaminationConstraintConfiguration()\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != null,\n+//                      Math.abs($leftPeriodIndex - periodIndex) < ($constraintConfiguration.getPeriodSpreadLength() + 1))\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxNDQwMg==", "bodyText": "Also same comment regarding ifExists() as with twoExamsInADay.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383914402", "createdAt": "2020-02-25T14:32:06Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic))\n+                .filter((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null)\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .filter((roomPenalty, leftExam, rightExam) -> leftExam.getTopic().equals(rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    // Two exams in a row which share students\n+//    rule \"twoExamsInARow\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) == 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) == 1)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT, (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Two exams in a day which share students\n+//    rule \"twoExamsInADay\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) > 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)\n+                .penalize(\"Two exams in a day\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Exams which share students have to few periods between them\n+//    rule \"periodSpread\"\n+//    when\n+//    $constraintConfiguration : ExaminationConstraintConfiguration()\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != null,\n+//                      Math.abs($leftPeriodIndex - periodIndex) < ($constraintConfiguration.getPeriodSpreadLength() + 1))\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwMzc5MA=="}, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 282}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzMwOTUxOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoxNjo0M1rOFuHsCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoxNjo0M1rOFuHsCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwNDc3Ng==", "bodyText": "Personally, I like to see all equals() joiners first, but that's mostly aesthetic.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383904776", "createdAt": "2020-02-25T14:16:43Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic))\n+                .filter((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null)\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .filter((roomPenalty, leftExam, rightExam) -> leftExam.getTopic().equals(rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    // Two exams in a row which share students\n+//    rule \"twoExamsInARow\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) == 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) == 1)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT, (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Two exams in a day which share students\n+//    rule \"twoExamsInADay\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) > 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)\n+                .penalize(\"Two exams in a day\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Exams which share students have to few periods between them\n+//    rule \"periodSpread\"\n+//    when\n+//    $constraintConfiguration : ExaminationConstraintConfiguration()\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != null,\n+//                      Math.abs($leftPeriodIndex - periodIndex) < ($constraintConfiguration.getPeriodSpreadLength() + 1))\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)\n+                .penalize(\"Period spread\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Several exams in the same room and period have different durations\n+//    rule \"mixedDurations\"\n+//    when\n+//    $leftExam : Exam($leftId : id, period != null, $period : period, room != null, $room : room,\n+//                     $leftTopicDuration : topicDuration)\n+//    // 4 mixed durations of 100, 150, 200 and 200 should only result in 2 penalty's (for 100&150 and 100&200)\n+//    // leftExam has lowest id of the period+room combo\n+//    not Exam(period == $period, room == $room, id < $leftId)\n+//    // rightExam has a different duration\n+//    $rightExam : Exam(period == $period, room == $room, id > $leftId,\n+//                      topicDuration != $leftTopicDuration,\n+//                      $rightId : id, $rightTopicDuration : topicDuration\n+//    )\n+//    // rightExam has the lowest id of the period+room+rightDuration combo\n+//    not Exam(period == $period, room == $room, id < $rightId,\n+//            topicDuration == $rightTopicDuration\n+//    )\n+//    then\n+//        scoreHolder.penalize(kcontext);\n+//    end\n+    private Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifExists(Exam.class, equal(Exam::getRoom, Exam::getRoom))\n+                .ifNotExistsOther(Exam.class,\n+                                  equal(Exam::getPeriod, Exam::getPeriod),\n+                                  equal(Exam::getRoom, Exam::getRoom),\n+                                  lessThan(Exam::getId, Exam::getId))\n+                .join(Exam.class,\n+                      equal(Exam::getPeriod, Exam::getPeriod),\n+                      equal(Exam::getRoom, Exam::getRoom),\n+                      greaterThan(Exam::getId, Exam::getId))\n+                .filter((leftExam, rightExam) -> rightExam.getTopicDuration() != leftExam.getTopicDuration())\n+                .ifNotExists(Exam.class,\n+                             equal((leftExam, rightExam) -> rightExam.getPeriod(), Exam::getPeriod),\n+                             equal((leftExam, rightExam) -> rightExam.getRoom(), Exam::getRoom),\n+                             greaterThan((leftExam, rightExam) -> rightExam.getId(), Exam::getId),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzMxMzA0OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/examination/solver/examinationSolverConfig.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoxNzozMVrOFuHuDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoxNzozMVrOFuHuDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwNTI5NQ==", "bodyText": "Formatting, please. See other examples.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383905295", "createdAt": "2020-02-25T14:17:31Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/examination/solver/examinationSolverConfig.xml", "diffHunk": "@@ -9,6 +9,7 @@\n   <entityClass>org.optaplanner.examples.examination.domain.FollowingExam</entityClass>\n \n   <scoreDirectorFactory>\n+<!--    <constraintProviderClass>org.optaplanner.examples.examination.optional.score.examinationConstraintProvider</constraintProviderClass>-->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzMxNzQyOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/examination/solver/examinationSolverConfig.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoxODozNlrOFuHwtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoxODozNlrOFuHwtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwNTk3NQ==", "bodyText": "Has this been through assertion score director and FULL_ASSERT? Since I don't see it commented out in the example, I assume not.\nDo it. It will tell you whether or not your implementation is identical to DRL.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383905975", "createdAt": "2020-02-25T14:18:36Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/examination/solver/examinationSolverConfig.xml", "diffHunk": "@@ -9,6 +9,7 @@\n   <entityClass>org.optaplanner.examples.examination.domain.FollowingExam</entityClass>\n \n   <scoreDirectorFactory>\n+<!--    <constraintProviderClass>org.optaplanner.examples.examination.optional.score.examinationConstraintProvider</constraintProviderClass>-->\n     <scoreDrl>org/optaplanner/examples/examination/solver/examinationScoreRules.drl</scoreDrl>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzM0Mjg3OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoyNTowNVrOFuIAQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoyNTowNVrOFuIAQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwOTk1Mg==", "bodyText": "Also, this from(Exam).join(Exam) can be replaced by .fromUniquePair(Exam.class, equal(...))", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383909952", "createdAt": "2020-02-25T14:25:05Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzM0ODk1OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoyNjozMVrOFuIELg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoyNjozMVrOFuIELg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxMDk1OA==", "bodyText": "Most likely not necessary, as the rule doesn't use it either.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383910958", "createdAt": "2020-02-25T14:26:31Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzM3NDc0OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDozMzoxOVrOFuIUNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDozMzoxOVrOFuIUNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxNTA2MQ==", "bodyText": "Perhaps could be replaced by ifExists(), but then the constraint may no longer be functionally equivalent to the DRL. FULL_ASSERT would tell.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383915061", "createdAt": "2020-02-25T14:33:19Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic))\n+                .filter((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null)\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .filter((roomPenalty, leftExam, rightExam) -> leftExam.getTopic().equals(rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    // Two exams in a row which share students\n+//    rule \"twoExamsInARow\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) == 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 234}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzM3NjQwOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDozMzo0NFrOFuIVNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDozMzo0NFrOFuIVNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxNTMxOQ==", "bodyText": "Dtto. on ifExists().", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383915319", "createdAt": "2020-02-25T14:33:44Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic))\n+                .filter((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null)\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .filter((roomPenalty, leftExam, rightExam) -> leftExam.getTopic().equals(rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    // Two exams in a row which share students\n+//    rule \"twoExamsInARow\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) == 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) == 1)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT, (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Two exams in a day which share students\n+//    rule \"twoExamsInADay\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) > 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTE1MTM0OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzo0MzowNFrOFuZZaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzo0MzowNFrOFuZZaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NDkyMQ==", "bodyText": "Why is this here? I don't see it in the DRL.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r384194921", "createdAt": "2020-02-25T23:43:04Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic))\n+                .filter((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null)\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .filter((roomPenalty, leftExam, rightExam) -> leftExam.getTopic().equals(rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    // Two exams in a row which share students\n+//    rule \"twoExamsInARow\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) == 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) == 1)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT, (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Two exams in a day which share students\n+//    rule \"twoExamsInADay\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) > 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)\n+                .penalize(\"Two exams in a day\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Exams which share students have to few periods between them\n+//    rule \"periodSpread\"\n+//    when\n+//    $constraintConfiguration : ExaminationConstraintConfiguration()\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != null,\n+//                      Math.abs($leftPeriodIndex - periodIndex) < ($constraintConfiguration.getPeriodSpreadLength() + 1))\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)\n+                .penalize(\"Period spread\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Several exams in the same room and period have different durations\n+//    rule \"mixedDurations\"\n+//    when\n+//    $leftExam : Exam($leftId : id, period != null, $period : period, room != null, $room : room,\n+//                     $leftTopicDuration : topicDuration)\n+//    // 4 mixed durations of 100, 150, 200 and 200 should only result in 2 penalty's (for 100&150 and 100&200)\n+//    // leftExam has lowest id of the period+room combo\n+//    not Exam(period == $period, room == $room, id < $leftId)\n+//    // rightExam has a different duration\n+//    $rightExam : Exam(period == $period, room == $room, id > $leftId,\n+//                      topicDuration != $leftTopicDuration,\n+//                      $rightId : id, $rightTopicDuration : topicDuration\n+//    )\n+//    // rightExam has the lowest id of the period+room+rightDuration combo\n+//    not Exam(period == $period, room == $room, id < $rightId,\n+//            topicDuration == $rightTopicDuration\n+//    )\n+//    then\n+//        scoreHolder.penalize(kcontext);\n+//    end\n+    private Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifExists(Exam.class, equal(Exam::getRoom, Exam::getRoom))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 311}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTE1NjY5OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzo0NTozMFrOFuZckA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzo0NTozMFrOFuZckA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NTcyOA==", "bodyText": "Since both left and right are the same type and we're joining on the same field, equal() can lose its second argument.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r384195728", "createdAt": "2020-02-25T23:45:30Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic))\n+                .filter((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null)\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .filter((roomPenalty, leftExam, rightExam) -> leftExam.getTopic().equals(rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    // Two exams in a row which share students\n+//    rule \"twoExamsInARow\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) == 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) == 1)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT, (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Two exams in a day which share students\n+//    rule \"twoExamsInADay\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) > 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)\n+                .penalize(\"Two exams in a day\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Exams which share students have to few periods between them\n+//    rule \"periodSpread\"\n+//    when\n+//    $constraintConfiguration : ExaminationConstraintConfiguration()\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != null,\n+//                      Math.abs($leftPeriodIndex - periodIndex) < ($constraintConfiguration.getPeriodSpreadLength() + 1))\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)\n+                .penalize(\"Period spread\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Several exams in the same room and period have different durations\n+//    rule \"mixedDurations\"\n+//    when\n+//    $leftExam : Exam($leftId : id, period != null, $period : period, room != null, $room : room,\n+//                     $leftTopicDuration : topicDuration)\n+//    // 4 mixed durations of 100, 150, 200 and 200 should only result in 2 penalty's (for 100&150 and 100&200)\n+//    // leftExam has lowest id of the period+room combo\n+//    not Exam(period == $period, room == $room, id < $leftId)\n+//    // rightExam has a different duration\n+//    $rightExam : Exam(period == $period, room == $room, id > $leftId,\n+//                      topicDuration != $leftTopicDuration,\n+//                      $rightId : id, $rightTopicDuration : topicDuration\n+//    )\n+//    // rightExam has the lowest id of the period+room+rightDuration combo\n+//    not Exam(period == $period, room == $room, id < $rightId,\n+//            topicDuration == $rightTopicDuration\n+//    )\n+//    then\n+//        scoreHolder.penalize(kcontext);\n+//    end\n+    private Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifExists(Exam.class, equal(Exam::getRoom, Exam::getRoom))\n+                .ifNotExistsOther(Exam.class,\n+                                  equal(Exam::getPeriod, Exam::getPeriod),\n+                                  equal(Exam::getRoom, Exam::getRoom),\n+                                  lessThan(Exam::getId, Exam::getId))\n+                .join(Exam.class,\n+                      equal(Exam::getPeriod, Exam::getPeriod),\n+                      equal(Exam::getRoom, Exam::getRoom),\n+                      greaterThan(Exam::getId, Exam::getId))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063"}, "originalPosition": 319}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDI4NDM4OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOToxMTozMlrOFvKPag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOToxMTozMlrOFvKPag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk5NTE3OA==", "bodyText": "Choose a better name for the method. Don't describe the code, describe the purpose.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r384995178", "createdAt": "2020-02-27T09:11:32Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUniquePair(Exam.class, equal(Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Period.class)\n+                .join(Exam.class, equal(Function.identity(), Exam::getPeriod))\n+                .join(Room.class, equal((period, exam) -> exam.getRoom(), Function.identity()))\n+                .groupBy((period, exam, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((period, exam, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                      filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                      filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                      filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic),\n+                      filtering((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null))\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod),\n+                      equal((roomPenalty, leftExam) -> leftExam.getTopic(), Exam::getTopic))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    // Two exams in a row which share students\n+//    rule \"twoExamsInARow\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) == 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                      filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                      filtering((topicConflict, leftExam, rightExam) -> getAbsoluteValue(leftExam, rightExam) == 1))\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT, (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Two exams in a day which share students\n+//    rule \"twoExamsInADay\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) > 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                      filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                      filtering((topicConflict, leftExam, rightExam) -> getAbsoluteValue(leftExam, rightExam) > 1))\n+                .penalize(\"Two exams in a day\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Exams which share students have to few periods between them\n+//    rule \"periodSpread\"\n+//    when\n+//    $constraintConfiguration : ExaminationConstraintConfiguration()\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != null,\n+//                      Math.abs($leftPeriodIndex - periodIndex) < ($constraintConfiguration.getPeriodSpreadLength() + 1))\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                      filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                      filtering((topicConflict, leftExam, rightExam) -> getAbsoluteValue(leftExam, rightExam) > 1))\n+                .penalize(\"Period spread\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Several exams in the same room and period have different durations\n+//    rule \"mixedDurations\"\n+//    when\n+//    $leftExam : Exam($leftId : id, period != null, $period : period, room != null, $room : room,\n+//                     $leftTopicDuration : topicDuration)\n+//    // 4 mixed durations of 100, 150, 200 and 200 should only result in 2 penalty's (for 100&150 and 100&200)\n+//    // leftExam has lowest id of the period+room combo\n+//    not Exam(period == $period, room == $room, id < $leftId)\n+//    // rightExam has a different duration\n+//    $rightExam : Exam(period == $period, room == $room, id > $leftId,\n+//                      topicDuration != $leftTopicDuration,\n+//                      $rightId : id, $rightTopicDuration : topicDuration\n+//    )\n+//    // rightExam has the lowest id of the period+room+rightDuration combo\n+//    not Exam(period == $period, room == $room, id < $rightId,\n+//            topicDuration == $rightTopicDuration\n+//    )\n+//    then\n+//        scoreHolder.penalize(kcontext);\n+//    end\n+    private Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifNotExistsOther(Exam.class,\n+                                  equal(Exam::getPeriod, Exam::getPeriod),\n+                                  equal(Exam::getRoom, Exam::getRoom),\n+                                  lessThan(Exam::getId, Exam::getId))\n+                .join(Exam.class,\n+                      equal(Exam::getPeriod),\n+                      equal(Exam::getRoom),\n+                      greaterThan(Exam::getId),\n+                      filtering((leftExam, rightExam) -> rightExam.getTopicDuration() != leftExam.getTopicDuration()))\n+                .ifNotExists(Exam.class,\n+                             equal((leftExam, rightExam) -> rightExam.getPeriod(), Exam::getPeriod),\n+                             equal((leftExam, rightExam) -> rightExam.getRoom(), Exam::getRoom),\n+                             equal((leftExam, rightExam) -> rightExam.getTopicDuration(), Exam::getTopicDuration),\n+                             greaterThan((leftExam, rightExam) -> rightExam.getId(), Exam::getId))\n+                .penalize(\"Mixed durations\", HardSoftScore.ONE_SOFT);\n+    }\n+\n+    //    // Larger Exams towards the beginning of the examination session\n+//    rule \"frontLoad\"\n+//    when\n+//    $exam : Exam(topicFrontLoadLarge == true, periodFrontLoadLast == true)\n+//    then\n+//        scoreHolder.penalize(kcontext);\n+//    end\n+    private Constraint frontLoad(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.isTopicFrontLoadLarge() && exam.isPeriodFrontLoadLast())\n+                .penalize(\"Front load\", HardSoftScore.ONE_SOFT);\n+    }\n+\n+    //    // Period Penalty\n+//    rule \"periodPenalty\"\n+//    when\n+//    $period : Period(penalty != 0)\n+//    $exam: Exam(period == $period)\n+//    then\n+//        scoreHolder.addSoftConstraintMatch(kcontext, - $period.getPenalty());\n+//    end\n+    private Constraint periodPenalty(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Period.class)\n+                .filter(period -> period.getPenalty() != 0)\n+                .ifExists(Exam.class, equal(Function.identity(), Exam::getPeriod))\n+                .penalize(\"Period penalty\", HardSoftScore.ONE_SOFT, Period::getPenalty);\n+    }\n+\n+    //    // Room Penalty\n+//    rule \"roomPenalty\"\n+//    when\n+//    $room : Room(penalty != 0)\n+//    $exam: Exam(room == $room)\n+//    then\n+//        scoreHolder.addSoftConstraintMatch(kcontext, - $room.getPenalty());\n+//    end\n+    private Constraint roomPenalty(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Room.class)\n+                .filter(room -> room.getPenalty() != 0)\n+                .ifExists(Exam.class, equal(Function.identity(), Exam::getRoom))\n+                .penalize(\"Room penalty\", HardSoftScore.ONE_SOFT, Room::getPenalty);\n+    }\n+\n+    private int getAbsoluteValue(Exam leftExam, Exam rightExam) {\n+        return Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58619aa65d2026f4dc6957b6ef1fc271a24205f9"}, "originalPosition": 368}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzQ1NjUwOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMDozODoyMFrOGZ85eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMDozODoyMFrOGZ85eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NTMzOA==", "bodyText": "I see that there is a ConstraintConfiguration available. Yet, you still use penalize() instead of penalizeConfigurable(). I suggest you change that, @michaltomco .", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r429865338", "createdAt": "2020-05-25T10:38:20Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package org.optaplanner.examples.examination.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.ExaminationConstraintConfiguration;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+\n+                // Soft constraints\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    protected Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Conflicting exams in same period\",\n+                        HardSoftScore.ONE_HARD,\n+                        (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    protected Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Room.class)\n+                .join(Exam.class, equal(Function.identity(), Exam::getRoom))\n+                .join(Period.class, equal((room, exam) -> exam.getPeriod(), Function.identity()))\n+                .groupBy((room, exam, period) -> room,\n+                        (room, exam, period) -> period,\n+                        ConstraintCollectors.sum((period, exam, room) -> exam.getTopicStudentSize()))\n+                .filter((room, period, totalStudentSize) -> totalStudentSize > room.getCapacity())\n+                .penalize(\"Room capacity too small\",\n+                        HardSoftScore.ONE_HARD,\n+                        (room, period, totalStudentSize) -> totalStudentSize - room.getCapacity());\n+    }\n+\n+    protected Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod() != rightExam.getPeriod()))\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod().equals(rightExam.getPeriod())))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam,\n+                                rightExam) -> leftExam.getPeriod().getPeriodIndex() <= rightExam.getPeriod().getPeriodIndex()))\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                        equal(RoomPenalty::getTopic, Exam::getTopic),\n+                        filtering((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null))\n+                .join(Exam.class,\n+                        equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                        equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod),\n+                        filtering((roomPenalty, leftExam, rightExam) -> leftExam.getTopic() != rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) == 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInARowPenalty());\n+    }\n+\n+    protected Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        // Find exams in a day, but not being held right after each other. That case is handled in the twoExamsInARow constraint.\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) > 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a day\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInADayPenalty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9645c0ff8064317c15581721b2c778423e3896"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzY4MTQzOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjowODoyN1rOGZ_DmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjoyODoxMVrOGZ_j8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkwMDY5Nw==", "bodyText": "return constraintFactory.from(Exam.class)\n            .ifNotExists(Exam.class,\n                    equal(Exam::getPeriod),\n                    equal(Exam::getRoom),\n                    lessThan(Exam::getId))\n\nBut that won't change much, if anything.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r429900697", "createdAt": "2020-05-25T12:08:27Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package org.optaplanner.examples.examination.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.ExaminationConstraintConfiguration;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+\n+                // Soft constraints\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    protected Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Conflicting exams in same period\",\n+                        HardSoftScore.ONE_HARD,\n+                        (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    protected Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Room.class)\n+                .join(Exam.class, equal(Function.identity(), Exam::getRoom))\n+                .join(Period.class, equal((room, exam) -> exam.getPeriod(), Function.identity()))\n+                .groupBy((room, exam, period) -> room,\n+                        (room, exam, period) -> period,\n+                        ConstraintCollectors.sum((period, exam, room) -> exam.getTopicStudentSize()))\n+                .filter((room, period, totalStudentSize) -> totalStudentSize > room.getCapacity())\n+                .penalize(\"Room capacity too small\",\n+                        HardSoftScore.ONE_HARD,\n+                        (room, period, totalStudentSize) -> totalStudentSize - room.getCapacity());\n+    }\n+\n+    protected Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod() != rightExam.getPeriod()))\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod().equals(rightExam.getPeriod())))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam,\n+                                rightExam) -> leftExam.getPeriod().getPeriodIndex() <= rightExam.getPeriod().getPeriodIndex()))\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                        equal(RoomPenalty::getTopic, Exam::getTopic),\n+                        filtering((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null))\n+                .join(Exam.class,\n+                        equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                        equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod),\n+                        filtering((roomPenalty, leftExam, rightExam) -> leftExam.getTopic() != rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) == 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInARowPenalty());\n+    }\n+\n+    protected Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        // Find exams in a day, but not being held right after each other. That case is handled in the twoExamsInARow constraint.\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) > 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a day\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInADayPenalty());\n+    }\n+\n+    protected Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)\n+                .join(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal((config, topicConflict) -> topicConflict.getLeftTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((config, topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((config, topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam,\n+                                        rightExam) < (config.getPeriodSpreadLength() + 1)))\n+                .penalize(\"Period spread\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (config, topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifNotExistsOther(Exam.class,\n+                        equal(Exam::getPeriod, Exam::getPeriod),\n+                        equal(Exam::getRoom, Exam::getRoom),\n+                        lessThan(Exam::getId, Exam::getId))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9645c0ff8064317c15581721b2c778423e3896"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkwODk3Nw==", "bodyText": "Also, I'd put the lessThan filter first. Will eliminate many things quickly.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r429908977", "createdAt": "2020-05-25T12:28:11Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package org.optaplanner.examples.examination.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.ExaminationConstraintConfiguration;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+\n+                // Soft constraints\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    protected Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Conflicting exams in same period\",\n+                        HardSoftScore.ONE_HARD,\n+                        (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    protected Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Room.class)\n+                .join(Exam.class, equal(Function.identity(), Exam::getRoom))\n+                .join(Period.class, equal((room, exam) -> exam.getPeriod(), Function.identity()))\n+                .groupBy((room, exam, period) -> room,\n+                        (room, exam, period) -> period,\n+                        ConstraintCollectors.sum((period, exam, room) -> exam.getTopicStudentSize()))\n+                .filter((room, period, totalStudentSize) -> totalStudentSize > room.getCapacity())\n+                .penalize(\"Room capacity too small\",\n+                        HardSoftScore.ONE_HARD,\n+                        (room, period, totalStudentSize) -> totalStudentSize - room.getCapacity());\n+    }\n+\n+    protected Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod() != rightExam.getPeriod()))\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod().equals(rightExam.getPeriod())))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam,\n+                                rightExam) -> leftExam.getPeriod().getPeriodIndex() <= rightExam.getPeriod().getPeriodIndex()))\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                        equal(RoomPenalty::getTopic, Exam::getTopic),\n+                        filtering((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null))\n+                .join(Exam.class,\n+                        equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                        equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod),\n+                        filtering((roomPenalty, leftExam, rightExam) -> leftExam.getTopic() != rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) == 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInARowPenalty());\n+    }\n+\n+    protected Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        // Find exams in a day, but not being held right after each other. That case is handled in the twoExamsInARow constraint.\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) > 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a day\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInADayPenalty());\n+    }\n+\n+    protected Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)\n+                .join(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal((config, topicConflict) -> topicConflict.getLeftTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((config, topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((config, topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam,\n+                                        rightExam) < (config.getPeriodSpreadLength() + 1)))\n+                .penalize(\"Period spread\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (config, topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifNotExistsOther(Exam.class,\n+                        equal(Exam::getPeriod, Exam::getPeriod),\n+                        equal(Exam::getRoom, Exam::getRoom),\n+                        lessThan(Exam::getId, Exam::getId))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkwMDY5Nw=="}, "originalCommit": {"oid": "4d9645c0ff8064317c15581721b2c778423e3896"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Nzc0MTczOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjozMToyMVrOGZ_pFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjozMToyMVrOGZ_pFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMDI5Mg==", "bodyText": "Also, I wonder why this entire construct isn't simply .fromUniquePair(Exam.class, ...), which handles this ID lessThan/greaterThan mess.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r429910292", "createdAt": "2020-05-25T12:31:21Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package org.optaplanner.examples.examination.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.ExaminationConstraintConfiguration;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+\n+                // Soft constraints\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    protected Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Conflicting exams in same period\",\n+                        HardSoftScore.ONE_HARD,\n+                        (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    protected Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Room.class)\n+                .join(Exam.class, equal(Function.identity(), Exam::getRoom))\n+                .join(Period.class, equal((room, exam) -> exam.getPeriod(), Function.identity()))\n+                .groupBy((room, exam, period) -> room,\n+                        (room, exam, period) -> period,\n+                        ConstraintCollectors.sum((period, exam, room) -> exam.getTopicStudentSize()))\n+                .filter((room, period, totalStudentSize) -> totalStudentSize > room.getCapacity())\n+                .penalize(\"Room capacity too small\",\n+                        HardSoftScore.ONE_HARD,\n+                        (room, period, totalStudentSize) -> totalStudentSize - room.getCapacity());\n+    }\n+\n+    protected Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod() != rightExam.getPeriod()))\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod().equals(rightExam.getPeriod())))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam,\n+                                rightExam) -> leftExam.getPeriod().getPeriodIndex() <= rightExam.getPeriod().getPeriodIndex()))\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                        equal(RoomPenalty::getTopic, Exam::getTopic),\n+                        filtering((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null))\n+                .join(Exam.class,\n+                        equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                        equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod),\n+                        filtering((roomPenalty, leftExam, rightExam) -> leftExam.getTopic() != rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) == 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInARowPenalty());\n+    }\n+\n+    protected Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        // Find exams in a day, but not being held right after each other. That case is handled in the twoExamsInARow constraint.\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) > 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a day\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInADayPenalty());\n+    }\n+\n+    protected Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)\n+                .join(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal((config, topicConflict) -> topicConflict.getLeftTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((config, topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((config, topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam,\n+                                        rightExam) < (config.getPeriodSpreadLength() + 1)))\n+                .penalize(\"Period spread\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (config, topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifNotExistsOther(Exam.class,\n+                        equal(Exam::getPeriod, Exam::getPeriod),\n+                        equal(Exam::getRoom, Exam::getRoom),\n+                        lessThan(Exam::getId, Exam::getId))\n+                .join(Exam.class,\n+                        equal(Exam::getPeriod),\n+                        equal(Exam::getRoom),\n+                        greaterThan(Exam::getId),\n+                        filtering((leftExam, rightExam) -> rightExam.getTopicDuration() != leftExam.getTopicDuration()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9645c0ff8064317c15581721b2c778423e3896"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Nzc0OTYxOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjozNDoyOFrOGZ_t_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjozNDoyOFrOGZ_t_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMTU0OQ==", "bodyText": "Why not .filter(exam -> exam.getPeriod().getPenalty() != 0)?", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r429911549", "createdAt": "2020-05-25T12:34:28Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package org.optaplanner.examples.examination.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.ExaminationConstraintConfiguration;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+\n+                // Soft constraints\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    protected Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Conflicting exams in same period\",\n+                        HardSoftScore.ONE_HARD,\n+                        (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    protected Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Room.class)\n+                .join(Exam.class, equal(Function.identity(), Exam::getRoom))\n+                .join(Period.class, equal((room, exam) -> exam.getPeriod(), Function.identity()))\n+                .groupBy((room, exam, period) -> room,\n+                        (room, exam, period) -> period,\n+                        ConstraintCollectors.sum((period, exam, room) -> exam.getTopicStudentSize()))\n+                .filter((room, period, totalStudentSize) -> totalStudentSize > room.getCapacity())\n+                .penalize(\"Room capacity too small\",\n+                        HardSoftScore.ONE_HARD,\n+                        (room, period, totalStudentSize) -> totalStudentSize - room.getCapacity());\n+    }\n+\n+    protected Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod() != rightExam.getPeriod()))\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod().equals(rightExam.getPeriod())))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam,\n+                                rightExam) -> leftExam.getPeriod().getPeriodIndex() <= rightExam.getPeriod().getPeriodIndex()))\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                        equal(RoomPenalty::getTopic, Exam::getTopic),\n+                        filtering((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null))\n+                .join(Exam.class,\n+                        equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                        equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod),\n+                        filtering((roomPenalty, leftExam, rightExam) -> leftExam.getTopic() != rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) == 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInARowPenalty());\n+    }\n+\n+    protected Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        // Find exams in a day, but not being held right after each other. That case is handled in the twoExamsInARow constraint.\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) > 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a day\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInADayPenalty());\n+    }\n+\n+    protected Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)\n+                .join(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal((config, topicConflict) -> topicConflict.getLeftTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((config, topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((config, topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam,\n+                                        rightExam) < (config.getPeriodSpreadLength() + 1)))\n+                .penalize(\"Period spread\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (config, topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifNotExistsOther(Exam.class,\n+                        equal(Exam::getPeriod, Exam::getPeriod),\n+                        equal(Exam::getRoom, Exam::getRoom),\n+                        lessThan(Exam::getId, Exam::getId))\n+                .join(Exam.class,\n+                        equal(Exam::getPeriod),\n+                        equal(Exam::getRoom),\n+                        greaterThan(Exam::getId),\n+                        filtering((leftExam, rightExam) -> rightExam.getTopicDuration() != leftExam.getTopicDuration()))\n+                .ifNotExists(Exam.class,\n+                        equal((leftExam, rightExam) -> rightExam.getPeriod(), Exam::getPeriod),\n+                        equal((leftExam, rightExam) -> rightExam.getRoom(), Exam::getRoom),\n+                        equal((leftExam, rightExam) -> rightExam.getTopicDuration(), Exam::getTopicDuration),\n+                        greaterThan((leftExam, rightExam) -> rightExam.getId(), Exam::getId))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Mixed durations\", HardSoftScore.ONE_SOFT,\n+                        (leftExam, rightExam, config) -> config.getMixedDurationPenalty());\n+    }\n+\n+    protected Constraint frontLoad(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)\n+                .join(Exam.class,\n+                        filtering((config, exam) -> exam.isTopicFrontLoadLarge() && exam.isPeriodFrontLoadLast()))\n+                .penalize(\"Front load\", HardSoftScore.ONE_SOFT, (config, exam) -> config.getFrontLoadPenalty());\n+    }\n+\n+    protected Constraint periodPenalty(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Period.class,\n+                        equal(Exam::getPeriod, Function.identity()),\n+                        filtering((exam, period) -> period.getPenalty() != 0))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9645c0ff8064317c15581721b2c778423e3896"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Nzc1MjEyOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjozNToyN1rOGZ_vhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjozNToyN1rOGZ_vhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMTk0Mw==", "bodyText": "All uses of from/join on ExaminationConstraintConfiguration should theoretically be removable when converted to penalizeConfigurable().", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r429911943", "createdAt": "2020-05-25T12:35:27Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package org.optaplanner.examples.examination.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.ExaminationConstraintConfiguration;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+\n+                // Soft constraints\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    protected Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Conflicting exams in same period\",\n+                        HardSoftScore.ONE_HARD,\n+                        (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    protected Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Room.class)\n+                .join(Exam.class, equal(Function.identity(), Exam::getRoom))\n+                .join(Period.class, equal((room, exam) -> exam.getPeriod(), Function.identity()))\n+                .groupBy((room, exam, period) -> room,\n+                        (room, exam, period) -> period,\n+                        ConstraintCollectors.sum((period, exam, room) -> exam.getTopicStudentSize()))\n+                .filter((room, period, totalStudentSize) -> totalStudentSize > room.getCapacity())\n+                .penalize(\"Room capacity too small\",\n+                        HardSoftScore.ONE_HARD,\n+                        (room, period, totalStudentSize) -> totalStudentSize - room.getCapacity());\n+    }\n+\n+    protected Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod() != rightExam.getPeriod()))\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod().equals(rightExam.getPeriod())))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam,\n+                                rightExam) -> leftExam.getPeriod().getPeriodIndex() <= rightExam.getPeriod().getPeriodIndex()))\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                        equal(RoomPenalty::getTopic, Exam::getTopic),\n+                        filtering((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null))\n+                .join(Exam.class,\n+                        equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                        equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod),\n+                        filtering((roomPenalty, leftExam, rightExam) -> leftExam.getTopic() != rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) == 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInARowPenalty());\n+    }\n+\n+    protected Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        // Find exams in a day, but not being held right after each other. That case is handled in the twoExamsInARow constraint.\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) > 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a day\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInADayPenalty());\n+    }\n+\n+    protected Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)\n+                .join(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal((config, topicConflict) -> topicConflict.getLeftTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((config, topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((config, topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam,\n+                                        rightExam) < (config.getPeriodSpreadLength() + 1)))\n+                .penalize(\"Period spread\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (config, topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifNotExistsOther(Exam.class,\n+                        equal(Exam::getPeriod, Exam::getPeriod),\n+                        equal(Exam::getRoom, Exam::getRoom),\n+                        lessThan(Exam::getId, Exam::getId))\n+                .join(Exam.class,\n+                        equal(Exam::getPeriod),\n+                        equal(Exam::getRoom),\n+                        greaterThan(Exam::getId),\n+                        filtering((leftExam, rightExam) -> rightExam.getTopicDuration() != leftExam.getTopicDuration()))\n+                .ifNotExists(Exam.class,\n+                        equal((leftExam, rightExam) -> rightExam.getPeriod(), Exam::getPeriod),\n+                        equal((leftExam, rightExam) -> rightExam.getRoom(), Exam::getRoom),\n+                        equal((leftExam, rightExam) -> rightExam.getTopicDuration(), Exam::getTopicDuration),\n+                        greaterThan((leftExam, rightExam) -> rightExam.getId(), Exam::getId))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Mixed durations\", HardSoftScore.ONE_SOFT,\n+                        (leftExam, rightExam, config) -> config.getMixedDurationPenalty());\n+    }\n+\n+    protected Constraint frontLoad(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9645c0ff8064317c15581721b2c778423e3896"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Nzc1Mzc0OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjozNjowNlrOGZ_wkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjozNjowNlrOGZ_wkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMjIwOA==", "bodyText": "Ditto. It appears you have a Room reference on Exam directly.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r429912208", "createdAt": "2020-05-25T12:36:06Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package org.optaplanner.examples.examination.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.ExaminationConstraintConfiguration;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+\n+                // Soft constraints\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    protected Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Conflicting exams in same period\",\n+                        HardSoftScore.ONE_HARD,\n+                        (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    protected Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Room.class)\n+                .join(Exam.class, equal(Function.identity(), Exam::getRoom))\n+                .join(Period.class, equal((room, exam) -> exam.getPeriod(), Function.identity()))\n+                .groupBy((room, exam, period) -> room,\n+                        (room, exam, period) -> period,\n+                        ConstraintCollectors.sum((period, exam, room) -> exam.getTopicStudentSize()))\n+                .filter((room, period, totalStudentSize) -> totalStudentSize > room.getCapacity())\n+                .penalize(\"Room capacity too small\",\n+                        HardSoftScore.ONE_HARD,\n+                        (room, period, totalStudentSize) -> totalStudentSize - room.getCapacity());\n+    }\n+\n+    protected Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod() != rightExam.getPeriod()))\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod().equals(rightExam.getPeriod())))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam,\n+                                rightExam) -> leftExam.getPeriod().getPeriodIndex() <= rightExam.getPeriod().getPeriodIndex()))\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                        equal(RoomPenalty::getTopic, Exam::getTopic),\n+                        filtering((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null))\n+                .join(Exam.class,\n+                        equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                        equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod),\n+                        filtering((roomPenalty, leftExam, rightExam) -> leftExam.getTopic() != rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) == 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInARowPenalty());\n+    }\n+\n+    protected Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        // Find exams in a day, but not being held right after each other. That case is handled in the twoExamsInARow constraint.\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) > 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a day\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInADayPenalty());\n+    }\n+\n+    protected Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)\n+                .join(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal((config, topicConflict) -> topicConflict.getLeftTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((config, topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((config, topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam,\n+                                        rightExam) < (config.getPeriodSpreadLength() + 1)))\n+                .penalize(\"Period spread\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (config, topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifNotExistsOther(Exam.class,\n+                        equal(Exam::getPeriod, Exam::getPeriod),\n+                        equal(Exam::getRoom, Exam::getRoom),\n+                        lessThan(Exam::getId, Exam::getId))\n+                .join(Exam.class,\n+                        equal(Exam::getPeriod),\n+                        equal(Exam::getRoom),\n+                        greaterThan(Exam::getId),\n+                        filtering((leftExam, rightExam) -> rightExam.getTopicDuration() != leftExam.getTopicDuration()))\n+                .ifNotExists(Exam.class,\n+                        equal((leftExam, rightExam) -> rightExam.getPeriod(), Exam::getPeriod),\n+                        equal((leftExam, rightExam) -> rightExam.getRoom(), Exam::getRoom),\n+                        equal((leftExam, rightExam) -> rightExam.getTopicDuration(), Exam::getTopicDuration),\n+                        greaterThan((leftExam, rightExam) -> rightExam.getId(), Exam::getId))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Mixed durations\", HardSoftScore.ONE_SOFT,\n+                        (leftExam, rightExam, config) -> config.getMixedDurationPenalty());\n+    }\n+\n+    protected Constraint frontLoad(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)\n+                .join(Exam.class,\n+                        filtering((config, exam) -> exam.isTopicFrontLoadLarge() && exam.isPeriodFrontLoadLast()))\n+                .penalize(\"Front load\", HardSoftScore.ONE_SOFT, (config, exam) -> config.getFrontLoadPenalty());\n+    }\n+\n+    protected Constraint periodPenalty(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Period.class,\n+                        equal(Exam::getPeriod, Function.identity()),\n+                        filtering((exam, period) -> period.getPenalty() != 0))\n+                .penalize(\"Period penalty\", HardSoftScore.ONE_SOFT, exam -> exam.getPeriod().getPenalty());\n+    }\n+\n+    protected Constraint roomPenalty(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Room.class,\n+                        equal(Exam::getRoom, Function.identity()),\n+                        filtering((exam, room) -> room.getPenalty() != 0))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9645c0ff8064317c15581721b2c778423e3896"}, "originalPosition": 234}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Nzc2MDY2OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjozODo1OVrOGZ_08g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjozODo1OVrOGZ_08g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMzMzMA==", "bodyText": "Why fromUnfiltered(), if you then filter anyway?", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r429913330", "createdAt": "2020-05-25T12:38:59Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package org.optaplanner.examples.examination.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.ExaminationConstraintConfiguration;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+\n+                // Soft constraints\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    protected Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Conflicting exams in same period\",\n+                        HardSoftScore.ONE_HARD,\n+                        (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9645c0ff8064317c15581721b2c778423e3896"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4OTgyMDMxOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/examination/solver/examinationSolverConfig.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNDowMTowOVrOGb2iEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNDowMTowOVrOGb2iEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1ODE5NQ==", "bodyText": "It looks like accidentally wrapping one comment into another.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r431858195", "createdAt": "2020-05-28T14:01:09Z", "author": {"login": "rsynek"}, "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/examination/solver/examinationSolverConfig.xml", "diffHunk": "@@ -1,7 +1,7 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <solver>\n-  <!--<environmentMode>FULL_ASSERT</environmentMode>--><!-- To slowly prove there are no bugs in this code -->\n-  <moveThreadCount>AUTO</moveThreadCount><!-- To solve faster by saturating multiple CPU cores -->\n+<!--  <environmentMode>FULL_ASSERT</environmentMode>&lt;!&ndash; To slowly prove there are no bugs in this code &ndash;&gt;-->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42af6ca76514e07f5483c0ec57493394ec1cbc9e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyOTcxNDM5OnYy", "diffSide": "RIGHT", "path": "optaplanner-benchmark/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNDozODo0NVrOGh4E0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNzoxNjo1M1rOGiRV8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE3NDkzMQ==", "bodyText": "Pretty sure CR1 does not belong here. (Nor anywhere else in this PR.)", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r438174931", "createdAt": "2020-06-10T14:38:45Z", "author": {"login": "triceo"}, "path": "optaplanner-benchmark/pom.xml", "diffHunk": "@@ -6,7 +6,7 @@\n   <parent>\n     <groupId>org.optaplanner</groupId>\n     <artifactId>optaplanner</artifactId>\n-    <version>7.39.0-SNAPSHOT</version>\n+    <version>7.39.0.CR1</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acc69ee999e3cd06bf5e28bbfca25e0d4ed45ec7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU4ODkxMg==", "bodyText": "Oops, this commit must've sneaked there while rebasing. Fixed now!", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r438588912", "createdAt": "2020-06-11T07:16:53Z", "author": {"login": "michaltomco"}, "path": "optaplanner-benchmark/pom.xml", "diffHunk": "@@ -6,7 +6,7 @@\n   <parent>\n     <groupId>org.optaplanner</groupId>\n     <artifactId>optaplanner</artifactId>\n-    <version>7.39.0-SNAPSHOT</version>\n+    <version>7.39.0.CR1</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE3NDkzMQ=="}, "originalCommit": {"oid": "acc69ee999e3cd06bf5e28bbfca25e0d4ed45ec7"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyOTcxOTE0OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/examination/solver/examinationSolverConfig.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNDozOTozN1rOGh4HlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNzoxNjo1OVrOGiRWIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE3NTYzNg==", "bodyText": "Formatting issues?", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r438175636", "createdAt": "2020-06-10T14:39:37Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/examination/solver/examinationSolverConfig.xml", "diffHunk": "@@ -1,7 +1,7 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <solver>\n-  <!--<environmentMode>FULL_ASSERT</environmentMode>--><!-- To slowly prove there are no bugs in this code -->\n-  <moveThreadCount>AUTO</moveThreadCount><!-- To solve faster by saturating multiple CPU cores -->\n+<!--  <environmentMode>FULL_ASSERT</environmentMode> To slowly prove there are no bugs in this code -->\n+  <!--<moveThreadCount>AUTO</moveThreadCount>--><!-- To solve faster by saturating multiple CPU cores -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acc69ee999e3cd06bf5e28bbfca25e0d4ed45ec7"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU4ODk2MA==", "bodyText": "Done.", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r438588960", "createdAt": "2020-06-11T07:16:59Z", "author": {"login": "michaltomco"}, "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/examination/solver/examinationSolverConfig.xml", "diffHunk": "@@ -1,7 +1,7 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <solver>\n-  <!--<environmentMode>FULL_ASSERT</environmentMode>--><!-- To slowly prove there are no bugs in this code -->\n-  <moveThreadCount>AUTO</moveThreadCount><!-- To solve faster by saturating multiple CPU cores -->\n+<!--  <environmentMode>FULL_ASSERT</environmentMode> To slowly prove there are no bugs in this code -->\n+  <!--<moveThreadCount>AUTO</moveThreadCount>--><!-- To solve faster by saturating multiple CPU cores -->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE3NTYzNg=="}, "originalCommit": {"oid": "acc69ee999e3cd06bf5e28bbfca25e0d4ed45ec7"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4439, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}