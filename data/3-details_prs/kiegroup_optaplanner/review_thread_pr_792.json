{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0MzI0ODc4", "number": 792, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwODozMDozMlrOEAaT5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowMzoxN1rOEBu_JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4ODY2NTM0OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/SwapMoveSelector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwODozMDozMlrOGbq-1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwODozMDozMlrOGbq-1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY2ODk0OQ==", "bodyText": "And this is why you don't put types of variables in variable names. This implementation detail now proliferated into places of this PR, which would otherwise be unaffected.", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r431668949", "createdAt": "2020-05-28T08:30:32Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/SwapMoveSelector.java", "diffHunk": "@@ -90,26 +94,19 @@ public boolean supportsPhaseAndSolverCaching() {\n     public void solvingStarted(DefaultSolverScope solverScope) {\n         super.solvingStarted(solverScope);\n         if (anyChained) {\n-            inverseVariableSupplyList = new ArrayList<>(variableDescriptorList.size());\n             SupplyManager supplyManager = solverScope.getScoreDirector().getSupplyManager();\n-            for (GenuineVariableDescriptor variableDescriptor : variableDescriptorList) {\n-                SingletonInverseVariableSupply inverseVariableSupply;\n-                if (variableDescriptor.isChained()) {\n-                    inverseVariableSupply = supplyManager.demand(\n-                            new SingletonInverseVariableDemand(variableDescriptor));\n-                } else {\n-                    inverseVariableSupply = null;\n-                }\n-                inverseVariableSupplyList.add(inverseVariableSupply);\n-            }\n+            inverseVariableSupplyMap = variableDescriptorList.stream()\n+                    .filter(GenuineVariableDescriptor::isChained)\n+                    .collect(toMap(Functions.identity(), variableDescriptor -> supplyManager\n+                            .demand(new SingletonInverseVariableDemand(variableDescriptor))));\n         }\n     }\n \n     @Override\n     public void solvingEnded(DefaultSolverScope solverScope) {\n         super.solvingEnded(solverScope);\n         if (anyChained) {\n-            inverseVariableSupplyList = null;\n+            inverseVariableSupplyMap = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caf0ec79730961ed68545fb48958b397960ac89f"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzYyMjYyOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzowNDo0MlrOGdAvQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzowNTozNlrOGdAwbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3Mzk4NQ==", "bodyText": "So when I have a plannning entity LessonVisit with a chained planning variable previous and a non-chained planning variable room, this code will execute for the room  too? That room should behave like a normal swap. Does it?\nWhat happens to room if it's trailing entities are null, both left and right? I guess it behaves like a normal swap move indeed?", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433073985", "createdAt": "2020-06-01T07:04:42Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java", "diffHunk": "@@ -74,8 +77,8 @@ protected void doMoveOnGenuineVariables(ScoreDirector<Solution_> scoreDirector)\n                     scoreDirector.changeVariableFacade(variableDescriptor, leftEntity, oldRightValue);\n                     scoreDirector.changeVariableFacade(variableDescriptor, rightEntity, oldLeftValue);\n                 } else {\n-                    Object oldLeftTrailingEntity = oldLeftTrailingEntityList.get(i);\n-                    Object oldRightTrailingEntity = oldRightTrailingEntityList.get(i);\n+                    Object oldLeftTrailingEntity = oldLeftTrailingEntityMap.get(variableDescriptor);\n+                    Object oldRightTrailingEntity = oldRightTrailingEntityMap.get(variableDescriptor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caf0ec79730961ed68545fb48958b397960ac89f"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NDI4NQ==", "bodyText": "I think the code behaves correctly, but we should add a test for it.", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433074285", "createdAt": "2020-06-01T07:05:36Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java", "diffHunk": "@@ -74,8 +77,8 @@ protected void doMoveOnGenuineVariables(ScoreDirector<Solution_> scoreDirector)\n                     scoreDirector.changeVariableFacade(variableDescriptor, leftEntity, oldRightValue);\n                     scoreDirector.changeVariableFacade(variableDescriptor, rightEntity, oldLeftValue);\n                 } else {\n-                    Object oldLeftTrailingEntity = oldLeftTrailingEntityList.get(i);\n-                    Object oldRightTrailingEntity = oldRightTrailingEntityList.get(i);\n+                    Object oldLeftTrailingEntity = oldLeftTrailingEntityMap.get(variableDescriptor);\n+                    Object oldRightTrailingEntity = oldRightTrailingEntityMap.get(variableDescriptor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3Mzk4NQ=="}, "originalCommit": {"oid": "caf0ec79730961ed68545fb48958b397960ac89f"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzYyNDQ4OnYy", "diffSide": "LEFT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/SwapMoveSelector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzowNTozNFrOGdAwXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzowNTozNFrOGdAwXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NDI2OQ==", "bodyText": "This is where you put the null that is then thrown later.", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433074269", "createdAt": "2020-06-01T07:05:34Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/SwapMoveSelector.java", "diffHunk": "@@ -90,26 +94,19 @@ public boolean supportsPhaseAndSolverCaching() {\n     public void solvingStarted(DefaultSolverScope solverScope) {\n         super.solvingStarted(solverScope);\n         if (anyChained) {\n-            inverseVariableSupplyList = new ArrayList<>(variableDescriptorList.size());\n             SupplyManager supplyManager = solverScope.getScoreDirector().getSupplyManager();\n-            for (GenuineVariableDescriptor variableDescriptor : variableDescriptorList) {\n-                SingletonInverseVariableSupply inverseVariableSupply;\n-                if (variableDescriptor.isChained()) {\n-                    inverseVariableSupply = supplyManager.demand(\n-                            new SingletonInverseVariableDemand(variableDescriptor));\n-                } else {\n-                    inverseVariableSupply = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caf0ec79730961ed68545fb48958b397960ac89f"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzYyNjA4OnYy", "diffSide": "LEFT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzowNjoxM1rOGdAxOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzoxNTo1MFrOGdA9xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NDQ4OQ==", "bodyText": "This is where the null would be thrown.\nI fix that by not iterating over the cases where the null would be thrown. (Non-chained vars.)", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433074489", "createdAt": "2020-06-01T07:06:13Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java", "diffHunk": "@@ -31,26 +32,28 @@\n  */\n public class ChainedSwapMove<Solution_> extends SwapMove<Solution_> {\n \n-    protected final List<Object> oldLeftTrailingEntityList;\n-    protected final List<Object> oldRightTrailingEntityList;\n+    protected final Map<GenuineVariableDescriptor<Solution_>, Object> oldLeftTrailingEntityMap;\n+    protected final Map<GenuineVariableDescriptor<Solution_>, Object> oldRightTrailingEntityMap;\n \n     public ChainedSwapMove(List<GenuineVariableDescriptor<Solution_>> variableDescriptorList,\n-            List<SingletonInverseVariableSupply> inverseVariableSupplyList, Object leftEntity, Object rightEntity) {\n+            Map<GenuineVariableDescriptor<Solution_>, SingletonInverseVariableSupply> inverseVariableSupplyMap,\n+            Object leftEntity, Object rightEntity) {\n         super(variableDescriptorList, leftEntity, rightEntity);\n-        oldLeftTrailingEntityList = new ArrayList<>(inverseVariableSupplyList.size());\n-        oldRightTrailingEntityList = new ArrayList<>(inverseVariableSupplyList.size());\n-        for (SingletonInverseVariableSupply inverseVariableSupply : inverseVariableSupplyList) {\n-            oldLeftTrailingEntityList.add(inverseVariableSupply.getInverseSingleton(leftEntity));\n-            oldRightTrailingEntityList.add(inverseVariableSupply.getInverseSingleton(rightEntity));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caf0ec79730961ed68545fb48958b397960ac89f"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NzcwMg==", "bodyText": "I'd iterate over them, to avoid changing an indexed lookup by a hashed lookup later on, but put in null if they don't exist, instead of throwing an NPE. wdyt?", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433077702", "createdAt": "2020-06-01T07:15:50Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java", "diffHunk": "@@ -31,26 +32,28 @@\n  */\n public class ChainedSwapMove<Solution_> extends SwapMove<Solution_> {\n \n-    protected final List<Object> oldLeftTrailingEntityList;\n-    protected final List<Object> oldRightTrailingEntityList;\n+    protected final Map<GenuineVariableDescriptor<Solution_>, Object> oldLeftTrailingEntityMap;\n+    protected final Map<GenuineVariableDescriptor<Solution_>, Object> oldRightTrailingEntityMap;\n \n     public ChainedSwapMove(List<GenuineVariableDescriptor<Solution_>> variableDescriptorList,\n-            List<SingletonInverseVariableSupply> inverseVariableSupplyList, Object leftEntity, Object rightEntity) {\n+            Map<GenuineVariableDescriptor<Solution_>, SingletonInverseVariableSupply> inverseVariableSupplyMap,\n+            Object leftEntity, Object rightEntity) {\n         super(variableDescriptorList, leftEntity, rightEntity);\n-        oldLeftTrailingEntityList = new ArrayList<>(inverseVariableSupplyList.size());\n-        oldRightTrailingEntityList = new ArrayList<>(inverseVariableSupplyList.size());\n-        for (SingletonInverseVariableSupply inverseVariableSupply : inverseVariableSupplyList) {\n-            oldLeftTrailingEntityList.add(inverseVariableSupply.getInverseSingleton(leftEntity));\n-            oldRightTrailingEntityList.add(inverseVariableSupply.getInverseSingleton(rightEntity));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NDQ4OQ=="}, "originalCommit": {"oid": "caf0ec79730961ed68545fb48958b397960ac89f"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzY0NDExOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzoxNDozN1rOGdA8DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzoxNDozN1rOGdA8DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NzI2MA==", "bodyText": "These map calls are a performance loss. We're replacing an indexed lookup by a hash lookup.\nI'd keep the index lookup (so the trailingEntityList has the same size as variableDescriptorList and their indexes match), but given that \"Object oldLeftTrailingEntity \" can be null, I 'd put a null as an element where we cache that (move constructor)", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433077260", "createdAt": "2020-06-01T07:14:37Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java", "diffHunk": "@@ -74,8 +77,8 @@ protected void doMoveOnGenuineVariables(ScoreDirector<Solution_> scoreDirector)\n                     scoreDirector.changeVariableFacade(variableDescriptor, leftEntity, oldRightValue);\n                     scoreDirector.changeVariableFacade(variableDescriptor, rightEntity, oldLeftValue);\n                 } else {\n-                    Object oldLeftTrailingEntity = oldLeftTrailingEntityList.get(i);\n-                    Object oldRightTrailingEntity = oldRightTrailingEntityList.get(i);\n+                    Object oldLeftTrailingEntity = oldLeftTrailingEntityMap.get(variableDescriptor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caf0ec79730961ed68545fb48958b397960ac89f"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjUzODYxOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/domain/chained/TestdataChainedEntity.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowMzoxN1rOGdwjsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowMzoxN1rOGdwjsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzQ1OQ==", "bodyText": "(very soft) I 'd have used TestdataValue as a type for unchainedObject, calling it unchainedValue instead, for consistency with other testdata. But it doesn't matter much.", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433857459", "createdAt": "2020-06-02T13:03:17Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/domain/chained/TestdataChainedEntity.java", "diffHunk": "@@ -39,7 +39,15 @@\n         return entityDescriptor.getGenuineVariableDescriptor(\"chainedObject\");\n     }\n \n+    public static GenuineVariableDescriptor<TestdataChainedSolution> buildVariableDescriptorForUnchainedObject() {\n+        SolutionDescriptor<TestdataChainedSolution> solutionDescriptor = TestdataChainedSolution.buildSolutionDescriptor();\n+        EntityDescriptor<TestdataChainedSolution> entityDescriptor = solutionDescriptor\n+                .findEntityDescriptorOrFail(TestdataChainedEntity.class);\n+        return entityDescriptor.getGenuineVariableDescriptor(\"unchainedObject\");\n+    }\n+\n     private TestdataChainedObject chainedObject;\n+    private TestdataObject unchainedObject;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eec39132a94378b750578cc8a2a566a4fb2c72d5"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4557, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}