{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5NTU0NzI4", "number": 703, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjozODozM1rODir4Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzoxODowMlrODi4zmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3Njk3MDc4OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjozODozM1rOFuEgxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMDoyNzoxNVrOFumEyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg1Mjc0Mw==", "bodyText": "If the usage is higher than the capacity, doesn't capacity - usage return a negative number? But we have a fail fast for that.\nWhat am I missing?", "url": "https://github.com/kiegroup/optaplanner/pull/703#discussion_r383852743", "createdAt": "2020-02-25T12:38:33Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -53,31 +62,28 @@\n      * Maximum capacity: The maximum capacity for each resource for each machine must not be exceeded.\n      */\n     private Constraint maximumCapacity(ConstraintFactory factory) {\n-        throw new UnsupportedOperationException(\"Not yet implemented due to missing support for bi-grouping.\");\n-//        return factory.from(MrMachineCapacity.class)\n-//                .join(MrProcessAssignment.class,\n-//                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-//                )\n-//                .groupBy(\n-//                        (machineCapacity, processAssignment) -> machineCapacity, sumLong(\n-//                                (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource())\n-//                        )\n-//                )\n-//                .filter(((machineCapacity, usage) -> machineCapacity.getMaximumCapacity() < usage))\n-//                .penalizeLong(MrConstraints.MAXIMUM_CAPACITY,\n-//                        HardSoftLongScore.ofHard(1L),\n-//                        (machineCapacity, usage) -> machineCapacity.getMaximumCapacity() - usage);\n+        return factory.from(MrMachineCapacity.class)\n+                .join(MrProcessAssignment.class,\n+                      equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n+                )\n+                .groupBy((machineCapacity, processAssignment) -> machineCapacity, sumLong(\n+                        (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource()))\n+                )\n+                .filter(((machineCapacity, usage) -> machineCapacity.getMaximumCapacity() < usage))\n+                .penalizeLong(MrConstraints.MAXIMUM_CAPACITY,\n+                              HardSoftLongScore.ofHard(1L),\n+                              (machineCapacity, usage) -> machineCapacity.getMaximumCapacity() - usage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b027f09afce4321e8fc804b84b5da316e46cad92"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQwMjYzNA==", "bodyText": "Good catch; there was no machine breaking this constraint. Once I removed the filter, the fast fast worked.", "url": "https://github.com/kiegroup/optaplanner/pull/703#discussion_r384402634", "createdAt": "2020-02-26T10:27:15Z", "author": {"login": "rsynek"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -53,31 +62,28 @@\n      * Maximum capacity: The maximum capacity for each resource for each machine must not be exceeded.\n      */\n     private Constraint maximumCapacity(ConstraintFactory factory) {\n-        throw new UnsupportedOperationException(\"Not yet implemented due to missing support for bi-grouping.\");\n-//        return factory.from(MrMachineCapacity.class)\n-//                .join(MrProcessAssignment.class,\n-//                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-//                )\n-//                .groupBy(\n-//                        (machineCapacity, processAssignment) -> machineCapacity, sumLong(\n-//                                (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource())\n-//                        )\n-//                )\n-//                .filter(((machineCapacity, usage) -> machineCapacity.getMaximumCapacity() < usage))\n-//                .penalizeLong(MrConstraints.MAXIMUM_CAPACITY,\n-//                        HardSoftLongScore.ofHard(1L),\n-//                        (machineCapacity, usage) -> machineCapacity.getMaximumCapacity() - usage);\n+        return factory.from(MrMachineCapacity.class)\n+                .join(MrProcessAssignment.class,\n+                      equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n+                )\n+                .groupBy((machineCapacity, processAssignment) -> machineCapacity, sumLong(\n+                        (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource()))\n+                )\n+                .filter(((machineCapacity, usage) -> machineCapacity.getMaximumCapacity() < usage))\n+                .penalizeLong(MrConstraints.MAXIMUM_CAPACITY,\n+                              HardSoftLongScore.ofHard(1L),\n+                              (machineCapacity, usage) -> machineCapacity.getMaximumCapacity() - usage);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg1Mjc0Mw=="}, "originalCommit": {"oid": "b027f09afce4321e8fc804b84b5da316e46cad92"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzAyNzIxOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjo1NzowMlrOFuFCYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjo1NzowMlrOFuFCYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2MTM0Nw==", "bodyText": "One experiment to make this go faster (not to be done as part of this PR!),\nis to something like this:\nfrom(MrProcessAssignment) // Look mom, no resource selected!\n.groupBy(MrProcessAssignment::getMachine,\n    sum(MrProcessAssignment::getUsages, some lamdba's)) // MrProcessAssignment::getUsages returns an array of usages\n\nNow that would screw up our constraint matches count, etc but the score would end up the same. Regardless if we'd want to do it, it's an interesting performance experiment.", "url": "https://github.com/kiegroup/optaplanner/pull/703#discussion_r383861347", "createdAt": "2020-02-25T12:57:02Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -53,31 +62,28 @@\n      * Maximum capacity: The maximum capacity for each resource for each machine must not be exceeded.\n      */\n     private Constraint maximumCapacity(ConstraintFactory factory) {\n-        throw new UnsupportedOperationException(\"Not yet implemented due to missing support for bi-grouping.\");\n-//        return factory.from(MrMachineCapacity.class)\n-//                .join(MrProcessAssignment.class,\n-//                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-//                )\n-//                .groupBy(\n-//                        (machineCapacity, processAssignment) -> machineCapacity, sumLong(\n-//                                (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource())\n-//                        )\n-//                )\n-//                .filter(((machineCapacity, usage) -> machineCapacity.getMaximumCapacity() < usage))\n-//                .penalizeLong(MrConstraints.MAXIMUM_CAPACITY,\n-//                        HardSoftLongScore.ofHard(1L),\n-//                        (machineCapacity, usage) -> machineCapacity.getMaximumCapacity() - usage);\n+        return factory.from(MrMachineCapacity.class)\n+                .join(MrProcessAssignment.class,\n+                      equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n+                )\n+                .groupBy((machineCapacity, processAssignment) -> machineCapacity, sumLong(\n+                        (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource()))\n+                )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b027f09afce4321e8fc804b84b5da316e46cad92"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzAyOTE5OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjo1Nzo0MFrOFuFDpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNTo1MTo1MlrOFuLhPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2MTY3MA==", "bodyText": "Math.max(0, balanceCost)?", "url": "https://github.com/kiegroup/optaplanner/pull/703#discussion_r383861670", "createdAt": "2020-02-25T12:57:40Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -139,42 +145,40 @@ private Constraint transientUsage(ConstraintFactory factory) {\n      * Load: The safety capacity for each resource for each machine should not be exceeded.\n      */\n     private Constraint loadCost(ConstraintFactory factory) {\n-        throw new UnsupportedOperationException(\"Not yet implemented due to missing support for bi-grouping.\");\n-//        return factory.from(MrMachineCapacity.class)\n-//                .join(MrProcessAssignment.class,\n-//                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-//                )\n-//                .groupBy(\n-//                        (machineCapacity, processAssignment) -> machineCapacity, sumLong(\n-//                                (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource())\n-//                        )\n-//                )\n-//                .filter(((machineCapacity, usage) -> machineCapacity.getSafetyCapacity() < usage))\n-//                .penalizeLong(MrConstraints.LOAD_COST,\n-//                        HardSoftLongScore.ofSoft(1L),\n-//                        (machineCapacity, usage) -> machineCapacity.getSafetyCapacity() - usage);\n+        return factory.from(MrMachineCapacity.class)\n+                .join(MrProcessAssignment.class,\n+                      equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n+                )\n+                .groupBy((machineCapacity, processAssignment) -> machineCapacity, sumLong(\n+                        (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource()))\n+                )\n+                .filter(((machineCapacity, usage) -> machineCapacity.getSafetyCapacity() < usage))\n+                .penalizeLong(MrConstraints.LOAD_COST,\n+                              HardSoftLongScore.ofSoft(1L),\n+                              (machineCapacity, usage) -> usage - machineCapacity.getSafetyCapacity());\n     }\n \n     /**\n      * availability(r) = capacity(m, r) - usage(m, r)\n      * balanceCost = sum(max(0, multiplier * availability(m, r1) - availability(m, r2)))\n      */\n     private Constraint balanceCost(ConstraintFactory factory) {\n-        throw new UnsupportedOperationException(\"Not yet implemented due to missing support for quad streams.\");\n-\n-        /* TODO: requires quad streams support and groupBy taking two collectors. Alternatively, use a shadow variable.\n         return factory.from(MrBalancePenalty.class)\n                 .join(MrProcessAssignment.class)\n-                .groupBy((penalty) -> penalty, (penalty, assignment) -> assignment.getMachine(),\n-                         sumLong((penalty, assignment) -> processAssignment.getUsage(penalty.getOrigin())\n-                                 sumLong((penalty, assignment) ->\n-                                                 processAssignment.getUsage(penalty.getTarget()))))\n-                // QuadStream<MrBalancePenalty, MrMachine, Long, Long>\n-                .filter((penalty, machine, originUsage, targetUsage) ->\n-                                (machine.getCapacity(penalty.getOrigin()) - originUsage) <\n-                                        penalty.getMultiplier() * (machine.getCapacity(penalty.getTarget()) - targetUsage))\n-                .penalizeLong(MrConstraintName.BALANCE_COST, HardSoftLongScore.ofSoft(1L), ...);\n-         */\n+                .groupBy((penalty, processAssignment) -> penalty, (penalty, processAssignment) -> processAssignment.getMachine(),\n+                         sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getOriginResource())),\n+                         sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getTargetResource()))\n+                )\n+                .penalizeLong(MrConstraints.BALANCE_COST, HardSoftLongScore.ofSoft(1L), this::balanceCost);\n+    }\n+\n+    private long balanceCost(MrBalancePenalty penalty, MrMachine machine, long originalUsage, long targetUsage) {\n+        long originalAvailability =\n+                machine.getMachineCapacity(penalty.getOriginResource()).getMaximumCapacity() - originalUsage;\n+        long targetAvailability =\n+                machine.getMachineCapacity(penalty.getTargetResource()).getMaximumCapacity() - targetUsage;\n+        long balanceCost = penalty.getMultiplicand() * originalAvailability - targetAvailability;\n+        return balanceCost < 0 ? 0 : balanceCost;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b027f09afce4321e8fc804b84b5da316e46cad92"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2MjUxOA==", "bodyText": "Not sure if that's more readable. Or faster.", "url": "https://github.com/kiegroup/optaplanner/pull/703#discussion_r383862518", "createdAt": "2020-02-25T12:59:18Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -139,42 +145,40 @@ private Constraint transientUsage(ConstraintFactory factory) {\n      * Load: The safety capacity for each resource for each machine should not be exceeded.\n      */\n     private Constraint loadCost(ConstraintFactory factory) {\n-        throw new UnsupportedOperationException(\"Not yet implemented due to missing support for bi-grouping.\");\n-//        return factory.from(MrMachineCapacity.class)\n-//                .join(MrProcessAssignment.class,\n-//                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-//                )\n-//                .groupBy(\n-//                        (machineCapacity, processAssignment) -> machineCapacity, sumLong(\n-//                                (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource())\n-//                        )\n-//                )\n-//                .filter(((machineCapacity, usage) -> machineCapacity.getSafetyCapacity() < usage))\n-//                .penalizeLong(MrConstraints.LOAD_COST,\n-//                        HardSoftLongScore.ofSoft(1L),\n-//                        (machineCapacity, usage) -> machineCapacity.getSafetyCapacity() - usage);\n+        return factory.from(MrMachineCapacity.class)\n+                .join(MrProcessAssignment.class,\n+                      equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n+                )\n+                .groupBy((machineCapacity, processAssignment) -> machineCapacity, sumLong(\n+                        (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource()))\n+                )\n+                .filter(((machineCapacity, usage) -> machineCapacity.getSafetyCapacity() < usage))\n+                .penalizeLong(MrConstraints.LOAD_COST,\n+                              HardSoftLongScore.ofSoft(1L),\n+                              (machineCapacity, usage) -> usage - machineCapacity.getSafetyCapacity());\n     }\n \n     /**\n      * availability(r) = capacity(m, r) - usage(m, r)\n      * balanceCost = sum(max(0, multiplier * availability(m, r1) - availability(m, r2)))\n      */\n     private Constraint balanceCost(ConstraintFactory factory) {\n-        throw new UnsupportedOperationException(\"Not yet implemented due to missing support for quad streams.\");\n-\n-        /* TODO: requires quad streams support and groupBy taking two collectors. Alternatively, use a shadow variable.\n         return factory.from(MrBalancePenalty.class)\n                 .join(MrProcessAssignment.class)\n-                .groupBy((penalty) -> penalty, (penalty, assignment) -> assignment.getMachine(),\n-                         sumLong((penalty, assignment) -> processAssignment.getUsage(penalty.getOrigin())\n-                                 sumLong((penalty, assignment) ->\n-                                                 processAssignment.getUsage(penalty.getTarget()))))\n-                // QuadStream<MrBalancePenalty, MrMachine, Long, Long>\n-                .filter((penalty, machine, originUsage, targetUsage) ->\n-                                (machine.getCapacity(penalty.getOrigin()) - originUsage) <\n-                                        penalty.getMultiplier() * (machine.getCapacity(penalty.getTarget()) - targetUsage))\n-                .penalizeLong(MrConstraintName.BALANCE_COST, HardSoftLongScore.ofSoft(1L), ...);\n-         */\n+                .groupBy((penalty, processAssignment) -> penalty, (penalty, processAssignment) -> processAssignment.getMachine(),\n+                         sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getOriginResource())),\n+                         sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getTargetResource()))\n+                )\n+                .penalizeLong(MrConstraints.BALANCE_COST, HardSoftLongScore.ofSoft(1L), this::balanceCost);\n+    }\n+\n+    private long balanceCost(MrBalancePenalty penalty, MrMachine machine, long originalUsage, long targetUsage) {\n+        long originalAvailability =\n+                machine.getMachineCapacity(penalty.getOriginResource()).getMaximumCapacity() - originalUsage;\n+        long targetAvailability =\n+                machine.getMachineCapacity(penalty.getTargetResource()).getMaximumCapacity() - targetUsage;\n+        long balanceCost = penalty.getMultiplicand() * originalAvailability - targetAvailability;\n+        return balanceCost < 0 ? 0 : balanceCost;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2MTY3MA=="}, "originalCommit": {"oid": "b027f09afce4321e8fc804b84b5da316e46cad92"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg3NTE4Mw==", "bodyText": "Although performance was not my concern here, Math.max() is intrinsic in Hotspot and therefore should be faster.\nMainly I'm interested in one less condition we have to test. :-)\nAnyway... fine to merge with or without this.", "url": "https://github.com/kiegroup/optaplanner/pull/703#discussion_r383875183", "createdAt": "2020-02-25T13:24:57Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -139,42 +145,40 @@ private Constraint transientUsage(ConstraintFactory factory) {\n      * Load: The safety capacity for each resource for each machine should not be exceeded.\n      */\n     private Constraint loadCost(ConstraintFactory factory) {\n-        throw new UnsupportedOperationException(\"Not yet implemented due to missing support for bi-grouping.\");\n-//        return factory.from(MrMachineCapacity.class)\n-//                .join(MrProcessAssignment.class,\n-//                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-//                )\n-//                .groupBy(\n-//                        (machineCapacity, processAssignment) -> machineCapacity, sumLong(\n-//                                (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource())\n-//                        )\n-//                )\n-//                .filter(((machineCapacity, usage) -> machineCapacity.getSafetyCapacity() < usage))\n-//                .penalizeLong(MrConstraints.LOAD_COST,\n-//                        HardSoftLongScore.ofSoft(1L),\n-//                        (machineCapacity, usage) -> machineCapacity.getSafetyCapacity() - usage);\n+        return factory.from(MrMachineCapacity.class)\n+                .join(MrProcessAssignment.class,\n+                      equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n+                )\n+                .groupBy((machineCapacity, processAssignment) -> machineCapacity, sumLong(\n+                        (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource()))\n+                )\n+                .filter(((machineCapacity, usage) -> machineCapacity.getSafetyCapacity() < usage))\n+                .penalizeLong(MrConstraints.LOAD_COST,\n+                              HardSoftLongScore.ofSoft(1L),\n+                              (machineCapacity, usage) -> usage - machineCapacity.getSafetyCapacity());\n     }\n \n     /**\n      * availability(r) = capacity(m, r) - usage(m, r)\n      * balanceCost = sum(max(0, multiplier * availability(m, r1) - availability(m, r2)))\n      */\n     private Constraint balanceCost(ConstraintFactory factory) {\n-        throw new UnsupportedOperationException(\"Not yet implemented due to missing support for quad streams.\");\n-\n-        /* TODO: requires quad streams support and groupBy taking two collectors. Alternatively, use a shadow variable.\n         return factory.from(MrBalancePenalty.class)\n                 .join(MrProcessAssignment.class)\n-                .groupBy((penalty) -> penalty, (penalty, assignment) -> assignment.getMachine(),\n-                         sumLong((penalty, assignment) -> processAssignment.getUsage(penalty.getOrigin())\n-                                 sumLong((penalty, assignment) ->\n-                                                 processAssignment.getUsage(penalty.getTarget()))))\n-                // QuadStream<MrBalancePenalty, MrMachine, Long, Long>\n-                .filter((penalty, machine, originUsage, targetUsage) ->\n-                                (machine.getCapacity(penalty.getOrigin()) - originUsage) <\n-                                        penalty.getMultiplier() * (machine.getCapacity(penalty.getTarget()) - targetUsage))\n-                .penalizeLong(MrConstraintName.BALANCE_COST, HardSoftLongScore.ofSoft(1L), ...);\n-         */\n+                .groupBy((penalty, processAssignment) -> penalty, (penalty, processAssignment) -> processAssignment.getMachine(),\n+                         sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getOriginResource())),\n+                         sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getTargetResource()))\n+                )\n+                .penalizeLong(MrConstraints.BALANCE_COST, HardSoftLongScore.ofSoft(1L), this::balanceCost);\n+    }\n+\n+    private long balanceCost(MrBalancePenalty penalty, MrMachine machine, long originalUsage, long targetUsage) {\n+        long originalAvailability =\n+                machine.getMachineCapacity(penalty.getOriginResource()).getMaximumCapacity() - originalUsage;\n+        long targetAvailability =\n+                machine.getMachineCapacity(penalty.getTargetResource()).getMaximumCapacity() - targetUsage;\n+        long balanceCost = penalty.getMultiplicand() * originalAvailability - targetAvailability;\n+        return balanceCost < 0 ? 0 : balanceCost;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2MTY3MA=="}, "originalCommit": {"oid": "b027f09afce4321e8fc804b84b5da316e46cad92"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk2NzU1MQ==", "bodyText": "Same here, fine to merge with or without this, too. You're owner, your call :)", "url": "https://github.com/kiegroup/optaplanner/pull/703#discussion_r383967551", "createdAt": "2020-02-25T15:51:52Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -139,42 +145,40 @@ private Constraint transientUsage(ConstraintFactory factory) {\n      * Load: The safety capacity for each resource for each machine should not be exceeded.\n      */\n     private Constraint loadCost(ConstraintFactory factory) {\n-        throw new UnsupportedOperationException(\"Not yet implemented due to missing support for bi-grouping.\");\n-//        return factory.from(MrMachineCapacity.class)\n-//                .join(MrProcessAssignment.class,\n-//                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-//                )\n-//                .groupBy(\n-//                        (machineCapacity, processAssignment) -> machineCapacity, sumLong(\n-//                                (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource())\n-//                        )\n-//                )\n-//                .filter(((machineCapacity, usage) -> machineCapacity.getSafetyCapacity() < usage))\n-//                .penalizeLong(MrConstraints.LOAD_COST,\n-//                        HardSoftLongScore.ofSoft(1L),\n-//                        (machineCapacity, usage) -> machineCapacity.getSafetyCapacity() - usage);\n+        return factory.from(MrMachineCapacity.class)\n+                .join(MrProcessAssignment.class,\n+                      equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n+                )\n+                .groupBy((machineCapacity, processAssignment) -> machineCapacity, sumLong(\n+                        (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource()))\n+                )\n+                .filter(((machineCapacity, usage) -> machineCapacity.getSafetyCapacity() < usage))\n+                .penalizeLong(MrConstraints.LOAD_COST,\n+                              HardSoftLongScore.ofSoft(1L),\n+                              (machineCapacity, usage) -> usage - machineCapacity.getSafetyCapacity());\n     }\n \n     /**\n      * availability(r) = capacity(m, r) - usage(m, r)\n      * balanceCost = sum(max(0, multiplier * availability(m, r1) - availability(m, r2)))\n      */\n     private Constraint balanceCost(ConstraintFactory factory) {\n-        throw new UnsupportedOperationException(\"Not yet implemented due to missing support for quad streams.\");\n-\n-        /* TODO: requires quad streams support and groupBy taking two collectors. Alternatively, use a shadow variable.\n         return factory.from(MrBalancePenalty.class)\n                 .join(MrProcessAssignment.class)\n-                .groupBy((penalty) -> penalty, (penalty, assignment) -> assignment.getMachine(),\n-                         sumLong((penalty, assignment) -> processAssignment.getUsage(penalty.getOrigin())\n-                                 sumLong((penalty, assignment) ->\n-                                                 processAssignment.getUsage(penalty.getTarget()))))\n-                // QuadStream<MrBalancePenalty, MrMachine, Long, Long>\n-                .filter((penalty, machine, originUsage, targetUsage) ->\n-                                (machine.getCapacity(penalty.getOrigin()) - originUsage) <\n-                                        penalty.getMultiplier() * (machine.getCapacity(penalty.getTarget()) - targetUsage))\n-                .penalizeLong(MrConstraintName.BALANCE_COST, HardSoftLongScore.ofSoft(1L), ...);\n-         */\n+                .groupBy((penalty, processAssignment) -> penalty, (penalty, processAssignment) -> processAssignment.getMachine(),\n+                         sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getOriginResource())),\n+                         sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getTargetResource()))\n+                )\n+                .penalizeLong(MrConstraints.BALANCE_COST, HardSoftLongScore.ofSoft(1L), this::balanceCost);\n+    }\n+\n+    private long balanceCost(MrBalancePenalty penalty, MrMachine machine, long originalUsage, long targetUsage) {\n+        long originalAvailability =\n+                machine.getMachineCapacity(penalty.getOriginResource()).getMaximumCapacity() - originalUsage;\n+        long targetAvailability =\n+                machine.getMachineCapacity(penalty.getTargetResource()).getMaximumCapacity() - targetUsage;\n+        long balanceCost = penalty.getMultiplicand() * originalAvailability - targetAvailability;\n+        return balanceCost < 0 ? 0 : balanceCost;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2MTY3MA=="}, "originalCommit": {"oid": "b027f09afce4321e8fc804b84b5da316e46cad92"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzAzODYxOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzowMDoyOFrOFuFJJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzowMDoyOFrOFuFJJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2MzA3OA==", "bodyText": "Any chance the sumLong() could come on a new line, like you do in other constraints?", "url": "https://github.com/kiegroup/optaplanner/pull/703#discussion_r383863078", "createdAt": "2020-02-25T13:00:28Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -139,42 +145,40 @@ private Constraint transientUsage(ConstraintFactory factory) {\n      * Load: The safety capacity for each resource for each machine should not be exceeded.\n      */\n     private Constraint loadCost(ConstraintFactory factory) {\n-        throw new UnsupportedOperationException(\"Not yet implemented due to missing support for bi-grouping.\");\n-//        return factory.from(MrMachineCapacity.class)\n-//                .join(MrProcessAssignment.class,\n-//                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-//                )\n-//                .groupBy(\n-//                        (machineCapacity, processAssignment) -> machineCapacity, sumLong(\n-//                                (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource())\n-//                        )\n-//                )\n-//                .filter(((machineCapacity, usage) -> machineCapacity.getSafetyCapacity() < usage))\n-//                .penalizeLong(MrConstraints.LOAD_COST,\n-//                        HardSoftLongScore.ofSoft(1L),\n-//                        (machineCapacity, usage) -> machineCapacity.getSafetyCapacity() - usage);\n+        return factory.from(MrMachineCapacity.class)\n+                .join(MrProcessAssignment.class,\n+                      equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n+                )\n+                .groupBy((machineCapacity, processAssignment) -> machineCapacity, sumLong(\n+                        (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b027f09afce4321e8fc804b84b5da316e46cad92"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTA1MjU2OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzowMzowM1rOFuYfXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzowMzowM1rOFuYfXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4MDA2Mw==", "bodyText": "We don't align on columns.", "url": "https://github.com/kiegroup/optaplanner/pull/703#discussion_r384180063", "createdAt": "2020-02-25T23:03:03Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -184,23 +188,19 @@ private Constraint processMoveCost(ConstraintFactory factory) {\n         return factory.from(MrProcessAssignment.class)\n                 .filter(MrProcessAssignment::isMoved)\n                 .penalizeLong(MrConstraints.PROCESS_MOVE_COST,\n-                        HardSoftLongScore.ofSoft(1L),\n-                        MrProcessAssignment::getProcessMoveCost);\n+                              HardSoftLongScore.ofSoft(1L),\n+                              MrProcessAssignment::getProcessMoveCost);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b027f09afce4321e8fc804b84b5da316e46cad92"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTA1MzQ1OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzowMzoxOVrOFuYf1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzowMzoxOVrOFuYf1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4MDE4Mw==", "bodyText": "Dtto. on aligning. In fact, I can see it all over the file.", "url": "https://github.com/kiegroup/optaplanner/pull/703#discussion_r384180183", "createdAt": "2020-02-25T23:03:19Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -210,8 +210,7 @@ private Constraint machineMoveCost(ConstraintFactory factory) {\n         return factory.from(MrProcessAssignment.class)\n                 .filter(MrProcessAssignment::isMoved)\n                 .penalizeLong(MrConstraints.MACHINE_MOVE_COST,\n-                        HardSoftLongScore.ofSoft(1L),\n-                        MrProcessAssignment::getMachineMoveCost);\n+                              HardSoftLongScore.ofSoft(1L),\n+                              MrProcessAssignment::getMachineMoveCost);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b027f09afce4321e8fc804b84b5da316e46cad92"}, "originalPosition": 269}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTA4ODg4OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzoxODowMlrOFuY1Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzoxODoyMFrOFuY1qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4NTY4Ng==", "bodyText": "FYI All instances of HardSoftLongScore.ofHard(1L) may be replaced by HardSoftLongScore.ONE_HARD,", "url": "https://github.com/kiegroup/optaplanner/pull/703#discussion_r384185686", "createdAt": "2020-02-25T23:18:02Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -53,31 +62,28 @@\n      * Maximum capacity: The maximum capacity for each resource for each machine must not be exceeded.\n      */\n     private Constraint maximumCapacity(ConstraintFactory factory) {\n-        throw new UnsupportedOperationException(\"Not yet implemented due to missing support for bi-grouping.\");\n-//        return factory.from(MrMachineCapacity.class)\n-//                .join(MrProcessAssignment.class,\n-//                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-//                )\n-//                .groupBy(\n-//                        (machineCapacity, processAssignment) -> machineCapacity, sumLong(\n-//                                (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource())\n-//                        )\n-//                )\n-//                .filter(((machineCapacity, usage) -> machineCapacity.getMaximumCapacity() < usage))\n-//                .penalizeLong(MrConstraints.MAXIMUM_CAPACITY,\n-//                        HardSoftLongScore.ofHard(1L),\n-//                        (machineCapacity, usage) -> machineCapacity.getMaximumCapacity() - usage);\n+        return factory.from(MrMachineCapacity.class)\n+                .join(MrProcessAssignment.class,\n+                      equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n+                )\n+                .groupBy((machineCapacity, processAssignment) -> machineCapacity, sumLong(\n+                        (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource()))\n+                )\n+                .filter(((machineCapacity, usage) -> machineCapacity.getMaximumCapacity() < usage))\n+                .penalizeLong(MrConstraints.MAXIMUM_CAPACITY,\n+                              HardSoftLongScore.ofHard(1L),\n+                              (machineCapacity, usage) -> machineCapacity.getMaximumCapacity() - usage);\n     }\n \n     /**\n      * Conflict: Processes of the same service must run on distinct machines.\n      */\n     private Constraint serviceConflict(ConstraintFactory factory) {\n         return factory.fromUniquePair(MrProcessAssignment.class,\n-                equal(MrProcessAssignment::getMachine),\n-                equal(MrProcessAssignment::getService)\n+                                      equal(MrProcessAssignment::getMachine),\n+                                      equal(MrProcessAssignment::getService)\n         ).penalize(MrConstraints.SERVICE_CONFLICT,\n-                HardSoftLongScore.ofHard(1L));\n+                   HardSoftLongScore.ofHard(1L));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b027f09afce4321e8fc804b84b5da316e46cad92"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4NTc3MA==", "bodyText": "(Similarly for ONE_SOFT.)", "url": "https://github.com/kiegroup/optaplanner/pull/703#discussion_r384185770", "createdAt": "2020-02-25T23:18:20Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -53,31 +62,28 @@\n      * Maximum capacity: The maximum capacity for each resource for each machine must not be exceeded.\n      */\n     private Constraint maximumCapacity(ConstraintFactory factory) {\n-        throw new UnsupportedOperationException(\"Not yet implemented due to missing support for bi-grouping.\");\n-//        return factory.from(MrMachineCapacity.class)\n-//                .join(MrProcessAssignment.class,\n-//                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-//                )\n-//                .groupBy(\n-//                        (machineCapacity, processAssignment) -> machineCapacity, sumLong(\n-//                                (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource())\n-//                        )\n-//                )\n-//                .filter(((machineCapacity, usage) -> machineCapacity.getMaximumCapacity() < usage))\n-//                .penalizeLong(MrConstraints.MAXIMUM_CAPACITY,\n-//                        HardSoftLongScore.ofHard(1L),\n-//                        (machineCapacity, usage) -> machineCapacity.getMaximumCapacity() - usage);\n+        return factory.from(MrMachineCapacity.class)\n+                .join(MrProcessAssignment.class,\n+                      equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n+                )\n+                .groupBy((machineCapacity, processAssignment) -> machineCapacity, sumLong(\n+                        (machineCapacity, processAssignment) -> processAssignment.getUsage(machineCapacity.getResource()))\n+                )\n+                .filter(((machineCapacity, usage) -> machineCapacity.getMaximumCapacity() < usage))\n+                .penalizeLong(MrConstraints.MAXIMUM_CAPACITY,\n+                              HardSoftLongScore.ofHard(1L),\n+                              (machineCapacity, usage) -> machineCapacity.getMaximumCapacity() - usage);\n     }\n \n     /**\n      * Conflict: Processes of the same service must run on distinct machines.\n      */\n     private Constraint serviceConflict(ConstraintFactory factory) {\n         return factory.fromUniquePair(MrProcessAssignment.class,\n-                equal(MrProcessAssignment::getMachine),\n-                equal(MrProcessAssignment::getService)\n+                                      equal(MrProcessAssignment::getMachine),\n+                                      equal(MrProcessAssignment::getService)\n         ).penalize(MrConstraints.SERVICE_CONFLICT,\n-                HardSoftLongScore.ofHard(1L));\n+                   HardSoftLongScore.ofHard(1L));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4NTY4Ng=="}, "originalCommit": {"oid": "b027f09afce4321e8fc804b84b5da316e46cad92"}, "originalPosition": 90}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4435, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}