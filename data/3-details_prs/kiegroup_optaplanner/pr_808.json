{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4MTc1Mzc0", "number": 808, "title": "WIP: Convert MeetingScheduling example to ConstraintStreams", "bodyText": "Jira: https://issues.redhat.com/browse/PLANNER-1820", "createdAt": "2020-06-22T21:01:29Z", "url": "https://github.com/kiegroup/optaplanner/pull/808", "merged": true, "mergeCommit": {"oid": "c7a3c65ad5066060c657e5762c371764a88ff7ae"}, "closed": true, "closedAt": "2020-07-14T06:56:06Z", "author": {"login": "cuijulian"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuf-JOABqjM0NzkyMDI3Mzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc0ngV1ABqjM1NDExODk0NDU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4cc5da6b5335b7cb93c026df24a249c11ca502e1", "author": {"user": null}, "url": "https://github.com/kiegroup/optaplanner/commit/4cc5da6b5335b7cb93c026df24a249c11ca502e1", "committedDate": "2020-06-22T20:48:34Z", "message": "Convert MeetingScheduling example to ConstraintStreams"}, "afterCommit": {"oid": "b9125e2e6b51b3cc2ed0086cc15d11280a6b3ed2", "author": {"user": null}, "url": "https://github.com/kiegroup/optaplanner/commit/b9125e2e6b51b3cc2ed0086cc15d11280a6b3ed2", "committedDate": "2020-06-24T20:20:56Z", "message": "Convert MeetingScheduling example to ConstraintStreams"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NzkyODE3", "url": "https://github.com/kiegroup/optaplanner/pull/808#pullrequestreview-439792817", "createdAt": "2020-06-30T08:35:20Z", "commit": {"oid": "b9125e2e6b51b3cc2ed0086cc15d11280a6b3ed2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwODozNToyMFrOGqx32g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwODozNToyMFrOGqx32g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUxMDQ5MA==", "bodyText": "The problem lies in from(MeetingAssignment.class). There are no such instances, because you never set any value to MeetingAssignment.room planning variable. from() therefore treats those instances as uninitialized, and skips them. Two solutions:\n\nuse fromUnfiltered() in the constraint provider or\ninitialize your entities properly in the test.\n\nAlso, I suggest you make sure your @PlanningIds are never null, because the following PR will start enforcing that pretty soon:\ntriceo#14\nI have not reviewed any other constraints as I assumed the same problem would be plagueing them as well.", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r447510490", "createdAt": "2020-06-30T08:35:20Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/test/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProviderTest.java", "diffHunk": "@@ -0,0 +1,616 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.examples.meetingscheduling.domain.*;\n+import org.optaplanner.test.api.score.stream.ConstraintVerifier;\n+\n+public class MeetingSchedulingConstraintProviderTest {\n+\n+    private final ConstraintVerifier<MeetingSchedulingConstraintProvider, MeetingSchedule> constraintVerifier =\n+            ConstraintVerifier.build(new MeetingSchedulingConstraintProvider(), MeetingSchedule.class,\n+                    MeetingAssignment.class);\n+\n+    @Test\n+    public void roomConflictUnpenalized() {\n+        Room room = new Room();\n+\n+        TimeGrain timeGrain1 = new TimeGrain();\n+        timeGrain1.setGrainIndex(0);\n+\n+        Meeting meeting1 = new Meeting();\n+        meeting1.setDurationInGrains(4);\n+\n+        MeetingAssignment leftAssignment = new MeetingAssignment();\n+        leftAssignment.setId(0L);\n+        leftAssignment.setRoom(room);\n+        leftAssignment.setStartingTimeGrain(timeGrain1);\n+        leftAssignment.setMeeting(meeting1);\n+\n+        TimeGrain timeGrain2 = new TimeGrain();\n+        timeGrain2.setGrainIndex(4);\n+\n+        Meeting meeting2 = new Meeting();\n+        meeting2.setDurationInGrains(4);\n+\n+        MeetingAssignment rightAssignment = new MeetingAssignment();\n+        rightAssignment.setId(1L);\n+        rightAssignment.setRoom(room);\n+        rightAssignment.setStartingTimeGrain(timeGrain2);\n+        rightAssignment.setMeeting(meeting2);\n+\n+        constraintVerifier.verifyThat(MeetingSchedulingConstraintProvider::roomConflict)\n+                .given(leftAssignment, rightAssignment)\n+                .penalizesBy(0);\n+    }\n+\n+    @Test\n+    public void roomConflictPenalized() {\n+        Room room = new Room();\n+\n+        TimeGrain timeGrain1 = new TimeGrain();\n+        timeGrain1.setGrainIndex(0);\n+\n+        Meeting meeting1 = new Meeting();\n+        meeting1.setDurationInGrains(4);\n+\n+        MeetingAssignment leftAssignment = new MeetingAssignment();\n+        leftAssignment.setId(0L);\n+        leftAssignment.setRoom(room);\n+        leftAssignment.setStartingTimeGrain(timeGrain1);\n+        leftAssignment.setMeeting(meeting1);\n+\n+        TimeGrain timeGrain2 = new TimeGrain();\n+        timeGrain2.setGrainIndex(2);\n+\n+        Meeting meeting2 = new Meeting();\n+        meeting2.setDurationInGrains(4);\n+\n+        MeetingAssignment rightAssignment = new MeetingAssignment();\n+        rightAssignment.setId(1L);\n+        rightAssignment.setRoom(room);\n+        rightAssignment.setStartingTimeGrain(timeGrain2);\n+        rightAssignment.setMeeting(meeting2);\n+\n+        constraintVerifier.verifyThat(MeetingSchedulingConstraintProvider::roomConflict)\n+                .given(leftAssignment, rightAssignment)\n+                .penalizesBy(2);\n+    }\n+\n+    @Test\n+    public void avoidOvertimeUnpenalized() {\n+        TimeGrain timeGrain = new TimeGrain();\n+        timeGrain.setGrainIndex(3);\n+\n+        TimeGrain assignmentTimeGrain = new TimeGrain();\n+        assignmentTimeGrain.setGrainIndex(0);\n+\n+        Meeting meeting = new Meeting();\n+        meeting.setDurationInGrains(4);\n+\n+        MeetingAssignment meetingAssignment = new MeetingAssignment();\n+        meetingAssignment.setStartingTimeGrain(assignmentTimeGrain);\n+        meetingAssignment.setMeeting(meeting);\n+\n+        constraintVerifier.verifyThat(MeetingSchedulingConstraintProvider::avoidOvertime)\n+                .given(meetingAssignment, timeGrain)\n+                .penalizesBy(0);\n+    }\n+\n+    @Test\n+    public void avoidOvertimePenalized() {\n+        TimeGrain assignmentTimeGrain = new TimeGrain();\n+        assignmentTimeGrain.setGrainIndex(0);\n+\n+        Meeting meeting = new Meeting();\n+        meeting.setDurationInGrains(4);\n+\n+        MeetingAssignment meetingAssignment = new MeetingAssignment();\n+        meetingAssignment.setStartingTimeGrain(assignmentTimeGrain);\n+        meetingAssignment.setMeeting(meeting);\n+\n+        constraintVerifier.verifyThat(MeetingSchedulingConstraintProvider::avoidOvertime)\n+                .given(meetingAssignment)\n+                .penalizesBy(3);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9125e2e6b51b3cc2ed0086cc15d11280a6b3ed2"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5Nzk1NTQz", "url": "https://github.com/kiegroup/optaplanner/pull/808#pullrequestreview-439795543", "createdAt": "2020-06-30T08:38:40Z", "commit": {"oid": "b9125e2e6b51b3cc2ed0086cc15d11280a6b3ed2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwODozODo0MFrOGqyAlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwODozODo0MFrOGqyAlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUxMjcyNg==", "bodyText": "Please remember to include in the given(...) call all the facts relevant to the problem. Not including them here means you won't be able to use them in join(), exists() etc.", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r447512726", "createdAt": "2020-06-30T08:38:40Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/test/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProviderTest.java", "diffHunk": "@@ -0,0 +1,616 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.examples.meetingscheduling.domain.*;\n+import org.optaplanner.test.api.score.stream.ConstraintVerifier;\n+\n+public class MeetingSchedulingConstraintProviderTest {\n+\n+    private final ConstraintVerifier<MeetingSchedulingConstraintProvider, MeetingSchedule> constraintVerifier =\n+            ConstraintVerifier.build(new MeetingSchedulingConstraintProvider(), MeetingSchedule.class,\n+                    MeetingAssignment.class);\n+\n+    @Test\n+    public void roomConflictUnpenalized() {\n+        Room room = new Room();\n+\n+        TimeGrain timeGrain1 = new TimeGrain();\n+        timeGrain1.setGrainIndex(0);\n+\n+        Meeting meeting1 = new Meeting();\n+        meeting1.setDurationInGrains(4);\n+\n+        MeetingAssignment leftAssignment = new MeetingAssignment();\n+        leftAssignment.setId(0L);\n+        leftAssignment.setRoom(room);\n+        leftAssignment.setStartingTimeGrain(timeGrain1);\n+        leftAssignment.setMeeting(meeting1);\n+\n+        TimeGrain timeGrain2 = new TimeGrain();\n+        timeGrain2.setGrainIndex(4);\n+\n+        Meeting meeting2 = new Meeting();\n+        meeting2.setDurationInGrains(4);\n+\n+        MeetingAssignment rightAssignment = new MeetingAssignment();\n+        rightAssignment.setId(1L);\n+        rightAssignment.setRoom(room);\n+        rightAssignment.setStartingTimeGrain(timeGrain2);\n+        rightAssignment.setMeeting(meeting2);\n+\n+        constraintVerifier.verifyThat(MeetingSchedulingConstraintProvider::roomConflict)\n+                .given(leftAssignment, rightAssignment)\n+                .penalizesBy(0);\n+    }\n+\n+    @Test\n+    public void roomConflictPenalized() {\n+        Room room = new Room();\n+\n+        TimeGrain timeGrain1 = new TimeGrain();\n+        timeGrain1.setGrainIndex(0);\n+\n+        Meeting meeting1 = new Meeting();\n+        meeting1.setDurationInGrains(4);\n+\n+        MeetingAssignment leftAssignment = new MeetingAssignment();\n+        leftAssignment.setId(0L);\n+        leftAssignment.setRoom(room);\n+        leftAssignment.setStartingTimeGrain(timeGrain1);\n+        leftAssignment.setMeeting(meeting1);\n+\n+        TimeGrain timeGrain2 = new TimeGrain();\n+        timeGrain2.setGrainIndex(2);\n+\n+        Meeting meeting2 = new Meeting();\n+        meeting2.setDurationInGrains(4);\n+\n+        MeetingAssignment rightAssignment = new MeetingAssignment();\n+        rightAssignment.setId(1L);\n+        rightAssignment.setRoom(room);\n+        rightAssignment.setStartingTimeGrain(timeGrain2);\n+        rightAssignment.setMeeting(meeting2);\n+\n+        constraintVerifier.verifyThat(MeetingSchedulingConstraintProvider::roomConflict)\n+                .given(leftAssignment, rightAssignment)\n+                .penalizesBy(2);\n+    }\n+\n+    @Test\n+    public void avoidOvertimeUnpenalized() {\n+        TimeGrain timeGrain = new TimeGrain();\n+        timeGrain.setGrainIndex(3);\n+\n+        TimeGrain assignmentTimeGrain = new TimeGrain();\n+        assignmentTimeGrain.setGrainIndex(0);\n+\n+        Meeting meeting = new Meeting();\n+        meeting.setDurationInGrains(4);\n+\n+        MeetingAssignment meetingAssignment = new MeetingAssignment();\n+        meetingAssignment.setStartingTimeGrain(assignmentTimeGrain);\n+        meetingAssignment.setMeeting(meeting);\n+\n+        constraintVerifier.verifyThat(MeetingSchedulingConstraintProvider::avoidOvertime)\n+                .given(meetingAssignment, timeGrain)\n+                .penalizesBy(0);\n+    }\n+\n+    @Test\n+    public void avoidOvertimePenalized() {\n+        TimeGrain assignmentTimeGrain = new TimeGrain();\n+        assignmentTimeGrain.setGrainIndex(0);\n+\n+        Meeting meeting = new Meeting();\n+        meeting.setDurationInGrains(4);\n+\n+        MeetingAssignment meetingAssignment = new MeetingAssignment();\n+        meetingAssignment.setStartingTimeGrain(assignmentTimeGrain);\n+        meetingAssignment.setMeeting(meeting);\n+\n+        constraintVerifier.verifyThat(MeetingSchedulingConstraintProvider::avoidOvertime)\n+                .given(meetingAssignment)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9125e2e6b51b3cc2ed0086cc15d11280a6b3ed2"}, "originalPosition": 131}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b9125e2e6b51b3cc2ed0086cc15d11280a6b3ed2", "author": {"user": null}, "url": "https://github.com/kiegroup/optaplanner/commit/b9125e2e6b51b3cc2ed0086cc15d11280a6b3ed2", "committedDate": "2020-06-24T20:20:56Z", "message": "Convert MeetingScheduling example to ConstraintStreams"}, "afterCommit": {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264", "author": {"user": null}, "url": "https://github.com/kiegroup/optaplanner/commit/8726f57d0eede9f773e32aae9ca00f51fe43f264", "committedDate": "2020-07-08T15:13:47Z", "message": "Convert MeetingScheduling example to ConstraintStreams"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MDQ2Nzc2", "url": "https://github.com/kiegroup/optaplanner/pull/808#pullrequestreview-445046776", "createdAt": "2020-07-08T18:58:56Z", "commit": {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxODo1ODo1NlrOGu1UQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxOTowNTo0NlrOGu1ikQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTIxOQ==", "bodyText": "Joiners.equal(...)?", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451761219", "createdAt": "2020-07-08T18:58:56Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTI5OA==", "bodyText": "Joiners.equal(...)?", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451761298", "createdAt": "2020-07-08T18:59:06Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTU5NQ==", "bodyText": "Joiners.equal(...)?", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451761595", "createdAt": "2020-07-08T18:59:37Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTY0OQ==", "bodyText": "Joiners.equal(...)?", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451761649", "createdAt": "2020-07-08T18:59:43Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTgxMg==", "bodyText": "Joiners.equal(...)?", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451761812", "createdAt": "2020-07-08T19:00:02Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required and preferred attendance conflict\");\n+    }\n+\n+    protected Constraint preferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PreferredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson),\n+                        lessThan(PreferredAttendance::getId, PreferredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTg2Ng==", "bodyText": "Joiners.equal(...)?", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451761866", "createdAt": "2020-07-08T19:00:08Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required and preferred attendance conflict\");\n+    }\n+\n+    protected Constraint preferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PreferredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson),\n+                        lessThan(PreferredAttendance::getId, PreferredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAttendance.getMeeting() == rightAssignment.getMeeting()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MjkzMA==", "bodyText": "fromUniquePair(...)?\nAlso, when operating on objects of the same type, equal(PreferredAttendance::getPerson) is syntactic sugar for equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson).\nI believe the same is true for lessThan().", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451762930", "createdAt": "2020-07-08T19:02:04Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required and preferred attendance conflict\");\n+    }\n+\n+    protected Constraint preferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PreferredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson),\n+                        lessThan(PreferredAttendance::getId, PreferredAttendance::getId))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MzI0NA==", "bodyText": "I think this should be doable via equal() as well.", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451763244", "createdAt": "2020-07-08T19:02:42Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required and preferred attendance conflict\");\n+    }\n+\n+    protected Constraint preferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PreferredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson),\n+                        lessThan(PreferredAttendance::getId, PreferredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Preferred attendance conflict\");\n+    }\n+\n+    // ************************************************************************\n+    // Soft constraints\n+    // ************************************************************************\n+\n+    protected Constraint doMeetingsAsSoonAsPossible(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .penalizeConfigurable(\"Do all meetings as soon as possible\",\n+                        MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint oneBreakBetweenConsecutiveMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> leftAssignment\n+                                        .getLastTimeGrainIndex() == rightAssignment.getStartingTimeGrain().getGrainIndex() - 1))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MzY1Nw==", "bodyText": "lessThan()?", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451763657", "createdAt": "2020-07-08T19:03:30Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required and preferred attendance conflict\");\n+    }\n+\n+    protected Constraint preferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PreferredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson),\n+                        lessThan(PreferredAttendance::getId, PreferredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Preferred attendance conflict\");\n+    }\n+\n+    // ************************************************************************\n+    // Soft constraints\n+    // ************************************************************************\n+\n+    protected Constraint doMeetingsAsSoonAsPossible(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .penalizeConfigurable(\"Do all meetings as soon as possible\",\n+                        MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint oneBreakBetweenConsecutiveMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> leftAssignment\n+                                        .getLastTimeGrainIndex() == rightAssignment.getStartingTimeGrain().getGrainIndex() - 1))\n+                .penalizeConfigurable(\"One TimeGrain break between two consecutive meetings\");\n+    }\n+\n+    protected Constraint overlappingMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> rightAssignment.getMeeting().getId() < leftAssignment.getMeeting().getId()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2Mzg3OA==", "bodyText": "Joiners.equal()?", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451763878", "createdAt": "2020-07-08T19:03:55Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required and preferred attendance conflict\");\n+    }\n+\n+    protected Constraint preferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PreferredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson),\n+                        lessThan(PreferredAttendance::getId, PreferredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Preferred attendance conflict\");\n+    }\n+\n+    // ************************************************************************\n+    // Soft constraints\n+    // ************************************************************************\n+\n+    protected Constraint doMeetingsAsSoonAsPossible(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .penalizeConfigurable(\"Do all meetings as soon as possible\",\n+                        MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint oneBreakBetweenConsecutiveMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> leftAssignment\n+                                        .getLastTimeGrainIndex() == rightAssignment.getStartingTimeGrain().getGrainIndex() - 1))\n+                .penalizeConfigurable(\"One TimeGrain break between two consecutive meetings\");\n+    }\n+\n+    protected Constraint overlappingMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> rightAssignment.getMeeting().getId() < leftAssignment.getMeeting().getId()),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> leftAssignment.getMeeting() != rightAssignment.getMeeting()),\n+                        filtering((leftAssignment, rightAssignment) -> leftAssignment.calculateOverlap(rightAssignment) != 0))\n+                .penalizeConfigurable(\"Overlapping meetings\");\n+    }\n+\n+    // TODO: Unspecified bug marked in DRL\n+    protected Constraint assignLargerRoomsFirst(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRoom() != null)\n+                .join(Room.class,\n+                        lessThan(MeetingAssignment::getRoomCapacity, Room::getCapacity))\n+                .penalizeConfigurable(\"Assign larger rooms first\",\n+                        (meetingAssignment, room) -> room.getCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint roomStability(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Attendance.class)\n+                .join(Attendance.class,\n+                        equal(Attendance::getPerson, Attendance::getPerson),\n+                        filtering((leftAttendance,\n+                                rightAttendance) -> leftAttendance.getMeeting() != rightAttendance.getMeeting()))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2Mzk5OQ==", "bodyText": "Joiners.equal()?", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451763999", "createdAt": "2020-07-08T19:04:11Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required and preferred attendance conflict\");\n+    }\n+\n+    protected Constraint preferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PreferredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson),\n+                        lessThan(PreferredAttendance::getId, PreferredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Preferred attendance conflict\");\n+    }\n+\n+    // ************************************************************************\n+    // Soft constraints\n+    // ************************************************************************\n+\n+    protected Constraint doMeetingsAsSoonAsPossible(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .penalizeConfigurable(\"Do all meetings as soon as possible\",\n+                        MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint oneBreakBetweenConsecutiveMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> leftAssignment\n+                                        .getLastTimeGrainIndex() == rightAssignment.getStartingTimeGrain().getGrainIndex() - 1))\n+                .penalizeConfigurable(\"One TimeGrain break between two consecutive meetings\");\n+    }\n+\n+    protected Constraint overlappingMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> rightAssignment.getMeeting().getId() < leftAssignment.getMeeting().getId()),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> leftAssignment.getMeeting() != rightAssignment.getMeeting()),\n+                        filtering((leftAssignment, rightAssignment) -> leftAssignment.calculateOverlap(rightAssignment) != 0))\n+                .penalizeConfigurable(\"Overlapping meetings\");\n+    }\n+\n+    // TODO: Unspecified bug marked in DRL\n+    protected Constraint assignLargerRoomsFirst(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRoom() != null)\n+                .join(Room.class,\n+                        lessThan(MeetingAssignment::getRoomCapacity, Room::getCapacity))\n+                .penalizeConfigurable(\"Assign larger rooms first\",\n+                        (meetingAssignment, room) -> room.getCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint roomStability(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Attendance.class)\n+                .join(Attendance.class,\n+                        equal(Attendance::getPerson, Attendance::getPerson),\n+                        filtering((leftAttendance,\n+                                rightAttendance) -> leftAttendance.getMeeting() != rightAttendance.getMeeting()))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAttendance.getMeeting() == rightAssignment.getMeeting()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2NDUxOA==", "bodyText": "From the looks of it, this should be doable with lessThan(...).", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451764518", "createdAt": "2020-07-08T19:05:10Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required and preferred attendance conflict\");\n+    }\n+\n+    protected Constraint preferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PreferredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson),\n+                        lessThan(PreferredAttendance::getId, PreferredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Preferred attendance conflict\");\n+    }\n+\n+    // ************************************************************************\n+    // Soft constraints\n+    // ************************************************************************\n+\n+    protected Constraint doMeetingsAsSoonAsPossible(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .penalizeConfigurable(\"Do all meetings as soon as possible\",\n+                        MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint oneBreakBetweenConsecutiveMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> leftAssignment\n+                                        .getLastTimeGrainIndex() == rightAssignment.getStartingTimeGrain().getGrainIndex() - 1))\n+                .penalizeConfigurable(\"One TimeGrain break between two consecutive meetings\");\n+    }\n+\n+    protected Constraint overlappingMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> rightAssignment.getMeeting().getId() < leftAssignment.getMeeting().getId()),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> leftAssignment.getMeeting() != rightAssignment.getMeeting()),\n+                        filtering((leftAssignment, rightAssignment) -> leftAssignment.calculateOverlap(rightAssignment) != 0))\n+                .penalizeConfigurable(\"Overlapping meetings\");\n+    }\n+\n+    // TODO: Unspecified bug marked in DRL\n+    protected Constraint assignLargerRoomsFirst(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRoom() != null)\n+                .join(Room.class,\n+                        lessThan(MeetingAssignment::getRoomCapacity, Room::getCapacity))\n+                .penalizeConfigurable(\"Assign larger rooms first\",\n+                        (meetingAssignment, room) -> room.getCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint roomStability(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Attendance.class)\n+                .join(Attendance.class,\n+                        equal(Attendance::getPerson, Attendance::getPerson),\n+                        filtering((leftAttendance,\n+                                rightAttendance) -> leftAttendance.getMeeting() != rightAttendance.getMeeting()))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> leftAssignment.getStartingTimeGrain().getGrainIndex() < rightAssignment\n+                                        .getStartingTimeGrain().getGrainIndex()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2NDg4MQ==", "bodyText": "I'll take this as you've made sure the DRL and the Provider give matching results. Good.", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451764881", "createdAt": "2020-07-08T19:05:46Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/meetingscheduling/solver/meetingSchedulingSolverConfig.xml", "diffHunk": "@@ -7,7 +7,11 @@\n   <entityClass>org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment</entityClass>\n \n   <scoreDirectorFactory>\n+    <!--<constraintProviderClass>org.optaplanner.examples.meetingscheduling.optional.score.MeetingSchedulingConstraintProvider</constraintProviderClass>-->\n     <scoreDrl>org/optaplanner/examples/meetingscheduling/solver/meetingSchedulingConstraints.drl</scoreDrl>\n+    <!--<assertionScoreDirectorFactory>-->\n+      <!--<scoreDrl>org/optaplanner/examples/meetingscheduling/solver/meetingSchedulingConstraints.drl</scoreDrl>-->\n+    <!--</assertionScoreDirectorFactory> -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fb3899aefdb5a35be2e3a615306fcbcbe3b2867", "author": {"user": null}, "url": "https://github.com/kiegroup/optaplanner/commit/1fb3899aefdb5a35be2e3a615306fcbcbe3b2867", "committedDate": "2020-07-13T20:31:16Z", "message": "Convert MeetingScheduling example to ConstraintStreams"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264", "author": {"user": null}, "url": "https://github.com/kiegroup/optaplanner/commit/8726f57d0eede9f773e32aae9ca00f51fe43f264", "committedDate": "2020-07-08T15:13:47Z", "message": "Convert MeetingScheduling example to ConstraintStreams"}, "afterCommit": {"oid": "1fb3899aefdb5a35be2e3a615306fcbcbe3b2867", "author": {"user": null}, "url": "https://github.com/kiegroup/optaplanner/commit/1fb3899aefdb5a35be2e3a615306fcbcbe3b2867", "committedDate": "2020-07-13T20:31:16Z", "message": "Convert MeetingScheduling example to ConstraintStreams"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3297, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}