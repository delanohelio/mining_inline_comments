{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2NjAxMzUy", "number": 877, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoyMToxNFrOEXhcLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMjo1OToyNlrOEXnZOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTAwNTg5OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/phase/PhaseFactoryProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoyMToxNFrOG_W4LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoyMToxNFrOG_W4LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4ODMwMQ==", "bodyText": "I'd put this as a static method on AbstractPhaseFactory.", "url": "https://github.com/kiegroup/optaplanner/pull/877#discussion_r469088301", "createdAt": "2020-08-12T08:21:14Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/phase/PhaseFactoryProvider.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.phase;\n+\n+import org.optaplanner.core.config.constructionheuristic.ConstructionHeuristicPhaseConfig;\n+import org.optaplanner.core.config.exhaustivesearch.ExhaustiveSearchPhaseConfig;\n+import org.optaplanner.core.config.localsearch.LocalSearchPhaseConfig;\n+import org.optaplanner.core.config.partitionedsearch.PartitionedSearchPhaseConfig;\n+import org.optaplanner.core.config.phase.NoChangePhaseConfig;\n+import org.optaplanner.core.config.phase.PhaseConfig;\n+import org.optaplanner.core.config.phase.custom.CustomPhaseConfig;\n+import org.optaplanner.core.impl.constructionheuristic.DefaultConstructionHeuristicPhaseFactory;\n+import org.optaplanner.core.impl.exhaustivesearch.DefaultExhaustiveSearchPhaseFactory;\n+import org.optaplanner.core.impl.localsearch.DefaultLocalSearchPhaseFactory;\n+import org.optaplanner.core.impl.partitionedsearch.DefaultPartitionedSearchPhaseFactory;\n+import org.optaplanner.core.impl.phase.custom.DefaultCustomPhaseFactory;\n+\n+public class PhaseFactoryProvider<Solution_> {\n+\n+    public AbstractPhaseFactory createPhaseFactory(PhaseConfig<?> phaseConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7efd56ce512f9da3aad52d57190ec44bb98c87f5"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTIwMDUzOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/solver/DefaultSolverFactoryTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOToxMTo1NlrOG_YvrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOToxMTo1NlrOG_YvrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExODg5Mg==", "bodyText": "Nitpicking: Integer.valueOf() is redundant here.", "url": "https://github.com/kiegroup/optaplanner/pull/877#discussion_r469118892", "createdAt": "2020-08-12T09:11:56Z", "author": {"login": "yurloc"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/solver/DefaultSolverFactoryTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.solver;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+\n+class DefaultSolverFactoryTest {\n+\n+    @Test\n+    void moveThreadCountAutoIsCorrectlyResolvedWhenCpuCountIsPositive() {\n+        final int cpuCount = 16;\n+        assertThat(mockMoveThreadCountResolverAuto(cpuCount)).isEqualTo(Integer.valueOf(cpuCount - 2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7efd56ce512f9da3aad52d57190ec44bb98c87f5"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTIyNDk4OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/solver/DefaultSolverFactoryTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOToxODoxMlrOG_Y-bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMTo0ODozN1rOG_dqzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyMjY3MQ==", "bodyText": "Instead of using spy() you can extend the resolver with an anonymous class and override the method to return mockCpuCount:\nDefaultSolverFactory.MoveThreadCountResolver moveThreadCountResolver =\n        new DefaultSolverFactory.MoveThreadCountResolver() {\n            @Override\n            protected int getAvailableProcessors() {\n                return mockCpuCount;\n            }\n        };\nJust an idea.", "url": "https://github.com/kiegroup/optaplanner/pull/877#discussion_r469122671", "createdAt": "2020-08-12T09:18:12Z", "author": {"login": "yurloc"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/solver/DefaultSolverFactoryTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.solver;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+\n+class DefaultSolverFactoryTest {\n+\n+    @Test\n+    void moveThreadCountAutoIsCorrectlyResolvedWhenCpuCountIsPositive() {\n+        final int cpuCount = 16;\n+        assertThat(mockMoveThreadCountResolverAuto(cpuCount)).isEqualTo(Integer.valueOf(cpuCount - 2));\n+    }\n+\n+    @Test\n+    void moveThreadCountAutoIsResolvedToNullWhenCpuCountIsNegative() {\n+        assertThat(mockMoveThreadCountResolverAuto(-1)).isNull();\n+    }\n+\n+    private Integer mockMoveThreadCountResolverAuto(int mockCpuCount) {\n+        DefaultSolverFactory.MoveThreadCountResolver moveThreadCountResolver =\n+                spy(new DefaultSolverFactory.MoveThreadCountResolver());\n+        when(moveThreadCountResolver.getAvailableProcessors()).thenReturn(mockCpuCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7efd56ce512f9da3aad52d57190ec44bb98c87f5"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE5OTU2Nw==", "bodyText": "I like it, thanks for the suggestion.", "url": "https://github.com/kiegroup/optaplanner/pull/877#discussion_r469199567", "createdAt": "2020-08-12T11:48:37Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/solver/DefaultSolverFactoryTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.solver;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+\n+class DefaultSolverFactoryTest {\n+\n+    @Test\n+    void moveThreadCountAutoIsCorrectlyResolvedWhenCpuCountIsPositive() {\n+        final int cpuCount = 16;\n+        assertThat(mockMoveThreadCountResolverAuto(cpuCount)).isEqualTo(Integer.valueOf(cpuCount - 2));\n+    }\n+\n+    @Test\n+    void moveThreadCountAutoIsResolvedToNullWhenCpuCountIsNegative() {\n+        assertThat(mockMoveThreadCountResolverAuto(-1)).isNull();\n+    }\n+\n+    private Integer mockMoveThreadCountResolverAuto(int mockCpuCount) {\n+        DefaultSolverFactory.MoveThreadCountResolver moveThreadCountResolver =\n+                spy(new DefaultSolverFactory.MoveThreadCountResolver());\n+        when(moveThreadCountResolver.getAvailableProcessors()).thenReturn(mockCpuCount);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyMjY3MQ=="}, "originalCommit": {"oid": "7efd56ce512f9da3aad52d57190ec44bb98c87f5"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTQ4OTgwOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/SolverConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMDozMjo0OVrOG_bgNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMDozMjo0OVrOG_bgNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2NDA4NQ==", "bodyText": "Maybe move this to DefaultSolverFactory.", "url": "https://github.com/kiegroup/optaplanner/pull/877#discussion_r469164085", "createdAt": "2020-08-12T10:32:49Z", "author": {"login": "yurloc"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/SolverConfig.java", "diffHunk": "@@ -211,9 +196,7 @@ public static SolverConfig createFromXmlReader(Reader reader, ClassLoader classL\n \n     public static final String MOVE_THREAD_COUNT_NONE = \"NONE\";\n     public static final String MOVE_THREAD_COUNT_AUTO = \"AUTO\";\n-    protected static final long DEFAULT_RANDOM_SEED = 0L;\n-\n-    private static final Logger logger = LoggerFactory.getLogger(SolverConfig.class);\n+    public static final long DEFAULT_RANDOM_SEED = 0L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7efd56ce512f9da3aad52d57190ec44bb98c87f5"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTU1MjgwOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/ScoreDirectorFactoryCreator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMDo1MzoxN1rOG_cGZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMDo1MzoxN1rOG_cGZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE3Mzg2Mg==", "bodyText": "Should be ScoreDirectorFactoryFactory.\nThe current convention seems to be that FooFactory takes FooConfig and build Foo.", "url": "https://github.com/kiegroup/optaplanner/pull/877#discussion_r469173862", "createdAt": "2020-08-12T10:53:17Z", "author": {"login": "yurloc"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/ScoreDirectorFactoryCreator.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.director;\n+\n+import static org.apache.commons.lang3.ObjectUtils.defaultIfNull;\n+\n+import java.io.File;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+import org.kie.api.KieBase;\n+import org.kie.api.KieBaseConfiguration;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.KieBuilder;\n+import org.kie.api.builder.KieFileSystem;\n+import org.kie.api.builder.Message;\n+import org.kie.api.builder.Results;\n+import org.kie.api.builder.model.KieModuleModel;\n+import org.kie.api.io.KieResources;\n+import org.kie.api.runtime.KieContainer;\n+import org.kie.internal.builder.conf.PropertySpecificOption;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.ConstraintStreamImplType;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.score.trend.InitializingScoreTrendLevel;\n+import org.optaplanner.core.config.solver.EnvironmentMode;\n+import org.optaplanner.core.config.util.ConfigUtils;\n+import org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor;\n+import org.optaplanner.core.impl.score.director.drools.DroolsScoreDirectorFactory;\n+import org.optaplanner.core.impl.score.director.drools.testgen.TestGenDroolsScoreDirectorFactory;\n+import org.optaplanner.core.impl.score.director.easy.EasyScoreCalculator;\n+import org.optaplanner.core.impl.score.director.easy.EasyScoreDirectorFactory;\n+import org.optaplanner.core.impl.score.director.incremental.IncrementalScoreCalculator;\n+import org.optaplanner.core.impl.score.director.incremental.IncrementalScoreDirectorFactory;\n+import org.optaplanner.core.impl.score.director.stream.ConstraintStreamScoreDirectorFactory;\n+import org.optaplanner.core.impl.score.trend.InitializingScoreTrend;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ScoreDirectorFactoryCreator<Solution_> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7efd56ce512f9da3aad52d57190ec44bb98c87f5"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTk4MTM5OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/phase/PhaseFactoryProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMjo1OToyNlrOG_gIxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMzoxMjoxMVrOG_goWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI0MDAwNQ==", "bodyText": "This should be a factory method on the PhaseFactory interface. Same pattern as with SolutionFactory.", "url": "https://github.com/kiegroup/optaplanner/pull/877#discussion_r469240005", "createdAt": "2020-08-12T12:59:26Z", "author": {"login": "yurloc"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/phase/PhaseFactoryProvider.java", "diffHunk": "@@ -29,21 +29,26 @@\n import org.optaplanner.core.impl.partitionedsearch.DefaultPartitionedSearchPhaseFactory;\n import org.optaplanner.core.impl.phase.custom.DefaultCustomPhaseFactory;\n \n-public class PhaseFactoryProvider<Solution_> {\n+public class PhaseFactoryProvider {\n \n-    public AbstractPhaseFactory createPhaseFactory(PhaseConfig<?> phaseConfig) {\n+    private PhaseFactoryProvider() {\n+        throw new UnsupportedOperationException(\n+                String.format(\"The class (%s) should not be instantiated.\", PhaseFactoryProvider.class));\n+    }\n+\n+    public static <Solution_> PhaseFactory<Solution_> createPhaseFactory(PhaseConfig<?> phaseConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "880df501b9219e4dc8014f6063b01cd57625ccba"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI0ODA4OQ==", "bodyText": "good catch!", "url": "https://github.com/kiegroup/optaplanner/pull/877#discussion_r469248089", "createdAt": "2020-08-12T13:12:11Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/phase/PhaseFactoryProvider.java", "diffHunk": "@@ -29,21 +29,26 @@\n import org.optaplanner.core.impl.partitionedsearch.DefaultPartitionedSearchPhaseFactory;\n import org.optaplanner.core.impl.phase.custom.DefaultCustomPhaseFactory;\n \n-public class PhaseFactoryProvider<Solution_> {\n+public class PhaseFactoryProvider {\n \n-    public AbstractPhaseFactory createPhaseFactory(PhaseConfig<?> phaseConfig) {\n+    private PhaseFactoryProvider() {\n+        throw new UnsupportedOperationException(\n+                String.format(\"The class (%s) should not be instantiated.\", PhaseFactoryProvider.class));\n+    }\n+\n+    public static <Solution_> PhaseFactory<Solution_> createPhaseFactory(PhaseConfig<?> phaseConfig) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI0MDAwNQ=="}, "originalCommit": {"oid": "880df501b9219e4dc8014f6063b01cd57625ccba"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4402, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}