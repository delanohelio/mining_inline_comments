{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwNzA4Njkx", "number": 890, "title": "PLANNER-2116 Extract build methods from Config classes: termination, entity and value selectors", "bodyText": "JIRA: PLANNER-2116\nThis is a first part of the Jira, the second one will be focused on entity and value selectors.\nHow to retest or run:\n\n\na pull request please add comment: regex [.*[j|J]enkins,?.*(retest|test) this.*]\n\n\na full downstream build please add comment: regex [.*[j|J]enkins,?.*(execute|run|trigger|start|do) fdb.*]\n\n\na compile downstream build please  add comment: regex [.*[j|J]enkins,?.*(execute|run|trigger|start|do) cdb.*]\n\n\na full production downstream please add comment: regex [.*[j|J]enkins,?.*(execute|run|trigger|start|do) product fdb.*]\n\n\nan upstream build please add comment: regex [.*[j|J]enkins,?.*(execute|run|trigger|start|do) upstream.*]\n\n\ni.e for running a full downstream build =  Jenkins do fdb", "createdAt": "2020-08-20T06:59:23Z", "url": "https://github.com/kiegroup/optaplanner/pull/890", "merged": true, "mergeCommit": {"oid": "09adc19460979bfa916215306e03b3eb68c5ece5"}, "closed": true, "closedAt": "2020-08-20T13:47:51Z", "author": {"login": "rsynek"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdAMnbrAH2gAyNDcwNzA4NjkxOmY0MzBkYmNlODU1YjNkMGZhYWE4YmYyNjc5MjQ5MWZmYThmNzQ5NGU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdAvtyRgH2gAyNDcwNzA4NjkxOjZlZTM1YTQxZWIzZDQwZDg1OGYyMzg3NDVmODk5Y2U3NzUwNmIwMDA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f430dbce855b3d0faaa8bf26792491ffa8f7494e", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/f430dbce855b3d0faaa8bf26792491ffa8f7494e", "committedDate": "2020-08-18T19:59:10Z", "message": "PLANNER-2116 Externalize build methods of TerminationConfig"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2e1a476f28c9417a9e9d771141e524cc73eeee1", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/e2e1a476f28c9417a9e9d771141e524cc73eeee1", "committedDate": "2020-08-18T19:59:10Z", "message": "PLANNER-2116 Externalize build method of AcceptorConfig"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21400637f5fe9591ac4575eb2c42c8295ea45a14", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/21400637f5fe9591ac4575eb2c42c8295ea45a14", "committedDate": "2020-08-18T19:59:10Z", "message": "PLANNER-2116 Externalize build method of ForagerConfig"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ca187a5c426563e227ef5c4bbe997402dc9f925", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/7ca187a5c426563e227ef5c4bbe997402dc9f925", "committedDate": "2020-08-18T19:59:10Z", "message": "Fix formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1458019698084bacd442ec33ab04a0163d6eacc", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/b1458019698084bacd442ec33ab04a0163d6eacc", "committedDate": "2020-08-18T19:59:10Z", "message": "PLANNER-2116 Externalize build method of ForagerConfig"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09af9b5a21112181b2be7a291fa55eaaf378c58a", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/09af9b5a21112181b2be7a291fa55eaaf378c58a", "committedDate": "2020-08-19T18:53:40Z", "message": "Externalize build methods from EntityPlacerConfigs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMzMzMTA4", "url": "https://github.com/kiegroup/optaplanner/pull/890#pullrequestreview-471333108", "createdAt": "2020-08-20T07:31:14Z", "commit": {"oid": "09af9b5a21112181b2be7a291fa55eaaf378c58a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozMToxNVrOHDwECQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozMToxNVrOHDwECQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY5NTI0MQ==", "bodyText": "Weird formatting again.", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473695241", "createdAt": "2020-08-20T07:31:15Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/constructionheuristic/decider/forager/ConstructionHeuristicForagerFactory.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.constructionheuristic.decider.forager;\n+\n+import org.optaplanner.core.config.constructionheuristic.decider.forager.ConstructionHeuristicForagerConfig;\n+import org.optaplanner.core.config.constructionheuristic.decider.forager.ConstructionHeuristicPickEarlyType;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+\n+public class ConstructionHeuristicForagerFactory {\n+\n+    public static ConstructionHeuristicForagerFactory create(ConstructionHeuristicForagerConfig foragerConfig) {\n+        return new ConstructionHeuristicForagerFactory(foragerConfig);\n+    }\n+\n+    private final ConstructionHeuristicForagerConfig foragerConfig;\n+\n+    public ConstructionHeuristicForagerFactory(\n+            ConstructionHeuristicForagerConfig foragerConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09af9b5a21112181b2be7a291fa55eaaf378c58a"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMzM0OTEy", "url": "https://github.com/kiegroup/optaplanner/pull/890#pullrequestreview-471334912", "createdAt": "2020-08-20T07:32:01Z", "commit": {"oid": "09af9b5a21112181b2be7a291fa55eaaf378c58a"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozMjowMVrOHDwGXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozNTozMlrOHDwXhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY5NTgzNw==", "bodyText": "Maybe an explanation here would be nice?", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473695837", "createdAt": "2020-08-20T07:32:01Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/constructionheuristic/placer/EntityPlacerFactory.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.constructionheuristic.placer;\n+\n+import org.optaplanner.core.config.constructionheuristic.placer.EntityPlacerConfig;\n+import org.optaplanner.core.config.constructionheuristic.placer.PooledEntityPlacerConfig;\n+import org.optaplanner.core.config.constructionheuristic.placer.QueuedEntityPlacerConfig;\n+import org.optaplanner.core.config.constructionheuristic.placer.QueuedValuePlacerConfig;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+\n+public interface EntityPlacerFactory {\n+\n+    static EntityPlacerFactory create(EntityPlacerConfig entityPlacerConfig) {\n+        if (PooledEntityPlacerConfig.class.isAssignableFrom(entityPlacerConfig.getClass())) {\n+            return new PooledEntityPlacerFactory((PooledEntityPlacerConfig) entityPlacerConfig);\n+        } else if (QueuedEntityPlacerConfig.class.isAssignableFrom(entityPlacerConfig.getClass())) {\n+            return new QueuedEntityPlacerFactory((QueuedEntityPlacerConfig) entityPlacerConfig);\n+        } else if (QueuedValuePlacerConfig.class.isAssignableFrom(entityPlacerConfig.getClass())) {\n+            return new QueuedValuePlacerFactory((QueuedValuePlacerConfig) entityPlacerConfig);\n+        } else {\n+            throw new IllegalArgumentException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09af9b5a21112181b2be7a291fa55eaaf378c58a"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY5NjcyMw==", "bodyText": "Formatting.", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473696723", "createdAt": "2020-08-20T07:32:52Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/constructionheuristic/placer/PooledEntityPlacerFactory.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.constructionheuristic.placer;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.optaplanner.core.config.constructionheuristic.placer.PooledEntityPlacerConfig;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.MoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.composite.CartesianProductMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.ChangeMoveSelectorConfig;\n+import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n+import org.optaplanner.core.impl.domain.variable.descriptor.GenuineVariableDescriptor;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+import org.optaplanner.core.impl.heuristic.selector.move.MoveSelector;\n+import org.optaplanner.core.impl.heuristic.selector.move.MoveSelectorFactory;\n+\n+public class PooledEntityPlacerFactory extends AbstractEntityPlacerFactory<PooledEntityPlacerConfig> {\n+\n+    public PooledEntityPlacerFactory(PooledEntityPlacerConfig placerConfig) {\n+        super(placerConfig);\n+    }\n+\n+    @Override\n+    public PooledEntityPlacer buildEntityPlacer(HeuristicConfigPolicy configPolicy) {\n+        MoveSelectorConfig moveSelectorConfig_ =\n+                placerConfig.getMoveSelectorConfig() == null ? buildMoveSelectorConfig(configPolicy)\n+                        : placerConfig.getMoveSelectorConfig();\n+\n+        MoveSelector moveSelector = MoveSelectorFactory.create(moveSelectorConfig_).buildMoveSelector(\n+                configPolicy, SelectionCacheType.JUST_IN_TIME, SelectionOrder.ORIGINAL);\n+        return new PooledEntityPlacer(moveSelector);\n+    }\n+\n+    private MoveSelectorConfig buildMoveSelectorConfig(HeuristicConfigPolicy configPolicy) {\n+        EntityDescriptor entityDescriptor = configPolicy.getSolutionDescriptor().deduceEntityDescriptor(null);\n+        EntitySelectorConfig entitySelectorConfig = buildEntitySelectorConfig(configPolicy, entityDescriptor);\n+\n+        Collection<GenuineVariableDescriptor> variableDescriptors = entityDescriptor.getGenuineVariableDescriptors();\n+        List<MoveSelectorConfig> subMoveSelectorConfigList = new ArrayList<>(\n+                variableDescriptors.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09af9b5a21112181b2be7a291fa55eaaf378c58a"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY5NzE1MQ==", "bodyText": "Formatting.", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473697151", "createdAt": "2020-08-20T07:33:14Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/constructionheuristic/placer/QueuedEntityPlacerFactory.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.constructionheuristic.placer;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.optaplanner.core.config.constructionheuristic.placer.QueuedEntityPlacerConfig;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.MoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.composite.CartesianProductMoveSelectorConfig;\n+import org.optaplanner.core.config.util.ConfigUtils;\n+import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n+import org.optaplanner.core.impl.domain.variable.descriptor.GenuineVariableDescriptor;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+import org.optaplanner.core.impl.heuristic.selector.entity.EntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.move.MoveSelector;\n+import org.optaplanner.core.impl.heuristic.selector.move.MoveSelectorFactory;\n+\n+public class QueuedEntityPlacerFactory extends AbstractEntityPlacerFactory<QueuedEntityPlacerConfig> {\n+\n+    public QueuedEntityPlacerFactory(QueuedEntityPlacerConfig placerConfig) {\n+        super(placerConfig);\n+    }\n+\n+    @Override\n+    public QueuedEntityPlacer buildEntityPlacer(HeuristicConfigPolicy configPolicy) {\n+        EntitySelectorConfig entitySelectorConfig_ = buildEntitySelectorConfig(configPolicy);\n+        EntitySelector entitySelector = entitySelectorConfig_.buildEntitySelector(configPolicy,\n+                SelectionCacheType.PHASE, SelectionOrder.ORIGINAL);\n+\n+        List<MoveSelectorConfig> moveSelectorConfigList_;\n+        if (ConfigUtils.isEmptyCollection(placerConfig.getMoveSelectorConfigList())) {\n+            EntityDescriptor entityDescriptor = entitySelector.getEntityDescriptor();\n+            Collection<GenuineVariableDescriptor> variableDescriptors = entityDescriptor.getGenuineVariableDescriptors();\n+            List<MoveSelectorConfig> subMoveSelectorConfigList = new ArrayList<>(\n+                    variableDescriptors.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09af9b5a21112181b2be7a291fa55eaaf378c58a"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcwMDIzMA==", "bodyText": "I'd change the logic here. Start with isEmpty(), then check for size == 1.\nThat way, you avoid calling size() twice, and also messing with boundary conditions (>).", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473700230", "createdAt": "2020-08-20T07:35:32Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/solver/termination/TerminationFactory.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.solver.termination;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import org.optaplanner.core.api.score.Score;\n+import org.optaplanner.core.config.solver.termination.TerminationCompositionStyle;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+import org.optaplanner.core.config.util.ConfigUtils;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+import org.optaplanner.core.impl.score.definition.ScoreDefinition;\n+\n+public class TerminationFactory {\n+\n+    public static TerminationFactory create(TerminationConfig terminationConfig) {\n+        return new TerminationFactory(terminationConfig);\n+    }\n+\n+    private final TerminationConfig terminationConfig;\n+\n+    private TerminationFactory(TerminationConfig terminationConfig) {\n+        this.terminationConfig = terminationConfig;\n+    }\n+\n+    public Termination buildTermination(HeuristicConfigPolicy configPolicy, Termination chainedTermination) {\n+        Termination termination = buildTermination(configPolicy);\n+        if (termination == null) {\n+            return chainedTermination;\n+        }\n+        return new OrCompositeTermination(chainedTermination, termination);\n+    }\n+\n+    /**\n+     * @param configPolicy never null\n+     * @return sometimes null\n+     */\n+    public Termination buildTermination(HeuristicConfigPolicy configPolicy) {\n+        List<Termination> terminationList = new ArrayList<>();\n+        if (terminationConfig.getTerminationClass() != null) {\n+            Termination termination =\n+                    ConfigUtils.newInstance(terminationConfig, \"terminationClass\", terminationConfig.getTerminationClass());\n+            terminationList.add(termination);\n+        }\n+\n+        terminationList.addAll(buildTimeBasedTermination(configPolicy));\n+\n+        if (terminationConfig.getBestScoreLimit() != null) {\n+            ScoreDefinition scoreDefinition = configPolicy.getScoreDefinition();\n+            Score bestScoreLimit_ = scoreDefinition.parseScore(terminationConfig.getBestScoreLimit());\n+            double[] timeGradientWeightNumbers = new double[scoreDefinition.getLevelsSize() - 1];\n+            Arrays.fill(timeGradientWeightNumbers, 0.50); // Number pulled out of thin air\n+            terminationList.add(new BestScoreTermination(scoreDefinition, bestScoreLimit_, timeGradientWeightNumbers));\n+        }\n+        if (terminationConfig.getBestScoreFeasible() != null) {\n+            ScoreDefinition scoreDefinition = configPolicy.getScoreDefinition();\n+            if (!terminationConfig.getBestScoreFeasible()) {\n+                throw new IllegalArgumentException(\"The termination bestScoreFeasible (\"\n+                        + terminationConfig.getBestScoreFeasible() + \") cannot be false.\");\n+            }\n+            double[] timeGradientWeightFeasibleNumbers = new double[scoreDefinition.getFeasibleLevelsSize() - 1];\n+            Arrays.fill(timeGradientWeightFeasibleNumbers, 0.50); // Number pulled out of thin air\n+            terminationList.add(new BestScoreFeasibleTermination(scoreDefinition, timeGradientWeightFeasibleNumbers));\n+        }\n+        if (terminationConfig.getStepCountLimit() != null) {\n+            terminationList.add(new StepCountTermination(terminationConfig.getStepCountLimit()));\n+        }\n+        if (terminationConfig.getScoreCalculationCountLimit() != null) {\n+            terminationList.add(new ScoreCalculationCountTermination(terminationConfig.getScoreCalculationCountLimit()));\n+        }\n+        if (terminationConfig.getUnimprovedStepCountLimit() != null) {\n+            terminationList.add(new UnimprovedStepCountTermination(terminationConfig.getUnimprovedStepCountLimit()));\n+        }\n+\n+        terminationList.addAll(buildInnerTermination(configPolicy));\n+        return buildTerminationFromList(terminationList);\n+    }\n+\n+    protected List<Termination> buildTimeBasedTermination(HeuristicConfigPolicy configPolicy) {\n+        List<Termination> terminationList = new ArrayList<>();\n+        Long timeMillisSpentLimit = terminationConfig.calculateTimeMillisSpentLimit();\n+        if (timeMillisSpentLimit != null) {\n+            terminationList.add(new TimeMillisSpentTermination(timeMillisSpentLimit));\n+        }\n+        Long unimprovedTimeMillisSpentLimit = terminationConfig.calculateUnimprovedTimeMillisSpentLimit();\n+        if (unimprovedTimeMillisSpentLimit != null) {\n+            if (terminationConfig.getUnimprovedScoreDifferenceThreshold() == null) {\n+                terminationList.add(new UnimprovedTimeMillisSpentTermination(unimprovedTimeMillisSpentLimit));\n+            } else {\n+                ScoreDefinition scoreDefinition = configPolicy.getScoreDefinition();\n+                Score unimprovedScoreDifferenceThreshold_ =\n+                        scoreDefinition.parseScore(terminationConfig.getUnimprovedScoreDifferenceThreshold());\n+                if (unimprovedScoreDifferenceThreshold_.compareTo(scoreDefinition.getZeroScore()) <= 0) {\n+                    throw new IllegalStateException(\"The unimprovedScoreDifferenceThreshold (\"\n+                            + terminationConfig.getUnimprovedScoreDifferenceThreshold() + \") must be positive.\");\n+\n+                }\n+                terminationList.add(new UnimprovedTimeMillisSpentScoreDifferenceThresholdTermination(\n+                        unimprovedTimeMillisSpentLimit, unimprovedScoreDifferenceThreshold_));\n+            }\n+        } else if (terminationConfig.getUnimprovedScoreDifferenceThreshold() != null) {\n+            throw new IllegalStateException(\"The unimprovedScoreDifferenceThreshold (\"\n+                    + terminationConfig.getUnimprovedScoreDifferenceThreshold()\n+                    + \") can only be used if an unimproved*SpentLimit (\"\n+                    + unimprovedTimeMillisSpentLimit + \") is used too.\");\n+        }\n+\n+        return terminationList;\n+    }\n+\n+    protected List<Termination> buildInnerTermination(HeuristicConfigPolicy configPolicy) {\n+        if (ConfigUtils.isEmptyCollection(terminationConfig.getTerminationConfigList())) {\n+            return Collections.emptyList();\n+        }\n+\n+        return terminationConfig.getTerminationConfigList().stream()\n+                .map(config -> TerminationFactory.create(config).buildTermination(configPolicy))\n+                .filter(Objects::nonNull)\n+                .collect(Collectors.toList());\n+    }\n+\n+    protected Termination buildTerminationFromList(List<Termination> terminationList) {\n+        if (terminationList.size() == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09af9b5a21112181b2be7a291fa55eaaf378c58a"}, "originalPosition": 142}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "003df931c33e6755928f0eb84a0cd8410432d932", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/003df931c33e6755928f0eb84a0cd8410432d932", "committedDate": "2020-08-20T10:32:53Z", "message": "Address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNTE0OTkw", "url": "https://github.com/kiegroup/optaplanner/pull/890#pullrequestreview-471514990", "createdAt": "2020-08-20T11:48:34Z", "commit": {"oid": "003df931c33e6755928f0eb84a0cd8410432d932"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMTo0ODozNFrOHD9MEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMTo0ODozNFrOHD9MEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkxMDI5MQ==", "bodyText": "The fact that the unfold methods create a new PlacerFactory,\nas well as do a lot of defaulting (configuration by exception),\nmakes me think we might want to move them to the Factory side too, alongside the build methods?", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473910291", "createdAt": "2020-08-20T11:48:34Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/constructionheuristic/placer/QueuedEntityPlacerConfig.java", "diffHunk": "@@ -40,22 +36,16 @@\n import org.optaplanner.core.config.heuristic.selector.move.generic.chained.SubChainChangeMoveSelectorConfig;\n import org.optaplanner.core.config.heuristic.selector.move.generic.chained.SubChainSwapMoveSelectorConfig;\n import org.optaplanner.core.config.heuristic.selector.move.generic.chained.TailChainSwapMoveSelectorConfig;\n-import org.optaplanner.core.config.heuristic.selector.value.ValueSelectorConfig;\n import org.optaplanner.core.config.util.ConfigUtils;\n-import org.optaplanner.core.impl.constructionheuristic.placer.QueuedEntityPlacer;\n-import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n-import org.optaplanner.core.impl.domain.variable.descriptor.GenuineVariableDescriptor;\n+import org.optaplanner.core.impl.constructionheuristic.placer.QueuedEntityPlacerFactory;\n import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n-import org.optaplanner.core.impl.heuristic.selector.entity.EntitySelector;\n-import org.optaplanner.core.impl.heuristic.selector.move.MoveSelector;\n-import org.optaplanner.core.impl.heuristic.selector.move.MoveSelectorFactory;\n \n public class QueuedEntityPlacerConfig extends EntityPlacerConfig<QueuedEntityPlacerConfig> {\n \n     public static QueuedEntityPlacerConfig unfoldNew(HeuristicConfigPolicy configPolicy,\n             List<MoveSelectorConfig> templateMoveSelectorConfigList) {\n         QueuedEntityPlacerConfig config = new QueuedEntityPlacerConfig();\n-        config.entitySelectorConfig = config.buildEntitySelectorConfig(configPolicy);\n+        config.entitySelectorConfig = new QueuedEntityPlacerFactory(config).buildEntitySelectorConfig(configPolicy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003df931c33e6755928f0eb84a0cd8410432d932"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNTE4MjQ2", "url": "https://github.com/kiegroup/optaplanner/pull/890#pullrequestreview-471518246", "createdAt": "2020-08-20T11:53:40Z", "commit": {"oid": "003df931c33e6755928f0eb84a0cd8410432d932"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMTo1Mzo0MFrOHD9Wcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMTo1Mzo0MFrOHD9Wcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkxMjk0Nw==", "bodyText": "I presume this is just GitHub getting confused?", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473912947", "createdAt": "2020-08-20T11:53:40Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/config/constructionheuristic/placer/PooledEntityPlacerConfigTest.java", "diffHunk": "@@ -16,46 +16,46 @@\n \n package org.optaplanner.core.config.constructionheuristic.placer;\n \n+import static org.assertj.core.api.Assertions.assertThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n-import java.util.Arrays;\n-\n import org.junit.jupiter.api.Test;\n import org.optaplanner.core.config.heuristic.selector.move.generic.ChangeMoveSelectorConfig;\n import org.optaplanner.core.config.heuristic.selector.value.ValueSelectorConfig;\n import org.optaplanner.core.config.solver.EnvironmentMode;\n-import org.optaplanner.core.impl.constructionheuristic.placer.QueuedEntityPlacer;\n import org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor;\n import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n-import org.optaplanner.core.impl.score.buildin.simple.SimpleScoreDefinition;\n import org.optaplanner.core.impl.score.director.InnerScoreDirectorFactory;\n-import org.optaplanner.core.impl.testdata.domain.multivar.TestdataMultiVarSolution;\n+import org.optaplanner.core.impl.testdata.domain.TestdataEntity;\n+import org.optaplanner.core.impl.testdata.domain.TestdataSolution;\n \n-public class QueuedEntityPlacerConfigTest {\n+public class PooledEntityPlacerConfigTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003df931c33e6755928f0eb84a0cd8410432d932"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNTIwMzUz", "url": "https://github.com/kiegroup/optaplanner/pull/890#pullrequestreview-471520353", "createdAt": "2020-08-20T11:57:08Z", "commit": {"oid": "003df931c33e6755928f0eb84a0cd8410432d932"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ee35a41eb3d40d858f238745f899ce77506b000", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/6ee35a41eb3d40d858f238745f899ce77506b000", "committedDate": "2020-08-20T12:52:47Z", "message": "Move unfoldNew into factories"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3412, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}