{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ2MDAzMzY2", "number": 1078, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxMjowMToyNVrOFOHX-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzo0NDoyOFrOFPA6CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwMzQ1MjEwOnYy", "diffSide": "RIGHT", "path": "Jenkinsfile", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxMjowMToyNVrOISsNKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxMTo1ODo0MFrOIThjZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQ2OTU0NQ==", "bodyText": "Note to self: remove once Kogito has Drools 7.49.\nUntil then, the tests will be failing and I would therefore not get to see Sonar.", "url": "https://github.com/kiegroup/optaplanner/pull/1078#discussion_r556469545", "createdAt": "2021-01-13T12:01:25Z", "author": {"login": "triceo"}, "path": "Jenkinsfile", "diffHunk": "@@ -43,7 +43,7 @@ pipeline {\n         }\n         stage('Build OptaPlanner') {\n             steps {\n-                mavenCleanInstall('optaplanner', false, ['run-code-coverage'], '-Dfull')\n+                mavenCleanInstall('optaplanner', false, ['run-code-coverage'], '-Dfull -Dmaven.test.failure.ignore=true')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b472bff8831d224d02fc513c2c2f64803a20f20f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzI1OTcyOQ==", "bodyText": "I presume this will be removed before merging this PR?", "url": "https://github.com/kiegroup/optaplanner/pull/1078#discussion_r557259729", "createdAt": "2021-01-14T09:36:12Z", "author": {"login": "ge0ffrey"}, "path": "Jenkinsfile", "diffHunk": "@@ -43,7 +43,7 @@ pipeline {\n         }\n         stage('Build OptaPlanner') {\n             steps {\n-                mavenCleanInstall('optaplanner', false, ['run-code-coverage'], '-Dfull')\n+                mavenCleanInstall('optaplanner', false, ['run-code-coverage'], '-Dfull -Dmaven.test.failure.ignore=true')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQ2OTU0NQ=="}, "originalCommit": {"oid": "b472bff8831d224d02fc513c2c2f64803a20f20f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM0MzU4OQ==", "bodyText": "It will.", "url": "https://github.com/kiegroup/optaplanner/pull/1078#discussion_r557343589", "createdAt": "2021-01-14T11:58:40Z", "author": {"login": "triceo"}, "path": "Jenkinsfile", "diffHunk": "@@ -43,7 +43,7 @@ pipeline {\n         }\n         stage('Build OptaPlanner') {\n             steps {\n-                mavenCleanInstall('optaplanner', false, ['run-code-coverage'], '-Dfull')\n+                mavenCleanInstall('optaplanner', false, ['run-code-coverage'], '-Dfull -Dmaven.test.failure.ignore=true')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQ2OTU0NQ=="}, "originalCommit": {"oid": "b472bff8831d224d02fc513c2c2f64803a20f20f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwMzQ1NjE5OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/ScoreDirectorFactoryFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxMjowMjozOVrOISsPpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxMjowMjozOVrOISsPpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQ3MDE4MQ==", "bodyText": "Although technically unrelated, this change improves DRL performance by a couple percentage points, and I was doing the same thing for CS-D, so I decided to introduce it here, too.", "url": "https://github.com/kiegroup/optaplanner/pull/1078#discussion_r556470181", "createdAt": "2021-01-13T12:02:39Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/ScoreDirectorFactoryFactory.java", "diffHunk": "@@ -268,7 +269,7 @@ private void checkMultipleScoreDirectorFactoryTypes(EasyScoreDirectorFactory eas\n         }\n \n         try {\n-            KieBase kieBase = kieHelper.build(ExecutableModelProject.class);\n+            KieBase kieBase = kieHelper.build(ExecutableModelProject.class, KieBaseMutabilityOption.DISABLED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b472bff8831d224d02fc513c2c2f64803a20f20f"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNDg2MTY1OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/DroolsConstraintFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxNzoxMTo1MVrOIS5uhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxNzoxMTo1MVrOIS5uhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY5MTA3OQ==", "bodyText": "Please check the star imports; I have seen them on multiple classes in the PR.", "url": "https://github.com/kiegroup/optaplanner/pull/1078#discussion_r556691079", "createdAt": "2021-01-13T17:11:51Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/DroolsConstraintFactory.java", "diffHunk": "@@ -18,11 +18,8 @@\n \n import static org.drools.model.DSL.globalOf;\n \n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49459a3d4260371fcf70c15d616f0d1249307072"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwOTU4MTk3OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/AbstractBiConstraintConsequence.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNDozODo1MFrOITniWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNDozODo1MFrOITniWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzQ0MTYyNw==", "bodyText": "The code below seem to access to the first two items of the variables array. Can it contain more items?", "url": "https://github.com/kiegroup/optaplanner/pull/1078#discussion_r557441627", "createdAt": "2021-01-14T14:38:50Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/AbstractBiConstraintConsequence.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common;\n+\n+import java.math.BigDecimal;\n+import java.util.function.BiFunction;\n+import java.util.function.Supplier;\n+import java.util.function.ToIntBiFunction;\n+import java.util.function.ToLongBiFunction;\n+\n+import org.drools.model.DSL;\n+import org.drools.model.Drools;\n+import org.drools.model.Global;\n+import org.drools.model.Variable;\n+import org.drools.model.consequences.ConsequenceBuilder;\n+import org.optaplanner.core.impl.score.holder.AbstractScoreHolder;\n+import org.optaplanner.core.impl.score.stream.drools.DroolsConstraint;\n+\n+abstract class AbstractBiConstraintConsequence<A, B> extends AbstractConstraintConsequence<BiLeftHandSide<A, B>> {\n+\n+    @Override\n+    public int getCardinality() {\n+        return 2;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @return Null.\n+     *         When this method returns {@link ConsequenceMatchWeightType#INTEGER}, children of this class are\n+     *         guaranteed to implement {@link ToIntBiFunction}.\n+     *         When this method returns {@link ConsequenceMatchWeightType#LONG}, children of this class are guaranteed\n+     *         to implement {@link ToLongBiFunction}.\n+     *         When this method returns {@link ConsequenceMatchWeightType#BIG_DECIMAL}, children of this class are\n+     *         guaranteed to implement {@link BiFunction} to {@link BigDecimal}.\n+     */\n+    @Override\n+    public abstract ConsequenceMatchWeightType getMatchWeightType();\n+\n+    @Override\n+    protected final ConsequenceBuilder.ValidBuilder buildConsequence(DroolsConstraint constraint,\n+            Global<? extends AbstractScoreHolder<?>> scoreHolderGlobal, Variable... variables) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49459a3d4260371fcf70c15d616f0d1249307072"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMDE1NDgyOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/PatternVariable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNjozOTowMlrOITtIvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNjozOTowMlrOITtIvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUzMzM3Mw==", "bodyText": "\"need want\"? Also not sure about using \"we\" in the comments and docs.", "url": "https://github.com/kiegroup/optaplanner/pull/1078#discussion_r557533373", "createdAt": "2021-01-14T16:39:02Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/PatternVariable.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common;\n+\n+import static org.drools.model.PatternDSL.betaIndexedBy;\n+import static org.drools.model.PatternDSL.pattern;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.drools.model.BetaIndex;\n+import org.drools.model.PatternDSL;\n+import org.drools.model.Variable;\n+import org.drools.model.functions.Function1;\n+import org.drools.model.functions.Predicate2;\n+import org.drools.model.view.ViewItem;\n+import org.optaplanner.core.api.function.QuadFunction;\n+import org.optaplanner.core.api.function.QuadPredicate;\n+import org.optaplanner.core.api.function.TriFunction;\n+import org.optaplanner.core.api.function.TriPredicate;\n+import org.optaplanner.core.impl.score.stream.bi.AbstractBiJoiner;\n+import org.optaplanner.core.impl.score.stream.common.JoinerType;\n+\n+class PatternVariable<A> {\n+\n+    private final Variable<A> primaryVariable;\n+    // Patterns in Drools are mutable, yet we need want to share them. Therefore we need to create them on-demand.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49459a3d4260371fcf70c15d616f0d1249307072"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMDMxNTcyOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/BiLeftHandSide.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNzoxNTo1NVrOITutDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNzoxNTo1NVrOITutDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU1OTA1Mg==", "bodyText": "I think the trick with joining two columns into a BiTuple is worth documenting; mainly the motivation.", "url": "https://github.com/kiegroup/optaplanner/pull/1078#discussion_r557559052", "createdAt": "2021-01-14T17:15:55Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/BiLeftHandSide.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common;\n+\n+import static java.util.Collections.singletonList;\n+import static org.drools.model.DSL.*;\n+import static org.drools.model.PatternDSL.pattern;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.ToIntBiFunction;\n+import java.util.function.ToLongBiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.drools.model.PatternDSL;\n+import org.drools.model.Variable;\n+import org.drools.model.view.ViewItem;\n+import org.optaplanner.core.api.function.TriPredicate;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintCollector;\n+import org.optaplanner.core.api.score.stream.tri.TriJoiner;\n+import org.optaplanner.core.impl.score.stream.drools.DroolsVariableFactory;\n+import org.optaplanner.core.impl.score.stream.tri.AbstractTriJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.FilteringTriJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.NoneTriJoiner;\n+\n+public final class BiLeftHandSide<A, B> extends AbstractLeftHandSide {\n+\n+    private final PatternVariable<A> patternVariableA;\n+    private final PatternVariable<B> patternVariableB;\n+\n+    protected BiLeftHandSide(PatternVariable<A> left, PatternVariable<B> right, DroolsVariableFactory variableFactory) {\n+        super(variableFactory);\n+        this.patternVariableA = left;\n+        this.patternVariableB = right;\n+    }\n+\n+    protected BiLeftHandSide(BiLeftHandSide<A, B> leftHandSide, PatternVariable<A> left, PatternVariable<B> right) {\n+        super(leftHandSide.variableFactory);\n+        this.patternVariableA = left;\n+        this.patternVariableB = right;\n+    }\n+\n+    protected PatternVariable<A> getPatternVariableA() {\n+        return patternVariableA;\n+    }\n+\n+    protected PatternVariable<B> getPatternVariableB() {\n+        return patternVariableB;\n+    }\n+\n+    public BiLeftHandSide<A, B> andFilter(BiPredicate<A, B> filter) {\n+        return new BiLeftHandSide<>(this, patternVariableA,\n+                patternVariableB.filter(filter, patternVariableA.getPrimaryVariable()));\n+    }\n+\n+    private <C> BiLeftHandSide<A, B> applyJoiners(Class<C> otherFactType, AbstractTriJoiner<A, B, C> joiner,\n+            TriPredicate<A, B, C> predicate, boolean shouldExist) {\n+        if (joiner == null) {\n+            return applyFilters(otherFactType, predicate, shouldExist);\n+        }\n+        // There is no gamma index in Drools, therefore we replace joining with a filter.\n+        TriPredicate<A, B, C> joinFilter = joiner::matches;\n+        TriPredicate<A, B, C> result = predicate == null ? joinFilter : joinFilter.and(predicate);\n+        // And finally we add the filter to the C pattern.\n+        return applyFilters(otherFactType, result, shouldExist);\n+    }\n+\n+    private <C> BiLeftHandSide<A, B> applyFilters(Class<C> otherFactType, TriPredicate<A, B, C> predicate,\n+            boolean shouldExist) {\n+        Variable<C> toExist = (Variable<C>) variableFactory.createVariable(otherFactType, \"biToExist\");\n+        PatternDSL.PatternDef<C> existencePattern = pattern(toExist);\n+        PatternDSL.PatternDef<C> possiblyFilteredExistencePattern = predicate == null ? existencePattern\n+                : existencePattern.expr(\"Filter using \" + predicate, patternVariableA.getPrimaryVariable(),\n+                        patternVariableB.getPrimaryVariable(), (c, a, b) -> predicate.test(a, b, c));\n+        ViewItem<?> existenceExpression = exists(possiblyFilteredExistencePattern);\n+        if (!shouldExist) {\n+            existenceExpression = not(possiblyFilteredExistencePattern);\n+        }\n+        return new BiLeftHandSide<>(this, patternVariableA, patternVariableB.addDependentExpression(existenceExpression));\n+    }\n+\n+    private <C> BiLeftHandSide<A, B> existsOrNot(Class<C> cClass, TriJoiner<A, B, C>[] joiners, boolean shouldExist) {\n+        int indexOfFirstFilter = -1;\n+        // Prepare the joiner and filter that will be used in the pattern\n+        AbstractTriJoiner<A, B, C> finalJoiner = null;\n+        TriPredicate<A, B, C> finalFilter = null;\n+        for (int i = 0; i < joiners.length; i++) {\n+            AbstractTriJoiner<A, B, C> joiner = (AbstractTriJoiner<A, B, C>) joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof NoneTriJoiner && joiners.length > 1) {\n+                throw new IllegalStateException(\"If present, \" + NoneTriJoiner.class + \" must be the only joiner, got \"\n+                        + Arrays.toString(joiners) + \" instead.\");\n+            } else if (!(joiner instanceof FilteringTriJoiner)) {\n+                if (hasAFilter) {\n+                    throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                            + joiners[indexOfFirstFilter] + \").\");\n+                } else { // Merge this Joiner with the existing Joiners.\n+                    finalJoiner = finalJoiner == null ? joiner : AbstractTriJoiner.merge(finalJoiner, joiner);\n+                }\n+            } else {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+                // Merge all filters into one to avoid paying the penalty for lack of indexing more than once.\n+                finalFilter = finalFilter == null ? joiner.getFilter() : finalFilter.and(joiner.getFilter());\n+            }\n+        }\n+        return applyJoiners(cClass, finalJoiner, finalFilter, shouldExist);\n+    }\n+\n+    public <C> BiLeftHandSide<A, B> andExists(Class<C> cClass, TriJoiner<A, B, C>[] joiners) {\n+        return existsOrNot(cClass, joiners, true);\n+    }\n+\n+    public <C> BiLeftHandSide<A, B> andNotExists(Class<C> cClass, TriJoiner<A, B, C>[] joiners) {\n+        return existsOrNot(cClass, joiners, false);\n+    }\n+\n+    public <C> TriLeftHandSide<A, B, C> andJoin(UniLeftHandSide<C> right, TriJoiner<A, B, C> joiner) {\n+        AbstractTriJoiner<A, B, C> castJoiner = (AbstractTriJoiner<A, B, C>) joiner;\n+        PatternVariable<C> filteredRight = right.getPatternVariableA()\n+                .filter(castJoiner::matches, patternVariableA.getPrimaryVariable(),\n+                        patternVariableB.getPrimaryVariable());\n+        return new TriLeftHandSide<>(patternVariableA, patternVariableB, filteredRight, variableFactory);\n+    }\n+\n+    public <NewA> UniLeftHandSide<NewA> andGroupBy(BiFunction<A, B, NewA> keyMapping) {\n+        Variable<A> inputA = patternVariableA.getPrimaryVariable();\n+        Variable<B> inputB = patternVariableB.getPrimaryVariable();\n+        Variable<NewA> groupKey = variableFactory.createVariable(\"groupKey\");\n+        ViewItem<?> innerGroupByPattern = joinViewItemsWithLogicalAnd(patternVariableA, patternVariableB);\n+        ViewItem<?> groupByPattern = groupBy(innerGroupByPattern, inputA, inputB, groupKey,\n+                keyMapping::apply);\n+        Variable<NewA> newA = (Variable<NewA>) variableFactory.createVariable(\"newA\", from(groupKey));\n+        return new UniLeftHandSide<>(new PatternVariable<>(newA, singletonList(groupByPattern)), variableFactory);\n+    }\n+\n+    public <NewA> UniLeftHandSide<NewA> andGroupBy(BiConstraintCollector<A, B, ?, NewA> collector) {\n+        Variable<BiTuple<A, B>> accumulateSource =\n+                (Variable<BiTuple<A, B>>) variableFactory.createVariable(BiTuple.class, \"source\");\n+        PatternVariable<B> newPatternVariableB = patternVariableB.bind(accumulateSource,\n+                patternVariableA.getPrimaryVariable(), (b, a) -> new BiTuple<>(a, b));\n+        Variable<NewA> outputVariable = variableFactory.createVariable(\"collected\");\n+        ViewItem<?> innerAccumulatePattern = joinViewItemsWithLogicalAnd(patternVariableA, newPatternVariableB);\n+        ViewItem<?> outerAccumulatePattern = accumulate(innerAccumulatePattern,\n+                accFunction(() -> new DroolsBiAccumulateFunction<>(collector), accumulateSource).as(outputVariable));\n+        return new UniLeftHandSide<>(new PatternVariable<>(outputVariable, singletonList(outerAccumulatePattern)),\n+                variableFactory);\n+    }\n+\n+    public <NewA, NewB> BiLeftHandSide<NewA, NewB> andGroupBy(BiFunction<A, B, NewA> keyMappingA,\n+            BiFunction<A, B, NewB> keyMappingB) {\n+        Variable<A> inputA = patternVariableA.getPrimaryVariable();\n+        Variable<B> inputB = patternVariableB.getPrimaryVariable();\n+        Variable<BiTuple<NewA, NewB>> groupKey =\n+                (Variable<BiTuple<NewA, NewB>>) variableFactory.createVariable(BiTuple.class, \"groupKey\");\n+        ViewItem<?> innerGroupByPattern = joinViewItemsWithLogicalAnd(patternVariableA, patternVariableB);\n+        ViewItem<?> groupByPattern = groupBy(innerGroupByPattern, inputA, inputB, groupKey,\n+                (a, b) -> new BiTuple<>(keyMappingA.apply(a, b), keyMappingB.apply(a, b)));\n+        Variable<NewA> newA =\n+                (Variable<NewA>) variableFactory.createVariable(\"newA\", from(groupKey, k -> k.a));\n+        Variable<NewB> newB =\n+                (Variable<NewB>) variableFactory.createVariable(\"newB\", from(groupKey, k -> k.b));\n+        return new BiLeftHandSide<>(new PatternVariable<>(newA, singletonList(groupByPattern)),\n+                new PatternVariable<>(newB), variableFactory);\n+    }\n+\n+    public <NewA, NewB> BiLeftHandSide<NewA, NewB> andGroupBy(BiFunction<A, B, NewA> keyMappingA,\n+            BiConstraintCollector<A, B, ?, NewB> collectorB) {\n+        Variable<A> inputA = patternVariableA.getPrimaryVariable();\n+        Variable<B> inputB = patternVariableB.getPrimaryVariable();\n+        Variable<BiTuple<A, B>> accumulateSource =\n+                (Variable<BiTuple<A, B>>) variableFactory.createVariable(BiTuple.class, \"source\");\n+        PatternVariable<B> newPatternVariableB = patternVariableB.bind(accumulateSource, inputA,\n+                (b, a) -> new BiTuple<>(a, b));\n+        Variable<NewA> groupKey = variableFactory.createVariable(\"groupKey\");\n+        Variable<NewB> output = variableFactory.createVariable(\"output\");\n+        ViewItem<?> innerGroupByPattern = joinViewItemsWithLogicalAnd(patternVariableA, newPatternVariableB);\n+        ViewItem<?> groupByPattern = groupBy(innerGroupByPattern, inputA, inputB, groupKey,\n+                keyMappingA::apply,\n+                accFunction(() -> new DroolsBiAccumulateFunction<>(collectorB), accumulateSource).as(output));\n+        Variable<NewA> newA = (Variable<NewA>) variableFactory.createVariable(\"newA\", from(groupKey));\n+        Variable<NewB> newB = (Variable<NewB>) variableFactory.createVariable(\"newB\", from(output));\n+        return new BiLeftHandSide<>(new PatternVariable<>(newA, singletonList(groupByPattern)),\n+                new PatternVariable<>(newB), variableFactory);\n+    }\n+\n+    public <NewA, NewB, NewC> TriLeftHandSide<NewA, NewB, NewC> andGroupBy(BiFunction<A, B, NewA> keyMappingA,\n+            BiFunction<A, B, NewB> keyMappingB, BiConstraintCollector<A, B, ?, NewC> collectorC) {\n+        Variable<A> inputA = patternVariableA.getPrimaryVariable();\n+        Variable<B> inputB = patternVariableB.getPrimaryVariable();\n+        Variable<BiTuple<A, B>> accumulateSource =\n+                (Variable<BiTuple<A, B>>) variableFactory.createVariable(BiTuple.class, \"source\");\n+        PatternVariable<B> newPatternVariableB = patternVariableB.bind(accumulateSource, inputA,\n+                (b, a) -> new BiTuple<>(a, b));\n+        Variable<BiTuple<NewA, NewB>> groupKey =\n+                (Variable<BiTuple<NewA, NewB>>) variableFactory.createVariable(BiTuple.class, \"groupKey\");\n+        Variable<NewC> output = variableFactory.createVariable(\"output\");\n+        ViewItem<?> innerGroupByPattern = joinViewItemsWithLogicalAnd(patternVariableA, newPatternVariableB);\n+        ViewItem<?> groupByPattern = groupBy(innerGroupByPattern, inputA, inputB, groupKey,\n+                (a, b) -> new BiTuple<>(keyMappingA.apply(a, b), keyMappingB.apply(a, b)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49459a3d4260371fcf70c15d616f0d1249307072"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMjg3ODE2OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/BiLeftHandSide.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzo0NDoyOFrOIUHT5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzo0NDoyOFrOIUHT5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2MjIxMg==", "bodyText": "Naming: I think the parameter should be called predicate:\n\nwe filter based on a predicate\nother methods (see applyJoiners) use that name for the same parameter too", "url": "https://github.com/kiegroup/optaplanner/pull/1078#discussion_r557962212", "createdAt": "2021-01-15T07:44:28Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/BiLeftHandSide.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common;\n+\n+import static java.util.Collections.singletonList;\n+import static org.drools.model.DSL.*;\n+import static org.drools.model.PatternDSL.pattern;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.ToIntBiFunction;\n+import java.util.function.ToLongBiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.drools.model.PatternDSL;\n+import org.drools.model.Variable;\n+import org.drools.model.view.ViewItem;\n+import org.optaplanner.core.api.function.TriPredicate;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintCollector;\n+import org.optaplanner.core.api.score.stream.tri.TriJoiner;\n+import org.optaplanner.core.impl.score.stream.drools.DroolsVariableFactory;\n+import org.optaplanner.core.impl.score.stream.tri.AbstractTriJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.FilteringTriJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.NoneTriJoiner;\n+\n+public final class BiLeftHandSide<A, B> extends AbstractLeftHandSide {\n+\n+    private final PatternVariable<A> patternVariableA;\n+    private final PatternVariable<B> patternVariableB;\n+\n+    protected BiLeftHandSide(PatternVariable<A> left, PatternVariable<B> right, DroolsVariableFactory variableFactory) {\n+        super(variableFactory);\n+        this.patternVariableA = left;\n+        this.patternVariableB = right;\n+    }\n+\n+    protected BiLeftHandSide(BiLeftHandSide<A, B> leftHandSide, PatternVariable<A> left, PatternVariable<B> right) {\n+        super(leftHandSide.variableFactory);\n+        this.patternVariableA = left;\n+        this.patternVariableB = right;\n+    }\n+\n+    protected PatternVariable<A> getPatternVariableA() {\n+        return patternVariableA;\n+    }\n+\n+    protected PatternVariable<B> getPatternVariableB() {\n+        return patternVariableB;\n+    }\n+\n+    public BiLeftHandSide<A, B> andFilter(BiPredicate<A, B> filter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49459a3d4260371fcf70c15d616f0d1249307072"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4203, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}