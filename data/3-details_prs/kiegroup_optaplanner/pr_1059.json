{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxMTYxNDM5", "number": 1059, "title": "PLANNER-2264: Gizmo Member Accessor", "bodyText": "Note that currently, if you use non-public fields, we use the getter of the field, which violates a guarantee we made. Reading private fields is blocked by the bytecode (even if you set the field as accessible), so for private fields, we need to use a getter (either an existing one or a created virtual one) or use the old reflection approach.\n\nJIRA\n\n\nhttps://issues.redhat.com/browse/PLANNER-2264\nReferenced pull requests\n\n\nChecklist\n\n Documentation updated if applicable.\n Upgrade recipe provided if applicable.\n\n\n\nHow to retest this PR or trigger a specific build:\n\n\nfor a pull request build please add comment: Jenkins retest this\nfor a full downstream build please add comment: Jenkins run fdb\nfor a compile downstream build please add comment: Jenkins run cdb\nfor a full production downstream build please add comment: Jenkins execute product fdb\nfor an upstream build please add comment: Jenkins run upstream", "createdAt": "2020-12-02T17:06:57Z", "url": "https://github.com/kiegroup/optaplanner/pull/1059", "merged": true, "mergeCommit": {"oid": "d172f0d37b054394ca7445bbd7f5f9bd476bc48a"}, "closed": true, "closedAt": "2021-01-22T09:53:14Z", "author": {"login": "Christopher-Chianelli"}, "timelineItems": {"totalCount": 54, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdmMsN_gBqjQxMTE0MzU5Njk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdymCiogH2gAyNTMxMTYxNDM5OmVmYmZlZmM0ZDAxZTUyZWU3M2VlM2EwNDcyNDQ3ZjFmNThjZWE0NzI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e2fbe9778f7cdc344a90111e86fb852160912f59", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/e2fbe9778f7cdc344a90111e86fb852160912f59", "committedDate": "2020-12-10T19:40:19Z", "message": "Keep track of only OptaPlanner annotations in gizmo member accessor"}, "afterCommit": {"oid": "73f68ab9de95dbfbf5fd5d02fa7e2b0fbee2bcb3", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/73f68ab9de95dbfbf5fd5d02fa7e2b0fbee2bcb3", "committedDate": "2020-12-14T21:32:47Z", "message": "Organize wrapper classes, added comments to main generator"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed35d30cd1a27b0343c7631356acc10a9d95ee3c", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/ed35d30cd1a27b0343c7631356acc10a9d95ee3c", "committedDate": "2020-12-16T19:04:45Z", "message": "Add tests for domain accessor type property"}, "afterCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/c573c771e287b1037058b488a0bb9a5d8ab94944", "committedDate": "2020-12-16T19:23:30Z", "message": "Rebase fixup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MzQyNTQx", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555342541", "createdAt": "2020-12-18T09:47:30Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOTo0NzozMFrOIIcCGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOTo0NzozMFrOIIcCGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcxODgxMQ==", "bodyText": "Version properties must be in alphabetical order of groupId, no \"***\" lines etc", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545718811", "createdAt": "2020-12-18T09:47:30Z", "author": {"login": "ge0ffrey"}, "path": "build/optaplanner-build-parent/pom.xml", "diffHunk": "@@ -31,6 +31,10 @@\n     <version.com.h2database>1.3.173</version.com.h2database>\n     <version.com.thoughtworks.xstream>1.4.14</version.com.thoughtworks.xstream>\n     <version.io.quarkus>1.10.0.Final</version.io.quarkus>\n+    <!-- keep these aligned with gizmo -->\n+    <version.io.quarkus.gizmo>1.0.4.Final</version.io.quarkus.gizmo>\n+    <version.org.jboss.jandex>2.1.3.Final</version.org.jboss.jandex>\n+    <!-- ***************************** -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MzQ5MjAz", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555349203", "createdAt": "2020-12-18T09:57:13Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOTo1NzoxNFrOIIcX8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOTo1NzoxNFrOIIcX8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyNDQwMA==", "bodyText": "Every time we upgrade Quarkus, we need to upgrade Gizmo and Jandex (it's unlikely we every upgrade gizmo or jandex indepentenly of Quarkus).\nSo I'd remove this comment and add one above the Quarkus version:\n<-- Keep in sync with the versions of org.quarkus.gizmo and org.jboss.jandex -->\nThe Quarkus bom defines gizmo and jandex, but we only import it for optaplanner-quarkus-integration in fear of disrupting OptaPlanner's dependencies. We should set up a meeting with Radovan to see if we can and want to just import the quarkus-bom in optaplanner-build-parent (different issue). Meanwhile that comment will have to do.\n@rsynek Wdyt?", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545724400", "createdAt": "2020-12-18T09:57:14Z", "author": {"login": "ge0ffrey"}, "path": "build/optaplanner-build-parent/pom.xml", "diffHunk": "@@ -31,6 +31,10 @@\n     <version.com.h2database>1.3.173</version.com.h2database>\n     <version.com.thoughtworks.xstream>1.4.14</version.com.thoughtworks.xstream>\n     <version.io.quarkus>1.10.0.Final</version.io.quarkus>\n+    <!-- keep these aligned with gizmo -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MzUwMTE5", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555350119", "createdAt": "2020-12-18T09:58:29Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOTo1ODoyOVrOIIcbDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOTo1ODoyOVrOIIcbDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyNTE5OA==", "bodyText": "(important) Out of sync with our quarkus bom version.\nquarkus-bom 1.10.0.Final has\n\n        <jandex.version>2.2.1.Final</jandex.version>\n       ...\n        <gizmo.version>1.0.6.Final</gizmo.version>", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545725198", "createdAt": "2020-12-18T09:58:29Z", "author": {"login": "ge0ffrey"}, "path": "build/optaplanner-build-parent/pom.xml", "diffHunk": "@@ -31,6 +31,10 @@\n     <version.com.h2database>1.3.173</version.com.h2database>\n     <version.com.thoughtworks.xstream>1.4.14</version.com.thoughtworks.xstream>\n     <version.io.quarkus>1.10.0.Final</version.io.quarkus>\n+    <!-- keep these aligned with gizmo -->\n+    <version.io.quarkus.gizmo>1.0.4.Final</version.io.quarkus.gizmo>\n+    <version.org.jboss.jandex>2.1.3.Final</version.org.jboss.jandex>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MzU0MjEy", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555354212", "createdAt": "2020-12-18T10:04:36Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDowNDozNlrOIIcnFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDowNDozNlrOIIcnFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyODI3Ng==", "bodyText": "Should this be in package \"config\", \"api\" or \"impl\"?\nI'd argue \"api\", because I have a sneaking feeling we might see this in annotation parameters in the future too (see SolutionCloner parameters in @PlanningSolution).", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545728276", "createdAt": "2020-12-18T10:04:36Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/DomainAccessType.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.config.solver;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MzYwNDAz", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555360403", "createdAt": "2020-12-18T10:13:40Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoxMzo0MFrOIIc6Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoxMzo0MFrOIIc6Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMzE1OQ==", "bodyText": "Javadocs, see LookUpStrategyType on how the writing style looks.\nAlso on every enum.\nPut yourself in a user's shoe. What is important in their decision making process? Don't add all the information you know - only the information they would/should care about.\nFor example, for GIZMO, I'd start with \"Generate bytecode to ...\"", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545733159", "createdAt": "2020-12-18T10:13:40Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/DomainAccessType.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.config.solver;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MzYwOTkx", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555360991", "createdAt": "2020-12-18T10:14:30Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoxNDozMVrOIIc8IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoxNDozMVrOIIc8IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMzY2NQ==", "bodyText": "Naming: Do we access a domain? Or do we access a Member of the domain?\nProposal A) DomainAccessType\nProposal B) MemberAccessType\nI'd argue that B) is more appropriate", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545733665", "createdAt": "2020-12-18T10:14:31Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/DomainAccessType.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.config.solver;\n+\n+public enum DomainAccessType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MzYzMjg3", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555363287", "createdAt": "2020-12-18T10:17:49Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoxNzo0OVrOIIdDPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoxNzo0OVrOIIdDPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczNTQ4Ng==", "bodyText": "Reflection is ambiguous. Does LamdbaMetaFactory count as reflection? And MethodHandles/VarHandles?\nSomething to discuss. I suspect we might want to offer all basic options (old school reflection, methodhandles, lamdba meta factory, gizmo) and then the advanced option (auto choose between old school reflection, methodhandles, lamdba meta factory), which is the default?\nBtw, GIZMO is a perfect name.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545735486", "createdAt": "2020-12-18T10:17:49Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/DomainAccessType.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.config.solver;\n+\n+public enum DomainAccessType {\n+    REFLECTION,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MzkyMjc4", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555392278", "createdAt": "2020-12-18T11:00:28Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTowMDoyOFrOIIebvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTowMDoyOFrOIIebvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc1ODE0Mg==", "bodyText": "Putting in between solutionClass and entityClassList (in xsd, fields, get/set/with methods, etc) seems wierd, because:\n\nit applies to both\nif a user defines solutionClass, he/she defines entityClassList. But this new field is much rarer.\n\nProposal A) Put it under entityClassList, because the others are more important (important properties should go first)\nProposal B) Out it above solutionClass because it's a general property.\n+1 for A, +0 for B.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545758142", "createdAt": "2020-12-18T11:00:28Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/SolverConfig.java", "diffHunk": "@@ -235,6 +236,8 @@ public static SolverConfig createFromXmlReader(Reader reader, ClassLoader classL\n     protected Class<? extends ThreadFactory> threadFactoryClass = null;\n \n     protected Class<?> solutionClass = null;\n+\n+    protected DomainAccessType domainAccessType = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1Mzk2NjIx", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555396621", "createdAt": "2020-12-18T11:07:07Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTowNzowN1rOIIepFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTowNzowN1rOIIepFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2MTU1OQ==", "bodyText": "Method signature: domainAccessType is less important to understand this code than member and FIELD_OR_READ_METHOD and even the PlanningId.class. Let's make that the last parameter.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545761559", "createdAt": "2020-12-18T11:07:07Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/util/ConfigUtils.java", "diffHunk": "@@ -401,8 +402,9 @@ public static int resolvePoolSize(String propertyName, String value, String... m\n                     + PlanningId.class.getSimpleName() + \" annotation.\");\n         }\n         Member member = memberList.get(0);\n-        MemberAccessor memberAccessor = MemberAccessorFactory.buildMemberAccessor(member, FIELD_OR_READ_METHOD,\n-                PlanningId.class);\n+        MemberAccessor memberAccessor =\n+                MemberAccessorFactory.buildMemberAccessor(domainAccessType, member, FIELD_OR_READ_METHOD,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1Mzk3MDc2", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555397076", "createdAt": "2020-12-18T11:07:50Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTowNzo1MFrOIIeqYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTowNzo1MFrOIIeqYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2MTg4OQ==", "bodyText": "Let's make domainAccessType the last parameter, because when reading code that calls this method, the clazz (= the what) is more important than the accesstype (the how)", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545761889", "createdAt": "2020-12-18T11:07:50Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/util/ConfigUtils.java", "diffHunk": "@@ -390,7 +391,7 @@ public static int resolvePoolSize(String propertyName, String value, String... m\n         }\n     }\n \n-    public static <C> MemberAccessor findPlanningIdMemberAccessor(Class<C> clazz) {\n+    public static <C> MemberAccessor findPlanningIdMemberAccessor(DomainAccessType domainAccessType, Class<C> clazz) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1Mzk4NjM2", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555398636", "createdAt": "2020-12-18T11:10:13Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxMDoxM1rOIIevEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxMDoxM1rOIIevEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2MzA5MQ==", "bodyText": "Smells like code duplication with the lines above.\nWhat about an array of arrays - is that unit tested?", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545763091", "createdAt": "2020-12-18T11:10:13Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoAnnotationWrappers.java", "diffHunk": "@@ -0,0 +1,690 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.IndexView;\n+import org.optaplanner.core.api.domain.autodiscover.AutoDiscoverMemberType;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfiguration;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfigurationProvider;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintWeight;\n+import org.optaplanner.core.api.domain.entity.PinningFilter;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.entity.PlanningPin;\n+import org.optaplanner.core.api.domain.lookup.LookUpStrategyType;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.ProblemFactProperty;\n+import org.optaplanner.core.api.domain.solution.cloner.SolutionCloner;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.domain.variable.AnchorShadowVariable;\n+import org.optaplanner.core.api.domain.variable.CustomShadowVariable;\n+import org.optaplanner.core.api.domain.variable.InverseRelationShadowVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableGraphType;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableReference;\n+import org.optaplanner.core.api.domain.variable.VariableListener;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionSorterWeightFactory;\n+import org.optaplanner.core.impl.score.definition.ScoreDefinition;\n+\n+/**\n+ * Contains wrappers for Annotations so they may be\n+ * recorded in bytecode. The annotation's values are stored\n+ * in the wrapper's map.\n+ */\n+public class GizmoAnnotationWrappers {\n+\n+    enum AllOptaPlannerAnnotationEnum {\n+        CONSTRAINT_CONFIGURATION(ConstraintConfiguration.class,\n+                ConstraintConfigurationWrapper::new),\n+        CONSTRAINT_CONFIGURATION_PROVIDER(ConstraintConfigurationProvider.class,\n+                ConstraintConfigurationProviderWrapper::new),\n+        CONSTRAINT_WEIGHT(ConstraintWeight.class, ConstraintWeightWrapper::new),\n+        PLANNING_ENTITY(PlanningEntity.class, PlanningEntityWrapper::new),\n+        PLANNING_PIN(PlanningPin.class, PlanningPinWrapper::new),\n+        PLANNING_ID(PlanningId.class, PlanningIdWrapper::new),\n+        PLANNING_ENTITY_COLLECTION_PROPERTY(PlanningEntityCollectionProperty.class,\n+                PlanningEntityCollectionPropertyWrapper::new),\n+        PLANNING_ENTITY_PROPERTY(PlanningEntityProperty.class,\n+                PlanningEntityPropertyWrapper::new),\n+        PLANNING_SCORE(PlanningScore.class, PlanningScoreWrapper::new),\n+        PLANNING_SOLUTION(PlanningSolution.class, PlanningSolutionWrapper::new),\n+        PROBLEM_FACT_COLLECTION_PROPERTY(ProblemFactCollectionProperty.class,\n+                ProblemFactCollectionPropertyWrapper::new),\n+        PROBLEM_FACT_PROPERTY(ProblemFactProperty.class, ProblemFactPropertyWrapper::new),\n+        VALUE_RANGE_PROVIDER(ValueRangeProvider.class, ValueRangeProviderWrapper::new),\n+        ANCHOR_SHADOW_VARIABLE(AnchorShadowVariable.class, AnchorShadowVariableWrapper::new),\n+        CUSTOM_SHADOW_VARIABLE(CustomShadowVariable.class, CustomShadowVariableWrapper::new),\n+        INVERSE_RELATION_SHADOW_VARIABLE(InverseRelationShadowVariable.class,\n+                InverseRelationShadowVariableWrapper::new),\n+        PLANNING_VARIABLE(PlanningVariable.class, PlanningVariableWrapper::new),\n+        PLANNING_VARIABLE_REFERENCE(PlanningVariableReference.class, PlanningVariableReferenceWrapper::new);\n+\n+        Class<?> annotationClass;\n+        Function<Map<String, Object>, Annotation> mapper;\n+\n+        <T extends Annotation> AllOptaPlannerAnnotationEnum(Class<? extends T> annotationClass,\n+                Function<Map<String, Object>, T> mapper) {\n+            this.annotationClass = annotationClass;\n+            this.mapper = (Function<Map<String, Object>, Annotation>) mapper;\n+        }\n+\n+        public Annotation get(Map<String, Object> values) {\n+            return mapper.apply(values);\n+        }\n+\n+        public static Annotation getForClass(Class<? extends Annotation> annotationClass, Map<String, Object> values) {\n+            for (AllOptaPlannerAnnotationEnum annotationType : AllOptaPlannerAnnotationEnum.values()) {\n+                if (annotationClass.equals(annotationType.annotationClass)) {\n+                    return annotationType.get(values);\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Missing case for \" + annotationClass);\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(Class<? extends Annotation> annotationClass) {\n+            return isOptaPlannerAnnotation(annotationClass.getName());\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(String annotationClass) {\n+            return annotationClass.startsWith(\"org.optaplanner.\");\n+        }\n+    }\n+\n+    public static class AnnotationWrapper implements Supplier<Annotation> {\n+        Class<? extends Annotation> annotationType;\n+        Map<String, Object> annotationValues = new HashMap<String, Object>();\n+        Annotation annotation;\n+\n+        public AnnotationWrapper() {\n+        }\n+\n+        public AnnotationWrapper(Annotation annotation) {\n+            this.annotation = annotation;\n+        }\n+\n+        public AnnotationWrapper(AnnotationInstance annotationInstance, IndexView indexView) {\n+            try {\n+                annotationType = (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString());\n+            } catch (ClassNotFoundException e) {\n+                throw new IllegalStateException(e);\n+            }\n+            annotationValues = new HashMap<>();\n+            if (AllOptaPlannerAnnotationEnum.isOptaPlannerAnnotation(annotationType)) {\n+                annotationInstance.valuesWithDefaults(indexView).forEach((value) -> {\n+                    switch (value.kind()) {\n+                        case BYTE:\n+                            annotationValues.put(value.name(),\n+                                    value.asByte());\n+                            break;\n+                        case SHORT:\n+                            annotationValues.put(value.name(),\n+                                    value.asShort());\n+                            break;\n+                        case INTEGER:\n+                            annotationValues.put(value.name(),\n+                                    value.asInt());\n+                            break;\n+                        case CHARACTER:\n+                            annotationValues.put(value.name(),\n+                                    value.asChar());\n+                            break;\n+                        case FLOAT:\n+                            annotationValues.put(value.name(),\n+                                    value.asFloat());\n+                            break;\n+                        case DOUBLE:\n+                            annotationValues.put(value.name(),\n+                                    value.asDouble());\n+                            break;\n+                        case LONG:\n+                            annotationValues.put(value.name(),\n+                                    value.asLong());\n+                            break;\n+                        case BOOLEAN:\n+                            annotationValues.put(value.name(),\n+                                    value.asBoolean());\n+                            break;\n+                        case CLASS:\n+                            try {\n+                                annotationValues.put(value.name(),\n+                                        Class.forName(value.asClass().toString()));\n+                            } catch (ClassNotFoundException e) {\n+                                throw new IllegalStateException(e);\n+                            }\n+                            break;\n+                        case STRING:\n+                            annotationValues.put(value.name(),\n+                                    value.asString());\n+                            break;\n+                        case ENUM:\n+                            annotationValues.put(value.name(),\n+                                    value.asEnum());\n+                            break;\n+                        case ARRAY:\n+                            switch (value.componentKind()) {\n+                                case BYTE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asByteArray());\n+                                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 180}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1Mzk5MTg5", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555399189", "createdAt": "2020-12-18T11:10:53Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxMDo1M1rOIIewwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxMDo1M1rOIIewwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2MzUyMA==", "bodyText": "Don't sweep anything under the carpet.\nEither it works, or fail fast. That's the 2 options.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545763520", "createdAt": "2020-12-18T11:10:53Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoAnnotationWrappers.java", "diffHunk": "@@ -0,0 +1,690 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.IndexView;\n+import org.optaplanner.core.api.domain.autodiscover.AutoDiscoverMemberType;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfiguration;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfigurationProvider;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintWeight;\n+import org.optaplanner.core.api.domain.entity.PinningFilter;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.entity.PlanningPin;\n+import org.optaplanner.core.api.domain.lookup.LookUpStrategyType;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.ProblemFactProperty;\n+import org.optaplanner.core.api.domain.solution.cloner.SolutionCloner;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.domain.variable.AnchorShadowVariable;\n+import org.optaplanner.core.api.domain.variable.CustomShadowVariable;\n+import org.optaplanner.core.api.domain.variable.InverseRelationShadowVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableGraphType;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableReference;\n+import org.optaplanner.core.api.domain.variable.VariableListener;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionSorterWeightFactory;\n+import org.optaplanner.core.impl.score.definition.ScoreDefinition;\n+\n+/**\n+ * Contains wrappers for Annotations so they may be\n+ * recorded in bytecode. The annotation's values are stored\n+ * in the wrapper's map.\n+ */\n+public class GizmoAnnotationWrappers {\n+\n+    enum AllOptaPlannerAnnotationEnum {\n+        CONSTRAINT_CONFIGURATION(ConstraintConfiguration.class,\n+                ConstraintConfigurationWrapper::new),\n+        CONSTRAINT_CONFIGURATION_PROVIDER(ConstraintConfigurationProvider.class,\n+                ConstraintConfigurationProviderWrapper::new),\n+        CONSTRAINT_WEIGHT(ConstraintWeight.class, ConstraintWeightWrapper::new),\n+        PLANNING_ENTITY(PlanningEntity.class, PlanningEntityWrapper::new),\n+        PLANNING_PIN(PlanningPin.class, PlanningPinWrapper::new),\n+        PLANNING_ID(PlanningId.class, PlanningIdWrapper::new),\n+        PLANNING_ENTITY_COLLECTION_PROPERTY(PlanningEntityCollectionProperty.class,\n+                PlanningEntityCollectionPropertyWrapper::new),\n+        PLANNING_ENTITY_PROPERTY(PlanningEntityProperty.class,\n+                PlanningEntityPropertyWrapper::new),\n+        PLANNING_SCORE(PlanningScore.class, PlanningScoreWrapper::new),\n+        PLANNING_SOLUTION(PlanningSolution.class, PlanningSolutionWrapper::new),\n+        PROBLEM_FACT_COLLECTION_PROPERTY(ProblemFactCollectionProperty.class,\n+                ProblemFactCollectionPropertyWrapper::new),\n+        PROBLEM_FACT_PROPERTY(ProblemFactProperty.class, ProblemFactPropertyWrapper::new),\n+        VALUE_RANGE_PROVIDER(ValueRangeProvider.class, ValueRangeProviderWrapper::new),\n+        ANCHOR_SHADOW_VARIABLE(AnchorShadowVariable.class, AnchorShadowVariableWrapper::new),\n+        CUSTOM_SHADOW_VARIABLE(CustomShadowVariable.class, CustomShadowVariableWrapper::new),\n+        INVERSE_RELATION_SHADOW_VARIABLE(InverseRelationShadowVariable.class,\n+                InverseRelationShadowVariableWrapper::new),\n+        PLANNING_VARIABLE(PlanningVariable.class, PlanningVariableWrapper::new),\n+        PLANNING_VARIABLE_REFERENCE(PlanningVariableReference.class, PlanningVariableReferenceWrapper::new);\n+\n+        Class<?> annotationClass;\n+        Function<Map<String, Object>, Annotation> mapper;\n+\n+        <T extends Annotation> AllOptaPlannerAnnotationEnum(Class<? extends T> annotationClass,\n+                Function<Map<String, Object>, T> mapper) {\n+            this.annotationClass = annotationClass;\n+            this.mapper = (Function<Map<String, Object>, Annotation>) mapper;\n+        }\n+\n+        public Annotation get(Map<String, Object> values) {\n+            return mapper.apply(values);\n+        }\n+\n+        public static Annotation getForClass(Class<? extends Annotation> annotationClass, Map<String, Object> values) {\n+            for (AllOptaPlannerAnnotationEnum annotationType : AllOptaPlannerAnnotationEnum.values()) {\n+                if (annotationClass.equals(annotationType.annotationClass)) {\n+                    return annotationType.get(values);\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Missing case for \" + annotationClass);\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(Class<? extends Annotation> annotationClass) {\n+            return isOptaPlannerAnnotation(annotationClass.getName());\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(String annotationClass) {\n+            return annotationClass.startsWith(\"org.optaplanner.\");\n+        }\n+    }\n+\n+    public static class AnnotationWrapper implements Supplier<Annotation> {\n+        Class<? extends Annotation> annotationType;\n+        Map<String, Object> annotationValues = new HashMap<String, Object>();\n+        Annotation annotation;\n+\n+        public AnnotationWrapper() {\n+        }\n+\n+        public AnnotationWrapper(Annotation annotation) {\n+            this.annotation = annotation;\n+        }\n+\n+        public AnnotationWrapper(AnnotationInstance annotationInstance, IndexView indexView) {\n+            try {\n+                annotationType = (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString());\n+            } catch (ClassNotFoundException e) {\n+                throw new IllegalStateException(e);\n+            }\n+            annotationValues = new HashMap<>();\n+            if (AllOptaPlannerAnnotationEnum.isOptaPlannerAnnotation(annotationType)) {\n+                annotationInstance.valuesWithDefaults(indexView).forEach((value) -> {\n+                    switch (value.kind()) {\n+                        case BYTE:\n+                            annotationValues.put(value.name(),\n+                                    value.asByte());\n+                            break;\n+                        case SHORT:\n+                            annotationValues.put(value.name(),\n+                                    value.asShort());\n+                            break;\n+                        case INTEGER:\n+                            annotationValues.put(value.name(),\n+                                    value.asInt());\n+                            break;\n+                        case CHARACTER:\n+                            annotationValues.put(value.name(),\n+                                    value.asChar());\n+                            break;\n+                        case FLOAT:\n+                            annotationValues.put(value.name(),\n+                                    value.asFloat());\n+                            break;\n+                        case DOUBLE:\n+                            annotationValues.put(value.name(),\n+                                    value.asDouble());\n+                            break;\n+                        case LONG:\n+                            annotationValues.put(value.name(),\n+                                    value.asLong());\n+                            break;\n+                        case BOOLEAN:\n+                            annotationValues.put(value.name(),\n+                                    value.asBoolean());\n+                            break;\n+                        case CLASS:\n+                            try {\n+                                annotationValues.put(value.name(),\n+                                        Class.forName(value.asClass().toString()));\n+                            } catch (ClassNotFoundException e) {\n+                                throw new IllegalStateException(e);\n+                            }\n+                            break;\n+                        case STRING:\n+                            annotationValues.put(value.name(),\n+                                    value.asString());\n+                            break;\n+                        case ENUM:\n+                            annotationValues.put(value.name(),\n+                                    value.asEnum());\n+                            break;\n+                        case ARRAY:\n+                            switch (value.componentKind()) {\n+                                case BYTE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asByteArray());\n+                                    break;\n+                                case SHORT:\n+                                    annotationValues.put(value.name(),\n+                                            value.asShortArray());\n+                                    break;\n+                                case INTEGER:\n+                                    annotationValues.put(value.name(),\n+                                            value.asIntArray());\n+                                    break;\n+                                case CHARACTER:\n+                                    annotationValues.put(value.name(),\n+                                            value.asCharArray());\n+                                    break;\n+                                case FLOAT:\n+                                    annotationValues.put(value.name(),\n+                                            value.asFloatArray());\n+                                    break;\n+                                case DOUBLE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asDoubleArray());\n+                                    break;\n+                                case LONG:\n+                                    annotationValues.put(value.name(),\n+                                            value.asLongArray());\n+                                    break;\n+                                case BOOLEAN:\n+                                    annotationValues.put(value.name(),\n+                                            value.asBooleanArray());\n+                                    break;\n+                                case CLASS:\n+                                    Class[] valueArr = Arrays.stream(value.asClassArray())\n+                                            .map(v -> {\n+                                                try {\n+                                                    return Class.forName(v.toString());\n+                                                } catch (ClassNotFoundException e) {\n+                                                    throw new IllegalStateException(e);\n+                                                }\n+                                            })\n+                                            .collect(Collectors.toList()).toArray(new Class[0]);\n+                                    annotationValues.put(value.name(),\n+                                            valueArr);\n+                                    break;\n+                                case STRING:\n+                                    annotationValues.put(value.name(),\n+                                            value.asStringArray());\n+                                    break;\n+                                case ENUM:\n+                                    annotationValues.put(value.name(),\n+                                            value.asEnumArray());\n+                                    break;\n+                                case ARRAY:\n+                                case NESTED:\n+                                case UNKNOWN:\n+                                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 233}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDAwMDY2", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555400066", "createdAt": "2020-12-18T11:12:17Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxMjoxN1rOIIez4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxMjoxN1rOIIez4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NDMyMA==", "bodyText": "All switch statements must have a default that fails fast. For example:\n          switch (type) {\n               case EQUAL:\n               ...\n               default:\n                   throw new UnsupportedOperationException(\"Unsupported joiner type (\" + type + \").\");\n           }", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545764320", "createdAt": "2020-12-18T11:12:17Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoAnnotationWrappers.java", "diffHunk": "@@ -0,0 +1,690 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.IndexView;\n+import org.optaplanner.core.api.domain.autodiscover.AutoDiscoverMemberType;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfiguration;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfigurationProvider;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintWeight;\n+import org.optaplanner.core.api.domain.entity.PinningFilter;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.entity.PlanningPin;\n+import org.optaplanner.core.api.domain.lookup.LookUpStrategyType;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.ProblemFactProperty;\n+import org.optaplanner.core.api.domain.solution.cloner.SolutionCloner;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.domain.variable.AnchorShadowVariable;\n+import org.optaplanner.core.api.domain.variable.CustomShadowVariable;\n+import org.optaplanner.core.api.domain.variable.InverseRelationShadowVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableGraphType;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableReference;\n+import org.optaplanner.core.api.domain.variable.VariableListener;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionSorterWeightFactory;\n+import org.optaplanner.core.impl.score.definition.ScoreDefinition;\n+\n+/**\n+ * Contains wrappers for Annotations so they may be\n+ * recorded in bytecode. The annotation's values are stored\n+ * in the wrapper's map.\n+ */\n+public class GizmoAnnotationWrappers {\n+\n+    enum AllOptaPlannerAnnotationEnum {\n+        CONSTRAINT_CONFIGURATION(ConstraintConfiguration.class,\n+                ConstraintConfigurationWrapper::new),\n+        CONSTRAINT_CONFIGURATION_PROVIDER(ConstraintConfigurationProvider.class,\n+                ConstraintConfigurationProviderWrapper::new),\n+        CONSTRAINT_WEIGHT(ConstraintWeight.class, ConstraintWeightWrapper::new),\n+        PLANNING_ENTITY(PlanningEntity.class, PlanningEntityWrapper::new),\n+        PLANNING_PIN(PlanningPin.class, PlanningPinWrapper::new),\n+        PLANNING_ID(PlanningId.class, PlanningIdWrapper::new),\n+        PLANNING_ENTITY_COLLECTION_PROPERTY(PlanningEntityCollectionProperty.class,\n+                PlanningEntityCollectionPropertyWrapper::new),\n+        PLANNING_ENTITY_PROPERTY(PlanningEntityProperty.class,\n+                PlanningEntityPropertyWrapper::new),\n+        PLANNING_SCORE(PlanningScore.class, PlanningScoreWrapper::new),\n+        PLANNING_SOLUTION(PlanningSolution.class, PlanningSolutionWrapper::new),\n+        PROBLEM_FACT_COLLECTION_PROPERTY(ProblemFactCollectionProperty.class,\n+                ProblemFactCollectionPropertyWrapper::new),\n+        PROBLEM_FACT_PROPERTY(ProblemFactProperty.class, ProblemFactPropertyWrapper::new),\n+        VALUE_RANGE_PROVIDER(ValueRangeProvider.class, ValueRangeProviderWrapper::new),\n+        ANCHOR_SHADOW_VARIABLE(AnchorShadowVariable.class, AnchorShadowVariableWrapper::new),\n+        CUSTOM_SHADOW_VARIABLE(CustomShadowVariable.class, CustomShadowVariableWrapper::new),\n+        INVERSE_RELATION_SHADOW_VARIABLE(InverseRelationShadowVariable.class,\n+                InverseRelationShadowVariableWrapper::new),\n+        PLANNING_VARIABLE(PlanningVariable.class, PlanningVariableWrapper::new),\n+        PLANNING_VARIABLE_REFERENCE(PlanningVariableReference.class, PlanningVariableReferenceWrapper::new);\n+\n+        Class<?> annotationClass;\n+        Function<Map<String, Object>, Annotation> mapper;\n+\n+        <T extends Annotation> AllOptaPlannerAnnotationEnum(Class<? extends T> annotationClass,\n+                Function<Map<String, Object>, T> mapper) {\n+            this.annotationClass = annotationClass;\n+            this.mapper = (Function<Map<String, Object>, Annotation>) mapper;\n+        }\n+\n+        public Annotation get(Map<String, Object> values) {\n+            return mapper.apply(values);\n+        }\n+\n+        public static Annotation getForClass(Class<? extends Annotation> annotationClass, Map<String, Object> values) {\n+            for (AllOptaPlannerAnnotationEnum annotationType : AllOptaPlannerAnnotationEnum.values()) {\n+                if (annotationClass.equals(annotationType.annotationClass)) {\n+                    return annotationType.get(values);\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Missing case for \" + annotationClass);\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(Class<? extends Annotation> annotationClass) {\n+            return isOptaPlannerAnnotation(annotationClass.getName());\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(String annotationClass) {\n+            return annotationClass.startsWith(\"org.optaplanner.\");\n+        }\n+    }\n+\n+    public static class AnnotationWrapper implements Supplier<Annotation> {\n+        Class<? extends Annotation> annotationType;\n+        Map<String, Object> annotationValues = new HashMap<String, Object>();\n+        Annotation annotation;\n+\n+        public AnnotationWrapper() {\n+        }\n+\n+        public AnnotationWrapper(Annotation annotation) {\n+            this.annotation = annotation;\n+        }\n+\n+        public AnnotationWrapper(AnnotationInstance annotationInstance, IndexView indexView) {\n+            try {\n+                annotationType = (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString());\n+            } catch (ClassNotFoundException e) {\n+                throw new IllegalStateException(e);\n+            }\n+            annotationValues = new HashMap<>();\n+            if (AllOptaPlannerAnnotationEnum.isOptaPlannerAnnotation(annotationType)) {\n+                annotationInstance.valuesWithDefaults(indexView).forEach((value) -> {\n+                    switch (value.kind()) {\n+                        case BYTE:\n+                            annotationValues.put(value.name(),\n+                                    value.asByte());\n+                            break;\n+                        case SHORT:\n+                            annotationValues.put(value.name(),\n+                                    value.asShort());\n+                            break;\n+                        case INTEGER:\n+                            annotationValues.put(value.name(),\n+                                    value.asInt());\n+                            break;\n+                        case CHARACTER:\n+                            annotationValues.put(value.name(),\n+                                    value.asChar());\n+                            break;\n+                        case FLOAT:\n+                            annotationValues.put(value.name(),\n+                                    value.asFloat());\n+                            break;\n+                        case DOUBLE:\n+                            annotationValues.put(value.name(),\n+                                    value.asDouble());\n+                            break;\n+                        case LONG:\n+                            annotationValues.put(value.name(),\n+                                    value.asLong());\n+                            break;\n+                        case BOOLEAN:\n+                            annotationValues.put(value.name(),\n+                                    value.asBoolean());\n+                            break;\n+                        case CLASS:\n+                            try {\n+                                annotationValues.put(value.name(),\n+                                        Class.forName(value.asClass().toString()));\n+                            } catch (ClassNotFoundException e) {\n+                                throw new IllegalStateException(e);\n+                            }\n+                            break;\n+                        case STRING:\n+                            annotationValues.put(value.name(),\n+                                    value.asString());\n+                            break;\n+                        case ENUM:\n+                            annotationValues.put(value.name(),\n+                                    value.asEnum());\n+                            break;\n+                        case ARRAY:\n+                            switch (value.componentKind()) {\n+                                case BYTE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asByteArray());\n+                                    break;\n+                                case SHORT:\n+                                    annotationValues.put(value.name(),\n+                                            value.asShortArray());\n+                                    break;\n+                                case INTEGER:\n+                                    annotationValues.put(value.name(),\n+                                            value.asIntArray());\n+                                    break;\n+                                case CHARACTER:\n+                                    annotationValues.put(value.name(),\n+                                            value.asCharArray());\n+                                    break;\n+                                case FLOAT:\n+                                    annotationValues.put(value.name(),\n+                                            value.asFloatArray());\n+                                    break;\n+                                case DOUBLE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asDoubleArray());\n+                                    break;\n+                                case LONG:\n+                                    annotationValues.put(value.name(),\n+                                            value.asLongArray());\n+                                    break;\n+                                case BOOLEAN:\n+                                    annotationValues.put(value.name(),\n+                                            value.asBooleanArray());\n+                                    break;\n+                                case CLASS:\n+                                    Class[] valueArr = Arrays.stream(value.asClassArray())\n+                                            .map(v -> {\n+                                                try {\n+                                                    return Class.forName(v.toString());\n+                                                } catch (ClassNotFoundException e) {\n+                                                    throw new IllegalStateException(e);\n+                                                }\n+                                            })\n+                                            .collect(Collectors.toList()).toArray(new Class[0]);\n+                                    annotationValues.put(value.name(),\n+                                            valueArr);\n+                                    break;\n+                                case STRING:\n+                                    annotationValues.put(value.name(),\n+                                            value.asStringArray());\n+                                    break;\n+                                case ENUM:\n+                                    annotationValues.put(value.name(),\n+                                            value.asEnumArray());\n+                                    break;\n+                                case ARRAY:\n+                                case NESTED:\n+                                case UNKNOWN:\n+                                    break;\n+                            }\n+                            break;\n+                        case NESTED:\n+                        case UNKNOWN:\n+                            break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 238}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDAwODc2", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555400876", "createdAt": "2020-12-18T11:13:32Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxMzozMlrOIIe2Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxMzozMlrOIIe2Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NDk0Mg==", "bodyText": "Naming: This cannot be named GizmoMemberAccessor, because it does not implement MemberAccessor (nor should it).\nWhat does it really do?", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545764942", "createdAt": "2020-12-18T11:13:32Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessor.java", "diffHunk": "@@ -0,0 +1,637 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+public class GizmoMemberAccessor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDAxNTA1", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555401505", "createdAt": "2020-12-18T11:14:31Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxNDozMlrOIIe4Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxNDozMlrOIIe4Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NTQxNQ==", "bodyText": "the acess type last", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545765415", "createdAt": "2020-12-18T11:14:32Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/constraintweight/descriptor/ConstraintConfigurationDescriptor.java", "diffHunk": "@@ -78,7 +79,8 @@ public String getConstraintPackage() {\n     // Lifecycle methods\n     // ************************************************************************\n \n-    public void processAnnotations(DescriptorPolicy descriptorPolicy, ScoreDefinition scoreDefinition) {\n+    public void processAnnotations(DomainAccessType domainAccessType, DescriptorPolicy descriptorPolicy,\n+            ScoreDefinition scoreDefinition) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDAyMzE2", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555402316", "createdAt": "2020-12-18T11:15:54Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxNTo1NFrOIIe6xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxNTo1NFrOIIe6xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NjA4NQ==", "bodyText": "Instead of passing the access type everywhere can't we just make it part of DescriptorPolicy?\nThe Policy objects are exactly created for this purpose: a bunch of general information that is passed to all the build/create/policy methods.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545766085", "createdAt": "2020-12-18T11:15:54Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/entity/descriptor/EntityDescriptor.java", "diffHunk": "@@ -205,16 +206,18 @@ private void processDifficulty(DescriptorPolicy descriptorPolicy, PlanningEntity\n         }\n     }\n \n-    private void processValueRangeProviderAnnotation(DescriptorPolicy descriptorPolicy, Member member) {\n+    private void processValueRangeProviderAnnotation(DomainAccessType domainAccessType, DescriptorPolicy descriptorPolicy,\n+            Member member) {\n         if (((AnnotatedElement) member).isAnnotationPresent(ValueRangeProvider.class)) {\n-            MemberAccessor memberAccessor = MemberAccessorFactory.buildMemberAccessor(\n+            MemberAccessor memberAccessor = MemberAccessorFactory.buildMemberAccessor(domainAccessType,\n                     member, FIELD_OR_READ_METHOD, ValueRangeProvider.class);\n             descriptorPolicy.addFromEntityValueRangeProvider(\n                     memberAccessor);\n         }\n     }\n \n-    private void processPlanningVariableAnnotation(DescriptorPolicy descriptorPolicy, Member member) {\n+    private void processPlanningVariableAnnotation(DomainAccessType domainAccessType, DescriptorPolicy descriptorPolicy,\n+            Member member) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDAzNTA1", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555403505", "createdAt": "2020-12-18T11:18:02Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxODowMlrOIIe-uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxODowMlrOIIe-uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NzA5Nw==", "bodyText": "IMPORTANT\nSwitching method references to anonymous methods that call it can cause performance regression if used within ConstrainStreams, because Foo::getBar == Foo::getBar returns true but foo -> foo.getBar() == foo -> foo.getBar() returns false and this impacts node sharing.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545767097", "createdAt": "2020-12-18T11:18:02Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/lookup/ClassAndPlanningIdComparator.java", "diffHunk": "@@ -51,9 +58,9 @@ public int compare(Object a, Object b) {\n             return aClass.getName().compareTo(bClass.getName());\n         }\n         MemberAccessor aMemberAccessor = decisionCache.computeIfAbsent(aClass,\n-                ConfigUtils::findPlanningIdMemberAccessor);\n+                clazz -> ConfigUtils.findPlanningIdMemberAccessor(domainAccessType, clazz));\n         MemberAccessor bMemberAccessor = decisionCache.computeIfAbsent(bClass,\n-                ConfigUtils::findPlanningIdMemberAccessor);\n+                clazz -> ConfigUtils.findPlanningIdMemberAccessor(domainAccessType, clazz));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDA2Nzgx", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555406781", "createdAt": "2020-12-18T11:23:35Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDA4MTA4", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555408108", "createdAt": "2020-12-18T11:25:44Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToyNTo0NFrOIIfMwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToyNTo0NFrOIIfMwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MDY5MA==", "bodyText": "nitpick: we usually call this field \"pinned\" in the examples, instead of \"isPinned\".\nGreat that this is being tested!", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545770690", "createdAt": "2020-12-18T11:25:44Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/domain/gizmo/GizmoTestdataEntity.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package org.optaplanner.core.impl.testdata.domain.gizmo;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.entity.PlanningPin;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+import org.optaplanner.core.impl.testdata.domain.TestdataValue;\n+\n+@PlanningEntity\n+public class GizmoTestdataEntity {\n+\n+    private String id;\n+\n+    @PlanningVariable\n+    public TestdataValue value;\n+\n+    @PlanningPin\n+    public boolean isPinned;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDA5MjE2", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555409216", "createdAt": "2020-12-18T11:27:33Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToyNzozNFrOIIfQBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToyNzozNFrOIIfQBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MTUyNg==", "bodyText": "-1 Let's not commit this.\nA great way to avoid these uninteded \"tmp local changes\" is to make a change list in IntelliJ and put that file in that changelist. (I call that change list \"dnc\" which stands for \"Do Not Commit\").", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545771526", "createdAt": "2020-12-18T11:27:34Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/tsp/solver/tspSolverConfig.xml", "diffHunk": "@@ -10,8 +10,8 @@\n   <scoreDirectorFactory>\n     <!--<easyScoreCalculatorClass>org.optaplanner.examples.tsp.optional.score.TspEasyScoreCalculator</easyScoreCalculatorClass>-->\n     <!--<constraintProviderClass>org.optaplanner.examples.tsp.optional.score.TspConstraintProvider</constraintProviderClass>-->\n-    <!--<incrementalScoreCalculatorClass>org.optaplanner.examples.tsp.optional.score.TspIncrementalScoreCalculator</incrementalScoreCalculatorClass>-->\n-    <scoreDrl>org/optaplanner/examples/tsp/solver/tspConstraints.drl</scoreDrl>\n+    <incrementalScoreCalculatorClass>org.optaplanner.examples.tsp.optional.score.TspIncrementalScoreCalculator</incrementalScoreCalculatorClass>\n+    <!-- <scoreDrl>org/optaplanner/examples/tsp/solver/tspConstraints.drl</scoreDrl> -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDEyMDA0", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555412004", "createdAt": "2020-12-18T11:31:45Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTozMTo0NlrOIIfXow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTozMTo0NlrOIIfXow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MzQ3NQ==", "bodyText": "Order: PLANNING_VARIABLE before any the shadow vars types.\nTypical order is something like this: solution related stuff, entity related stuff, genuine planning variable related stuff (IIRC including value range providers), shadow vars related.\nBAsically, when the annotations are parsed by the Descriptors, their order is the order in which they get parsed, mostly.\nMotivation for why order matter: if code always handles a set of aspects in the same order, it is much, much clearer to notice while reading when something is missing, or something is unused. It's also easier to determine in which order they get filled in (important to avoid chicken-and-egg situations if they depend on each other) and sometimes even avoids a deadlock.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545773475", "createdAt": "2020-12-18T11:31:46Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/DotNames.java", "diffHunk": "@@ -27,11 +42,48 @@\n \n     static final DotName PLANNING_SOLUTION = DotName.createSimple(PlanningSolution.class.getName());\n     static final DotName PLANNING_ENTITY = DotName.createSimple(PlanningEntity.class.getName());\n+\n+    static final DotName CONSTRAINT_CONFIGURATION_PROVIDER =\n+            DotName.createSimple(ConstraintConfigurationProvider.class.getName());\n+    static final DotName CONSTRAINT_WEIGHT = DotName.createSimple(ConstraintWeight.class.getName());\n+    static final DotName PLANNING_PIN = DotName.createSimple(PlanningPin.class.getName());\n+    static final DotName PLANNING_ID = DotName.createSimple(PlanningId.class.getName());\n+    static final DotName PLANNING_ENTITY_COLLECTION_PROPERTY =\n+            DotName.createSimple(PlanningEntityCollectionProperty.class.getName());\n+    static final DotName PLANNING_ENTITY_PROPERTY = DotName.createSimple(PlanningEntityProperty.class.getName());\n+    static final DotName PLANNING_SCORE = DotName.createSimple(PlanningScore.class.getName());\n+    static final DotName PROBLEM_FACT_COLLECTION_PROPERTY = DotName.createSimple(ProblemFactCollectionProperty.class.getName());\n+    static final DotName PROBLEM_FACT_PROPERTY = DotName.createSimple(ProblemFactProperty.class.getName());\n+    static final DotName VALUE_RANGE_PROVIDER = DotName.createSimple(ValueRangeProvider.class.getName());\n+    static final DotName ANCHOR_SHADOW_VARIABLE = DotName.createSimple(AnchorShadowVariable.class.getName());\n+    static final DotName CUSTOM_SHADOW_VARIABLE = DotName.createSimple(CustomShadowVariable.class.getName());\n+    static final DotName INVERSE_RELATION_SHADOW_VARIABLE = DotName.createSimple(InverseRelationShadowVariable.class.getName());\n+    static final DotName PLANNING_VARIABLE = DotName.createSimple(PlanningVariable.class.getName());\n+    static final DotName PLANNING_VARIABLE_REFERENCE = DotName.createSimple(PlanningVariableReference.class.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDEzMzYz", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555413363", "createdAt": "2020-12-18T11:34:01Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTozNDowMVrOIIfbpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTozNDowMVrOIIfbpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3NDUwMw==", "bodyText": "In other quarkus extensions, written by the masters (so hibernate, resteasy etc), do they also call this kind of class typically a Creator? (I don't know)", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545774503", "createdAt": "2020-12-18T11:34:01Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/GizmoMemberAccessorCreator.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package org.optaplanner.quarkus.deployment;\n+\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.IRETURN;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Type;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+import org.optaplanner.core.impl.domain.common.accessor.gizmo.GizmoMemberAccessor;\n+\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.DescriptorUtils;\n+import io.quarkus.gizmo.Gizmo;\n+import io.quarkus.gizmo.MethodDescriptor;\n+\n+public class GizmoMemberAccessorCreator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDE0ODEy", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555414812", "createdAt": "2020-12-18T11:36:20Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTozNjoyMFrOIIfgBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTozNjoyMFrOIIfgBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3NTYyMg==", "bodyText": "When chaining an exception, always add a message and then the cause. The message should indicate, at the very least, what action is failing. So here that owuld be something like \"Unable to define assessor for member (\"+ member + \").\", e). That mentioning of the member's value is very handy when this occurs in a production log.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545775622", "createdAt": "2020-12-18T11:36:20Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/GizmoMemberAccessorCreator.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package org.optaplanner.quarkus.deployment;\n+\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.IRETURN;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Type;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+import org.optaplanner.core.impl.domain.common.accessor.gizmo.GizmoMemberAccessor;\n+\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.DescriptorUtils;\n+import io.quarkus.gizmo.Gizmo;\n+import io.quarkus.gizmo.MethodDescriptor;\n+\n+public class GizmoMemberAccessorCreator {\n+\n+    private static Set<FieldInfo> visitedFields = new HashSet<>();\n+    private static Set<MethodInfo> visitedMethods = new HashSet<>();\n+\n+    public static void addVirtualFieldGetter(ClassInfo classInfo, FieldInfo fieldInfo,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedFields.contains(fieldInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerFieldEnhancingClassVisitor(classInfo, classVisitor,\n+                            fieldInfo)));\n+            visitedFields.add(fieldInfo);\n+        }\n+    }\n+\n+    public static Optional<MethodDescriptor> addVirtualMethodGetter(ClassInfo classInfo, MethodInfo methodInfo, String name,\n+            Optional<MethodDescriptor> setterDescriptor,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedMethods.contains(methodInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerMethodEnhancingClassVisitor(classInfo, classVisitor, methodInfo,\n+                            name, setterDescriptor)));\n+            visitedMethods.add(methodInfo);\n+        }\n+        return setterDescriptor.map(md -> MethodDescriptor\n+                .ofMethod(classInfo.name().toString(), getVirtualSetterName(name),\n+                        md.getReturnType(), md.getParameterTypes()));\n+    }\n+\n+    public static String getVirtualGetterName(String name) {\n+        return \"$get$optaplanner$__\" + name;\n+    }\n+\n+    public static String getVirtualSetterName(String name) {\n+        return \"$set$optaplanner$__\" + name;\n+    }\n+\n+    public static void generateFieldAccessor(AnnotationInstance annotationInstance, IndexView indexView,\n+            ClassOutput classOutput, ClassInfo classInfo,\n+            FieldInfo fieldInfo, BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        String generatedClassName = classInfo.name().prefix().toString() + \".$optaplanner$__\"\n+                + classInfo.name().withoutPackagePrefix() + \"$__\" + fieldInfo.name();\n+        ClassCreator classCreator = ClassCreator\n+                .builder()\n+                .className(generatedClassName)\n+                .interfaces(MemberAccessor.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        GizmoMemberAccessor.MemberDescriptor member;\n+        if (Modifier.isPublic(fieldInfo.flags())) {\n+            member = new GizmoMemberAccessor.MemberDescriptor(fieldInfo, indexView);\n+        } else {\n+            addVirtualFieldGetter(classInfo, fieldInfo, transformers);\n+            String methodName = getVirtualGetterName(fieldInfo.name());\n+            MethodDescriptor setterDescriptor = MethodDescriptor.ofMethod(fieldInfo.declaringClass().name().toString(),\n+                    getVirtualSetterName(fieldInfo.name()),\n+                    \"void\",\n+                    fieldInfo.type().name().toString());\n+            MethodInfo methodInfo = MethodInfo.create(classInfo, methodName, new org.jboss.jandex.Type[] {}, fieldInfo.type(),\n+                    (short) Modifier.PUBLIC);\n+            member = new GizmoMemberAccessor.MemberDescriptor(fieldInfo, methodInfo, Optional.of(setterDescriptor), indexView,\n+                    fieldInfo.name());\n+        }\n+        try {\n+            GizmoMemberAccessor.defineAccessorFor(classCreator, member,\n+                    (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString()));\n+            classCreator.close();\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDE3MDk5", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555417099", "createdAt": "2020-12-18T11:40:13Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTo0MDoxNFrOIIfnHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTo0MDoxNFrOIIfnHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3NzQzOA==", "bodyText": "Soft suggestion nitpick: active tense + more concrete by calling out a specific annotation\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Needed so Annotation information in the index\n          \n          \n            \n                    // Add @PlanningEntity and other annotations in the Jandex index for Gizmo", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545777438", "createdAt": "2020-12-18T11:40:14Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -84,14 +101,22 @@ HotDeploymentWatchedFileBuildItem watchConstraintsDrl() {\n         return new HotDeploymentWatchedFileBuildItem(constraintsDrl);\n     }\n \n+    @BuildStep\n+    IndexDependencyBuildItem indexDependencyBuildItem() {\n+        // Needed so Annotation information in the index", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDE3NzY4", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555417768", "createdAt": "2020-12-18T11:41:25Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTo0MToyNVrOIIfpHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTo0MToyNVrOIIfpHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3Nzk0OA==", "bodyText": "important\nNo System.out's or printStackTraces() in committed code", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545777948", "createdAt": "2020-12-18T11:41:25Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -343,4 +386,60 @@ private String convertClassInfosToString(Collection<ClassInfo> classInfos) {\n         }\n     }\n \n+    private OptaPlannerGizmoInfo generateDomainAccessors(IndexView indexView,\n+            BuildProducer<GeneratedClassBuildItem> generatedClasses,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        Collection<AnnotationInstance> membersToGeneratedAccessorsFor = new ArrayList<>();\n+        ClassOutput classOutput = new GeneratedClassGizmoAdaptor(generatedClasses, true);\n+        ClassOutput debuggableClassOutput = (className, bytes) -> {\n+            final String DEBUG_CLASSES_DIR = \"target/optaplanner-generated-classes\";\n+            if (DEBUG_CLASSES_DIR != null) {\n+                Path pathToFile = Paths.get(DEBUG_CLASSES_DIR, className.replace('.', '/') + \".class\");\n+                try {\n+                    Files.createDirectories(pathToFile.getParent());\n+                    Files.write(pathToFile, bytes);\n+                } catch (IOException e) {\n+                    System.out.println(\"Failed writing debug class: \" + pathToFile);\n+                    e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 141}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDE4MjE3", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555418217", "createdAt": "2020-12-18T11:42:08Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTo0MjowOVrOIIfqeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTo0MjowOVrOIIfqeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3ODI5OA==", "bodyText": "error messages: put values between braces, so it's clear what is static text and dynamic text. (important if their planning variable is a field called variable.)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                throw new IllegalStateException(annotatedMember + \" is not on a field or method.\");\n          \n          \n            \n                                throw new IllegalStateException(\"The member (\" + annotatedMember + \") is not on a field or method.\");", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545778298", "createdAt": "2020-12-18T11:42:09Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -343,4 +386,60 @@ private String convertClassInfosToString(Collection<ClassInfo> classInfos) {\n         }\n     }\n \n+    private OptaPlannerGizmoInfo generateDomainAccessors(IndexView indexView,\n+            BuildProducer<GeneratedClassBuildItem> generatedClasses,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        Collection<AnnotationInstance> membersToGeneratedAccessorsFor = new ArrayList<>();\n+        ClassOutput classOutput = new GeneratedClassGizmoAdaptor(generatedClasses, true);\n+        ClassOutput debuggableClassOutput = (className, bytes) -> {\n+            final String DEBUG_CLASSES_DIR = \"target/optaplanner-generated-classes\";\n+            if (DEBUG_CLASSES_DIR != null) {\n+                Path pathToFile = Paths.get(DEBUG_CLASSES_DIR, className.replace('.', '/') + \".class\");\n+                try {\n+                    Files.createDirectories(pathToFile.getParent());\n+                    Files.write(pathToFile, bytes);\n+                } catch (IOException e) {\n+                    System.out.println(\"Failed writing debug class: \" + pathToFile);\n+                    e.printStackTrace();\n+                }\n+            }\n+            classOutput.write(className, bytes);\n+        };\n+\n+        Map<String, java.lang.reflect.Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+        Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+        GizmoMemberAccessor.setGizmoClassLoader(Thread.currentThread().getContextClassLoader(),\n+                gizmoMemberAccessorNameToGenericType,\n+                gizmoMemberAccessorNameToAnnotatedElement);\n+        for (DotName dotName : DotNames.GIZMO_MEMBER_ACCESSOR_ANNOTATIONS) {\n+            membersToGeneratedAccessorsFor.addAll(indexView.getAnnotations(dotName));\n+        }\n+        for (AnnotationInstance annotatedMember : membersToGeneratedAccessorsFor) {\n+            switch (annotatedMember.target().kind()) {\n+                case FIELD: {\n+                    FieldInfo fieldInfo = annotatedMember.target().asField();\n+                    ClassInfo classInfo = fieldInfo.declaringClass();\n+                    GizmoMemberAccessorCreator.generateFieldAccessor(annotatedMember, indexView, debuggableClassOutput,\n+                            classInfo,\n+                            fieldInfo, transformers);\n+                    break;\n+                }\n+                case METHOD: {\n+                    MethodInfo methodInfo = annotatedMember.target().asMethod();\n+                    ClassInfo classInfo = methodInfo.declaringClass();\n+                    GizmoMemberAccessorCreator.generateMethodAccessor(annotatedMember, indexView, debuggableClassOutput,\n+                            classInfo,\n+                            methodInfo, transformers);\n+                    break;\n+                }\n+                default: {\n+                    throw new IllegalStateException(annotatedMember + \" is not on a field or method.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 175}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDE5NDg4", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555419488", "createdAt": "2020-12-18T11:44:17Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTo0NDoxN1rOIIfueg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTo0NDoxN1rOIIfueg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3OTMyMg==", "bodyText": "We typically call such things dummy, so DummyConstraintProvider.\nWe might have one like that around already.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545779322", "createdAt": "2020-12-18T11:44:17Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/test/java/org/optaplanner/quarkus/testdata/gizmo/KitchenSinkConstraintProvider.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package org.optaplanner.quarkus.testdata.gizmo;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+\n+public class KitchenSinkConstraintProvider implements ConstraintProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDIwMjc2", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555420276", "createdAt": "2020-12-18T11:45:38Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTo0NTozOFrOIIfxHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTo0NTozOFrOIIfxHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3OTk5Nw==", "bodyText": "Naming, the other TestData objects start with TestData.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545779997", "createdAt": "2020-12-18T11:45:38Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/test/java/org/optaplanner/quarkus/testdata/gizmo/KitchenSinkTestDataEntity.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.optaplanner.quarkus.testdata.gizmo;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.entity.PlanningPin;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.domain.variable.AnchorShadowVariable;\n+import org.optaplanner.core.api.domain.variable.CustomShadowVariable;\n+import org.optaplanner.core.api.domain.variable.InverseRelationShadowVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+// Should have one of every annotation, even annotations that\n+// don't make sense on an entity, to make sure everything works\n+// a-ok\n+@PlanningEntity\n+public class KitchenSinkTestDataEntity {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NjA4MTgz", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-555608183", "createdAt": "2020-12-18T15:54:23Z", "commit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNTo1NDoyM1rOIIootw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNTo1NDoyM1rOIIootw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyNTMwMw==", "bodyText": "Do we have an integration-chapter.adoc entry?", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545925303", "createdAt": "2020-12-18T15:54:23Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-spring-integration/optaplanner-spring-boot-autoconfigure/src/main/java/org/optaplanner/spring/boot/autoconfigure/SolverProperties.java", "diffHunk": "@@ -26,6 +27,15 @@\n      * Defaults to \"REPRODUCIBLE\".\n      */\n     private EnvironmentMode environmentMode;\n+\n+    /**\n+     * Determines how Domain Accessors are created. Defaults\n+     * to \"REFLECTION\". To use \"GIZMO\", io.quarkus.gizmo:gizmo\n+     * MUST be in your classpath, and all OptaPlanner annotations\n+     * must be on public members.\n+     */\n+    private DomainAccessType domainAccessType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 19}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/c573c771e287b1037058b488a0bb9a5d8ab94944", "committedDate": "2020-12-16T19:23:30Z", "message": "Rebase fixup"}, "afterCommit": {"oid": "3a0f8e164b37aaa113730699b808e0c8880aa008", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/3a0f8e164b37aaa113730699b808e0c8880aa008", "committedDate": "2020-12-18T21:15:11Z", "message": "Rebase fixup"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4dce320f9cba9f4ab56e8a474ed0e256311aaf6c", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/4dce320f9cba9f4ab56e8a474ed0e256311aaf6c", "committedDate": "2020-12-18T21:55:13Z", "message": "Put DomainAccessType in DescriptorPolicy\n\n- Also use correct Gizmo + Jandex versions"}, "afterCommit": {"oid": "e2f25955a542798ad5d37431c08229eec85d7b06", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/e2f25955a542798ad5d37431c08229eec85d7b06", "committedDate": "2021-01-04T16:55:22Z", "message": "Put DomainAccessType in DescriptorPolicy\n\n- Also use correct Gizmo + Jandex versions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMDAzNTY5", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-561003569", "createdAt": "2021-01-04T12:47:26Z", "commit": {"oid": "4dce320f9cba9f4ab56e8a474ed0e256311aaf6c"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxMjo0NzoyNlrOINwg5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoxMDowNVrOIN5xoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI5NzI1NA==", "bodyText": "+1 to A. If you move the property, please don't forget to move also its mention in the @XmlType annotation over the class.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551297254", "createdAt": "2021-01-04T12:47:26Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/SolverConfig.java", "diffHunk": "@@ -235,6 +236,8 @@ public static SolverConfig createFromXmlReader(Reader reader, ClassLoader classL\n     protected Class<? extends ThreadFactory> threadFactoryClass = null;\n \n     protected Class<?> solutionClass = null;\n+\n+    protected DomainAccessType domainAccessType = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc1ODE0Mg=="}, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI5ODczOA==", "bodyText": "If the comment stays, I suggest turning it into a multi-line comment and finish the sentence with '.'", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551298738", "createdAt": "2021-01-04T12:50:38Z", "author": {"login": "rsynek"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/test/java/org/optaplanner/quarkus/testdata/gizmo/KitchenSinkTestDataEntity.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.optaplanner.quarkus.testdata.gizmo;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.entity.PlanningPin;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.domain.variable.AnchorShadowVariable;\n+import org.optaplanner.core.api.domain.variable.CustomShadowVariable;\n+import org.optaplanner.core.api.domain.variable.InverseRelationShadowVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+// Should have one of every annotation, even annotations that\n+// don't make sense on an entity, to make sure everything works\n+// a-ok", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dce320f9cba9f4ab56e8a474ed0e256311aaf6c"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM3Njc0NA==", "bodyText": "Why do we define the (empty) maps here, to only have them filled later by the GizmoMemberAccessorCreator.generateFieldAccessor and GizmoMemberAccessorCreator.generateMethodAccessor ?", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551376744", "createdAt": "2021-01-04T15:14:41Z", "author": {"login": "rsynek"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -343,4 +386,60 @@ private String convertClassInfosToString(Collection<ClassInfo> classInfos) {\n         }\n     }\n \n+    private OptaPlannerGizmoInfo generateDomainAccessors(IndexView indexView,\n+            BuildProducer<GeneratedClassBuildItem> generatedClasses,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        Collection<AnnotationInstance> membersToGeneratedAccessorsFor = new ArrayList<>();\n+        ClassOutput classOutput = new GeneratedClassGizmoAdaptor(generatedClasses, true);\n+        ClassOutput debuggableClassOutput = (className, bytes) -> {\n+            final String DEBUG_CLASSES_DIR = \"target/optaplanner-generated-classes\";\n+            if (DEBUG_CLASSES_DIR != null) {\n+                Path pathToFile = Paths.get(DEBUG_CLASSES_DIR, className.replace('.', '/') + \".class\");\n+                try {\n+                    Files.createDirectories(pathToFile.getParent());\n+                    Files.write(pathToFile, bytes);\n+                } catch (IOException e) {\n+                    System.out.println(\"Failed writing debug class: \" + pathToFile);\n+                    e.printStackTrace();\n+                }\n+            }\n+            classOutput.write(className, bytes);\n+        };\n+\n+        Map<String, java.lang.reflect.Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+        Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dce320f9cba9f4ab56e8a474ed0e256311aaf6c"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM3NzI5NA==", "bodyText": "Formatting - unnecessary line.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551377294", "createdAt": "2021-01-04T15:15:33Z", "author": {"login": "rsynek"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -343,4 +386,60 @@ private String convertClassInfosToString(Collection<ClassInfo> classInfos) {\n         }\n     }\n \n+    private OptaPlannerGizmoInfo generateDomainAccessors(IndexView indexView,\n+            BuildProducer<GeneratedClassBuildItem> generatedClasses,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        Collection<AnnotationInstance> membersToGeneratedAccessorsFor = new ArrayList<>();\n+        ClassOutput classOutput = new GeneratedClassGizmoAdaptor(generatedClasses, true);\n+        ClassOutput debuggableClassOutput = (className, bytes) -> {\n+            final String DEBUG_CLASSES_DIR = \"target/optaplanner-generated-classes\";\n+            if (DEBUG_CLASSES_DIR != null) {\n+                Path pathToFile = Paths.get(DEBUG_CLASSES_DIR, className.replace('.', '/') + \".class\");\n+                try {\n+                    Files.createDirectories(pathToFile.getParent());\n+                    Files.write(pathToFile, bytes);\n+                } catch (IOException e) {\n+                    System.out.println(\"Failed writing debug class: \" + pathToFile);\n+                    e.printStackTrace();\n+                }\n+            }\n+            classOutput.write(className, bytes);\n+        };\n+\n+        Map<String, java.lang.reflect.Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+        Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+        GizmoMemberAccessor.setGizmoClassLoader(Thread.currentThread().getContextClassLoader(),\n+                gizmoMemberAccessorNameToGenericType,\n+                gizmoMemberAccessorNameToAnnotatedElement);\n+        for (DotName dotName : DotNames.GIZMO_MEMBER_ACCESSOR_ANNOTATIONS) {\n+            membersToGeneratedAccessorsFor.addAll(indexView.getAnnotations(dotName));\n+        }\n+        for (AnnotationInstance annotatedMember : membersToGeneratedAccessorsFor) {\n+            switch (annotatedMember.target().kind()) {\n+                case FIELD: {\n+                    FieldInfo fieldInfo = annotatedMember.target().asField();\n+                    ClassInfo classInfo = fieldInfo.declaringClass();\n+                    GizmoMemberAccessorCreator.generateFieldAccessor(annotatedMember, indexView, debuggableClassOutput,\n+                            classInfo,\n+                            fieldInfo, transformers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dce320f9cba9f4ab56e8a474ed0e256311aaf6c"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM3NzM3MQ==", "bodyText": "Formatting - unnecessary line.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551377371", "createdAt": "2021-01-04T15:15:40Z", "author": {"login": "rsynek"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -343,4 +386,60 @@ private String convertClassInfosToString(Collection<ClassInfo> classInfos) {\n         }\n     }\n \n+    private OptaPlannerGizmoInfo generateDomainAccessors(IndexView indexView,\n+            BuildProducer<GeneratedClassBuildItem> generatedClasses,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        Collection<AnnotationInstance> membersToGeneratedAccessorsFor = new ArrayList<>();\n+        ClassOutput classOutput = new GeneratedClassGizmoAdaptor(generatedClasses, true);\n+        ClassOutput debuggableClassOutput = (className, bytes) -> {\n+            final String DEBUG_CLASSES_DIR = \"target/optaplanner-generated-classes\";\n+            if (DEBUG_CLASSES_DIR != null) {\n+                Path pathToFile = Paths.get(DEBUG_CLASSES_DIR, className.replace('.', '/') + \".class\");\n+                try {\n+                    Files.createDirectories(pathToFile.getParent());\n+                    Files.write(pathToFile, bytes);\n+                } catch (IOException e) {\n+                    System.out.println(\"Failed writing debug class: \" + pathToFile);\n+                    e.printStackTrace();\n+                }\n+            }\n+            classOutput.write(className, bytes);\n+        };\n+\n+        Map<String, java.lang.reflect.Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+        Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+        GizmoMemberAccessor.setGizmoClassLoader(Thread.currentThread().getContextClassLoader(),\n+                gizmoMemberAccessorNameToGenericType,\n+                gizmoMemberAccessorNameToAnnotatedElement);\n+        for (DotName dotName : DotNames.GIZMO_MEMBER_ACCESSOR_ANNOTATIONS) {\n+            membersToGeneratedAccessorsFor.addAll(indexView.getAnnotations(dotName));\n+        }\n+        for (AnnotationInstance annotatedMember : membersToGeneratedAccessorsFor) {\n+            switch (annotatedMember.target().kind()) {\n+                case FIELD: {\n+                    FieldInfo fieldInfo = annotatedMember.target().asField();\n+                    ClassInfo classInfo = fieldInfo.declaringClass();\n+                    GizmoMemberAccessorCreator.generateFieldAccessor(annotatedMember, indexView, debuggableClassOutput,\n+                            classInfo,\n+                            fieldInfo, transformers);\n+                    break;\n+                }\n+                case METHOD: {\n+                    MethodInfo methodInfo = annotatedMember.target().asMethod();\n+                    ClassInfo classInfo = methodInfo.declaringClass();\n+                    GizmoMemberAccessorCreator.generateMethodAccessor(annotatedMember, indexView, debuggableClassOutput,\n+                            classInfo,\n+                            methodInfo, transformers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dce320f9cba9f4ab56e8a474ed0e256311aaf6c"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM3ODAwNw==", "bodyText": "In my opinion too much detail for this method, which is growing bigger and bigger.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551378007", "createdAt": "2021-01-04T15:16:39Z", "author": {"login": "rsynek"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -131,6 +156,14 @@ void recordAndRegisterBeans(OptaPlannerRecorder recorder, RecorderContext record\n                                     || dotName.toString().startsWith(\"org.optaplanner\"))\n                     .build());\n         }\n+\n+        OptaPlannerGizmoInfo gizmoInfo;\n+        if (solverConfig.getDomainAccessType() == DomainAccessType.GIZMO) {\n+            gizmoInfo = generateDomainAccessors(indexView, generatedClasses, transformers);\n+        } else {\n+            gizmoInfo = new OptaPlannerGizmoInfo(Collections.emptyMap(), Collections.emptyMap());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dce320f9cba9f4ab56e8a474ed0e256311aaf6c"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQzNjIxNA==", "bodyText": "I noticed that often call the classes generating byte code via Gizmo \"Implementor\", e.g. https://github.com/quarkusio/quarkus/blob/master/extensions/panache/rest-data-panache/deployment/src/main/java/io/quarkus/rest/data/panache/deployment/JaxRsResourceImplementor.java", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551436214", "createdAt": "2021-01-04T16:48:45Z", "author": {"login": "rsynek"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/GizmoMemberAccessorCreator.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package org.optaplanner.quarkus.deployment;\n+\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.IRETURN;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Type;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+import org.optaplanner.core.impl.domain.common.accessor.gizmo.GizmoMemberAccessor;\n+\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.DescriptorUtils;\n+import io.quarkus.gizmo.Gizmo;\n+import io.quarkus.gizmo.MethodDescriptor;\n+\n+public class GizmoMemberAccessorCreator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3NDUwMw=="}, "originalCommit": {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0MzY1OQ==", "bodyText": "This line repeats for the boolean getter too. Maybe a method that just figures out the setter's name would do it (and make the code more testable).", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551443659", "createdAt": "2021-01-04T17:00:55Z", "author": {"login": "rsynek"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/GizmoMemberAccessorCreator.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package org.optaplanner.quarkus.deployment;\n+\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.IRETURN;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Type;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+import org.optaplanner.core.impl.domain.common.accessor.gizmo.GizmoMemberAccessor;\n+\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.DescriptorUtils;\n+import io.quarkus.gizmo.Gizmo;\n+import io.quarkus.gizmo.MethodDescriptor;\n+\n+public class GizmoMemberAccessorCreator {\n+\n+    private static Set<FieldInfo> visitedFields = new HashSet<>();\n+    private static Set<MethodInfo> visitedMethods = new HashSet<>();\n+\n+    public static void addVirtualFieldGetter(ClassInfo classInfo, FieldInfo fieldInfo,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedFields.contains(fieldInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerFieldEnhancingClassVisitor(classInfo, classVisitor,\n+                            fieldInfo)));\n+            visitedFields.add(fieldInfo);\n+        }\n+    }\n+\n+    public static Optional<MethodDescriptor> addVirtualMethodGetter(ClassInfo classInfo, MethodInfo methodInfo, String name,\n+            Optional<MethodDescriptor> setterDescriptor,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedMethods.contains(methodInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerMethodEnhancingClassVisitor(classInfo, classVisitor, methodInfo,\n+                            name, setterDescriptor)));\n+            visitedMethods.add(methodInfo);\n+        }\n+        return setterDescriptor.map(md -> MethodDescriptor\n+                .ofMethod(classInfo.name().toString(), getVirtualSetterName(name),\n+                        md.getReturnType(), md.getParameterTypes()));\n+    }\n+\n+    public static String getVirtualGetterName(String name) {\n+        return \"$get$optaplanner$__\" + name;\n+    }\n+\n+    public static String getVirtualSetterName(String name) {\n+        return \"$set$optaplanner$__\" + name;\n+    }\n+\n+    public static void generateFieldAccessor(AnnotationInstance annotationInstance, IndexView indexView,\n+            ClassOutput classOutput, ClassInfo classInfo,\n+            FieldInfo fieldInfo, BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        String generatedClassName = classInfo.name().prefix().toString() + \".$optaplanner$__\"\n+                + classInfo.name().withoutPackagePrefix() + \"$__\" + fieldInfo.name();\n+        ClassCreator classCreator = ClassCreator\n+                .builder()\n+                .className(generatedClassName)\n+                .interfaces(MemberAccessor.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        GizmoMemberAccessor.MemberDescriptor member;\n+        if (Modifier.isPublic(fieldInfo.flags())) {\n+            member = new GizmoMemberAccessor.MemberDescriptor(fieldInfo, indexView);\n+        } else {\n+            addVirtualFieldGetter(classInfo, fieldInfo, transformers);\n+            String methodName = getVirtualGetterName(fieldInfo.name());\n+            MethodDescriptor setterDescriptor = MethodDescriptor.ofMethod(fieldInfo.declaringClass().name().toString(),\n+                    getVirtualSetterName(fieldInfo.name()),\n+                    \"void\",\n+                    fieldInfo.type().name().toString());\n+            MethodInfo methodInfo = MethodInfo.create(classInfo, methodName, new org.jboss.jandex.Type[] {}, fieldInfo.type(),\n+                    (short) Modifier.PUBLIC);\n+            member = new GizmoMemberAccessor.MemberDescriptor(fieldInfo, methodInfo, Optional.of(setterDescriptor), indexView,\n+                    fieldInfo.name());\n+        }\n+        try {\n+            GizmoMemberAccessor.defineAccessorFor(classCreator, member,\n+                    (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString()));\n+            classCreator.close();\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    public static void generateMethodAccessor(AnnotationInstance annotationInstance, IndexView indexView,\n+            ClassOutput classOutput, ClassInfo classInfo,\n+            MethodInfo methodInfo, BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        String generatedClassName = classInfo.name().prefix().toString() + \".$optaplanner$__\"\n+                + classInfo.name().withoutPackagePrefix() + \"$__\" + methodInfo.name();\n+        ClassCreator classCreator = ClassCreator\n+                .builder()\n+                .className(generatedClassName)\n+                .interfaces(MemberAccessor.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        GizmoMemberAccessor.MemberDescriptor member;\n+        String name;\n+        MethodInfo setterMethod;\n+\n+        if (methodInfo.name().startsWith(\"get\")) {\n+            name = methodInfo.name().substring(3, 4).toLowerCase(Locale.ROOT) + methodInfo.name().substring(4);\n+            setterMethod = classInfo.method(\"set\" + name.substring(0, 1).toUpperCase(Locale.ROOT) + name.substring(1),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dce320f9cba9f4ab56e8a474ed0e256311aaf6c"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0ODk5Mw==", "bodyText": "Why is it necessary to use directly ASM?", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551448993", "createdAt": "2021-01-04T17:10:05Z", "author": {"login": "rsynek"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/GizmoMemberAccessorCreator.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package org.optaplanner.quarkus.deployment;\n+\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.IRETURN;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Type;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+import org.optaplanner.core.impl.domain.common.accessor.gizmo.GizmoMemberAccessor;\n+\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.DescriptorUtils;\n+import io.quarkus.gizmo.Gizmo;\n+import io.quarkus.gizmo.MethodDescriptor;\n+\n+public class GizmoMemberAccessorCreator {\n+\n+    private static Set<FieldInfo> visitedFields = new HashSet<>();\n+    private static Set<MethodInfo> visitedMethods = new HashSet<>();\n+\n+    public static void addVirtualFieldGetter(ClassInfo classInfo, FieldInfo fieldInfo,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedFields.contains(fieldInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerFieldEnhancingClassVisitor(classInfo, classVisitor,\n+                            fieldInfo)));\n+            visitedFields.add(fieldInfo);\n+        }\n+    }\n+\n+    public static Optional<MethodDescriptor> addVirtualMethodGetter(ClassInfo classInfo, MethodInfo methodInfo, String name,\n+            Optional<MethodDescriptor> setterDescriptor,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedMethods.contains(methodInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerMethodEnhancingClassVisitor(classInfo, classVisitor, methodInfo,\n+                            name, setterDescriptor)));\n+            visitedMethods.add(methodInfo);\n+        }\n+        return setterDescriptor.map(md -> MethodDescriptor\n+                .ofMethod(classInfo.name().toString(), getVirtualSetterName(name),\n+                        md.getReturnType(), md.getParameterTypes()));\n+    }\n+\n+    public static String getVirtualGetterName(String name) {\n+        return \"$get$optaplanner$__\" + name;\n+    }\n+\n+    public static String getVirtualSetterName(String name) {\n+        return \"$set$optaplanner$__\" + name;\n+    }\n+\n+    public static void generateFieldAccessor(AnnotationInstance annotationInstance, IndexView indexView,\n+            ClassOutput classOutput, ClassInfo classInfo,\n+            FieldInfo fieldInfo, BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        String generatedClassName = classInfo.name().prefix().toString() + \".$optaplanner$__\"\n+                + classInfo.name().withoutPackagePrefix() + \"$__\" + fieldInfo.name();\n+        ClassCreator classCreator = ClassCreator\n+                .builder()\n+                .className(generatedClassName)\n+                .interfaces(MemberAccessor.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        GizmoMemberAccessor.MemberDescriptor member;\n+        if (Modifier.isPublic(fieldInfo.flags())) {\n+            member = new GizmoMemberAccessor.MemberDescriptor(fieldInfo, indexView);\n+        } else {\n+            addVirtualFieldGetter(classInfo, fieldInfo, transformers);\n+            String methodName = getVirtualGetterName(fieldInfo.name());\n+            MethodDescriptor setterDescriptor = MethodDescriptor.ofMethod(fieldInfo.declaringClass().name().toString(),\n+                    getVirtualSetterName(fieldInfo.name()),\n+                    \"void\",\n+                    fieldInfo.type().name().toString());\n+            MethodInfo methodInfo = MethodInfo.create(classInfo, methodName, new org.jboss.jandex.Type[] {}, fieldInfo.type(),\n+                    (short) Modifier.PUBLIC);\n+            member = new GizmoMemberAccessor.MemberDescriptor(fieldInfo, methodInfo, Optional.of(setterDescriptor), indexView,\n+                    fieldInfo.name());\n+        }\n+        try {\n+            GizmoMemberAccessor.defineAccessorFor(classCreator, member,\n+                    (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString()));\n+            classCreator.close();\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    public static void generateMethodAccessor(AnnotationInstance annotationInstance, IndexView indexView,\n+            ClassOutput classOutput, ClassInfo classInfo,\n+            MethodInfo methodInfo, BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        String generatedClassName = classInfo.name().prefix().toString() + \".$optaplanner$__\"\n+                + classInfo.name().withoutPackagePrefix() + \"$__\" + methodInfo.name();\n+        ClassCreator classCreator = ClassCreator\n+                .builder()\n+                .className(generatedClassName)\n+                .interfaces(MemberAccessor.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        GizmoMemberAccessor.MemberDescriptor member;\n+        String name;\n+        MethodInfo setterMethod;\n+\n+        if (methodInfo.name().startsWith(\"get\")) {\n+            name = methodInfo.name().substring(3, 4).toLowerCase(Locale.ROOT) + methodInfo.name().substring(4);\n+            setterMethod = classInfo.method(\"set\" + name.substring(0, 1).toUpperCase(Locale.ROOT) + name.substring(1),\n+                    methodInfo.returnType());\n+        } else if (methodInfo.name().startsWith(\"is\")) {\n+            name = methodInfo.name().substring(2, 3).toLowerCase(Locale.ROOT) + methodInfo.name().substring(3);\n+            setterMethod = classInfo.method(\"set\" + name.substring(0, 1).toUpperCase(Locale.ROOT) + name.substring(1),\n+                    methodInfo.returnType());\n+        } else {\n+            name = methodInfo.name();\n+            setterMethod = null;\n+        }\n+\n+        Optional<MethodDescriptor> setterDescriptor = Optional.ofNullable(setterMethod).map(MethodDescriptor::of);\n+        if (Modifier.isPublic(methodInfo.flags())) {\n+            member = new GizmoMemberAccessor.MemberDescriptor(methodInfo, methodInfo, setterDescriptor, indexView, name);\n+        } else {\n+            setterDescriptor = addVirtualMethodGetter(classInfo, methodInfo, name, setterDescriptor, transformers);\n+            String methodName = getVirtualGetterName(name);\n+            MethodInfo newMethodInfo = classInfo.method(methodName);\n+            member = new GizmoMemberAccessor.MemberDescriptor(methodInfo, newMethodInfo, setterDescriptor, indexView, name);\n+        }\n+        try {\n+            GizmoMemberAccessor.defineAccessorFor(classCreator, member,\n+                    (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString()));\n+            classCreator.close();\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    private static class OptaPlannerFieldEnhancingClassVisitor extends ClassVisitor {\n+        private final FieldInfo fieldInfo;\n+        private final Class<?> clazz;\n+        private final String fieldTypeDescriptor;\n+\n+        public OptaPlannerFieldEnhancingClassVisitor(ClassInfo classInfo, ClassVisitor outputClassVisitor,\n+                FieldInfo fieldInfo) {\n+            super(Gizmo.ASM_API_VERSION, outputClassVisitor);\n+            this.fieldInfo = fieldInfo;\n+            try {\n+                clazz = Class.forName(classInfo.name().toString(), false, Thread.currentThread().getContextClassLoader());\n+                fieldTypeDescriptor = DescriptorUtils.typeToString(fieldInfo.type());\n+            } catch (ClassNotFoundException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+\n+        @Override\n+        public void visitEnd() {\n+            super.visitEnd();\n+            addGetter(this.cv);\n+            addSetter(this.cv);\n+        }\n+\n+        private void addSetter(ClassVisitor classWriter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2f25955a542798ad5d37431c08229eec85d7b06"}, "originalPosition": 182}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxODUxMDUw", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-561851050", "createdAt": "2021-01-05T14:50:29Z", "commit": {"oid": "e2f25955a542798ad5d37431c08229eec85d7b06"}, "state": "COMMENTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNDo1MDoyOVrOIOaIjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxMTo1NTozNVrOIO73HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk3OTE1MQ==", "bodyText": "The <optional>true</optional> is necessary for the dependencies, but not he dependencyManagement.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551979151", "createdAt": "2021-01-05T14:50:29Z", "author": {"login": "rsynek"}, "path": "build/optaplanner-build-parent/pom.xml", "diffHunk": "@@ -159,6 +161,18 @@\n <!--          </exclusion>-->\n         </exclusions>\n       </dependency>\n+      <dependency>\n+        <groupId>io.quarkus.gizmo</groupId>\n+        <artifactId>gizmo</artifactId>\n+        <version>${version.io.quarkus.gizmo}</version>\n+        <optional>true</optional>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2f25955a542798ad5d37431c08229eec85d7b06"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4NDA1MA==", "bodyText": "Please provide a message for this exception (and there are two more below).", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551984050", "createdAt": "2021-01-05T14:58:02Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoTypeWrappers.java", "diffHunk": "@@ -0,0 +1,387 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.AnnotatedType;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.GenericDeclaration;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.jandex.PrimitiveType;\n+\n+/**\n+ * Contains wrappers for types so they may be\n+ * recorded in bytecode.\n+ */\n+public class GizmoTypeWrappers {\n+\n+    public static Type getTypeForJandex(IndexView indexView, org.jboss.jandex.Type jandexType) {\n+        if (jandexType == null) {\n+            return null;\n+        }\n+\n+        switch (jandexType.kind()) {\n+            case CLASS:\n+                try {\n+                    return Class.forName(jandexType.asClassType().name().toString(), false,\n+                            Thread.currentThread().getContextClassLoader());\n+                } catch (ClassNotFoundException e) {\n+                    throw new IllegalStateException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2f25955a542798ad5d37431c08229eec85d7b06"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAzMTQyMw==", "bodyText": "The setter is not just setting the classloader, but also the maps - the method should do what it says it does.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552031423", "createdAt": "2021-01-05T16:09:48Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessor.java", "diffHunk": "@@ -0,0 +1,637 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+public class GizmoMemberAccessor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (classNameToBytecode.containsKey(name)) {\n+                // Gizmo generated class\n+                byte[] byteCode = classNameToBytecode.get(name);\n+                return defineClass(name, byteCode, 0, byteCode.length);\n+            } else {\n+                // Not a Gizmo generated class; load from context class loader\n+                return Thread.currentThread().getContextClassLoader().loadClass(name);\n+            }\n+        }\n+    };\n+\n+    private static boolean useClassLoader = false;\n+\n+    /**\n+     * Call this method if you generated the bytecode\n+     * during the build process (ex: Quarkus)\n+     *\n+     * @param classLoader The classloader that contains the generated\n+     *        gizmo classes.\n+     *\n+     * @param newGizmoMemberAccessorNameToGenericType The map from\n+     *        member accessor class name\n+     *        to its generic type\n+     * @param newGizmoMemberAccessorNameToAnnotatedElement The map from\n+     *        member accessor class name\n+     *        to its annotated Element.\n+     */\n+    public static void setGizmoClassLoader(ClassLoader classLoader, Map<String, Type> newGizmoMemberAccessorNameToGenericType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2f25955a542798ad5d37431c08229eec85d7b06"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNzMzNw==", "bodyText": "A suggestion in order not to repeat the map in every annotation wrapper: declare an abstract super class.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552437337", "createdAt": "2021-01-06T08:38:00Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoAnnotationWrappers.java", "diffHunk": "@@ -0,0 +1,740 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.IndexView;\n+import org.optaplanner.core.api.domain.autodiscover.AutoDiscoverMemberType;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfiguration;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfigurationProvider;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintWeight;\n+import org.optaplanner.core.api.domain.entity.PinningFilter;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.entity.PlanningPin;\n+import org.optaplanner.core.api.domain.lookup.LookUpStrategyType;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.ProblemFactProperty;\n+import org.optaplanner.core.api.domain.solution.cloner.SolutionCloner;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.domain.variable.AnchorShadowVariable;\n+import org.optaplanner.core.api.domain.variable.CustomShadowVariable;\n+import org.optaplanner.core.api.domain.variable.InverseRelationShadowVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableGraphType;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableReference;\n+import org.optaplanner.core.api.domain.variable.VariableListener;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionSorterWeightFactory;\n+import org.optaplanner.core.impl.score.definition.ScoreDefinition;\n+\n+/**\n+ * Contains wrappers for Annotations so they may be\n+ * recorded in bytecode. The annotation's values are stored\n+ * in the wrapper's map.\n+ *\n+ * When bytecode is being recorded in Quarkus (i.e. an\n+ * object is passed to a recorder), the following restrictions apply:\n+ *\n+ * - Classes without public getters/setters for all fields,\n+ * a constructor annotated with @RecordableConstructor with parameter names that match field names or a\n+ * registered substitution cannot be recorded. (https://quarkus.io/guides/writing-extensions#bytecode-recording)\n+ *\n+ * Annotations and Generic Types do not satisfy the above criteria, so they cannot be\n+ * recorded directly at build time. However, we don't want to use reflection at runtime,\n+ * and we want to build the GizmoMemberAccessors at build time. So we need to create\n+ * wrappers for the annotations and types so they can be recorded.\n+ */\n+public class GizmoAnnotationWrappers {\n+\n+    enum AllOptaPlannerAnnotationEnum {\n+        CONSTRAINT_CONFIGURATION(ConstraintConfiguration.class,\n+                ConstraintConfigurationWrapper::new),\n+        CONSTRAINT_CONFIGURATION_PROVIDER(ConstraintConfigurationProvider.class,\n+                ConstraintConfigurationProviderWrapper::new),\n+        CONSTRAINT_WEIGHT(ConstraintWeight.class, ConstraintWeightWrapper::new),\n+        PLANNING_ENTITY(PlanningEntity.class, PlanningEntityWrapper::new),\n+        PLANNING_PIN(PlanningPin.class, PlanningPinWrapper::new),\n+        PLANNING_ID(PlanningId.class, PlanningIdWrapper::new),\n+        PLANNING_ENTITY_COLLECTION_PROPERTY(PlanningEntityCollectionProperty.class,\n+                PlanningEntityCollectionPropertyWrapper::new),\n+        PLANNING_ENTITY_PROPERTY(PlanningEntityProperty.class,\n+                PlanningEntityPropertyWrapper::new),\n+        PLANNING_SCORE(PlanningScore.class, PlanningScoreWrapper::new),\n+        PLANNING_SOLUTION(PlanningSolution.class, PlanningSolutionWrapper::new),\n+        PROBLEM_FACT_COLLECTION_PROPERTY(ProblemFactCollectionProperty.class,\n+                ProblemFactCollectionPropertyWrapper::new),\n+        PROBLEM_FACT_PROPERTY(ProblemFactProperty.class, ProblemFactPropertyWrapper::new),\n+        VALUE_RANGE_PROVIDER(ValueRangeProvider.class, ValueRangeProviderWrapper::new),\n+        ANCHOR_SHADOW_VARIABLE(AnchorShadowVariable.class, AnchorShadowVariableWrapper::new),\n+        CUSTOM_SHADOW_VARIABLE(CustomShadowVariable.class, CustomShadowVariableWrapper::new),\n+        INVERSE_RELATION_SHADOW_VARIABLE(InverseRelationShadowVariable.class,\n+                InverseRelationShadowVariableWrapper::new),\n+        PLANNING_VARIABLE(PlanningVariable.class, PlanningVariableWrapper::new),\n+        PLANNING_VARIABLE_REFERENCE(PlanningVariableReference.class, PlanningVariableReferenceWrapper::new);\n+\n+        Class<?> annotationClass;\n+        Function<Map<String, Object>, Annotation> mapper;\n+\n+        <T extends Annotation> AllOptaPlannerAnnotationEnum(Class<? extends T> annotationClass,\n+                Function<Map<String, Object>, T> mapper) {\n+            this.annotationClass = annotationClass;\n+            this.mapper = (Function<Map<String, Object>, Annotation>) mapper;\n+        }\n+\n+        public Annotation get(Map<String, Object> values) {\n+            return mapper.apply(values);\n+        }\n+\n+        public static Annotation getForClass(Class<? extends Annotation> annotationClass, Map<String, Object> values) {\n+            for (AllOptaPlannerAnnotationEnum annotationType : AllOptaPlannerAnnotationEnum.values()) {\n+                if (annotationClass.equals(annotationType.annotationClass)) {\n+                    return annotationType.get(values);\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Missing case for \" + annotationClass);\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(Class<? extends Annotation> annotationClass) {\n+            return isOptaPlannerAnnotation(annotationClass.getName());\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(String annotationClass) {\n+            return annotationClass.startsWith(\"org.optaplanner.\");\n+        }\n+    }\n+\n+    public static class AnnotationWrapper implements Supplier<Annotation> {\n+        Class<? extends Annotation> annotationType;\n+        Map<String, Object> annotationValues = new HashMap<String, Object>();\n+        Annotation annotation;\n+\n+        public AnnotationWrapper() {\n+        }\n+\n+        public AnnotationWrapper(Annotation annotation) {\n+            this.annotation = annotation;\n+        }\n+\n+        public AnnotationWrapper(AnnotationInstance annotationInstance, IndexView indexView) {\n+            try {\n+                annotationType = (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString());\n+            } catch (ClassNotFoundException e) {\n+                throw new IllegalStateException(e);\n+            }\n+            annotationValues = new HashMap<>();\n+            if (AllOptaPlannerAnnotationEnum.isOptaPlannerAnnotation(annotationType)) {\n+                // Annotation is an OptaPlanner annotation (i.e.\n+                // is a subpackage of org.optaplanner)\n+                annotationInstance.valuesWithDefaults(indexView).forEach((value) -> {\n+                    switch (value.kind()) {\n+                        case BYTE:\n+                            annotationValues.put(value.name(),\n+                                    value.asByte());\n+                            break;\n+                        case SHORT:\n+                            annotationValues.put(value.name(),\n+                                    value.asShort());\n+                            break;\n+                        case INTEGER:\n+                            annotationValues.put(value.name(),\n+                                    value.asInt());\n+                            break;\n+                        case CHARACTER:\n+                            annotationValues.put(value.name(),\n+                                    value.asChar());\n+                            break;\n+                        case FLOAT:\n+                            annotationValues.put(value.name(),\n+                                    value.asFloat());\n+                            break;\n+                        case DOUBLE:\n+                            annotationValues.put(value.name(),\n+                                    value.asDouble());\n+                            break;\n+                        case LONG:\n+                            annotationValues.put(value.name(),\n+                                    value.asLong());\n+                            break;\n+                        case BOOLEAN:\n+                            annotationValues.put(value.name(),\n+                                    value.asBoolean());\n+                            break;\n+                        case CLASS:\n+                            try {\n+                                annotationValues.put(value.name(),\n+                                        Class.forName(value.asClass().toString()));\n+                            } catch (ClassNotFoundException e) {\n+                                throw new IllegalStateException(e);\n+                            }\n+                            break;\n+                        case STRING:\n+                            annotationValues.put(value.name(),\n+                                    value.asString());\n+                            break;\n+                        case ENUM:\n+                            annotationValues.put(value.name(),\n+                                    value.asEnum());\n+                            break;\n+                        case ARRAY:\n+                            switch (value.componentKind()) {\n+                                case BYTE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asByteArray());\n+                                    break;\n+                                case SHORT:\n+                                    annotationValues.put(value.name(),\n+                                            value.asShortArray());\n+                                    break;\n+                                case INTEGER:\n+                                    annotationValues.put(value.name(),\n+                                            value.asIntArray());\n+                                    break;\n+                                case CHARACTER:\n+                                    annotationValues.put(value.name(),\n+                                            value.asCharArray());\n+                                    break;\n+                                case FLOAT:\n+                                    annotationValues.put(value.name(),\n+                                            value.asFloatArray());\n+                                    break;\n+                                case DOUBLE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asDoubleArray());\n+                                    break;\n+                                case LONG:\n+                                    annotationValues.put(value.name(),\n+                                            value.asLongArray());\n+                                    break;\n+                                case BOOLEAN:\n+                                    annotationValues.put(value.name(),\n+                                            value.asBooleanArray());\n+                                    break;\n+                                case CLASS: {\n+                                    Class[] valueArr = Arrays.stream(value.asClassArray())\n+                                            .map(v -> {\n+                                                try {\n+                                                    return Class.forName(v.toString());\n+                                                } catch (ClassNotFoundException e) {\n+                                                    throw new IllegalStateException(e);\n+                                                }\n+                                            })\n+                                            .collect(Collectors.toList()).toArray(new Class[0]);\n+                                    annotationValues.put(value.name(),\n+                                            valueArr);\n+                                    break;\n+                                }\n+                                case STRING:\n+                                    annotationValues.put(value.name(),\n+                                            value.asStringArray());\n+                                    break;\n+                                case ENUM:\n+                                    annotationValues.put(value.name(),\n+                                            value.asEnumArray());\n+                                    break;\n+                                case NESTED: {\n+                                    Annotation[] valueArr = Arrays.stream(value.asNestedArray())\n+                                            .map(v -> new AnnotationWrapper(v, indexView).get())\n+                                            .collect(Collectors.toList()).toArray(new Annotation[0]);\n+                                    annotationValues.put(value.name(),\n+                                            valueArr);\n+                                    break;\n+                                }\n+                                case UNKNOWN:\n+                                    // Note: If an array is empty, it is unknown, but\n+                                    // Jandex doesn't provide a way to check array length\n+                                    // According to Jandex javadoc:\n+                                    //\n+                                    // A special AnnotationValue.Kind.UNKNOWN kind is used to refer to\n+                                    // components of zero-length arrays, as the underlying type is not known.\n+                                    //\n+                                    // So it safe to use an empty Object array\n+                                    annotationValues.put(value.name(),\n+                                            new Object[] {});\n+                                    break;\n+                                case ARRAY:\n+                                default:\n+                                    throw new IllegalStateException(\"Arrays of \" + value.componentKind() +\n+                                            \" are unsupported in the enum parser.\" +\n+                                            \" This exception was caused by a\" +\n+                                            \" @\" + annotationInstance.name() + \" annotation\" +\n+                                            \" for parameter \" + value.name() + \".\" +\n+                                            \" Maybe put \" + annotationInstance.name() +\n+                                            \" not in a subpackage of org.optaplanner?\");\n+                            }\n+                            break;\n+                        case NESTED:\n+                            AnnotationWrapper wrapper = new AnnotationWrapper(value.asNested(), indexView);\n+                            annotationValues.put(value.name(), wrapper.get());\n+                            break;\n+                        case UNKNOWN:\n+                        default:\n+                            throw new IllegalStateException(value.componentKind() +\n+                                    \" are unsupported in the enum parser.\" +\n+                                    \" This exception was caused by a\" +\n+                                    \" @\" + annotationInstance.name() + \" annotation\" +\n+                                    \" for parameter \" + value.name() + \".\" +\n+                                    \" Maybe put \" + annotationInstance.name() +\n+                                    \" not in a subpackage of org.optaplanner?\");\n+                    }\n+                });\n+            }\n+        }\n+\n+        @Override\n+        public Annotation get() {\n+            if (annotation != null) {\n+                return annotation;\n+            } else {\n+                return AllOptaPlannerAnnotationEnum.getForClass(annotationType, annotationValues);\n+            }\n+        }\n+\n+        public Class<? extends Annotation> getAnnotationType() {\n+            return annotationType;\n+        }\n+\n+        public void setAnnotationType(Class<? extends Annotation> annotationType) {\n+            this.annotationType = annotationType;\n+        }\n+\n+        public Map<String, Object> getAnnotationValues() {\n+            return annotationValues;\n+        }\n+\n+        public void setAnnotationValues(Map<String, Object> annotationValues) {\n+            this.annotationValues = annotationValues;\n+        }\n+\n+        public Annotation getAnnotation() {\n+            return annotation;\n+        }\n+\n+        public void setAnnotation(Annotation annotation) {\n+            this.annotation = annotation;\n+        }\n+    }\n+\n+    public static class ConstraintConfigurationWrapper implements ConstraintConfiguration {\n+        public Map<String, Object> map;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26442d15e9b9a5c576dee926017ce74dd7a4b9"}, "originalPosition": 329}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MTM1MQ==", "bodyText": "Redundant block of code; in fact, it's a single line.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552441351", "createdAt": "2021-01-06T08:47:10Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoTypeWrappers.java", "diffHunk": "@@ -0,0 +1,400 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.AnnotatedType;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.GenericDeclaration;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.jandex.PrimitiveType;\n+\n+/**\n+ * Contains wrappers for types so they may be\n+ * recorded in bytecode.\n+ *\n+ * When bytecode is being recorded in Quarkus (i.e. an\n+ * object is passed to a recorder), the following restrictions apply:\n+ *\n+ * - Classes without public getters/setters for all fields,\n+ * a constructor annotated with @RecordableConstructor with parameter names that match field names or a\n+ * registered substitution cannot be recorded. (https://quarkus.io/guides/writing-extensions#bytecode-recording)\n+ *\n+ * Annotations and Generic Types do not satisfy the above criteria, so they cannot be\n+ * recorded directly at build time. However, we don't want to use reflection at runtime,\n+ * and we want to build the GizmoMemberAccessors at build time. So we need to create\n+ * wrappers for the annotations and types so they can be recorded.\n+ */\n+public class GizmoTypeWrappers {\n+\n+    public static Type getTypeForJandex(IndexView indexView, org.jboss.jandex.Type jandexType) {\n+        if (jandexType == null) {\n+            return null;\n+        }\n+\n+        switch (jandexType.kind()) {\n+            case CLASS:\n+                try {\n+                    // Classes do not need a wrapper, so we can just return the Class object\n+                    return Class.forName(jandexType.asClassType().name().toString(), false,\n+                            Thread.currentThread().getContextClassLoader());\n+                } catch (ClassNotFoundException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            case ARRAY:\n+                return new GizmoTypeWrappers.ArrayTypeWrapper(\n+                        getTypeForJandex(indexView, jandexType.asArrayType().component()));\n+            case PRIMITIVE:\n+                return lookupPrimitiveType(jandexType.asPrimitiveType().primitive());\n+            case VOID:\n+                return void.class;\n+            case TYPE_VARIABLE: {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26442d15e9b9a5c576dee926017ce74dd7a4b9"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MjE4MQ==", "bodyText": "Such a switch statement with block of code under individual cases is difficult to test.\nSuggestion: if any CASE is not a one-liner, move the block of code to a method, which can be easily unit-tested.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552442181", "createdAt": "2021-01-06T08:49:09Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoTypeWrappers.java", "diffHunk": "@@ -0,0 +1,400 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.AnnotatedType;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.GenericDeclaration;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.jandex.PrimitiveType;\n+\n+/**\n+ * Contains wrappers for types so they may be\n+ * recorded in bytecode.\n+ *\n+ * When bytecode is being recorded in Quarkus (i.e. an\n+ * object is passed to a recorder), the following restrictions apply:\n+ *\n+ * - Classes without public getters/setters for all fields,\n+ * a constructor annotated with @RecordableConstructor with parameter names that match field names or a\n+ * registered substitution cannot be recorded. (https://quarkus.io/guides/writing-extensions#bytecode-recording)\n+ *\n+ * Annotations and Generic Types do not satisfy the above criteria, so they cannot be\n+ * recorded directly at build time. However, we don't want to use reflection at runtime,\n+ * and we want to build the GizmoMemberAccessors at build time. So we need to create\n+ * wrappers for the annotations and types so they can be recorded.\n+ */\n+public class GizmoTypeWrappers {\n+\n+    public static Type getTypeForJandex(IndexView indexView, org.jboss.jandex.Type jandexType) {\n+        if (jandexType == null) {\n+            return null;\n+        }\n+\n+        switch (jandexType.kind()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26442d15e9b9a5c576dee926017ce74dd7a4b9"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MzEzNg==", "bodyText": "Formatting: the sentence fits a single line.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552443136", "createdAt": "2021-01-06T08:51:18Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26442d15e9b9a5c576dee926017ce74dd7a4b9"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NzExMQ==", "bodyText": "I haven't found any usage of the method; why do we define it and return an empty string?", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552447111", "createdAt": "2021-01-06T09:00:12Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor\n+ * of a particular Member\n+ */\n+public class GizmoMemberAccessorImplementor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26442d15e9b9a5c576dee926017ce74dd7a4b9"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1MjAyNg==", "bodyText": "One-line lambdas can be written like follows (soft suggestion):\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ClassOutput classOutput = (path, byteCode) -> {\n          \n          \n            \n                        classBytecodeHolder[0] = byteCode;\n          \n          \n            \n                    };\n          \n          \n            \n                    ClassOutput classOutput = (path, byteCode) -> classBytecodeHolder[0] = byteCode;", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552452026", "createdAt": "2021-01-06T09:10:22Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor\n+ * of a particular Member\n+ */\n+public class GizmoMemberAccessorImplementor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (classNameToBytecode.containsKey(name)) {\n+                // Gizmo generated class\n+                byte[] byteCode = classNameToBytecode.get(name);\n+                return defineClass(name, byteCode, 0, byteCode.length);\n+            } else {\n+                // Not a Gizmo generated class; load from context class loader\n+                return Thread.currentThread().getContextClassLoader().loadClass(name);\n+            }\n+        }\n+    };\n+\n+    private static boolean useClassLoader = false;\n+\n+    /**\n+     * Call this method if you generated the bytecode\n+     * during the build process (ex: Quarkus)\n+     *\n+     * @param classLoader The classloader that contains the generated\n+     *        gizmo classes.\n+     *\n+     * @param newGizmoMemberAccessorNameToGenericType The map from\n+     *        member accessor class name\n+     *        to its generic type\n+     * @param newGizmoMemberAccessorNameToAnnotatedElement The map from\n+     *        member accessor class name\n+     *        to its annotated Element.\n+     */\n+    public static void setGizmoClassLoader(ClassLoader classLoader, Map<String, Type> newGizmoMemberAccessorNameToGenericType,\n+            Map<String, AnnotatedElement> newGizmoMemberAccessorNameToAnnotatedElement) {\n+        gizmoClassLoader = classLoader;\n+        gizmoMemberAccessorNameToGenericType = newGizmoMemberAccessorNameToGenericType;\n+        gizmoMemberAccessorNameToAnnotatedElement = newGizmoMemberAccessorNameToAnnotatedElement;\n+        useClassLoader = true;\n+    }\n+\n+    /**\n+     * Generates the constructor and implementations of MemberAccessor\n+     * methods for the given MemberDescriptor using the given ClassCreator\n+     *\n+     * @param classCreator ClassCreator to write output to\n+     * @param member Member to generate MemberAccessor methods implementation for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     */\n+    public static void defineAccessorFor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        // ************************************************************************\n+        // MemberAccessor methods\n+        // ************************************************************************\n+        createConstructor(classCreator, member, annotationClass);\n+        createGetDeclaringClass(classCreator, member, annotationClass);\n+        createGetType(classCreator, member, annotationClass);\n+        createGetGenericType(classCreator, member, annotationClass);\n+        createGetName(classCreator, member, annotationClass);\n+        createGetSpeedNote(classCreator, member, annotationClass);\n+        createSupportSetter(classCreator, member, annotationClass);\n+        createExecuteGetter(classCreator, member, annotationClass);\n+        createExecuteSetter(classCreator, member, annotationClass);\n+\n+        // ************************************************************************\n+        // AnnotatedElement methods\n+        // ************************************************************************\n+        createAnnotatedElement(classCreator, member);\n+\n+        createIsAnnotationPresent(classCreator, member, annotationClass);\n+        createGetAnnotation(classCreator, member, annotationClass);\n+        createGetAnnotations(classCreator, member, annotationClass);\n+        createGetDeclaredAnnotations(classCreator, member, annotationClass);\n+    }\n+\n+    /**\n+     * Returns the generated class name for a given member\n+     *\n+     * @param member The member to get the generated class name for\n+     * @return The generated class name for member\n+     */\n+    public static String getGeneratedClassName(Member member) {\n+        return member.getDeclaringClass().getPackage().getName() + \".$optaplanner$__\"\n+                + member.getDeclaringClass().getSimpleName() + \"$__\" + member.getName();\n+    }\n+\n+    /**\n+     * Creates a MemberAccessor for a given member, generating\n+     * the MemberAccessor bytecode if required\n+     *\n+     * @param member The member to generate a MemberAccessor for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n+     *         Will generate the bytecode the first type it is called\n+     *         for a member, unless a classloader has been set,\n+     *         in which case no Gizmo code will be generated.\n+     */\n+    public static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass) {\n+        String className = getGeneratedClassName(member);\n+        if (useClassLoader || classNameToBytecode.containsKey(className)) {\n+            return createInstance(className);\n+        }\n+        final byte[][] classBytecodeHolder = new byte[1][];\n+        ClassOutput classOutput = (path, byteCode) -> {\n+            classBytecodeHolder[0] = byteCode;\n+        };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26442d15e9b9a5c576dee926017ce74dd7a4b9"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1MjY2NA==", "bodyText": "Unused parameters.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552452664", "createdAt": "2021-01-06T09:11:37Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor\n+ * of a particular Member\n+ */\n+public class GizmoMemberAccessorImplementor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (classNameToBytecode.containsKey(name)) {\n+                // Gizmo generated class\n+                byte[] byteCode = classNameToBytecode.get(name);\n+                return defineClass(name, byteCode, 0, byteCode.length);\n+            } else {\n+                // Not a Gizmo generated class; load from context class loader\n+                return Thread.currentThread().getContextClassLoader().loadClass(name);\n+            }\n+        }\n+    };\n+\n+    private static boolean useClassLoader = false;\n+\n+    /**\n+     * Call this method if you generated the bytecode\n+     * during the build process (ex: Quarkus)\n+     *\n+     * @param classLoader The classloader that contains the generated\n+     *        gizmo classes.\n+     *\n+     * @param newGizmoMemberAccessorNameToGenericType The map from\n+     *        member accessor class name\n+     *        to its generic type\n+     * @param newGizmoMemberAccessorNameToAnnotatedElement The map from\n+     *        member accessor class name\n+     *        to its annotated Element.\n+     */\n+    public static void setGizmoClassLoader(ClassLoader classLoader, Map<String, Type> newGizmoMemberAccessorNameToGenericType,\n+            Map<String, AnnotatedElement> newGizmoMemberAccessorNameToAnnotatedElement) {\n+        gizmoClassLoader = classLoader;\n+        gizmoMemberAccessorNameToGenericType = newGizmoMemberAccessorNameToGenericType;\n+        gizmoMemberAccessorNameToAnnotatedElement = newGizmoMemberAccessorNameToAnnotatedElement;\n+        useClassLoader = true;\n+    }\n+\n+    /**\n+     * Generates the constructor and implementations of MemberAccessor\n+     * methods for the given MemberDescriptor using the given ClassCreator\n+     *\n+     * @param classCreator ClassCreator to write output to\n+     * @param member Member to generate MemberAccessor methods implementation for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     */\n+    public static void defineAccessorFor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        // ************************************************************************\n+        // MemberAccessor methods\n+        // ************************************************************************\n+        createConstructor(classCreator, member, annotationClass);\n+        createGetDeclaringClass(classCreator, member, annotationClass);\n+        createGetType(classCreator, member, annotationClass);\n+        createGetGenericType(classCreator, member, annotationClass);\n+        createGetName(classCreator, member, annotationClass);\n+        createGetSpeedNote(classCreator, member, annotationClass);\n+        createSupportSetter(classCreator, member, annotationClass);\n+        createExecuteGetter(classCreator, member, annotationClass);\n+        createExecuteSetter(classCreator, member, annotationClass);\n+\n+        // ************************************************************************\n+        // AnnotatedElement methods\n+        // ************************************************************************\n+        createAnnotatedElement(classCreator, member);\n+\n+        createIsAnnotationPresent(classCreator, member, annotationClass);\n+        createGetAnnotation(classCreator, member, annotationClass);\n+        createGetAnnotations(classCreator, member, annotationClass);\n+        createGetDeclaredAnnotations(classCreator, member, annotationClass);\n+    }\n+\n+    /**\n+     * Returns the generated class name for a given member\n+     *\n+     * @param member The member to get the generated class name for\n+     * @return The generated class name for member\n+     */\n+    public static String getGeneratedClassName(Member member) {\n+        return member.getDeclaringClass().getPackage().getName() + \".$optaplanner$__\"\n+                + member.getDeclaringClass().getSimpleName() + \"$__\" + member.getName();\n+    }\n+\n+    /**\n+     * Creates a MemberAccessor for a given member, generating\n+     * the MemberAccessor bytecode if required\n+     *\n+     * @param member The member to generate a MemberAccessor for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n+     *         Will generate the bytecode the first type it is called\n+     *         for a member, unless a classloader has been set,\n+     *         in which case no Gizmo code will be generated.\n+     */\n+    public static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass) {\n+        String className = getGeneratedClassName(member);\n+        if (useClassLoader || classNameToBytecode.containsKey(className)) {\n+            return createInstance(className);\n+        }\n+        final byte[][] classBytecodeHolder = new byte[1][];\n+        ClassOutput classOutput = (path, byteCode) -> {\n+            classBytecodeHolder[0] = byteCode;\n+        };\n+        ClassCreator classCreator = ClassCreator.builder()\n+                .className(className)\n+                .interfaces(MemberAccessor.class)\n+                .superClass(Object.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        MemberDescriptor memberDescriptor = new MemberDescriptor(member);\n+        defineAccessorFor(classCreator, memberDescriptor, annotationClass);\n+\n+        classCreator.close();\n+        byte[] classBytecode = classBytecodeHolder[0];\n+\n+        classNameToBytecode.put(className, classBytecode);\n+        return createInstance(className);\n+    }\n+\n+    private static MemberAccessor createInstance(String className) {\n+        try {\n+            return (MemberAccessor) gizmoClassLoader.loadClass(className)\n+                    .getConstructor().newInstance();\n+        } catch (InvocationTargetException | InstantiationException | IllegalAccessException | ClassNotFoundException\n+                | NoSuchMethodException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the Generic Type that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The generic type gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getGenericType\n+     */\n+    public static Type getGenericTypeFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToGenericType.get(gizmoMemberAccessorName);\n+    }\n+\n+    /**\n+     * Returns the AnnotatedElement that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The AnnotatedElement gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getAnnotatedElement\n+     */\n+    public static AnnotatedElement getAnnotatedElementFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToAnnotatedElement.get(gizmoMemberAccessorName);\n+    }\n+\n+    // ************************************************************************\n+    // MemberAccessor methods\n+    // ************************************************************************\n+\n+    private static MethodCreator getMethodCreator(ClassCreator classCreator, String methodName, Class<?>... parameters) {\n+        try {\n+            return classCreator.getMethodCreator(\n+                    MethodDescriptor.ofMethod(MemberAccessor.class.getMethod(methodName, parameters)));\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalStateException(\"No such method: \" + methodName, e);\n+        }\n+    }\n+\n+    private static void createConstructor(ClassCreator classCreator, MemberDescriptor member,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26442d15e9b9a5c576dee926017ce74dd7a4b9"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1NjI0Mw==", "bodyText": "A formatting suggestion (please consider for other methods as well):\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Class getDeclaringClass() {\n          \n          \n            \n                 * return ClassThatDeclaredMember.class;\n          \n          \n            \n                 * }\n          \n          \n            \n                 * <pre>\n          \n          \n            \n                 *     Class getDeclaringClass() {\n          \n          \n            \n                 *         return ClassThatDeclaredMember.class;\n          \n          \n            \n                 *     }\n          \n          \n            \n                 * </pre>", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552456243", "createdAt": "2021-01-06T09:18:51Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor\n+ * of a particular Member\n+ */\n+public class GizmoMemberAccessorImplementor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (classNameToBytecode.containsKey(name)) {\n+                // Gizmo generated class\n+                byte[] byteCode = classNameToBytecode.get(name);\n+                return defineClass(name, byteCode, 0, byteCode.length);\n+            } else {\n+                // Not a Gizmo generated class; load from context class loader\n+                return Thread.currentThread().getContextClassLoader().loadClass(name);\n+            }\n+        }\n+    };\n+\n+    private static boolean useClassLoader = false;\n+\n+    /**\n+     * Call this method if you generated the bytecode\n+     * during the build process (ex: Quarkus)\n+     *\n+     * @param classLoader The classloader that contains the generated\n+     *        gizmo classes.\n+     *\n+     * @param newGizmoMemberAccessorNameToGenericType The map from\n+     *        member accessor class name\n+     *        to its generic type\n+     * @param newGizmoMemberAccessorNameToAnnotatedElement The map from\n+     *        member accessor class name\n+     *        to its annotated Element.\n+     */\n+    public static void setGizmoClassLoader(ClassLoader classLoader, Map<String, Type> newGizmoMemberAccessorNameToGenericType,\n+            Map<String, AnnotatedElement> newGizmoMemberAccessorNameToAnnotatedElement) {\n+        gizmoClassLoader = classLoader;\n+        gizmoMemberAccessorNameToGenericType = newGizmoMemberAccessorNameToGenericType;\n+        gizmoMemberAccessorNameToAnnotatedElement = newGizmoMemberAccessorNameToAnnotatedElement;\n+        useClassLoader = true;\n+    }\n+\n+    /**\n+     * Generates the constructor and implementations of MemberAccessor\n+     * methods for the given MemberDescriptor using the given ClassCreator\n+     *\n+     * @param classCreator ClassCreator to write output to\n+     * @param member Member to generate MemberAccessor methods implementation for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     */\n+    public static void defineAccessorFor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        // ************************************************************************\n+        // MemberAccessor methods\n+        // ************************************************************************\n+        createConstructor(classCreator, member, annotationClass);\n+        createGetDeclaringClass(classCreator, member, annotationClass);\n+        createGetType(classCreator, member, annotationClass);\n+        createGetGenericType(classCreator, member, annotationClass);\n+        createGetName(classCreator, member, annotationClass);\n+        createGetSpeedNote(classCreator, member, annotationClass);\n+        createSupportSetter(classCreator, member, annotationClass);\n+        createExecuteGetter(classCreator, member, annotationClass);\n+        createExecuteSetter(classCreator, member, annotationClass);\n+\n+        // ************************************************************************\n+        // AnnotatedElement methods\n+        // ************************************************************************\n+        createAnnotatedElement(classCreator, member);\n+\n+        createIsAnnotationPresent(classCreator, member, annotationClass);\n+        createGetAnnotation(classCreator, member, annotationClass);\n+        createGetAnnotations(classCreator, member, annotationClass);\n+        createGetDeclaredAnnotations(classCreator, member, annotationClass);\n+    }\n+\n+    /**\n+     * Returns the generated class name for a given member\n+     *\n+     * @param member The member to get the generated class name for\n+     * @return The generated class name for member\n+     */\n+    public static String getGeneratedClassName(Member member) {\n+        return member.getDeclaringClass().getPackage().getName() + \".$optaplanner$__\"\n+                + member.getDeclaringClass().getSimpleName() + \"$__\" + member.getName();\n+    }\n+\n+    /**\n+     * Creates a MemberAccessor for a given member, generating\n+     * the MemberAccessor bytecode if required\n+     *\n+     * @param member The member to generate a MemberAccessor for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n+     *         Will generate the bytecode the first type it is called\n+     *         for a member, unless a classloader has been set,\n+     *         in which case no Gizmo code will be generated.\n+     */\n+    public static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass) {\n+        String className = getGeneratedClassName(member);\n+        if (useClassLoader || classNameToBytecode.containsKey(className)) {\n+            return createInstance(className);\n+        }\n+        final byte[][] classBytecodeHolder = new byte[1][];\n+        ClassOutput classOutput = (path, byteCode) -> {\n+            classBytecodeHolder[0] = byteCode;\n+        };\n+        ClassCreator classCreator = ClassCreator.builder()\n+                .className(className)\n+                .interfaces(MemberAccessor.class)\n+                .superClass(Object.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        MemberDescriptor memberDescriptor = new MemberDescriptor(member);\n+        defineAccessorFor(classCreator, memberDescriptor, annotationClass);\n+\n+        classCreator.close();\n+        byte[] classBytecode = classBytecodeHolder[0];\n+\n+        classNameToBytecode.put(className, classBytecode);\n+        return createInstance(className);\n+    }\n+\n+    private static MemberAccessor createInstance(String className) {\n+        try {\n+            return (MemberAccessor) gizmoClassLoader.loadClass(className)\n+                    .getConstructor().newInstance();\n+        } catch (InvocationTargetException | InstantiationException | IllegalAccessException | ClassNotFoundException\n+                | NoSuchMethodException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the Generic Type that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The generic type gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getGenericType\n+     */\n+    public static Type getGenericTypeFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToGenericType.get(gizmoMemberAccessorName);\n+    }\n+\n+    /**\n+     * Returns the AnnotatedElement that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The AnnotatedElement gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getAnnotatedElement\n+     */\n+    public static AnnotatedElement getAnnotatedElementFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToAnnotatedElement.get(gizmoMemberAccessorName);\n+    }\n+\n+    // ************************************************************************\n+    // MemberAccessor methods\n+    // ************************************************************************\n+\n+    private static MethodCreator getMethodCreator(ClassCreator classCreator, String methodName, Class<?>... parameters) {\n+        try {\n+            return classCreator.getMethodCreator(\n+                    MethodDescriptor.ofMethod(MemberAccessor.class.getMethod(methodName, parameters)));\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalStateException(\"No such method: \" + methodName, e);\n+        }\n+    }\n+\n+    private static void createConstructor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator =\n+                classCreator.getMethodCreator(MethodDescriptor.ofConstructor(classCreator.getClassName()));\n+\n+        ResultHandle thisObj = methodCreator.getThis();\n+\n+        // Invoke Object's constructor\n+        methodCreator.invokeSpecialMethod(MethodDescriptor.ofConstructor(Object.class), thisObj);\n+\n+        // Return this (it a constructor)\n+        methodCreator.returnValue(thisObj);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Class getDeclaringClass() {\n+     * return ClassThatDeclaredMember.class;\n+     * }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26442d15e9b9a5c576dee926017ce74dd7a4b9"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1NjY0MA==", "bodyText": "The annotationClass parameter is not used (please check also other methods below).", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552456640", "createdAt": "2021-01-06T09:19:29Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor\n+ * of a particular Member\n+ */\n+public class GizmoMemberAccessorImplementor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (classNameToBytecode.containsKey(name)) {\n+                // Gizmo generated class\n+                byte[] byteCode = classNameToBytecode.get(name);\n+                return defineClass(name, byteCode, 0, byteCode.length);\n+            } else {\n+                // Not a Gizmo generated class; load from context class loader\n+                return Thread.currentThread().getContextClassLoader().loadClass(name);\n+            }\n+        }\n+    };\n+\n+    private static boolean useClassLoader = false;\n+\n+    /**\n+     * Call this method if you generated the bytecode\n+     * during the build process (ex: Quarkus)\n+     *\n+     * @param classLoader The classloader that contains the generated\n+     *        gizmo classes.\n+     *\n+     * @param newGizmoMemberAccessorNameToGenericType The map from\n+     *        member accessor class name\n+     *        to its generic type\n+     * @param newGizmoMemberAccessorNameToAnnotatedElement The map from\n+     *        member accessor class name\n+     *        to its annotated Element.\n+     */\n+    public static void setGizmoClassLoader(ClassLoader classLoader, Map<String, Type> newGizmoMemberAccessorNameToGenericType,\n+            Map<String, AnnotatedElement> newGizmoMemberAccessorNameToAnnotatedElement) {\n+        gizmoClassLoader = classLoader;\n+        gizmoMemberAccessorNameToGenericType = newGizmoMemberAccessorNameToGenericType;\n+        gizmoMemberAccessorNameToAnnotatedElement = newGizmoMemberAccessorNameToAnnotatedElement;\n+        useClassLoader = true;\n+    }\n+\n+    /**\n+     * Generates the constructor and implementations of MemberAccessor\n+     * methods for the given MemberDescriptor using the given ClassCreator\n+     *\n+     * @param classCreator ClassCreator to write output to\n+     * @param member Member to generate MemberAccessor methods implementation for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     */\n+    public static void defineAccessorFor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        // ************************************************************************\n+        // MemberAccessor methods\n+        // ************************************************************************\n+        createConstructor(classCreator, member, annotationClass);\n+        createGetDeclaringClass(classCreator, member, annotationClass);\n+        createGetType(classCreator, member, annotationClass);\n+        createGetGenericType(classCreator, member, annotationClass);\n+        createGetName(classCreator, member, annotationClass);\n+        createGetSpeedNote(classCreator, member, annotationClass);\n+        createSupportSetter(classCreator, member, annotationClass);\n+        createExecuteGetter(classCreator, member, annotationClass);\n+        createExecuteSetter(classCreator, member, annotationClass);\n+\n+        // ************************************************************************\n+        // AnnotatedElement methods\n+        // ************************************************************************\n+        createAnnotatedElement(classCreator, member);\n+\n+        createIsAnnotationPresent(classCreator, member, annotationClass);\n+        createGetAnnotation(classCreator, member, annotationClass);\n+        createGetAnnotations(classCreator, member, annotationClass);\n+        createGetDeclaredAnnotations(classCreator, member, annotationClass);\n+    }\n+\n+    /**\n+     * Returns the generated class name for a given member\n+     *\n+     * @param member The member to get the generated class name for\n+     * @return The generated class name for member\n+     */\n+    public static String getGeneratedClassName(Member member) {\n+        return member.getDeclaringClass().getPackage().getName() + \".$optaplanner$__\"\n+                + member.getDeclaringClass().getSimpleName() + \"$__\" + member.getName();\n+    }\n+\n+    /**\n+     * Creates a MemberAccessor for a given member, generating\n+     * the MemberAccessor bytecode if required\n+     *\n+     * @param member The member to generate a MemberAccessor for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n+     *         Will generate the bytecode the first type it is called\n+     *         for a member, unless a classloader has been set,\n+     *         in which case no Gizmo code will be generated.\n+     */\n+    public static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass) {\n+        String className = getGeneratedClassName(member);\n+        if (useClassLoader || classNameToBytecode.containsKey(className)) {\n+            return createInstance(className);\n+        }\n+        final byte[][] classBytecodeHolder = new byte[1][];\n+        ClassOutput classOutput = (path, byteCode) -> {\n+            classBytecodeHolder[0] = byteCode;\n+        };\n+        ClassCreator classCreator = ClassCreator.builder()\n+                .className(className)\n+                .interfaces(MemberAccessor.class)\n+                .superClass(Object.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        MemberDescriptor memberDescriptor = new MemberDescriptor(member);\n+        defineAccessorFor(classCreator, memberDescriptor, annotationClass);\n+\n+        classCreator.close();\n+        byte[] classBytecode = classBytecodeHolder[0];\n+\n+        classNameToBytecode.put(className, classBytecode);\n+        return createInstance(className);\n+    }\n+\n+    private static MemberAccessor createInstance(String className) {\n+        try {\n+            return (MemberAccessor) gizmoClassLoader.loadClass(className)\n+                    .getConstructor().newInstance();\n+        } catch (InvocationTargetException | InstantiationException | IllegalAccessException | ClassNotFoundException\n+                | NoSuchMethodException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the Generic Type that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The generic type gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getGenericType\n+     */\n+    public static Type getGenericTypeFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToGenericType.get(gizmoMemberAccessorName);\n+    }\n+\n+    /**\n+     * Returns the AnnotatedElement that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The AnnotatedElement gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getAnnotatedElement\n+     */\n+    public static AnnotatedElement getAnnotatedElementFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToAnnotatedElement.get(gizmoMemberAccessorName);\n+    }\n+\n+    // ************************************************************************\n+    // MemberAccessor methods\n+    // ************************************************************************\n+\n+    private static MethodCreator getMethodCreator(ClassCreator classCreator, String methodName, Class<?>... parameters) {\n+        try {\n+            return classCreator.getMethodCreator(\n+                    MethodDescriptor.ofMethod(MemberAccessor.class.getMethod(methodName, parameters)));\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalStateException(\"No such method: \" + methodName, e);\n+        }\n+    }\n+\n+    private static void createConstructor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator =\n+                classCreator.getMethodCreator(MethodDescriptor.ofConstructor(classCreator.getClassName()));\n+\n+        ResultHandle thisObj = methodCreator.getThis();\n+\n+        // Invoke Object's constructor\n+        methodCreator.invokeSpecialMethod(MethodDescriptor.ofConstructor(Object.class), thisObj);\n+\n+        // Return this (it a constructor)\n+        methodCreator.returnValue(thisObj);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Class getDeclaringClass() {\n+     * return ClassThatDeclaredMember.class;\n+     * }\n+     */\n+    private static void createGetDeclaringClass(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26442d15e9b9a5c576dee926017ce74dd7a4b9"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ4NzUzOA==", "bodyText": "May be reused as a standalone method.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552487538", "createdAt": "2021-01-06T10:17:33Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor\n+ * of a particular Member\n+ */\n+public class GizmoMemberAccessorImplementor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (classNameToBytecode.containsKey(name)) {\n+                // Gizmo generated class\n+                byte[] byteCode = classNameToBytecode.get(name);\n+                return defineClass(name, byteCode, 0, byteCode.length);\n+            } else {\n+                // Not a Gizmo generated class; load from context class loader\n+                return Thread.currentThread().getContextClassLoader().loadClass(name);\n+            }\n+        }\n+    };\n+\n+    private static boolean useClassLoader = false;\n+\n+    /**\n+     * Call this method if you generated the bytecode\n+     * during the build process (ex: Quarkus)\n+     *\n+     * @param classLoader The classloader that contains the generated\n+     *        gizmo classes.\n+     *\n+     * @param newGizmoMemberAccessorNameToGenericType The map from\n+     *        member accessor class name\n+     *        to its generic type\n+     * @param newGizmoMemberAccessorNameToAnnotatedElement The map from\n+     *        member accessor class name\n+     *        to its annotated Element.\n+     */\n+    public static void setGizmoClassLoader(ClassLoader classLoader, Map<String, Type> newGizmoMemberAccessorNameToGenericType,\n+            Map<String, AnnotatedElement> newGizmoMemberAccessorNameToAnnotatedElement) {\n+        gizmoClassLoader = classLoader;\n+        gizmoMemberAccessorNameToGenericType = newGizmoMemberAccessorNameToGenericType;\n+        gizmoMemberAccessorNameToAnnotatedElement = newGizmoMemberAccessorNameToAnnotatedElement;\n+        useClassLoader = true;\n+    }\n+\n+    /**\n+     * Generates the constructor and implementations of MemberAccessor\n+     * methods for the given MemberDescriptor using the given ClassCreator\n+     *\n+     * @param classCreator ClassCreator to write output to\n+     * @param member Member to generate MemberAccessor methods implementation for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     */\n+    public static void defineAccessorFor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        // ************************************************************************\n+        // MemberAccessor methods\n+        // ************************************************************************\n+        createConstructor(classCreator, member, annotationClass);\n+        createGetDeclaringClass(classCreator, member, annotationClass);\n+        createGetType(classCreator, member, annotationClass);\n+        createGetGenericType(classCreator, member, annotationClass);\n+        createGetName(classCreator, member, annotationClass);\n+        createGetSpeedNote(classCreator, member, annotationClass);\n+        createSupportSetter(classCreator, member, annotationClass);\n+        createExecuteGetter(classCreator, member, annotationClass);\n+        createExecuteSetter(classCreator, member, annotationClass);\n+\n+        // ************************************************************************\n+        // AnnotatedElement methods\n+        // ************************************************************************\n+        createAnnotatedElement(classCreator, member);\n+\n+        createIsAnnotationPresent(classCreator, member, annotationClass);\n+        createGetAnnotation(classCreator, member, annotationClass);\n+        createGetAnnotations(classCreator, member, annotationClass);\n+        createGetDeclaredAnnotations(classCreator, member, annotationClass);\n+    }\n+\n+    /**\n+     * Returns the generated class name for a given member\n+     *\n+     * @param member The member to get the generated class name for\n+     * @return The generated class name for member\n+     */\n+    public static String getGeneratedClassName(Member member) {\n+        return member.getDeclaringClass().getPackage().getName() + \".$optaplanner$__\"\n+                + member.getDeclaringClass().getSimpleName() + \"$__\" + member.getName();\n+    }\n+\n+    /**\n+     * Creates a MemberAccessor for a given member, generating\n+     * the MemberAccessor bytecode if required\n+     *\n+     * @param member The member to generate a MemberAccessor for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n+     *         Will generate the bytecode the first type it is called\n+     *         for a member, unless a classloader has been set,\n+     *         in which case no Gizmo code will be generated.\n+     */\n+    public static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass) {\n+        String className = getGeneratedClassName(member);\n+        if (useClassLoader || classNameToBytecode.containsKey(className)) {\n+            return createInstance(className);\n+        }\n+        final byte[][] classBytecodeHolder = new byte[1][];\n+        ClassOutput classOutput = (path, byteCode) -> {\n+            classBytecodeHolder[0] = byteCode;\n+        };\n+        ClassCreator classCreator = ClassCreator.builder()\n+                .className(className)\n+                .interfaces(MemberAccessor.class)\n+                .superClass(Object.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        MemberDescriptor memberDescriptor = new MemberDescriptor(member);\n+        defineAccessorFor(classCreator, memberDescriptor, annotationClass);\n+\n+        classCreator.close();\n+        byte[] classBytecode = classBytecodeHolder[0];\n+\n+        classNameToBytecode.put(className, classBytecode);\n+        return createInstance(className);\n+    }\n+\n+    private static MemberAccessor createInstance(String className) {\n+        try {\n+            return (MemberAccessor) gizmoClassLoader.loadClass(className)\n+                    .getConstructor().newInstance();\n+        } catch (InvocationTargetException | InstantiationException | IllegalAccessException | ClassNotFoundException\n+                | NoSuchMethodException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the Generic Type that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The generic type gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getGenericType\n+     */\n+    public static Type getGenericTypeFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToGenericType.get(gizmoMemberAccessorName);\n+    }\n+\n+    /**\n+     * Returns the AnnotatedElement that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The AnnotatedElement gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getAnnotatedElement\n+     */\n+    public static AnnotatedElement getAnnotatedElementFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToAnnotatedElement.get(gizmoMemberAccessorName);\n+    }\n+\n+    // ************************************************************************\n+    // MemberAccessor methods\n+    // ************************************************************************\n+\n+    private static MethodCreator getMethodCreator(ClassCreator classCreator, String methodName, Class<?>... parameters) {\n+        try {\n+            return classCreator.getMethodCreator(\n+                    MethodDescriptor.ofMethod(MemberAccessor.class.getMethod(methodName, parameters)));\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalStateException(\"No such method: \" + methodName, e);\n+        }\n+    }\n+\n+    private static void createConstructor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator =\n+                classCreator.getMethodCreator(MethodDescriptor.ofConstructor(classCreator.getClassName()));\n+\n+        ResultHandle thisObj = methodCreator.getThis();\n+\n+        // Invoke Object's constructor\n+        methodCreator.invokeSpecialMethod(MethodDescriptor.ofConstructor(Object.class), thisObj);\n+\n+        // Return this (it a constructor)\n+        methodCreator.returnValue(thisObj);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Class getDeclaringClass() {\n+     * return ClassThatDeclaredMember.class;\n+     * }\n+     */\n+    private static void createGetDeclaringClass(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getDeclaringClass\");\n+        ResultHandle out = methodCreator.loadClass(member.getDeclaringClassName());\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Asserts method is a getter or read method\n+     *\n+     * @param method Method to assert is getter or read\n+     * @param annotationClass Used in exception message\n+     */\n+    private static void assertIsGoodMethod(MethodDescriptor method, Class<? extends Annotation> annotationClass) {\n+        if (method.getParameterTypes().length != 0) {\n+            // not read or getter method\n+            throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                    + annotationClass.getSimpleName() + \" annotation must not have any parameters (\"\n+                    + Arrays.toString(method.getParameterTypes()) + \").\");\n+        }\n+        String methodName = method.getName();\n+        if (methodName.startsWith(\"get\")) {\n+            if (method.getReturnType().equals(\"void\")) {\n+                throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a non-void return type (\"\n+                        + method.getReturnType() + \").\");\n+            }\n+        } else if (methodName.startsWith(\"is\")) {\n+            if (!method.getReturnType().equals(\"boolean\")) {\n+                throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a primitive boolean return type (\"\n+                        + method.getReturnType() + \") or use another prefix in its methodName (\"\n+                        + methodName + \").\");\n+            }\n+        } else {\n+            // must be a read method\n+            if (method.getReturnType().equals(\"void\")) {\n+                throw new IllegalStateException(\"The readMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a non-void return type (\"\n+                        + method.getReturnType() + \").\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * String getName() {\n+     * return \"fieldOrMethodName\";\n+     * }\n+     *\n+     * If it is a getter method, \"get\" is removed and the first\n+     * letter become lowercase\n+     */\n+    private static void createGetName(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getName\");\n+\n+        // If it is a method, assert that it has the required\n+        // properties\n+        member.whenIsMethod(method -> {\n+            assertIsGoodMethod(method, annotationClass);\n+        });\n+\n+        String fieldName = member.getName();\n+        ResultHandle out = methodCreator.load(fieldName);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Class getType() {\n+     * return FieldTypeOrMethodReturnType.class;\n+     * }\n+     */\n+    private static void createGetType(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getType\");\n+        ResultHandle out = methodCreator.loadClass(member.getTypeName());\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Type getGenericType() {\n+     * return GizmoMemberAccessorImplementor.getGenericTypeFor(this.getClass().getName());\n+     * }\n+     *\n+     * We are unable to load a non-primitive object constant, so we need to store it\n+     * in the implementor, which then can return us the Type when needed. The type\n+     * is stored in gizmoMemberAccessorNameToGenericType when this method is called.\n+     */\n+    private static void createGetGenericType(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getGenericType\");\n+        String gizmoMemberAccessorName = classCreator.getClassName();\n+\n+        // Put the member generic type in the map\n+        gizmoMemberAccessorNameToGenericType.put(gizmoMemberAccessorName,\n+                member.getType());\n+\n+        ResultHandle gizmoMemberAccessorNameResult = methodCreator.load(gizmoMemberAccessorName);\n+\n+        // Use getGenericTypeFor to receive the generic type that\n+        // was put in the map\n+        ResultHandle out = methodCreator.invokeStaticMethod(\n+                MethodDescriptor.ofMethod(GizmoMemberAccessorImplementor.class,\n+                        \"getGenericTypeFor\",\n+                        Type.class,\n+                        String.class),\n+                gizmoMemberAccessorNameResult);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * // for a field\n+     * Object executeGetter(Object bean) {\n+     * return ((DeclaringClass) bean).field;\n+     * }\n+     *\n+     * // for a method\n+     * Object executeGetter(Object bean) {\n+     * return ((DeclaringClass) bean).method();\n+     * }\n+     *\n+     * The member MUST be public if not called in Quarkus\n+     * (i.e. we don't delegate to the field getter/setter).\n+     * In Quarkus, we generate simple getter/setter for the\n+     * member if it is private (which get passed to the MemberDescriptor).\n+     */\n+    private static void createExecuteGetter(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"executeGetter\", Object.class);\n+        ResultHandle bean = methodCreator.getMethodParam(0);\n+\n+        member.whenIsMethod(method -> {\n+            assertIsGoodMethod(method, annotationClass);\n+            ResultHandle out;\n+            if (member.isInterfaceMethod()) {\n+                out = methodCreator.invokeInterfaceMethod(method, bean);\n+            } else {\n+                out = methodCreator.invokeVirtualMethod(method, bean);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26442d15e9b9a5c576dee926017ce74dd7a4b9"}, "originalPosition": 408}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ5NTkyNw==", "bodyText": "A good old if-else would make it clear it's either a method or a field, never both.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552495927", "createdAt": "2021-01-06T10:34:49Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor\n+ * of a particular Member\n+ */\n+public class GizmoMemberAccessorImplementor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (classNameToBytecode.containsKey(name)) {\n+                // Gizmo generated class\n+                byte[] byteCode = classNameToBytecode.get(name);\n+                return defineClass(name, byteCode, 0, byteCode.length);\n+            } else {\n+                // Not a Gizmo generated class; load from context class loader\n+                return Thread.currentThread().getContextClassLoader().loadClass(name);\n+            }\n+        }\n+    };\n+\n+    private static boolean useClassLoader = false;\n+\n+    /**\n+     * Call this method if you generated the bytecode\n+     * during the build process (ex: Quarkus)\n+     *\n+     * @param classLoader The classloader that contains the generated\n+     *        gizmo classes.\n+     *\n+     * @param newGizmoMemberAccessorNameToGenericType The map from\n+     *        member accessor class name\n+     *        to its generic type\n+     * @param newGizmoMemberAccessorNameToAnnotatedElement The map from\n+     *        member accessor class name\n+     *        to its annotated Element.\n+     */\n+    public static void setGizmoClassLoader(ClassLoader classLoader, Map<String, Type> newGizmoMemberAccessorNameToGenericType,\n+            Map<String, AnnotatedElement> newGizmoMemberAccessorNameToAnnotatedElement) {\n+        gizmoClassLoader = classLoader;\n+        gizmoMemberAccessorNameToGenericType = newGizmoMemberAccessorNameToGenericType;\n+        gizmoMemberAccessorNameToAnnotatedElement = newGizmoMemberAccessorNameToAnnotatedElement;\n+        useClassLoader = true;\n+    }\n+\n+    /**\n+     * Generates the constructor and implementations of MemberAccessor\n+     * methods for the given MemberDescriptor using the given ClassCreator\n+     *\n+     * @param classCreator ClassCreator to write output to\n+     * @param member Member to generate MemberAccessor methods implementation for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     */\n+    public static void defineAccessorFor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        // ************************************************************************\n+        // MemberAccessor methods\n+        // ************************************************************************\n+        createConstructor(classCreator, member, annotationClass);\n+        createGetDeclaringClass(classCreator, member, annotationClass);\n+        createGetType(classCreator, member, annotationClass);\n+        createGetGenericType(classCreator, member, annotationClass);\n+        createGetName(classCreator, member, annotationClass);\n+        createGetSpeedNote(classCreator, member, annotationClass);\n+        createSupportSetter(classCreator, member, annotationClass);\n+        createExecuteGetter(classCreator, member, annotationClass);\n+        createExecuteSetter(classCreator, member, annotationClass);\n+\n+        // ************************************************************************\n+        // AnnotatedElement methods\n+        // ************************************************************************\n+        createAnnotatedElement(classCreator, member);\n+\n+        createIsAnnotationPresent(classCreator, member, annotationClass);\n+        createGetAnnotation(classCreator, member, annotationClass);\n+        createGetAnnotations(classCreator, member, annotationClass);\n+        createGetDeclaredAnnotations(classCreator, member, annotationClass);\n+    }\n+\n+    /**\n+     * Returns the generated class name for a given member\n+     *\n+     * @param member The member to get the generated class name for\n+     * @return The generated class name for member\n+     */\n+    public static String getGeneratedClassName(Member member) {\n+        return member.getDeclaringClass().getPackage().getName() + \".$optaplanner$__\"\n+                + member.getDeclaringClass().getSimpleName() + \"$__\" + member.getName();\n+    }\n+\n+    /**\n+     * Creates a MemberAccessor for a given member, generating\n+     * the MemberAccessor bytecode if required\n+     *\n+     * @param member The member to generate a MemberAccessor for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n+     *         Will generate the bytecode the first type it is called\n+     *         for a member, unless a classloader has been set,\n+     *         in which case no Gizmo code will be generated.\n+     */\n+    public static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass) {\n+        String className = getGeneratedClassName(member);\n+        if (useClassLoader || classNameToBytecode.containsKey(className)) {\n+            return createInstance(className);\n+        }\n+        final byte[][] classBytecodeHolder = new byte[1][];\n+        ClassOutput classOutput = (path, byteCode) -> {\n+            classBytecodeHolder[0] = byteCode;\n+        };\n+        ClassCreator classCreator = ClassCreator.builder()\n+                .className(className)\n+                .interfaces(MemberAccessor.class)\n+                .superClass(Object.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        MemberDescriptor memberDescriptor = new MemberDescriptor(member);\n+        defineAccessorFor(classCreator, memberDescriptor, annotationClass);\n+\n+        classCreator.close();\n+        byte[] classBytecode = classBytecodeHolder[0];\n+\n+        classNameToBytecode.put(className, classBytecode);\n+        return createInstance(className);\n+    }\n+\n+    private static MemberAccessor createInstance(String className) {\n+        try {\n+            return (MemberAccessor) gizmoClassLoader.loadClass(className)\n+                    .getConstructor().newInstance();\n+        } catch (InvocationTargetException | InstantiationException | IllegalAccessException | ClassNotFoundException\n+                | NoSuchMethodException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the Generic Type that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The generic type gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getGenericType\n+     */\n+    public static Type getGenericTypeFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToGenericType.get(gizmoMemberAccessorName);\n+    }\n+\n+    /**\n+     * Returns the AnnotatedElement that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The AnnotatedElement gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getAnnotatedElement\n+     */\n+    public static AnnotatedElement getAnnotatedElementFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToAnnotatedElement.get(gizmoMemberAccessorName);\n+    }\n+\n+    // ************************************************************************\n+    // MemberAccessor methods\n+    // ************************************************************************\n+\n+    private static MethodCreator getMethodCreator(ClassCreator classCreator, String methodName, Class<?>... parameters) {\n+        try {\n+            return classCreator.getMethodCreator(\n+                    MethodDescriptor.ofMethod(MemberAccessor.class.getMethod(methodName, parameters)));\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalStateException(\"No such method: \" + methodName, e);\n+        }\n+    }\n+\n+    private static void createConstructor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator =\n+                classCreator.getMethodCreator(MethodDescriptor.ofConstructor(classCreator.getClassName()));\n+\n+        ResultHandle thisObj = methodCreator.getThis();\n+\n+        // Invoke Object's constructor\n+        methodCreator.invokeSpecialMethod(MethodDescriptor.ofConstructor(Object.class), thisObj);\n+\n+        // Return this (it a constructor)\n+        methodCreator.returnValue(thisObj);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Class getDeclaringClass() {\n+     * return ClassThatDeclaredMember.class;\n+     * }\n+     */\n+    private static void createGetDeclaringClass(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getDeclaringClass\");\n+        ResultHandle out = methodCreator.loadClass(member.getDeclaringClassName());\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Asserts method is a getter or read method\n+     *\n+     * @param method Method to assert is getter or read\n+     * @param annotationClass Used in exception message\n+     */\n+    private static void assertIsGoodMethod(MethodDescriptor method, Class<? extends Annotation> annotationClass) {\n+        if (method.getParameterTypes().length != 0) {\n+            // not read or getter method\n+            throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                    + annotationClass.getSimpleName() + \" annotation must not have any parameters (\"\n+                    + Arrays.toString(method.getParameterTypes()) + \").\");\n+        }\n+        String methodName = method.getName();\n+        if (methodName.startsWith(\"get\")) {\n+            if (method.getReturnType().equals(\"void\")) {\n+                throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a non-void return type (\"\n+                        + method.getReturnType() + \").\");\n+            }\n+        } else if (methodName.startsWith(\"is\")) {\n+            if (!method.getReturnType().equals(\"boolean\")) {\n+                throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a primitive boolean return type (\"\n+                        + method.getReturnType() + \") or use another prefix in its methodName (\"\n+                        + methodName + \").\");\n+            }\n+        } else {\n+            // must be a read method\n+            if (method.getReturnType().equals(\"void\")) {\n+                throw new IllegalStateException(\"The readMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a non-void return type (\"\n+                        + method.getReturnType() + \").\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * String getName() {\n+     * return \"fieldOrMethodName\";\n+     * }\n+     *\n+     * If it is a getter method, \"get\" is removed and the first\n+     * letter become lowercase\n+     */\n+    private static void createGetName(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getName\");\n+\n+        // If it is a method, assert that it has the required\n+        // properties\n+        member.whenIsMethod(method -> {\n+            assertIsGoodMethod(method, annotationClass);\n+        });\n+\n+        String fieldName = member.getName();\n+        ResultHandle out = methodCreator.load(fieldName);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Class getType() {\n+     * return FieldTypeOrMethodReturnType.class;\n+     * }\n+     */\n+    private static void createGetType(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getType\");\n+        ResultHandle out = methodCreator.loadClass(member.getTypeName());\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Type getGenericType() {\n+     * return GizmoMemberAccessorImplementor.getGenericTypeFor(this.getClass().getName());\n+     * }\n+     *\n+     * We are unable to load a non-primitive object constant, so we need to store it\n+     * in the implementor, which then can return us the Type when needed. The type\n+     * is stored in gizmoMemberAccessorNameToGenericType when this method is called.\n+     */\n+    private static void createGetGenericType(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getGenericType\");\n+        String gizmoMemberAccessorName = classCreator.getClassName();\n+\n+        // Put the member generic type in the map\n+        gizmoMemberAccessorNameToGenericType.put(gizmoMemberAccessorName,\n+                member.getType());\n+\n+        ResultHandle gizmoMemberAccessorNameResult = methodCreator.load(gizmoMemberAccessorName);\n+\n+        // Use getGenericTypeFor to receive the generic type that\n+        // was put in the map\n+        ResultHandle out = methodCreator.invokeStaticMethod(\n+                MethodDescriptor.ofMethod(GizmoMemberAccessorImplementor.class,\n+                        \"getGenericTypeFor\",\n+                        Type.class,\n+                        String.class),\n+                gizmoMemberAccessorNameResult);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * // for a field\n+     * Object executeGetter(Object bean) {\n+     * return ((DeclaringClass) bean).field;\n+     * }\n+     *\n+     * // for a method\n+     * Object executeGetter(Object bean) {\n+     * return ((DeclaringClass) bean).method();\n+     * }\n+     *\n+     * The member MUST be public if not called in Quarkus\n+     * (i.e. we don't delegate to the field getter/setter).\n+     * In Quarkus, we generate simple getter/setter for the\n+     * member if it is private (which get passed to the MemberDescriptor).\n+     */\n+    private static void createExecuteGetter(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"executeGetter\", Object.class);\n+        ResultHandle bean = methodCreator.getMethodParam(0);\n+\n+        member.whenIsMethod(method -> {\n+            assertIsGoodMethod(method, annotationClass);\n+            ResultHandle out;\n+            if (member.isInterfaceMethod()) {\n+                out = methodCreator.invokeInterfaceMethod(method, bean);\n+            } else {\n+                out = methodCreator.invokeVirtualMethod(method, bean);\n+            }\n+            methodCreator.returnValue(out);\n+        });\n+\n+        member.whenIsField(field -> {\n+            ResultHandle out = methodCreator.readInstanceField(field, bean);\n+            methodCreator.returnValue(out);\n+        });\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * // for a field or a getter method that also have a corresponding setter\n+     * boolean supportSetter() {\n+     * return true;\n+     * }\n+     *\n+     * // for a read method or a getter method without a setter\n+     * boolean supportSetter() {\n+     * return false;\n+     * }\n+     */\n+    private static void createSupportSetter(ClassCreator classCreator, MemberDescriptor member, Class<?> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"supportSetter\");\n+        member.whenIsMethod(method -> {\n+            boolean supportSetter = member.getSetter().isPresent();\n+            ResultHandle out = methodCreator.load(supportSetter);\n+            methodCreator.returnValue(out);\n+        });\n+        member.whenIsField(field -> {\n+            ResultHandle out = methodCreator.load(true);\n+            methodCreator.returnValue(out);\n+        });\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * // for a field\n+     * void executeSetter(Object bean, Object value) {\n+     * return ((DeclaringClass) bean).field = value;\n+     * }\n+     *\n+     * // for a getter method with a corresponding setter\n+     * void executeSetter(Object bean, Object value) {\n+     * return ((DeclaringClass) bean).setValue(value);\n+     * }\n+     *\n+     * // for a read method or a getter method without a setter\n+     * void executeSetter(Object bean, Object value) {\n+     * throw new UnsupportedOperationException(\"Setter not supported\");\n+     * }\n+     */\n+    private static void createExecuteSetter(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"executeSetter\", Object.class,\n+                Object.class);\n+\n+        member.whenIsMethod(method -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26442d15e9b9a5c576dee926017ce74dd7a4b9"}, "originalPosition": 467}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxODc4Nw==", "bodyText": "When there are several constructors with various combinations of parameters, it's often better to reuse the most general one that takes all the possible parameters, possibly together with factory methods.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552518787", "createdAt": "2021-01-06T11:25:30Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor\n+ * of a particular Member\n+ */\n+public class GizmoMemberAccessorImplementor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (classNameToBytecode.containsKey(name)) {\n+                // Gizmo generated class\n+                byte[] byteCode = classNameToBytecode.get(name);\n+                return defineClass(name, byteCode, 0, byteCode.length);\n+            } else {\n+                // Not a Gizmo generated class; load from context class loader\n+                return Thread.currentThread().getContextClassLoader().loadClass(name);\n+            }\n+        }\n+    };\n+\n+    private static boolean useClassLoader = false;\n+\n+    /**\n+     * Call this method if you generated the bytecode\n+     * during the build process (ex: Quarkus)\n+     *\n+     * @param classLoader The classloader that contains the generated\n+     *        gizmo classes.\n+     *\n+     * @param newGizmoMemberAccessorNameToGenericType The map from\n+     *        member accessor class name\n+     *        to its generic type\n+     * @param newGizmoMemberAccessorNameToAnnotatedElement The map from\n+     *        member accessor class name\n+     *        to its annotated Element.\n+     */\n+    public static void setGizmoClassLoader(ClassLoader classLoader, Map<String, Type> newGizmoMemberAccessorNameToGenericType,\n+            Map<String, AnnotatedElement> newGizmoMemberAccessorNameToAnnotatedElement) {\n+        gizmoClassLoader = classLoader;\n+        gizmoMemberAccessorNameToGenericType = newGizmoMemberAccessorNameToGenericType;\n+        gizmoMemberAccessorNameToAnnotatedElement = newGizmoMemberAccessorNameToAnnotatedElement;\n+        useClassLoader = true;\n+    }\n+\n+    /**\n+     * Generates the constructor and implementations of MemberAccessor\n+     * methods for the given MemberDescriptor using the given ClassCreator\n+     *\n+     * @param classCreator ClassCreator to write output to\n+     * @param member Member to generate MemberAccessor methods implementation for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     */\n+    public static void defineAccessorFor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        // ************************************************************************\n+        // MemberAccessor methods\n+        // ************************************************************************\n+        createConstructor(classCreator, member, annotationClass);\n+        createGetDeclaringClass(classCreator, member, annotationClass);\n+        createGetType(classCreator, member, annotationClass);\n+        createGetGenericType(classCreator, member, annotationClass);\n+        createGetName(classCreator, member, annotationClass);\n+        createGetSpeedNote(classCreator, member, annotationClass);\n+        createSupportSetter(classCreator, member, annotationClass);\n+        createExecuteGetter(classCreator, member, annotationClass);\n+        createExecuteSetter(classCreator, member, annotationClass);\n+\n+        // ************************************************************************\n+        // AnnotatedElement methods\n+        // ************************************************************************\n+        createAnnotatedElement(classCreator, member);\n+\n+        createIsAnnotationPresent(classCreator, member, annotationClass);\n+        createGetAnnotation(classCreator, member, annotationClass);\n+        createGetAnnotations(classCreator, member, annotationClass);\n+        createGetDeclaredAnnotations(classCreator, member, annotationClass);\n+    }\n+\n+    /**\n+     * Returns the generated class name for a given member\n+     *\n+     * @param member The member to get the generated class name for\n+     * @return The generated class name for member\n+     */\n+    public static String getGeneratedClassName(Member member) {\n+        return member.getDeclaringClass().getPackage().getName() + \".$optaplanner$__\"\n+                + member.getDeclaringClass().getSimpleName() + \"$__\" + member.getName();\n+    }\n+\n+    /**\n+     * Creates a MemberAccessor for a given member, generating\n+     * the MemberAccessor bytecode if required\n+     *\n+     * @param member The member to generate a MemberAccessor for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n+     *         Will generate the bytecode the first type it is called\n+     *         for a member, unless a classloader has been set,\n+     *         in which case no Gizmo code will be generated.\n+     */\n+    public static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass) {\n+        String className = getGeneratedClassName(member);\n+        if (useClassLoader || classNameToBytecode.containsKey(className)) {\n+            return createInstance(className);\n+        }\n+        final byte[][] classBytecodeHolder = new byte[1][];\n+        ClassOutput classOutput = (path, byteCode) -> {\n+            classBytecodeHolder[0] = byteCode;\n+        };\n+        ClassCreator classCreator = ClassCreator.builder()\n+                .className(className)\n+                .interfaces(MemberAccessor.class)\n+                .superClass(Object.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        MemberDescriptor memberDescriptor = new MemberDescriptor(member);\n+        defineAccessorFor(classCreator, memberDescriptor, annotationClass);\n+\n+        classCreator.close();\n+        byte[] classBytecode = classBytecodeHolder[0];\n+\n+        classNameToBytecode.put(className, classBytecode);\n+        return createInstance(className);\n+    }\n+\n+    private static MemberAccessor createInstance(String className) {\n+        try {\n+            return (MemberAccessor) gizmoClassLoader.loadClass(className)\n+                    .getConstructor().newInstance();\n+        } catch (InvocationTargetException | InstantiationException | IllegalAccessException | ClassNotFoundException\n+                | NoSuchMethodException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the Generic Type that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The generic type gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getGenericType\n+     */\n+    public static Type getGenericTypeFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToGenericType.get(gizmoMemberAccessorName);\n+    }\n+\n+    /**\n+     * Returns the AnnotatedElement that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The AnnotatedElement gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getAnnotatedElement\n+     */\n+    public static AnnotatedElement getAnnotatedElementFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToAnnotatedElement.get(gizmoMemberAccessorName);\n+    }\n+\n+    // ************************************************************************\n+    // MemberAccessor methods\n+    // ************************************************************************\n+\n+    private static MethodCreator getMethodCreator(ClassCreator classCreator, String methodName, Class<?>... parameters) {\n+        try {\n+            return classCreator.getMethodCreator(\n+                    MethodDescriptor.ofMethod(MemberAccessor.class.getMethod(methodName, parameters)));\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalStateException(\"No such method: \" + methodName, e);\n+        }\n+    }\n+\n+    private static void createConstructor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator =\n+                classCreator.getMethodCreator(MethodDescriptor.ofConstructor(classCreator.getClassName()));\n+\n+        ResultHandle thisObj = methodCreator.getThis();\n+\n+        // Invoke Object's constructor\n+        methodCreator.invokeSpecialMethod(MethodDescriptor.ofConstructor(Object.class), thisObj);\n+\n+        // Return this (it a constructor)\n+        methodCreator.returnValue(thisObj);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Class getDeclaringClass() {\n+     * return ClassThatDeclaredMember.class;\n+     * }\n+     */\n+    private static void createGetDeclaringClass(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getDeclaringClass\");\n+        ResultHandle out = methodCreator.loadClass(member.getDeclaringClassName());\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Asserts method is a getter or read method\n+     *\n+     * @param method Method to assert is getter or read\n+     * @param annotationClass Used in exception message\n+     */\n+    private static void assertIsGoodMethod(MethodDescriptor method, Class<? extends Annotation> annotationClass) {\n+        if (method.getParameterTypes().length != 0) {\n+            // not read or getter method\n+            throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                    + annotationClass.getSimpleName() + \" annotation must not have any parameters (\"\n+                    + Arrays.toString(method.getParameterTypes()) + \").\");\n+        }\n+        String methodName = method.getName();\n+        if (methodName.startsWith(\"get\")) {\n+            if (method.getReturnType().equals(\"void\")) {\n+                throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a non-void return type (\"\n+                        + method.getReturnType() + \").\");\n+            }\n+        } else if (methodName.startsWith(\"is\")) {\n+            if (!method.getReturnType().equals(\"boolean\")) {\n+                throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a primitive boolean return type (\"\n+                        + method.getReturnType() + \") or use another prefix in its methodName (\"\n+                        + methodName + \").\");\n+            }\n+        } else {\n+            // must be a read method\n+            if (method.getReturnType().equals(\"void\")) {\n+                throw new IllegalStateException(\"The readMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a non-void return type (\"\n+                        + method.getReturnType() + \").\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * String getName() {\n+     * return \"fieldOrMethodName\";\n+     * }\n+     *\n+     * If it is a getter method, \"get\" is removed and the first\n+     * letter become lowercase\n+     */\n+    private static void createGetName(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getName\");\n+\n+        // If it is a method, assert that it has the required\n+        // properties\n+        member.whenIsMethod(method -> {\n+            assertIsGoodMethod(method, annotationClass);\n+        });\n+\n+        String fieldName = member.getName();\n+        ResultHandle out = methodCreator.load(fieldName);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Class getType() {\n+     * return FieldTypeOrMethodReturnType.class;\n+     * }\n+     */\n+    private static void createGetType(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getType\");\n+        ResultHandle out = methodCreator.loadClass(member.getTypeName());\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Type getGenericType() {\n+     * return GizmoMemberAccessorImplementor.getGenericTypeFor(this.getClass().getName());\n+     * }\n+     *\n+     * We are unable to load a non-primitive object constant, so we need to store it\n+     * in the implementor, which then can return us the Type when needed. The type\n+     * is stored in gizmoMemberAccessorNameToGenericType when this method is called.\n+     */\n+    private static void createGetGenericType(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getGenericType\");\n+        String gizmoMemberAccessorName = classCreator.getClassName();\n+\n+        // Put the member generic type in the map\n+        gizmoMemberAccessorNameToGenericType.put(gizmoMemberAccessorName,\n+                member.getType());\n+\n+        ResultHandle gizmoMemberAccessorNameResult = methodCreator.load(gizmoMemberAccessorName);\n+\n+        // Use getGenericTypeFor to receive the generic type that\n+        // was put in the map\n+        ResultHandle out = methodCreator.invokeStaticMethod(\n+                MethodDescriptor.ofMethod(GizmoMemberAccessorImplementor.class,\n+                        \"getGenericTypeFor\",\n+                        Type.class,\n+                        String.class),\n+                gizmoMemberAccessorNameResult);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * // for a field\n+     * Object executeGetter(Object bean) {\n+     * return ((DeclaringClass) bean).field;\n+     * }\n+     *\n+     * // for a method\n+     * Object executeGetter(Object bean) {\n+     * return ((DeclaringClass) bean).method();\n+     * }\n+     *\n+     * The member MUST be public if not called in Quarkus\n+     * (i.e. we don't delegate to the field getter/setter).\n+     * In Quarkus, we generate simple getter/setter for the\n+     * member if it is private (which get passed to the MemberDescriptor).\n+     */\n+    private static void createExecuteGetter(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"executeGetter\", Object.class);\n+        ResultHandle bean = methodCreator.getMethodParam(0);\n+\n+        member.whenIsMethod(method -> {\n+            assertIsGoodMethod(method, annotationClass);\n+            ResultHandle out;\n+            if (member.isInterfaceMethod()) {\n+                out = methodCreator.invokeInterfaceMethod(method, bean);\n+            } else {\n+                out = methodCreator.invokeVirtualMethod(method, bean);\n+            }\n+            methodCreator.returnValue(out);\n+        });\n+\n+        member.whenIsField(field -> {\n+            ResultHandle out = methodCreator.readInstanceField(field, bean);\n+            methodCreator.returnValue(out);\n+        });\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * // for a field or a getter method that also have a corresponding setter\n+     * boolean supportSetter() {\n+     * return true;\n+     * }\n+     *\n+     * // for a read method or a getter method without a setter\n+     * boolean supportSetter() {\n+     * return false;\n+     * }\n+     */\n+    private static void createSupportSetter(ClassCreator classCreator, MemberDescriptor member, Class<?> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"supportSetter\");\n+        member.whenIsMethod(method -> {\n+            boolean supportSetter = member.getSetter().isPresent();\n+            ResultHandle out = methodCreator.load(supportSetter);\n+            methodCreator.returnValue(out);\n+        });\n+        member.whenIsField(field -> {\n+            ResultHandle out = methodCreator.load(true);\n+            methodCreator.returnValue(out);\n+        });\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * // for a field\n+     * void executeSetter(Object bean, Object value) {\n+     * return ((DeclaringClass) bean).field = value;\n+     * }\n+     *\n+     * // for a getter method with a corresponding setter\n+     * void executeSetter(Object bean, Object value) {\n+     * return ((DeclaringClass) bean).setValue(value);\n+     * }\n+     *\n+     * // for a read method or a getter method without a setter\n+     * void executeSetter(Object bean, Object value) {\n+     * throw new UnsupportedOperationException(\"Setter not supported\");\n+     * }\n+     */\n+    private static void createExecuteSetter(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"executeSetter\", Object.class,\n+                Object.class);\n+\n+        member.whenIsMethod(method -> {\n+            Optional<MethodDescriptor> setter = member.getSetter();\n+            if (setter.isPresent()) {\n+                ResultHandle bean = methodCreator.getMethodParam(0);\n+                ResultHandle value = methodCreator.getMethodParam(1);\n+                if (member.isInterfaceMethod()) {\n+                    methodCreator.invokeInterfaceMethod(setter.get(), bean, value);\n+                } else {\n+                    methodCreator.invokeVirtualMethod(setter.get(), bean, value);\n+                }\n+                methodCreator.returnValue(null);\n+            } else {\n+                methodCreator.throwException(UnsupportedOperationException.class, \"Setter not supported\");\n+            }\n+        });\n+\n+        member.whenIsField(field -> {\n+            ResultHandle bean = methodCreator.getMethodParam(0);\n+            ResultHandle value = methodCreator.getMethodParam(1);\n+            methodCreator.writeInstanceField(field, bean, value);\n+            methodCreator.returnValue(null);\n+        });\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * String getSpeedNote() {\n+     * return \"Fast access with generated bytecode\";\n+     * }\n+     */\n+    private static void createGetSpeedNote(ClassCreator classCreator, MemberDescriptor member, Class<?> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getSpeedNote\");\n+        ResultHandle out = methodCreator.load(\"Fast access with generated bytecode\");\n+        methodCreator.returnValue(out);\n+    }\n+\n+    // ************************************************************************\n+    // AnnotatedElement methods\n+    // ************************************************************************\n+    private static MethodCreator getAnnotationMethodCreator(ClassCreator classCreator, String methodName,\n+            Class<?>... parameters) {\n+        return classCreator.getMethodCreator(getAnnotationMethod(methodName, parameters));\n+    }\n+\n+    private static MethodDescriptor getAnnotationMethod(String methodName, Class<?>... parameters) {\n+        try {\n+            return MethodDescriptor.ofMethod(AnnotatedElement.class.getMethod(methodName, parameters));\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalStateException(\"No such method: \" + methodName, e);\n+        }\n+    }\n+\n+    private static void createAnnotatedElement(ClassCreator classCreator, MemberDescriptor member) {\n+        String gizmoMemberAccessorName = classCreator.getClassName();\n+        AnnotatedElement annotatedElement = member.getAnnotatedElement();\n+        gizmoMemberAccessorNameToAnnotatedElement.put(gizmoMemberAccessorName, annotatedElement);\n+    }\n+\n+    private static MethodDescriptor getAnnotatedElementGetter() {\n+        return MethodDescriptor.ofMethod(GizmoMemberAccessorImplementor.class, \"getAnnotatedElementFor\",\n+                AnnotatedElement.class, String.class);\n+    }\n+\n+    // These methods all delegate to an AnnotatedElement we store in\n+    // gizmoMemberAccessorNameToAnnotatedElement\n+\n+    // getAnnotatedElementGetter() simply returns the method descriptor for getAnnotatedElementFor\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * boolean isAnnotationPresent(Class annotationClass) {\n+     * AnnotatedElement annotatedElement = GizmoMemberAccessorImplementor\n+     * .getAnnotatedElementFor(this.getClass().getName());\n+     * return annotatedElement.isAnnotationPresent(annotationClass);\n+     * }\n+     */\n+    private static void createIsAnnotationPresent(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getAnnotationMethodCreator(classCreator, \"isAnnotationPresent\",\n+                Class.class);\n+        String gizmoMemberAccessorName = classCreator.getClassName();\n+        ResultHandle gizmoMemberAccessorNameResult = methodCreator.load(gizmoMemberAccessorName);\n+        ResultHandle annotatedElement = methodCreator.invokeStaticMethod(getAnnotatedElementGetter(),\n+                gizmoMemberAccessorNameResult);\n+        ResultHandle query = methodCreator.getMethodParam(0);\n+        ResultHandle out = methodCreator.invokeInterfaceMethod(getAnnotationMethod(\"isAnnotationPresent\", Class.class),\n+                annotatedElement, query);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Object getAnnotation(Class annotationClass) {\n+     * AnnotatedElement annotatedElement = GizmoMemberAccessorImplementor\n+     * .getAnnotatedElementFor(this.getClass().getName());\n+     * return annotatedElement.getAnnotation(annotationClass);\n+     * }\n+     */\n+    private static void createGetAnnotation(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getAnnotationMethodCreator(classCreator, \"getAnnotation\",\n+                Class.class);\n+        String gizmoMemberAccessorName = classCreator.getClassName();\n+        ResultHandle gizmoMemberAccessorNameResult = methodCreator.load(gizmoMemberAccessorName);\n+        ResultHandle annotatedElement = methodCreator.invokeStaticMethod(getAnnotatedElementGetter(),\n+                gizmoMemberAccessorNameResult);\n+        ResultHandle query = methodCreator.getMethodParam(0);\n+        ResultHandle out = methodCreator.invokeInterfaceMethod(getAnnotationMethod(\"getAnnotation\", Class.class),\n+                annotatedElement, query);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Object[] getAnnotations() {\n+     * AnnotatedElement annotatedElement = GizmoMemberAccessorImplementor\n+     * .getAnnotatedElementFor(this.getClass().getName());\n+     * return annotatedElement.getAnnotations();\n+     * }\n+     */\n+    private static void createGetAnnotations(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getAnnotationMethodCreator(classCreator, \"getAnnotations\");\n+        String gizmoMemberAccessorName = classCreator.getClassName();\n+        ResultHandle gizmoMemberAccessorNameResult = methodCreator.load(gizmoMemberAccessorName);\n+        ResultHandle annotatedElement = methodCreator.invokeStaticMethod(getAnnotatedElementGetter(),\n+                gizmoMemberAccessorNameResult);\n+        ResultHandle out = methodCreator.invokeInterfaceMethod(getAnnotationMethod(\"getAnnotations\"),\n+                annotatedElement);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Object[] getDeclaredAnnotations() {\n+     * AnnotatedElement annotatedElement = GizmoMemberAccessorImplementor\n+     * .getAnnotatedElementFor(this.getClass().getName());\n+     * return annotatedElement.getDeclaredAnnotations();\n+     * }\n+     */\n+    private static void createGetDeclaredAnnotations(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getAnnotationMethodCreator(classCreator, \"getDeclaredAnnotations\");\n+        String gizmoMemberAccessorName = classCreator.getClassName();\n+        ResultHandle gizmoMemberAccessorNameResult = methodCreator.load(gizmoMemberAccessorName);\n+        ResultHandle annotatedElement = methodCreator.invokeStaticMethod(getAnnotatedElementGetter(),\n+                gizmoMemberAccessorNameResult);\n+        ResultHandle out = methodCreator.invokeInterfaceMethod(getAnnotationMethod(\"getDeclaredAnnotations\"),\n+                annotatedElement);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Describe and provide simplified/unified access for a Member\n+     */\n+    public static class MemberDescriptor {\n+\n+        /**\n+         * The name of a member. For a field, it the field name.\n+         * For a method, if it is a getter, the method name without \"get\"/\"is\"\n+         * and the first letter lowercase; otherwise, the method name.\n+         */\n+        String name;\n+\n+        /**\n+         * If the member is a field, the FieldDescriptor of the member\n+         * If the member is a method, the MethodDescriptor of the member\n+         */\n+        Object memberDescriptor;\n+\n+        /**\n+         * If the member is a normal member, the class that declared it\n+         * If the member is from Jandex, the Jandex ClassInfo of the class that declared it\n+         */\n+        Object declaringClass;\n+\n+        /**\n+         * The member as an AnnotatedElement\n+         */\n+        AnnotatedElement annotatedElement;\n+\n+        /**\n+         * The MethodDescriptor of the corresponding setter. Is empty if not present.\n+         */\n+        Optional<MethodDescriptor> setter;\n+\n+        /**\n+         * The generic type of the member\n+         */\n+        Type type;\n+\n+        public MemberDescriptor(Member member) {\n+            declaringClass = member.getDeclaringClass();\n+            if (member instanceof Field) {\n+                memberDescriptor = FieldDescriptor.of((Field) member);\n+                name = member.getName();\n+                annotatedElement = (Field) member;\n+                type = ((Field) member).getGenericType();\n+                setter = lookupSetter();\n+            } else if (member instanceof Method) {\n+                memberDescriptor = MethodDescriptor.ofMethod((Method) member);\n+                annotatedElement = (Method) member;\n+                if (ReflectionHelper.isGetterMethod((Method) member)) {\n+                    name = ReflectionHelper.getGetterPropertyName(member);\n+                } else {\n+                    name = member.getName();\n+                }\n+                type = ((Method) member).getGenericReturnType();\n+                setter = lookupSetter();\n+            } else {\n+                throw new IllegalArgumentException(member + \" is not a Method or a Field.\");\n+            }\n+        }\n+\n+        // For Quarkus\n+        // (Cannot move to Quarkus module; get runtime\n+        //  exception since objects created here use classes\n+        //  from another ClassLoader).\n+        public MemberDescriptor(FieldInfo fieldInfo, IndexView indexView) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26442d15e9b9a5c576dee926017ce74dd7a4b9"}, "originalPosition": 690}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUyNjE2Mw==", "bodyText": "Please add a message explaining what is the consequence of the CNFE here.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552526163", "createdAt": "2021-01-06T11:43:20Z", "author": {"login": "rsynek"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/GizmoMemberAccessorEntityEnhancer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+package org.optaplanner.quarkus.deployment;\n+\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.IRETURN;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Type;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+import org.optaplanner.core.impl.domain.common.accessor.gizmo.GizmoMemberAccessorImplementor;\n+\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.DescriptorUtils;\n+import io.quarkus.gizmo.Gizmo;\n+import io.quarkus.gizmo.MethodDescriptor;\n+\n+public class GizmoMemberAccessorEntityEnhancer {\n+\n+    private static Set<FieldInfo> visitedFields = new HashSet<>();\n+    private static Set<MethodInfo> visitedMethods = new HashSet<>();\n+\n+    public static void addVirtualFieldGetter(ClassInfo classInfo, FieldInfo fieldInfo,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedFields.contains(fieldInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerFieldEnhancingClassVisitor(classInfo, classVisitor,\n+                            fieldInfo)));\n+            visitedFields.add(fieldInfo);\n+        }\n+    }\n+\n+    public static Optional<MethodDescriptor> addVirtualMethodGetter(ClassInfo classInfo, MethodInfo methodInfo, String name,\n+            Optional<MethodDescriptor> setterDescriptor,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedMethods.contains(methodInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerMethodEnhancingClassVisitor(classInfo, classVisitor, methodInfo,\n+                            name, setterDescriptor)));\n+            visitedMethods.add(methodInfo);\n+        }\n+        return setterDescriptor.map(md -> MethodDescriptor\n+                .ofMethod(classInfo.name().toString(), getVirtualSetterName(name),\n+                        md.getReturnType(), md.getParameterTypes()));\n+    }\n+\n+    public static String getVirtualGetterName(String name) {\n+        return \"$get$optaplanner$__\" + name;\n+    }\n+\n+    public static String getVirtualSetterName(String name) {\n+        return \"$set$optaplanner$__\" + name;\n+    }\n+\n+    /**\n+     * Generates the bytecode for the member accessor for the specified field.\n+     * Additionally enhances the class that declares the field with public simple\n+     * getters/setters methods for the field if the field is private.\n+     *\n+     * @param annotationInstance The annotations on the field\n+     * @param indexView The index view (needed to get default values of annotations)\n+     * @param classOutput Where to output the bytecode\n+     * @param classInfo The declaring class for the field\n+     * @param fieldInfo The field to generate the MemberAccessor for\n+     * @param transformers BuildProducer of BytecodeTransformers\n+     */\n+    public static void generateFieldAccessor(AnnotationInstance annotationInstance, IndexView indexView,\n+            ClassOutput classOutput, ClassInfo classInfo,\n+            FieldInfo fieldInfo, BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        String generatedClassName = classInfo.name().prefix().toString() + \".$optaplanner$__\"\n+                + classInfo.name().withoutPackagePrefix() + \"$__\" + fieldInfo.name();\n+        ClassCreator classCreator = ClassCreator\n+                .builder()\n+                .className(generatedClassName)\n+                .interfaces(MemberAccessor.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        GizmoMemberAccessorImplementor.MemberDescriptor member;\n+        if (Modifier.isPublic(fieldInfo.flags())) {\n+            member = new GizmoMemberAccessorImplementor.MemberDescriptor(fieldInfo, indexView);\n+        } else {\n+            addVirtualFieldGetter(classInfo, fieldInfo, transformers);\n+            String methodName = getVirtualGetterName(fieldInfo.name());\n+            MethodDescriptor setterDescriptor = MethodDescriptor.ofMethod(fieldInfo.declaringClass().name().toString(),\n+                    getVirtualSetterName(fieldInfo.name()),\n+                    \"void\",\n+                    fieldInfo.type().name().toString());\n+            MethodInfo methodInfo = MethodInfo.create(classInfo, methodName, new org.jboss.jandex.Type[] {}, fieldInfo.type(),\n+                    (short) Modifier.PUBLIC);\n+            member = new GizmoMemberAccessorImplementor.MemberDescriptor(fieldInfo, methodInfo, Optional.of(setterDescriptor),\n+                    indexView,\n+                    fieldInfo.name());\n+        }\n+        try {\n+            GizmoMemberAccessorImplementor.defineAccessorFor(classCreator, member,\n+                    (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString()));\n+            classCreator.close();\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    private static String getMemberName(MethodInfo methodInfo) {\n+        if (methodInfo.name().startsWith(\"get\")) { // Case 1: Getter method\n+            return methodInfo.name().substring(3, 4).toLowerCase(Locale.ROOT) + methodInfo.name().substring(4);\n+        } else if (methodInfo.name().startsWith(\"is\")) { // Case 2: Getter method for boolean\n+            return methodInfo.name().substring(2, 3).toLowerCase(Locale.ROOT) + methodInfo.name().substring(3);\n+        } else { // Case 3: Read method\n+            return methodInfo.name();\n+        }\n+    }\n+\n+    private static Optional<MethodDescriptor> getSetterDescriptor(ClassInfo classInfo, MethodInfo methodInfo, String name) {\n+        if (methodInfo.name().startsWith(\"get\") || methodInfo.name().startsWith(\"is\")) {\n+            // ex: for methodInfo = Integer getValue(), name = value,\n+            // return void setValue(Integer value)\n+            // i.e. capitalize first letter of name, and take a parameter\n+            // of the getter return type.\n+            return Optional.ofNullable(classInfo.method(\"set\" + name.substring(0, 1)\n+                    .toUpperCase(Locale.ROOT) +\n+                    name.substring(1),\n+                    methodInfo.returnType())).map(MethodDescriptor::of);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Generates the bytecode for the member accessor for the specified method.\n+     * Additionally enhances the class that declares the method with public simple\n+     * read/(optionally write if getter method and setter present) methods for the method\n+     * if the method is private.\n+     *\n+     * @param annotationInstance The annotations on the field\n+     * @param indexView The index view (needed to get default values of annotations)\n+     * @param classOutput Where to output the bytecode\n+     * @param classInfo The declaring class for the field\n+     * @param methodInfo The method to generate the MemberAccessor for\n+     * @param transformers BuildProducer of BytecodeTransformers\n+     */\n+    public static void generateMethodAccessor(AnnotationInstance annotationInstance, IndexView indexView,\n+            ClassOutput classOutput, ClassInfo classInfo,\n+            MethodInfo methodInfo, BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        String generatedClassName = classInfo.name().prefix().toString() + \".$optaplanner$__\"\n+                + classInfo.name().withoutPackagePrefix() + \"$__\" + methodInfo.name();\n+        ClassCreator classCreator = ClassCreator\n+                .builder()\n+                .className(generatedClassName)\n+                .interfaces(MemberAccessor.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        GizmoMemberAccessorImplementor.MemberDescriptor member;\n+        String name = getMemberName(methodInfo);\n+        Optional<MethodDescriptor> setterDescriptor = getSetterDescriptor(classInfo, methodInfo, name);\n+\n+        if (Modifier.isPublic(methodInfo.flags())) {\n+            member = new GizmoMemberAccessorImplementor.MemberDescriptor(methodInfo, methodInfo, setterDescriptor, indexView,\n+                    name);\n+        } else {\n+            setterDescriptor = addVirtualMethodGetter(classInfo, methodInfo, name, setterDescriptor, transformers);\n+            String methodName = getVirtualGetterName(name);\n+            MethodInfo newMethodInfo = classInfo.method(methodName);\n+            member = new GizmoMemberAccessorImplementor.MemberDescriptor(methodInfo, newMethodInfo, setterDescriptor, indexView,\n+                    name);\n+        }\n+        try {\n+            GizmoMemberAccessorImplementor.defineAccessorFor(classCreator, member,\n+                    (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString()));\n+            classCreator.close();\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26442d15e9b9a5c576dee926017ce74dd7a4b9"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUzMTc0MQ==", "bodyText": "If I understand it correctly, we have a class with a field and an annotation on top of it like follows:\nclass SomeClass {\n  @SomeAnnotation\n  SomeMember member;\n}\n\nHere we load the annotation using the classloader of this class, but when we load the SomeClass here, we use the Thread.currentThread().getContextClassLoader() ?", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552531741", "createdAt": "2021-01-06T11:55:35Z", "author": {"login": "rsynek"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/GizmoMemberAccessorEntityEnhancer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+package org.optaplanner.quarkus.deployment;\n+\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.IRETURN;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Type;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+import org.optaplanner.core.impl.domain.common.accessor.gizmo.GizmoMemberAccessorImplementor;\n+\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.DescriptorUtils;\n+import io.quarkus.gizmo.Gizmo;\n+import io.quarkus.gizmo.MethodDescriptor;\n+\n+public class GizmoMemberAccessorEntityEnhancer {\n+\n+    private static Set<FieldInfo> visitedFields = new HashSet<>();\n+    private static Set<MethodInfo> visitedMethods = new HashSet<>();\n+\n+    public static void addVirtualFieldGetter(ClassInfo classInfo, FieldInfo fieldInfo,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedFields.contains(fieldInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerFieldEnhancingClassVisitor(classInfo, classVisitor,\n+                            fieldInfo)));\n+            visitedFields.add(fieldInfo);\n+        }\n+    }\n+\n+    public static Optional<MethodDescriptor> addVirtualMethodGetter(ClassInfo classInfo, MethodInfo methodInfo, String name,\n+            Optional<MethodDescriptor> setterDescriptor,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedMethods.contains(methodInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerMethodEnhancingClassVisitor(classInfo, classVisitor, methodInfo,\n+                            name, setterDescriptor)));\n+            visitedMethods.add(methodInfo);\n+        }\n+        return setterDescriptor.map(md -> MethodDescriptor\n+                .ofMethod(classInfo.name().toString(), getVirtualSetterName(name),\n+                        md.getReturnType(), md.getParameterTypes()));\n+    }\n+\n+    public static String getVirtualGetterName(String name) {\n+        return \"$get$optaplanner$__\" + name;\n+    }\n+\n+    public static String getVirtualSetterName(String name) {\n+        return \"$set$optaplanner$__\" + name;\n+    }\n+\n+    /**\n+     * Generates the bytecode for the member accessor for the specified field.\n+     * Additionally enhances the class that declares the field with public simple\n+     * getters/setters methods for the field if the field is private.\n+     *\n+     * @param annotationInstance The annotations on the field\n+     * @param indexView The index view (needed to get default values of annotations)\n+     * @param classOutput Where to output the bytecode\n+     * @param classInfo The declaring class for the field\n+     * @param fieldInfo The field to generate the MemberAccessor for\n+     * @param transformers BuildProducer of BytecodeTransformers\n+     */\n+    public static void generateFieldAccessor(AnnotationInstance annotationInstance, IndexView indexView,\n+            ClassOutput classOutput, ClassInfo classInfo,\n+            FieldInfo fieldInfo, BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        String generatedClassName = classInfo.name().prefix().toString() + \".$optaplanner$__\"\n+                + classInfo.name().withoutPackagePrefix() + \"$__\" + fieldInfo.name();\n+        ClassCreator classCreator = ClassCreator\n+                .builder()\n+                .className(generatedClassName)\n+                .interfaces(MemberAccessor.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        GizmoMemberAccessorImplementor.MemberDescriptor member;\n+        if (Modifier.isPublic(fieldInfo.flags())) {\n+            member = new GizmoMemberAccessorImplementor.MemberDescriptor(fieldInfo, indexView);\n+        } else {\n+            addVirtualFieldGetter(classInfo, fieldInfo, transformers);\n+            String methodName = getVirtualGetterName(fieldInfo.name());\n+            MethodDescriptor setterDescriptor = MethodDescriptor.ofMethod(fieldInfo.declaringClass().name().toString(),\n+                    getVirtualSetterName(fieldInfo.name()),\n+                    \"void\",\n+                    fieldInfo.type().name().toString());\n+            MethodInfo methodInfo = MethodInfo.create(classInfo, methodName, new org.jboss.jandex.Type[] {}, fieldInfo.type(),\n+                    (short) Modifier.PUBLIC);\n+            member = new GizmoMemberAccessorImplementor.MemberDescriptor(fieldInfo, methodInfo, Optional.of(setterDescriptor),\n+                    indexView,\n+                    fieldInfo.name());\n+        }\n+        try {\n+            GizmoMemberAccessorImplementor.defineAccessorFor(classCreator, member,\n+                    (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26442d15e9b9a5c576dee926017ce74dd7a4b9"}, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1MTk5OTE1", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-565199915", "createdAt": "2021-01-11T09:53:58Z", "commit": {"oid": "c02661847e2b207da15b06bcda21a26001df8995"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQwOTo1Mzo1OFrOIROLhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQwOTo1Mzo1OFrOIROLhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkyOTAzMQ==", "bodyText": "Dependencies are also in alphabetical order according to groupId, artifactId.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r554929031", "createdAt": "2021-01-11T09:53:58Z", "author": {"login": "ge0ffrey"}, "path": "build/optaplanner-build-parent/pom.xml", "diffHunk": "@@ -159,6 +161,16 @@\n <!--          </exclusion>-->\n         </exclusions>\n       </dependency>\n+      <dependency>\n+        <groupId>io.quarkus.gizmo</groupId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c02661847e2b207da15b06bcda21a26001df8995"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1MjAyNTgz", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-565202583", "createdAt": "2021-01-11T09:57:23Z", "commit": {"oid": "c02661847e2b207da15b06bcda21a26001df8995"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQwOTo1NzoyNFrOIROTpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQwOTo1NzoyNFrOIROTpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkzMTExMQ==", "bodyText": "We like the order of the \"with\" method (just like the getter/setters) to be in the order of the fields.\nso withDomainAccesType() method after withEntityClassList() and also after withEntityClasses().\nMotivation: It's just easier to see if a get/set/with method is lacking. Less chaotic.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r554931111", "createdAt": "2021-01-11T09:57:24Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/SolverConfig.java", "diffHunk": "@@ -445,6 +456,11 @@ public SolverConfig withSolutionClass(Class<?> solutionClass) {\n         return this;\n     }\n \n+    public SolverConfig withDomainAccessType(DomainAccessType domainAccessType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c02661847e2b207da15b06bcda21a26001df8995"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1MjAyOTQ5", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-565202949", "createdAt": "2021-01-11T09:57:51Z", "commit": {"oid": "c02661847e2b207da15b06bcda21a26001df8995"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQwOTo1Nzo1MVrOIROU2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQwOTo1Nzo1MVrOIROU2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkzMTQxOA==", "bodyText": "We like the order of the \"get/set\" method combo to be in the order of the fields.\nso both after setEntityClassList().\nMotivation: It's just easier to see if a get/set/with method is lacking. Less chaotic.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r554931418", "createdAt": "2021-01-11T09:57:51Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/SolverConfig.java", "diffHunk": "@@ -364,6 +367,14 @@ public void setSolutionClass(Class<?> solutionClass) {\n         this.solutionClass = solutionClass;\n     }\n \n+    public DomainAccessType getDomainAccessType() {\n+        return domainAccessType;\n+    }\n+\n+    public void setDomainAccessType(DomainAccessType domainAccessType) {\n+        this.domainAccessType = domainAccessType;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c02661847e2b207da15b06bcda21a26001df8995"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1MjE1Mjc3", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-565215277", "createdAt": "2021-01-11T10:14:14Z", "commit": {"oid": "c02661847e2b207da15b06bcda21a26001df8995"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMDoxNDoxNFrOIRO5FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMDoxNDoxNFrOIRO5FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk0MDY5Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * to \"REFLECTION\". To use \"GIZMO\", io.quarkus.gizmo:gizmo\n          \n          \n            \n                 * to {@link DomainAccessType#REFLECTION}. To use {@link DomainAccessType#GIZMO}, io.quarkus.gizmo:gizmo", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r554940692", "createdAt": "2021-01-11T10:14:14Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-spring-integration/optaplanner-spring-boot-autoconfigure/src/main/java/org/optaplanner/spring/boot/autoconfigure/SolverProperties.java", "diffHunk": "@@ -26,6 +27,15 @@\n      * Defaults to \"REPRODUCIBLE\".\n      */\n     private EnvironmentMode environmentMode;\n+\n+    /**\n+     * Determines how Domain Accessors are created. Defaults\n+     * to \"REFLECTION\". To use \"GIZMO\", io.quarkus.gizmo:gizmo", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c02661847e2b207da15b06bcda21a26001df8995"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1MjMxOTM1", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-565231935", "createdAt": "2021-01-11T10:36:33Z", "commit": {"oid": "c02661847e2b207da15b06bcda21a26001df8995"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMDozNjozM1rOIRPr-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMDozNjozM1rOIRPr-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk1MzcyMg==", "bodyText": "Very important:\n\nFail fast with a clear error message when they use domainAccessType=GIZMO without gizmo in the classpath.\nA `Class.forName() based on a String after the if statement here probably does the trick. Make sure to pick a class to check for that is very very unlikely to disappear in a future Gizmo release.\n\nSuggestion for error message: \"When using the domainAccessType (\" + domainAccessType  + \") the classpath or modulepath must contain io.quarkus.gizmo:gizmo.\\nMaybe add a dependency to io.quarkus.gizmo:gizmo.\");\nHere's what I get on spring-school-timetabling as-is with optaplanner.solver.domainAccessType=GIZMO in application.properties.\nCaused by: java.lang.NoClassDefFoundError: io/quarkus/gizmo/ClassOutput\n        at org.optaplanner.core.impl.domain.common.accessor.gizmo.GizmoMemberAccessorImplementor.createAccessorFor(GizmoMemberAccessorImplementor.java:163)\n        at org.optaplanner.core.impl.domain.common.accessor.MemberAccessorFactory.buildMemberAccessor(MemberAccessorFactory.java:40)\n        at org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor.processPlanningEntityPropertyAnnotation(SolutionDescriptor.java:472)", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r554953722", "createdAt": "2021-01-11T10:36:33Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/MemberAccessorFactory.java", "diffHunk": "@@ -32,7 +34,12 @@\n             SolverFactory.class.getSimpleName() + \".create...() method call.\";\n \n     public static MemberAccessor buildMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n-            Class<? extends Annotation> annotationClass) {\n+            Class<? extends Annotation> annotationClass,\n+            DomainAccessType domainAccessType) {\n+        if (domainAccessType == DomainAccessType.GIZMO) {\n+            return GizmoMemberAccessorImplementor.createAccessorFor(member, annotationClass);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c02661847e2b207da15b06bcda21a26001df8995"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2Mzg3ODQ3", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-566387847", "createdAt": "2021-01-12T15:25:48Z", "commit": {"oid": "1e30fa668fd548870cc1432d969a72f28504f5c3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxNToyNTo0OFrOISGyfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxNToyNTo0OFrOISGyfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTg1NjUxMQ==", "bodyText": "Javadoc proposal: Uses Gizmo generated bytecode to access members (field and method) of the domain for performance, instead of reflection. When used without Quarkus, the planning annotations must be on public members and Gizmo must be added on the classpath or modulepath.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r555856511", "createdAt": "2021-01-12T15:25:48Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/DomainAccessType.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.config.solver;\n+\n+public enum DomainAccessType {\n+    REFLECTION,\n+    GIZMO", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e30fa668fd548870cc1432d969a72f28504f5c3"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2NDE1NjA0", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-566415604", "createdAt": "2021-01-12T15:53:36Z", "commit": {"oid": "1e30fa668fd548870cc1432d969a72f28504f5c3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxNTo1MzozNlrOISIMiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxNTo1MzozNlrOISIMiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTg3OTU2MQ==", "bodyText": "Add // TODO This will break Quarkus once we don't open up the domain hierarchy for reflection any more", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r555879561", "createdAt": "2021-01-12T15:53:36Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/lookup/ClassAndPlanningIdComparator.java", "diffHunk": "@@ -21,18 +21,25 @@\n import java.util.Map;\n \n import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.config.solver.DomainAccessType;\n import org.optaplanner.core.config.util.ConfigUtils;\n import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n \n public class ClassAndPlanningIdComparator implements Comparator<Object> {\n \n     private boolean failFastIfNoPlanningId;\n+    private DomainAccessType domainAccessType;\n \n     public ClassAndPlanningIdComparator() {\n-        this(true);\n+        this(DomainAccessType.REFLECTION, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e30fa668fd548870cc1432d969a72f28504f5c3"}, "originalPosition": 15}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1e30fa668fd548870cc1432d969a72f28504f5c3", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/1e30fa668fd548870cc1432d969a72f28504f5c3", "committedDate": "2021-01-11T20:07:19Z", "message": "Reorder dependencies/methods, add exceptions, add tests\n\n- Exceptions are for missing Gizmo in classpath and\n  annotations on private fields when using domainAccessType=GIZMO"}, "afterCommit": {"oid": "e18200a0144b64c3d5dbd7555049abd23f6d090b", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/e18200a0144b64c3d5dbd7555049abd23f6d090b", "committedDate": "2021-01-12T18:51:07Z", "message": "Change DomainAccessType package, add Javadocs + docs, fix native factory"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2NjI5Mzky", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-566629392", "createdAt": "2021-01-12T19:41:43Z", "commit": {"oid": "e18200a0144b64c3d5dbd7555049abd23f6d090b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxOTo0MTo0NFrOISRlQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxOTo0MTo0NFrOISRlQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjAzMzM0Ng==", "bodyText": "So, I was thinking... why does the user need to make this choice?\n\nWe can detect if Gizmo is on the classpath/modulepath. In that case, we can just enable it.\nLikewise, we can detect if the user has annotations on non-public members.\n\nTherefore - why not simply use Gizmo when present and possible, and use reflection for the rest?\nI'm sure I'm missing some consideration, but from where I'm standing, it seems like we could just make the best choice for the user, instead of forcing them to think about this.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r556033346", "createdAt": "2021-01-12T19:41:44Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/domain/common/DomainAccessType.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.api.domain.common;\n+\n+/**\n+ * Determines how members (fields and methods) of\n+ * the domain are accessed.\n+ */\n+public enum DomainAccessType {\n+    /**\n+     * Use reflection to read the member. Always work, but slow.\n+     */\n+    REFLECTION,\n+\n+    /**\n+     * Uses Gizmo generated bytecode to access members (field and method)\n+     * of the domain for performance, instead of reflection. When used without Quarkus,\n+     * the planning annotations must be on public members and Gizmo must be added\n+     * on the classpath or modulepath.\n+     */\n+    GIZMO\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e18200a0144b64c3d5dbd7555049abd23f6d090b"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2NjMwMjUz", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-566630253", "createdAt": "2021-01-12T19:42:52Z", "commit": {"oid": "e18200a0144b64c3d5dbd7555049abd23f6d090b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxOTo0Mjo1MlrOISRoTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxOTo0Mjo1MlrOISRoTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjAzNDEyNA==", "bodyText": "I see we actually detect if Gizmo is present. So the only thing to make my previous comment happen is the detection of annotations on private fields.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r556034124", "createdAt": "2021-01-12T19:42:52Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/MemberAccessorFactory.java", "diffHunk": "@@ -32,7 +34,22 @@\n             SolverFactory.class.getSimpleName() + \".create...() method call.\";\n \n     public static MemberAccessor buildMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n-            Class<? extends Annotation> annotationClass) {\n+            Class<? extends Annotation> annotationClass,\n+            DomainAccessType domainAccessType) {\n+        if (domainAccessType == DomainAccessType.GIZMO) {\n+            try {\n+                // Check if Gizmo on the classpath by verifying we can access one of its classes\n+                Class.forName(\"io.quarkus.gizmo.ClassCreator\", false,\n+                        Thread.currentThread().getContextClassLoader());\n+            } catch (ClassNotFoundException e) {\n+                throw new IllegalStateException(\"When using the domainAccessType (\" +\n+                        domainAccessType +\n+                        \") the classpath or modulepath must contain io.quarkus.gizmo:gizmo.\\n\" +\n+                        \"Maybe add a dependency to io.quarkus.gizmo:gizmo.\");\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e18200a0144b64c3d5dbd7555049abd23f6d090b"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3Mzg4MzE2", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-567388316", "createdAt": "2021-01-13T16:14:58Z", "commit": {"oid": "0b2cf2df648d282fcd33413747e18b0527e12bf8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxNjoxNDo1OFrOIS3Ksw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxNjoxNDo1OFrOIS3Ksw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY0OTEzOQ==", "bodyText": "I suggest these be extracted to separate top-level classes. 700-line long classes that consist pretty much of other classes should IMO be avoided.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r556649139", "createdAt": "2021-01-13T16:14:58Z", "author": {"login": "triceo"}, "path": "optaplanner-quarkus-integration/optaplanner-quarkus/runtime/src/main/java/org/optaplanner/quarkus/gizmo/GizmoAnnotationWrappers.java", "diffHunk": "@@ -0,0 +1,726 @@\n+package org.optaplanner.quarkus.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.autodiscover.AutoDiscoverMemberType;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfiguration;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfigurationProvider;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintWeight;\n+import org.optaplanner.core.api.domain.entity.PinningFilter;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.entity.PlanningPin;\n+import org.optaplanner.core.api.domain.lookup.LookUpStrategyType;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.ProblemFactProperty;\n+import org.optaplanner.core.api.domain.solution.cloner.SolutionCloner;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.domain.variable.AnchorShadowVariable;\n+import org.optaplanner.core.api.domain.variable.CustomShadowVariable;\n+import org.optaplanner.core.api.domain.variable.InverseRelationShadowVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableGraphType;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableReference;\n+import org.optaplanner.core.api.domain.variable.VariableListener;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionSorterWeightFactory;\n+import org.optaplanner.core.impl.score.definition.ScoreDefinition;\n+\n+/**\n+ * Contains wrappers for Annotations so they may be\n+ * recorded in bytecode. The annotation's values are stored\n+ * in the wrapper's map.\n+ *\n+ * When bytecode is being recorded in Quarkus (i.e. an\n+ * object is passed to a recorder), the following restrictions apply:\n+ *\n+ * - Classes without public getters/setters for all fields,\n+ * a constructor annotated with @RecordableConstructor with parameter names that match field names or a\n+ * registered substitution cannot be recorded. (https://quarkus.io/guides/writing-extensions#bytecode-recording)\n+ *\n+ * Annotations and Generic Types do not satisfy the above criteria, so they cannot be\n+ * recorded directly at build time. However, we don't want to use reflection at runtime,\n+ * and we want to build the GizmoMemberAccessors at build time. So we need to create\n+ * wrappers for the annotations and types so they can be recorded.\n+ */\n+public class GizmoAnnotationWrappers {\n+\n+    enum AllOptaPlannerAnnotationEnum {\n+        PLANNING_SOLUTION(PlanningSolution.class, PlanningSolutionWrapper::new),\n+        PLANNING_SCORE(PlanningScore.class, PlanningScoreWrapper::new),\n+        PLANNING_ENTITY_COLLECTION_PROPERTY(PlanningEntityCollectionProperty.class,\n+                PlanningEntityCollectionPropertyWrapper::new),\n+        PLANNING_ENTITY_PROPERTY(PlanningEntityProperty.class,\n+                PlanningEntityPropertyWrapper::new),\n+        PROBLEM_FACT_COLLECTION_PROPERTY(ProblemFactCollectionProperty.class,\n+                ProblemFactCollectionPropertyWrapper::new),\n+        PROBLEM_FACT_PROPERTY(ProblemFactProperty.class, ProblemFactPropertyWrapper::new),\n+        CONSTRAINT_CONFIGURATION(ConstraintConfiguration.class,\n+                ConstraintConfigurationWrapper::new),\n+        CONSTRAINT_CONFIGURATION_PROVIDER(ConstraintConfigurationProvider.class,\n+                ConstraintConfigurationProviderWrapper::new),\n+        CONSTRAINT_WEIGHT(ConstraintWeight.class, ConstraintWeightWrapper::new),\n+        PLANNING_ENTITY(PlanningEntity.class, PlanningEntityWrapper::new),\n+        PLANNING_PIN(PlanningPin.class, PlanningPinWrapper::new),\n+        PLANNING_ID(PlanningId.class, PlanningIdWrapper::new),\n+        PLANNING_VARIABLE(PlanningVariable.class, PlanningVariableWrapper::new),\n+        PLANNING_VARIABLE_REFERENCE(PlanningVariableReference.class, PlanningVariableReferenceWrapper::new),\n+        VALUE_RANGE_PROVIDER(ValueRangeProvider.class, ValueRangeProviderWrapper::new),\n+        ANCHOR_SHADOW_VARIABLE(AnchorShadowVariable.class, AnchorShadowVariableWrapper::new),\n+        CUSTOM_SHADOW_VARIABLE(CustomShadowVariable.class, CustomShadowVariableWrapper::new),\n+        INVERSE_RELATION_SHADOW_VARIABLE(InverseRelationShadowVariable.class,\n+                InverseRelationShadowVariableWrapper::new);\n+\n+        Class<?> annotationClass;\n+        Function<Map<String, Object>, Annotation> mapper;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        <T extends Annotation> AllOptaPlannerAnnotationEnum(Class<? extends T> annotationClass,\n+                Function<Map<String, Object>, T> mapper) {\n+            this.annotationClass = annotationClass;\n+            this.mapper = (Function<Map<String, Object>, Annotation>) mapper;\n+        }\n+\n+        public Annotation get(Map<String, Object> values) {\n+            return mapper.apply(values);\n+        }\n+\n+        public static Annotation getForClass(Class<? extends Annotation> annotationClass, Map<String, Object> values) {\n+            for (AllOptaPlannerAnnotationEnum annotationType : AllOptaPlannerAnnotationEnum.values()) {\n+                if (annotationClass.equals(annotationType.annotationClass)) {\n+                    return annotationType.get(values);\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Missing case for \" + annotationClass);\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(Class<? extends Annotation> annotationClass) {\n+            return isOptaPlannerAnnotation(annotationClass.getName());\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(String annotationClass) {\n+            return annotationClass.startsWith(\"org.optaplanner.\");\n+        }\n+    }\n+\n+    public static class AnnotationWrapper implements Supplier<Annotation> {\n+        Class<? extends Annotation> annotationType;\n+        Map<String, Object> annotationValues = new HashMap<String, Object>();\n+        Annotation annotation;\n+\n+        public AnnotationWrapper() {\n+        }\n+\n+        public AnnotationWrapper(Annotation annotation) {\n+            this.annotation = annotation;\n+        }\n+\n+        public AnnotationWrapper(AnnotationInstance annotationInstance, IndexView indexView) {\n+            try {\n+                annotationType = (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString());\n+            } catch (ClassNotFoundException e) {\n+                throw new IllegalStateException(e);\n+            }\n+            annotationValues = new HashMap<>();\n+            if (AllOptaPlannerAnnotationEnum.isOptaPlannerAnnotation(annotationType)) {\n+                // Annotation is an OptaPlanner annotation (i.e.\n+                // is a subpackage of org.optaplanner)\n+                annotationInstance.valuesWithDefaults(indexView).forEach((value) -> {\n+                    switch (value.kind()) {\n+                        case BYTE:\n+                            annotationValues.put(value.name(),\n+                                    value.asByte());\n+                            break;\n+                        case SHORT:\n+                            annotationValues.put(value.name(),\n+                                    value.asShort());\n+                            break;\n+                        case INTEGER:\n+                            annotationValues.put(value.name(),\n+                                    value.asInt());\n+                            break;\n+                        case CHARACTER:\n+                            annotationValues.put(value.name(),\n+                                    value.asChar());\n+                            break;\n+                        case FLOAT:\n+                            annotationValues.put(value.name(),\n+                                    value.asFloat());\n+                            break;\n+                        case DOUBLE:\n+                            annotationValues.put(value.name(),\n+                                    value.asDouble());\n+                            break;\n+                        case LONG:\n+                            annotationValues.put(value.name(),\n+                                    value.asLong());\n+                            break;\n+                        case BOOLEAN:\n+                            annotationValues.put(value.name(),\n+                                    value.asBoolean());\n+                            break;\n+                        case CLASS:\n+                            annotationValues.put(value.name(),\n+                                    findClass(annotationInstance, value.asClass()));\n+                            break;\n+                        case STRING:\n+                            annotationValues.put(value.name(),\n+                                    value.asString());\n+                            break;\n+                        case ENUM:\n+                            annotationValues.put(value.name(),\n+                                    value.asEnum());\n+                            break;\n+                        case ARRAY:\n+                            switch (value.componentKind()) {\n+                                case BYTE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asByteArray());\n+                                    break;\n+                                case SHORT:\n+                                    annotationValues.put(value.name(),\n+                                            value.asShortArray());\n+                                    break;\n+                                case INTEGER:\n+                                    annotationValues.put(value.name(),\n+                                            value.asIntArray());\n+                                    break;\n+                                case CHARACTER:\n+                                    annotationValues.put(value.name(),\n+                                            value.asCharArray());\n+                                    break;\n+                                case FLOAT:\n+                                    annotationValues.put(value.name(),\n+                                            value.asFloatArray());\n+                                    break;\n+                                case DOUBLE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asDoubleArray());\n+                                    break;\n+                                case LONG:\n+                                    annotationValues.put(value.name(),\n+                                            value.asLongArray());\n+                                    break;\n+                                case BOOLEAN:\n+                                    annotationValues.put(value.name(),\n+                                            value.asBooleanArray());\n+                                    break;\n+                                case CLASS:\n+                                    annotationValues.put(value.name(),\n+                                            Arrays.stream(value.asClassArray())\n+                                                    .map(v -> findClass(annotationInstance, v))\n+                                                    .collect(Collectors.toList()).toArray(new Class[0]));\n+                                    break;\n+                                case STRING:\n+                                    annotationValues.put(value.name(),\n+                                            value.asStringArray());\n+                                    break;\n+                                case ENUM:\n+                                    annotationValues.put(value.name(),\n+                                            value.asEnumArray());\n+                                    break;\n+                                case NESTED:\n+                                    annotationValues.put(value.name(),\n+                                            Arrays.stream(value.asNestedArray())\n+                                                    .map(v -> new AnnotationWrapper(v, indexView).get())\n+                                                    .collect(Collectors.toList())\n+                                                    .toArray(new Annotation[0]));\n+                                    break;\n+                                case UNKNOWN:\n+                                    // Note: If an array is empty, it is unknown, but\n+                                    // Jandex doesn't provide a way to check array length\n+                                    // According to Jandex javadoc:\n+                                    //\n+                                    // A special AnnotationValue.Kind.UNKNOWN kind is used to refer to\n+                                    // components of zero-length arrays, as the underlying type is not known.\n+                                    //\n+                                    // So it safe to use an empty Object array\n+                                    annotationValues.put(value.name(),\n+                                            new Object[] {});\n+                                    break;\n+                                case ARRAY:\n+                                default:\n+                                    throw new IllegalStateException(\"Arrays of \" + value.componentKind() +\n+                                            \" are unsupported in the enum parser.\" +\n+                                            \" This exception was caused by a\" +\n+                                            \" @\" + annotationInstance.name() + \" annotation\" +\n+                                            \" for parameter \" + value.name() + \".\" +\n+                                            \" Maybe put \" + annotationInstance.name() +\n+                                            \" not in a subpackage of org.optaplanner?\");\n+                            }\n+                            break;\n+                        case NESTED:\n+                            annotationValues.put(value.name(),\n+                                    new AnnotationWrapper(value.asNested(), indexView).get());\n+                            break;\n+                        case UNKNOWN:\n+                        default:\n+                            throw new IllegalStateException(value.componentKind() +\n+                                    \" are unsupported in the enum parser.\" +\n+                                    \" This exception was caused by a\" +\n+                                    \" @\" + annotationInstance.name() + \" annotation\" +\n+                                    \" for parameter \" + value.name() + \".\" +\n+                                    \" Maybe put \" + annotationInstance.name() +\n+                                    \" not in a subpackage of org.optaplanner?\");\n+                    }\n+                });\n+            }\n+        }\n+\n+        @Override\n+        public Annotation get() {\n+            if (annotation != null) {\n+                return annotation;\n+            } else {\n+                return AllOptaPlannerAnnotationEnum.getForClass(annotationType, annotationValues);\n+            }\n+        }\n+\n+        public Class<? extends Annotation> getAnnotationType() {\n+            return annotationType;\n+        }\n+\n+        public void setAnnotationType(Class<? extends Annotation> annotationType) {\n+            this.annotationType = annotationType;\n+        }\n+\n+        public Map<String, Object> getAnnotationValues() {\n+            return annotationValues;\n+        }\n+\n+        public void setAnnotationValues(Map<String, Object> annotationValues) {\n+            this.annotationValues = annotationValues;\n+        }\n+\n+        public Annotation getAnnotation() {\n+            return annotation;\n+        }\n+\n+        public void setAnnotation(Annotation annotation) {\n+            this.annotation = annotation;\n+        }\n+    }\n+\n+    private static Class<?> findClass(AnnotationInstance annotationInstance, Type type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b2cf2df648d282fcd33413747e18b0527e12bf8"}, "originalPosition": 317}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f35ed14177785dc65c26caa2819c0a78ea39095a", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/f35ed14177785dc65c26caa2819c0a78ea39095a", "committedDate": "2021-01-13T22:22:51Z", "message": "Move Quarkus wrapper types to own files, add tests"}, "afterCommit": {"oid": "4494972aa90a488e685f7ead6214cd84a0b024ac", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/4494972aa90a488e685f7ead6214cd84a0b024ac", "committedDate": "2021-01-13T22:38:54Z", "message": "Fixup docs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3OTcxNjA3", "url": "https://github.com/kiegroup/optaplanner/pull/1059#pullrequestreview-567971607", "createdAt": "2021-01-14T07:40:39Z", "commit": {"oid": "4494972aa90a488e685f7ead6214cd84a0b024ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQwNzo0MDozOVrOITTmSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQwNzo0MDozOVrOITTmSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzExNDk1Mg==", "bodyText": "Sonar doesn't like this, and I agree. Optional method argument is a good sign that you need two methods instead. One without the argument, which could delegate to the one with the argument.", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r557114952", "createdAt": "2021-01-14T07:40:39Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberDescriptor.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+\n+import io.quarkus.gizmo.BytecodeCreator;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Describe and provide simplified/unified access for a Member\n+ */\n+public class GizmoMemberDescriptor {\n+\n+    /**\n+     * The name of a member. For a field, it the field name.\n+     * For a method, if it is a getter, the method name without \"get\"/\"is\"\n+     * and the first letter lowercase; otherwise, the method name.\n+     */\n+    String name;\n+\n+    /**\n+     * If the member is a field, the FieldDescriptor of the member\n+     * If the member is a method, the MethodDescriptor of the member\n+     */\n+    Object memberDescriptor;\n+\n+    /**\n+     * If the member is a normal member, the class that declared it\n+     * If the member is from Jandex, the Jandex ClassInfo of the class that declared it\n+     */\n+    Class<?> declaringClass;\n+\n+    /**\n+     * The member as an AnnotatedElement\n+     */\n+    AnnotatedElement annotatedElement;\n+\n+    /**\n+     * The MethodDescriptor of the corresponding setter. Is empty if not present.\n+     */\n+    Optional<MethodDescriptor> setter;\n+\n+    /**\n+     * The generic type of the member\n+     */\n+    Type type;\n+\n+    public GizmoMemberDescriptor(Member member) {\n+        declaringClass = member.getDeclaringClass();\n+        if (!Modifier.isPublic(member.getModifiers())) {\n+            throw new IllegalStateException(\"Member (\" + member.getName() + \") of class (\" +\n+                    member.getDeclaringClass().getName() + \") is not public and domainAccessType is GIZMO.\\n\" +\n+                    ((member instanceof Field) ? \"Maybe put the annotations onto the public getter of the field.\\n\" : \"\") +\n+                    \"Maybe use domainAccessType REFLECTION instead of GIZMO.\");\n+        }\n+        if (member instanceof Field) {\n+            memberDescriptor = FieldDescriptor.of((Field) member);\n+            name = member.getName();\n+            annotatedElement = (Field) member;\n+            type = ((Field) member).getGenericType();\n+            setter = lookupSetter();\n+        } else if (member instanceof Method) {\n+            memberDescriptor = MethodDescriptor.ofMethod((Method) member);\n+            annotatedElement = (Method) member;\n+            if (ReflectionHelper.isGetterMethod((Method) member)) {\n+                name = ReflectionHelper.getGetterPropertyName(member);\n+            } else {\n+                name = member.getName();\n+            }\n+            type = ((Method) member).getGenericReturnType();\n+            setter = lookupSetter();\n+        } else {\n+            throw new IllegalArgumentException(member + \" is not a Method or a Field.\");\n+        }\n+    }\n+\n+    // For Quarkus\n+    // (Cannot move to Quarkus module; get runtime\n+    //  exception since objects created here use classes\n+    //  from another ClassLoader).\n+    public GizmoMemberDescriptor(String name, Object memberDescriptor, Class<?> declaringClass,\n+            AnnotatedElement annotatedElement, Type type) {\n+        this(name, memberDescriptor, declaringClass, annotatedElement, type, null);\n+    }\n+\n+    public GizmoMemberDescriptor(String name, Object memberDescriptor, Class<?> declaringClass,\n+            AnnotatedElement annotatedElement, Type type,\n+            Optional<MethodDescriptor> setterDescriptor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4494972aa90a488e685f7ead6214cd84a0b024ac"}, "originalPosition": 113}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4494972aa90a488e685f7ead6214cd84a0b024ac", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/4494972aa90a488e685f7ead6214cd84a0b024ac", "committedDate": "2021-01-13T22:38:54Z", "message": "Fixup docs"}, "afterCommit": {"oid": "1ff98b2b86a22ebd23fb50c0d5f449b6d3807920", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/1ff98b2b86a22ebd23fb50c0d5f449b6d3807920", "committedDate": "2021-01-14T17:03:27Z", "message": "Fixup docs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f40e9dfc144e38a3b7b27e39f29cefa1d7e1255a", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/f40e9dfc144e38a3b7b27e39f29cefa1d7e1255a", "committedDate": "2021-01-14T20:33:22Z", "message": "Add tests for private methods, remove unused classes"}, "afterCommit": {"oid": "40a2f33609d90cee940e35d650d8835edbd17f5e", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/40a2f33609d90cee940e35d650d8835edbd17f5e", "committedDate": "2021-01-19T14:28:18Z", "message": "Add tests for private methods, remove unused classes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "40a2f33609d90cee940e35d650d8835edbd17f5e", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/40a2f33609d90cee940e35d650d8835edbd17f5e", "committedDate": "2021-01-19T14:28:18Z", "message": "Add tests for private methods, remove unused classes"}, "afterCommit": {"oid": "405b0868fb81b2400d33d5dd0ae769b8bccbf94f", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/405b0868fb81b2400d33d5dd0ae769b8bccbf94f", "committedDate": "2021-01-19T14:48:28Z", "message": "Add tests for private methods, remove unused classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee0e0aa741c21427c201f8c222314f6c9cff198c", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/ee0e0aa741c21427c201f8c222314f6c9cff198c", "committedDate": "2021-01-20T15:04:54Z", "message": "PLANNER-2264: Gizmo Member Accessor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "45e48a5abdf7a1862cd24362620a722d965f730c", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/45e48a5abdf7a1862cd24362620a722d965f730c", "committedDate": "2021-01-19T18:49:42Z", "message": "Add test coverage for bad methods and missing gizmo"}, "afterCommit": {"oid": "ee0e0aa741c21427c201f8c222314f6c9cff198c", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/ee0e0aa741c21427c201f8c222314f6c9cff198c", "committedDate": "2021-01-20T15:04:54Z", "message": "PLANNER-2264: Gizmo Member Accessor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efbfefc4d01e52ee73ee3a0472447f1f58cea472", "author": {"user": {"login": "ge0ffrey", "name": "Geoffrey De Smet"}}, "url": "https://github.com/kiegroup/optaplanner/commit/efbfefc4d01e52ee73ee3a0472447f1f58cea472", "committedDate": "2021-01-22T09:52:37Z", "message": "Merge branch 'master' into PLANNER-2264"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3149, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}