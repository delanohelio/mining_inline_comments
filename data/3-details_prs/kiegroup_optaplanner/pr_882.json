{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3MzE1NDU4", "number": 882, "title": "PLANNER-2114 Extract build methods from Config", "bodyText": "The scope of this PR is move selectors.\nJIRA: PLANNER-2114\nreferenced Pull Requests: None\nHow to retest or run:\n\n\na pull request please add comment: regex [.*[j|J]enkins,?.*(retest|test) this.*]\n\n\na full downstream build please add comment: regex [.*[j|J]enkins,?.*(execute|run|trigger|start|do) fdb.*]\n\n\na compile downstream build please  add comment: regex [.*[j|J]enkins,?.*(execute|run|trigger|start|do) cdb.*]\n\n\na full production downstream please add comment: regex [.*[j|J]enkins,?.*(execute|run|trigger|start|do) product fdb.*]\n\n\nan upstream build please add comment: regex [.*[j|J]enkins,?.*(execute|run|trigger|start|do) upstream.*]\n\n\ni.e for running a full downstream build =  Jenkins do fdb", "createdAt": "2020-08-13T11:09:21Z", "url": "https://github.com/kiegroup/optaplanner/pull/882", "merged": true, "mergeCommit": {"oid": "c729e89bd0bb38de784fbeb8662d6fe4daa77463"}, "closed": true, "closedAt": "2020-08-17T11:58:16Z", "author": {"login": "rsynek"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-eMdigBqjM2NTE2MDI2Mzk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc_wbQ4AH2gAyNDY3MzE1NDU4OjBhZTM3ODMwMDE2ZDMzYjIyM2U2MzEwNDY1MmYzMWQ3N2JmNmE0MDc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1b0cec50ea4b25cad6c80cabdb84ba0ff730638a", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/1b0cec50ea4b25cad6c80cabdb84ba0ff730638a", "committedDate": "2020-08-13T11:06:50Z", "message": "PLANNER-2114 Extract build methods from Config\n\nThis commit scope is move selectors."}, "afterCommit": {"oid": "70a4bf2a4dea37191f024f07fa896e23b67069e5", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/70a4bf2a4dea37191f024f07fa896e23b67069e5", "committedDate": "2020-08-13T11:20:00Z", "message": "PLANNER-2114 Extract build methods from Config\n\nThis commit scope is move selectors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5097fdb32bcb6e8d4087f24084b61384bb35cc2a", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/5097fdb32bcb6e8d4087f24084b61384bb35cc2a", "committedDate": "2020-08-13T12:51:59Z", "message": "PLANNER-2114 Extract build methods from Config\n\nThis commit scope is move selectors."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "70a4bf2a4dea37191f024f07fa896e23b67069e5", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/70a4bf2a4dea37191f024f07fa896e23b67069e5", "committedDate": "2020-08-13T11:20:00Z", "message": "PLANNER-2114 Extract build methods from Config\n\nThis commit scope is move selectors."}, "afterCommit": {"oid": "5097fdb32bcb6e8d4087f24084b61384bb35cc2a", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/5097fdb32bcb6e8d4087f24084b61384bb35cc2a", "committedDate": "2020-08-13T12:51:59Z", "message": "PLANNER-2114 Extract build methods from Config\n\nThis commit scope is move selectors."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2ODc3ODcw", "url": "https://github.com/kiegroup/optaplanner/pull/882#pullrequestreview-466877870", "createdAt": "2020-08-13T15:32:42Z", "commit": {"oid": "5097fdb32bcb6e8d4087f24084b61384bb35cc2a"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozMjo0MlrOHAQ_9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTo0MzowMFrOHARatQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0MDU2Nw==", "bodyText": "Missing @Override.", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r470040567", "createdAt": "2020-08-13T15:32:42Z", "author": {"login": "yurloc"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/MoveSelectorFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.heuristic.selector.move;\n+\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.move.MoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.composite.CartesianProductMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.composite.UnionMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.factory.MoveIteratorFactoryConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.factory.MoveListFactoryConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.ChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.PillarChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.PillarSwapMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.SwapMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.chained.KOptMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.chained.SubChainChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.chained.SubChainSwapMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.chained.TailChainSwapMoveSelectorConfig;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+import org.optaplanner.core.impl.heuristic.selector.move.composite.CartesianProductMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.composite.UnionMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.factory.MoveIteratorFactoryFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.factory.MoveListFactoryFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.ChangeMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.PillarChangeMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.PillarSwapMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.SwapMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.chained.KOptMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.chained.SubChainChangeMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.chained.SubChainSwapMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.chained.TailChainSwapMoveSelectorFactory;\n+\n+public interface MoveSelectorFactory {\n+\n+    static MoveSelectorFactory get(MoveSelectorConfig<?> moveSelectorConfig) {\n+        if (ChangeMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new ChangeMoveSelectorFactory((ChangeMoveSelectorConfig) moveSelectorConfig);\n+        } else if (SwapMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new SwapMoveSelectorFactory((SwapMoveSelectorConfig) moveSelectorConfig);\n+        } else if (PillarChangeMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new PillarChangeMoveSelectorFactory((PillarChangeMoveSelectorConfig) moveSelectorConfig);\n+        } else if (PillarSwapMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new PillarSwapMoveSelectorFactory((PillarSwapMoveSelectorConfig) moveSelectorConfig);\n+        } else if (UnionMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new UnionMoveSelectorFactory((UnionMoveSelectorConfig) moveSelectorConfig);\n+        } else if (CartesianProductMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new CartesianProductMoveSelectorFactory((CartesianProductMoveSelectorConfig) moveSelectorConfig);\n+        } else if (SubChainChangeMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new SubChainChangeMoveSelectorFactory((SubChainChangeMoveSelectorConfig) moveSelectorConfig);\n+        } else if (SubChainSwapMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new SubChainSwapMoveSelectorFactory((SubChainSwapMoveSelectorConfig) moveSelectorConfig);\n+        } else if (TailChainSwapMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new TailChainSwapMoveSelectorFactory((TailChainSwapMoveSelectorConfig) moveSelectorConfig);\n+        } else if (MoveIteratorFactoryConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new MoveIteratorFactoryFactory((MoveIteratorFactoryConfig) moveSelectorConfig);\n+        } else if (MoveListFactoryConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new MoveListFactoryFactory((MoveListFactoryConfig) moveSelectorConfig);\n+        } else if (KOptMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new KOptMoveSelectorFactory((KOptMoveSelectorConfig) moveSelectorConfig);\n+        } else {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Unknown MoveSelectorConfig type: (%s).\", moveSelectorConfig.getClass().getName()));\n+        }\n+    }\n+\n+    /**\n+     * Builds {@link MoveSelector} from the {@link MoveSelectorConfig} and provided parameters.\n+     * \n+     * @param configPolicy never null\n+     * @param minimumCacheType never null, If caching is used (different from {@link SelectionCacheType#JUST_IN_TIME}),\n+     *        then it should be at least this {@link SelectionCacheType} because an ancestor already uses such caching\n+     *        and less would be pointless.\n+     * @param inheritedSelectionOrder never null\n+     * @return never null\n+     */\n+    MoveSelector buildMoveSelector(HeuristicConfigPolicy configPolicy, SelectionCacheType minimumCacheType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5097fdb32bcb6e8d4087f24084b61384bb35cc2a"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0MTAyOA==", "bodyText": "I didn't notice it in the previous PR but this should be called create() for consistency with SolverFactory.", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r470041028", "createdAt": "2020-08-13T15:33:25Z", "author": {"login": "yurloc"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/MoveSelectorFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.heuristic.selector.move;\n+\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.move.MoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.composite.CartesianProductMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.composite.UnionMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.factory.MoveIteratorFactoryConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.factory.MoveListFactoryConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.ChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.PillarChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.PillarSwapMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.SwapMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.chained.KOptMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.chained.SubChainChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.chained.SubChainSwapMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.chained.TailChainSwapMoveSelectorConfig;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+import org.optaplanner.core.impl.heuristic.selector.move.composite.CartesianProductMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.composite.UnionMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.factory.MoveIteratorFactoryFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.factory.MoveListFactoryFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.ChangeMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.PillarChangeMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.PillarSwapMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.SwapMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.chained.KOptMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.chained.SubChainChangeMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.chained.SubChainSwapMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.chained.TailChainSwapMoveSelectorFactory;\n+\n+public interface MoveSelectorFactory {\n+\n+    static MoveSelectorFactory get(MoveSelectorConfig<?> moveSelectorConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5097fdb32bcb6e8d4087f24084b61384bb35cc2a"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0NzQxMw==", "bodyText": "TODO improve this method in the next PR (I can do that).\n\nAdd a zero-arg method instead of checking whether the argument is null.\nMaybe access entityDescriptorMap directly.", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r470047413", "createdAt": "2020-08-13T15:43:00Z", "author": {"login": "yurloc"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/solution/descriptor/SolutionDescriptor.java", "diffHunk": "@@ -727,6 +727,32 @@ public ScoreDefinition getScoreDefinition() {\n     // Model methods\n     // ************************************************************************\n \n+    public EntityDescriptor deduceEntityDescriptor(Class<?> entityClass) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5097fdb32bcb6e8d4087f24084b61384bb35cc2a"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "274d198ad020bb07ed2b34008d976d30f711b3c0", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/274d198ad020bb07ed2b34008d976d30f711b3c0", "committedDate": "2020-08-17T07:38:20Z", "message": "Rename factory methods to 'create'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afa736f7b64a74298234b324ed8e35314870105a", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/afa736f7b64a74298234b324ed8e35314870105a", "committedDate": "2020-08-17T07:45:45Z", "message": "Add missing override annotation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MzQ3MTky", "url": "https://github.com/kiegroup/optaplanner/pull/882#pullrequestreview-468347192", "createdAt": "2020-08-17T10:29:20Z", "commit": {"oid": "afa736f7b64a74298234b324ed8e35314870105a"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxMDoyOToyMFrOHBjNGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxMDo1MDozNlrOHBj3Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4NzQxNw==", "bodyText": "This method, it's actually two methods. One accepts the argument, the other doesn't need it. Let's do it like that.", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r471387417", "createdAt": "2020-08-17T10:29:20Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/entity/descriptor/EntityDescriptor.java", "diffHunk": "@@ -516,6 +516,58 @@ public boolean hasAnyChainedGenuineVariables() {\n         return false;\n     }\n \n+    public GenuineVariableDescriptor deduceVariableDescriptor(String variableName) {\n+        GenuineVariableDescriptor<Solution_> variableDescriptor;\n+        if (variableName != null) {\n+            variableDescriptor = getGenuineVariableDescriptor(variableName);\n+            if (variableDescriptor == null) {\n+                throw new IllegalArgumentException(\"The config (\" + this\n+                        + \") has a variableName (\" + variableName\n+                        + \") which is not a valid planning variable on entityClass (\"\n+                        + getEntityClass() + \").\\n\"\n+                        + buildInvalidVariableNameExceptionMessage(variableName));\n+            }\n+        } else {\n+            Collection<GenuineVariableDescriptor<Solution_>> variableDescriptors = getGenuineVariableDescriptors();\n+            if (variableDescriptors.size() != 1) {\n+                throw new IllegalArgumentException(\"The config (\" + this\n+                        + \") has no configured variableName (\" + variableName\n+                        + \") for entityClass (\" + getEntityClass()\n+                        + \") and because there are multiple variableNames (\"\n+                        + getGenuineVariableNameSet()\n+                        + \"), it cannot be deduced automatically.\");\n+            }\n+            variableDescriptor = variableDescriptors.iterator().next();\n+        }\n+        return variableDescriptor;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afa736f7b64a74298234b324ed8e35314870105a"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4Nzk0MQ==", "bodyText": "I'd prefer a no-arg overload to just putting null here.", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r471387941", "createdAt": "2020-08-17T10:30:07Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/entity/descriptor/EntityDescriptor.java", "diffHunk": "@@ -516,6 +516,58 @@ public boolean hasAnyChainedGenuineVariables() {\n         return false;\n     }\n \n+    public GenuineVariableDescriptor deduceVariableDescriptor(String variableName) {\n+        GenuineVariableDescriptor<Solution_> variableDescriptor;\n+        if (variableName != null) {\n+            variableDescriptor = getGenuineVariableDescriptor(variableName);\n+            if (variableDescriptor == null) {\n+                throw new IllegalArgumentException(\"The config (\" + this\n+                        + \") has a variableName (\" + variableName\n+                        + \") which is not a valid planning variable on entityClass (\"\n+                        + getEntityClass() + \").\\n\"\n+                        + buildInvalidVariableNameExceptionMessage(variableName));\n+            }\n+        } else {\n+            Collection<GenuineVariableDescriptor<Solution_>> variableDescriptors = getGenuineVariableDescriptors();\n+            if (variableDescriptors.size() != 1) {\n+                throw new IllegalArgumentException(\"The config (\" + this\n+                        + \") has no configured variableName (\" + variableName\n+                        + \") for entityClass (\" + getEntityClass()\n+                        + \") and because there are multiple variableNames (\"\n+                        + getGenuineVariableNameSet()\n+                        + \"), it cannot be deduced automatically.\");\n+            }\n+            variableDescriptor = variableDescriptors.iterator().next();\n+        }\n+        return variableDescriptor;\n+    }\n+\n+    public List<GenuineVariableDescriptor<Solution_>> deduceVariableDescriptorList(List<String> variableNameIncludeList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afa736f7b64a74298234b324ed8e35314870105a"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4ODM3Nw==", "bodyText": "Same comment on the entityClass nullity. This is two methods masquerading as one.", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r471388377", "createdAt": "2020-08-17T10:30:58Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/solution/descriptor/SolutionDescriptor.java", "diffHunk": "@@ -727,6 +727,32 @@ public ScoreDefinition getScoreDefinition() {\n     // Model methods\n     // ************************************************************************\n \n+    public EntityDescriptor deduceEntityDescriptor(Class<?> entityClass) {\n+        EntityDescriptor<Solution_> entityDescriptor;\n+        if (entityClass != null) {\n+            entityDescriptor = getEntityDescriptorStrict(entityClass);\n+            if (entityDescriptor == null) {\n+                throw new IllegalArgumentException(\"The config (\" + this\n+                        + \") has an entityClass (\" + entityClass + \") that is not a known planning entity.\\n\"\n+                        + \"Check your solver configuration. If that class (\" + entityClass.getSimpleName()\n+                        + \") is not in the entityClassSet (\" + getEntityClassSet()\n+                        + \"), check your \" + PlanningSolution.class.getSimpleName()\n+                        + \" implementation's annotated methods too.\");\n+            }\n+        } else {\n+            Collection<EntityDescriptor<Solution_>> entityDescriptors = getGenuineEntityDescriptors();\n+            if (entityDescriptors.size() != 1) {\n+                throw new IllegalArgumentException(\"The config (\" + this\n+                        + \") has no entityClass (\" + entityClass\n+                        + \") configured and because there are multiple in the entityClassSet (\"\n+                        + getEntityClassSet()\n+                        + \"), it cannot be deduced automatically.\");\n+            }\n+            entityDescriptor = entityDescriptors.iterator().next();\n+        }\n+        return entityDescriptor;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afa736f7b64a74298234b324ed8e35314870105a"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM5ODIxMQ==", "bodyText": "Is this what the code formatter does? Pretty sure it fits on one 120-char line.", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r471398211", "createdAt": "2020-08-17T10:50:36Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/heuristic/selector/move/MoveSelectorFactoryTest.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.heuristic.selector.move;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+\n+import java.util.Comparator;\n+\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.core.api.score.director.ScoreDirector;\n+import org.optaplanner.core.config.heuristic.selector.AbstractSelectorConfigTest;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.common.decorator.SelectionSorterOrder;\n+import org.optaplanner.core.config.heuristic.selector.move.MoveSelectorConfig;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+import org.optaplanner.core.impl.heuristic.move.DummyMove;\n+import org.optaplanner.core.impl.heuristic.selector.SelectorTestUtils;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionProbabilityWeightFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.decorator.CachingMoveSelector;\n+import org.optaplanner.core.impl.heuristic.selector.move.decorator.ProbabilityMoveSelector;\n+import org.optaplanner.core.impl.heuristic.selector.move.decorator.ShufflingMoveSelector;\n+import org.optaplanner.core.impl.heuristic.selector.move.decorator.SortingMoveSelector;\n+import org.optaplanner.core.impl.testdata.domain.TestdataSolution;\n+\n+class MoveSelectorFactoryTest extends AbstractSelectorConfigTest {\n+\n+    @Test\n+    void phaseOriginal() {\n+        final MoveSelector baseMoveSelector = SelectorTestUtils.mockMoveSelector(DummyMove.class);\n+        DummyMoveSelectorConfig moveSelectorConfig = new DummyMoveSelectorConfig();\n+        moveSelectorConfig.setCacheType(SelectionCacheType.PHASE);\n+        moveSelectorConfig.setSelectionOrder(SelectionOrder.ORIGINAL);\n+        MoveSelectorFactory moveSelectorFactory =\n+                new AssertingMoveSelectorFactory(moveSelectorConfig, baseMoveSelector, SelectionCacheType.PHASE, false);\n+        MoveSelector moveSelector = moveSelectorFactory.buildMoveSelector(\n+                buildHeuristicConfigPolicy(),\n+                SelectionCacheType.JUST_IN_TIME, SelectionOrder.RANDOM);\n+        assertThat(moveSelector)\n+                .isInstanceOf(CachingMoveSelector.class)\n+                .isNotInstanceOf(ShufflingMoveSelector.class);\n+        assertThat(moveSelector.getCacheType()).isEqualTo(SelectionCacheType.PHASE);\n+        assertThat(((CachingMoveSelector) moveSelector).getChildMoveSelector()).isSameAs(baseMoveSelector);\n+    }\n+\n+    @Test\n+    void stepOriginal() {\n+        final MoveSelector baseMoveSelector = SelectorTestUtils.mockMoveSelector(DummyMove.class);\n+        DummyMoveSelectorConfig moveSelectorConfig = new DummyMoveSelectorConfig();\n+        moveSelectorConfig.setCacheType(SelectionCacheType.STEP);\n+        moveSelectorConfig.setSelectionOrder(SelectionOrder.ORIGINAL);\n+        MoveSelectorFactory moveSelectorFactory =\n+                new AssertingMoveSelectorFactory(moveSelectorConfig, baseMoveSelector, SelectionCacheType.STEP, false);\n+        MoveSelector moveSelector = moveSelectorFactory.buildMoveSelector(\n+                buildHeuristicConfigPolicy(),\n+                SelectionCacheType.JUST_IN_TIME, SelectionOrder.RANDOM);\n+        assertThat(moveSelector)\n+                .isInstanceOf(CachingMoveSelector.class)\n+                .isNotInstanceOf(ShufflingMoveSelector.class);\n+        assertThat(moveSelector.getCacheType()).isEqualTo(SelectionCacheType.STEP);\n+        assertThat(((CachingMoveSelector) moveSelector).getChildMoveSelector()).isSameAs(baseMoveSelector);\n+    }\n+\n+    @Test\n+    void justInTimeOriginal() {\n+        final MoveSelector baseMoveSelector = SelectorTestUtils.mockMoveSelector(DummyMove.class);\n+        DummyMoveSelectorConfig moveSelectorConfig = new DummyMoveSelectorConfig();\n+        MoveSelectorFactory moveSelectorFactory =\n+                new AssertingMoveSelectorFactory(moveSelectorConfig, baseMoveSelector, SelectionCacheType.JUST_IN_TIME, false);\n+        moveSelectorConfig.setCacheType(SelectionCacheType.JUST_IN_TIME);\n+        moveSelectorConfig.setSelectionOrder(SelectionOrder.ORIGINAL);\n+        MoveSelector moveSelector = moveSelectorFactory.buildMoveSelector(\n+                buildHeuristicConfigPolicy(),\n+                SelectionCacheType.JUST_IN_TIME, SelectionOrder.RANDOM);\n+        assertThat(moveSelector).isSameAs(baseMoveSelector);\n+        assertThat(moveSelector.getCacheType()).isEqualTo(SelectionCacheType.JUST_IN_TIME);\n+    }\n+\n+    @Test\n+    void phaseRandom() {\n+        final MoveSelector baseMoveSelector = SelectorTestUtils.mockMoveSelector(DummyMove.class);\n+        DummyMoveSelectorConfig moveSelectorConfig = new DummyMoveSelectorConfig();\n+        MoveSelectorFactory moveSelectorFactory =\n+                new AssertingMoveSelectorFactory(moveSelectorConfig, baseMoveSelector, SelectionCacheType.PHASE, false);\n+        moveSelectorConfig.setCacheType(SelectionCacheType.PHASE);\n+        moveSelectorConfig.setSelectionOrder(SelectionOrder.RANDOM);\n+        MoveSelector moveSelector = moveSelectorFactory.buildMoveSelector(\n+                buildHeuristicConfigPolicy(),\n+                SelectionCacheType.JUST_IN_TIME, SelectionOrder.RANDOM);\n+        assertThat(moveSelector)\n+                .isInstanceOf(CachingMoveSelector.class)\n+                .isNotInstanceOf(ShufflingMoveSelector.class);\n+        assertThat(moveSelector.getCacheType()).isEqualTo(SelectionCacheType.PHASE);\n+        assertThat(((CachingMoveSelector) moveSelector).getChildMoveSelector()).isSameAs(baseMoveSelector);\n+    }\n+\n+    @Test\n+    void stepRandom() {\n+        final MoveSelector baseMoveSelector = SelectorTestUtils.mockMoveSelector(DummyMove.class);\n+        DummyMoveSelectorConfig moveSelectorConfig = new DummyMoveSelectorConfig();\n+        MoveSelectorFactory moveSelectorFactory =\n+                new AssertingMoveSelectorFactory(moveSelectorConfig, baseMoveSelector, SelectionCacheType.STEP, false);\n+        moveSelectorConfig.setCacheType(SelectionCacheType.STEP);\n+        moveSelectorConfig.setSelectionOrder(SelectionOrder.RANDOM);\n+        MoveSelector moveSelector = moveSelectorFactory.buildMoveSelector(\n+                buildHeuristicConfigPolicy(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afa736f7b64a74298234b324ed8e35314870105a"}, "originalPosition": 121}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ae37830016d33b223e63104652f31d77bf6a407", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/0ae37830016d33b223e63104652f31d77bf6a407", "committedDate": "2020-08-17T11:08:32Z", "message": "Reformat the MoveSelectorFactoryTest"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3400, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}