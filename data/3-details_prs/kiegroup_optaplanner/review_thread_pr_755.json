{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4MDA3ODYy", "number": 755, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTo0NjoxMFrOD1V_ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjo0Mzo1MlrOD1wZBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MjYxNDEyOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTo0NjoxMFrOGKvG-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTo0NjoxMFrOGKvG-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkxMDc3Nw==", "bodyText": "Let's not merge this monstrosity. I have it stored for my own use.", "url": "https://github.com/kiegroup/optaplanner/pull/755#discussion_r413910777", "createdAt": "2020-04-23T15:46:10Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -145,74 +158,121 @@ private Constraint transientUsage(ConstraintFactory factory) {\n     /**\n      * Load: The safety capacity for each resource for each machine should not be exceeded.\n      */\n-    private Constraint loadCost(ConstraintFactory factory) {\n+    protected Constraint loadCost(ConstraintFactory factory) {\n         return factory.from(MrMachineCapacity.class)\n                 .join(MrProcessAssignment.class,\n-                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-                )\n+                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine))\n                 .groupBy((machineCapacity, processAssignment) -> machineCapacity,\n-                        sumLong((machineCapacity, processAssignment) ->\n-                                processAssignment.getUsage(machineCapacity.getResource()))\n-                )\n+                        sumLong((machineCapacity, processAssignment) -> processAssignment\n+                                .getUsage(machineCapacity.getResource())))\n                 .filter(((machineCapacity, usage) -> machineCapacity.getSafetyCapacity() < usage))\n                 .penalizeLong(MrConstraints.LOAD_COST,\n                         HardSoftLongScore.ONE_SOFT,\n-                        (machineCapacity, usage) -> usage - machineCapacity.getSafetyCapacity());\n+                        (machineCapacity, usage) -> machineCapacity.getResource().getLoadCostWeight()\n+                                * (usage - machineCapacity.getSafetyCapacity()));\n     }\n \n     /**\n      * availability(r) = capacity(m, r) - usage(m, r)\n      * balanceCost = sum(max(0, multiplier * availability(m, r1) - availability(m, r2)))\n      */\n-    private Constraint balanceCost(ConstraintFactory factory) {\n-        return factory.from(MrBalancePenalty.class)\n-                .join(MrProcessAssignment.class)\n-                .groupBy((penalty, processAssignment) -> penalty, (penalty, processAssignment) -> processAssignment.getMachine(),\n-                        sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getOriginResource())),\n-                        sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getTargetResource()))\n-                )\n-                .penalizeLong(MrConstraints.BALANCE_COST, HardSoftLongScore.ONE_SOFT, this::balanceCost);\n+    protected Constraint balanceCost(ConstraintFactory factory) {\n+        throw new UnsupportedOperationException(\"Not yet implemented.\");\n+        /*\n+         * return factory.from(MrMachineCapacity.class)\n+         * .join(MrProcessAssignment.class,\n+         * equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n+         * )\n+         * .groupBy((machineCapacity, processAssignment) -> new ImmutablePair<MrMachine,\n+         * MrResource>(machineCapacity.getMachine(), machineCapacity.getResource()),\n+         * sumLong((machineCapacity, processAssignment) -> machineCapacity.getMaximumCapacity() - getUsage(processAssignment,\n+         * machineCapacity.getResource()))\n+         * )\n+         * .filter((pair, originAvailability) -> {\n+         * System.out.println(pair + \", \" + originAvailability);\n+         * return true;\n+         * })\n+         * .join(MrBalancePenalty.class,\n+         * equal((pair, availability) -> pair.getRight(), penalty -> penalty.getOriginResource())\n+         * )\n+         * .join(MrMachineCapacity.class, // for the same machine and the other - target resource\n+         * equal((pair, availability, penalty) -> pair.getLeft(), capacity -> capacity.getMachine()),\n+         * equal((pair, availability, penalty) -> penalty.getTargetResource(), capacity -> capacity.getResource())\n+         * )\n+         * .filter((pair, originAvailability, penalty, targetCapacity) -> {\n+         * System.out.println(pair + \", \" + originAvailability + \", \" + penalty + \", \" + targetCapacity);\n+         * return true;\n+         * })\n+         * .groupBy((pair, availability, penalty, targetCapacity) -> new ImmutableTriple<MrMachine, MrResource,\n+         * Long>(pair.getLeft(), pair.getRight(), availability),\n+         * (pair, availability, penalty, targetCapacity) -> new ImmutablePair<MrBalancePenalty, MrMachineCapacity>(penalty,\n+         * targetCapacity)\n+         * )\n+         * .filter((triple, pair) -> {\n+         * System.out.println(triple + \", \" + pair);\n+         * return true;\n+         * })\n+         * .join(MrProcessAssignment.class,\n+         * equal((triple, pair) -> pair.getRight().getMachine(), MrProcessAssignment::getMachine))\n+         * .groupBy((triple, pair, processAssignment) -> triple,\n+         * (triple, pair, processAssignment) -> pair, // TODO: it should be groupedBy Resource\n+         * // get the target availability\n+         * sumLong((triple, pair, processAssignment) -> pair.getRight().getMaximumCapacity() - getUsage(processAssignment,\n+         * pair.getRight().getResource()))\n+         * )\n+         * .filter((originTriple, pair, targetAvailability) -> originTriple.right > 0 && targetAvailability <\n+         * pair.left.getMultiplicand() * originTriple.right)\n+         * .penalizeLong(MrConstraints.BALANCE_COST, HardSoftLongScore.ONE_SOFT, (originTriple, pair, targetAvailability) -> {\n+         * System.out.println(originTriple + \", \" + pair + \", \" + targetAvailability);\n+         * return (targetAvailability - pair.left.getMultiplicand() * originTriple.right) * pair.left.getWeight();\n+         * });\n+         */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83164a3674e6c25f2ed5eb5a7f8cafa9aaa8781b"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MjYxNTQ2OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTo0NjoyNVrOGKvH0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTo0NjoyNVrOGKvH0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkxMDk5NQ==", "bodyText": "Again, let's remove this.", "url": "https://github.com/kiegroup/optaplanner/pull/755#discussion_r413910995", "createdAt": "2020-04-23T15:46:25Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -145,74 +158,121 @@ private Constraint transientUsage(ConstraintFactory factory) {\n     /**\n      * Load: The safety capacity for each resource for each machine should not be exceeded.\n      */\n-    private Constraint loadCost(ConstraintFactory factory) {\n+    protected Constraint loadCost(ConstraintFactory factory) {\n         return factory.from(MrMachineCapacity.class)\n                 .join(MrProcessAssignment.class,\n-                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-                )\n+                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine))\n                 .groupBy((machineCapacity, processAssignment) -> machineCapacity,\n-                        sumLong((machineCapacity, processAssignment) ->\n-                                processAssignment.getUsage(machineCapacity.getResource()))\n-                )\n+                        sumLong((machineCapacity, processAssignment) -> processAssignment\n+                                .getUsage(machineCapacity.getResource())))\n                 .filter(((machineCapacity, usage) -> machineCapacity.getSafetyCapacity() < usage))\n                 .penalizeLong(MrConstraints.LOAD_COST,\n                         HardSoftLongScore.ONE_SOFT,\n-                        (machineCapacity, usage) -> usage - machineCapacity.getSafetyCapacity());\n+                        (machineCapacity, usage) -> machineCapacity.getResource().getLoadCostWeight()\n+                                * (usage - machineCapacity.getSafetyCapacity()));\n     }\n \n     /**\n      * availability(r) = capacity(m, r) - usage(m, r)\n      * balanceCost = sum(max(0, multiplier * availability(m, r1) - availability(m, r2)))\n      */\n-    private Constraint balanceCost(ConstraintFactory factory) {\n-        return factory.from(MrBalancePenalty.class)\n-                .join(MrProcessAssignment.class)\n-                .groupBy((penalty, processAssignment) -> penalty, (penalty, processAssignment) -> processAssignment.getMachine(),\n-                        sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getOriginResource())),\n-                        sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getTargetResource()))\n-                )\n-                .penalizeLong(MrConstraints.BALANCE_COST, HardSoftLongScore.ONE_SOFT, this::balanceCost);\n+    protected Constraint balanceCost(ConstraintFactory factory) {\n+        throw new UnsupportedOperationException(\"Not yet implemented.\");\n+        /*\n+         * return factory.from(MrMachineCapacity.class)\n+         * .join(MrProcessAssignment.class,\n+         * equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n+         * )\n+         * .groupBy((machineCapacity, processAssignment) -> new ImmutablePair<MrMachine,\n+         * MrResource>(machineCapacity.getMachine(), machineCapacity.getResource()),\n+         * sumLong((machineCapacity, processAssignment) -> machineCapacity.getMaximumCapacity() - getUsage(processAssignment,\n+         * machineCapacity.getResource()))\n+         * )\n+         * .filter((pair, originAvailability) -> {\n+         * System.out.println(pair + \", \" + originAvailability);\n+         * return true;\n+         * })\n+         * .join(MrBalancePenalty.class,\n+         * equal((pair, availability) -> pair.getRight(), penalty -> penalty.getOriginResource())\n+         * )\n+         * .join(MrMachineCapacity.class, // for the same machine and the other - target resource\n+         * equal((pair, availability, penalty) -> pair.getLeft(), capacity -> capacity.getMachine()),\n+         * equal((pair, availability, penalty) -> penalty.getTargetResource(), capacity -> capacity.getResource())\n+         * )\n+         * .filter((pair, originAvailability, penalty, targetCapacity) -> {\n+         * System.out.println(pair + \", \" + originAvailability + \", \" + penalty + \", \" + targetCapacity);\n+         * return true;\n+         * })\n+         * .groupBy((pair, availability, penalty, targetCapacity) -> new ImmutableTriple<MrMachine, MrResource,\n+         * Long>(pair.getLeft(), pair.getRight(), availability),\n+         * (pair, availability, penalty, targetCapacity) -> new ImmutablePair<MrBalancePenalty, MrMachineCapacity>(penalty,\n+         * targetCapacity)\n+         * )\n+         * .filter((triple, pair) -> {\n+         * System.out.println(triple + \", \" + pair);\n+         * return true;\n+         * })\n+         * .join(MrProcessAssignment.class,\n+         * equal((triple, pair) -> pair.getRight().getMachine(), MrProcessAssignment::getMachine))\n+         * .groupBy((triple, pair, processAssignment) -> triple,\n+         * (triple, pair, processAssignment) -> pair, // TODO: it should be groupedBy Resource\n+         * // get the target availability\n+         * sumLong((triple, pair, processAssignment) -> pair.getRight().getMaximumCapacity() - getUsage(processAssignment,\n+         * pair.getRight().getResource()))\n+         * )\n+         * .filter((originTriple, pair, targetAvailability) -> originTriple.right > 0 && targetAvailability <\n+         * pair.left.getMultiplicand() * originTriple.right)\n+         * .penalizeLong(MrConstraints.BALANCE_COST, HardSoftLongScore.ONE_SOFT, (originTriple, pair, targetAvailability) -> {\n+         * System.out.println(originTriple + \", \" + pair + \", \" + targetAvailability);\n+         * return (targetAvailability - pair.left.getMultiplicand() * originTriple.right) * pair.left.getWeight();\n+         * });\n+         */\n     }\n \n-    private long balanceCost(MrBalancePenalty penalty, MrMachine machine, long originalUsage, long targetUsage) {\n-        long originalAvailability =\n-                machine.getMachineCapacity(penalty.getOriginResource()).getMaximumCapacity() - originalUsage;\n-        long targetAvailability =\n-                machine.getMachineCapacity(penalty.getTargetResource()).getMaximumCapacity() - targetUsage;\n-        long balanceCost = penalty.getMultiplicand() * originalAvailability - targetAvailability;\n-        return Math.max(0, balanceCost);\n+    private long getUsage(MrProcessAssignment processAssignment, MrResource resource) {\n+        // System.out.println(String.format(\"Usage of resource %d by a process %s is: %d\",\n+        //         resource.getIndex(), processAssignment.getProcess(), processAssignment.getUsage(resource)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83164a3674e6c25f2ed5eb5a7f8cafa9aaa8781b"}, "originalPosition": 272}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MjYxNjIwOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTo0NjozNFrOGKvIRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTo0OTozM1rOGKvRLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkxMTExMQ==", "bodyText": "\"Interesting\" behavior of the eclipse formatter: the block comment has leading asterisk on each line. As a result, IDE cannot automatically uncomment such a block.", "url": "https://github.com/kiegroup/optaplanner/pull/755#discussion_r413911111", "createdAt": "2020-04-23T15:46:34Z", "author": {"login": "rsynek"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -145,74 +158,121 @@ private Constraint transientUsage(ConstraintFactory factory) {\n     /**\n      * Load: The safety capacity for each resource for each machine should not be exceeded.\n      */\n-    private Constraint loadCost(ConstraintFactory factory) {\n+    protected Constraint loadCost(ConstraintFactory factory) {\n         return factory.from(MrMachineCapacity.class)\n                 .join(MrProcessAssignment.class,\n-                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-                )\n+                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine))\n                 .groupBy((machineCapacity, processAssignment) -> machineCapacity,\n-                        sumLong((machineCapacity, processAssignment) ->\n-                                processAssignment.getUsage(machineCapacity.getResource()))\n-                )\n+                        sumLong((machineCapacity, processAssignment) -> processAssignment\n+                                .getUsage(machineCapacity.getResource())))\n                 .filter(((machineCapacity, usage) -> machineCapacity.getSafetyCapacity() < usage))\n                 .penalizeLong(MrConstraints.LOAD_COST,\n                         HardSoftLongScore.ONE_SOFT,\n-                        (machineCapacity, usage) -> usage - machineCapacity.getSafetyCapacity());\n+                        (machineCapacity, usage) -> machineCapacity.getResource().getLoadCostWeight()\n+                                * (usage - machineCapacity.getSafetyCapacity()));\n     }\n \n     /**\n      * availability(r) = capacity(m, r) - usage(m, r)\n      * balanceCost = sum(max(0, multiplier * availability(m, r1) - availability(m, r2)))\n      */\n-    private Constraint balanceCost(ConstraintFactory factory) {\n-        return factory.from(MrBalancePenalty.class)\n-                .join(MrProcessAssignment.class)\n-                .groupBy((penalty, processAssignment) -> penalty, (penalty, processAssignment) -> processAssignment.getMachine(),\n-                        sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getOriginResource())),\n-                        sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getTargetResource()))\n-                )\n-                .penalizeLong(MrConstraints.BALANCE_COST, HardSoftLongScore.ONE_SOFT, this::balanceCost);\n+    protected Constraint balanceCost(ConstraintFactory factory) {\n+        throw new UnsupportedOperationException(\"Not yet implemented.\");\n+        /*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83164a3674e6c25f2ed5eb5a7f8cafa9aaa8781b"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkxMzM5MA==", "bodyText": "Maybe that's fixable?", "url": "https://github.com/kiegroup/optaplanner/pull/755#discussion_r413913390", "createdAt": "2020-04-23T15:49:33Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -145,74 +158,121 @@ private Constraint transientUsage(ConstraintFactory factory) {\n     /**\n      * Load: The safety capacity for each resource for each machine should not be exceeded.\n      */\n-    private Constraint loadCost(ConstraintFactory factory) {\n+    protected Constraint loadCost(ConstraintFactory factory) {\n         return factory.from(MrMachineCapacity.class)\n                 .join(MrProcessAssignment.class,\n-                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-                )\n+                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine))\n                 .groupBy((machineCapacity, processAssignment) -> machineCapacity,\n-                        sumLong((machineCapacity, processAssignment) ->\n-                                processAssignment.getUsage(machineCapacity.getResource()))\n-                )\n+                        sumLong((machineCapacity, processAssignment) -> processAssignment\n+                                .getUsage(machineCapacity.getResource())))\n                 .filter(((machineCapacity, usage) -> machineCapacity.getSafetyCapacity() < usage))\n                 .penalizeLong(MrConstraints.LOAD_COST,\n                         HardSoftLongScore.ONE_SOFT,\n-                        (machineCapacity, usage) -> usage - machineCapacity.getSafetyCapacity());\n+                        (machineCapacity, usage) -> machineCapacity.getResource().getLoadCostWeight()\n+                                * (usage - machineCapacity.getSafetyCapacity()));\n     }\n \n     /**\n      * availability(r) = capacity(m, r) - usage(m, r)\n      * balanceCost = sum(max(0, multiplier * availability(m, r1) - availability(m, r2)))\n      */\n-    private Constraint balanceCost(ConstraintFactory factory) {\n-        return factory.from(MrBalancePenalty.class)\n-                .join(MrProcessAssignment.class)\n-                .groupBy((penalty, processAssignment) -> penalty, (penalty, processAssignment) -> processAssignment.getMachine(),\n-                        sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getOriginResource())),\n-                        sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getTargetResource()))\n-                )\n-                .penalizeLong(MrConstraints.BALANCE_COST, HardSoftLongScore.ONE_SOFT, this::balanceCost);\n+    protected Constraint balanceCost(ConstraintFactory factory) {\n+        throw new UnsupportedOperationException(\"Not yet implemented.\");\n+        /*", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkxMTExMQ=="}, "originalCommit": {"oid": "83164a3674e6c25f2ed5eb5a7f8cafa9aaa8781b"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MjYxOTg0OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTo0NzoyMlrOGKvKrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTo0NzoyMlrOGKvKrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkxMTcyNg==", "bodyText": "I'd rather not confuse readers with this.", "url": "https://github.com/kiegroup/optaplanner/pull/755#discussion_r413911726", "createdAt": "2020-04-23T15:47:22Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -61,58 +63,72 @@\n     /**\n      * Maximum capacity: The maximum capacity for each resource for each machine must not be exceeded.\n      */\n-    private Constraint maximumCapacity(ConstraintFactory factory) {\n+    protected Constraint maximumCapacity(ConstraintFactory factory) {\n         return factory.from(MrMachineCapacity.class)\n                 .join(MrProcessAssignment.class,\n-                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-                )\n-                .groupBy((machineCapacity, processAssignment) -> machineCapacity,\n-                        sumLong((machineCapacity, processAssignment) ->\n-                                processAssignment.getUsage(machineCapacity.getResource()))\n-                )\n-                .filter(((machineCapacity, usage) -> machineCapacity.getMaximumCapacity() < usage))\n+                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine))\n+                .groupBy((machineCapacity, processAssignment) -> machineCapacity.getMachine(),\n+                        (machineCapacity, processAssignment) -> machineCapacity,\n+                        sumLong((machineCapacity, processAssignment) -> processAssignment\n+                                .getUsage(machineCapacity.getResource())))\n+                .filter(((machine, machineCapacity, usage) -> machineCapacity.getMaximumCapacity() < usage))\n                 .penalizeLong(MrConstraints.MAXIMUM_CAPACITY,\n                         HardSoftLongScore.ONE_HARD,\n-                        (machineCapacity, usage) -> usage - machineCapacity.getMaximumCapacity());\n+                        (machine, machineCapacity, usage) -> usage - machineCapacity.getMaximumCapacity());\n     }\n \n-    /**\n-     * Conflict: Processes of the same service must run on distinct machines.\n+    /*\n+     * More elegant solution, which is not compatible with Drools due to uninitialized entities:\n+     *\n+     * protected Constraint serviceConflict(ConstraintFactory factory) {\n+     * return factory.fromUniquePair(MrProcessAssignment.class,\n+     * equal(MrProcessAssignment::getMachine),\n+     * equal(MrProcessAssignment::getService)\n+     * ).penalize(MrConstraints.SERVICE_CONFLICT, HardSoftLongScore.ONE_HARD);\n+     *\n      */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83164a3674e6c25f2ed5eb5a7f8cafa9aaa8781b"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MjkyNDE3OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNjo0ODoyN1rOGKyCLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNzozNDo0NVrOGLKigw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1ODcwMg==", "bodyText": "Which MrProcessAssignment have a null location? The from already filters out all those that doesn't have a machine. Are there machines with a null location? If so, just add a filter before the groupBy.", "url": "https://github.com/kiegroup/optaplanner/pull/755#discussion_r413958702", "createdAt": "2020-04-23T16:48:27Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -61,58 +62,48 @@\n     /**\n      * Maximum capacity: The maximum capacity for each resource for each machine must not be exceeded.\n      */\n-    private Constraint maximumCapacity(ConstraintFactory factory) {\n+    protected Constraint maximumCapacity(ConstraintFactory factory) {\n         return factory.from(MrMachineCapacity.class)\n                 .join(MrProcessAssignment.class,\n-                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-                )\n-                .groupBy((machineCapacity, processAssignment) -> machineCapacity,\n-                        sumLong((machineCapacity, processAssignment) ->\n-                                processAssignment.getUsage(machineCapacity.getResource()))\n-                )\n-                .filter(((machineCapacity, usage) -> machineCapacity.getMaximumCapacity() < usage))\n+                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine))\n+                .groupBy((machineCapacity, processAssignment) -> machineCapacity.getMachine(),\n+                        (machineCapacity, processAssignment) -> machineCapacity,\n+                        sumLong((machineCapacity, processAssignment) -> processAssignment\n+                                .getUsage(machineCapacity.getResource())))\n+                .filter(((machine, machineCapacity, usage) -> machineCapacity.getMaximumCapacity() < usage))\n                 .penalizeLong(MrConstraints.MAXIMUM_CAPACITY,\n                         HardSoftLongScore.ONE_HARD,\n-                        (machineCapacity, usage) -> usage - machineCapacity.getMaximumCapacity());\n+                        (machine, machineCapacity, usage) -> usage - machineCapacity.getMaximumCapacity());\n     }\n \n-    /**\n-     * Conflict: Processes of the same service must run on distinct machines.\n-     */\n-    private Constraint serviceConflict(ConstraintFactory factory) {\n-        return factory.fromUniquePair(MrProcessAssignment.class,\n-                equal(MrProcessAssignment::getMachine),\n-                equal(MrProcessAssignment::getService)\n-        ).penalize(MrConstraints.SERVICE_CONFLICT,\n-                HardSoftLongScore.ONE_HARD);\n+    protected Constraint serviceConflict(ConstraintFactory factory) {\n+        return factory.fromUnfiltered(MrProcessAssignment.class)\n+                .join(factory.fromUnfiltered(MrProcessAssignment.class),\n+                        equal(MrProcessAssignment::getMachine, MrProcessAssignment::getMachine))\n+                .filter((left, right) -> left.getService().equals(right.getService()) && right.getId() > left.getId())\n+                .penalize(MrConstraints.SERVICE_CONFLICT, HardSoftLongScore.ONE_HARD);\n     }\n \n     /**\n      * Spread: Processes of the same service must be serviceLocationSpread out across locations.\n      */\n-    private Constraint serviceLocationSpread(ConstraintFactory factory) {\n-        return factory.from(MrProcessAssignment.class)\n-                .groupBy(MrProcessAssignment::getService,\n-                        ConstraintCollectors.countDistinct(MrProcessAssignment::getLocation))\n-                .filter((service, distinctLocationCount) -> service.getLocationSpread() > distinctLocationCount)\n-                .penalize(MrConstraints.SERVICE_LOCATION_SPREAD,\n-                        HardSoftLongScore.ONE_HARD);\n+    protected Constraint serviceLocationSpread(ConstraintFactory factory) {\n+        throw new UnsupportedOperationException(\"ConstraintCollectors.countDistinct should not count null as a distinct value\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4fb721e766e3e72db09a8a34bd9bfdf1fc6823"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM2MDE5NQ==", "bodyText": "See the discussion on Zulip chat - this is about uninitialized solution and the fact that a DRL score function works differently in such a condition.", "url": "https://github.com/kiegroup/optaplanner/pull/755#discussion_r414360195", "createdAt": "2020-04-24T07:34:45Z", "author": {"login": "rsynek"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -61,58 +62,48 @@\n     /**\n      * Maximum capacity: The maximum capacity for each resource for each machine must not be exceeded.\n      */\n-    private Constraint maximumCapacity(ConstraintFactory factory) {\n+    protected Constraint maximumCapacity(ConstraintFactory factory) {\n         return factory.from(MrMachineCapacity.class)\n                 .join(MrProcessAssignment.class,\n-                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-                )\n-                .groupBy((machineCapacity, processAssignment) -> machineCapacity,\n-                        sumLong((machineCapacity, processAssignment) ->\n-                                processAssignment.getUsage(machineCapacity.getResource()))\n-                )\n-                .filter(((machineCapacity, usage) -> machineCapacity.getMaximumCapacity() < usage))\n+                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine))\n+                .groupBy((machineCapacity, processAssignment) -> machineCapacity.getMachine(),\n+                        (machineCapacity, processAssignment) -> machineCapacity,\n+                        sumLong((machineCapacity, processAssignment) -> processAssignment\n+                                .getUsage(machineCapacity.getResource())))\n+                .filter(((machine, machineCapacity, usage) -> machineCapacity.getMaximumCapacity() < usage))\n                 .penalizeLong(MrConstraints.MAXIMUM_CAPACITY,\n                         HardSoftLongScore.ONE_HARD,\n-                        (machineCapacity, usage) -> usage - machineCapacity.getMaximumCapacity());\n+                        (machine, machineCapacity, usage) -> usage - machineCapacity.getMaximumCapacity());\n     }\n \n-    /**\n-     * Conflict: Processes of the same service must run on distinct machines.\n-     */\n-    private Constraint serviceConflict(ConstraintFactory factory) {\n-        return factory.fromUniquePair(MrProcessAssignment.class,\n-                equal(MrProcessAssignment::getMachine),\n-                equal(MrProcessAssignment::getService)\n-        ).penalize(MrConstraints.SERVICE_CONFLICT,\n-                HardSoftLongScore.ONE_HARD);\n+    protected Constraint serviceConflict(ConstraintFactory factory) {\n+        return factory.fromUnfiltered(MrProcessAssignment.class)\n+                .join(factory.fromUnfiltered(MrProcessAssignment.class),\n+                        equal(MrProcessAssignment::getMachine, MrProcessAssignment::getMachine))\n+                .filter((left, right) -> left.getService().equals(right.getService()) && right.getId() > left.getId())\n+                .penalize(MrConstraints.SERVICE_CONFLICT, HardSoftLongScore.ONE_HARD);\n     }\n \n     /**\n      * Spread: Processes of the same service must be serviceLocationSpread out across locations.\n      */\n-    private Constraint serviceLocationSpread(ConstraintFactory factory) {\n-        return factory.from(MrProcessAssignment.class)\n-                .groupBy(MrProcessAssignment::getService,\n-                        ConstraintCollectors.countDistinct(MrProcessAssignment::getLocation))\n-                .filter((service, distinctLocationCount) -> service.getLocationSpread() > distinctLocationCount)\n-                .penalize(MrConstraints.SERVICE_LOCATION_SPREAD,\n-                        HardSoftLongScore.ONE_HARD);\n+    protected Constraint serviceLocationSpread(ConstraintFactory factory) {\n+        throw new UnsupportedOperationException(\"ConstraintCollectors.countDistinct should not count null as a distinct value\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1ODcwMg=="}, "originalCommit": {"oid": "2a4fb721e766e3e72db09a8a34bd9bfdf1fc6823"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MjkzMDkwOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/test/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProviderTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNjo1MDowNlrOGKyGYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNjo1MDowNlrOGKyGYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1OTc3Ng==", "bodyText": "code style suggestion: this takes up 4 lines for 2 lines of content, typically we just use two // for 2 lines of non-javadoc comments.", "url": "https://github.com/kiegroup/optaplanner/pull/755#discussion_r413959776", "createdAt": "2020-04-23T16:50:06Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-examples/src/test/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProviderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.machinereassignment.solver.score;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.map.HashedMap;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.optaplanner.examples.machinereassignment.domain.MachineReassignment;\n+import org.optaplanner.examples.machinereassignment.domain.MrBalancePenalty;\n+import org.optaplanner.examples.machinereassignment.domain.MrGlobalPenaltyInfo;\n+import org.optaplanner.examples.machinereassignment.domain.MrLocation;\n+import org.optaplanner.examples.machinereassignment.domain.MrMachine;\n+import org.optaplanner.examples.machinereassignment.domain.MrMachineCapacity;\n+import org.optaplanner.examples.machinereassignment.domain.MrNeighborhood;\n+import org.optaplanner.examples.machinereassignment.domain.MrProcess;\n+import org.optaplanner.examples.machinereassignment.domain.MrProcessAssignment;\n+import org.optaplanner.examples.machinereassignment.domain.MrProcessRequirement;\n+import org.optaplanner.examples.machinereassignment.domain.MrResource;\n+import org.optaplanner.examples.machinereassignment.domain.MrService;\n+import org.optaplanner.examples.machinereassignment.domain.solver.MrServiceDependency;\n+import org.optaplanner.test.api.score.stream.ConstraintVerifier;\n+\n+public class MachineReassignmentConstraintProviderTest {\n+\n+    private final ConstraintVerifier<MachineReassignmentConstraintProvider, MachineReassignment> constraintVerifier = ConstraintVerifier\n+            .build(new MachineReassignmentConstraintProvider(), MachineReassignment.class, MrProcessAssignment.class);\n+\n+    @Test\n+    public void maximumCapacity() {\n+        MrResource resource1 = new MrResource(0, false, 1);\n+        MrMachine machine = new MrMachine();\n+        MrProcess process = new MrProcess();\n+        MrProcessRequirement processRequirement = new MrProcessRequirement(process, resource1, 30L);\n+        process.setProcessRequirementList(Arrays.asList(processRequirement));\n+\n+        MrMachineCapacity machineCapacity = new MrMachineCapacity(machine, resource1, 20L, 10L);\n+        MrProcessAssignment processAssignment = new MrProcessAssignment(0L, process, machine, machine);\n+\n+        constraintVerifier.verifyThat(MachineReassignmentConstraintProvider::maximumCapacity)\n+                .given(machineCapacity, machine, process, resource1, processAssignment, processRequirement)\n+                .penalizesBy(10L);\n+    }\n+\n+    @Test\n+    public void transientUsage() {\n+        MrResource normalResource = new MrResource(0, false, 5);\n+        MrResource transientlyConsumerResource = new MrResource(1, true, 10);\n+\n+        MrMachine machine1 = new MrMachine();\n+        MrMachine machine2 = new MrMachine();\n+\n+        MrMachineCapacity machineCapacityNormal = new MrMachineCapacity(machine2, normalResource, 20L, 10L);\n+        MrMachineCapacity machineCapacityTransientlyConsumed = new MrMachineCapacity(machine1,\n+                transientlyConsumerResource, 35L, 30L);\n+\n+        MrProcess process = new MrProcess();\n+        MrProcessRequirement processRequirement1 = new MrProcessRequirement(process, normalResource, 30L);\n+        MrProcessRequirement processRequirement2 = new MrProcessRequirement(process, transientlyConsumerResource, 50L);\n+        process.setProcessRequirementList(Arrays.asList(processRequirement1, processRequirement2));\n+\n+        MrProcessAssignment processAssignment = new MrProcessAssignment(0L, process, machine1, machine2);\n+\n+        constraintVerifier.verifyThat(MachineReassignmentConstraintProvider::transientUsage)\n+                .given(normalResource, transientlyConsumerResource, machine1, machine2, machineCapacityNormal,\n+                        machineCapacityTransientlyConsumed, process, processRequirement1, processRequirement2,\n+                        processAssignment)\n+                .penalizesBy(15L);\n+    }\n+\n+    @Test\n+    public void serviceConflict() {\n+        // 3 of 4 processes of the same service run on the same machine\n+        MrService service = new MrService();\n+\n+        MrMachine machine1 = new MrMachine();\n+        MrMachine machine2 = new MrMachine();\n+\n+        MrProcess process1 = new MrProcess(service);\n+        MrProcess process2 = new MrProcess(service);\n+        MrProcess process3 = new MrProcess(service);\n+        MrProcess process4 = new MrProcess(service);\n+        MrProcess process5 = new MrProcess(service);\n+\n+        MrProcessAssignment process1AssignmentToMachine1 = new MrProcessAssignment(1L, process1, machine1);\n+        MrProcessAssignment process2AssignmentToMachine1 = new MrProcessAssignment(2L, process2, machine1);\n+        MrProcessAssignment process3AssignmentToMachine1 = new MrProcessAssignment(3L, process3, machine1);\n+        MrProcessAssignment process4AssignmentToMachine2 = new MrProcessAssignment(4L, process4, machine2);\n+        MrProcessAssignment process5AssignmentToNoMachine = new MrProcessAssignment(5L, process5);\n+\n+        constraintVerifier.verifyThat(MachineReassignmentConstraintProvider::serviceConflict)\n+                .given(service, machine1, machine2, process1, process2, process3, process4, process1AssignmentToMachine1,\n+                        process2AssignmentToMachine1, process3AssignmentToMachine1, process4AssignmentToMachine2,\n+                        process5AssignmentToNoMachine)\n+                .penalizesBy(3L);\n+    }\n+\n+    @Test\n+    @Ignore(\"The constraint has not been fully implemented yet.\")\n+    public void serviceLocationSpreadWithUnassignedProcess() {\n+        MrLocation location = new MrLocation(0L);\n+\n+        MrMachine machine = new MrMachine(0L, location);\n+\n+        // the service is expected to be spread across at least 5 locations\n+        MrService service = new MrService(0L);\n+        service.setToDependencyServiceList(Collections.emptyList());\n+        service.setLocationSpread(5);\n+\n+        MrProcess process = new MrProcess(0L, service);\n+\n+        // the service is spread across no machines\n+        MrProcessAssignment processAssignment = new MrProcessAssignment(0L, process);\n+\n+        constraintVerifier.verifyThat(MachineReassignmentConstraintProvider::serviceLocationSpread)\n+                .given(service, location, machine, process, processAssignment)\n+                .penalizesBy(5L);\n+    }\n+\n+    @Test\n+    @Ignore(\"The constraint has not been fully implemented yet.\")\n+    public void serviceLocationSpread() {\n+        MrLocation location1 = new MrLocation(1L);\n+        MrLocation location2 = new MrLocation(2L);\n+\n+        MrMachine machine1 = new MrMachine(0L, location1);\n+        MrMachine machine2 = new MrMachine(1L, location2);\n+        MrMachine machine3 = new MrMachine(2L, location2);\n+\n+        // the service is expected to be spread across at least 5 locations\n+        MrService service1 = new MrService();\n+        service1.setLocationSpread(5);\n+\n+        MrProcess process1 = new MrProcess(service1);\n+        MrProcess process2 = new MrProcess(service1);\n+        MrProcess process3 = new MrProcess(service1);\n+\n+        // the service is spread across 3 machines in 2 different locations\n+        MrProcessAssignment process1AssignmentToMachine1 = new MrProcessAssignment(1L, process1, machine1);\n+        MrProcessAssignment process2AssignmentToMachine2 = new MrProcessAssignment(2L, process2, machine2);\n+        MrProcessAssignment process3AssignmentToMachine3 = new MrProcessAssignment(3L, process3, machine3);\n+\n+        constraintVerifier.verifyThat(MachineReassignmentConstraintProvider::serviceLocationSpread)\n+                .given(service1, location1, location2, machine1, machine2, machine3, process1, process2, process3,\n+                        process1AssignmentToMachine1, process2AssignmentToMachine2, process3AssignmentToMachine3)\n+                .penalizesBy(3L); // 5 - 3 (expected - real location spread)\n+    }\n+\n+    @Test\n+    public void serviceDependency() {\n+        MrNeighborhood neighborhood1 = new MrNeighborhood(1L);\n+        MrNeighborhood neighborhood2 = new MrNeighborhood(2L);\n+\n+        MrMachine machine1 = new MrMachine();\n+        machine1.setNeighborhood(neighborhood1);\n+        MrMachine machine2 = new MrMachine();\n+        machine2.setNeighborhood(neighborhood1);\n+        MrMachine machine3 = new MrMachine();\n+        machine3.setNeighborhood(neighborhood2);\n+\n+        MrService service1 = new MrService();\n+        MrService service2 = new MrService();\n+        MrService service3 = new MrService();\n+\n+        MrServiceDependency serviceDependency1 = new MrServiceDependency(service1, service2);\n+        MrServiceDependency serviceDependency2 = new MrServiceDependency(service1, service3);\n+\n+        MrProcess process1 = new MrProcess(service1);\n+        MrProcess process2 = new MrProcess(service2);\n+        MrProcess process3 = new MrProcess(service3);\n+\n+        MrProcessAssignment process1AssignmentToMachine1 = new MrProcessAssignment(1L, process1, machine1);\n+        MrProcessAssignment process2AssignmentToMachine2 = new MrProcessAssignment(2L, process2, machine2);\n+        MrProcessAssignment process3AssignmentToMachine3 = new MrProcessAssignment(3L, process3, machine3);\n+\n+        constraintVerifier.verifyThat(MachineReassignmentConstraintProvider::serviceDependency)\n+                .given(neighborhood1, neighborhood2, machine1, machine2, machine3, service1, service2, service3,\n+                        serviceDependency1, serviceDependency2, process1, process2, process3, process1AssignmentToMachine1,\n+                        process2AssignmentToMachine2, process3AssignmentToMachine3)\n+                .penalizesBy(1L);\n+    }\n+\n+    @Test\n+    public void loadCost() {\n+        MrResource resource1 = new MrResource(0, false, 5);\n+        MrResource resource2 = new MrResource(1, false, 10);\n+        MrMachine machine = new MrMachine();\n+\n+        MrMachineCapacity machineCapacity1 = new MrMachineCapacity(machine, resource1, 20L, 10L);\n+        MrMachineCapacity machineCapacity2 = new MrMachineCapacity(machine, resource2, 20L, 10L);\n+\n+        MrProcess process = new MrProcess();\n+        MrProcessRequirement processRequirement1 = new MrProcessRequirement(process, resource1, 15L);\n+        MrProcessRequirement processRequirement2 = new MrProcessRequirement(process, resource2, 15L);\n+        process.setProcessRequirementList(Arrays.asList(processRequirement1, processRequirement2));\n+\n+        MrProcessAssignment processAssignment = new MrProcessAssignment(0L, process, machine, machine);\n+\n+        // soft limits of both resources are exceeded by 5 (15 - 10) and the weights are 5 and 10.\n+        constraintVerifier.verifyThat(MachineReassignmentConstraintProvider::loadCost)\n+                .given(resource1, resource2, machine, machineCapacity1, machineCapacity2, process, processRequirement1,\n+                        processRequirement2, processAssignment)\n+                .penalizesBy(25L + 50L);\n+    }\n+\n+    @Test\n+    public void processMoveCost() {\n+        MrGlobalPenaltyInfo globalPenaltyInfo = new MrGlobalPenaltyInfo();\n+        globalPenaltyInfo.setProcessMoveCostWeight(10);\n+\n+        MrMachine machine1 = new MrMachine();\n+        MrMachine machine2 = new MrMachine();\n+\n+        MrProcess process = new MrProcess();\n+        process.setMoveCost(2);\n+        MrProcessAssignment processAssignment = new MrProcessAssignment(0L, process, machine1, machine2);\n+\n+        MrProcessAssignment processAssignment2 = new MrProcessAssignment();\n+        processAssignment2.setProcess(process);\n+        processAssignment2.setOriginalMachine(machine1);\n+\n+        MrProcessAssignment processAssignment3 = new MrProcessAssignment(0L, process, machine1, machine1);\n+\n+        constraintVerifier.verifyThat(MachineReassignmentConstraintProvider::processMoveCost)\n+                .given(globalPenaltyInfo, machine1, machine2, process, processAssignment, processAssignment2,\n+                        processAssignment3)\n+                .penalizesBy(20L);\n+    }\n+\n+    @Test\n+    public void serviceMoveCost() {\n+        MrGlobalPenaltyInfo globalPenaltyInfo = new MrGlobalPenaltyInfo();\n+        globalPenaltyInfo.setServiceMoveCostWeight(10);\n+\n+        MrMachine machine1 = new MrMachine();\n+        MrMachine machine2 = new MrMachine();\n+\n+        MrService service1 = new MrService(1L);\n+        MrService service2 = new MrService(2L);\n+        // service2 has only one process moving, while service1 has two processes moving => wins\n+        MrProcess process1 = new MrProcess(service1);\n+        MrProcess process2 = new MrProcess(service1);\n+        MrProcess process3 = new MrProcess(service2);\n+\n+        MrProcessAssignment processAssignment1 = new MrProcessAssignment(0L, process1, machine1, machine2);\n+        MrProcessAssignment processAssignment2 = new MrProcessAssignment(1L, process2, machine1, machine2);\n+        MrProcessAssignment processAssignment3 = new MrProcessAssignment(1L, process3, machine1, machine2);\n+\n+        constraintVerifier.verifyThat(MachineReassignmentConstraintProvider::serviceMoveCost)\n+                .given(globalPenaltyInfo, machine1, machine2, service1, service2, process1, process2, process3,\n+                        processAssignment1, processAssignment2, processAssignment3)\n+                .penalizesBy(2 * 10L);\n+    }\n+\n+    @Test\n+    public void machineMoveCost() {\n+        MrGlobalPenaltyInfo globalPenaltyInfo = new MrGlobalPenaltyInfo();\n+        globalPenaltyInfo.setMachineMoveCostWeight(10);\n+\n+        MrMachine machine1 = new MrMachine();\n+        MrMachine machine2 = new MrMachine();\n+\n+        Map<MrMachine, Integer> costMapFromMachine1 = new HashedMap<>();\n+        costMapFromMachine1.put(machine2, 20);\n+        machine1.setMachineMoveCostMap(costMapFromMachine1);\n+\n+        Map<MrMachine, Integer> costMapFromMachine2 = new HashedMap<>();\n+        costMapFromMachine2.put(machine1, 0);\n+        machine2.setMachineMoveCostMap(costMapFromMachine2);\n+\n+        MrProcess process1 = new MrProcess();\n+        MrProcess process2 = new MrProcess();\n+        MrProcess process3 = new MrProcess();\n+\n+        MrProcessAssignment processAssignment1 = new MrProcessAssignment(0L, process1, machine1, machine2);\n+        MrProcessAssignment processAssignment2 = new MrProcessAssignment(0L, process2, machine1, machine2);\n+        MrProcessAssignment processAssignment3 = new MrProcessAssignment(0L, process3, machine2, machine1);\n+\n+        /*\n+         * 2 processes are moving from machine1 to machine2, which has a cost of 20 => 2 * 20 * 10 (global penalty) = 400.\n+         * The process3 moves from machine2 to machine1, which has a zero cost.\n+         */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4fb721e766e3e72db09a8a34bd9bfdf1fc6823"}, "originalPosition": 299}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NjkzOTU3OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjo0Mzo1MlrOGLV6ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjo1MDo0NVrOGLWLIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU0NjUzMg==", "bodyText": "Is removing this constraint intentional?", "url": "https://github.com/kiegroup/optaplanner/pull/755#discussion_r414546532", "createdAt": "2020-04-24T12:43:52Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -145,74 +139,66 @@ private Constraint transientUsage(ConstraintFactory factory) {\n     /**\n      * Load: The safety capacity for each resource for each machine should not be exceeded.\n      */\n-    private Constraint loadCost(ConstraintFactory factory) {\n+    protected Constraint loadCost(ConstraintFactory factory) {\n         return factory.from(MrMachineCapacity.class)\n                 .join(MrProcessAssignment.class,\n-                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-                )\n+                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine))\n                 .groupBy((machineCapacity, processAssignment) -> machineCapacity,\n-                        sumLong((machineCapacity, processAssignment) ->\n-                                processAssignment.getUsage(machineCapacity.getResource()))\n-                )\n+                        sumLong((machineCapacity, processAssignment) -> processAssignment\n+                                .getUsage(machineCapacity.getResource())))\n                 .filter(((machineCapacity, usage) -> machineCapacity.getSafetyCapacity() < usage))\n                 .penalizeLong(MrConstraints.LOAD_COST,\n                         HardSoftLongScore.ONE_SOFT,\n-                        (machineCapacity, usage) -> usage - machineCapacity.getSafetyCapacity());\n+                        (machineCapacity, usage) -> machineCapacity.getResource().getLoadCostWeight()\n+                                * (usage - machineCapacity.getSafetyCapacity()));\n     }\n \n     /**\n      * availability(r) = capacity(m, r) - usage(m, r)\n      * balanceCost = sum(max(0, multiplier * availability(m, r1) - availability(m, r2)))\n      */\n-    private Constraint balanceCost(ConstraintFactory factory) {\n-        return factory.from(MrBalancePenalty.class)\n-                .join(MrProcessAssignment.class)\n-                .groupBy((penalty, processAssignment) -> penalty, (penalty, processAssignment) -> processAssignment.getMachine(),\n-                        sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getOriginResource())),\n-                        sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getTargetResource()))\n-                )\n-                .penalizeLong(MrConstraints.BALANCE_COST, HardSoftLongScore.ONE_SOFT, this::balanceCost);\n-    }\n-\n-    private long balanceCost(MrBalancePenalty penalty, MrMachine machine, long originalUsage, long targetUsage) {\n-        long originalAvailability =\n-                machine.getMachineCapacity(penalty.getOriginResource()).getMaximumCapacity() - originalUsage;\n-        long targetAvailability =\n-                machine.getMachineCapacity(penalty.getTargetResource()).getMaximumCapacity() - targetUsage;\n-        long balanceCost = penalty.getMultiplicand() * originalAvailability - targetAvailability;\n-        return Math.max(0, balanceCost);\n+    protected Constraint balanceCost(ConstraintFactory factory) {\n+        throw new UnsupportedOperationException(\"Not yet implemented.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2388bf963de9a547d392202019c48b0388d52bbf"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU1MDgxOQ==", "bodyText": "The old impl is wrong, so better to remove it.", "url": "https://github.com/kiegroup/optaplanner/pull/755#discussion_r414550819", "createdAt": "2020-04-24T12:50:45Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/machinereassignment/solver/score/MachineReassignmentConstraintProvider.java", "diffHunk": "@@ -145,74 +139,66 @@ private Constraint transientUsage(ConstraintFactory factory) {\n     /**\n      * Load: The safety capacity for each resource for each machine should not be exceeded.\n      */\n-    private Constraint loadCost(ConstraintFactory factory) {\n+    protected Constraint loadCost(ConstraintFactory factory) {\n         return factory.from(MrMachineCapacity.class)\n                 .join(MrProcessAssignment.class,\n-                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine)\n-                )\n+                        equal(MrMachineCapacity::getMachine, MrProcessAssignment::getMachine))\n                 .groupBy((machineCapacity, processAssignment) -> machineCapacity,\n-                        sumLong((machineCapacity, processAssignment) ->\n-                                processAssignment.getUsage(machineCapacity.getResource()))\n-                )\n+                        sumLong((machineCapacity, processAssignment) -> processAssignment\n+                                .getUsage(machineCapacity.getResource())))\n                 .filter(((machineCapacity, usage) -> machineCapacity.getSafetyCapacity() < usage))\n                 .penalizeLong(MrConstraints.LOAD_COST,\n                         HardSoftLongScore.ONE_SOFT,\n-                        (machineCapacity, usage) -> usage - machineCapacity.getSafetyCapacity());\n+                        (machineCapacity, usage) -> machineCapacity.getResource().getLoadCostWeight()\n+                                * (usage - machineCapacity.getSafetyCapacity()));\n     }\n \n     /**\n      * availability(r) = capacity(m, r) - usage(m, r)\n      * balanceCost = sum(max(0, multiplier * availability(m, r1) - availability(m, r2)))\n      */\n-    private Constraint balanceCost(ConstraintFactory factory) {\n-        return factory.from(MrBalancePenalty.class)\n-                .join(MrProcessAssignment.class)\n-                .groupBy((penalty, processAssignment) -> penalty, (penalty, processAssignment) -> processAssignment.getMachine(),\n-                        sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getOriginResource())),\n-                        sumLong((penalty, processAssignment) -> processAssignment.getUsage(penalty.getTargetResource()))\n-                )\n-                .penalizeLong(MrConstraints.BALANCE_COST, HardSoftLongScore.ONE_SOFT, this::balanceCost);\n-    }\n-\n-    private long balanceCost(MrBalancePenalty penalty, MrMachine machine, long originalUsage, long targetUsage) {\n-        long originalAvailability =\n-                machine.getMachineCapacity(penalty.getOriginResource()).getMaximumCapacity() - originalUsage;\n-        long targetAvailability =\n-                machine.getMachineCapacity(penalty.getTargetResource()).getMaximumCapacity() - targetUsage;\n-        long balanceCost = penalty.getMultiplicand() * originalAvailability - targetAvailability;\n-        return Math.max(0, balanceCost);\n+    protected Constraint balanceCost(ConstraintFactory factory) {\n+        throw new UnsupportedOperationException(\"Not yet implemented.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU0NjUzMg=="}, "originalCommit": {"oid": "2388bf963de9a547d392202019c48b0388d52bbf"}, "originalPosition": 205}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4502, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}