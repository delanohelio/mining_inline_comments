{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2NDc4NTc1", "number": 661, "title": "PLANNER-1802 Add early termination test for SolverManager", "bodyText": "There has been a potential bug found: not being able to terminate a job with terminateEarly() and close() having status SOLVING_SCHEDULED", "createdAt": "2020-01-23T17:27:12Z", "url": "https://github.com/kiegroup/optaplanner/pull/661", "merged": true, "mergeCommit": {"oid": "e08f34f059bd77b4143dd4183d69743c5c9ab1d7"}, "closed": true, "closedAt": "2020-02-07T09:30:20Z", "author": {"login": "michaltomco"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9NubLgH2gAyMzY2NDc4NTc1OjhmNGFhOWFiZmI0Y2UyYjY2ZGM1MmFhMmM0YzgyOTY2YjdhNjA1NTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcB7acEgFqTM1NTAwNjkzNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8f4aa9abfb4ce2b66dc52aa2c4c82966b7a60554", "author": {"user": null}, "url": "https://github.com/kiegroup/optaplanner/commit/8f4aa9abfb4ce2b66dc52aa2c4c82966b7a60554", "committedDate": "2020-01-23T17:23:47Z", "message": "PLANNER-1802 Add early termination test for SolverManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5dae818e6baba1868cec9719a2a38cd7f7774f12", "author": {"user": null}, "url": "https://github.com/kiegroup/optaplanner/commit/5dae818e6baba1868cec9719a2a38cd7f7774f12", "committedDate": "2020-01-24T08:12:58Z", "message": "PLANNER-1802 Add additional comments and add one more loop"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTIyNjA2", "url": "https://github.com/kiegroup/optaplanner/pull/661#pullrequestreview-350122606", "createdAt": "2020-01-29T13:56:55Z", "commit": {"oid": "5dae818e6baba1868cec9719a2a38cd7f7774f12"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzo1Njo1NVrOFjJN0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzo1Njo1NVrOFjJN0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5NTQ3Mg==", "bodyText": "Just a nitpicking: the condition can be put in the while clause to avoid break in the middle of the loop", "url": "https://github.com/kiegroup/optaplanner/pull/661#discussion_r372395472", "createdAt": "2020-01-29T13:56:55Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "diffHunk": "@@ -240,4 +245,90 @@ public void skipAhead() throws ExecutionException, InterruptedException {\n         assertTrue(eventCount.get() < 4);\n     }\n \n+    /**\n+     * In order to effectively test the terminateEarly() and close() methods there had to be a way how to make the job\n+     * status change deterministic while solving jobs on a separate thread. The test waits for a status change in\n+     * a loop and time-outs when it doesn't reach it's expected status.\n+     */\n+    @Test\n+    public void terminateEarlyAndClose() throws InterruptedException {\n+        final SolverConfig solverConfig = PlannerTestUtils.buildSolverConfig(TestdataSolution.class, TestdataEntity.class)\n+                .withPhases(new ConstructionHeuristicPhaseConfig(), new LocalSearchPhaseConfig());\n+\n+        // Having only one solver running at the same time is important for predicting solver status behaviour.\n+        SolverManager<TestdataSolution, Long> solverManager =\n+                SolverManager.create(solverConfig, new SolverManagerConfig().withParallelSolverCount(\"1\"));\n+\n+        Long firstProblemId = 1L;\n+        Long secondProblemId = 2L;\n+\n+        // Submit the first problem. Status changes from SOLVING_SCHEDULED to SOLVING_ACTIVE.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Second problem not yet submitted to solverManager, tries to terminate it leading to a debug output:\n+        // DEBUG Ignoring terminateEarly() call because problemId (1) is not solving.\n+        // Asserting a logger message was determined as being too complex for using only on this\n+        // one occurrence and would result in cluttering up the code. The output was checked manually.\n+        solverManager.terminateEarly(secondProblemId);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(secondProblemId));\n+        // Did not affect the actively solving job.\n+        assertSame(SolverStatus.SOLVING_ACTIVE, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Schedule second job while waiting for the first job to finish. It stays in the SOLVING_SCHEDULED status.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        // Terminate second job which is in scheduled status. The status changes from SOLVING_SCHEDULED to NOT_SOLVING\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+\n+        // Reschedule second job. It reintroduces it to the solverManager by changing status from NOT_SOLVING to\n+        // SOLVING_SCHEDULED in which it stays.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_SCHEDULED);\n+\n+        // Terminate the first job which triggers it to change it's status from SOLVING_ACTIVE to NOT_SOLVING.\n+        // Automatically starts working on the second job. Its status changes from STATUS_SCHEDULED to STATUS_ACTIVE.\n+        solverManager.terminateEarly(firstProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Terminate the second job, its status changes from SOLVING_ACTIVE to NOT_SOLVING. Both jobs stopped solving.\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Reintroduce the problems to solverManager and attempt to close them all at once using solverManager.close().\n+        // The first job's status changes from SOLVING_ACTIVE to NOT_SOLVING.\n+        // The second job's status changes from SOLVING_SCHEDULED to NOT_SOLVING.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        solverManager.close();\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+    }\n+\n+    private void waitForJobStatusChangeOrTimeout(SolverManager<TestdataSolution, Long> solverManager, Long problemId, SolverStatus expectedStatusChange) throws InterruptedException {\n+        long t = System.currentTimeMillis();\n+        long end = t + 5000;\n+        // Checks every 5 milliseconds for solverJob status change for 5 seconds at maximum, otherwise time-outs and fails.\n+        while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dae818e6baba1868cec9719a2a38cd7f7774f12"}, "originalPosition": 106}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6290c643f7f1d42d4741c95e172efe6deaf5e95e", "author": {"user": null}, "url": "https://github.com/kiegroup/optaplanner/commit/6290c643f7f1d42d4741c95e172efe6deaf5e95e", "committedDate": "2020-01-29T17:05:10Z", "message": "PLANNER-1802 Simplify synchronization while loop"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxNDgzMjQ4", "url": "https://github.com/kiegroup/optaplanner/pull/661#pullrequestreview-351483248", "createdAt": "2020-01-31T12:49:32Z", "commit": {"oid": "6290c643f7f1d42d4741c95e172efe6deaf5e95e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMjo0OTozM1rOFkKZ7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMjo0OTozM1rOFkKZ7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2MzUzMw==", "bodyText": "If this test fails (as it reproduces an issue), let's mark it as ignored with a link to that issue and get this merged. Once the issue is fixed, it will be enabled.", "url": "https://github.com/kiegroup/optaplanner/pull/661#discussion_r373463533", "createdAt": "2020-01-31T12:49:33Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "diffHunk": "@@ -240,4 +245,86 @@ public void skipAhead() throws ExecutionException, InterruptedException {\n         assertTrue(eventCount.get() < 4);\n     }\n \n+    /**\n+     * In order to effectively test the terminateEarly() and close() methods there had to be a way how to make the job\n+     * status change deterministic while solving jobs on a separate thread. The test waits for a status change in\n+     * a loop and time-outs when it doesn't reach it's expected status.\n+     */\n+    @Test\n+    public void terminateEarlyAndClose() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6290c643f7f1d42d4741c95e172efe6deaf5e95e"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8a45254f01cd6337344881737eb480b3c63f5b6", "author": {"user": null}, "url": "https://github.com/kiegroup/optaplanner/commit/d8a45254f01cd6337344881737eb480b3c63f5b6", "committedDate": "2020-01-31T13:20:36Z", "message": "PLANNER-1802 Add @Ignore and fix comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxNTk2NjYz", "url": "https://github.com/kiegroup/optaplanner/pull/661#pullrequestreview-351596663", "createdAt": "2020-01-31T15:49:37Z", "commit": {"oid": "d8a45254f01cd6337344881737eb480b3c63f5b6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2566379e64bda368a86542664992e017edc5d24e", "author": {"user": null}, "url": "https://github.com/kiegroup/optaplanner/commit/2566379e64bda368a86542664992e017edc5d24e", "committedDate": "2020-01-31T17:08:39Z", "message": "PLANNER-1802 Add Jira link to @Ignore text"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MDA0NDQx", "url": "https://github.com/kiegroup/optaplanner/pull/661#pullrequestreview-355004441", "createdAt": "2020-02-07T08:48:27Z", "commit": {"oid": "2566379e64bda368a86542664992e017edc5d24e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwODo0ODoyN1rOFm19Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwODo0ODoyN1rOFm19Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI3NDIxNQ==", "bodyText": "Above the sleep, can you add these comments?\n// Quick polling (not a Test Thread Sleep anti-pattern)\n// Test is still fast on fast machines and doesn't randomly fail on slow machines.\n\nMotivation: the use of Thread.sleep() is a red flag in tests, because it's often used in a catch 22 situation: wait long enough to succeed on the slow machine, but don't wait long so the tests run quickly. This comment makes it clear that this code is doing it correctly.", "url": "https://github.com/kiegroup/optaplanner/pull/661#discussion_r376274215", "createdAt": "2020-02-07T08:48:27Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "diffHunk": "@@ -240,4 +245,87 @@ public void skipAhead() throws ExecutionException, InterruptedException {\n         assertTrue(eventCount.get() < 4);\n     }\n \n+    /**\n+     * In order to effectively test the terminateEarly() and close() methods there had to be a way how to make the job\n+     * status change in a deterministic way while solving jobs on separate threads. The test waits for a status change in\n+     * a loop and time-outs when it doesn't reach it's expected status.\n+     */\n+    @Ignore(\"https://issues.redhat.com/browse/PLANNER-1836\")\n+    @Test\n+    public void terminateEarlyAndClose() throws InterruptedException {\n+        final SolverConfig solverConfig = PlannerTestUtils.buildSolverConfig(TestdataSolution.class, TestdataEntity.class)\n+                .withPhases(new ConstructionHeuristicPhaseConfig(), new LocalSearchPhaseConfig());\n+\n+        // Having only one solver running at the same time is important for predicting solver status behaviour.\n+        SolverManager<TestdataSolution, Long> solverManager =\n+                SolverManager.create(solverConfig, new SolverManagerConfig().withParallelSolverCount(\"1\"));\n+\n+        Long firstProblemId = 1L;\n+        Long secondProblemId = 2L;\n+\n+        // Submit the first problem. Status changes from SOLVING_SCHEDULED to SOLVING_ACTIVE.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Second problem not yet submitted to solverManager, tries to terminate it leading to a debug output:\n+        // DEBUG Ignoring terminateEarly() call because problemId (1) is not solving.\n+        // Asserting a logger message was determined as being too complex for using only on this\n+        // one occurrence and would result in cluttering up the code. The output was checked manually.\n+        solverManager.terminateEarly(secondProblemId);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(secondProblemId));\n+        // Did not affect the actively solving job.\n+        assertSame(SolverStatus.SOLVING_ACTIVE, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Schedule second job while waiting for the first job to finish. It stays in the SOLVING_SCHEDULED status.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        // Terminate second job which is in scheduled status. The status changes from SOLVING_SCHEDULED to NOT_SOLVING\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+\n+        // Reschedule second job. It reintroduces it to the solverManager by changing status from NOT_SOLVING to\n+        // SOLVING_SCHEDULED in which it stays.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_SCHEDULED);\n+\n+        // Terminate the first job which triggers it to change it's status from SOLVING_ACTIVE to NOT_SOLVING.\n+        // Automatically starts working on the second job. Its status changes from STATUS_SCHEDULED to STATUS_ACTIVE.\n+        solverManager.terminateEarly(firstProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Terminate the second job, its status changes from SOLVING_ACTIVE to NOT_SOLVING. Both jobs stopped solving.\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Reintroduce the problems to solverManager and attempt to close them all at once using solverManager.close().\n+        // The first job's status changes from SOLVING_ACTIVE to NOT_SOLVING.\n+        // The second job's status changes from SOLVING_SCHEDULED to NOT_SOLVING.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        solverManager.close();\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+    }\n+\n+    private void waitForJobStatusChangeOrTimeout(SolverManager<TestdataSolution, Long> solverManager, Long problemId, SolverStatus expectedStatusChange) throws InterruptedException {\n+        long t = System.currentTimeMillis();\n+        long end = t + 5000;\n+        // Check every 5 milliseconds for solverJob status change for 5 seconds at maximum, otherwise time-out and fail.\n+        while (t < end) {\n+            if (solverManager.getSolverStatus(problemId) == expectedStatusChange) {\n+                return;\n+            }\n+            TimeUnit.MILLISECONDS.sleep(5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2566379e64bda368a86542664992e017edc5d24e"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MDA2MjM5", "url": "https://github.com/kiegroup/optaplanner/pull/661#pullrequestreview-355006239", "createdAt": "2020-02-07T08:52:06Z", "commit": {"oid": "2566379e64bda368a86542664992e017edc5d24e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwODo1MjowNlrOFm2Ctg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwODo1MjowNlrOFm2Ctg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI3NTYzOA==", "bodyText": "5000 is risky on our slow jenkins machines (or a community user compiling while something else is running on his/her machine).\nI recommend just adding a @Timeout(600_000) on the test itself and do\nwhile (solverManager.getSolverStatus(problemId) != expectedStatusChange) {\n   Thread.sleep(100L);\n}\nreturn;\n\nCalling currentTimeMillis() every 5 milliseconds might not be as cheap as one would expect. And questionable on Windows that has a 17 millisecond clock granularity :)", "url": "https://github.com/kiegroup/optaplanner/pull/661#discussion_r376275638", "createdAt": "2020-02-07T08:52:06Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "diffHunk": "@@ -240,4 +245,87 @@ public void skipAhead() throws ExecutionException, InterruptedException {\n         assertTrue(eventCount.get() < 4);\n     }\n \n+    /**\n+     * In order to effectively test the terminateEarly() and close() methods there had to be a way how to make the job\n+     * status change in a deterministic way while solving jobs on separate threads. The test waits for a status change in\n+     * a loop and time-outs when it doesn't reach it's expected status.\n+     */\n+    @Ignore(\"https://issues.redhat.com/browse/PLANNER-1836\")\n+    @Test\n+    public void terminateEarlyAndClose() throws InterruptedException {\n+        final SolverConfig solverConfig = PlannerTestUtils.buildSolverConfig(TestdataSolution.class, TestdataEntity.class)\n+                .withPhases(new ConstructionHeuristicPhaseConfig(), new LocalSearchPhaseConfig());\n+\n+        // Having only one solver running at the same time is important for predicting solver status behaviour.\n+        SolverManager<TestdataSolution, Long> solverManager =\n+                SolverManager.create(solverConfig, new SolverManagerConfig().withParallelSolverCount(\"1\"));\n+\n+        Long firstProblemId = 1L;\n+        Long secondProblemId = 2L;\n+\n+        // Submit the first problem. Status changes from SOLVING_SCHEDULED to SOLVING_ACTIVE.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Second problem not yet submitted to solverManager, tries to terminate it leading to a debug output:\n+        // DEBUG Ignoring terminateEarly() call because problemId (1) is not solving.\n+        // Asserting a logger message was determined as being too complex for using only on this\n+        // one occurrence and would result in cluttering up the code. The output was checked manually.\n+        solverManager.terminateEarly(secondProblemId);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(secondProblemId));\n+        // Did not affect the actively solving job.\n+        assertSame(SolverStatus.SOLVING_ACTIVE, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Schedule second job while waiting for the first job to finish. It stays in the SOLVING_SCHEDULED status.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        // Terminate second job which is in scheduled status. The status changes from SOLVING_SCHEDULED to NOT_SOLVING\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+\n+        // Reschedule second job. It reintroduces it to the solverManager by changing status from NOT_SOLVING to\n+        // SOLVING_SCHEDULED in which it stays.\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_SCHEDULED);\n+\n+        // Terminate the first job which triggers it to change it's status from SOLVING_ACTIVE to NOT_SOLVING.\n+        // Automatically starts working on the second job. Its status changes from STATUS_SCHEDULED to STATUS_ACTIVE.\n+        solverManager.terminateEarly(firstProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        // Terminate the second job, its status changes from SOLVING_ACTIVE to NOT_SOLVING. Both jobs stopped solving.\n+        solverManager.terminateEarly(secondProblemId);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+        assertSame(SolverStatus.NOT_SOLVING, solverManager.getSolverStatus(firstProblemId));\n+\n+        // Reintroduce the problems to solverManager and attempt to close them all at once using solverManager.close().\n+        // The first job's status changes from SOLVING_ACTIVE to NOT_SOLVING.\n+        // The second job's status changes from SOLVING_SCHEDULED to NOT_SOLVING.\n+        solverManager.solve(firstProblemId, PlannerTestUtils.generateTestdataSolution(\"s1\"));\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.SOLVING_ACTIVE);\n+\n+        solverManager.solve(secondProblemId, PlannerTestUtils.generateTestdataSolution(\"s2\"));\n+        assertSame(SolverStatus.SOLVING_SCHEDULED, solverManager.getSolverStatus(secondProblemId));\n+\n+        solverManager.close();\n+        waitForJobStatusChangeOrTimeout(solverManager, firstProblemId, SolverStatus.NOT_SOLVING);\n+        waitForJobStatusChangeOrTimeout(solverManager, secondProblemId, SolverStatus.NOT_SOLVING);\n+    }\n+\n+    private void waitForJobStatusChangeOrTimeout(SolverManager<TestdataSolution, Long> solverManager, Long problemId, SolverStatus expectedStatusChange) throws InterruptedException {\n+        long t = System.currentTimeMillis();\n+        long end = t + 5000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2566379e64bda368a86542664992e017edc5d24e"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MDA2OTM3", "url": "https://github.com/kiegroup/optaplanner/pull/661#pullrequestreview-355006937", "createdAt": "2020-02-07T08:53:17Z", "commit": {"oid": "2566379e64bda368a86542664992e017edc5d24e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3046, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}