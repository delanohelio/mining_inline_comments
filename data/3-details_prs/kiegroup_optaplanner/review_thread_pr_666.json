{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4NTk3ODg4", "number": 666, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNjoyNzowOVrODb-mgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwODoyNTo0NVrODcjLBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNjYzODExOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStream.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNjoyNzowOVrOFjxZgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwODoyOTo1OVrOFkpaCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA1MzgyNw==", "bodyText": "I just experimented with this, and if called like ifNotExists(Visit.class) - without the joiners - this gives varargs warnings in IDE. Not sure what to do about this method (and its likes here and in UniStream).", "url": "https://github.com/kiegroup/optaplanner/pull/666#discussion_r373053827", "createdAt": "2020-01-30T16:27:09Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStream.java", "diffHunk": "@@ -198,6 +198,166 @@\n         return join(otherClass, AbstractTriJoiner.merge(joiners));\n     }\n \n+    // ************************************************************************\n+    // If (Not) Exists\n+    // ************************************************************************\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every pair of A and B where C exists for which the {@link TriJoiner}\n+     * is true (for the properties it extracts from the facts).\n+     * <p>\n+     * This method has overloaded methods with multiple {@link TriJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C exists for which the {@link TriJoiner}\n+     * is true\n+     */\n+    default <C> BiConstraintStream<A, B> ifExists(Class<C> otherClass, TriJoiner<A, B, C> joiner) {\n+        return ifExists(otherClass, new TriJoiner[] { joiner });\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C exists for which the {@link TriJoiner}s\n+     * are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2) {\n+        return ifExists(otherClass, new TriJoiner[] {joiner1, joiner2});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C exists for which the {@link TriJoiner}s\n+     * are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2, TriJoiner<A, B, C> joiner3) {\n+        return ifExists(otherClass, new TriJoiner[] {joiner1, joiner2, joiner3});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param joiner4 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C exists for which the {@link TriJoiner}s\n+     * are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2, TriJoiner<A, B, C> joiner3, TriJoiner<A, B, C> joiner4) {\n+        return ifExists(otherClass, new TriJoiner[] {joiner1, joiner2, joiner3, joiner4});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * <p>\n+     * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n+     * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n+     * Therefore, there are overloaded methods with up to 4 {@link TriJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiners never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C exists for which the {@link TriJoiner}s\n+     * are true\n+     */\n+    <C> BiConstraintStream<A, B> ifExists(Class<C> otherClass, TriJoiner<A, B, C>... joiners);\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner} is true (for the properties it extracts from the facts).\n+     * <p>\n+     * This method has overloaded methods with multiple {@link TriJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner} is true\n+     */\n+    default <C> BiConstraintStream<A, B> ifNotExists(Class<C> otherClass, TriJoiner<A, B, C> joiner) {\n+        return ifNotExists(otherClass, new TriJoiner[] { joiner });\n+    }\n+\n+    /**\n+     * As defined by {@link #ifNotExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner}s are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifNotExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2) {\n+        return ifNotExists(otherClass, new TriJoiner[] {joiner1, joiner2});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifNotExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner}s are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifNotExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2, TriJoiner<A, B, C> joiner3) {\n+        return ifNotExists(otherClass, new TriJoiner[] {joiner1, joiner2, joiner3});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifNotExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param joiner4 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner}s are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifNotExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2, TriJoiner<A, B, C> joiner3, TriJoiner<A, B, C> joiner4) {\n+        return ifNotExists(otherClass, new TriJoiner[] {joiner1, joiner2, joiner3, joiner4});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifNotExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * <p>\n+     * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n+     * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n+     * Therefore, there are overloaded methods with up to 4 {@link TriJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiners never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner}s are true\n+     */\n+    <C> BiConstraintStream<A, B> ifNotExists(Class<C> otherClass, TriJoiner<A, B, C>... joiners);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d44250756e0df73ba036c2d3ebeb13a05aeaee5"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk3MDgyOA==", "bodyText": "In the javadoc it says:\n* This method causes Unchecked generics array creation for varargs parameter warnings,\n* but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n* Therefore, there are overloaded methods with up to 4 {@link TriJoiner} parameters.\nI've seen that issue on all other varargs methods before (including join etc) - is this the same issue as what you are seeing?\nIf it is, ignore it: this javadoc is the lesser evil. If it's not, let's discuss it.", "url": "https://github.com/kiegroup/optaplanner/pull/666#discussion_r373970828", "createdAt": "2020-02-03T08:28:07Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStream.java", "diffHunk": "@@ -198,6 +198,166 @@\n         return join(otherClass, AbstractTriJoiner.merge(joiners));\n     }\n \n+    // ************************************************************************\n+    // If (Not) Exists\n+    // ************************************************************************\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every pair of A and B where C exists for which the {@link TriJoiner}\n+     * is true (for the properties it extracts from the facts).\n+     * <p>\n+     * This method has overloaded methods with multiple {@link TriJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C exists for which the {@link TriJoiner}\n+     * is true\n+     */\n+    default <C> BiConstraintStream<A, B> ifExists(Class<C> otherClass, TriJoiner<A, B, C> joiner) {\n+        return ifExists(otherClass, new TriJoiner[] { joiner });\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C exists for which the {@link TriJoiner}s\n+     * are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2) {\n+        return ifExists(otherClass, new TriJoiner[] {joiner1, joiner2});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C exists for which the {@link TriJoiner}s\n+     * are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2, TriJoiner<A, B, C> joiner3) {\n+        return ifExists(otherClass, new TriJoiner[] {joiner1, joiner2, joiner3});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param joiner4 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C exists for which the {@link TriJoiner}s\n+     * are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2, TriJoiner<A, B, C> joiner3, TriJoiner<A, B, C> joiner4) {\n+        return ifExists(otherClass, new TriJoiner[] {joiner1, joiner2, joiner3, joiner4});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * <p>\n+     * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n+     * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n+     * Therefore, there are overloaded methods with up to 4 {@link TriJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiners never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C exists for which the {@link TriJoiner}s\n+     * are true\n+     */\n+    <C> BiConstraintStream<A, B> ifExists(Class<C> otherClass, TriJoiner<A, B, C>... joiners);\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner} is true (for the properties it extracts from the facts).\n+     * <p>\n+     * This method has overloaded methods with multiple {@link TriJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner} is true\n+     */\n+    default <C> BiConstraintStream<A, B> ifNotExists(Class<C> otherClass, TriJoiner<A, B, C> joiner) {\n+        return ifNotExists(otherClass, new TriJoiner[] { joiner });\n+    }\n+\n+    /**\n+     * As defined by {@link #ifNotExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner}s are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifNotExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2) {\n+        return ifNotExists(otherClass, new TriJoiner[] {joiner1, joiner2});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifNotExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner}s are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifNotExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2, TriJoiner<A, B, C> joiner3) {\n+        return ifNotExists(otherClass, new TriJoiner[] {joiner1, joiner2, joiner3});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifNotExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param joiner4 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner}s are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifNotExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2, TriJoiner<A, B, C> joiner3, TriJoiner<A, B, C> joiner4) {\n+        return ifNotExists(otherClass, new TriJoiner[] {joiner1, joiner2, joiner3, joiner4});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifNotExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * <p>\n+     * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n+     * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n+     * Therefore, there are overloaded methods with up to 4 {@link TriJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiners never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner}s are true\n+     */\n+    <C> BiConstraintStream<A, B> ifNotExists(Class<C> otherClass, TriJoiner<A, B, C>... joiners);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA1MzgyNw=="}, "originalCommit": {"oid": "7d44250756e0df73ba036c2d3ebeb13a05aeaee5"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk3MTQ2Ng==", "bodyText": "Yeah, it is the same with joins etc. Ok, leaving it as it is.", "url": "https://github.com/kiegroup/optaplanner/pull/666#discussion_r373971466", "createdAt": "2020-02-03T08:29:59Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStream.java", "diffHunk": "@@ -198,6 +198,166 @@\n         return join(otherClass, AbstractTriJoiner.merge(joiners));\n     }\n \n+    // ************************************************************************\n+    // If (Not) Exists\n+    // ************************************************************************\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every pair of A and B where C exists for which the {@link TriJoiner}\n+     * is true (for the properties it extracts from the facts).\n+     * <p>\n+     * This method has overloaded methods with multiple {@link TriJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C exists for which the {@link TriJoiner}\n+     * is true\n+     */\n+    default <C> BiConstraintStream<A, B> ifExists(Class<C> otherClass, TriJoiner<A, B, C> joiner) {\n+        return ifExists(otherClass, new TriJoiner[] { joiner });\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C exists for which the {@link TriJoiner}s\n+     * are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2) {\n+        return ifExists(otherClass, new TriJoiner[] {joiner1, joiner2});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C exists for which the {@link TriJoiner}s\n+     * are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2, TriJoiner<A, B, C> joiner3) {\n+        return ifExists(otherClass, new TriJoiner[] {joiner1, joiner2, joiner3});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param joiner4 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C exists for which the {@link TriJoiner}s\n+     * are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2, TriJoiner<A, B, C> joiner3, TriJoiner<A, B, C> joiner4) {\n+        return ifExists(otherClass, new TriJoiner[] {joiner1, joiner2, joiner3, joiner4});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * <p>\n+     * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n+     * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n+     * Therefore, there are overloaded methods with up to 4 {@link TriJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiners never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C exists for which the {@link TriJoiner}s\n+     * are true\n+     */\n+    <C> BiConstraintStream<A, B> ifExists(Class<C> otherClass, TriJoiner<A, B, C>... joiners);\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner} is true (for the properties it extracts from the facts).\n+     * <p>\n+     * This method has overloaded methods with multiple {@link TriJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner} is true\n+     */\n+    default <C> BiConstraintStream<A, B> ifNotExists(Class<C> otherClass, TriJoiner<A, B, C> joiner) {\n+        return ifNotExists(otherClass, new TriJoiner[] { joiner });\n+    }\n+\n+    /**\n+     * As defined by {@link #ifNotExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner}s are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifNotExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2) {\n+        return ifNotExists(otherClass, new TriJoiner[] {joiner1, joiner2});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifNotExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner}s are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifNotExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2, TriJoiner<A, B, C> joiner3) {\n+        return ifNotExists(otherClass, new TriJoiner[] {joiner1, joiner2, joiner3});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifNotExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param joiner4 never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner}s are true\n+     */\n+    default <C> BiConstraintStream<A, B> ifNotExists(Class<C> otherClass, TriJoiner<A, B, C> joiner1,\n+            TriJoiner<A, B, C> joiner2, TriJoiner<A, B, C> joiner3, TriJoiner<A, B, C> joiner4) {\n+        return ifNotExists(otherClass, new TriJoiner[] {joiner1, joiner2, joiner3, joiner4});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifNotExists(Class, TriJoiner)}. For performance reasons, indexing joiners must be placed\n+     * before filtering joiners.\n+     * <p>\n+     * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n+     * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n+     * Therefore, there are overloaded methods with up to 4 {@link TriJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiners never null\n+     * @param <C> the type of the third matched fact\n+     * @return never null, a stream that matches every pair of A and B where C does not exist for which the\n+     * {@link TriJoiner}s are true\n+     */\n+    <C> BiConstraintStream<A, B> ifNotExists(Class<C> otherClass, TriJoiner<A, B, C>... joiners);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA1MzgyNw=="}, "originalCommit": {"oid": "7d44250756e0df73ba036c2d3ebeb13a05aeaee5"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjYyOTgxOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwODoyNTo0NVrOFkpUAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwODoyNjoyM1rOFkpVEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk2OTkyMA==", "bodyText": "style: Not and Exists without capital. only first word has capital in comments", "url": "https://github.com/kiegroup/optaplanner/pull/666#discussion_r373969920", "createdAt": "2020-02-03T08:25:45Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStream.java", "diffHunk": "@@ -198,6 +198,166 @@\n         return join(otherClass, AbstractTriJoiner.merge(joiners));\n     }\n \n+    // ************************************************************************\n+    // If (Not) Exists", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d44250756e0df73ba036c2d3ebeb13a05aeaee5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk3MDE5NQ==", "bodyText": "BTW, in general for titles (including docs), we're now following scientific titles, not newspaper titles. So basically only the first word has a capital.", "url": "https://github.com/kiegroup/optaplanner/pull/666#discussion_r373970195", "createdAt": "2020-02-03T08:26:23Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStream.java", "diffHunk": "@@ -198,6 +198,166 @@\n         return join(otherClass, AbstractTriJoiner.merge(joiners));\n     }\n \n+    // ************************************************************************\n+    // If (Not) Exists", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk2OTkyMA=="}, "originalCommit": {"oid": "7d44250756e0df73ba036c2d3ebeb13a05aeaee5"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4590, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}