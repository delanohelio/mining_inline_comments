{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczMzEyODk4", "number": 679, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo0MDo1MFrODelN8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODo1Mjo0M1rODfSyVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzkzNjUxOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo0MDo1MFrOFnzDvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo0MDo1MFrOFnzDvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI3NTMyNw==", "bodyText": "Some suggestions, for reasons of performance:\n\nThe first getX()/getY() comparisons should be done using Joiners.equal(...).\nI would consider first filtering out all the cells where c1.hasWordSet(...) and only then joining with c2.", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r377275327", "createdAt": "2020-02-10T19:40:50Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.impl.score.stream.bi.FilteringBiJoiner;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> 1 - sc.getCharacterSet().size());\n+    }\n+\n+    private Constraint noParallelHorizontalNeighbours(ConstraintFactory cf) {\n+        return cf.fromUniquePair(ScrabbleCell.class)\n+                 .filter((c1, c2) -> c1.getX() == c2.getX() &&\n+                                     Math.abs(c1.getY() - c2.getY()) == 1 &&\n+                                     c1.hasWordSet(ScrabbleWordDirection.HORIZONTAL) &&\n+                                     c2.hasWordSet(ScrabbleWordDirection.HORIZONTAL))\n+                 .penalize(\"No parallel horizontal neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint noParallelVerticalNeighbours(ConstraintFactory cf) {\n+        return cf.fromUniquePair(ScrabbleCell.class)\n+                 .filter((c1, c2) -> c1.getY() == c2.getY() &&\n+                                     Math.abs(c1.getX() - c2.getX()) == 1 &&\n+                                     c1.hasWordSet(ScrabbleWordDirection.VERTICAL) &&\n+                                     c2.hasWordSet(ScrabbleWordDirection.VERTICAL))\n+                 .penalize(\"No parallel vertical neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a415badc5a20f0bb9b1f1f091cb80a615ea4a4eb"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzkzOTk3OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo0MTo1MlrOFnzF6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo0MTo1MlrOFnzF6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI3NTg4MA==", "bodyText": "Please replace FilteringBiJoiner with Joiners.filtering(...).", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r377275880", "createdAt": "2020-02-10T19:41:52Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.impl.score.stream.bi.FilteringBiJoiner;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> 1 - sc.getCharacterSet().size());\n+    }\n+\n+    private Constraint noParallelHorizontalNeighbours(ConstraintFactory cf) {\n+        return cf.fromUniquePair(ScrabbleCell.class)\n+                 .filter((c1, c2) -> c1.getX() == c2.getX() &&\n+                                     Math.abs(c1.getY() - c2.getY()) == 1 &&\n+                                     c1.hasWordSet(ScrabbleWordDirection.HORIZONTAL) &&\n+                                     c2.hasWordSet(ScrabbleWordDirection.HORIZONTAL))\n+                 .penalize(\"No parallel horizontal neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint noParallelVerticalNeighbours(ConstraintFactory cf) {\n+        return cf.fromUniquePair(ScrabbleCell.class)\n+                 .filter((c1, c2) -> c1.getY() == c2.getY() &&\n+                                     Math.abs(c1.getX() - c2.getX()) == 1 &&\n+                                     c1.hasWordSet(ScrabbleWordDirection.VERTICAL) &&\n+                                     c2.hasWordSet(ScrabbleWordDirection.VERTICAL))\n+                 .penalize(\"No parallel vertical neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint outOfGrid(ConstraintFactory cf) {\n+        return cf.from(ScrabbleWordAssignment.class)\n+                 .filter(ScrabbleWordAssignment::isOutOfGrid)\n+                 .penalize(\"Out of grid\", HardMediumSoftScore.ONE_HARD, swa -> swa.getWord().length());\n+    }\n+\n+    private Constraint maximizeMergesPerWord(ConstraintFactory cf) {\n+        return cf.from(ScrabbleWordAssignment.class)\n+                 .join(ScrabbleCell.class, new FilteringBiJoiner<>((swa, sc) -> sc.getWordSet().contains(swa) && sc.hasMerge()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a415badc5a20f0bb9b1f1f091cb80a615ea4a4eb"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzk3NDA4OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo1Mjo1MlrOFnzbXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMTozMToyOFrOFn2RzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4MTM3NQ==", "bodyText": "@Christopher-Chianelli  This is where the score corruption is going to be. DRL does this:\nscoreHolder.addHardConstraintMatch(kcontext, 1 - $size);\n\nSo the number will be 0 or less. But that is because in DRL, you need to input a negative number to penalize.\nIn CS, you have the penalize() call, and that expects a positive number.\nTherefore I think that if you invert the logic of the match weigher here, this score corruption will go away.", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r377281375", "createdAt": "2020-02-10T19:52:52Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.impl.score.stream.bi.FilteringBiJoiner;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> 1 - sc.getCharacterSet().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a415badc5a20f0bb9b1f1f091cb80a615ea4a4eb"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5MzUwMA==", "bodyText": "Thanks for that; (although I still find it odd FAST_ASSERT didn't catch this) Suggestion for Constrant Stream: output a warning to the console whenever it see a penalize/reward with a negative number (if possible)", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r377293500", "createdAt": "2020-02-10T20:18:12Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.impl.score.stream.bi.FilteringBiJoiner;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> 1 - sc.getCharacterSet().size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4MTM3NQ=="}, "originalCommit": {"oid": "a415badc5a20f0bb9b1f1f091cb80a615ea4a4eb"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMjIxNg==", "bodyText": "There was another one: maximizeMergesPerWord was suppose to be a reward, not a penalty. But I got it working in FULL_ASSERT mode now.", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r377302216", "createdAt": "2020-02-10T20:37:08Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.impl.score.stream.bi.FilteringBiJoiner;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> 1 - sc.getCharacterSet().size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4MTM3NQ=="}, "originalCommit": {"oid": "a415badc5a20f0bb9b1f1f091cb80a615ea4a4eb"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMzUwNg==", "bodyText": "Please make it run like that for a couple minutes, sometimes the corruptions are hiding in less likely corners of the state space.\nWrt. the warning - I'll think about it. We generally don't do warnings in Optaplanner, but I'll consider if fail-fast would be a good idea here.", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r377303506", "createdAt": "2020-02-10T20:40:00Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.impl.score.stream.bi.FilteringBiJoiner;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> 1 - sc.getCharacterSet().size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4MTM3NQ=="}, "originalCommit": {"oid": "a415badc5a20f0bb9b1f1f091cb80a615ea4a4eb"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxNDUyMA==", "bodyText": "Error is probably better than a warning so users will immediately know something wrong instead of having to look at the logs to see why it not working correctly. Although that raises the question if someone has a constraint that can be positive or negative (Drools can do that since its reward function is also its penalize function).", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r377314520", "createdAt": "2020-02-10T21:02:43Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.impl.score.stream.bi.FilteringBiJoiner;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> 1 - sc.getCharacterSet().size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4MTM3NQ=="}, "originalCommit": {"oid": "a415badc5a20f0bb9b1f1f091cb80a615ea4a4eb"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyODA3Nw==", "bodyText": "I ran it for 30 minutes; no Score Corruption was detected on FULL_ASSERT (manually terminated on Local Search step 1677)", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r377328077", "createdAt": "2020-02-10T21:31:28Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.impl.score.stream.bi.FilteringBiJoiner;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> 1 - sc.getCharacterSet().size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4MTM3NQ=="}, "originalCommit": {"oid": "a415badc5a20f0bb9b1f1f091cb80a615ea4a4eb"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNTI2MzI3OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNzo0NzozN1rOFn_j4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODowMzo0MlrOFo481g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4MDE2Mg==", "bodyText": "Looking at the code now, the join().filter() could be replaced by ifExists(...) with the appropriate joiners. The performance of that would likely be the best - only not sure if it would match 1:1 with what the DRL does. If FULL_ASSERT passes, I say let's do it.", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r377480162", "createdAt": "2020-02-11T07:47:37Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> sc.getCharacterSet().size() - 1);\n+    }\n+\n+    private Constraint noParallelHorizontalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.HORIZONTAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getX), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.HORIZONTAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getY() - c2.getY()) == 1)\n+                 .penalize(\"No parallel horizontal neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint noParallelVerticalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.VERTICAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getY), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.VERTICAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getX() - c2.getX()) == 1)\n+                 .penalize(\"No parallel vertical neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8313e66887e52cc13e3e7cc461cb54e7cae6eb0d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM2Mjc4OA==", "bodyText": "I don't think they are the same. Consider this scenario:\nWO[R]D1\nWO[R]D2\nWO[R]D3\n\nWhere id([R] in WORD2) < id([R] in WORD1) < id([R] in WORD3).\nUsing the current method, the constraint matches are [([R] in WORD2, [R] in WORD1),([R] in WORD2, [R] in WORD3)].\nUsing the ifExists method, the constraint matches are [([R] in WORD2,[R] in WORD1|WORD2)] (there is only one constraint match, with the second element being in either WORD1 or WORD2). This situation is extremely rare, and probably take a long time to be explored. I ran 20 minutes on FULL_ASSERT using ifExists and got no errors so far, but I still think it not one-to-one.", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r378362788", "createdAt": "2020-02-12T16:25:14Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> sc.getCharacterSet().size() - 1);\n+    }\n+\n+    private Constraint noParallelHorizontalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.HORIZONTAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getX), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.HORIZONTAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getY() - c2.getY()) == 1)\n+                 .penalize(\"No parallel horizontal neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint noParallelVerticalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.VERTICAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getY), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.VERTICAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getX() - c2.getX()) == 1)\n+                 .penalize(\"No parallel vertical neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4MDE2Mg=="}, "originalCommit": {"oid": "8313e66887e52cc13e3e7cc461cb54e7cae6eb0d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM2ODI5Ng==", "bodyText": "If (cell1.x < cell2.x -> cell1.id < cell2.id and cell1.y < cell2.y -> cell1.id < cell2.id) or (cell1.x > cell2.x -> cell1.id > cell2.id and cell1.y > cell2.y -> cell1.id > cell2.id), this could never happen (it requires an id discontinuity)", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r378368296", "createdAt": "2020-02-12T16:33:40Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> sc.getCharacterSet().size() - 1);\n+    }\n+\n+    private Constraint noParallelHorizontalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.HORIZONTAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getX), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.HORIZONTAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getY() - c2.getY()) == 1)\n+                 .penalize(\"No parallel horizontal neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint noParallelVerticalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.VERTICAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getY), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.VERTICAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getX() - c2.getX()) == 1)\n+                 .penalize(\"No parallel vertical neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4MDE2Mg=="}, "originalCommit": {"oid": "8313e66887e52cc13e3e7cc461cb54e7cae6eb0d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM3ODExNw==", "bodyText": "From the importer:\n        private void readCellList() throws IOException {\n            int gridWidth = readIntegerValue(\"gridWidth:\");\n            solution.setGridWidth(gridWidth);\n            int gridHeight = readIntegerValue(\"gridHeight:\");\n            solution.setGridHeight(gridHeight);\n            List<ScrabbleCell> cellList = new ArrayList<>(gridWidth * gridHeight);\n            for (int x = 0; x < gridWidth; x++) {\n                for (int y = 0; y < gridHeight; y++) {\n                    ScrabbleCell cell = new ScrabbleCell();\n                    cell.setId((long) (y * gridWidth + x));\n                    cell.setX(x);\n                    cell.setY(y);\n                    cell.setWordSet(new LinkedHashSet<>());\n                    cell.setCharacterCountMap(new LinkedHashMap<>());\n                    cellList.add(cell);\n                }\n            }\n            solution.setCellList(cellList);\n        }\n\nIn particular: cell.setId((long) (y * gridWidth + x))\nDue to this, the corner case will never be hit, and the constraints are \"equivalent\".\n\"Proof\":\nAssume, for contradiction, there exists cells c1, c2, c3 such that c1.x = c2.x = c3.x and c1.hasWordSet(HORIZONTAL) and c2.hasWordSet(HORIZONTAL) and c3.hasWordSet(HORIZONTAL), with c1.y < c2.y < c3.y. From the id formula we can derive:\nc1.id \n= c1.y * W + x\n< c2.y * W + x\n= c2.id\n\nThus c1.id < c2.id. Similarly we have:\nc2.id\n= c2.y * W + x\n< c3.y * W + x\n= c3.id\n\nThus c2.id < c3.id and we have c1.id < c2.id < c3.id. This make \"double\" matches impossible, as they can only occur if a cell is between two cells with an id less than both of them, which we proved is not possible. QED.", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r378378117", "createdAt": "2020-02-12T16:48:46Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> sc.getCharacterSet().size() - 1);\n+    }\n+\n+    private Constraint noParallelHorizontalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.HORIZONTAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getX), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.HORIZONTAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getY() - c2.getY()) == 1)\n+                 .penalize(\"No parallel horizontal neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint noParallelVerticalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.VERTICAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getY), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.VERTICAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getX() - c2.getX()) == 1)\n+                 .penalize(\"No parallel vertical neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4MDE2Mg=="}, "originalCommit": {"oid": "8313e66887e52cc13e3e7cc461cb54e7cae6eb0d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM4MTE4OQ==", "bodyText": "Side note: This proof also proves the filter can be simplified to c1.y == c2.y - 1.", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r378381189", "createdAt": "2020-02-12T16:53:28Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> sc.getCharacterSet().size() - 1);\n+    }\n+\n+    private Constraint noParallelHorizontalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.HORIZONTAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getX), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.HORIZONTAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getY() - c2.getY()) == 1)\n+                 .penalize(\"No parallel horizontal neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint noParallelVerticalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.VERTICAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getY), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.VERTICAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getX() - c2.getX()) == 1)\n+                 .penalize(\"No parallel vertical neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4MDE2Mg=="}, "originalCommit": {"oid": "8313e66887e52cc13e3e7cc461cb54e7cae6eb0d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM4NDE5MQ==", "bodyText": "@triceo if Id generating code won't change and no one using Scrabble in production (with their own id generating code that might not have this property that cause the constraints to be equivalent), then I am okay changing it to ifExists.", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r378384191", "createdAt": "2020-02-12T16:58:18Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> sc.getCharacterSet().size() - 1);\n+    }\n+\n+    private Constraint noParallelHorizontalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.HORIZONTAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getX), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.HORIZONTAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getY() - c2.getY()) == 1)\n+                 .penalize(\"No parallel horizontal neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint noParallelVerticalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.VERTICAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getY), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.VERTICAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getX() - c2.getX()) == 1)\n+                 .penalize(\"No parallel vertical neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4MDE2Mg=="}, "originalCommit": {"oid": "8313e66887e52cc13e3e7cc461cb54e7cae6eb0d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM5MjI3OQ==", "bodyText": "Looking at the Drools, they indeed use c1.x = c2.x and c2.y = c1.y + 1, meaning we can safety change this to an ifExists and remove the id joiner (which turn out was only changing Math.abs(c1.y - c2.y) = 1 to c2.y = c1.y + 1).", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r378392279", "createdAt": "2020-02-12T17:12:00Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> sc.getCharacterSet().size() - 1);\n+    }\n+\n+    private Constraint noParallelHorizontalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.HORIZONTAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getX), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.HORIZONTAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getY() - c2.getY()) == 1)\n+                 .penalize(\"No parallel horizontal neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint noParallelVerticalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.VERTICAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getY), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.VERTICAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getX() - c2.getX()) == 1)\n+                 .penalize(\"No parallel vertical neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4MDE2Mg=="}, "originalCommit": {"oid": "8313e66887e52cc13e3e7cc461cb54e7cae6eb0d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM5NTk1MQ==", "bodyText": "(To bad there isn't a Joiners.fixed((first,second) -> boolean), since the cells x and y don't ever change, meaning we already know what cell we need to check for a particular cell and don't need to check all the cells in the same column)", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r378395951", "createdAt": "2020-02-12T17:18:20Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> sc.getCharacterSet().size() - 1);\n+    }\n+\n+    private Constraint noParallelHorizontalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.HORIZONTAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getX), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.HORIZONTAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getY() - c2.getY()) == 1)\n+                 .penalize(\"No parallel horizontal neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint noParallelVerticalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.VERTICAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getY), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.VERTICAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getX() - c2.getX()) == 1)\n+                 .penalize(\"No parallel vertical neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4MDE2Mg=="}, "originalCommit": {"oid": "8313e66887e52cc13e3e7cc461cb54e7cae6eb0d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM5NjI0Mg==", "bodyText": "(fixed is basically a filtering that is only run once)", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r378396242", "createdAt": "2020-02-12T17:18:51Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> sc.getCharacterSet().size() - 1);\n+    }\n+\n+    private Constraint noParallelHorizontalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.HORIZONTAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getX), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.HORIZONTAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getY() - c2.getY()) == 1)\n+                 .penalize(\"No parallel horizontal neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint noParallelVerticalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.VERTICAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getY), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.VERTICAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getX() - c2.getX()) == 1)\n+                 .penalize(\"No parallel vertical neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4MDE2Mg=="}, "originalCommit": {"oid": "8313e66887e52cc13e3e7cc461cb54e7cae6eb0d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM5ODQ4Mg==", "bodyText": "(wait, equals have an override that use two different functions; I can use that)", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r378398482", "createdAt": "2020-02-12T17:22:45Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> sc.getCharacterSet().size() - 1);\n+    }\n+\n+    private Constraint noParallelHorizontalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.HORIZONTAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getX), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.HORIZONTAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getY() - c2.getY()) == 1)\n+                 .penalize(\"No parallel horizontal neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint noParallelVerticalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.VERTICAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getY), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.VERTICAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getX() - c2.getX()) == 1)\n+                 .penalize(\"No parallel vertical neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4MDE2Mg=="}, "originalCommit": {"oid": "8313e66887e52cc13e3e7cc461cb54e7cae6eb0d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQyMDQzOA==", "bodyText": "Well proven!", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r378420438", "createdAt": "2020-02-12T18:03:42Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };\n+    }\n+\n+    private Constraint characterConflict(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class)\n+                 .filter(sc -> sc.getCharacterSet().size() >= 2)\n+                 .penalize(\"Character confict\", HardMediumSoftScore.ONE_HARD, sc -> sc.getCharacterSet().size() - 1);\n+    }\n+\n+    private Constraint noParallelHorizontalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.HORIZONTAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getX), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.HORIZONTAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getY() - c2.getY()) == 1)\n+                 .penalize(\"No parallel horizontal neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint noParallelVerticalNeighbours(ConstraintFactory cf) {\n+        return cf.from(ScrabbleCell.class).filter(sc -> sc.hasWordSet(ScrabbleWordDirection.VERTICAL))\n+                 .join(ScrabbleCell.class,\n+                       Joiners.equal(ScrabbleCell::getY), Joiners.lessThan(ScrabbleCell::getId),\n+                       Joiners.filtering((first, other) -> other.hasWordSet(ScrabbleWordDirection.VERTICAL)))\n+                 .filter((c1, c2) -> Math.abs(c1.getX() - c2.getX()) == 1)\n+                 .penalize(\"No parallel vertical neighbours\", HardMediumSoftScore.ONE_HARD);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4MDE2Mg=="}, "originalCommit": {"oid": "8313e66887e52cc13e3e7cc461cb54e7cae6eb0d"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNTI5NDYxOnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/scrabble/solver/scrabbleSolverConfig.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwODowMjoyOVrOFn_1XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwODowMjoyOVrOFn_1XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4NDYzNg==", "bodyText": "When you're done with the constraint provider, please bring this in sync with the rest of the examples. (Only scoreDrl is enabled, the rest is commented out.)", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r377484636", "createdAt": "2020-02-11T08:02:29Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/scrabble/solver/scrabbleSolverConfig.xml", "diffHunk": "@@ -6,10 +6,15 @@\n   <solutionClass>org.optaplanner.examples.scrabble.domain.ScrabbleSolution</solutionClass>\n   <entityClass>org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment</entityClass>\n   <entityClass>org.optaplanner.examples.scrabble.domain.ScrabbleCell</entityClass>\n+  <environmentMode>FULL_ASSERT</environmentMode>\n \n   <!-- Score configuration -->\n   <scoreDirectorFactory>\n-    <scoreDrl>org/optaplanner/examples/scrabble/solver/scrabbleScoreRules.drl</scoreDrl>\n+    <constraintProviderClass>org.optaplanner.examples.scrabble.optional.score.ScrabbleConstraintProvider</constraintProviderClass>\n     <initializingScoreTrend>ONLY_DOWN</initializingScoreTrend>\n+    <assertionScoreDirectorFactory>\n+      <scoreDrl>org/optaplanner/examples/scrabble/solver/scrabbleScoreRules.drl</scoreDrl>\n+      <initializingScoreTrend>ONLY_DOWN</initializingScoreTrend>\n+    </assertionScoreDirectorFactory>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8313e66887e52cc13e3e7cc461cb54e7cae6eb0d"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTM5NzM4OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODo1MToxNVrOFo6dIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxODoyMDo1MFrOFp_gQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ0NTA4OQ==", "bodyText": "One last thing, @Christopher-Chianelli, and then I'll merge: this isn't the proper code style, we don't do alignment on brackets. Please check the rest of the file as well, it's not the only place I see it.", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r378445089", "createdAt": "2020-02-12T18:51:15Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ff94274b96677ecf90f0a408c759b36e40475f0"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ4ODE4NQ==", "bodyText": "I use KIE Java Conventions in Eclipse. Fun fact: the IDEA KIE Java Formatter and Eclipse KIE Java Formatter disagrees in some places, and this is one of them. I remember I created a script once that ran Idea formatter for me from command line. Might be harder to do that now that I have IDEA in a flatpak....", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r378488185", "createdAt": "2020-02-12T20:14:17Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ0NTA4OQ=="}, "originalCommit": {"oid": "3ff94274b96677ecf90f0a408c759b36e40475f0"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5MDA0MQ==", "bodyText": "Dammit. :-( We should somehow get them in sync. I'll bring it up.\nIn the meantime - any chance you could configure yours to be the same as in IDEA? As far as I know, most of the team uses IntelliJ.", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r378490041", "createdAt": "2020-02-12T20:18:15Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ0NTA4OQ=="}, "originalCommit": {"oid": "3ff94274b96677ecf90f0a408c759b36e40475f0"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5NTM1NA==", "bodyText": "They are fundamentally incompatible (IDEA's have more features than Eclipse). I will try running the IDEA's formatter in a container and package it as a program.", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r378495354", "createdAt": "2020-02-12T20:29:50Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ0NTA4OQ=="}, "originalCommit": {"oid": "3ff94274b96677ecf90f0a408c759b36e40475f0"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU3NjM4NA==", "bodyText": "Done; managed to find out where format.sh is in the flatpak.", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r379576384", "createdAt": "2020-02-14T18:20:50Z", "author": {"login": "Christopher-Chianelli"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/scrabble/optional/score/ScrabbleConstraintProvider.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.optaplanner.examples.scrabble.optional.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordDirection;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleCell;\n+import org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment;\n+\n+public class ScrabbleConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                                characterConflict(constraintFactory),\n+                                noParallelHorizontalNeighbours(constraintFactory),\n+                                noParallelVerticalNeighbours(constraintFactory),\n+                                outOfGrid(constraintFactory),\n+                                maximizeMergesPerWord(constraintFactory),\n+                                pullToCenter(constraintFactory)\n+        };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ0NTA4OQ=="}, "originalCommit": {"oid": "3ff94274b96677ecf90f0a408c759b36e40475f0"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTQwMjQ3OnYy", "diffSide": "RIGHT", "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/scrabble/solver/scrabbleSolverConfig.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODo1Mjo0M1rOFo6gTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODo1MzowMlrOFo6g7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ0NTkwMw==", "bodyText": "This needs to be commented out before merging.", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r378445903", "createdAt": "2020-02-12T18:52:43Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/scrabble/solver/scrabbleSolverConfig.xml", "diffHunk": "@@ -6,10 +6,15 @@\n   <solutionClass>org.optaplanner.examples.scrabble.domain.ScrabbleSolution</solutionClass>\n   <entityClass>org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment</entityClass>\n   <entityClass>org.optaplanner.examples.scrabble.domain.ScrabbleCell</entityClass>\n+  <environmentMode>FULL_ASSERT</environmentMode>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ff94274b96677ecf90f0a408c759b36e40475f0"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ0NjA2MA==", "bodyText": "Also, we usually keep it at the top of the file. (Check other examples for reference.)", "url": "https://github.com/kiegroup/optaplanner/pull/679#discussion_r378446060", "createdAt": "2020-02-12T18:53:02Z", "author": {"login": "triceo"}, "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/scrabble/solver/scrabbleSolverConfig.xml", "diffHunk": "@@ -6,10 +6,15 @@\n   <solutionClass>org.optaplanner.examples.scrabble.domain.ScrabbleSolution</solutionClass>\n   <entityClass>org.optaplanner.examples.scrabble.domain.ScrabbleWordAssignment</entityClass>\n   <entityClass>org.optaplanner.examples.scrabble.domain.ScrabbleCell</entityClass>\n+  <environmentMode>FULL_ASSERT</environmentMode>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ0NTkwMw=="}, "originalCommit": {"oid": "3ff94274b96677ecf90f0a408c759b36e40475f0"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4611, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}