{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwNzA4Njkx", "number": 890, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozMToxNVrOEaXfPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMTo1Mzo0MFrOEaflQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MDgzMjYzOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/constructionheuristic/decider/forager/ConstructionHeuristicForagerFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozMToxNVrOHDwECQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozMToxNVrOHDwECQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY5NTI0MQ==", "bodyText": "Weird formatting again.", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473695241", "createdAt": "2020-08-20T07:31:15Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/constructionheuristic/decider/forager/ConstructionHeuristicForagerFactory.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.constructionheuristic.decider.forager;\n+\n+import org.optaplanner.core.config.constructionheuristic.decider.forager.ConstructionHeuristicForagerConfig;\n+import org.optaplanner.core.config.constructionheuristic.decider.forager.ConstructionHeuristicPickEarlyType;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+\n+public class ConstructionHeuristicForagerFactory {\n+\n+    public static ConstructionHeuristicForagerFactory create(ConstructionHeuristicForagerConfig foragerConfig) {\n+        return new ConstructionHeuristicForagerFactory(foragerConfig);\n+    }\n+\n+    private final ConstructionHeuristicForagerConfig foragerConfig;\n+\n+    public ConstructionHeuristicForagerFactory(\n+            ConstructionHeuristicForagerConfig foragerConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09af9b5a21112181b2be7a291fa55eaaf378c58a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MDgzNjQxOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/constructionheuristic/placer/EntityPlacerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozMjowMVrOHDwGXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzo0MDo1NFrOHDwyLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY5NTgzNw==", "bodyText": "Maybe an explanation here would be nice?", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473695837", "createdAt": "2020-08-20T07:32:01Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/constructionheuristic/placer/EntityPlacerFactory.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.constructionheuristic.placer;\n+\n+import org.optaplanner.core.config.constructionheuristic.placer.EntityPlacerConfig;\n+import org.optaplanner.core.config.constructionheuristic.placer.PooledEntityPlacerConfig;\n+import org.optaplanner.core.config.constructionheuristic.placer.QueuedEntityPlacerConfig;\n+import org.optaplanner.core.config.constructionheuristic.placer.QueuedValuePlacerConfig;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+\n+public interface EntityPlacerFactory {\n+\n+    static EntityPlacerFactory create(EntityPlacerConfig entityPlacerConfig) {\n+        if (PooledEntityPlacerConfig.class.isAssignableFrom(entityPlacerConfig.getClass())) {\n+            return new PooledEntityPlacerFactory((PooledEntityPlacerConfig) entityPlacerConfig);\n+        } else if (QueuedEntityPlacerConfig.class.isAssignableFrom(entityPlacerConfig.getClass())) {\n+            return new QueuedEntityPlacerFactory((QueuedEntityPlacerConfig) entityPlacerConfig);\n+        } else if (QueuedValuePlacerConfig.class.isAssignableFrom(entityPlacerConfig.getClass())) {\n+            return new QueuedValuePlacerFactory((QueuedValuePlacerConfig) entityPlacerConfig);\n+        } else {\n+            throw new IllegalArgumentException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09af9b5a21112181b2be7a291fa55eaaf378c58a"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcwNzA1Mw==", "bodyText": "good catch, thanks!", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473707053", "createdAt": "2020-08-20T07:40:54Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/constructionheuristic/placer/EntityPlacerFactory.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.constructionheuristic.placer;\n+\n+import org.optaplanner.core.config.constructionheuristic.placer.EntityPlacerConfig;\n+import org.optaplanner.core.config.constructionheuristic.placer.PooledEntityPlacerConfig;\n+import org.optaplanner.core.config.constructionheuristic.placer.QueuedEntityPlacerConfig;\n+import org.optaplanner.core.config.constructionheuristic.placer.QueuedValuePlacerConfig;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+\n+public interface EntityPlacerFactory {\n+\n+    static EntityPlacerFactory create(EntityPlacerConfig entityPlacerConfig) {\n+        if (PooledEntityPlacerConfig.class.isAssignableFrom(entityPlacerConfig.getClass())) {\n+            return new PooledEntityPlacerFactory((PooledEntityPlacerConfig) entityPlacerConfig);\n+        } else if (QueuedEntityPlacerConfig.class.isAssignableFrom(entityPlacerConfig.getClass())) {\n+            return new QueuedEntityPlacerFactory((QueuedEntityPlacerConfig) entityPlacerConfig);\n+        } else if (QueuedValuePlacerConfig.class.isAssignableFrom(entityPlacerConfig.getClass())) {\n+            return new QueuedValuePlacerFactory((QueuedValuePlacerConfig) entityPlacerConfig);\n+        } else {\n+            throw new IllegalArgumentException();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY5NTgzNw=="}, "originalCommit": {"oid": "09af9b5a21112181b2be7a291fa55eaaf378c58a"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MDg0MTkxOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/constructionheuristic/placer/PooledEntityPlacerFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozMjo1MlrOHDwJ0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozMjo1MlrOHDwJ0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY5NjcyMw==", "bodyText": "Formatting.", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473696723", "createdAt": "2020-08-20T07:32:52Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/constructionheuristic/placer/PooledEntityPlacerFactory.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.constructionheuristic.placer;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.optaplanner.core.config.constructionheuristic.placer.PooledEntityPlacerConfig;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.MoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.composite.CartesianProductMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.ChangeMoveSelectorConfig;\n+import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n+import org.optaplanner.core.impl.domain.variable.descriptor.GenuineVariableDescriptor;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+import org.optaplanner.core.impl.heuristic.selector.move.MoveSelector;\n+import org.optaplanner.core.impl.heuristic.selector.move.MoveSelectorFactory;\n+\n+public class PooledEntityPlacerFactory extends AbstractEntityPlacerFactory<PooledEntityPlacerConfig> {\n+\n+    public PooledEntityPlacerFactory(PooledEntityPlacerConfig placerConfig) {\n+        super(placerConfig);\n+    }\n+\n+    @Override\n+    public PooledEntityPlacer buildEntityPlacer(HeuristicConfigPolicy configPolicy) {\n+        MoveSelectorConfig moveSelectorConfig_ =\n+                placerConfig.getMoveSelectorConfig() == null ? buildMoveSelectorConfig(configPolicy)\n+                        : placerConfig.getMoveSelectorConfig();\n+\n+        MoveSelector moveSelector = MoveSelectorFactory.create(moveSelectorConfig_).buildMoveSelector(\n+                configPolicy, SelectionCacheType.JUST_IN_TIME, SelectionOrder.ORIGINAL);\n+        return new PooledEntityPlacer(moveSelector);\n+    }\n+\n+    private MoveSelectorConfig buildMoveSelectorConfig(HeuristicConfigPolicy configPolicy) {\n+        EntityDescriptor entityDescriptor = configPolicy.getSolutionDescriptor().deduceEntityDescriptor(null);\n+        EntitySelectorConfig entitySelectorConfig = buildEntitySelectorConfig(configPolicy, entityDescriptor);\n+\n+        Collection<GenuineVariableDescriptor> variableDescriptors = entityDescriptor.getGenuineVariableDescriptors();\n+        List<MoveSelectorConfig> subMoveSelectorConfigList = new ArrayList<>(\n+                variableDescriptors.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09af9b5a21112181b2be7a291fa55eaaf378c58a"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MDg0NDU0OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/constructionheuristic/placer/QueuedEntityPlacerFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozMzoxNFrOHDwLfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozMzoxNFrOHDwLfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY5NzE1MQ==", "bodyText": "Formatting.", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473697151", "createdAt": "2020-08-20T07:33:14Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/constructionheuristic/placer/QueuedEntityPlacerFactory.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.constructionheuristic.placer;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.optaplanner.core.config.constructionheuristic.placer.QueuedEntityPlacerConfig;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.MoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.composite.CartesianProductMoveSelectorConfig;\n+import org.optaplanner.core.config.util.ConfigUtils;\n+import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n+import org.optaplanner.core.impl.domain.variable.descriptor.GenuineVariableDescriptor;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+import org.optaplanner.core.impl.heuristic.selector.entity.EntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.move.MoveSelector;\n+import org.optaplanner.core.impl.heuristic.selector.move.MoveSelectorFactory;\n+\n+public class QueuedEntityPlacerFactory extends AbstractEntityPlacerFactory<QueuedEntityPlacerConfig> {\n+\n+    public QueuedEntityPlacerFactory(QueuedEntityPlacerConfig placerConfig) {\n+        super(placerConfig);\n+    }\n+\n+    @Override\n+    public QueuedEntityPlacer buildEntityPlacer(HeuristicConfigPolicy configPolicy) {\n+        EntitySelectorConfig entitySelectorConfig_ = buildEntitySelectorConfig(configPolicy);\n+        EntitySelector entitySelector = entitySelectorConfig_.buildEntitySelector(configPolicy,\n+                SelectionCacheType.PHASE, SelectionOrder.ORIGINAL);\n+\n+        List<MoveSelectorConfig> moveSelectorConfigList_;\n+        if (ConfigUtils.isEmptyCollection(placerConfig.getMoveSelectorConfigList())) {\n+            EntityDescriptor entityDescriptor = entitySelector.getEntityDescriptor();\n+            Collection<GenuineVariableDescriptor> variableDescriptors = entityDescriptor.getGenuineVariableDescriptors();\n+            List<MoveSelectorConfig> subMoveSelectorConfigList = new ArrayList<>(\n+                    variableDescriptors.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09af9b5a21112181b2be7a291fa55eaaf378c58a"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MDg2MjY4OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/solver/termination/TerminationFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozNTozMlrOHDwXhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozNTozMlrOHDwXhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcwMDIzMA==", "bodyText": "I'd change the logic here. Start with isEmpty(), then check for size == 1.\nThat way, you avoid calling size() twice, and also messing with boundary conditions (>).", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473700230", "createdAt": "2020-08-20T07:35:32Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/solver/termination/TerminationFactory.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.solver.termination;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import org.optaplanner.core.api.score.Score;\n+import org.optaplanner.core.config.solver.termination.TerminationCompositionStyle;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+import org.optaplanner.core.config.util.ConfigUtils;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+import org.optaplanner.core.impl.score.definition.ScoreDefinition;\n+\n+public class TerminationFactory {\n+\n+    public static TerminationFactory create(TerminationConfig terminationConfig) {\n+        return new TerminationFactory(terminationConfig);\n+    }\n+\n+    private final TerminationConfig terminationConfig;\n+\n+    private TerminationFactory(TerminationConfig terminationConfig) {\n+        this.terminationConfig = terminationConfig;\n+    }\n+\n+    public Termination buildTermination(HeuristicConfigPolicy configPolicy, Termination chainedTermination) {\n+        Termination termination = buildTermination(configPolicy);\n+        if (termination == null) {\n+            return chainedTermination;\n+        }\n+        return new OrCompositeTermination(chainedTermination, termination);\n+    }\n+\n+    /**\n+     * @param configPolicy never null\n+     * @return sometimes null\n+     */\n+    public Termination buildTermination(HeuristicConfigPolicy configPolicy) {\n+        List<Termination> terminationList = new ArrayList<>();\n+        if (terminationConfig.getTerminationClass() != null) {\n+            Termination termination =\n+                    ConfigUtils.newInstance(terminationConfig, \"terminationClass\", terminationConfig.getTerminationClass());\n+            terminationList.add(termination);\n+        }\n+\n+        terminationList.addAll(buildTimeBasedTermination(configPolicy));\n+\n+        if (terminationConfig.getBestScoreLimit() != null) {\n+            ScoreDefinition scoreDefinition = configPolicy.getScoreDefinition();\n+            Score bestScoreLimit_ = scoreDefinition.parseScore(terminationConfig.getBestScoreLimit());\n+            double[] timeGradientWeightNumbers = new double[scoreDefinition.getLevelsSize() - 1];\n+            Arrays.fill(timeGradientWeightNumbers, 0.50); // Number pulled out of thin air\n+            terminationList.add(new BestScoreTermination(scoreDefinition, bestScoreLimit_, timeGradientWeightNumbers));\n+        }\n+        if (terminationConfig.getBestScoreFeasible() != null) {\n+            ScoreDefinition scoreDefinition = configPolicy.getScoreDefinition();\n+            if (!terminationConfig.getBestScoreFeasible()) {\n+                throw new IllegalArgumentException(\"The termination bestScoreFeasible (\"\n+                        + terminationConfig.getBestScoreFeasible() + \") cannot be false.\");\n+            }\n+            double[] timeGradientWeightFeasibleNumbers = new double[scoreDefinition.getFeasibleLevelsSize() - 1];\n+            Arrays.fill(timeGradientWeightFeasibleNumbers, 0.50); // Number pulled out of thin air\n+            terminationList.add(new BestScoreFeasibleTermination(scoreDefinition, timeGradientWeightFeasibleNumbers));\n+        }\n+        if (terminationConfig.getStepCountLimit() != null) {\n+            terminationList.add(new StepCountTermination(terminationConfig.getStepCountLimit()));\n+        }\n+        if (terminationConfig.getScoreCalculationCountLimit() != null) {\n+            terminationList.add(new ScoreCalculationCountTermination(terminationConfig.getScoreCalculationCountLimit()));\n+        }\n+        if (terminationConfig.getUnimprovedStepCountLimit() != null) {\n+            terminationList.add(new UnimprovedStepCountTermination(terminationConfig.getUnimprovedStepCountLimit()));\n+        }\n+\n+        terminationList.addAll(buildInnerTermination(configPolicy));\n+        return buildTerminationFromList(terminationList);\n+    }\n+\n+    protected List<Termination> buildTimeBasedTermination(HeuristicConfigPolicy configPolicy) {\n+        List<Termination> terminationList = new ArrayList<>();\n+        Long timeMillisSpentLimit = terminationConfig.calculateTimeMillisSpentLimit();\n+        if (timeMillisSpentLimit != null) {\n+            terminationList.add(new TimeMillisSpentTermination(timeMillisSpentLimit));\n+        }\n+        Long unimprovedTimeMillisSpentLimit = terminationConfig.calculateUnimprovedTimeMillisSpentLimit();\n+        if (unimprovedTimeMillisSpentLimit != null) {\n+            if (terminationConfig.getUnimprovedScoreDifferenceThreshold() == null) {\n+                terminationList.add(new UnimprovedTimeMillisSpentTermination(unimprovedTimeMillisSpentLimit));\n+            } else {\n+                ScoreDefinition scoreDefinition = configPolicy.getScoreDefinition();\n+                Score unimprovedScoreDifferenceThreshold_ =\n+                        scoreDefinition.parseScore(terminationConfig.getUnimprovedScoreDifferenceThreshold());\n+                if (unimprovedScoreDifferenceThreshold_.compareTo(scoreDefinition.getZeroScore()) <= 0) {\n+                    throw new IllegalStateException(\"The unimprovedScoreDifferenceThreshold (\"\n+                            + terminationConfig.getUnimprovedScoreDifferenceThreshold() + \") must be positive.\");\n+\n+                }\n+                terminationList.add(new UnimprovedTimeMillisSpentScoreDifferenceThresholdTermination(\n+                        unimprovedTimeMillisSpentLimit, unimprovedScoreDifferenceThreshold_));\n+            }\n+        } else if (terminationConfig.getUnimprovedScoreDifferenceThreshold() != null) {\n+            throw new IllegalStateException(\"The unimprovedScoreDifferenceThreshold (\"\n+                    + terminationConfig.getUnimprovedScoreDifferenceThreshold()\n+                    + \") can only be used if an unimproved*SpentLimit (\"\n+                    + unimprovedTimeMillisSpentLimit + \") is used too.\");\n+        }\n+\n+        return terminationList;\n+    }\n+\n+    protected List<Termination> buildInnerTermination(HeuristicConfigPolicy configPolicy) {\n+        if (ConfigUtils.isEmptyCollection(terminationConfig.getTerminationConfigList())) {\n+            return Collections.emptyList();\n+        }\n+\n+        return terminationConfig.getTerminationConfigList().stream()\n+                .map(config -> TerminationFactory.create(config).buildTermination(configPolicy))\n+                .filter(Objects::nonNull)\n+                .collect(Collectors.toList());\n+    }\n+\n+    protected Termination buildTerminationFromList(List<Termination> terminationList) {\n+        if (terminationList.size() == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09af9b5a21112181b2be7a291fa55eaaf378c58a"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MjE0MTQxOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/constructionheuristic/placer/QueuedEntityPlacerConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMTo0ODozNFrOHD9MEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMTo1MTozNVrOHD9SGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkxMDI5MQ==", "bodyText": "The fact that the unfold methods create a new PlacerFactory,\nas well as do a lot of defaulting (configuration by exception),\nmakes me think we might want to move them to the Factory side too, alongside the build methods?", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473910291", "createdAt": "2020-08-20T11:48:34Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/constructionheuristic/placer/QueuedEntityPlacerConfig.java", "diffHunk": "@@ -40,22 +36,16 @@\n import org.optaplanner.core.config.heuristic.selector.move.generic.chained.SubChainChangeMoveSelectorConfig;\n import org.optaplanner.core.config.heuristic.selector.move.generic.chained.SubChainSwapMoveSelectorConfig;\n import org.optaplanner.core.config.heuristic.selector.move.generic.chained.TailChainSwapMoveSelectorConfig;\n-import org.optaplanner.core.config.heuristic.selector.value.ValueSelectorConfig;\n import org.optaplanner.core.config.util.ConfigUtils;\n-import org.optaplanner.core.impl.constructionheuristic.placer.QueuedEntityPlacer;\n-import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n-import org.optaplanner.core.impl.domain.variable.descriptor.GenuineVariableDescriptor;\n+import org.optaplanner.core.impl.constructionheuristic.placer.QueuedEntityPlacerFactory;\n import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n-import org.optaplanner.core.impl.heuristic.selector.entity.EntitySelector;\n-import org.optaplanner.core.impl.heuristic.selector.move.MoveSelector;\n-import org.optaplanner.core.impl.heuristic.selector.move.MoveSelectorFactory;\n \n public class QueuedEntityPlacerConfig extends EntityPlacerConfig<QueuedEntityPlacerConfig> {\n \n     public static QueuedEntityPlacerConfig unfoldNew(HeuristicConfigPolicy configPolicy,\n             List<MoveSelectorConfig> templateMoveSelectorConfigList) {\n         QueuedEntityPlacerConfig config = new QueuedEntityPlacerConfig();\n-        config.entitySelectorConfig = config.buildEntitySelectorConfig(configPolicy);\n+        config.entitySelectorConfig = new QueuedEntityPlacerFactory(config).buildEntitySelectorConfig(configPolicy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003df931c33e6755928f0eb84a0cd8410432d932"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkxMTgzNA==", "bodyText": "The \"configuration by exception\" in one place argument is really the big reason I'd like to see them in the same class as the build methods.\nDue to conf by exception, most properties are automatically assigned a default value (sometimes calculated to a default value). For example, a move selector doesn't have to explicity state its cacheType in the XML (it can, but it doesn't have too).\nOften, we need to answer \"what does that property default too again?\" That used to have 1 answer: in the Config class. Now, if the unfold methods are in the Config class, it depends. I'd rather see all that information in 1 location, the new Factory class.", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473911834", "createdAt": "2020-08-20T11:51:35Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/constructionheuristic/placer/QueuedEntityPlacerConfig.java", "diffHunk": "@@ -40,22 +36,16 @@\n import org.optaplanner.core.config.heuristic.selector.move.generic.chained.SubChainChangeMoveSelectorConfig;\n import org.optaplanner.core.config.heuristic.selector.move.generic.chained.SubChainSwapMoveSelectorConfig;\n import org.optaplanner.core.config.heuristic.selector.move.generic.chained.TailChainSwapMoveSelectorConfig;\n-import org.optaplanner.core.config.heuristic.selector.value.ValueSelectorConfig;\n import org.optaplanner.core.config.util.ConfigUtils;\n-import org.optaplanner.core.impl.constructionheuristic.placer.QueuedEntityPlacer;\n-import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n-import org.optaplanner.core.impl.domain.variable.descriptor.GenuineVariableDescriptor;\n+import org.optaplanner.core.impl.constructionheuristic.placer.QueuedEntityPlacerFactory;\n import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n-import org.optaplanner.core.impl.heuristic.selector.entity.EntitySelector;\n-import org.optaplanner.core.impl.heuristic.selector.move.MoveSelector;\n-import org.optaplanner.core.impl.heuristic.selector.move.MoveSelectorFactory;\n \n public class QueuedEntityPlacerConfig extends EntityPlacerConfig<QueuedEntityPlacerConfig> {\n \n     public static QueuedEntityPlacerConfig unfoldNew(HeuristicConfigPolicy configPolicy,\n             List<MoveSelectorConfig> templateMoveSelectorConfigList) {\n         QueuedEntityPlacerConfig config = new QueuedEntityPlacerConfig();\n-        config.entitySelectorConfig = config.buildEntitySelectorConfig(configPolicy);\n+        config.entitySelectorConfig = new QueuedEntityPlacerFactory(config).buildEntitySelectorConfig(configPolicy);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkxMDI5MQ=="}, "originalCommit": {"oid": "003df931c33e6755928f0eb84a0cd8410432d932"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MjE1ODcyOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/test/java/org/optaplanner/core/config/constructionheuristic/placer/PooledEntityPlacerConfigTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMTo1Mzo0MFrOHD9Wcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMjoxNDo0MVrOHD-CjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkxMjk0Nw==", "bodyText": "I presume this is just GitHub getting confused?", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473912947", "createdAt": "2020-08-20T11:53:40Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/config/constructionheuristic/placer/PooledEntityPlacerConfigTest.java", "diffHunk": "@@ -16,46 +16,46 @@\n \n package org.optaplanner.core.config.constructionheuristic.placer;\n \n+import static org.assertj.core.api.Assertions.assertThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n-import java.util.Arrays;\n-\n import org.junit.jupiter.api.Test;\n import org.optaplanner.core.config.heuristic.selector.move.generic.ChangeMoveSelectorConfig;\n import org.optaplanner.core.config.heuristic.selector.value.ValueSelectorConfig;\n import org.optaplanner.core.config.solver.EnvironmentMode;\n-import org.optaplanner.core.impl.constructionheuristic.placer.QueuedEntityPlacer;\n import org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor;\n import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n-import org.optaplanner.core.impl.score.buildin.simple.SimpleScoreDefinition;\n import org.optaplanner.core.impl.score.director.InnerScoreDirectorFactory;\n-import org.optaplanner.core.impl.testdata.domain.multivar.TestdataMultiVarSolution;\n+import org.optaplanner.core.impl.testdata.domain.TestdataEntity;\n+import org.optaplanner.core.impl.testdata.domain.TestdataSolution;\n \n-public class QueuedEntityPlacerConfigTest {\n+public class PooledEntityPlacerConfigTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003df931c33e6755928f0eb84a0cd8410432d932"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkyNDIzNw==", "bodyText": "Short answer: yes; long answer:\nduring this refactoring, I look in the coverage reports and try to cover the biggest gaps. Often, the gaps are in the build methods, thus the QueuedEntityPlacerConfigTest moved to QueuedEntityPlacerFactoryTest. On the other hand, the PooledEntityPlacerConfig had a coverage gap in its unfoldNew(), which lead to introducing a new test class.", "url": "https://github.com/kiegroup/optaplanner/pull/890#discussion_r473924237", "createdAt": "2020-08-20T12:14:41Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/config/constructionheuristic/placer/PooledEntityPlacerConfigTest.java", "diffHunk": "@@ -16,46 +16,46 @@\n \n package org.optaplanner.core.config.constructionheuristic.placer;\n \n+import static org.assertj.core.api.Assertions.assertThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n-import java.util.Arrays;\n-\n import org.junit.jupiter.api.Test;\n import org.optaplanner.core.config.heuristic.selector.move.generic.ChangeMoveSelectorConfig;\n import org.optaplanner.core.config.heuristic.selector.value.ValueSelectorConfig;\n import org.optaplanner.core.config.solver.EnvironmentMode;\n-import org.optaplanner.core.impl.constructionheuristic.placer.QueuedEntityPlacer;\n import org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor;\n import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n-import org.optaplanner.core.impl.score.buildin.simple.SimpleScoreDefinition;\n import org.optaplanner.core.impl.score.director.InnerScoreDirectorFactory;\n-import org.optaplanner.core.impl.testdata.domain.multivar.TestdataMultiVarSolution;\n+import org.optaplanner.core.impl.testdata.domain.TestdataEntity;\n+import org.optaplanner.core.impl.testdata.domain.TestdataSolution;\n \n-public class QueuedEntityPlacerConfigTest {\n+public class PooledEntityPlacerConfigTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkxMjk0Nw=="}, "originalCommit": {"oid": "003df931c33e6755928f0eb84a0cd8410432d932"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4416, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}