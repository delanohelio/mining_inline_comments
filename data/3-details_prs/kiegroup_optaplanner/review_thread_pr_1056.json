{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwMzI0ODQy", "number": 1056, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowNDo1N1rOE_KjZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowNToxNFrOE_Kj5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjY4NjQ1OnYy", "diffSide": "LEFT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/ConstraintSubTree.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowNDo1N1rOH8uCeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowNDo1N1rOH8uCeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzMDkwNg==", "bodyText": "This is purely aesthetic. Was so much easier to debug, now that the condition isn't a one-liner.", "url": "https://github.com/kiegroup/optaplanner/pull/1056#discussion_r533430906", "createdAt": "2020-12-01T14:04:57Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/ConstraintSubTree.java", "diffHunk": "@@ -90,12 +90,22 @@ public RuleAssembler getRuleAssembler() {\n     }\n \n     public RuleAssembler getRuleAssembler(int totalExpectedGroupByCount) {\n-        RuleAssembler builder = isJoin ? leftSubTree.getRuleAssembler(totalExpectedGroupByCount)\n-                .join(rightSubTree.getRuleAssembler(totalExpectedGroupByCount), nodeList.get(0))\n-                : RuleAssembler.from(variableFactory, nodeList.get(0), totalExpectedGroupByCount);\n+        RuleAssembler assembler = getRuleAssemblerForFirstNode(totalExpectedGroupByCount);\n         for (int i = 1; i < nodeList.size(); i++) {\n-            builder = builder.andThen(nodeList.get(i));\n+            ConstraintGraphNode nextNode = nodeList.get(i);\n+            assembler = assembler.andThen(nextNode);\n+        }\n+        return assembler;\n+    }\n+\n+    private RuleAssembler getRuleAssemblerForFirstNode(int totalExpectedGroupByCount) {\n+        ConstraintGraphNode firstNode = nodeList.get(0);\n+        if (isJoin) {\n+            RuleAssembler left = leftSubTree.getRuleAssembler(totalExpectedGroupByCount);\n+            RuleAssembler right = rightSubTree.getRuleAssembler(totalExpectedGroupByCount);\n+            return left.join(right, firstNode);\n+        } else {\n+            return RuleAssembler.from(variableFactory, firstNode, totalExpectedGroupByCount);\n         }\n-        return builder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ca9f2e9380de89d99e08a91df9d102231e1ba40"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjY4Nzc0OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/rules/UniGroupBy2Map0CollectMutator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowNToxNFrOH8uDWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowNToxNFrOH8uDWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzMTEzMA==", "bodyText": "This is \"the meat\" of the PR. Trivial typo fix.", "url": "https://github.com/kiegroup/optaplanner/pull/1056#discussion_r533431130", "createdAt": "2020-12-01T14:05:14Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/rules/UniGroupBy2Map0CollectMutator.java", "diffHunk": "@@ -35,12 +35,12 @@ public UniGroupBy2Map0CollectMutator(Function<A, NewA> groupKeyMappingA, Functio\n \n     @Override\n     public AbstractRuleAssembler apply(AbstractRuleAssembler ruleAssembler) {\n-        BiConsumer<PatternDef, Variable<NewA>> binder = (pattern, tuple) -> pattern.bind(tuple, a -> {\n+        BiConsumer<PatternDef, Variable<BiTuple<NewA, NewB>>> binder = (pattern, tuple) -> pattern.bind(tuple, a -> {\n             final NewA newA = groupKeyMappingA.apply((A) a);\n             final NewB newB = groupKeyMappingB.apply((A) a);\n             return new BiTuple<>(newA, newB);\n         });\n         return universalGroup(ruleAssembler, binder,\n-                (var, pattern, accumulate) -> regroup(ruleAssembler, var, pattern, accumulate));\n+                (variable, pattern, accumulate) -> regroupBi(ruleAssembler, variable, pattern, accumulate));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ca9f2e9380de89d99e08a91df9d102231e1ba40"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4172, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}