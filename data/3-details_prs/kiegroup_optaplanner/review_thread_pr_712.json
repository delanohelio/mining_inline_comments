{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzMDc2Mjc0", "number": 712, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjo1MToyMFrODk2GwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMTozMDozN1rODmP5UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5OTYxNzkyOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/DroolsConstraintSessionFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjo1MToyMFrOFxZioQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjo1MToyMFrOFxZioQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0MzAwOQ==", "bodyText": "I'll refactor this to disabledConstraintIdSet - that will cause less operations with the collection, and therefore perform better.", "url": "https://github.com/kiegroup/optaplanner/pull/712#discussion_r387343009", "createdAt": "2020-03-03T22:51:20Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/DroolsConstraintSessionFactory.java", "diffHunk": "@@ -42,30 +49,65 @@\n public class DroolsConstraintSessionFactory<Solution_> implements ConstraintSessionFactory<Solution_> {\n \n     private final SolutionDescriptor<Solution_> solutionDescriptor;\n-    private final KieBase kieBase;\n-    private final Map<Rule, DroolsConstraint<Solution_>> constraints;\n+    private final Model originalModel;\n+    private KieBase originalKieBase;\n+    private KieBase activeKieBase;\n+    private Set<String> activeConstraintIdSet = null;\n+    private final Map<Rule, DroolsConstraint<Solution_>> compiledRuleToConstraintMap;\n+    private final Map<String, org.drools.model.Rule> constraintToModelRuleMap;\n \n-    public DroolsConstraintSessionFactory(SolutionDescriptor<Solution_> solutionDescriptor, KieBase kieBase,\n+    public DroolsConstraintSessionFactory(SolutionDescriptor<Solution_> solutionDescriptor, Model model,\n             List<DroolsConstraint<Solution_>> constraintList) {\n         this.solutionDescriptor = solutionDescriptor;\n-        this.kieBase = kieBase;\n-        this.constraints = constraintList.stream()\n-                .collect(toMap(constraint -> kieBase.getRule(constraint.getConstraintPackage(),\n+        this.originalModel = model;\n+        this.originalKieBase = KieBaseBuilder.createKieBaseFromModel(model);\n+        this.activeKieBase = originalKieBase;\n+        this.compiledRuleToConstraintMap = constraintList.stream()\n+                .collect(toMap(constraint -> activeKieBase.getRule(constraint.getConstraintPackage(),\n                         constraint.getConstraintName()), Function.identity()));\n+        this.constraintToModelRuleMap = constraintList.stream()\n+                .collect(toMap(Constraint::getConstraintId, constraint -> model.getRules().stream()\n+                        .filter(rule -> Objects.equals(rule.getName(), constraint.getConstraintName()))\n+                        .filter(rule -> Objects.equals(rule.getPackage(), constraint.getConstraintPackage()))\n+                        .findFirst()\n+                        .orElseThrow(() -> new IllegalStateException(\"Programming error: Rule for constraint (\" +\n+                                constraint + \") not found.\"))));\n     }\n \n     @Override\n     public ConstraintSession<Solution_> buildSession(boolean constraintMatchEnabled, Solution_ workingSolution) {\n         ScoreDefinition scoreDefinition = solutionDescriptor.getScoreDefinition();\n         AbstractScoreHolder scoreHolder = (AbstractScoreHolder) scoreDefinition.buildScoreHolder(constraintMatchEnabled);\n         scoreHolder.setJustificationListConverter((justificationList, rule) ->\n-                matchJustificationsToOutput((List<Object>) justificationList, constraints.get(rule).getExpectedJustificationTypes()));\n-        constraints.forEach((rule, constraint) -> scoreHolder.configureConstraintWeight(rule,\n-                constraint.extractConstraintWeight(workingSolution)));\n-        KieSession kieSession = kieBase.newKieSession();\n-        ((RuleEventManager) kieSession).addEventListener(new OptaPlannerRuleEventListener()); // Enables undo in rules\n+                matchJustificationsToOutput((List<Object>) justificationList,\n+                        compiledRuleToConstraintMap.get(rule).getExpectedJustificationTypes()));\n+        // Determine which rules to enable based on the fact that their constraints carry weight.\n+        Score<?> zero = scoreDefinition.getZeroScore();\n+        Set<String> enabledConstraintIdSet = new LinkedHashSet<>(compiledRuleToConstraintMap.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "606cb28e9d74d1f9326350df9e657acd6cf88eec"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNDMxNzc4OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetScoringBiConstraintStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMToyNjoyNFrOFzjZpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMToyOTowMlrOFzjePA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwMTcwMQ==", "bodyText": "Soft: might be worth extracting a NO_OP_UNDO into AbstractConstraintStream?", "url": "https://github.com/kiegroup/optaplanner/pull/712#discussion_r389601701", "createdAt": "2020-03-09T11:26:24Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetScoringBiConstraintStream.java", "diffHunk": "@@ -113,6 +113,9 @@ private BavetScoringBiConstraintStream(BavetConstraintFactory<Solution_> constra\n             if (intMatchWeigher != null) {\n                 scoreImpacter = (A a, B b, Consumer<Score<?>> matchScoreConsumer) -> {\n                     int matchWeight = intMatchWeigher.applyAsInt(a, b);\n+                    if (matchWeight == 0) { // No need to include and no need to undo later.\n+                        return () -> { /* NOOP */ };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2e006390396d70576ef718c73f75a439845dd0a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwMjg3Ng==", "bodyText": "I still wonder if it shouldn't fail fast if the matchWeight is zero.\nActually, thinking about this more - we probably want to have the indictment anyway, even if the matchWeigh is zero...  even if it's just for debugging purposes - for easy of debugging. Let's discuss.", "url": "https://github.com/kiegroup/optaplanner/pull/712#discussion_r389602876", "createdAt": "2020-03-09T11:29:02Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetScoringBiConstraintStream.java", "diffHunk": "@@ -113,6 +113,9 @@ private BavetScoringBiConstraintStream(BavetConstraintFactory<Solution_> constra\n             if (intMatchWeigher != null) {\n                 scoreImpacter = (A a, B b, Consumer<Score<?>> matchScoreConsumer) -> {\n                     int matchWeight = intMatchWeigher.applyAsInt(a, b);\n+                    if (matchWeight == 0) { // No need to include and no need to undo later.\n+                        return () -> { /* NOOP */ };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwMTcwMQ=="}, "originalCommit": {"oid": "f2e006390396d70576ef718c73f75a439845dd0a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNDMyOTEyOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/DroolsCondition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMTozMDozN1rOFzjguQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMTozMDozN1rOFzjguQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwMzUxMw==", "bodyText": "Same here: if a matchWeigth is zero, it probably shouldn't disable the indictment. For clarity: If the constraintWeight is zero, it should (and the entire constraint execution too, as it does in the rest of this PR).", "url": "https://github.com/kiegroup/optaplanner/pull/712#discussion_r389603513", "createdAt": "2020-03-09T11:30:37Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/DroolsCondition.java", "diffHunk": "@@ -175,20 +175,29 @@ protected DroolsCondition(T ruleStructure) {\n \n     protected <S extends Score<S>, H extends AbstractScoreHolder<S>> void impactScore(DroolsConstraint<?> constraint,\n             Drools drools, H scoreHolder, int impact) {\n+        if (impact == 0) { // No need to include and no need to undo later.\n+            return;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2e006390396d70576ef718c73f75a439845dd0a"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4449, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}