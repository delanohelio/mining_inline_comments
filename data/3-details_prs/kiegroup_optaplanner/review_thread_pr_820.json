{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyNjAyNTMw", "number": 820, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDoyNzoxM1rOEKdFYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoyNDowM1rOEPcbMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Mzk3NzMxOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/DroolsConstraint.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDoyNzoxM1rOGrgLTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDoyNzoxM1rOGrgLTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI2OTEzNA==", "bodyText": "The only use of fromStreamList() was in this toString().\nTherefore I removed it.", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r448269134", "createdAt": "2020-07-01T10:27:13Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/DroolsConstraint.java", "diffHunk": "@@ -77,6 +72,6 @@ public int getExpectedJustificationCount() {\n \n     @Override\n     public String toString() {\n-        return \"DroolsConstraint(\" + getConstraintId() + \") in \" + fromStreamList.size() + \" from() stream(s)\";\n+        return \"DroolsConstraint(\" + getConstraintId() + \")\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8af3252acc12eca9501af6010c8bbb31ebe6608a"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjI0NjY5OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/DroolsConstraintSessionFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODowODo1NVrOGzJlcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODo0NTowM1rOGzKw9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI4NzYwMg==", "bodyText": "Where do these classNames come from?\nWhy are we receiving them as Strings?", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456287602", "createdAt": "2020-07-17T08:08:55Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/DroolsConstraintSessionFactory.java", "diffHunk": "@@ -70,50 +72,20 @@ public DroolsConstraintSessionFactory(SolutionDescriptor<Solution_> solutionDesc\n                         .findFirst()\n                         .orElseThrow(() -> new IllegalStateException(\"Programming error: Rule for constraint (\" +\n                                 constraint + \") not found.\"))));\n-    }\n-\n-    @Override\n-    public ConstraintSession<Solution_> buildSession(boolean constraintMatchEnabled, Solution_ workingSolution) {\n-        // Make sure the constraint justifications match what comes out of Bavet.\n-        AbstractScoreHolder scoreHolder = getScoreDefinition().buildScoreHolder(constraintMatchEnabled);\n-        scoreHolder.setJustificationListConverter(\n-                (justificationList, rule) -> {\n-                    DroolsConstraint<Solution_> constraint = compiledRuleToConstraintMap.get(rule);\n-                    return matchJustificationsToOutput((List<Object>) justificationList,\n-                            constraint.getExpectedJustificationCount(),\n-                            constraint.getExpectedJustificationTypes());\n-                });\n-        // Determine which rules to enable based on the fact that their constraints carry weight.\n-        Score<?> zeroScore = getScoreDefinition().getZeroScore();\n-        Set<String> disabledConstraintIdSet = new LinkedHashSet<>(0);\n-        compiledRuleToConstraintMap.forEach((compiledRule, constraint) -> {\n-            Score<?> constraintWeight = constraint.extractConstraintWeight(workingSolution);\n-            scoreHolder.configureConstraintWeight(compiledRule, constraintWeight);\n-            if (constraintWeight.equals(zeroScore)) {\n-                disabledConstraintIdSet.add(constraint.getConstraintId());\n-            }\n-        });\n-        // Determine the KieBase to use.\n-        if (disabledConstraintIdSet.isEmpty()) { // Shortcut; don't change the original KieBase.\n-            currentKieBase = originalKieBase;\n-            currentlyDisabledConstraintIdSet = null;\n-        } else if (!disabledConstraintIdSet.equals(currentlyDisabledConstraintIdSet)) {\n-            // Only rebuild the active KieBase when the set of disabled constraints changed.\n-            ModelImpl model = new ModelImpl().withGlobals(originalModel.getGlobals());\n-            constraintToModelRuleMap.forEach((constraintId, modelRule) -> {\n-                if (disabledConstraintIdSet.contains(constraintId)) {\n-                    return;\n-                }\n-                model.addRule(modelRule);\n-            });\n-            currentKieBase = KieBaseBuilder.createKieBaseFromModel(model);\n-            currentlyDisabledConstraintIdSet = disabledConstraintIdSet;\n-        }\n-        // Create the session itself.\n-        KieSession kieSession = currentKieBase.newKieSession();\n-        ((RuleEventManager) kieSession).addEventListener(new OptaPlannerRuleEventListener()); // Enables undo in rules.\n-        kieSession.setGlobal(DroolsScoreDirector.GLOBAL_SCORE_HOLDER_KEY, scoreHolder);\n-        return new DroolsConstraintSession<>(kieSession, scoreHolder);\n+        this.compiledRuleToExpectedTypesMap = compiledRuleToConstraintMap.keySet().stream()\n+                .collect(Collectors.toMap(Function.identity(), rule -> {\n+                    String commaSeparatedFqnList = (String) rule.getMetaData().getOrDefault(\n+                            RuleAssembler.VARIABLE_TYPE_RULE_METADATA_KEY, \"\");\n+                    return Arrays.stream(commaSeparatedFqnList.split(\"\\\\Q,\\\\E\"))\n+                            .map(className -> {\n+                                try {\n+                                    return Class.forName(className.trim());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cae85a6935e468bddde8164db34bf2fff0ab7e92"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwNjkzNA==", "bodyText": "It comes from here: https://github.com/kiegroup/optaplanner/pull/820/files#diff-ebd21b451df70a2dceb49bbea389ef3eR196\nIt's a way of bypassing several levels of class hierarchy and the breaking of abstraction that it would cause.\nI'll try once more to figure out a way to do it in a cleaner way, but I was already unsuccessful the first time around.", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456306934", "createdAt": "2020-07-17T08:45:03Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/DroolsConstraintSessionFactory.java", "diffHunk": "@@ -70,50 +72,20 @@ public DroolsConstraintSessionFactory(SolutionDescriptor<Solution_> solutionDesc\n                         .findFirst()\n                         .orElseThrow(() -> new IllegalStateException(\"Programming error: Rule for constraint (\" +\n                                 constraint + \") not found.\"))));\n-    }\n-\n-    @Override\n-    public ConstraintSession<Solution_> buildSession(boolean constraintMatchEnabled, Solution_ workingSolution) {\n-        // Make sure the constraint justifications match what comes out of Bavet.\n-        AbstractScoreHolder scoreHolder = getScoreDefinition().buildScoreHolder(constraintMatchEnabled);\n-        scoreHolder.setJustificationListConverter(\n-                (justificationList, rule) -> {\n-                    DroolsConstraint<Solution_> constraint = compiledRuleToConstraintMap.get(rule);\n-                    return matchJustificationsToOutput((List<Object>) justificationList,\n-                            constraint.getExpectedJustificationCount(),\n-                            constraint.getExpectedJustificationTypes());\n-                });\n-        // Determine which rules to enable based on the fact that their constraints carry weight.\n-        Score<?> zeroScore = getScoreDefinition().getZeroScore();\n-        Set<String> disabledConstraintIdSet = new LinkedHashSet<>(0);\n-        compiledRuleToConstraintMap.forEach((compiledRule, constraint) -> {\n-            Score<?> constraintWeight = constraint.extractConstraintWeight(workingSolution);\n-            scoreHolder.configureConstraintWeight(compiledRule, constraintWeight);\n-            if (constraintWeight.equals(zeroScore)) {\n-                disabledConstraintIdSet.add(constraint.getConstraintId());\n-            }\n-        });\n-        // Determine the KieBase to use.\n-        if (disabledConstraintIdSet.isEmpty()) { // Shortcut; don't change the original KieBase.\n-            currentKieBase = originalKieBase;\n-            currentlyDisabledConstraintIdSet = null;\n-        } else if (!disabledConstraintIdSet.equals(currentlyDisabledConstraintIdSet)) {\n-            // Only rebuild the active KieBase when the set of disabled constraints changed.\n-            ModelImpl model = new ModelImpl().withGlobals(originalModel.getGlobals());\n-            constraintToModelRuleMap.forEach((constraintId, modelRule) -> {\n-                if (disabledConstraintIdSet.contains(constraintId)) {\n-                    return;\n-                }\n-                model.addRule(modelRule);\n-            });\n-            currentKieBase = KieBaseBuilder.createKieBaseFromModel(model);\n-            currentlyDisabledConstraintIdSet = disabledConstraintIdSet;\n-        }\n-        // Create the session itself.\n-        KieSession kieSession = currentKieBase.newKieSession();\n-        ((RuleEventManager) kieSession).addEventListener(new OptaPlannerRuleEventListener()); // Enables undo in rules.\n-        kieSession.setGlobal(DroolsScoreDirector.GLOBAL_SCORE_HOLDER_KEY, scoreHolder);\n-        return new DroolsConstraintSession<>(kieSession, scoreHolder);\n+        this.compiledRuleToExpectedTypesMap = compiledRuleToConstraintMap.keySet().stream()\n+                .collect(Collectors.toMap(Function.identity(), rule -> {\n+                    String commaSeparatedFqnList = (String) rule.getMetaData().getOrDefault(\n+                            RuleAssembler.VARIABLE_TYPE_RULE_METADATA_KEY, \"\");\n+                    return Arrays.stream(commaSeparatedFqnList.split(\"\\\\Q,\\\\E\"))\n+                            .map(className -> {\n+                                try {\n+                                    return Class.forName(className.trim());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI4NzYwMg=="}, "originalCommit": {"oid": "cae85a6935e468bddde8164db34bf2fff0ab7e92"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjI2MTk3OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/ConstraintSubTree.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoxMzo0M1rOGzJu7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODo0MjoxMlrOGzKq7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MDAyOQ==", "bodyText": "Can the user trigger this error?\nIf not, prefix the error message with \"Impossible state\", so for example \"Impossible state: the nodeList must not be empty.\" It signals that we're 100% sure that if any user sees this, it is an OptaPlanner bug, never their fault.", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456290029", "createdAt": "2020-07-17T08:13:43Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/ConstraintSubTree.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common;\n+\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.FROM;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.GROUPBY_COLLECTING_ONLY;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.GROUPBY_MAPPING_AND_COLLECTING;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.GROUPBY_MAPPING_ONLY;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.JOIN;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNode;\n+import org.optaplanner.core.impl.score.stream.drools.common.rules.RuleAssembler;\n+\n+final class ConstraintSubTree {\n+\n+    private final boolean isJoin;\n+    private final ConstraintSubTree leftSubTree;\n+    private final ConstraintSubTree rightSubTree;\n+    private final List<ConstraintGraphNode> nodes;\n+\n+    public ConstraintSubTree(List<ConstraintGraphNode> nodesWithoutJoin) {\n+        this.isJoin = false;\n+        this.leftSubTree = null;\n+        this.rightSubTree = null;\n+        this.nodes = Collections.unmodifiableList(nodesWithoutJoin);\n+        if (nodes.isEmpty()) {\n+            throw new IllegalStateException(\"Node list may not be empty.\");\n+        }\n+        if (nodes.get(0).getType() != FROM) {\n+            throw new IllegalStateException(\"First node is not a From (\" + nodes.get(0) + \").\");\n+        }\n+    }\n+\n+    public ConstraintSubTree(ConstraintSubTree leftSubTree, ConstraintSubTree rightSubTree,\n+            List<ConstraintGraphNode> joinAndOtherNodes) {\n+        this.isJoin = true;\n+        this.leftSubTree = Objects.requireNonNull(leftSubTree);\n+        this.rightSubTree = Objects.requireNonNull(rightSubTree);\n+        this.nodes = Collections.unmodifiableList(joinAndOtherNodes);\n+        if (nodes.isEmpty()) {\n+            throw new IllegalStateException(\"Node list may not be empty.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cae85a6935e468bddde8164db34bf2fff0ab7e92"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwNTM5MQ==", "bodyText": "Yeah, there will be more places like that in this code. I'll go over it again.", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456305391", "createdAt": "2020-07-17T08:42:12Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/ConstraintSubTree.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common;\n+\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.FROM;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.GROUPBY_COLLECTING_ONLY;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.GROUPBY_MAPPING_AND_COLLECTING;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.GROUPBY_MAPPING_ONLY;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.JOIN;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNode;\n+import org.optaplanner.core.impl.score.stream.drools.common.rules.RuleAssembler;\n+\n+final class ConstraintSubTree {\n+\n+    private final boolean isJoin;\n+    private final ConstraintSubTree leftSubTree;\n+    private final ConstraintSubTree rightSubTree;\n+    private final List<ConstraintGraphNode> nodes;\n+\n+    public ConstraintSubTree(List<ConstraintGraphNode> nodesWithoutJoin) {\n+        this.isJoin = false;\n+        this.leftSubTree = null;\n+        this.rightSubTree = null;\n+        this.nodes = Collections.unmodifiableList(nodesWithoutJoin);\n+        if (nodes.isEmpty()) {\n+            throw new IllegalStateException(\"Node list may not be empty.\");\n+        }\n+        if (nodes.get(0).getType() != FROM) {\n+            throw new IllegalStateException(\"First node is not a From (\" + nodes.get(0) + \").\");\n+        }\n+    }\n+\n+    public ConstraintSubTree(ConstraintSubTree leftSubTree, ConstraintSubTree rightSubTree,\n+            List<ConstraintGraphNode> joinAndOtherNodes) {\n+        this.isJoin = true;\n+        this.leftSubTree = Objects.requireNonNull(leftSubTree);\n+        this.rightSubTree = Objects.requireNonNull(rightSubTree);\n+        this.nodes = Collections.unmodifiableList(joinAndOtherNodes);\n+        if (nodes.isEmpty()) {\n+            throw new IllegalStateException(\"Node list may not be empty.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MDAyOQ=="}, "originalCommit": {"oid": "cae85a6935e468bddde8164db34bf2fff0ab7e92"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjI2NDIyOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/ConstraintSubTree.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoxNDoyNVrOGzJwVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoxNDoyNVrOGzJwVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MDM4OA==", "bodyText": "nodeList for consistency with all other code? :)", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456290388", "createdAt": "2020-07-17T08:14:25Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/ConstraintSubTree.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common;\n+\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.FROM;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.GROUPBY_COLLECTING_ONLY;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.GROUPBY_MAPPING_AND_COLLECTING;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.GROUPBY_MAPPING_ONLY;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.JOIN;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNode;\n+import org.optaplanner.core.impl.score.stream.drools.common.rules.RuleAssembler;\n+\n+final class ConstraintSubTree {\n+\n+    private final boolean isJoin;\n+    private final ConstraintSubTree leftSubTree;\n+    private final ConstraintSubTree rightSubTree;\n+    private final List<ConstraintGraphNode> nodes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cae85a6935e468bddde8164db34bf2fff0ab7e92"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjI2OTc3OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/ConstraintTree.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoxNTo1OFrOGzJzqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoxNTo1OFrOGzJzqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MTI0Mg==", "bodyText": "Stack is a relic from Java 1.0, just like Vector.\nVector was replaced by (Array)List\nStack was replaced by (Array)Deque", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456291242", "createdAt": "2020-07-17T08:15:58Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/ConstraintTree.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Stack;\n+\n+import org.optaplanner.core.impl.score.stream.drools.common.consequences.ConstraintConsequence;\n+import org.optaplanner.core.impl.score.stream.drools.common.nodes.ChildNode;\n+import org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNode;\n+import org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType;\n+\n+final class ConstraintTree<Node_ extends ConstraintGraphNode, Consequence_ extends ConstraintConsequence<Node_>> {\n+\n+    private final ConstraintSubTree nestedNodes;\n+\n+    ConstraintTree(Consequence_ consequence) {\n+        List<ConstraintGraphNode> orderedNodeList = orderNodes(consequence);\n+        this.nestedNodes = assembleSubTree(orderedNodeList);\n+        ConstraintGraphNode firstNode = orderedNodeList.get(0);\n+        if (firstNode.getType() != ConstraintGraphNodeType.FROM) {\n+            throw new IllegalStateException(\"First node (\" + firstNode + \") is not a \" + ConstraintGraphNodeType.FROM +\n+                    \" (\" + firstNode.getType() + \").\");\n+        }\n+        ConstraintGraphNode lastNode = orderedNodeList.get(orderedNodeList.size() - 1);\n+        if (lastNode != consequence.getTerminalNode()) {\n+            throw new IllegalStateException(\"Last node (\" + lastNode + \") is not the terminal node (\" +\n+                    consequence.getTerminalNode() + \").\");\n+        }\n+    }\n+\n+    private List<ConstraintGraphNode> orderNodes(Consequence_ consequence) {\n+        // Depth-first search, right parents of join nodes get precedence.\n+        List<ConstraintGraphNode> nodeList = new ArrayList<>(0);\n+        Stack<ConstraintGraphNode> unprocessedNodes = new Stack<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cae85a6935e468bddde8164db34bf2fff0ab7e92"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjI4MDY1OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/rules/AbstractGroupByMutator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoxOTowOVrOGzJ6GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoxOTowOVrOGzJ6GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5Mjg4OQ==", "bodyText": "Seems a bit fishy: A list (naming btw) that is converted into an array that is then copied partially", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456292889", "createdAt": "2020-07-17T08:19:09Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/rules/AbstractGroupByMutator.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common.rules;\n+\n+import static java.util.Arrays.copyOfRange;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static org.drools.model.DSL.accFunction;\n+import static org.drools.model.PatternDSL.alphaIndexedBy;\n+import static org.drools.model.PatternDSL.pattern;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import org.drools.model.DSL;\n+import org.drools.model.Index;\n+import org.drools.model.PatternDSL;\n+import org.drools.model.PatternDSL.PatternDef;\n+import org.drools.model.Variable;\n+import org.drools.model.view.ViewItem;\n+import org.optaplanner.core.api.function.TriFunction;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.DroolsAbstractAccumulateFunction;\n+import org.optaplanner.core.impl.score.stream.drools.common.DroolsAbstractGroupByAccumulator;\n+import org.optaplanner.core.impl.score.stream.drools.common.FactTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.TriTuple;\n+\n+abstract class AbstractGroupByMutator implements Mutator {\n+\n+    protected abstract <InTuple> PatternDef bindTupleVariableOnFirstGrouping(AbstractRuleAssembler ruleAssembler,\n+            PatternDef pattern, Variable<InTuple> tupleVariable);\n+\n+    protected ViewItem<?> getInnerAccumulatePattern(AbstractRuleAssembler ruleAssembler) {\n+        List<ViewItem> allPatterns = new ArrayList<>();\n+        for (int i = 0; i < ruleAssembler.getPrimaryPatterns().size(); i++) {\n+            allPatterns.add(ruleAssembler.getPrimaryPatterns().get(i));\n+            allPatterns.addAll(ruleAssembler.getDependentExpressionMap().getOrDefault(i, Collections.emptyList()));\n+        }\n+        ViewItem[] items = allPatterns.toArray(new ViewItem[0]);\n+        return PatternDSL.and(items[0], copyOfRange(items, 1, items.length));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cae85a6935e468bddde8164db34bf2fff0ab7e92"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjI5Mjg2OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/rules/TriExistenceMutator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoyMjozOFrOGzKBZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoyMjozOFrOGzKBZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NDc1Nw==", "bodyText": "comment code style: avoid \"we\" and \"you\" just like docs -> \"Merge all filters into on to avoid paying the penalty for ...\"\nMotivation: by always writing in the same style, it's easier to switch back and forth between docs, blogs and comments. It's also a better writting style.", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456294757", "createdAt": "2020-07-17T08:22:38Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/rules/TriExistenceMutator.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common.rules;\n+\n+import java.util.Arrays;\n+\n+import org.drools.model.PatternDSL;\n+import org.drools.model.Variable;\n+import org.drools.model.view.ExprViewItem;\n+import org.optaplanner.core.api.function.QuadPredicate;\n+import org.optaplanner.core.impl.score.stream.drools.common.nodes.AbstractConstraintModelJoiningNode;\n+import org.optaplanner.core.impl.score.stream.quad.AbstractQuadJoiner;\n+import org.optaplanner.core.impl.score.stream.quad.FilteringQuadJoiner;\n+import org.optaplanner.core.impl.score.stream.quad.NoneQuadJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.NoneTriJoiner;\n+\n+final class TriExistenceMutator<A, B, C, D> implements Mutator {\n+\n+    private final boolean shouldExist;\n+    private final Class<D> otherFactType;\n+    private final AbstractQuadJoiner<A, B, C, D>[] joiners;\n+\n+    public TriExistenceMutator(AbstractConstraintModelJoiningNode<D, AbstractQuadJoiner<A, B, C, D>> node,\n+            boolean shouldExist) {\n+        this.shouldExist = shouldExist;\n+        this.otherFactType = node.getOtherFactType();\n+        this.joiners = node.get().stream()\n+                .toArray(AbstractQuadJoiner[]::new);\n+    }\n+\n+    private AbstractRuleAssembler applyJoiners(AbstractRuleAssembler ruleAssembler, AbstractQuadJoiner<A, B, C, D> joiner,\n+            QuadPredicate<A, B, C, D> predicate) {\n+        if (joiner == null) {\n+            return applyFilters(ruleAssembler, predicate);\n+        }\n+        // There is no delta index in Drools, therefore we replace joining with a filter.\n+        QuadPredicate<A, B, C, D> joinFilter = joiner::matches;\n+        QuadPredicate<A, B, C, D> result = predicate == null ? joinFilter : joinFilter.and(predicate);\n+        // And finally we add the filter to the D pattern,\n+        return applyFilters(ruleAssembler, result);\n+    }\n+\n+    private AbstractRuleAssembler applyFilters(AbstractRuleAssembler ruleAssembler, QuadPredicate<A, B, C, D> predicate) {\n+        Variable<D> toExist = PatternDSL.declarationOf(otherFactType, ruleAssembler.generateNextId(\"triToExist\"));\n+        PatternDSL.PatternDef<D> existencePattern = PatternDSL.pattern(toExist);\n+        PatternDSL.PatternDef<D> possiblyFilteredExistencePattern = predicate == null ? existencePattern\n+                : existencePattern.expr(\"Filter using \" + predicate, ruleAssembler.getVariable(0),\n+                        ruleAssembler.getVariable(1), ruleAssembler.getVariable(2),\n+                        (d, a, b, c) -> predicate.test((A) a, (B) b, (C) c, d));\n+        ExprViewItem existenceExpression = PatternDSL.exists(possiblyFilteredExistencePattern);\n+        if (!shouldExist) {\n+            existenceExpression = PatternDSL.not(possiblyFilteredExistencePattern);\n+        }\n+        ruleAssembler.addDependentExpressionToLastPattern(existenceExpression);\n+        return ruleAssembler;\n+    }\n+\n+    @Override\n+    public AbstractRuleAssembler apply(AbstractRuleAssembler ruleAssembler) {\n+        int indexOfFirstFilter = -1;\n+        // Prepare the joiner and filter that will be used in the pattern\n+        AbstractQuadJoiner<A, B, C, D> finalJoiner = null;\n+        QuadPredicate<A, B, C, D> finalFilter = null;\n+        for (int i = 0; i < joiners.length; i++) {\n+            AbstractQuadJoiner<A, B, C, D> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof NoneQuadJoiner && joiners.length > 1) {\n+                throw new IllegalStateException(\"If present, \" + NoneTriJoiner.class + \" must be the only joiner, got \"\n+                        + Arrays.toString(joiners) + \" instead.\");\n+            } else if (!(joiner instanceof FilteringQuadJoiner)) {\n+                if (hasAFilter) {\n+                    throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                            + joiners[indexOfFirstFilter] + \").\");\n+                } else { // Merge this Joiner with the existing Joiners.\n+                    finalJoiner = finalJoiner == null ? joiner : AbstractQuadJoiner.merge(finalJoiner, joiner);\n+                }\n+            } else {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+                // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cae85a6935e468bddde8164db34bf2fff0ab7e92"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjI5ODA4OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStreamTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoyNDowM1rOGzKEgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODo0MTozNFrOGzKptQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NTU1Mw==", "bodyText": "Seems wierd, because the argument returns \"1\", so it's impact isn't asserted. Does it work without that extra argument?", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456295553", "createdAt": "2020-07-17T08:24:03Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStreamTest.java", "diffHunk": "@@ -1388,7 +1388,7 @@ public void globalNodeOrder() {\n                     .filter(entity -> entity.getEntityGroup() == entityGroup)\n                     .filter(entity -> entity.getStringProperty().equals(\"MyString1\"))\n                     .join(TestdataLavishEntity.class, equal(TestdataLavishEntity::getIntegerProperty))\n-                    .penalize(TEST_CONSTRAINT_NAME, SimpleScore.ONE);\n+                    .penalize(TEST_CONSTRAINT_NAME, SimpleScore.ONE, (a, b) -> 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cae85a6935e468bddde8164db34bf2fff0ab7e92"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwNTA3Nw==", "bodyText": "That's a leftover from debugging. Yes, it works, will remove.", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456305077", "createdAt": "2020-07-17T08:41:34Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStreamTest.java", "diffHunk": "@@ -1388,7 +1388,7 @@ public void globalNodeOrder() {\n                     .filter(entity -> entity.getEntityGroup() == entityGroup)\n                     .filter(entity -> entity.getStringProperty().equals(\"MyString1\"))\n                     .join(TestdataLavishEntity.class, equal(TestdataLavishEntity::getIntegerProperty))\n-                    .penalize(TEST_CONSTRAINT_NAME, SimpleScore.ONE);\n+                    .penalize(TEST_CONSTRAINT_NAME, SimpleScore.ONE, (a, b) -> 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NTU1Mw=="}, "originalCommit": {"oid": "cae85a6935e468bddde8164db34bf2fff0ab7e92"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4332, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}