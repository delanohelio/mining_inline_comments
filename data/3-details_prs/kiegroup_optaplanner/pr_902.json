{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczODA5NDQ5", "number": 902, "title": "PLANNER-2093 Schema Definition for SolverConfig and BenchmarkConfig", "bodyText": "JIRA: PLANNER-2093\nHow to retest or run:\n\n\na pull request please add comment: regex [.*[j|J]enkins,?.*(retest|test) this.*]\n\n\na full downstream build please add comment: regex [.*[j|J]enkins,?.*(execute|run|trigger|start|do) fdb.*]\n\n\na compile downstream build please  add comment: regex [.*[j|J]enkins,?.*(execute|run|trigger|start|do) cdb.*]\n\n\na full production downstream please add comment: regex [.*[j|J]enkins,?.*(execute|run|trigger|start|do) product fdb.*]\n\n\nan upstream build please add comment: regex [.*[j|J]enkins,?.*(execute|run|trigger|start|do) upstream.*]\n\n\ni.e for running a full downstream build =  Jenkins do fdb", "createdAt": "2020-08-26T10:25:45Z", "url": "https://github.com/kiegroup/optaplanner/pull/902", "merged": true, "mergeCommit": {"oid": "1edad31ce23814983604b6b3446ea10c7da4779d"}, "closed": true, "closedAt": "2020-08-27T13:54:46Z", "author": {"login": "rsynek"}, "timelineItems": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdCDtmCAH2gAyNDczODA5NDQ5OjA3MTEwMDE0YTY4NWI0Yzc2OTkzODdlMDI1ZmFjY2QxMTA5NDllZjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdC_VRKABqjM2OTkzMzE1ODg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "07110014a685b4c7699387e025faccd110949ef0", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/07110014a685b4c7699387e025faccd110949ef0", "committedDate": "2020-08-24T14:44:36Z", "message": "PLANNER-2025 Provide XSD for SolverConfig"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6cded8002459bd4e01d1461a36bf4969bbd59e4", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/d6cded8002459bd4e01d1461a36bf4969bbd59e4", "committedDate": "2020-08-24T14:44:36Z", "message": "Remove @SuppressWarning(\"unchecked\")"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0640c8a9394dc4d4220ceb529493fc02feae87f0", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/0640c8a9394dc4d4220ceb529493fc02feae87f0", "committedDate": "2020-08-24T14:44:36Z", "message": "Use return value of requireNonNull()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b47e73cc5ce988063259289d88709bba4d17925", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/2b47e73cc5ce988063259289d88709bba4d17925", "committedDate": "2020-08-25T09:26:31Z", "message": "Resolve conflicts after rebase to master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05ee684d7c9f52e7dd69fd36fa9d98b4523f817f", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/05ee684d7c9f52e7dd69fd36fa9d98b4523f817f", "committedDate": "2020-08-25T13:37:22Z", "message": "PLANNER-2093 Provide XSD for BenchmarkConfig"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9729c7101284a69604836ded4f7181a00c63dae3", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/9729c7101284a69604836ded4f7181a00c63dae3", "committedDate": "2020-08-25T17:59:56Z", "message": "Generate XSD for BenchmarkConfig"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bc25020a35acc4f624fee38fe7cd5e110e4d7ed", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/9bc25020a35acc4f624fee38fe7cd5e110e4d7ed", "committedDate": "2020-08-26T09:20:29Z", "message": "Define explicit element order"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ea6f809b6a37d15539d850751cff6cf6c1a28f8", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/1ea6f809b6a37d15539d850751cff6cf6c1a28f8", "committedDate": "2020-08-26T09:27:05Z", "message": "Rework the IO classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5febe2a653bbc419b8097d28ebaada4abac4701b", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/5febe2a653bbc419b8097d28ebaada4abac4701b", "committedDate": "2020-08-26T10:28:19Z", "message": "Fix incorrect comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e24d05d4d509b2a0eec1d66053d93df660879ef", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/2e24d05d4d509b2a0eec1d66053d93df660879ef", "committedDate": "2020-08-26T12:15:41Z", "message": "Add missing Locale adapter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "829914df7618e2fcf50eea59b0024eb20a74b2cf", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/829914df7618e2fcf50eea59b0024eb20a74b2cf", "committedDate": "2020-08-26T12:19:44Z", "message": "Make naming of JAXB adapters consistent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "533fba3dd24a2e4c872e6a8780ca9ed740f4ed80", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/533fba3dd24a2e4c872e6a8780ca9ed740f4ed80", "committedDate": "2020-08-26T12:29:31Z", "message": "Move JAXB adapters to a subpackage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "865139133529354fcd086b6376470417a27d715f", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/865139133529354fcd086b6376470417a27d715f", "committedDate": "2020-08-26T12:34:21Z", "message": "Simplify comparison of xml content in tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59d6ac7d627fb5955056e737a6acba629d2984bc", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/59d6ac7d627fb5955056e737a6acba629d2984bc", "committedDate": "2020-08-26T12:43:40Z", "message": "Fix a typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69eea1d55a5db4cb1123b6242a368a374e01d142", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/69eea1d55a5db4cb1123b6242a368a374e01d142", "committedDate": "2020-08-26T12:48:48Z", "message": "Remove unnecessary element override"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NDU0ODQ0", "url": "https://github.com/kiegroup/optaplanner/pull/902#pullrequestreview-475454844", "createdAt": "2020-08-26T12:51:45Z", "commit": {"oid": "865139133529354fcd086b6376470417a27d715f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMjo1MTo0NlrOHHKlHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMjo1MTo0NlrOHHKlHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3NTQyMw==", "bodyText": "This is the single namespace we have for both the <solver/> and <benchmark/>.", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r477275423", "createdAt": "2020-08-26T12:51:46Z", "author": {"login": "rsynek"}, "path": "optaplanner-build-parent/pom.xml", "diffHunk": "@@ -840,6 +840,31 @@\n             </execution>\n           </executions>\n         </plugin>\n+        <plugin>\n+          <groupId>org.codehaus.mojo</groupId>\n+          <artifactId>jaxb2-maven-plugin</artifactId>\n+          <version>2.5.0</version>\n+          <executions>\n+            <execution>\n+              <id>schemagen</id>\n+              <goals>\n+                <goal>schemagen</goal>\n+              </goals>\n+            </execution>\n+          </executions>\n+          <configuration>\n+            <clearOutputDir>true</clearOutputDir>\n+            <createJavaDocAnnotations>false</createJavaDocAnnotations>\n+            <generateEpisode>false</generateEpisode>\n+            <outputDirectory>${project.build.outputDirectory}</outputDirectory>\n+            <transformSchemas>\n+              <transformSchema>\n+                <uri>https://www.optaplanner.org/xsd/optaplanner</uri>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865139133529354fcd086b6376470417a27d715f"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59891d9f105a5c630b8c1c5faeb1eba53457e56e", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/59891d9f105a5c630b8c1c5faeb1eba53457e56e", "committedDate": "2020-08-26T12:59:27Z", "message": "Remove incorrect comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NDcyODA2", "url": "https://github.com/kiegroup/optaplanner/pull/902#pullrequestreview-475472806", "createdAt": "2020-08-26T13:12:45Z", "commit": {"oid": "865139133529354fcd086b6376470417a27d715f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzoxMjo0NVrOHHLZgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzoxMjo0NVrOHHLZgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4ODgzMg==", "bodyText": "As we agreed, we don't validate the input solver config XML. We use the validation just in tests to make sure the solver config XML is valid by the generated XSD.", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r477288832", "createdAt": "2020-08-26T13:12:45Z", "author": {"login": "rsynek"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";\n+\n+    private final JAXBContext jaxbContext;\n+    private final Marshaller marshaller;\n+    private final Class<T> rootClass;\n+    private final int indentation;\n+\n+    public GenericJaxbIO(Class<T> rootClass) {\n+        this(rootClass, DEFAULT_INDENTATION);\n+    }\n+\n+    public GenericJaxbIO(Class<T> rootClass, int indentation) {\n+        Objects.requireNonNull(rootClass);\n+        this.rootClass = rootClass;\n+        this.indentation = indentation;\n+        try {\n+            jaxbContext = JAXBContext.newInstance(rootClass);\n+            marshaller = jaxbContext.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            marshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.toString());\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to create JAXB Marshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    @Override\n+    public T read(Reader reader) {\n+        Objects.requireNonNull(reader);\n+        try {\n+            return (T) createUnmarshaller().unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    public T readAndValidate(Reader reader, String schemaResource) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865139133529354fcd086b6376470417a27d715f"}, "originalPosition": 104}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83be25dec1cb097837f99797cf198a63fc1dd22a", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/83be25dec1cb097837f99797cf198a63fc1dd22a", "committedDate": "2020-08-26T13:13:37Z", "message": "Improve javadoc comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1627e2b4475ff47fcbc72eb97da9bec060e65ca", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/d1627e2b4475ff47fcbc72eb97da9bec060e65ca", "committedDate": "2020-08-26T13:15:56Z", "message": "Make a nested class final"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b9fec6b4c18d7fb38b9dd9c09a8517eb7238875", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/3b9fec6b4c18d7fb38b9dd9c09a8517eb7238875", "committedDate": "2020-08-26T13:21:36Z", "message": "Move adapter tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/1d0bed8beead1d5dbf6e20bd8eb5556f77321596", "committedDate": "2020-08-26T13:23:40Z", "message": "Update revapi config"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NTE0OTIy", "url": "https://github.com/kiegroup/optaplanner/pull/902#pullrequestreview-475514922", "createdAt": "2020-08-26T13:56:17Z", "commit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTU5MTI2", "url": "https://github.com/kiegroup/optaplanner/pull/902#pullrequestreview-476559126", "createdAt": "2020-08-27T09:48:17Z", "commit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOTo0ODoxN1rOHIIyTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOTo0ODoxN1rOHIIyTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI5NDYwNw==", "bodyText": "soft: I think putting error messages in a constant - if it's only used once - is a form of unneeded indirection, making the code harder to read (code is read 10 times more than it it written) because it reduces \"vertical density\" (that which belongs together is together).\nIn this case, the ERR_MSG_READ is used more than once, but that's often a sign that multiple different error causes are being reported as the same error, providing less information to the user. See examples below.", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478294607", "createdAt": "2020-08-27T09:48:17Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTYwNjkx", "url": "https://github.com/kiegroup/optaplanner/pull/902#pullrequestreview-476560691", "createdAt": "2020-08-27T09:50:28Z", "commit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOTo1MDoyOFrOHII3HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOTo1MDoyOFrOHII3HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI5NTgzNw==", "bodyText": "DRY with the first few lines of write(T root, Writer writer).", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478295837", "createdAt": "2020-08-27T09:50:28Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";\n+\n+    private final JAXBContext jaxbContext;\n+    private final Marshaller marshaller;\n+    private final Class<T> rootClass;\n+    private final int indentation;\n+\n+    public GenericJaxbIO(Class<T> rootClass) {\n+        this(rootClass, DEFAULT_INDENTATION);\n+    }\n+\n+    public GenericJaxbIO(Class<T> rootClass, int indentation) {\n+        Objects.requireNonNull(rootClass);\n+        this.rootClass = rootClass;\n+        this.indentation = indentation;\n+        try {\n+            jaxbContext = JAXBContext.newInstance(rootClass);\n+            marshaller = jaxbContext.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            marshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.toString());\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to create JAXB Marshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    @Override\n+    public T read(Reader reader) {\n+        Objects.requireNonNull(reader);\n+        try {\n+            return (T) createUnmarshaller().unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    public T readAndValidate(Reader reader, String schemaResource) {\n+        Objects.requireNonNull(reader);\n+        String nonNullSchemaResource = Objects.requireNonNull(schemaResource);\n+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        Schema schema;\n+        try {\n+            schema = schemaFactory.newSchema(GenericJaxbIO.class.getResource(nonNullSchemaResource));\n+        } catch (SAXException e) {\n+            throw new IllegalArgumentException(\"Unable to read input schema resource (\" + nonNullSchemaResource + \")\", e);\n+        }\n+\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        unmarshaller.setSchema(schema);\n+        ValidationEventStringCollector validationEventHandler = new ValidationEventStringCollector();\n+\n+        try {\n+            unmarshaller.setEventHandler(validationEventHandler);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to set validation event handler to the unmarshaller for \"\n+                    + \"a root element class (%s).\", rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try {\n+            return (T) unmarshaller.unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            if (validationEventHandler.hasEvents()) {\n+                String errMessageWithValidationEvents = errMessage + \"\\n\" + validationEventHandler.reportAll();\n+                throw new OptaPlannerXmlSerializationException(errMessageWithValidationEvents, jaxbException);\n+            } else {\n+                throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+            }\n+        }\n+    }\n+\n+    private Unmarshaller createUnmarshaller() {\n+        try {\n+            return jaxbContext.createUnmarshaller();\n+        } catch (JAXBException e) {\n+            String errMessage = String.format(\"Unable to create JAXB unmarshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Reads the input XML using the {@link Reader} overriding elements namespaces. If an element already has a namespace and\n+     * a {@link ElementNamespaceOverride} is defined for this element, its namespace is overridden. In case the element has no\n+     * namespace, new namespace defined in the {@link ElementNamespaceOverride} is added.\n+     * \n+     * @param reader input XML {@link Reader}; never null\n+     * @param elementNamespaceOverrides never null\n+     * @return deserialized object representation of the XML.\n+     */\n+    public T readOverridingNamespace(Reader reader, ElementNamespaceOverride... elementNamespaceOverrides) {\n+        Objects.requireNonNull(reader);\n+        Objects.requireNonNull(elementNamespaceOverrides);\n+\n+        final String errMessage = String.format(\"Unable to read the (%s) from XML with overriding elements' namespaces: %s.\",\n+                rootClass.getName(), Arrays.toString(elementNamespaceOverrides));\n+\n+        // Create a SAXParser to use its XMLReader on the XMLFilter\n+        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n+        SAXParser saxParser;\n+        try {\n+            // Protect the parser against the XXE attack\n+            // https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE)\n+            saxParserFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+            saxParser = saxParserFactory.newSAXParser();\n+        } catch (ParserConfigurationException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+        XMLReader xmlReader;\n+        try {\n+            xmlReader = saxParser.getXMLReader();\n+        } catch (SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        XMLFilter namespaceOverridingXmlFilter = new NamespaceOverridingXmlFilter(xmlReader, elementNamespaceOverrides);\n+        namespaceOverridingXmlFilter.setParent(xmlReader);\n+\n+        // Use UnmarshallerHandler as a content handler for the XML filter.\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();\n+        namespaceOverridingXmlFilter.setContentHandler(unmarshallerHandler);\n+\n+        InputSource xmlInputSource = new InputSource(reader);\n+        try {\n+            // Parse the XML to feed its content into the UnmarshallerHandler.\n+            namespaceOverridingXmlFilter.parse(xmlInputSource);\n+        } catch (IOException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        try {\n+            return (T) unmarshallerHandler.getResult();\n+        } catch (JAXBException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    @Override\n+    public void write(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        formatXml(new DOMSource(domResult.getNode()), null, writer);\n+    }\n+\n+    public void writeWithoutNamespaces(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        final String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "originalPosition": 231}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTYyMzU0", "url": "https://github.com/kiegroup/optaplanner/pull/902#pullrequestreview-476562354", "createdAt": "2020-08-27T09:52:39Z", "commit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOTo1MjozOVrOHII8Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOTo1MjozOVrOHII8Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI5NzA5MQ==", "bodyText": "The errorMessage String should only be created if it actually fails, so inside the catch", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478297091", "createdAt": "2020-08-27T09:52:39Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";\n+\n+    private final JAXBContext jaxbContext;\n+    private final Marshaller marshaller;\n+    private final Class<T> rootClass;\n+    private final int indentation;\n+\n+    public GenericJaxbIO(Class<T> rootClass) {\n+        this(rootClass, DEFAULT_INDENTATION);\n+    }\n+\n+    public GenericJaxbIO(Class<T> rootClass, int indentation) {\n+        Objects.requireNonNull(rootClass);\n+        this.rootClass = rootClass;\n+        this.indentation = indentation;\n+        try {\n+            jaxbContext = JAXBContext.newInstance(rootClass);\n+            marshaller = jaxbContext.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            marshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.toString());\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to create JAXB Marshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    @Override\n+    public T read(Reader reader) {\n+        Objects.requireNonNull(reader);\n+        try {\n+            return (T) createUnmarshaller().unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    public T readAndValidate(Reader reader, String schemaResource) {\n+        Objects.requireNonNull(reader);\n+        String nonNullSchemaResource = Objects.requireNonNull(schemaResource);\n+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        Schema schema;\n+        try {\n+            schema = schemaFactory.newSchema(GenericJaxbIO.class.getResource(nonNullSchemaResource));\n+        } catch (SAXException e) {\n+            throw new IllegalArgumentException(\"Unable to read input schema resource (\" + nonNullSchemaResource + \")\", e);\n+        }\n+\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        unmarshaller.setSchema(schema);\n+        ValidationEventStringCollector validationEventHandler = new ValidationEventStringCollector();\n+\n+        try {\n+            unmarshaller.setEventHandler(validationEventHandler);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to set validation event handler to the unmarshaller for \"\n+                    + \"a root element class (%s).\", rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try {\n+            return (T) unmarshaller.unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            if (validationEventHandler.hasEvents()) {\n+                String errMessageWithValidationEvents = errMessage + \"\\n\" + validationEventHandler.reportAll();\n+                throw new OptaPlannerXmlSerializationException(errMessageWithValidationEvents, jaxbException);\n+            } else {\n+                throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+            }\n+        }\n+    }\n+\n+    private Unmarshaller createUnmarshaller() {\n+        try {\n+            return jaxbContext.createUnmarshaller();\n+        } catch (JAXBException e) {\n+            String errMessage = String.format(\"Unable to create JAXB unmarshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Reads the input XML using the {@link Reader} overriding elements namespaces. If an element already has a namespace and\n+     * a {@link ElementNamespaceOverride} is defined for this element, its namespace is overridden. In case the element has no\n+     * namespace, new namespace defined in the {@link ElementNamespaceOverride} is added.\n+     * \n+     * @param reader input XML {@link Reader}; never null\n+     * @param elementNamespaceOverrides never null\n+     * @return deserialized object representation of the XML.\n+     */\n+    public T readOverridingNamespace(Reader reader, ElementNamespaceOverride... elementNamespaceOverrides) {\n+        Objects.requireNonNull(reader);\n+        Objects.requireNonNull(elementNamespaceOverrides);\n+\n+        final String errMessage = String.format(\"Unable to read the (%s) from XML with overriding elements' namespaces: %s.\",\n+                rootClass.getName(), Arrays.toString(elementNamespaceOverrides));\n+\n+        // Create a SAXParser to use its XMLReader on the XMLFilter\n+        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n+        SAXParser saxParser;\n+        try {\n+            // Protect the parser against the XXE attack\n+            // https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE)\n+            saxParserFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+            saxParser = saxParserFactory.newSAXParser();\n+        } catch (ParserConfigurationException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+        XMLReader xmlReader;\n+        try {\n+            xmlReader = saxParser.getXMLReader();\n+        } catch (SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        XMLFilter namespaceOverridingXmlFilter = new NamespaceOverridingXmlFilter(xmlReader, elementNamespaceOverrides);\n+        namespaceOverridingXmlFilter.setParent(xmlReader);\n+\n+        // Use UnmarshallerHandler as a content handler for the XML filter.\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();\n+        namespaceOverridingXmlFilter.setContentHandler(unmarshallerHandler);\n+\n+        InputSource xmlInputSource = new InputSource(reader);\n+        try {\n+            // Parse the XML to feed its content into the UnmarshallerHandler.\n+            namespaceOverridingXmlFilter.parse(xmlInputSource);\n+        } catch (IOException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        try {\n+            return (T) unmarshallerHandler.getResult();\n+        } catch (JAXBException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    @Override\n+    public void write(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        formatXml(new DOMSource(domResult.getNode()), null, writer);\n+    }\n+\n+    public void writeWithoutNamespaces(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        final String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "originalPosition": 226}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTY3MDA2", "url": "https://github.com/kiegroup/optaplanner/pull/902#pullrequestreview-476567006", "createdAt": "2020-08-27T09:58:45Z", "commit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOTo1ODo0NVrOHIJJyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOTo1ODo0NVrOHIJJyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwMDYxNg==", "bodyText": "Here, it didn't fail to marshall the rootClass to XML, so the error message should be different.\n=> \"Failed to format XML for rootClass(...).\" maybe?", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478300616", "createdAt": "2020-08-27T09:58:45Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";\n+\n+    private final JAXBContext jaxbContext;\n+    private final Marshaller marshaller;\n+    private final Class<T> rootClass;\n+    private final int indentation;\n+\n+    public GenericJaxbIO(Class<T> rootClass) {\n+        this(rootClass, DEFAULT_INDENTATION);\n+    }\n+\n+    public GenericJaxbIO(Class<T> rootClass, int indentation) {\n+        Objects.requireNonNull(rootClass);\n+        this.rootClass = rootClass;\n+        this.indentation = indentation;\n+        try {\n+            jaxbContext = JAXBContext.newInstance(rootClass);\n+            marshaller = jaxbContext.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            marshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.toString());\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to create JAXB Marshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    @Override\n+    public T read(Reader reader) {\n+        Objects.requireNonNull(reader);\n+        try {\n+            return (T) createUnmarshaller().unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    public T readAndValidate(Reader reader, String schemaResource) {\n+        Objects.requireNonNull(reader);\n+        String nonNullSchemaResource = Objects.requireNonNull(schemaResource);\n+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        Schema schema;\n+        try {\n+            schema = schemaFactory.newSchema(GenericJaxbIO.class.getResource(nonNullSchemaResource));\n+        } catch (SAXException e) {\n+            throw new IllegalArgumentException(\"Unable to read input schema resource (\" + nonNullSchemaResource + \")\", e);\n+        }\n+\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        unmarshaller.setSchema(schema);\n+        ValidationEventStringCollector validationEventHandler = new ValidationEventStringCollector();\n+\n+        try {\n+            unmarshaller.setEventHandler(validationEventHandler);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to set validation event handler to the unmarshaller for \"\n+                    + \"a root element class (%s).\", rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try {\n+            return (T) unmarshaller.unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            if (validationEventHandler.hasEvents()) {\n+                String errMessageWithValidationEvents = errMessage + \"\\n\" + validationEventHandler.reportAll();\n+                throw new OptaPlannerXmlSerializationException(errMessageWithValidationEvents, jaxbException);\n+            } else {\n+                throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+            }\n+        }\n+    }\n+\n+    private Unmarshaller createUnmarshaller() {\n+        try {\n+            return jaxbContext.createUnmarshaller();\n+        } catch (JAXBException e) {\n+            String errMessage = String.format(\"Unable to create JAXB unmarshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Reads the input XML using the {@link Reader} overriding elements namespaces. If an element already has a namespace and\n+     * a {@link ElementNamespaceOverride} is defined for this element, its namespace is overridden. In case the element has no\n+     * namespace, new namespace defined in the {@link ElementNamespaceOverride} is added.\n+     * \n+     * @param reader input XML {@link Reader}; never null\n+     * @param elementNamespaceOverrides never null\n+     * @return deserialized object representation of the XML.\n+     */\n+    public T readOverridingNamespace(Reader reader, ElementNamespaceOverride... elementNamespaceOverrides) {\n+        Objects.requireNonNull(reader);\n+        Objects.requireNonNull(elementNamespaceOverrides);\n+\n+        final String errMessage = String.format(\"Unable to read the (%s) from XML with overriding elements' namespaces: %s.\",\n+                rootClass.getName(), Arrays.toString(elementNamespaceOverrides));\n+\n+        // Create a SAXParser to use its XMLReader on the XMLFilter\n+        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n+        SAXParser saxParser;\n+        try {\n+            // Protect the parser against the XXE attack\n+            // https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE)\n+            saxParserFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+            saxParser = saxParserFactory.newSAXParser();\n+        } catch (ParserConfigurationException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+        XMLReader xmlReader;\n+        try {\n+            xmlReader = saxParser.getXMLReader();\n+        } catch (SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        XMLFilter namespaceOverridingXmlFilter = new NamespaceOverridingXmlFilter(xmlReader, elementNamespaceOverrides);\n+        namespaceOverridingXmlFilter.setParent(xmlReader);\n+\n+        // Use UnmarshallerHandler as a content handler for the XML filter.\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();\n+        namespaceOverridingXmlFilter.setContentHandler(unmarshallerHandler);\n+\n+        InputSource xmlInputSource = new InputSource(reader);\n+        try {\n+            // Parse the XML to feed its content into the UnmarshallerHandler.\n+            namespaceOverridingXmlFilter.parse(xmlInputSource);\n+        } catch (IOException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        try {\n+            return (T) unmarshallerHandler.getResult();\n+        } catch (JAXBException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    @Override\n+    public void write(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        formatXml(new DOMSource(domResult.getNode()), null, writer);\n+    }\n+\n+    public void writeWithoutNamespaces(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        final String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try (InputStream xsltInputStream = getClass().getResourceAsStream(\"removeNamespaces.xslt\")) {\n+            formatXml(new DOMSource(domResult.getNode()), new StreamSource(xsltInputStream), writer);\n+        } catch (IOException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    private void formatXml(Source source, Source transformationTemplate, Writer writer) {\n+        /*\n+         * The code is not vulnerable to XXE-based attacks as it does not process any external XML nor XSL input.\n+         * Should the transformerFactory be used for such purposes, it has to be appropriately secured:\n+         * https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE)\n+         */\n+        @SuppressWarnings({ \"java:S2755\", \"java:S4435\" })\n+        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n+        try {\n+            Transformer transformer = transformationTemplate == null ? transformerFactory.newTransformer()\n+                    : transformerFactory.newTransformer(transformationTemplate);\n+            // See https://stackoverflow.com/questions/46708498/jaxb-marshaller-indentation.\n+            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+            transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", String.valueOf(indentation));\n+            transformer.transform(source, new StreamResult(writer));\n+        } catch (TransformerException transformerException) {\n+            String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "originalPosition": 256}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTY4Nzkx", "url": "https://github.com/kiegroup/optaplanner/pull/902#pullrequestreview-476568791", "createdAt": "2020-08-27T10:01:04Z", "commit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDowMTowNFrOHIJPQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDowMTowNFrOHIJPQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwMjAxOQ==", "bodyText": "Do we need to bring in an XSLT formatter to format the JAXB output?\nCan we not use this instead?\nmarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\nLess XSLT is always better ;-)", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478302019", "createdAt": "2020-08-27T10:01:04Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";\n+\n+    private final JAXBContext jaxbContext;\n+    private final Marshaller marshaller;\n+    private final Class<T> rootClass;\n+    private final int indentation;\n+\n+    public GenericJaxbIO(Class<T> rootClass) {\n+        this(rootClass, DEFAULT_INDENTATION);\n+    }\n+\n+    public GenericJaxbIO(Class<T> rootClass, int indentation) {\n+        Objects.requireNonNull(rootClass);\n+        this.rootClass = rootClass;\n+        this.indentation = indentation;\n+        try {\n+            jaxbContext = JAXBContext.newInstance(rootClass);\n+            marshaller = jaxbContext.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            marshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.toString());\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to create JAXB Marshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    @Override\n+    public T read(Reader reader) {\n+        Objects.requireNonNull(reader);\n+        try {\n+            return (T) createUnmarshaller().unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    public T readAndValidate(Reader reader, String schemaResource) {\n+        Objects.requireNonNull(reader);\n+        String nonNullSchemaResource = Objects.requireNonNull(schemaResource);\n+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        Schema schema;\n+        try {\n+            schema = schemaFactory.newSchema(GenericJaxbIO.class.getResource(nonNullSchemaResource));\n+        } catch (SAXException e) {\n+            throw new IllegalArgumentException(\"Unable to read input schema resource (\" + nonNullSchemaResource + \")\", e);\n+        }\n+\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        unmarshaller.setSchema(schema);\n+        ValidationEventStringCollector validationEventHandler = new ValidationEventStringCollector();\n+\n+        try {\n+            unmarshaller.setEventHandler(validationEventHandler);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to set validation event handler to the unmarshaller for \"\n+                    + \"a root element class (%s).\", rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try {\n+            return (T) unmarshaller.unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            if (validationEventHandler.hasEvents()) {\n+                String errMessageWithValidationEvents = errMessage + \"\\n\" + validationEventHandler.reportAll();\n+                throw new OptaPlannerXmlSerializationException(errMessageWithValidationEvents, jaxbException);\n+            } else {\n+                throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+            }\n+        }\n+    }\n+\n+    private Unmarshaller createUnmarshaller() {\n+        try {\n+            return jaxbContext.createUnmarshaller();\n+        } catch (JAXBException e) {\n+            String errMessage = String.format(\"Unable to create JAXB unmarshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Reads the input XML using the {@link Reader} overriding elements namespaces. If an element already has a namespace and\n+     * a {@link ElementNamespaceOverride} is defined for this element, its namespace is overridden. In case the element has no\n+     * namespace, new namespace defined in the {@link ElementNamespaceOverride} is added.\n+     * \n+     * @param reader input XML {@link Reader}; never null\n+     * @param elementNamespaceOverrides never null\n+     * @return deserialized object representation of the XML.\n+     */\n+    public T readOverridingNamespace(Reader reader, ElementNamespaceOverride... elementNamespaceOverrides) {\n+        Objects.requireNonNull(reader);\n+        Objects.requireNonNull(elementNamespaceOverrides);\n+\n+        final String errMessage = String.format(\"Unable to read the (%s) from XML with overriding elements' namespaces: %s.\",\n+                rootClass.getName(), Arrays.toString(elementNamespaceOverrides));\n+\n+        // Create a SAXParser to use its XMLReader on the XMLFilter\n+        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n+        SAXParser saxParser;\n+        try {\n+            // Protect the parser against the XXE attack\n+            // https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE)\n+            saxParserFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+            saxParser = saxParserFactory.newSAXParser();\n+        } catch (ParserConfigurationException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+        XMLReader xmlReader;\n+        try {\n+            xmlReader = saxParser.getXMLReader();\n+        } catch (SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        XMLFilter namespaceOverridingXmlFilter = new NamespaceOverridingXmlFilter(xmlReader, elementNamespaceOverrides);\n+        namespaceOverridingXmlFilter.setParent(xmlReader);\n+\n+        // Use UnmarshallerHandler as a content handler for the XML filter.\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();\n+        namespaceOverridingXmlFilter.setContentHandler(unmarshallerHandler);\n+\n+        InputSource xmlInputSource = new InputSource(reader);\n+        try {\n+            // Parse the XML to feed its content into the UnmarshallerHandler.\n+            namespaceOverridingXmlFilter.parse(xmlInputSource);\n+        } catch (IOException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        try {\n+            return (T) unmarshallerHandler.getResult();\n+        } catch (JAXBException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    @Override\n+    public void write(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        formatXml(new DOMSource(domResult.getNode()), null, writer);\n+    }\n+\n+    public void writeWithoutNamespaces(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        final String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try (InputStream xsltInputStream = getClass().getResourceAsStream(\"removeNamespaces.xslt\")) {\n+            formatXml(new DOMSource(domResult.getNode()), new StreamSource(xsltInputStream), writer);\n+        } catch (IOException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    private void formatXml(Source source, Source transformationTemplate, Writer writer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "originalPosition": 240}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTcwODky", "url": "https://github.com/kiegroup/optaplanner/pull/902#pullrequestreview-476570892", "createdAt": "2020-08-27T10:04:02Z", "commit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDowNDowMlrOHIJVqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDowNDowMlrOHIJVqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwMzY1OA==", "bodyText": "error style, always use braces to mention values at runtime.\n=> \"... rootClass (%s) ... namespaces (%s).\"", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478303658", "createdAt": "2020-08-27T10:04:02Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";\n+\n+    private final JAXBContext jaxbContext;\n+    private final Marshaller marshaller;\n+    private final Class<T> rootClass;\n+    private final int indentation;\n+\n+    public GenericJaxbIO(Class<T> rootClass) {\n+        this(rootClass, DEFAULT_INDENTATION);\n+    }\n+\n+    public GenericJaxbIO(Class<T> rootClass, int indentation) {\n+        Objects.requireNonNull(rootClass);\n+        this.rootClass = rootClass;\n+        this.indentation = indentation;\n+        try {\n+            jaxbContext = JAXBContext.newInstance(rootClass);\n+            marshaller = jaxbContext.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            marshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.toString());\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to create JAXB Marshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    @Override\n+    public T read(Reader reader) {\n+        Objects.requireNonNull(reader);\n+        try {\n+            return (T) createUnmarshaller().unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    public T readAndValidate(Reader reader, String schemaResource) {\n+        Objects.requireNonNull(reader);\n+        String nonNullSchemaResource = Objects.requireNonNull(schemaResource);\n+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        Schema schema;\n+        try {\n+            schema = schemaFactory.newSchema(GenericJaxbIO.class.getResource(nonNullSchemaResource));\n+        } catch (SAXException e) {\n+            throw new IllegalArgumentException(\"Unable to read input schema resource (\" + nonNullSchemaResource + \")\", e);\n+        }\n+\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        unmarshaller.setSchema(schema);\n+        ValidationEventStringCollector validationEventHandler = new ValidationEventStringCollector();\n+\n+        try {\n+            unmarshaller.setEventHandler(validationEventHandler);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to set validation event handler to the unmarshaller for \"\n+                    + \"a root element class (%s).\", rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try {\n+            return (T) unmarshaller.unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            if (validationEventHandler.hasEvents()) {\n+                String errMessageWithValidationEvents = errMessage + \"\\n\" + validationEventHandler.reportAll();\n+                throw new OptaPlannerXmlSerializationException(errMessageWithValidationEvents, jaxbException);\n+            } else {\n+                throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+            }\n+        }\n+    }\n+\n+    private Unmarshaller createUnmarshaller() {\n+        try {\n+            return jaxbContext.createUnmarshaller();\n+        } catch (JAXBException e) {\n+            String errMessage = String.format(\"Unable to create JAXB unmarshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Reads the input XML using the {@link Reader} overriding elements namespaces. If an element already has a namespace and\n+     * a {@link ElementNamespaceOverride} is defined for this element, its namespace is overridden. In case the element has no\n+     * namespace, new namespace defined in the {@link ElementNamespaceOverride} is added.\n+     * \n+     * @param reader input XML {@link Reader}; never null\n+     * @param elementNamespaceOverrides never null\n+     * @return deserialized object representation of the XML.\n+     */\n+    public T readOverridingNamespace(Reader reader, ElementNamespaceOverride... elementNamespaceOverrides) {\n+        Objects.requireNonNull(reader);\n+        Objects.requireNonNull(elementNamespaceOverrides);\n+\n+        final String errMessage = String.format(\"Unable to read the (%s) from XML with overriding elements' namespaces: %s.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "originalPosition": 163}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTczNjE2", "url": "https://github.com/kiegroup/optaplanner/pull/902#pullrequestreview-476573616", "createdAt": "2020-08-27T10:07:41Z", "commit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDowNzo0MVrOHIJfQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDowNzo0MVrOHIJfQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwNjExMw==", "bodyText": "Do we need a custom class for this?\nWe can probably just do\nString s = validationEventCollector.getEvents().stream().map(Event::getMessage).collect(Collectors.joining(\"\\n\"))", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478306113", "createdAt": "2020-08-27T10:07:41Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";\n+\n+    private final JAXBContext jaxbContext;\n+    private final Marshaller marshaller;\n+    private final Class<T> rootClass;\n+    private final int indentation;\n+\n+    public GenericJaxbIO(Class<T> rootClass) {\n+        this(rootClass, DEFAULT_INDENTATION);\n+    }\n+\n+    public GenericJaxbIO(Class<T> rootClass, int indentation) {\n+        Objects.requireNonNull(rootClass);\n+        this.rootClass = rootClass;\n+        this.indentation = indentation;\n+        try {\n+            jaxbContext = JAXBContext.newInstance(rootClass);\n+            marshaller = jaxbContext.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            marshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.toString());\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to create JAXB Marshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    @Override\n+    public T read(Reader reader) {\n+        Objects.requireNonNull(reader);\n+        try {\n+            return (T) createUnmarshaller().unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    public T readAndValidate(Reader reader, String schemaResource) {\n+        Objects.requireNonNull(reader);\n+        String nonNullSchemaResource = Objects.requireNonNull(schemaResource);\n+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        Schema schema;\n+        try {\n+            schema = schemaFactory.newSchema(GenericJaxbIO.class.getResource(nonNullSchemaResource));\n+        } catch (SAXException e) {\n+            throw new IllegalArgumentException(\"Unable to read input schema resource (\" + nonNullSchemaResource + \")\", e);\n+        }\n+\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        unmarshaller.setSchema(schema);\n+        ValidationEventStringCollector validationEventHandler = new ValidationEventStringCollector();\n+\n+        try {\n+            unmarshaller.setEventHandler(validationEventHandler);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to set validation event handler to the unmarshaller for \"\n+                    + \"a root element class (%s).\", rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try {\n+            return (T) unmarshaller.unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            if (validationEventHandler.hasEvents()) {\n+                String errMessageWithValidationEvents = errMessage + \"\\n\" + validationEventHandler.reportAll();\n+                throw new OptaPlannerXmlSerializationException(errMessageWithValidationEvents, jaxbException);\n+            } else {\n+                throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+            }\n+        }\n+    }\n+\n+    private Unmarshaller createUnmarshaller() {\n+        try {\n+            return jaxbContext.createUnmarshaller();\n+        } catch (JAXBException e) {\n+            String errMessage = String.format(\"Unable to create JAXB unmarshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Reads the input XML using the {@link Reader} overriding elements namespaces. If an element already has a namespace and\n+     * a {@link ElementNamespaceOverride} is defined for this element, its namespace is overridden. In case the element has no\n+     * namespace, new namespace defined in the {@link ElementNamespaceOverride} is added.\n+     * \n+     * @param reader input XML {@link Reader}; never null\n+     * @param elementNamespaceOverrides never null\n+     * @return deserialized object representation of the XML.\n+     */\n+    public T readOverridingNamespace(Reader reader, ElementNamespaceOverride... elementNamespaceOverrides) {\n+        Objects.requireNonNull(reader);\n+        Objects.requireNonNull(elementNamespaceOverrides);\n+\n+        final String errMessage = String.format(\"Unable to read the (%s) from XML with overriding elements' namespaces: %s.\",\n+                rootClass.getName(), Arrays.toString(elementNamespaceOverrides));\n+\n+        // Create a SAXParser to use its XMLReader on the XMLFilter\n+        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n+        SAXParser saxParser;\n+        try {\n+            // Protect the parser against the XXE attack\n+            // https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE)\n+            saxParserFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+            saxParser = saxParserFactory.newSAXParser();\n+        } catch (ParserConfigurationException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+        XMLReader xmlReader;\n+        try {\n+            xmlReader = saxParser.getXMLReader();\n+        } catch (SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        XMLFilter namespaceOverridingXmlFilter = new NamespaceOverridingXmlFilter(xmlReader, elementNamespaceOverrides);\n+        namespaceOverridingXmlFilter.setParent(xmlReader);\n+\n+        // Use UnmarshallerHandler as a content handler for the XML filter.\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();\n+        namespaceOverridingXmlFilter.setContentHandler(unmarshallerHandler);\n+\n+        InputSource xmlInputSource = new InputSource(reader);\n+        try {\n+            // Parse the XML to feed its content into the UnmarshallerHandler.\n+            namespaceOverridingXmlFilter.parse(xmlInputSource);\n+        } catch (IOException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        try {\n+            return (T) unmarshallerHandler.getResult();\n+        } catch (JAXBException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    @Override\n+    public void write(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        formatXml(new DOMSource(domResult.getNode()), null, writer);\n+    }\n+\n+    public void writeWithoutNamespaces(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        final String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try (InputStream xsltInputStream = getClass().getResourceAsStream(\"removeNamespaces.xslt\")) {\n+            formatXml(new DOMSource(domResult.getNode()), new StreamSource(xsltInputStream), writer);\n+        } catch (IOException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    private void formatXml(Source source, Source transformationTemplate, Writer writer) {\n+        /*\n+         * The code is not vulnerable to XXE-based attacks as it does not process any external XML nor XSL input.\n+         * Should the transformerFactory be used for such purposes, it has to be appropriately secured:\n+         * https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE)\n+         */\n+        @SuppressWarnings({ \"java:S2755\", \"java:S4435\" })\n+        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n+        try {\n+            Transformer transformer = transformationTemplate == null ? transformerFactory.newTransformer()\n+                    : transformerFactory.newTransformer(transformationTemplate);\n+            // See https://stackoverflow.com/questions/46708498/jaxb-marshaller-indentation.\n+            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+            transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", String.valueOf(indentation));\n+            transformer.transform(source, new StreamResult(writer));\n+        } catch (TransformerException transformerException) {\n+            String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, transformerException);\n+        }\n+    }\n+\n+    /**\n+     * Overrides namespace of every XML element by the namespace defined in the {@link ElementNamespaceOverride}.\n+     */\n+    private static final class NamespaceOverridingXmlFilter extends XMLFilterImpl {\n+\n+        private final Deque<String> activeNamespace = new ArrayDeque<>();\n+        private final Map<String, String> elementNamespaceOverridesMap = new HashMap<>();\n+\n+        public NamespaceOverridingXmlFilter(XMLReader xmlReader, ElementNamespaceOverride... elementNamespaceOverrides) {\n+            super(xmlReader);\n+            Objects.requireNonNull(elementNamespaceOverrides);\n+            for (ElementNamespaceOverride namespaceOverride : elementNamespaceOverrides) {\n+                elementNamespaceOverridesMap.put(namespaceOverride.getElementLocalName(),\n+                        namespaceOverride.getNamespaceOverride());\n+            }\n+        }\n+\n+        @Override\n+        public void endElement(String uri, String localName, String qName) throws SAXException {\n+            String resultingUri = activeNamespace.isEmpty() ? uri : activeNamespace.peek();\n+            if (elementNamespaceOverridesMap.containsKey(qName)) {\n+                activeNamespace.pop();\n+            }\n+            super.endElement(resultingUri, localName, qName);\n+        }\n+\n+        @Override\n+        public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException {\n+            String namespaceOverride = elementNamespaceOverridesMap.get(qName);\n+            if (namespaceOverride != null) {\n+                activeNamespace.push(namespaceOverride);\n+            }\n+\n+            String resultingUri = activeNamespace.isEmpty() ? uri : activeNamespace.peek();\n+            super.startElement(resultingUri, localName, qName, atts);\n+        }\n+\n+    }\n+\n+    private static final class ValidationEventStringCollector extends ValidationEventCollector {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "originalPosition": 300}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTc2MTY4", "url": "https://github.com/kiegroup/optaplanner/pull/902#pullrequestreview-476576168", "createdAt": "2020-08-27T10:11:23Z", "commit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDoxMToyM1rOHIJnVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDoxMToyM1rOHIJnVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwODE4MA==", "bodyText": "open question (maybe for another PR): Is this public API? Should SolverFactory.createFromXmlResource()'s javadoc have a \"@throws OptaPlannerXmlSerializationException\" ? In that case we might want to move it into the api package.", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478308180", "createdAt": "2020-08-27T10:11:23Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/OptaPlannerXmlSerializationException.java", "diffHunk": "@@ -16,21 +16,21 @@\n \n package org.optaplanner.core.impl.io;\n \n-public class XmlUnmarshallingException extends RuntimeException {\n+public class OptaPlannerXmlSerializationException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTc4NTg4", "url": "https://github.com/kiegroup/optaplanner/pull/902#pullrequestreview-476578588", "createdAt": "2020-08-27T10:15:01Z", "commit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDoxNTowMVrOHIJujg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDoxNTowMVrOHIJujg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMxMDAzMA==", "bodyText": "Naming consistency: the only implementation of an interface Foo is normally called DefaultFoo in the rest of the optaplanner repo. This makes it easier to guess when doing ctrl-n.\n=> rename GenericJaxbIO to DefaultJaxbIO", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478310030", "createdAt": "2020-08-27T10:15:01Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTgwNTA4", "url": "https://github.com/kiegroup/optaplanner/pull/902#pullrequestreview-476580508", "createdAt": "2020-08-27T10:17:54Z", "commit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDoxNzo1NFrOHIJ0UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDoxNzo1NFrOHIJ0UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMxMTUwNA==", "bodyText": "Read didn't fail here. Validation failed. Or if read includes validation, then actually stating \"validation failed\" is more specific. The error message should reflect that, so users don't think that the file wasn't found.", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478311504", "createdAt": "2020-08-27T10:17:54Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";\n+\n+    private final JAXBContext jaxbContext;\n+    private final Marshaller marshaller;\n+    private final Class<T> rootClass;\n+    private final int indentation;\n+\n+    public GenericJaxbIO(Class<T> rootClass) {\n+        this(rootClass, DEFAULT_INDENTATION);\n+    }\n+\n+    public GenericJaxbIO(Class<T> rootClass, int indentation) {\n+        Objects.requireNonNull(rootClass);\n+        this.rootClass = rootClass;\n+        this.indentation = indentation;\n+        try {\n+            jaxbContext = JAXBContext.newInstance(rootClass);\n+            marshaller = jaxbContext.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            marshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.toString());\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to create JAXB Marshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    @Override\n+    public T read(Reader reader) {\n+        Objects.requireNonNull(reader);\n+        try {\n+            return (T) createUnmarshaller().unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    public T readAndValidate(Reader reader, String schemaResource) {\n+        Objects.requireNonNull(reader);\n+        String nonNullSchemaResource = Objects.requireNonNull(schemaResource);\n+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        Schema schema;\n+        try {\n+            schema = schemaFactory.newSchema(GenericJaxbIO.class.getResource(nonNullSchemaResource));\n+        } catch (SAXException e) {\n+            throw new IllegalArgumentException(\"Unable to read input schema resource (\" + nonNullSchemaResource + \")\", e);\n+        }\n+\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        unmarshaller.setSchema(schema);\n+        ValidationEventStringCollector validationEventHandler = new ValidationEventStringCollector();\n+\n+        try {\n+            unmarshaller.setEventHandler(validationEventHandler);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to set validation event handler to the unmarshaller for \"\n+                    + \"a root element class (%s).\", rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try {\n+            return (T) unmarshaller.unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            if (validationEventHandler.hasEvents()) {\n+                String errMessageWithValidationEvents = errMessage + \"\\n\" + validationEventHandler.reportAll();\n+                throw new OptaPlannerXmlSerializationException(errMessageWithValidationEvents, jaxbException);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596"}, "originalPosition": 133}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39d10d5f5404ff8537bef0dcc5b2848f007c107b", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/39d10d5f5404ff8537bef0dcc5b2848f007c107b", "committedDate": "2020-08-27T12:12:11Z", "message": "Address review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c734825b85c4dd39f6bd5e8f4938eb4bc196e36e", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/c734825b85c4dd39f6bd5e8f4938eb4bc196e36e", "committedDate": "2020-08-27T11:59:44Z", "message": "Address review comments"}, "afterCommit": {"oid": "39d10d5f5404ff8537bef0dcc5b2848f007c107b", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/39d10d5f5404ff8537bef0dcc5b2848f007c107b", "committedDate": "2020-08-27T12:12:11Z", "message": "Address review comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3172, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}