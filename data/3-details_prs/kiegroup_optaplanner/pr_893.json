{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwOTcwOTcx", "number": 893, "title": "PLANNER-2116 Externalize build methods of entity and value selectors", "bodyText": "JIRA: PLANNER-2116\nHow to retest or run:\n\n\na pull request please add comment: regex [.*[j|J]enkins,?.*(retest|test) this.*]\n\n\na full downstream build please add comment: regex [.*[j|J]enkins,?.*(execute|run|trigger|start|do) fdb.*]\n\n\na compile downstream build please  add comment: regex [.*[j|J]enkins,?.*(execute|run|trigger|start|do) cdb.*]\n\n\na full production downstream please add comment: regex [.*[j|J]enkins,?.*(execute|run|trigger|start|do) product fdb.*]\n\n\nan upstream build please add comment: regex [.*[j|J]enkins,?.*(execute|run|trigger|start|do) upstream.*]\n\n\ni.e for running a full downstream build =  Jenkins do fdb", "createdAt": "2020-08-20T15:02:46Z", "url": "https://github.com/kiegroup/optaplanner/pull/893", "merged": true, "mergeCommit": {"oid": "fd1d73a04ead9046e8794b3a97a43751d9637b43"}, "closed": true, "closedAt": "2020-08-24T12:24:21Z", "author": {"login": "rsynek"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdA_EXCgBqjM2NzgyNzQ3NDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCBF2rgBqjM2ODUwMjc3MDg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "63db4a93d13e7a574bd5ef1cf9dd26a6aea62b02", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/63db4a93d13e7a574bd5ef1cf9dd26a6aea62b02", "committedDate": "2020-08-21T06:42:23Z", "message": "Increase coverage of value and entity selection"}, "afterCommit": {"oid": "25096d8fb99105d990e31779cbec9854cc682d94", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/25096d8fb99105d990e31779cbec9854cc682d94", "committedDate": "2020-08-21T06:45:41Z", "message": "Increase coverage of value and entity selection"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e1d05468f29bf050db9670e8b90e36013cea7875", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/e1d05468f29bf050db9670e8b90e36013cea7875", "committedDate": "2020-08-21T08:56:55Z", "message": "Check for entity class nullity"}, "afterCommit": {"oid": "53325e9463ef79cb7cc6a0331aed08a452937964", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/53325e9463ef79cb7cc6a0331aed08a452937964", "committedDate": "2020-08-21T15:02:31Z", "message": "Check for entity class nullity"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDI1MTIy", "url": "https://github.com/kiegroup/optaplanner/pull/893#pullrequestreview-473025122", "createdAt": "2020-08-23T16:33:33Z", "commit": {"oid": "53325e9463ef79cb7cc6a0331aed08a452937964"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxNjozMzozNFrOHFOSWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxNjo0ODoyM1rOHFOYEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzOTAwMg==", "bodyText": "Please merge the assignment with the declaration.", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475239002", "createdAt": "2020-08-23T16:33:34Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/AbstractFromConfigFactory.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.config.AbstractConfig;\n+import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n+import org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor;\n+import org.optaplanner.core.impl.domain.variable.descriptor.GenuineVariableDescriptor;\n+\n+public abstract class AbstractFromConfigFactory<Config_ extends AbstractConfig<Config_>> {\n+\n+    protected final Config_ config;\n+\n+    public AbstractFromConfigFactory(Config_ config) {\n+        this.config = config;\n+    }\n+\n+    protected EntityDescriptor deduceEntityDescriptor(SolutionDescriptor solutionDescriptor, Class<?> entityClass) {\n+        EntityDescriptor entityDescriptor;\n+        entityDescriptor = solutionDescriptor.getEntityDescriptorStrict(Objects.requireNonNull(entityClass));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53325e9463ef79cb7cc6a0331aed08a452937964"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzOTA3Mg==", "bodyText": "Dtto.", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475239072", "createdAt": "2020-08-23T16:34:15Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/AbstractFromConfigFactory.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.config.AbstractConfig;\n+import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n+import org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor;\n+import org.optaplanner.core.impl.domain.variable.descriptor.GenuineVariableDescriptor;\n+\n+public abstract class AbstractFromConfigFactory<Config_ extends AbstractConfig<Config_>> {\n+\n+    protected final Config_ config;\n+\n+    public AbstractFromConfigFactory(Config_ config) {\n+        this.config = config;\n+    }\n+\n+    protected EntityDescriptor deduceEntityDescriptor(SolutionDescriptor solutionDescriptor, Class<?> entityClass) {\n+        EntityDescriptor entityDescriptor;\n+        entityDescriptor = solutionDescriptor.getEntityDescriptorStrict(Objects.requireNonNull(entityClass));\n+        if (entityDescriptor == null) {\n+            throw new IllegalArgumentException(\"The config (\" + config\n+                    + \") has an entityClass (\" + entityClass + \") that is not a known planning entity.\\n\"\n+                    + \"Check your solver configuration. If that class (\" + entityClass.getSimpleName()\n+                    + \") is not in the entityClassSet (\" + solutionDescriptor.getEntityClassSet()\n+                    + \"), check your \" + PlanningSolution.class.getSimpleName()\n+                    + \" implementation's annotated methods too.\");\n+        }\n+        return entityDescriptor;\n+    }\n+\n+    protected EntityDescriptor deduceEntityDescriptor(SolutionDescriptor solutionDescriptor) {\n+        Collection<EntityDescriptor> entityDescriptors = solutionDescriptor.getGenuineEntityDescriptors();\n+        if (entityDescriptors.size() != 1) {\n+            throw new IllegalArgumentException(\"The config (\" + config\n+                    + \") has no entityClass configured and because there are multiple in the entityClassSet (\"\n+                    + solutionDescriptor.getEntityClassSet()\n+                    + \"), it cannot be deduced automatically.\");\n+        }\n+        return entityDescriptors.iterator().next();\n+    }\n+\n+    protected GenuineVariableDescriptor deduceVariableDescriptor(EntityDescriptor entityDescriptor, String variableName) {\n+        GenuineVariableDescriptor variableDescriptor;\n+        variableDescriptor = entityDescriptor.getGenuineVariableDescriptor(Objects.requireNonNull(variableName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53325e9463ef79cb7cc6a0331aed08a452937964"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzOTY0OQ==", "bodyText": "This could be a nice stream.\nreturn variableNameIncludeList.stream()\n    .map(n -> variableDescriptorList.stream()\n        .filter(d -> d.gerVariableName().equals(n))\n        .findFirst()\n        .orElseThrow(...))\n    .collect(Collectors.toList());\n\nIn my opinion, this reads better as you don't need to mentally track the state of found.", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475239649", "createdAt": "2020-08-23T16:40:12Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/AbstractFromConfigFactory.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.config.AbstractConfig;\n+import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n+import org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor;\n+import org.optaplanner.core.impl.domain.variable.descriptor.GenuineVariableDescriptor;\n+\n+public abstract class AbstractFromConfigFactory<Config_ extends AbstractConfig<Config_>> {\n+\n+    protected final Config_ config;\n+\n+    public AbstractFromConfigFactory(Config_ config) {\n+        this.config = config;\n+    }\n+\n+    protected EntityDescriptor deduceEntityDescriptor(SolutionDescriptor solutionDescriptor, Class<?> entityClass) {\n+        EntityDescriptor entityDescriptor;\n+        entityDescriptor = solutionDescriptor.getEntityDescriptorStrict(Objects.requireNonNull(entityClass));\n+        if (entityDescriptor == null) {\n+            throw new IllegalArgumentException(\"The config (\" + config\n+                    + \") has an entityClass (\" + entityClass + \") that is not a known planning entity.\\n\"\n+                    + \"Check your solver configuration. If that class (\" + entityClass.getSimpleName()\n+                    + \") is not in the entityClassSet (\" + solutionDescriptor.getEntityClassSet()\n+                    + \"), check your \" + PlanningSolution.class.getSimpleName()\n+                    + \" implementation's annotated methods too.\");\n+        }\n+        return entityDescriptor;\n+    }\n+\n+    protected EntityDescriptor deduceEntityDescriptor(SolutionDescriptor solutionDescriptor) {\n+        Collection<EntityDescriptor> entityDescriptors = solutionDescriptor.getGenuineEntityDescriptors();\n+        if (entityDescriptors.size() != 1) {\n+            throw new IllegalArgumentException(\"The config (\" + config\n+                    + \") has no entityClass configured and because there are multiple in the entityClassSet (\"\n+                    + solutionDescriptor.getEntityClassSet()\n+                    + \"), it cannot be deduced automatically.\");\n+        }\n+        return entityDescriptors.iterator().next();\n+    }\n+\n+    protected GenuineVariableDescriptor deduceVariableDescriptor(EntityDescriptor entityDescriptor, String variableName) {\n+        GenuineVariableDescriptor variableDescriptor;\n+        variableDescriptor = entityDescriptor.getGenuineVariableDescriptor(Objects.requireNonNull(variableName));\n+        if (variableDescriptor == null) {\n+            throw new IllegalArgumentException(\"The config (\" + config\n+                    + \") has a variableName (\" + variableName\n+                    + \") which is not a valid planning variable on entityClass (\"\n+                    + entityDescriptor.getEntityClass() + \").\\n\"\n+                    + entityDescriptor.buildInvalidVariableNameExceptionMessage(variableName));\n+        }\n+        return variableDescriptor;\n+    }\n+\n+    protected GenuineVariableDescriptor deduceVariableDescriptor(EntityDescriptor entityDescriptor) {\n+        Collection<GenuineVariableDescriptor> variableDescriptors = entityDescriptor.getGenuineVariableDescriptors();\n+        if (variableDescriptors.size() != 1) {\n+            throw new IllegalArgumentException(\"The config (\" + config\n+                    + \") has no configured variableName for entityClass (\" + entityDescriptor.getEntityClass()\n+                    + \") and because there are multiple variableNames (\"\n+                    + entityDescriptor.getGenuineVariableNameSet()\n+                    + \"), it cannot be deduced automatically.\");\n+        }\n+        return variableDescriptors.iterator().next();\n+    }\n+\n+    protected List<GenuineVariableDescriptor> deduceVariableDescriptorList(EntityDescriptor entityDescriptor,\n+            List<String> variableNameIncludeList) {\n+        Objects.requireNonNull(entityDescriptor);\n+        List<GenuineVariableDescriptor> variableDescriptorList = entityDescriptor.getGenuineVariableDescriptorList();\n+        if (variableNameIncludeList == null) {\n+            return variableDescriptorList;\n+        }\n+        List<GenuineVariableDescriptor> resolvedVariableDescriptorList =\n+                new ArrayList<>(variableDescriptorList.size());\n+        for (String variableNameInclude : variableNameIncludeList) {\n+            boolean found = false;\n+            for (GenuineVariableDescriptor variableDescriptor : variableDescriptorList) {\n+                if (variableDescriptor.getVariableName().equals(variableNameInclude)) {\n+                    resolvedVariableDescriptorList.add(variableDescriptor);\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (!found) {\n+                throw new IllegalArgumentException(\"The config (\" + this\n+                        + \") has a variableNameInclude (\" + variableNameInclude\n+                        + \") which does not exist in the entity (\" + entityDescriptor.getEntityClass()\n+                        + \")'s variableDescriptorList (\" + variableDescriptorList + \").\");\n+            }\n+        }\n+        return resolvedVariableDescriptorList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53325e9463ef79cb7cc6a0331aed08a452937964"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzOTk2OA==", "bodyText": "How about:\nboolean distributionEnabled = false;\nswitch (nearbySelectionConfig.getNearbySelectionDistributionType()) {\n     case LINEAR_DISTRIBUTION:\n          distributionEnabled = nearbySelectionConfig.getLinearDistributionSizeMaximum() != null;\n          break;\n     ...\n}\n\nLess repetition, and in my opinion more clarity.", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475239968", "createdAt": "2020-08-23T16:43:26Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/common/nearby/NearbyRandomFactory.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.heuristic.selector.common.nearby;\n+\n+import static org.apache.commons.lang3.ObjectUtils.defaultIfNull;\n+\n+import org.optaplanner.core.config.heuristic.selector.common.nearby.NearbySelectionConfig;\n+import org.optaplanner.core.config.heuristic.selector.common.nearby.NearbySelectionDistributionType;\n+\n+public class NearbyRandomFactory {\n+\n+    public static NearbyRandomFactory create(NearbySelectionConfig nearbySelectionConfig) {\n+        return new NearbyRandomFactory(nearbySelectionConfig);\n+    }\n+\n+    private final NearbySelectionConfig nearbySelectionConfig;\n+\n+    public NearbyRandomFactory(NearbySelectionConfig nearbySelectionConfig) {\n+        this.nearbySelectionConfig = nearbySelectionConfig;\n+    }\n+\n+    public NearbyRandom buildNearbyRandom(boolean randomSelection) {\n+        boolean blockDistributionEnabled =\n+                nearbySelectionConfig.getNearbySelectionDistributionType() == NearbySelectionDistributionType.BLOCK_DISTRIBUTION\n+                        || nearbySelectionConfig.getBlockDistributionSizeMinimum() != null\n+                        || nearbySelectionConfig.getBlockDistributionSizeMaximum() != null\n+                        || nearbySelectionConfig.getBlockDistributionSizeRatio() != null\n+                        || nearbySelectionConfig.getBlockDistributionUniformDistributionProbability() != null;\n+        boolean linearDistributionEnabled = nearbySelectionConfig\n+                .getNearbySelectionDistributionType() == NearbySelectionDistributionType.LINEAR_DISTRIBUTION\n+                || nearbySelectionConfig.getLinearDistributionSizeMaximum() != null;\n+        boolean parabolicDistributionEnabled = nearbySelectionConfig\n+                .getNearbySelectionDistributionType() == NearbySelectionDistributionType.PARABOLIC_DISTRIBUTION\n+                || nearbySelectionConfig.getParabolicDistributionSizeMaximum() != null;\n+        boolean betaDistributionEnabled =\n+                nearbySelectionConfig.getNearbySelectionDistributionType() == NearbySelectionDistributionType.BETA_DISTRIBUTION\n+                        || nearbySelectionConfig.getBetaDistributionAlpha() != null\n+                        || nearbySelectionConfig.getBetaDistributionBeta() != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53325e9463ef79cb7cc6a0331aed08a452937964"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI0MDEwOA==", "bodyText": "Implementing my previous comment would complicate this. But I suppose you could set these variables in the switch directly.", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475240108", "createdAt": "2020-08-23T16:44:49Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/common/nearby/NearbyRandomFactory.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.heuristic.selector.common.nearby;\n+\n+import static org.apache.commons.lang3.ObjectUtils.defaultIfNull;\n+\n+import org.optaplanner.core.config.heuristic.selector.common.nearby.NearbySelectionConfig;\n+import org.optaplanner.core.config.heuristic.selector.common.nearby.NearbySelectionDistributionType;\n+\n+public class NearbyRandomFactory {\n+\n+    public static NearbyRandomFactory create(NearbySelectionConfig nearbySelectionConfig) {\n+        return new NearbyRandomFactory(nearbySelectionConfig);\n+    }\n+\n+    private final NearbySelectionConfig nearbySelectionConfig;\n+\n+    public NearbyRandomFactory(NearbySelectionConfig nearbySelectionConfig) {\n+        this.nearbySelectionConfig = nearbySelectionConfig;\n+    }\n+\n+    public NearbyRandom buildNearbyRandom(boolean randomSelection) {\n+        boolean blockDistributionEnabled =\n+                nearbySelectionConfig.getNearbySelectionDistributionType() == NearbySelectionDistributionType.BLOCK_DISTRIBUTION\n+                        || nearbySelectionConfig.getBlockDistributionSizeMinimum() != null\n+                        || nearbySelectionConfig.getBlockDistributionSizeMaximum() != null\n+                        || nearbySelectionConfig.getBlockDistributionSizeRatio() != null\n+                        || nearbySelectionConfig.getBlockDistributionUniformDistributionProbability() != null;\n+        boolean linearDistributionEnabled = nearbySelectionConfig\n+                .getNearbySelectionDistributionType() == NearbySelectionDistributionType.LINEAR_DISTRIBUTION\n+                || nearbySelectionConfig.getLinearDistributionSizeMaximum() != null;\n+        boolean parabolicDistributionEnabled = nearbySelectionConfig\n+                .getNearbySelectionDistributionType() == NearbySelectionDistributionType.PARABOLIC_DISTRIBUTION\n+                || nearbySelectionConfig.getParabolicDistributionSizeMaximum() != null;\n+        boolean betaDistributionEnabled =\n+                nearbySelectionConfig.getNearbySelectionDistributionType() == NearbySelectionDistributionType.BETA_DISTRIBUTION\n+                        || nearbySelectionConfig.getBetaDistributionAlpha() != null\n+                        || nearbySelectionConfig.getBetaDistributionBeta() != null;\n+        if (!randomSelection) {\n+            if (blockDistributionEnabled || linearDistributionEnabled || parabolicDistributionEnabled\n+                    || betaDistributionEnabled) {\n+                throw new IllegalArgumentException(\"The nearbySelectorConfig (\" + nearbySelectionConfig\n+                        + \") with randomSelection (\" + randomSelection\n+                        + \") has distribution parameters.\");\n+            }\n+            return null;\n+        }\n+        if (blockDistributionEnabled && linearDistributionEnabled) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53325e9463ef79cb7cc6a0331aed08a452937964"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI0MDI1Mw==", "bodyText": "Personally, I'd make this part of the switch, too. There should only be one place where decisions are made from a single piece of data.", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475240253", "createdAt": "2020-08-23T16:45:52Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/common/nearby/NearbyRandomFactory.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.heuristic.selector.common.nearby;\n+\n+import static org.apache.commons.lang3.ObjectUtils.defaultIfNull;\n+\n+import org.optaplanner.core.config.heuristic.selector.common.nearby.NearbySelectionConfig;\n+import org.optaplanner.core.config.heuristic.selector.common.nearby.NearbySelectionDistributionType;\n+\n+public class NearbyRandomFactory {\n+\n+    public static NearbyRandomFactory create(NearbySelectionConfig nearbySelectionConfig) {\n+        return new NearbyRandomFactory(nearbySelectionConfig);\n+    }\n+\n+    private final NearbySelectionConfig nearbySelectionConfig;\n+\n+    public NearbyRandomFactory(NearbySelectionConfig nearbySelectionConfig) {\n+        this.nearbySelectionConfig = nearbySelectionConfig;\n+    }\n+\n+    public NearbyRandom buildNearbyRandom(boolean randomSelection) {\n+        boolean blockDistributionEnabled =\n+                nearbySelectionConfig.getNearbySelectionDistributionType() == NearbySelectionDistributionType.BLOCK_DISTRIBUTION\n+                        || nearbySelectionConfig.getBlockDistributionSizeMinimum() != null\n+                        || nearbySelectionConfig.getBlockDistributionSizeMaximum() != null\n+                        || nearbySelectionConfig.getBlockDistributionSizeRatio() != null\n+                        || nearbySelectionConfig.getBlockDistributionUniformDistributionProbability() != null;\n+        boolean linearDistributionEnabled = nearbySelectionConfig\n+                .getNearbySelectionDistributionType() == NearbySelectionDistributionType.LINEAR_DISTRIBUTION\n+                || nearbySelectionConfig.getLinearDistributionSizeMaximum() != null;\n+        boolean parabolicDistributionEnabled = nearbySelectionConfig\n+                .getNearbySelectionDistributionType() == NearbySelectionDistributionType.PARABOLIC_DISTRIBUTION\n+                || nearbySelectionConfig.getParabolicDistributionSizeMaximum() != null;\n+        boolean betaDistributionEnabled =\n+                nearbySelectionConfig.getNearbySelectionDistributionType() == NearbySelectionDistributionType.BETA_DISTRIBUTION\n+                        || nearbySelectionConfig.getBetaDistributionAlpha() != null\n+                        || nearbySelectionConfig.getBetaDistributionBeta() != null;\n+        if (!randomSelection) {\n+            if (blockDistributionEnabled || linearDistributionEnabled || parabolicDistributionEnabled\n+                    || betaDistributionEnabled) {\n+                throw new IllegalArgumentException(\"The nearbySelectorConfig (\" + nearbySelectionConfig\n+                        + \") with randomSelection (\" + randomSelection\n+                        + \") has distribution parameters.\");\n+            }\n+            return null;\n+        }\n+        if (blockDistributionEnabled && linearDistributionEnabled) {\n+            throw new IllegalArgumentException(\"The nearbySelectorConfig (\" + nearbySelectionConfig\n+                    + \") has both blockDistribution and linearDistribution parameters.\");\n+        }\n+        if (blockDistributionEnabled && parabolicDistributionEnabled) {\n+            throw new IllegalArgumentException(\"The nearbySelectorConfig (\" + nearbySelectionConfig\n+                    + \") has both blockDistribution and parabolicDistribution parameters.\");\n+        }\n+        if (blockDistributionEnabled && betaDistributionEnabled) {\n+            throw new IllegalArgumentException(\"The nearbySelectorConfig (\" + nearbySelectionConfig\n+                    + \") has both blockDistribution and betaDistribution parameters.\");\n+        }\n+        if (linearDistributionEnabled && parabolicDistributionEnabled) {\n+            throw new IllegalArgumentException(\"The nearbySelectorConfig (\" + nearbySelectionConfig\n+                    + \") has both linearDistribution and parabolicDistribution parameters.\");\n+        }\n+        if (linearDistributionEnabled && betaDistributionEnabled) {\n+            throw new IllegalArgumentException(\"The nearbySelectorConfig (\" + nearbySelectionConfig\n+                    + \") has both linearDistribution and betaDistribution parameters.\");\n+        }\n+        if (parabolicDistributionEnabled && betaDistributionEnabled) {\n+            throw new IllegalArgumentException(\"The nearbySelectorConfig (\" + nearbySelectionConfig\n+                    + \") has both parabolicDistribution and betaDistribution parameters.\");\n+        }\n+        if (blockDistributionEnabled) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53325e9463ef79cb7cc6a0331aed08a452937964"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI0MDMyMg==", "bodyText": "Good that you're not doing mutation testing. You'd grow old testing all the permutations of this particular condition.", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475240322", "createdAt": "2020-08-23T16:46:46Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/entity/EntitySelectorFactory.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.heuristic.selector.entity;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.common.decorator.SelectionSorterOrder;\n+import org.optaplanner.core.config.heuristic.selector.common.nearby.NearbySelectionConfig;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySelectorConfig;\n+import org.optaplanner.core.config.util.ConfigUtils;\n+import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n+import org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+import org.optaplanner.core.impl.heuristic.selector.AbstractSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.ComparatorSelectionSorter;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionFilter;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionProbabilityWeightFactory;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionSorter;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionSorterWeightFactory;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.WeightFactorySelectionSorter;\n+import org.optaplanner.core.impl.heuristic.selector.common.nearby.NearbyDistanceMeter;\n+import org.optaplanner.core.impl.heuristic.selector.common.nearby.NearbyRandom;\n+import org.optaplanner.core.impl.heuristic.selector.common.nearby.NearbyRandomFactory;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.CachingEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.FilteringEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.ProbabilityEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.SelectedCountLimitEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.ShufflingEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.SortingEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.mimic.EntityMimicRecorder;\n+import org.optaplanner.core.impl.heuristic.selector.entity.mimic.MimicRecordingEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.mimic.MimicReplayingEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.nearby.NearEntityNearbyEntitySelector;\n+\n+public class EntitySelectorFactory extends AbstractSelectorFactory<EntitySelectorConfig> {\n+\n+    public static EntitySelectorFactory create(EntitySelectorConfig entitySelectorConfig) {\n+        return new EntitySelectorFactory(entitySelectorConfig);\n+    }\n+\n+    public EntitySelectorFactory(EntitySelectorConfig entitySelectorConfig) {\n+        super(entitySelectorConfig);\n+    }\n+\n+    public EntityDescriptor extractEntityDescriptor(HeuristicConfigPolicy configPolicy) {\n+        if (config.getEntityClass() != null) {\n+            SolutionDescriptor solutionDescriptor = configPolicy.getSolutionDescriptor();\n+            EntityDescriptor entityDescriptor = solutionDescriptor.getEntityDescriptorStrict(config.getEntityClass());\n+            if (entityDescriptor == null) {\n+                throw new IllegalArgumentException(\"The selectorConfig (\" + config\n+                        + \") has an entityClass (\" + config.getEntityClass() + \") that is not a known planning entity.\\n\"\n+                        + \"Check your solver configuration. If that class (\" + config.getEntityClass().getSimpleName()\n+                        + \") is not in the entityClassSet (\" + solutionDescriptor.getEntityClassSet()\n+                        + \"), check your \" + PlanningSolution.class.getSimpleName()\n+                        + \" implementation's annotated methods too.\");\n+            }\n+            return entityDescriptor;\n+        } else if (config.getMimicSelectorRef() != null) {\n+            return configPolicy.getEntityMimicRecorder(config.getMimicSelectorRef()).getEntityDescriptor();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param configPolicy never null\n+     * @param minimumCacheType never null, If caching is used (different from {@link SelectionCacheType#JUST_IN_TIME}),\n+     *        then it should be at least this {@link SelectionCacheType} because an ancestor already uses such caching\n+     *        and less would be pointless.\n+     * @param inheritedSelectionOrder never null\n+     * @return never null\n+     */\n+    public EntitySelector buildEntitySelector(HeuristicConfigPolicy configPolicy, SelectionCacheType minimumCacheType,\n+            SelectionOrder inheritedSelectionOrder) {\n+        if (config.getMimicSelectorRef() != null) {\n+            return buildMimicReplaying(configPolicy);\n+        }\n+        EntityDescriptor entityDescriptor =\n+                config.getEntityClass() == null ? deduceEntityDescriptor(configPolicy.getSolutionDescriptor())\n+                        : deduceEntityDescriptor(configPolicy.getSolutionDescriptor(), config.getEntityClass());\n+        SelectionCacheType resolvedCacheType = SelectionCacheType.resolve(config.getCacheType(), minimumCacheType);\n+        SelectionOrder resolvedSelectionOrder = SelectionOrder.resolve(config.getSelectionOrder(), inheritedSelectionOrder);\n+\n+        if (config.getNearbySelectionConfig() != null) {\n+            config.getNearbySelectionConfig().validateNearby(resolvedCacheType, resolvedSelectionOrder);\n+        }\n+        validateCacheTypeVersusSelectionOrder(resolvedCacheType, resolvedSelectionOrder);\n+        validateSorting(resolvedSelectionOrder);\n+        validateProbability(resolvedSelectionOrder);\n+        validateSelectedLimit(minimumCacheType);\n+\n+        // baseEntitySelector and lower should be SelectionOrder.ORIGINAL if they are going to get cached completely\n+        boolean baseRandomSelection = determineBaseRandomSelection(entityDescriptor, resolvedCacheType, resolvedSelectionOrder);\n+        SelectionCacheType baseSelectionCacheType = SelectionCacheType.max(minimumCacheType, resolvedCacheType);\n+        EntitySelector entitySelector = buildBaseEntitySelector(entityDescriptor, baseSelectionCacheType, baseRandomSelection);\n+        if (config.getNearbySelectionConfig() != null) {\n+            // TODO Static filtering (such as movableEntitySelectionFilter) should affect nearbySelection\n+            entitySelector = applyNearbySelection(configPolicy, config.getNearbySelectionConfig(), minimumCacheType,\n+                    resolvedSelectionOrder, entitySelector);\n+        }\n+        entitySelector = applyFiltering(entitySelector);\n+        entitySelector = applySorting(resolvedCacheType, resolvedSelectionOrder, entitySelector);\n+        entitySelector = applyProbability(resolvedCacheType, resolvedSelectionOrder, entitySelector);\n+        entitySelector = applyShuffling(resolvedCacheType, resolvedSelectionOrder, entitySelector);\n+        entitySelector = applyCaching(resolvedCacheType, resolvedSelectionOrder, entitySelector);\n+        entitySelector = applySelectedLimit(resolvedSelectionOrder, entitySelector);\n+        entitySelector = applyMimicRecording(configPolicy, entitySelector);\n+        return entitySelector;\n+    }\n+\n+    protected EntitySelector buildMimicReplaying(HeuristicConfigPolicy configPolicy) {\n+        if (config.getId() != null\n+                || config.getEntityClass() != null\n+                || config.getCacheType() != null\n+                || config.getSelectionOrder() != null\n+                || config.getNearbySelectionConfig() != null\n+                || config.getFilterClass() != null\n+                || config.getSorterManner() != null\n+                || config.getSorterComparatorClass() != null\n+                || config.getSorterWeightFactoryClass() != null\n+                || config.getSorterOrder() != null\n+                || config.getSorterClass() != null\n+                || config.getProbabilityWeightFactoryClass() != null\n+                || config.getSelectedCountLimit() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53325e9463ef79cb7cc6a0331aed08a452937964"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI0MDQ2Nw==", "bodyText": "But to be constructive here - I'd add all of the calls into a stream, and then filter anything non null. That way, the code would  more readily express what you're trying to do.", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475240467", "createdAt": "2020-08-23T16:48:23Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/entity/EntitySelectorFactory.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.heuristic.selector.entity;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.common.decorator.SelectionSorterOrder;\n+import org.optaplanner.core.config.heuristic.selector.common.nearby.NearbySelectionConfig;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySelectorConfig;\n+import org.optaplanner.core.config.util.ConfigUtils;\n+import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n+import org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+import org.optaplanner.core.impl.heuristic.selector.AbstractSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.ComparatorSelectionSorter;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionFilter;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionProbabilityWeightFactory;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionSorter;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionSorterWeightFactory;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.WeightFactorySelectionSorter;\n+import org.optaplanner.core.impl.heuristic.selector.common.nearby.NearbyDistanceMeter;\n+import org.optaplanner.core.impl.heuristic.selector.common.nearby.NearbyRandom;\n+import org.optaplanner.core.impl.heuristic.selector.common.nearby.NearbyRandomFactory;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.CachingEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.FilteringEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.ProbabilityEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.SelectedCountLimitEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.ShufflingEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.SortingEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.mimic.EntityMimicRecorder;\n+import org.optaplanner.core.impl.heuristic.selector.entity.mimic.MimicRecordingEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.mimic.MimicReplayingEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.nearby.NearEntityNearbyEntitySelector;\n+\n+public class EntitySelectorFactory extends AbstractSelectorFactory<EntitySelectorConfig> {\n+\n+    public static EntitySelectorFactory create(EntitySelectorConfig entitySelectorConfig) {\n+        return new EntitySelectorFactory(entitySelectorConfig);\n+    }\n+\n+    public EntitySelectorFactory(EntitySelectorConfig entitySelectorConfig) {\n+        super(entitySelectorConfig);\n+    }\n+\n+    public EntityDescriptor extractEntityDescriptor(HeuristicConfigPolicy configPolicy) {\n+        if (config.getEntityClass() != null) {\n+            SolutionDescriptor solutionDescriptor = configPolicy.getSolutionDescriptor();\n+            EntityDescriptor entityDescriptor = solutionDescriptor.getEntityDescriptorStrict(config.getEntityClass());\n+            if (entityDescriptor == null) {\n+                throw new IllegalArgumentException(\"The selectorConfig (\" + config\n+                        + \") has an entityClass (\" + config.getEntityClass() + \") that is not a known planning entity.\\n\"\n+                        + \"Check your solver configuration. If that class (\" + config.getEntityClass().getSimpleName()\n+                        + \") is not in the entityClassSet (\" + solutionDescriptor.getEntityClassSet()\n+                        + \"), check your \" + PlanningSolution.class.getSimpleName()\n+                        + \" implementation's annotated methods too.\");\n+            }\n+            return entityDescriptor;\n+        } else if (config.getMimicSelectorRef() != null) {\n+            return configPolicy.getEntityMimicRecorder(config.getMimicSelectorRef()).getEntityDescriptor();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param configPolicy never null\n+     * @param minimumCacheType never null, If caching is used (different from {@link SelectionCacheType#JUST_IN_TIME}),\n+     *        then it should be at least this {@link SelectionCacheType} because an ancestor already uses such caching\n+     *        and less would be pointless.\n+     * @param inheritedSelectionOrder never null\n+     * @return never null\n+     */\n+    public EntitySelector buildEntitySelector(HeuristicConfigPolicy configPolicy, SelectionCacheType minimumCacheType,\n+            SelectionOrder inheritedSelectionOrder) {\n+        if (config.getMimicSelectorRef() != null) {\n+            return buildMimicReplaying(configPolicy);\n+        }\n+        EntityDescriptor entityDescriptor =\n+                config.getEntityClass() == null ? deduceEntityDescriptor(configPolicy.getSolutionDescriptor())\n+                        : deduceEntityDescriptor(configPolicy.getSolutionDescriptor(), config.getEntityClass());\n+        SelectionCacheType resolvedCacheType = SelectionCacheType.resolve(config.getCacheType(), minimumCacheType);\n+        SelectionOrder resolvedSelectionOrder = SelectionOrder.resolve(config.getSelectionOrder(), inheritedSelectionOrder);\n+\n+        if (config.getNearbySelectionConfig() != null) {\n+            config.getNearbySelectionConfig().validateNearby(resolvedCacheType, resolvedSelectionOrder);\n+        }\n+        validateCacheTypeVersusSelectionOrder(resolvedCacheType, resolvedSelectionOrder);\n+        validateSorting(resolvedSelectionOrder);\n+        validateProbability(resolvedSelectionOrder);\n+        validateSelectedLimit(minimumCacheType);\n+\n+        // baseEntitySelector and lower should be SelectionOrder.ORIGINAL if they are going to get cached completely\n+        boolean baseRandomSelection = determineBaseRandomSelection(entityDescriptor, resolvedCacheType, resolvedSelectionOrder);\n+        SelectionCacheType baseSelectionCacheType = SelectionCacheType.max(minimumCacheType, resolvedCacheType);\n+        EntitySelector entitySelector = buildBaseEntitySelector(entityDescriptor, baseSelectionCacheType, baseRandomSelection);\n+        if (config.getNearbySelectionConfig() != null) {\n+            // TODO Static filtering (such as movableEntitySelectionFilter) should affect nearbySelection\n+            entitySelector = applyNearbySelection(configPolicy, config.getNearbySelectionConfig(), minimumCacheType,\n+                    resolvedSelectionOrder, entitySelector);\n+        }\n+        entitySelector = applyFiltering(entitySelector);\n+        entitySelector = applySorting(resolvedCacheType, resolvedSelectionOrder, entitySelector);\n+        entitySelector = applyProbability(resolvedCacheType, resolvedSelectionOrder, entitySelector);\n+        entitySelector = applyShuffling(resolvedCacheType, resolvedSelectionOrder, entitySelector);\n+        entitySelector = applyCaching(resolvedCacheType, resolvedSelectionOrder, entitySelector);\n+        entitySelector = applySelectedLimit(resolvedSelectionOrder, entitySelector);\n+        entitySelector = applyMimicRecording(configPolicy, entitySelector);\n+        return entitySelector;\n+    }\n+\n+    protected EntitySelector buildMimicReplaying(HeuristicConfigPolicy configPolicy) {\n+        if (config.getId() != null\n+                || config.getEntityClass() != null\n+                || config.getCacheType() != null\n+                || config.getSelectionOrder() != null\n+                || config.getNearbySelectionConfig() != null\n+                || config.getFilterClass() != null\n+                || config.getSorterManner() != null\n+                || config.getSorterComparatorClass() != null\n+                || config.getSorterWeightFactoryClass() != null\n+                || config.getSorterOrder() != null\n+                || config.getSorterClass() != null\n+                || config.getProbabilityWeightFactoryClass() != null\n+                || config.getSelectedCountLimit() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI0MDMyMg=="}, "originalCommit": {"oid": "53325e9463ef79cb7cc6a0331aed08a452937964"}, "originalPosition": 143}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47138bafba7e3b7064f1a21d0582ecb80cda6493", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/47138bafba7e3b7064f1a21d0582ecb80cda6493", "committedDate": "2020-08-24T06:19:40Z", "message": "PLANNER-2116 Externalize build methods of Selectors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01b80ddeaa5cf67d157c6b5563a8b2fa09d5f064", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/01b80ddeaa5cf67d157c6b5563a8b2fa09d5f064", "committedDate": "2020-08-24T06:19:40Z", "message": "PLANNER-2116 Externalize build method of BestSolutionRecaller"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ceceffefc59c6de78aa917e3724c832a55ff0f6", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/8ceceffefc59c6de78aa917e3724c832a55ff0f6", "committedDate": "2020-08-24T06:19:40Z", "message": "Update revapi-config.json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f187cd2e7ed33a2cbc9955146cfc5c3575b4486", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/2f187cd2e7ed33a2cbc9955146cfc5c3575b4486", "committedDate": "2020-08-24T06:19:40Z", "message": "Remove unused method parameters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c14620bbb73f6eef921c374776f24a1ae6f4623", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/5c14620bbb73f6eef921c374776f24a1ae6f4623", "committedDate": "2020-08-24T06:19:40Z", "message": "Add QueuedValuePlacerFactoryTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d045caa63ca78bff1ce56be364dbac09fb04883", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/5d045caa63ca78bff1ce56be364dbac09fb04883", "committedDate": "2020-08-24T06:19:40Z", "message": "Add SubChainSelectorFactoryTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7999651332cda4286d9832c49e343f08e4414a98", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/7999651332cda4286d9832c49e343f08e4414a98", "committedDate": "2020-08-24T06:19:40Z", "message": "Test applyFiltering in ValueSelectorFactory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6549549a64865941f2b7b85545e716a4aa3207d3", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/6549549a64865941f2b7b85545e716a4aa3207d3", "committedDate": "2020-08-24T06:19:40Z", "message": "Increase coverage of value and entity selection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "235a22787eafec8d0a5be84703692b12b290668e", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/235a22787eafec8d0a5be84703692b12b290668e", "committedDate": "2020-08-24T06:19:40Z", "message": "Fix formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccdae7505a8525cbff7c851ac1d8d711a8ec5efd", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/ccdae7505a8525cbff7c851ac1d8d711a8ec5efd", "committedDate": "2020-08-24T06:19:40Z", "message": "Increase coverage of move selector factories"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "998a6f175de3e58c6726715bc3fc90e26ce9e7cb", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/998a6f175de3e58c6726715bc3fc90e26ce9e7cb", "committedDate": "2020-08-24T06:19:40Z", "message": "Add test for configuration inheritance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a22bcf5ae02a278b81fca8cb72a6df80920cac1", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/2a22bcf5ae02a278b81fca8cb72a6df80920cac1", "committedDate": "2020-08-24T06:19:40Z", "message": "Check for entity class nullity"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "53325e9463ef79cb7cc6a0331aed08a452937964", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/53325e9463ef79cb7cc6a0331aed08a452937964", "committedDate": "2020-08-21T15:02:31Z", "message": "Check for entity class nullity"}, "afterCommit": {"oid": "b1e638da6ac8ff38d2486727f01bc27e8d44aeb2", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/b1e638da6ac8ff38d2486727f01bc27e8d44aeb2", "committedDate": "2020-08-24T10:05:41Z", "message": "Address review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMzI0Mjcy", "url": "https://github.com/kiegroup/optaplanner/pull/893#pullrequestreview-473324272", "createdAt": "2020-08-24T10:16:15Z", "commit": {"oid": "b1e638da6ac8ff38d2486727f01bc27e8d44aeb2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b045216c7c0d0d36852d621ad069463db0d30338", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/b045216c7c0d0d36852d621ad069463db0d30338", "committedDate": "2020-08-24T11:15:48Z", "message": "Address review comments."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b1e638da6ac8ff38d2486727f01bc27e8d44aeb2", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/b1e638da6ac8ff38d2486727f01bc27e8d44aeb2", "committedDate": "2020-08-24T10:05:41Z", "message": "Address review comments."}, "afterCommit": {"oid": "b045216c7c0d0d36852d621ad069463db0d30338", "author": {"user": {"login": "rsynek", "name": "Radovan Synek"}}, "url": "https://github.com/kiegroup/optaplanner/commit/b045216c7c0d0d36852d621ad069463db0d30338", "committedDate": "2020-08-24T11:15:48Z", "message": "Address review comments."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3419, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}