{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4OTQwMDU3", "number": 702, "title": "PLANNER-1849 Constraint Stream support for regrouping", "bodyText": "", "createdAt": "2020-02-24T11:26:41Z", "url": "https://github.com/kiegroup/optaplanner/pull/702", "merged": true, "mergeCommit": {"oid": "212e7e78a2061cddb49c55fd5a078d26dd327387"}, "closed": true, "closedAt": "2020-02-25T12:25:57Z", "author": {"login": "triceo"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcHYpXDgH2gAyMzc4OTQwMDU3OjE1ZTIwM2QyMjY0ZGQ0MmRmZDlhNzgxOTU5NjUwZTIzNTZlZDRkZWQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcHtcI-gFqTM2MzkzMTMxMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "15e203d2264dd42dfd9a781959650e2356ed4ded", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/15e203d2264dd42dfd9a781959650e2356ed4ded", "committedDate": "2020-02-24T07:46:27Z", "message": "Reenable regrouping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45254b366a789a85c9a2d4b4d5b43971df79eb24", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/45254b366a789a85c9a2d4b4d5b43971df79eb24", "committedDate": "2020-02-24T07:54:21Z", "message": "Fix first test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b72ca9a1f0e3d7a2207d2c139ff8271d72d93ca8", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/b72ca9a1f0e3d7a2207d2c139ff8271d72d93ca8", "committedDate": "2020-02-24T09:56:22Z", "message": "PoC of recollect"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59ebe8100be6814c001ac481ec0f0295d96af2df", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/59ebe8100be6814c001ac481ec0f0295d96af2df", "committedDate": "2020-02-24T11:06:31Z", "message": "Unify code across all streams"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc4d32fdd887477a1847fea9ba9d0de553e24a00", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/dc4d32fdd887477a1847fea9ba9d0de553e24a00", "committedDate": "2020-02-24T11:24:33Z", "message": "Test for quad recollect as well"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMzIzNTAz", "url": "https://github.com/kiegroup/optaplanner/pull/702#pullrequestreview-363323503", "createdAt": "2020-02-24T11:29:02Z", "commit": {"oid": "dc4d32fdd887477a1847fea9ba9d0de553e24a00"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMToyOTowMlrOFtdeDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMToyOTowMlrOFtdeDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMzA2OQ==", "bodyText": "I do not know how we missed this, but until now, filtering joiners were not supported for tri/quad joins. (The API allowed it, but threw a runtime exception.) Filtering joiners only ever worked with bi joins.\nThis PR adds test coverage that uncovered the problem, and so I also add the fix. The fix is to bring the code to functional equivalence with bi joins.", "url": "https://github.com/kiegroup/optaplanner/pull/702#discussion_r383213069", "createdAt": "2020-02-24T11:29:02Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStream.java", "diffHunk": "@@ -196,7 +198,42 @@\n      * {@link TriJoiner joiners} are true\n      */\n     default <C> TriConstraintStream<A, B, C> join(Class<C> otherClass, TriJoiner<A, B, C>... joiners) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc4d32fdd887477a1847fea9ba9d0de553e24a00"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMzIzNjcy", "url": "https://github.com/kiegroup/optaplanner/pull/702#pullrequestreview-363323672", "createdAt": "2020-02-24T11:29:22Z", "commit": {"oid": "dc4d32fdd887477a1847fea9ba9d0de553e24a00"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMToyOToyM1rOFtdegw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMToyOToyM1rOFtdegw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMzE4Nw==", "bodyText": "Ditto.", "url": "https://github.com/kiegroup/optaplanner/pull/702#discussion_r383213187", "createdAt": "2020-02-24T11:29:23Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/tri/TriConstraintStream.java", "diffHunk": "@@ -197,7 +199,42 @@\n      * {@link QuadJoiner joiners} are true\n      */\n     default <D> QuadConstraintStream<A, B, C, D> join(Class<D> otherClass, QuadJoiner<A, B, C, D>... joiners) {\n-        return join(otherClass, AbstractQuadJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        // Make sure all indexing joiners, if any, come before filtering joiners. This is necessary for performance.\n+        for (int i = 0; i < joinerCount; i++) {\n+            QuadJoiner<A, B, C, D> joiner = joiners[i];\n+            if (indexOfFirstFilter >= 0) {\n+                if (!(joiner instanceof FilteringQuadJoiner)) {\n+                    throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow \" +\n+                            \"a filtering joiner (\" + joiners[indexOfFirstFilter] + \").\\n\" +\n+                            \"Maybe reorder the joiners such that filtering() joiners are later in the parameter list.\");\n+                }\n+            } else {\n+                if (joiner instanceof FilteringQuadJoiner) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.\n+            return join(otherClass, AbstractQuadJoiner.merge(joiners));\n+        }\n+        // Assemble the join stream that may be followed by filter stream.\n+        QuadConstraintStream<A, B, C, D> joined = indexOfFirstFilter == 0 ?\n+                join(otherClass) :\n+                join(otherClass, Arrays.copyOf(joiners, indexOfFirstFilter));\n+        int filterCount = joinerCount - indexOfFirstFilter;\n+        if (filterCount == 0) { // No filters, return the original join stream.\n+            return joined;\n+        }\n+        // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.\n+        FilteringQuadJoiner<A, B, C, D> filteringJoiner = (FilteringQuadJoiner<A, B, C, D>) joiners[indexOfFirstFilter];\n+        QuadPredicate<A, B, C, D> resultingFilter = filteringJoiner.getFilter();\n+        for (int i = indexOfFirstFilter + 1; i < joinerCount; i++) {\n+            FilteringQuadJoiner<A, B, C, D> anoterFilteringJoiner = (FilteringQuadJoiner<A, B, C, D>) joiners[i];\n+            resultingFilter = resultingFilter.and(anoterFilteringJoiner.getFilter());\n+        }\n+        return joined.filter(resultingFilter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc4d32fdd887477a1847fea9ba9d0de553e24a00"}, "originalPosition": 83}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fba710b28b30eaa8710b812066a64447761a3a0", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/5fba710b28b30eaa8710b812066a64447761a3a0", "committedDate": "2020-02-24T11:54:47Z", "message": "Test for single level regrouping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11c6ee9e0bf00b706199d1591c5b3af2b4a92019", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/11c6ee9e0bf00b706199d1591c5b3af2b4a92019", "committedDate": "2020-02-24T12:04:05Z", "message": "Add double regroups"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMzQ2NDc1", "url": "https://github.com/kiegroup/optaplanner/pull/702#pullrequestreview-363346475", "createdAt": "2020-02-24T12:14:06Z", "commit": {"oid": "dc4d32fdd887477a1847fea9ba9d0de553e24a00"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMjoxNDowN1rOFtekpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMjoxNDowN1rOFtekpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIzMTE0Mw==", "bodyText": "These 3 methods belong in PlannerTestUtils", "url": "https://github.com/kiegroup/optaplanner/pull/702#discussion_r383231143", "createdAt": "2020-02-24T12:14:07Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/AdvancedGroupByConstraintStreamTest.java", "diffHunk": "@@ -251,4 +341,21 @@ public void groupByAfterExists() {\n                 assertMatchWithScore(-2, solution.getFirstEntityGroup(), 2));\n     }\n \n+    private static <X> Set<X> asSet(X... x) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc4d32fdd887477a1847fea9ba9d0de553e24a00"}, "originalPosition": 269}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMzQ2NzE3", "url": "https://github.com/kiegroup/optaplanner/pull/702#pullrequestreview-363346717", "createdAt": "2020-02-24T12:14:37Z", "commit": {"oid": "dc4d32fdd887477a1847fea9ba9d0de553e24a00"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMjoxNDozN1rOFtelYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMjoxNDozN1rOFtelYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIzMTMyOQ==", "bodyText": "Still ignored? If so, can we mention why?", "url": "https://github.com/kiegroup/optaplanner/pull/702#discussion_r383231329", "createdAt": "2020-02-24T12:14:37Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/AdvancedGroupByConstraintStreamTest.java", "diffHunk": "@@ -71,80 +86,155 @@ public void collectedAndFiltered() {\n     }\n \n     @Test\n-    @Ignore(\"Regrouping not yet supported.\")\n     public void collectedFilteredRecollected() {\n         assumeDrools();\n-        TestdataLavishSolution solution = TestdataLavishSolution.generateSolution(2, 5, 1, 7);\n-        TestdataLavishEntityGroup entityGroup1 = new TestdataLavishEntityGroup(\"MyEntityGroup\");\n-        solution.getEntityGroupList().add(entityGroup1);\n-        TestdataLavishEntity entity1 = new TestdataLavishEntity(\"MyEntity 1\", entityGroup1, solution.getFirstValue());\n-        solution.getEntityList().add(entity1);\n-        TestdataLavishEntity entity2 = new TestdataLavishEntity(\"MyEntity 2\", entityGroup1, solution.getFirstValue());\n-        solution.getEntityList().add(entity2);\n-        TestdataLavishEntity entity3 = new TestdataLavishEntity(\"MyEntity 3\", solution.getFirstEntityGroup(),\n-                solution.getFirstValue());\n-        solution.getEntityList().add(entity3);\n+        TestdataLavishSolution solution = TestdataLavishSolution.generateSolution(2, 2, 2, 2);\n \n         InnerScoreDirector<TestdataLavishSolution> scoreDirector = buildScoreDirector((factory) -> {\n             return factory.from(TestdataLavishEntity.class)\n-                    .groupBy(ConstraintCollectors.count())\n-                    .filter(count -> count == 10)\n-                    .groupBy(ConstraintCollectors.count())\n-                    .penalize(TEST_CONSTRAINT_NAME, SimpleScore.ONE);\n+                    .groupBy(toSet())\n+                    .groupBy(sum(Set::size))\n+                    .penalize(TEST_CONSTRAINT_NAME, SimpleScore.ONE, count -> count);\n         });\n \n         // From scratch\n         scoreDirector.setWorkingSolution(solution);\n+        assertScore(scoreDirector, assertMatchWithScore(-2, 2));\n+\n+        // Incremental\n+        TestdataLavishEntity entity = solution.getFirstEntity();\n+        scoreDirector.beforeEntityRemoved(entity);\n+        solution.getEntityList().remove(entity);\n+        scoreDirector.afterEntityRemoved(entity);\n         assertScore(scoreDirector, assertMatchWithScore(-1, 1));\n+    }\n+\n+    @Test\n+    public void uniGroupByRecollected() {\n+        assumeDrools();\n+        TestdataLavishSolution solution = TestdataLavishSolution.generateSolution(2, 2, 2, 2);\n+\n+        InnerScoreDirector<TestdataLavishSolution> scoreDirector = buildScoreDirector((factory) -> {\n+            return factory.from(TestdataLavishEntity.class)\n+                    .groupBy(TestdataLavishEntity::getEntityGroup)\n+                    .groupBy(toSet())\n+                    .penalize(TEST_CONSTRAINT_NAME, SimpleScore.ONE, Set::size);\n+        });\n+\n+        TestdataLavishEntity entity1 = solution.getFirstEntity();\n+        TestdataLavishEntity entity2 = solution.getEntityList().get(1);\n+\n+        // From scratch\n+        scoreDirector.setWorkingSolution(solution);\n+        assertScore(scoreDirector,\n+                assertMatchWithScore(-2, asSet(entity1.getEntityGroup(), entity2.getEntityGroup())));\n \n         // Incremental\n-        Stream.of(entity1, entity2).forEach(entity -> {\n-            scoreDirector.beforeEntityRemoved(entity);\n-            solution.getEntityList().remove(entity);\n-            scoreDirector.afterEntityRemoved(entity);\n+        scoreDirector.beforeEntityRemoved(entity1);\n+        solution.getEntityList().remove(entity1);\n+        scoreDirector.afterEntityRemoved(entity1);\n+        assertScore(scoreDirector,\n+                assertMatchWithScore(-1, asSet(entity2.getEntityGroup())));\n+    }\n+\n+    @Test\n+    public void biGroupByRecollected() {\n+        assumeDrools();\n+        TestdataLavishSolution solution = TestdataLavishSolution.generateSolution(2, 3, 2, 5);\n+\n+        InnerScoreDirector<TestdataLavishSolution> scoreDirector = buildScoreDirector((factory) -> {\n+            return factory.fromUniquePair(TestdataLavishEntity.class, equal(TestdataLavishEntity::getEntityGroup))\n+                    // Stream of all unique entity bi tuples that share a group\n+                    .groupBy((entityA, entityB) -> entityA.getEntityGroup(), countBi())\n+                    .groupBy(toMap((g, c) -> g, (g, c) -> c, Integer::sum))\n+                    .penalize(TEST_CONSTRAINT_NAME, SimpleScore.ONE);\n         });\n-        assertScore(scoreDirector); // There is less than 10 entities, and therefore there are no penalties.\n+\n+        // From scratch\n+        scoreDirector.setWorkingSolution(solution);\n+        assertScore(scoreDirector,\n+                assertMatchWithScore(-1,\n+                        asMap(solution.getFirstEntityGroup(), 3, solution.getEntityGroupList().get(1), 1)));\n+\n+        // Incremental\n+        TestdataLavishEntity entity = solution.getFirstEntity();\n+        scoreDirector.beforeEntityRemoved(entity);\n+        solution.getEntityList().remove(entity);\n+        scoreDirector.afterEntityRemoved(entity);\n+        assertScore(scoreDirector,\n+                assertMatchWithScore(-1,\n+                        asMap(solution.getFirstEntityGroup(), 1, solution.getEntityGroupList().get(1), 1)));\n     }\n \n     @Test\n-    @Ignore(\"Regrouping not yet supported.\")\n-    public void bigroupBiregrouped() {\n+    public void triGroupByRecollected() {\n         assumeDrools();\n-        TestdataLavishSolution solution = TestdataLavishSolution.generateSolution(2, 5, 1, 7);\n-        TestdataLavishEntityGroup entityGroup1 = new TestdataLavishEntityGroup(\"MyEntityGroup\");\n-        solution.getEntityGroupList().add(entityGroup1);\n-        TestdataLavishEntity entity1 = new TestdataLavishEntity(\"MyEntity 1\", entityGroup1, solution.getFirstValue());\n-        solution.getEntityList().add(entity1);\n-        TestdataLavishEntity entity2 = new TestdataLavishEntity(\"MyEntity 2\", entityGroup1, solution.getFirstValue());\n-        solution.getEntityList().add(entity2);\n-        TestdataLavishEntity entity3 = new TestdataLavishEntity(\"MyEntity 3\", solution.getFirstEntityGroup(),\n-                solution.getFirstValue());\n-        solution.getEntityList().add(entity3);\n+        TestdataLavishSolution solution = TestdataLavishSolution.generateSolution(2, 3, 2, 6);\n \n         InnerScoreDirector<TestdataLavishSolution> scoreDirector = buildScoreDirector((factory) -> {\n             return factory.fromUniquePair(TestdataLavishEntity.class, equal(TestdataLavishEntity::getEntityGroup))\n-                    .groupBy((entityA, entityB) -> entityA.getEntityGroup())\n-                    .groupBy(Function.identity(), ConstraintCollectors.count())\n+                    .join(TestdataLavishEntity.class,\n+                            equal((a, b) -> a.getEntityGroup(), TestdataLavishEntity::getEntityGroup),\n+                            filtering((a, b, c) -> !Objects.equals(a, c) && !Objects.equals(b, c)))\n+                    // Stream of all unique entity tri tuples that share a group\n+                    .groupBy((entityA, entityB, entityC) -> entityA.getEntityGroup(), countTri())\n+                    .groupBy(toMap((g, c) -> g, (g, c) -> c, Integer::sum))\n                     .penalize(TEST_CONSTRAINT_NAME, SimpleScore.ONE);\n         });\n \n         // From scratch\n         scoreDirector.setWorkingSolution(solution);\n         assertScore(scoreDirector,\n-                assertMatchWithScore(-1, entityGroup1, 1),\n-                assertMatchWithScore(-1, solution.getFirstEntityGroup(), 1));\n+                assertMatchWithScore(-1,\n+                        asMap(solution.getFirstEntityGroup(), 3, solution.getEntityGroupList().get(1), 3)));\n \n         // Incremental\n-        Stream.of(entity1, entity2).forEach(entity -> {\n-            scoreDirector.beforeEntityRemoved(entity);\n-            solution.getEntityList().remove(entity);\n-            scoreDirector.afterEntityRemoved(entity);\n+        TestdataLavishEntity entity = solution.getFirstEntity();\n+        scoreDirector.beforeEntityRemoved(entity);\n+        solution.getEntityList().remove(entity);\n+        scoreDirector.afterEntityRemoved(entity);\n+        assertScore(scoreDirector,\n+                assertMatchWithScore(-1,\n+                        asMap(solution.getEntityGroupList().get(1), 3)));\n+    }\n+\n+    @Test\n+    public void quadGroupByRecollected() {\n+        assumeDrools();\n+        TestdataLavishSolution solution = TestdataLavishSolution.generateSolution(2, 3, 2, 8);\n+\n+        InnerScoreDirector<TestdataLavishSolution> scoreDirector = buildScoreDirector((factory) -> {\n+            return factory.fromUniquePair(TestdataLavishEntity.class, equal(TestdataLavishEntity::getEntityGroup))\n+                    .join(TestdataLavishEntity.class,\n+                            equal((a, b) -> a.getEntityGroup(), TestdataLavishEntity::getEntityGroup),\n+                            filtering((a, b, c) -> !Objects.equals(a, c) && !Objects.equals(b, c)))\n+                    .join(TestdataLavishEntity.class,\n+                            equal((a, b, c) -> a.getEntityGroup(), TestdataLavishEntity::getEntityGroup),\n+                            filtering((a, b, c, d) -> !Objects.equals(a, d) && !Objects.equals(b, d) && !Objects.equals(c, d)))\n+                    // Stream of all unique entity quad tuples that share a group\n+                    .groupBy((entityA, entityB, entityC, entityD) -> entityA.getEntityGroup(), countQuad())\n+                    .groupBy(toMap((g, c) -> g, (g, c) -> c, Integer::sum))\n+                    .penalize(TEST_CONSTRAINT_NAME, SimpleScore.ONE);\n         });\n-        assertScore(scoreDirector, assertMatchWithScore(-1, solution.getFirstEntityGroup(), 1));\n+\n+        // From scratch\n+        scoreDirector.setWorkingSolution(solution);\n+        assertScore(scoreDirector,\n+                assertMatchWithScore(-1,\n+                        asMap(solution.getFirstEntityGroup(), 12, solution.getEntityGroupList().get(1), 12)));\n+\n+        // Incremental\n+        TestdataLavishEntity entity = solution.getFirstEntity();\n+        scoreDirector.beforeEntityRemoved(entity);\n+        solution.getEntityList().remove(entity);\n+        scoreDirector.afterEntityRemoved(entity);\n+        assertScore(scoreDirector,\n+                assertMatchWithScore(-1,\n+                        asMap(solution.getEntityGroupList().get(1), 12)));\n     }\n \n     @Test\n-    @Ignore(\"Regrouping not yet supported.\")\n+    @Ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc4d32fdd887477a1847fea9ba9d0de553e24a00"}, "originalPosition": 234}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMzQ3NjU3", "url": "https://github.com/kiegroup/optaplanner/pull/702#pullrequestreview-363347657", "createdAt": "2020-02-24T12:16:23Z", "commit": {"oid": "dc4d32fdd887477a1847fea9ba9d0de553e24a00"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b80f63e259c15289c18b9ea4267ef0d31b999495", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/b80f63e259c15289c18b9ea4267ef0d31b999495", "committedDate": "2020-02-24T15:24:18Z", "message": "Share some code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "804f35673a29e7710620b400e0efce430cd83f1c", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/804f35673a29e7710620b400e0efce430cd83f1c", "committedDate": "2020-02-24T15:30:05Z", "message": "Reuse utility methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNDc3ODc5", "url": "https://github.com/kiegroup/optaplanner/pull/702#pullrequestreview-363477879", "createdAt": "2020-02-24T15:32:14Z", "commit": {"oid": "804f35673a29e7710620b400e0efce430cd83f1c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNTozMjoxNFrOFtk6IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNTozMjoxNFrOFtk6IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMzNDk0NA==", "bodyText": "I expect a lively discussion about this. :-)\nThis exists so that I can reuse JoinerUtils.join(...) across all the streams. It may be a lot of code for such a simple purpose, but it's just a level of abstraction. The code that is being shared thanks to this is complicated and needs to be kept identical across all the streams, so I think it's worth it.", "url": "https://github.com/kiegroup/optaplanner/pull/702#discussion_r383334944", "createdAt": "2020-02-24T15:32:14Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/common/ConstraintStreamHelper.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.common;\n+\n+interface ConstraintStreamHelper<Right, JoinedStream, Joiner, Predicate> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "804f35673a29e7710620b400e0efce430cd83f1c"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNDg2OTg0", "url": "https://github.com/kiegroup/optaplanner/pull/702#pullrequestreview-363486984", "createdAt": "2020-02-24T15:43:23Z", "commit": {"oid": "804f35673a29e7710620b400e0efce430cd83f1c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNTo0MzoyM1rOFtlWyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNTo0MzoyM1rOFtlWyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM0MjI4MA==", "bodyText": "Need the same name, except for Bi", "url": "https://github.com/kiegroup/optaplanner/pull/702#discussion_r383342280", "createdAt": "2020-02-24T15:43:23Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/common/BiConstraintStreamDescriptor.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.common;\n+\n+import java.util.function.BiPredicate;\n+\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.bi.BiJoiner;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.bi.AbstractBiJoiner;\n+import org.optaplanner.core.impl.score.stream.bi.FilteringBiJoiner;\n+\n+final class BiConstraintStreamDescriptor<A, B>\n+        implements ConstraintStreamHelper<B, BiConstraintStream<A, B>, BiJoiner<A, B>, BiPredicate<A, B>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "804f35673a29e7710620b400e0efce430cd83f1c"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNDg4NTcw", "url": "https://github.com/kiegroup/optaplanner/pull/702#pullrequestreview-363488570", "createdAt": "2020-02-24T15:45:19Z", "commit": {"oid": "804f35673a29e7710620b400e0efce430cd83f1c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNTo0NToyMFrOFtlbrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNTo0NToyMFrOFtlbrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM0MzUzMw==", "bodyText": "variable name", "url": "https://github.com/kiegroup/optaplanner/pull/702#discussion_r383343533", "createdAt": "2020-02-24T15:45:20Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/common/JoinerUtils.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.common;\n+\n+import java.util.Arrays;\n+\n+import org.optaplanner.core.api.score.stream.ConstraintStream;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.bi.BiJoiner;\n+import org.optaplanner.core.api.score.stream.quad.QuadConstraintStream;\n+import org.optaplanner.core.api.score.stream.quad.QuadJoiner;\n+import org.optaplanner.core.api.score.stream.tri.TriConstraintStream;\n+import org.optaplanner.core.api.score.stream.tri.TriJoiner;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+\n+public final class JoinerUtils {\n+\n+    public static <A, B> BiConstraintStream<A, B> join(UniConstraintStream<A> stream, Class<B> otherClass,\n+            BiJoiner<A, B>... joiners) {\n+        return join(new BiConstraintStreamDescriptor<>(stream), otherClass, joiners);\n+    }\n+\n+    public static <A, B, C> TriConstraintStream<A, B, C> join(BiConstraintStream<A, B> stream, Class<C> otherClass,\n+            TriJoiner<A, B, C>... joiners) {\n+        return join(new TriConstraintStreamDescriptor<>(stream), otherClass, joiners);\n+    }\n+\n+    public static <A, B, C, D> QuadConstraintStream<A, B, C, D> join(TriConstraintStream<A, B, C> stream,\n+            Class<D> otherClass, QuadJoiner<A, B, C, D>... joiners) {\n+        return join(new QuadConstraintStreamDescriptor<>(stream), otherClass, joiners);\n+    }\n+\n+    private static <Right, JoinedStream extends ConstraintStream, Joiner, Predicate> JoinedStream join(\n+            ConstraintStreamHelper<Right, JoinedStream, Joiner, Predicate> constraintStreamDescriptor,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "804f35673a29e7710620b400e0efce430cd83f1c"}, "originalPosition": 48}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73b4388e9f6a54977a910506f2ebd776de0dcc61", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/73b4388e9f6a54977a910506f2ebd776de0dcc61", "committedDate": "2020-02-24T16:57:23Z", "message": "Rename classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f92eec9428a9977c3e900674c506303ea6ff10bb", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/f92eec9428a9977c3e900674c506303ea6ff10bb", "committedDate": "2020-02-24T17:12:14Z", "message": "Remove JoinerUtils"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbfe500cb70026b45ceaa966aa961212cd4e406f", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/bbfe500cb70026b45ceaa966aa961212cd4e406f", "committedDate": "2020-02-24T17:19:09Z", "message": "Move classes to their final destinations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfa1bd887af262787a2ecb631c24c2e978252c2b", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/bfa1bd887af262787a2ecb631c24c2e978252c2b", "committedDate": "2020-02-24T17:26:43Z", "message": "Remove an obsolete note from the documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e73eb114ecbb46757ba1ea1322301b83e4bed663", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/e73eb114ecbb46757ba1ea1322301b83e4bed663", "committedDate": "2020-02-24T17:50:45Z", "message": "Fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b639034cc587c131d86c6583a0011c12da31bfd6", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/b639034cc587c131d86c6583a0011c12da31bfd6", "committedDate": "2020-02-24T17:57:04Z", "message": "Fix var name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca6bb9d07aa9dc0de430572724888fe8ca8bcd4b", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/ca6bb9d07aa9dc0de430572724888fe8ca8bcd4b", "committedDate": "2020-02-24T21:23:56Z", "message": "Remove unnecessary parentheses"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzOTMxMzEx", "url": "https://github.com/kiegroup/optaplanner/pull/702#pullrequestreview-363931311", "createdAt": "2020-02-25T08:00:01Z", "commit": {"oid": "ca6bb9d07aa9dc0de430572724888fe8ca8bcd4b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2864, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}