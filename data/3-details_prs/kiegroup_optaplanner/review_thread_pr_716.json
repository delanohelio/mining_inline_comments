{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1NTczMDM1", "number": 716, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMzowMTowOFrODmRh5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMzowMTowOFrODmRh5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNDU5Njg0OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/InnerConstraintFactory.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMzowMTowOFrOFzmA2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMzoxMzo1OVrOFzmZVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NDUwNA==", "bodyText": "There is a problem here.\nOriginally, the order of joiners in this code was joiner, lessThan(planningIdGetter). However, that breaks if the user wants to do:\nfromUniquePair(..., Joiners.filtering(...))\n\nBecause we fail fast when filtering() joiner is anything but last. This could be considered a bug that I only just now found out about.\nHowever, the other way around (putting lessThan() before filtering()) breaks Bavet, as Bavet only supports lessThan() when it's the last joiner.\nThe fail-fasts of filtering() and lessThan() in Bavet are mutually incompatible. Drools is fine.\nWhat do we want to do about this?", "url": "https://github.com/kiegroup/optaplanner/pull/716#discussion_r389644504", "createdAt": "2020-03-09T13:01:08Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/InnerConstraintFactory.java", "diffHunk": "@@ -41,6 +49,19 @@\n         return stream;\n     }\n \n+    @Override\n+    default <A> BiConstraintStream<A, A> fromUniquePair(Class<A> fromClass, BiJoiner<A, A> joiner) {\n+        MemberAccessor planningIdMemberAccessor = ConfigUtils.findPlanningIdMemberAccessor(fromClass);\n+        if (planningIdMemberAccessor == null) {\n+            throw new IllegalArgumentException(\"The fromClass (\" + fromClass + \") has no member with a @\"\n+                    + PlanningId.class.getSimpleName() + \" annotation,\"\n+                    + \" so the pairs can not be made unique ([A,B] vs [B,A]).\");\n+        }\n+        // TODO In Bavet breaks node sharing + involves unneeded indirection\n+        Function<A, Comparable> planningIdGetter = (fact) -> (Comparable<?>) planningIdMemberAccessor.executeGetter(fact);\n+        return from(fromClass).join(fromClass, lessThan(planningIdGetter), joiner);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6fa10c90c65de7188a75d64b0b6926a1ce23c4"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NzkyOA==", "bodyText": "I see 3 proposals:\nA) Leave as is (bad idea, fromUniquePair(..., Joiners.filtering(...)) doesn't work for CS-D and CS-B)\nB) Put lessThan() before filtering() - Is it a regression for Bavet? does this break any of the existing Bavet working examples?\nC) Like B), but add Bavet syntactic sugar to support filtering() to avoid any regressions of B.", "url": "https://github.com/kiegroup/optaplanner/pull/716#discussion_r389647928", "createdAt": "2020-03-09T13:08:24Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/InnerConstraintFactory.java", "diffHunk": "@@ -41,6 +49,19 @@\n         return stream;\n     }\n \n+    @Override\n+    default <A> BiConstraintStream<A, A> fromUniquePair(Class<A> fromClass, BiJoiner<A, A> joiner) {\n+        MemberAccessor planningIdMemberAccessor = ConfigUtils.findPlanningIdMemberAccessor(fromClass);\n+        if (planningIdMemberAccessor == null) {\n+            throw new IllegalArgumentException(\"The fromClass (\" + fromClass + \") has no member with a @\"\n+                    + PlanningId.class.getSimpleName() + \" annotation,\"\n+                    + \" so the pairs can not be made unique ([A,B] vs [B,A]).\");\n+        }\n+        // TODO In Bavet breaks node sharing + involves unneeded indirection\n+        Function<A, Comparable> planningIdGetter = (fact) -> (Comparable<?>) planningIdMemberAccessor.executeGetter(fact);\n+        return from(fromClass).join(fromClass, lessThan(planningIdGetter), joiner);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NDUwNA=="}, "originalCommit": {"oid": "1e6fa10c90c65de7188a75d64b0b6926a1ce23c4"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0OTYwMA==", "bodyText": "B) Yes, it actually breaks many tests.\nC) Could be doable.", "url": "https://github.com/kiegroup/optaplanner/pull/716#discussion_r389649600", "createdAt": "2020-03-09T13:11:41Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/InnerConstraintFactory.java", "diffHunk": "@@ -41,6 +49,19 @@\n         return stream;\n     }\n \n+    @Override\n+    default <A> BiConstraintStream<A, A> fromUniquePair(Class<A> fromClass, BiJoiner<A, A> joiner) {\n+        MemberAccessor planningIdMemberAccessor = ConfigUtils.findPlanningIdMemberAccessor(fromClass);\n+        if (planningIdMemberAccessor == null) {\n+            throw new IllegalArgumentException(\"The fromClass (\" + fromClass + \") has no member with a @\"\n+                    + PlanningId.class.getSimpleName() + \" annotation,\"\n+                    + \" so the pairs can not be made unique ([A,B] vs [B,A]).\");\n+        }\n+        // TODO In Bavet breaks node sharing + involves unneeded indirection\n+        Function<A, Comparable> planningIdGetter = (fact) -> (Comparable<?>) planningIdMemberAccessor.executeGetter(fact);\n+        return from(fromClass).join(fromClass, lessThan(planningIdGetter), joiner);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NDUwNA=="}, "originalCommit": {"oid": "1e6fa10c90c65de7188a75d64b0b6926a1ce23c4"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY1MDc3NA==", "bodyText": "I am -1 for B if and only if B has regressions. Otherwise I am ok with all.", "url": "https://github.com/kiegroup/optaplanner/pull/716#discussion_r389650774", "createdAt": "2020-03-09T13:13:59Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/InnerConstraintFactory.java", "diffHunk": "@@ -41,6 +49,19 @@\n         return stream;\n     }\n \n+    @Override\n+    default <A> BiConstraintStream<A, A> fromUniquePair(Class<A> fromClass, BiJoiner<A, A> joiner) {\n+        MemberAccessor planningIdMemberAccessor = ConfigUtils.findPlanningIdMemberAccessor(fromClass);\n+        if (planningIdMemberAccessor == null) {\n+            throw new IllegalArgumentException(\"The fromClass (\" + fromClass + \") has no member with a @\"\n+                    + PlanningId.class.getSimpleName() + \" annotation,\"\n+                    + \" so the pairs can not be made unique ([A,B] vs [B,A]).\");\n+        }\n+        // TODO In Bavet breaks node sharing + involves unneeded indirection\n+        Function<A, Comparable> planningIdGetter = (fact) -> (Comparable<?>) planningIdMemberAccessor.executeGetter(fact);\n+        return from(fromClass).join(fromClass, lessThan(planningIdGetter), joiner);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NDUwNA=="}, "originalCommit": {"oid": "1e6fa10c90c65de7188a75d64b0b6926a1ce23c4"}, "originalPosition": 44}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4455, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}