{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU5NTY0Mjk0", "number": 865, "title": "PLANNER-2078: Add Overlaps Joiners", "bodyText": "Also refactored the Joiners test to remove static field imports to make it clear what type the constants refer to.\nTODO: Other temporal/interval joiners (contains, consecutive)\nTODO: TriJoiner, QuadJoiner, PentaJoiner versions", "createdAt": "2020-07-30T20:13:44Z", "url": "https://github.com/kiegroup/optaplanner/pull/865", "merged": true, "mergeCommit": {"oid": "5a8ea9766ecce0a23947621b3682c1c7bc9b4238"}, "closed": true, "closedAt": "2020-09-14T20:53:39Z", "author": {"login": "Christopher-Chianelli"}, "timelineItems": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc6GESOAFqTQ1ODc1MTMxOQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdI2H0zgBqjM3NjQzOTcyNjA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NzUxMzE5", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-458751319", "createdAt": "2020-07-30T20:57:48Z", "commit": {"oid": "83a13331d007733cf9e0ee81292d1f25719c8678"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMDo1Nzo0OFrOG5zk7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMDo1Nzo0OFrOG5zk7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI2NzA1NA==", "bodyText": "Considering that these are not simple Joiners anymore, I would:\n\nExtract their implementations into their own class.\nSo that the tests for each also get their own class.\nAnd in that class, I'd make sure I cover all the boundary conditions in different test methods.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463267054", "createdAt": "2020-07-30T20:57:48Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -151,6 +152,23 @@\n     // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n     // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n     // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlapsOrMeets(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(lessThanOrEqual(leftStartMapping, rightEndMapping),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83a13331d007733cf9e0ee81292d1f25719c8678"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NzU1Mzc5", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-458755379", "createdAt": "2020-07-30T21:04:03Z", "commit": {"oid": "83a13331d007733cf9e0ee81292d1f25719c8678"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMTowNDowM1rOG5zxTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMTowNDowM1rOG5zxTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MDIyMg==", "bodyText": "I think this a bit over-engineered. You don't need the factory, just use the Interval constructor directly.\nThese are tests - we're not looking for memory efficiency or performance, we're looking for maintainable code that is easy to understand.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463270222", "createdAt": "2020-07-30T21:04:03Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/JoinersTest.java", "diffHunk": "@@ -300,9 +308,163 @@ public void greaterThanOrEqualPenta() {\n                 (AbstractPentaJoiner<BigInteger, BigInteger, BigInteger, BigInteger, BigDecimal>) Joiners\n                         .greaterThanOrEqual(leftMapping, rightMapping);\n         assertSoftly(softly -> {\n-            softly.assertThat(joiner.matches(TEN, ZERO, ZERO, ZERO, BigDecimal.TEN)).isTrue();\n-            softly.assertThat(joiner.matches(TEN, ZERO, ZERO, ZERO, BigDecimal.ONE)).isTrue();\n-            softly.assertThat(joiner.matches(ZERO, ZERO, ZERO, ZERO, BigDecimal.ONE)).isFalse();\n+            softly.assertThat(joiner.matches(BigInteger.TEN, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO,\n+                    BigDecimal.TEN)).isTrue();\n+            softly.assertThat(joiner.matches(BigInteger.TEN, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO,\n+                    BigDecimal.ONE)).isTrue();\n+            softly.assertThat(joiner.matches(BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO,\n+                    BigDecimal.ONE)).isFalse();\n+        });\n+    }\n+\n+    private static final class Interval<A, B> {\n+        final A start;\n+        final A end;\n+        final Function<A, B> map;\n+\n+        public Interval(A start, A end, Function<A, B> map) {\n+            this.start = start;\n+            this.end = end;\n+            this.map = map;\n+        }\n+\n+        public B getStart() {\n+            return map.apply(start);\n+        }\n+\n+        public B getEnd() {\n+            return map.apply(end);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"(\" + start.toString() + \", \" + end.toString() + \")\";\n+        }\n+\n+        public static <A, B, C> IntervalFactory<A, B, C> createFactory(Function<C, A> constructorMap, Function<A, B> map) {\n+            return new IntervalFactory<A, B, C>(constructorMap, map);\n+        }\n+\n+        private final static class IntervalFactory<A, B, C> {\n+            final Function<C, A> constructorMap;\n+            final Function<A, B> map;\n+\n+            public IntervalFactory(Function<C, A> constructorMap, Function<A, B> map) {\n+                this.constructorMap = constructorMap;\n+                this.map = map;\n+            }\n+\n+            public Interval<A, B> of(C start, C end) {\n+                return new Interval<A, B>(constructorMap.apply(start), constructorMap.apply(end), map);\n+            }\n+        }\n+    }\n+\n+    private final Interval.IntervalFactory<BigInteger, Long, Long> bigIntInterval =\n+            Interval.createFactory(BigInteger::valueOf, BigInteger::longValue);\n+\n+    private final Interval.IntervalFactory<BigDecimal, Long, Long> bigDecimalInterval =\n+            Interval.createFactory(BigDecimal::valueOf, BigDecimal::longValue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83a13331d007733cf9e0ee81292d1f25719c8678"}, "originalPosition": 323}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NzU3Mzgx", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-458757381", "createdAt": "2020-07-30T21:07:22Z", "commit": {"oid": "83a13331d007733cf9e0ee81292d1f25719c8678"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMTowNzoyM1rOG5z3XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMTowNzoyM1rOG5z3XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MTc3Mg==", "bodyText": "Now that the Joiners are actually relatively complex, I think that the comment before these assertions (Case A = B) should instead be turned into .as(...) on the assertion itself. The assertion messages will become so much better for it.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463271772", "createdAt": "2020-07-30T21:07:23Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/JoinersTest.java", "diffHunk": "@@ -300,9 +308,163 @@ public void greaterThanOrEqualPenta() {\n                 (AbstractPentaJoiner<BigInteger, BigInteger, BigInteger, BigInteger, BigDecimal>) Joiners\n                         .greaterThanOrEqual(leftMapping, rightMapping);\n         assertSoftly(softly -> {\n-            softly.assertThat(joiner.matches(TEN, ZERO, ZERO, ZERO, BigDecimal.TEN)).isTrue();\n-            softly.assertThat(joiner.matches(TEN, ZERO, ZERO, ZERO, BigDecimal.ONE)).isTrue();\n-            softly.assertThat(joiner.matches(ZERO, ZERO, ZERO, ZERO, BigDecimal.ONE)).isFalse();\n+            softly.assertThat(joiner.matches(BigInteger.TEN, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO,\n+                    BigDecimal.TEN)).isTrue();\n+            softly.assertThat(joiner.matches(BigInteger.TEN, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO,\n+                    BigDecimal.ONE)).isTrue();\n+            softly.assertThat(joiner.matches(BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO,\n+                    BigDecimal.ONE)).isFalse();\n+        });\n+    }\n+\n+    private static final class Interval<A, B> {\n+        final A start;\n+        final A end;\n+        final Function<A, B> map;\n+\n+        public Interval(A start, A end, Function<A, B> map) {\n+            this.start = start;\n+            this.end = end;\n+            this.map = map;\n+        }\n+\n+        public B getStart() {\n+            return map.apply(start);\n+        }\n+\n+        public B getEnd() {\n+            return map.apply(end);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"(\" + start.toString() + \", \" + end.toString() + \")\";\n+        }\n+\n+        public static <A, B, C> IntervalFactory<A, B, C> createFactory(Function<C, A> constructorMap, Function<A, B> map) {\n+            return new IntervalFactory<A, B, C>(constructorMap, map);\n+        }\n+\n+        private final static class IntervalFactory<A, B, C> {\n+            final Function<C, A> constructorMap;\n+            final Function<A, B> map;\n+\n+            public IntervalFactory(Function<C, A> constructorMap, Function<A, B> map) {\n+                this.constructorMap = constructorMap;\n+                this.map = map;\n+            }\n+\n+            public Interval<A, B> of(C start, C end) {\n+                return new Interval<A, B>(constructorMap.apply(start), constructorMap.apply(end), map);\n+            }\n+        }\n+    }\n+\n+    private final Interval.IntervalFactory<BigInteger, Long, Long> bigIntInterval =\n+            Interval.createFactory(BigInteger::valueOf, BigInteger::longValue);\n+\n+    private final Interval.IntervalFactory<BigDecimal, Long, Long> bigDecimalInterval =\n+            Interval.createFactory(BigDecimal::valueOf, BigDecimal::longValue);\n+\n+    @Test\n+    public void overlapsBi() {\n+        Function<Interval<BigInteger, Long>, Long> leftStartMapping = Interval::getStart;\n+        Function<Interval<BigInteger, Long>, Long> leftEndMapping = Interval::getEnd;\n+        Function<Interval<BigDecimal, Long>, Long> rightStartMapping = Interval::getStart;\n+        Function<Interval<BigDecimal, Long>, Long> rightEndMapping = Interval::getEnd;\n+\n+        AbstractBiJoiner<Interval<BigInteger, Long>, Interval<BigDecimal, Long>> joiner =\n+                (AbstractBiJoiner<Interval<BigInteger, Long>, Interval<BigDecimal, Long>>) Joiners.overlaps(leftStartMapping,\n+                        leftEndMapping, rightStartMapping, rightEndMapping);\n+\n+        assertSoftly(softly -> {\n+            // Case A = B\n+            softly.assertThat(joiner.matches(bigIntInterval.of(1L, 5L),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83a13331d007733cf9e0ee81292d1f25719c8678"}, "originalPosition": 338}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NzU5MzU0", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-458759354", "createdAt": "2020-07-30T21:10:46Z", "commit": {"oid": "83a13331d007733cf9e0ee81292d1f25719c8678"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMToxMDo0NlrOG5z9Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMToxMDo0NlrOG5z9Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MzMwMg==", "bodyText": "Let's make sure we have proper Javadocs for these factory methods. This is public API after all.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463273302", "createdAt": "2020-07-30T21:10:46Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -151,6 +152,23 @@\n     // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n     // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n     // then keep an index from every period to all talks in an overlapping period (possible the same period)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83a13331d007733cf9e0ee81292d1f25719c8678"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NzYwMDMy", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-458760032", "createdAt": "2020-07-30T21:11:52Z", "commit": {"oid": "83a13331d007733cf9e0ee81292d1f25719c8678"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMToxMTo1M1rOG5z_iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMToxMTo1M1rOG5z_iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3Mzg2Nw==", "bodyText": "Did you consider any other way of specifying the intervals?\n(I'm not saying this one is bad. Just making sure we went over all the options before we picked a public API to be with us forever.)", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463273867", "createdAt": "2020-07-30T21:11:53Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -151,6 +152,23 @@\n     // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n     // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n     // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlapsOrMeets(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(lessThanOrEqual(leftStartMapping, rightEndMapping),\n+                greaterThanOrEqual(leftEndMapping, rightStartMapping));\n+    }\n+\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlaps(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83a13331d007733cf9e0ee81292d1f25719c8678"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af66d519dfda5c3093905f1c3c896916fc0b00cf", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/af66d519dfda5c3093905f1c3c896916fc0b00cf", "committedDate": "2020-09-10T18:13:32Z", "message": "PLANNER-2078: Add Overlaps BiJoiner; remove static field imports in test to make it\nclear what type the field is."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/15b387f0a41ed13ee11809b59b3e5ecdc4c441c4", "committedDate": "2020-09-10T20:31:48Z", "message": "Move interval joiners impl. to own file, add During joiner"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "83a13331d007733cf9e0ee81292d1f25719c8678", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/83a13331d007733cf9e0ee81292d1f25719c8678", "committedDate": "2020-07-30T20:09:22Z", "message": "PLANNER-2078: Add Overlaps BiJoiner; remove static field imports in test to make it\nclear what type the field is."}, "afterCommit": {"oid": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/15b387f0a41ed13ee11809b59b3e5ecdc4c441c4", "committedDate": "2020-09-10T20:31:48Z", "message": "Move interval joiners impl. to own file, add During joiner"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MzAzNDc0", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-486303474", "createdAt": "2020-09-10T20:55:37Z", "commit": {"oid": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDo1NTozN1rOHQFa-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTowMDoxOFrOHQFkbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyODA5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param leftStartMapping Maps the first argument to the first interval start point\n          \n          \n            \n                 * @param leftStartMapping maps the first argument to the first interval start point\n          \n      \n    \n    \n  \n\nI believe we don't treat these as sentences, therefore the first letter is not capitalized.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r486628091", "createdAt": "2020-09-10T20:55:37Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +148,103 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those\n+     * pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and\n+     * x in [c,d)). These are exactly the pairs where\n+     * a < d and b > c (or in other words, when the first\n+     * interval starts before the second one ends and the\n+     * first interval ends after the second interval begins).\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first argument to the first interval start point", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyOTI2Mw==", "bodyText": "Considering that this is not a public API, I think we don't need such a comprehensive Javadoc.\nFeel free to keep it, but considering that everything important should be said on the public API already, this may be too much to maintain going forward, for little benefit.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r486629263", "createdAt": "2020-09-10T20:57:48Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/common/IntervalJoiners.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.common;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.function.QuadFunction;\n+import org.optaplanner.core.api.function.TriFunction;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiJoiner;\n+import org.optaplanner.core.api.score.stream.penta.PentaJoiner;\n+import org.optaplanner.core.api.score.stream.quad.QuadJoiner;\n+import org.optaplanner.core.api.score.stream.tri.TriJoiner;\n+import org.optaplanner.core.impl.score.stream.bi.AbstractBiJoiner;\n+import org.optaplanner.core.impl.score.stream.penta.AbstractPentaJoiner;\n+import org.optaplanner.core.impl.score.stream.quad.AbstractQuadJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.AbstractTriJoiner;\n+\n+/**\n+ * Creates an {@link BiJoiner}, {@link TriJoiner}, ... instance\n+ * for data types that can be described as intervals (for instance,\n+ * time slots and numeric ranges). Based on Allen's Interval Algebra.\n+ * See https://en.wikipedia.org/wiki/Allen%27s_interval_algebra\n+ */\n+public class IntervalJoiners {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMDUxMA==", "bodyText": "In fact, now that I see how little code there actually is in this class, makes me think that maybe IntervalJoiners class is unnecessary and the methods could just be inlined into Joiners?\nWhen I was making this suggestion, I was somehow expecting that there would be more code here.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r486630510", "createdAt": "2020-09-10T21:00:18Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/common/IntervalJoiners.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.common;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.function.QuadFunction;\n+import org.optaplanner.core.api.function.TriFunction;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiJoiner;\n+import org.optaplanner.core.api.score.stream.penta.PentaJoiner;\n+import org.optaplanner.core.api.score.stream.quad.QuadJoiner;\n+import org.optaplanner.core.api.score.stream.tri.TriJoiner;\n+import org.optaplanner.core.impl.score.stream.bi.AbstractBiJoiner;\n+import org.optaplanner.core.impl.score.stream.penta.AbstractPentaJoiner;\n+import org.optaplanner.core.impl.score.stream.quad.AbstractQuadJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.AbstractTriJoiner;\n+\n+/**\n+ * Creates an {@link BiJoiner}, {@link TriJoiner}, ... instance\n+ * for data types that can be described as intervals (for instance,\n+ * time slots and numeric ranges). Based on Allen's Interval Algebra.\n+ * See https://en.wikipedia.org/wiki/Allen%27s_interval_algebra\n+ */\n+public class IntervalJoiners {\n+\n+    // BiJoiners\n+\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those\n+     * pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and\n+     * x in [c,d)). These are exactly the pairs where\n+     * a < d and b > c (or in other words, when the first\n+     * interval starts before the second one ends and the\n+     * first interval ends after the second interval begins).\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first argument to the first interval start point\n+     * @param leftEndMapping Maps the first argument to the first interval end point\n+     * @param rightStartMapping Maps the second argument to the second interval start point\n+     * @param rightEndMapping Maps the second argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B) where A's and B's intervals (as defined by the function mapping)\n+     *         overlap.\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlaps(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Syntactic sugar for {@link #overlaps(Function, Function, Function, Function)} where\n+     * both elements of the tuple (A,B) are the same type and have the same interval\n+     * defining function. Identical to\n+     * {@code overlaps(startMapping, endMapping, startMapping, endMapping)}.\n+     * \n+     * @param <A> The type of both the first and second argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param startMapping Maps the argument to the start point of its interval\n+     * @param endMapping Maps the argument to the end point of its interval\n+     * \n+     * @return See {@link #overlaps(Function, Function, Function, Function)}\n+     */\n+    public static <A, Property_ extends Comparable<Property_>> BiJoiner<A, A> overlaps(\n+            Function<A, Property_> startMapping,\n+            Function<A, Property_> endMapping) {\n+        return overlaps(startMapping, endMapping, startMapping, endMapping);\n+    }\n+\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those\n+     * pairs where [a,b) contains [c,d) (or, in other\n+     * words, for any x in [c, d), x is also in [a,b)). These are exactly the pairs\n+     * where a <= c and b >= d (or in other words, when the first\n+     * interval starts before the second one starts and the\n+     * first interval ends after the second interval ends).\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first argument to the first interval start point\n+     * @param leftEndMapping Maps the first argument to the first interval end point\n+     * @param rightStartMapping Maps the second argument to the second interval start point\n+     * @param rightEndMapping Maps the second argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B) where A's interval contains B's interval (as defined by the function mapping)\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> during(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(Joiners.lessThanOrEqual(leftStartMapping, rightStartMapping),\n+                Joiners.greaterThanOrEqual(leftEndMapping, rightEndMapping));\n+    }\n+\n+    /**\n+     * Syntactic sugar for {@link #during(Function, Function, Function, Function)} where\n+     * both elements of the tuple (A,B) are the same type and have the same interval\n+     * defining function. Identical to\n+     * {@code during(startMapping, endMapping, startMapping, endMapping)}.\n+     * \n+     * @param <A> The type of both the first and second argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param startMapping Maps the argument to the start point of its interval\n+     * @param endMapping Maps the argument to the end point of its interval\n+     * \n+     * @return See {@link #during(Function, Function, Function, Function)}\n+     */\n+    public static <A, Property_ extends Comparable<Property_>> BiJoiner<A, A> during(\n+            Function<A, Property_> startMapping,\n+            Function<A, Property_> endMapping) {\n+        return during(startMapping, endMapping, startMapping, endMapping);\n+    }\n+\n+    // TriJoiners\n+    /**\n+     * Like {@link #overlaps(Function, Function, Function, Function)}, but for\n+     * TriConstraintStream.\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <C> The type of the third argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first and second arguments to the first interval start point\n+     * @param leftEndMapping Maps the first and second arguments to the first interval end point\n+     * @param rightStartMapping Maps the third argument to the second interval start point\n+     * @param rightEndMapping Maps the third argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B,C) where (A,B)'s and C's intervals (as defined by the function mapping)\n+     *         overlap.\n+     */\n+    public static <A, B, C, Property_ extends Comparable<Property_>> TriJoiner<A, B, C> overlaps(\n+            BiFunction<A, B, Property_> leftStartMapping,\n+            BiFunction<A, B, Property_> leftEndMapping,\n+            Function<C, Property_> rightStartMapping,\n+            Function<C, Property_> rightEndMapping) {\n+        return AbstractTriJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Like {@link #during(Function, Function, Function, Function)}, but for\n+     * TriConstraintStream.\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <C> The type of the third argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first and second arguments to the first interval start point\n+     * @param leftEndMapping Maps the first and second arguments to the first interval end point\n+     * @param rightStartMapping Maps the third argument to the second interval start point\n+     * @param rightEndMapping Maps the third argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B,C) where (A,B)'s interval contains C's interval (as defined by the function mapping)\n+     */\n+    public static <A, B, C, Property_ extends Comparable<Property_>> TriJoiner<A, B, C> during(\n+            BiFunction<A, B, Property_> leftStartMapping,\n+            BiFunction<A, B, Property_> leftEndMapping,\n+            Function<C, Property_> rightStartMapping,\n+            Function<C, Property_> rightEndMapping) {\n+        return AbstractTriJoiner.merge(Joiners.lessThanOrEqual(leftStartMapping, rightStartMapping),\n+                Joiners.greaterThanOrEqual(leftEndMapping, rightEndMapping));\n+    }\n+\n+    // QuadJoiners\n+    /**\n+     * Like {@link #overlaps(Function, Function, Function, Function)}, but for\n+     * QuadConstraintStream.\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <C> The type of the third argument\n+     * @param <D> The type of the fourth argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first, second and third arguments to the first interval start point\n+     * @param leftEndMapping Maps the first, second and third arguments to the first interval end point\n+     * @param rightStartMapping Maps the fourth argument to the second interval start point\n+     * @param rightEndMapping Maps the fourth argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B,C,D) where (A,B,C)'s and D's intervals (as defined by the function mapping)\n+     *         overlap.\n+     */\n+    public static <A, B, C, D, Property_ extends Comparable<Property_>> QuadJoiner<A, B, C, D> overlaps(\n+            TriFunction<A, B, C, Property_> leftStartMapping,\n+            TriFunction<A, B, C, Property_> leftEndMapping,\n+            Function<D, Property_> rightStartMapping,\n+            Function<D, Property_> rightEndMapping) {\n+        return AbstractQuadJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Like {@link #during(Function, Function, Function, Function)}, but for\n+     * QuadConstraintStream.\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <C> The type of the third argument\n+     * @param <D> The type of the fourth argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first, second and third arguments to the first interval start point\n+     * @param leftEndMapping Maps the first, second and third arguments to the first interval end point\n+     * @param rightStartMapping Maps the fourth argument to the second interval start point\n+     * @param rightEndMapping Maps the fourth argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B,C,D) where (A,B,C)'s interval contains D's interval (as defined by the function mapping)\n+     */\n+    public static <A, B, C, D, Property_ extends Comparable<Property_>> QuadJoiner<A, B, C, D> during(\n+            TriFunction<A, B, C, Property_> leftStartMapping,\n+            TriFunction<A, B, C, Property_> leftEndMapping,\n+            Function<D, Property_> rightStartMapping,\n+            Function<D, Property_> rightEndMapping) {\n+        return AbstractQuadJoiner.merge(Joiners.lessThanOrEqual(leftStartMapping, rightStartMapping),\n+                Joiners.greaterThanOrEqual(leftEndMapping, rightEndMapping));\n+    }\n+\n+    // PentaJoiners\n+    /**\n+     * Like {@link #overlaps(Function, Function, Function, Function)}, but for\n+     * PentaConstraintStream.\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <C> The type of the third argument\n+     * @param <D> The type of the fourth argument\n+     * @param <E> The type of the fifth argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first, second, third and fourth arguments to the first interval start point\n+     * @param leftEndMapping Maps the first, second, third and fourth arguments to the first interval end point\n+     * @param rightStartMapping Maps the fifth argument to the second interval start point\n+     * @param rightEndMapping Maps the fifth argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B,C,D,E) where (A,B,C,D)'s and E's intervals (as defined by the function mapping)\n+     *         overlap.\n+     */\n+    public static <A, B, C, D, E, Property_ extends Comparable<Property_>> PentaJoiner<A, B, C, D, E> overlaps(\n+            QuadFunction<A, B, C, D, Property_> leftStartMapping,\n+            QuadFunction<A, B, C, D, Property_> leftEndMapping,\n+            Function<E, Property_> rightStartMapping,\n+            Function<E, Property_> rightEndMapping) {\n+        return AbstractPentaJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Like {@link #during(Function, Function, Function, Function)}, but for\n+     * PentaConstraintStream.\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <C> The type of the third argument\n+     * @param <D> The type of the fourth argument\n+     * @param <E> The type of the fifth argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first, second, third and fourth arguments to the first interval start point\n+     * @param leftEndMapping Maps the first, second, third and fourth arguments to the first interval end point\n+     * @param rightStartMapping Maps the fifth argument to the second interval start point\n+     * @param rightEndMapping Maps the fifth argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B,C,D,E) where (A,B,C,D)'s interval contains E's interval (as defined by the function mapping)\n+     */\n+    public static <A, B, C, D, E, Property_ extends Comparable<Property_>> PentaJoiner<A, B, C, D, E> during(\n+            QuadFunction<A, B, C, D, Property_> leftStartMapping,\n+            QuadFunction<A, B, C, D, Property_> leftEndMapping,\n+            Function<E, Property_> rightStartMapping,\n+            Function<E, Property_> rightEndMapping) {\n+        return AbstractPentaJoiner.merge(Joiners.lessThanOrEqual(leftStartMapping, rightStartMapping),\n+                Joiners.greaterThanOrEqual(leftEndMapping, rightEndMapping));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4"}, "originalPosition": 309}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MzA4MjIz", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-486308223", "createdAt": "2020-09-10T21:02:48Z", "commit": {"oid": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTowMjo0OFrOHQFpLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTowMjo0OFrOHQFpLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMTcyNw==", "bodyText": "Two rules for our Javadocs:\n\nUse the full line length, which is 120 chars.\nEach sentence starts on a new line.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r486631727", "createdAt": "2020-09-10T21:02:48Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +148,103 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those\n+     * pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and\n+     * x in [c,d)). These are exactly the pairs where\n+     * a < d and b > c (or in other words, when the first\n+     * interval starts before the second one ends and the\n+     * first interval ends after the second interval begins).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MzA4OTA2", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-486308906", "createdAt": "2020-09-10T21:03:54Z", "commit": {"oid": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTowMzo1NFrOHQFrZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTowMzo1NFrOHQFrZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMjI5NA==", "bodyText": "We usually start with never null, an indexed joiner... And since it doesn't start with a capital letter, it doesn't end with a full stop.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r486632294", "createdAt": "2020-09-10T21:03:54Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +148,103 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those\n+     * pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and\n+     * x in [c,d)). These are exactly the pairs where\n+     * a < d and b > c (or in other words, when the first\n+     * interval starts before the second one ends and the\n+     * first interval ends after the second interval begins).\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first argument to the first interval start point\n+     * @param leftEndMapping Maps the first argument to the first interval end point\n+     * @param rightStartMapping Maps the second argument to the second interval start point\n+     * @param rightEndMapping Maps the second argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B) where A's and B's intervals (as defined by the function mapping)\n+     *         overlap.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35e0ee56541bffd50e5f1e8a0f49f8d2f460994f", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/35e0ee56541bffd50e5f1e8a0f49f8d2f460994f", "committedDate": "2020-09-11T15:02:53Z", "message": "Fixup interval joiners Javadoc, move impl. to Joiners, add missing test cases"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2OTA5NTgw", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-486909580", "createdAt": "2020-09-11T15:30:10Z", "commit": {"oid": "35e0ee56541bffd50e5f1e8a0f49f8d2f460994f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTozMDoxMVrOHQjoRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTozMDoxMVrOHQjoRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyMzAxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param leftStartMapping maps the first argument to the first interval start point\n          \n          \n            \n                 * @param leftEndMapping maps the first argument to the first interval end point\n          \n          \n            \n                 * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n          \n          \n            \n                 * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n          \n      \n    \n    \n  \n\nOne last comment on the Javadocs: The method description marks the intervals [a, b), which is the correct mathematical notation for an interval open on the right, but let's make it crystal clear.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487123014", "createdAt": "2020-09-11T15:30:11Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point\n+     * @param leftEndMapping maps the first argument to the first interval end point", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35e0ee56541bffd50e5f1e8a0f49f8d2f460994f"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2OTEwNjQx", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-486910641", "createdAt": "2020-09-11T15:31:34Z", "commit": {"oid": "35e0ee56541bffd50e5f1e8a0f49f8d2f460994f"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39e5ed15f651d41b0eae2e71c468f8eefc14e366", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/39e5ed15f651d41b0eae2e71c468f8eefc14e366", "committedDate": "2020-09-11T17:06:24Z", "message": "Make it clear starts are inclusive and end are exclusive, use correct terms in tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/671103550e740d691524256ea572ffc5b1e642ee", "committedDate": "2020-09-11T17:42:07Z", "message": "Modify ConstraintProviders to use overlaps"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MDMxMjEz", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-487031213", "createdAt": "2020-09-11T18:28:52Z", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3Njg4OTgz", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-487688983", "createdAt": "2020-09-14T12:11:17Z", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoxMToxOFrOHRQxTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoxMToxOFrOHRQxTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2MjYwNQ==", "bodyText": "style: type params are typically the last in the javadocs @ list", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487862605", "createdAt": "2020-09-14T12:11:18Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NjkwMDQ4", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-487690048", "createdAt": "2020-09-14T12:12:51Z", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoxMjo1MVrOHRQ0tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoxMjo1MVrOHRQ0tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2MzQ3OA==", "bodyText": "method name => overlapping (because it needs to be an adjective like other method names filtering, intersecting, equal, ...)", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487863478", "createdAt": "2020-09-14T12:12:51Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n+     * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n+     * @param rightStartMapping maps the second argument to the second interval start point (inclusive)\n+     * @param rightEndMapping maps the second argument to the second interval end point (exclusive)\n+     * \n+     * @return never null, an indexed joiner that filters the constraint stream to only include elements (A,B) where\n+     *         A's and B's intervals (as defined by the function mapping) overlap\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlaps(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NjkwOTkx", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-487690991", "createdAt": "2020-09-14T12:14:15Z", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoxNDoxNVrOHRQ3nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoxNDoxNVrOHRQ3nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2NDIyMw==", "bodyText": "\"maps the first argument to the first interval start point \" the double \"first\" could be confusing, suggestion:\n=> maps the first argument to its interval start point\"", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487864223", "createdAt": "2020-09-14T12:14:15Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NjkxOTgy", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-487691982", "createdAt": "2020-09-14T12:15:42Z", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoxNTo0M1rOHRQ6oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoxNTo0M1rOHRQ6oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2NDk5Mw==", "bodyText": "This second sentance seems to repeat the first sentence. I don't think it brings additional clarity, so I'd remove it.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487864993", "createdAt": "2020-09-14T12:15:43Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3Njk0NTAx", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-487694501", "createdAt": "2020-09-14T12:19:17Z", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoxOToxN1rOHRRCOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoxOToxN1rOHRRCOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2NjkzOQ==", "bodyText": "All joiners should probably have a first general line concept line, how about something like:\n\"Joins every A and B that overlap for an interval which is specified by a start and end property on both A and B.\"", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487866939", "createdAt": "2020-09-14T12:19:17Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3Njk1NzIz", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-487695723", "createdAt": "2020-09-14T12:21:05Z", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoyMTowNVrOHRRGFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoyMTowNVrOHRRGFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2NzkyNA==", "bodyText": "We should probably use the same trick here as we do for all overloaded methods in the UniConstraintStream API javadocs etc: the first one has the full javadoc, but the others simply put As defined by {@link #overlapping(...)}. and then still specify the @param and @return etc.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487867924", "createdAt": "2020-09-14T12:21:05Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n+     * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n+     * @param rightStartMapping maps the second argument to the second interval start point (inclusive)\n+     * @param rightEndMapping maps the second argument to the second interval end point (exclusive)\n+     * \n+     * @return never null, an indexed joiner that filters the constraint stream to only include elements (A,B) where\n+     *         A's and B's intervals (as defined by the function mapping) overlap\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlaps(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Syntactic sugar for {@link #overlaps(Function, Function, Function, Function)} where\n+     * both elements of the tuple (A,B) are the same type and have the same interval\n+     * defining function. Identical to\n+     * {@code overlaps(startMapping, endMapping, startMapping, endMapping)}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3Njk3MzE5", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-487697319", "createdAt": "2020-09-14T12:23:23Z", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoyMzoyM1rOHRRK7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoyMzoyM1rOHRRK7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2OTE2NQ==", "bodyText": "Method ordering: the other methods in the class such as equal(A) are ordered before equal(A, B). Let's keep that consistent for easier maintenance? So this method before the previous one.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487869165", "createdAt": "2020-09-14T12:23:23Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n+     * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n+     * @param rightStartMapping maps the second argument to the second interval start point (inclusive)\n+     * @param rightEndMapping maps the second argument to the second interval end point (exclusive)\n+     * \n+     * @return never null, an indexed joiner that filters the constraint stream to only include elements (A,B) where\n+     *         A's and B's intervals (as defined by the function mapping) overlap\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlaps(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Syntactic sugar for {@link #overlaps(Function, Function, Function, Function)} where\n+     * both elements of the tuple (A,B) are the same type and have the same interval\n+     * defining function. Identical to\n+     * {@code overlaps(startMapping, endMapping, startMapping, endMapping)}.\n+     * \n+     * @param <A> the type of both the first and second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param startMapping maps the argument to the start point of its interval (inclusive)\n+     * @param endMapping maps the argument to the end point of its interval (exclusive)\n+     * \n+     * @return see {@link #overlaps(Function, Function, Function, Function)}\n+     */\n+    public static <A, Property_ extends Comparable<Property_>> BiJoiner<A, A> overlaps(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NzAwNjUz", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-487700653", "createdAt": "2020-09-14T12:27:32Z", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoyNzozMlrOHRRVOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoyNzozMlrOHRRVOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3MTgwMg==", "bodyText": "Adding x complicates things. I am sure mathematicians love the \"for any x\" definition, but our audience, programmers, are better off with a simple statement a <= c and b <= d (or is it the other way around? see comment below), so no need for adding an x.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487871802", "createdAt": "2020-09-14T12:27:32Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n+     * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n+     * @param rightStartMapping maps the second argument to the second interval start point (inclusive)\n+     * @param rightEndMapping maps the second argument to the second interval end point (exclusive)\n+     * \n+     * @return never null, an indexed joiner that filters the constraint stream to only include elements (A,B) where\n+     *         A's and B's intervals (as defined by the function mapping) overlap\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlaps(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Syntactic sugar for {@link #overlaps(Function, Function, Function, Function)} where\n+     * both elements of the tuple (A,B) are the same type and have the same interval\n+     * defining function. Identical to\n+     * {@code overlaps(startMapping, endMapping, startMapping, endMapping)}.\n+     * \n+     * @param <A> the type of both the first and second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param startMapping maps the argument to the start point of its interval (inclusive)\n+     * @param endMapping maps the argument to the end point of its interval (exclusive)\n+     * \n+     * @return see {@link #overlaps(Function, Function, Function, Function)}\n+     */\n+    public static <A, Property_ extends Comparable<Property_>> BiJoiner<A, A> overlaps(\n+            Function<A, Property_> startMapping,\n+            Function<A, Property_> endMapping) {\n+        return overlaps(startMapping, endMapping, startMapping, endMapping);\n+    }\n+\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) contains [c,d) (or, in other\n+     * words, for any x in [c, d), x is also in [a,b)).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NzAyMzI2", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-487702326", "createdAt": "2020-09-14T12:29:39Z", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoyOTozOVrOHRRaLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoyOTozOVrOHRRaLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3MzA3MQ==", "bodyText": "Unlike in overlapping (and addition), for duration (like for substraction) it really important as to which is which.\nWhich of these is true?\n\nduring(summer 2020, year 2020)\nduring(year 2020, summer 2020)\n\nThe method name and the javadocs must make that crystal clear with no verbosity", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487873071", "createdAt": "2020-09-14T12:29:39Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n+     * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n+     * @param rightStartMapping maps the second argument to the second interval start point (inclusive)\n+     * @param rightEndMapping maps the second argument to the second interval end point (exclusive)\n+     * \n+     * @return never null, an indexed joiner that filters the constraint stream to only include elements (A,B) where\n+     *         A's and B's intervals (as defined by the function mapping) overlap\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlaps(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Syntactic sugar for {@link #overlaps(Function, Function, Function, Function)} where\n+     * both elements of the tuple (A,B) are the same type and have the same interval\n+     * defining function. Identical to\n+     * {@code overlaps(startMapping, endMapping, startMapping, endMapping)}.\n+     * \n+     * @param <A> the type of both the first and second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param startMapping maps the argument to the start point of its interval (inclusive)\n+     * @param endMapping maps the argument to the end point of its interval (exclusive)\n+     * \n+     * @return see {@link #overlaps(Function, Function, Function, Function)}\n+     */\n+    public static <A, Property_ extends Comparable<Property_>> BiJoiner<A, A> overlaps(\n+            Function<A, Property_> startMapping,\n+            Function<A, Property_> endMapping) {\n+        return overlaps(startMapping, endMapping, startMapping, endMapping);\n+    }\n+\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) contains [c,d) (or, in other\n+     * words, for any x in [c, d), x is also in [a,b)).\n+     * These are exactly the pairs where {@code a <= c} and {@code b >= d} (or in other words, when the first interval\n+     * starts before the second one starts and the first interval ends after the second interval ends).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n+     * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n+     * @param rightStartMapping maps the second argument to the second interval start point (inclusive)\n+     * @param rightEndMapping maps the second argument to the second interval end point (exclusive)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NzAzNzgy", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-487703782", "createdAt": "2020-09-14T12:31:28Z", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjozMToyOFrOHRReng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjozMToyOFrOHRReng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NDIwNg==", "bodyText": "-1 on \"during\" as method name because it presumes the notion of time.\nThis method applies not just to LocalDate etc, but also Integer, Long, BigDecimal and anything else that is Comparable.\nNot just intervals, but any type of range.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487874206", "createdAt": "2020-09-14T12:31:28Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n+     * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n+     * @param rightStartMapping maps the second argument to the second interval start point (inclusive)\n+     * @param rightEndMapping maps the second argument to the second interval end point (exclusive)\n+     * \n+     * @return never null, an indexed joiner that filters the constraint stream to only include elements (A,B) where\n+     *         A's and B's intervals (as defined by the function mapping) overlap\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlaps(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Syntactic sugar for {@link #overlaps(Function, Function, Function, Function)} where\n+     * both elements of the tuple (A,B) are the same type and have the same interval\n+     * defining function. Identical to\n+     * {@code overlaps(startMapping, endMapping, startMapping, endMapping)}.\n+     * \n+     * @param <A> the type of both the first and second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param startMapping maps the argument to the start point of its interval (inclusive)\n+     * @param endMapping maps the argument to the end point of its interval (exclusive)\n+     * \n+     * @return see {@link #overlaps(Function, Function, Function, Function)}\n+     */\n+    public static <A, Property_ extends Comparable<Property_>> BiJoiner<A, A> overlaps(\n+            Function<A, Property_> startMapping,\n+            Function<A, Property_> endMapping) {\n+        return overlaps(startMapping, endMapping, startMapping, endMapping);\n+    }\n+\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) contains [c,d) (or, in other\n+     * words, for any x in [c, d), x is also in [a,b)).\n+     * These are exactly the pairs where {@code a <= c} and {@code b >= d} (or in other words, when the first interval\n+     * starts before the second one starts and the first interval ends after the second interval ends).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n+     * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n+     * @param rightStartMapping maps the second argument to the second interval start point (inclusive)\n+     * @param rightEndMapping maps the second argument to the second interval end point (exclusive)\n+     * \n+     * @return never null, an indexed joiner that filters the constraint stream to only include elements (A,B) where\n+     *         A's interval contains B's interval (as defined by the function mapping)\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> during(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NzA3NDk2", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-487707496", "createdAt": "2020-09-14T12:36:16Z", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjozNjoxN1rOHRRp0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjozNjoxN1rOHRRp0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NzA3NA==", "bodyText": "All unit tests for the class Joiners should be in JoinersTests normally, so it's easier to find them. It's harder to know that this class exists, because it's not classname +\"Test\"", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487877074", "createdAt": "2020-09-14T12:36:17Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/IntervalJoinersTest.java", "diffHunk": "@@ -0,0 +1,951 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.api.score.stream;\n+\n+import static org.assertj.core.api.SoftAssertions.assertSoftly;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.core.api.function.QuadFunction;\n+import org.optaplanner.core.api.function.TriFunction;\n+import org.optaplanner.core.impl.score.stream.bi.AbstractBiJoiner;\n+import org.optaplanner.core.impl.score.stream.penta.AbstractPentaJoiner;\n+import org.optaplanner.core.impl.score.stream.quad.AbstractQuadJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.AbstractTriJoiner;\n+\n+public class IntervalJoinersTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NzA4NzM5", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-487708739", "createdAt": "2020-09-14T12:37:52Z", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjozNzo1MlrOHRRtgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjozNzo1MlrOHRRtgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3ODAxOQ==", "bodyText": "Please create a Testdata class for this instead, in the testdata package.\n@triceo Do we have any testdata classes already that are only for ConstraintStream testing and don't have any @planning* annotations?", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487878019", "createdAt": "2020-09-14T12:37:52Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/IntervalJoinersTest.java", "diffHunk": "@@ -0,0 +1,951 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.api.score.stream;\n+\n+import static org.assertj.core.api.SoftAssertions.assertSoftly;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.core.api.function.QuadFunction;\n+import org.optaplanner.core.api.function.TriFunction;\n+import org.optaplanner.core.impl.score.stream.bi.AbstractBiJoiner;\n+import org.optaplanner.core.impl.score.stream.penta.AbstractPentaJoiner;\n+import org.optaplanner.core.impl.score.stream.quad.AbstractQuadJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.AbstractTriJoiner;\n+\n+public class IntervalJoinersTest {\n+    private static final class Interval<A, B> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NzA5NjY3", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-487709667", "createdAt": "2020-09-14T12:39:03Z", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjozOTowM1rOHRRwaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjozOTowM1rOHRRwaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3ODc2MA==", "bodyText": "How does overlapsBiShort() improve the test coverage over overlapsBi? What does the \"short\" mean?", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487878760", "createdAt": "2020-09-14T12:39:03Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/IntervalJoinersTest.java", "diffHunk": "@@ -0,0 +1,951 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.api.score.stream;\n+\n+import static org.assertj.core.api.SoftAssertions.assertSoftly;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.core.api.function.QuadFunction;\n+import org.optaplanner.core.api.function.TriFunction;\n+import org.optaplanner.core.impl.score.stream.bi.AbstractBiJoiner;\n+import org.optaplanner.core.impl.score.stream.penta.AbstractPentaJoiner;\n+import org.optaplanner.core.impl.score.stream.quad.AbstractQuadJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.AbstractTriJoiner;\n+\n+public class IntervalJoinersTest {\n+    private static final class Interval<A, B> {\n+        final A start;\n+        final A end;\n+        final Function<A, B> map;\n+\n+        public Interval(A start, A end, Function<A, B> map) {\n+            this.start = start;\n+            this.end = end;\n+            this.map = map;\n+        }\n+\n+        public B getStart() {\n+            return map.apply(start);\n+        }\n+\n+        public B getEnd() {\n+            return map.apply(end);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"(\" + start.toString() + \", \" + end.toString() + \")\";\n+        }\n+\n+        public static Interval<Long, BigDecimal> ofBigDecimal(Long start, Long end) {\n+            return new Interval<>(start, end, BigDecimal::valueOf);\n+        }\n+\n+        public static Interval<Long, BigInteger> ofBigInt(Long start, Long end) {\n+            return new Interval<>(start, end, BigInteger::valueOf);\n+        }\n+    }\n+\n+    @Test\n+    public void overlapsBi() {\n+        Function<Interval<Long, BigInteger>, Long> leftStartMapping = interval -> interval.getStart().longValue();\n+        Function<Interval<Long, BigInteger>, Long> leftEndMapping = interval -> interval.getEnd().longValue();\n+        Function<Interval<Long, BigDecimal>, Long> rightStartMapping = interval -> interval.getStart().longValue();\n+        Function<Interval<Long, BigDecimal>, Long> rightEndMapping = interval -> interval.getEnd().longValue();\n+\n+        AbstractBiJoiner<Interval<Long, BigInteger>, Interval<Long, BigDecimal>> joiner =\n+                (AbstractBiJoiner<Interval<Long, BigInteger>, Interval<Long, BigDecimal>>) Joiners.overlaps(leftStartMapping,\n+                        leftEndMapping, rightStartMapping, rightEndMapping);\n+\n+        assertSoftly(softly -> {\n+            // True cases (equals, overlaps, contains, starts, ends)\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(1L, 5L),\n+                    Interval.ofBigDecimal(1L, 5L)))\n+                    .as(\"Case A = B\").isTrue();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(3L, 7L),\n+                    Interval.ofBigDecimal(1L, 5L)))\n+                    .as(\"B starts before A, A ends after B\").isTrue();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(1L, 5L),\n+                    Interval.ofBigDecimal(3L, 7L)))\n+                    .as(\"A starts before B, B ends after A\").isTrue();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(3L, 5L),\n+                    Interval.ofBigDecimal(1L, 7L)))\n+                    .as(\"B contains A\").isTrue();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(1L, 7L),\n+                    Interval.ofBigDecimal(3L, 5L)))\n+                    .as(\"A contains B\").isTrue();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(1L, 7L),\n+                    Interval.ofBigDecimal(1L, 3L)))\n+                    .as(\"A started by B\").isTrue();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(1L, 3L),\n+                    Interval.ofBigDecimal(1L, 7L)))\n+                    .as(\"B started by A\").isTrue();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(1L, 7L),\n+                    Interval.ofBigDecimal(3L, 7L)))\n+                    .as(\"A ended by B\").isTrue();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(3L, 7L),\n+                    Interval.ofBigDecimal(1L, 7L)))\n+                    .as(\"B ended by A\").isTrue();\n+\n+            // False Cases (before, after, meets)\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(1L, 3L),\n+                    Interval.ofBigDecimal(5L, 7L)))\n+                    .as(\"A before B\").isFalse();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(5L, 7L),\n+                    Interval.ofBigDecimal(1L, 3L)))\n+                    .as(\"B before A\").isFalse();\n+\n+            // This is false since typically, when overlaps is used,\n+            // end is exclusive, and start is inclusive,\n+            // so 0-5, 5-10 do not overlap\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(1L, 3L),\n+                    Interval.ofBigDecimal(3L, 7L)))\n+                    .as(\"A meets B\").isFalse();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(3L, 7L),\n+                    Interval.ofBigDecimal(1L, 3L)))\n+                    .as(\"B meets A\").isFalse();\n+        });\n+    }\n+\n+    @Test\n+    public void overlapsBiShort() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NzExNTMw", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-487711530", "createdAt": "2020-09-14T12:41:22Z", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo0MToyMlrOHRR2Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo0MToyMlrOHRR2Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4MDIxOQ==", "bodyText": "Great to see this!\nSmall suggestion: revmove Joiners. for consistency because the other ConstraintProviders seem to do a static import of all Joiners methods.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487880219", "createdAt": "2020-09-14T12:41:22Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/flightcrewscheduling/optional/score/FlightCrewSchedulingConstraintProvider.java", "diffHunk": "@@ -35,8 +35,9 @@ private Constraint requiredSkill(ConstraintFactory constraintFactory) {\n     }\n \n     private Constraint flightConflict(ConstraintFactory constraintFactory) {\n-        return constraintFactory.fromUniquePair(FlightAssignment.class, Joiners.equal(FlightAssignment::getEmployee))\n-                .filter((first, second) -> second.getFlight().overlaps(first.getFlight()))\n+        return constraintFactory.fromUniquePair(FlightAssignment.class, Joiners.equal(FlightAssignment::getEmployee),\n+                Joiners.overlaps(fa -> fa.getFlight().getDepartureUTCDateTime(),\n+                        fa -> fa.getFlight().getArrivalUTCDateTime()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NzE0ODQx", "url": "https://github.com/kiegroup/optaplanner/pull/865#pullrequestreview-487714841", "createdAt": "2020-09-14T12:45:29Z", "commit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo0NToyOVrOHRSAEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo0NToyOVrOHRSAEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4Mjc3MA==", "bodyText": "(not a change request)\nThis brings up an interesting question: often the overlap is penalized. For example in conference scheduling, the overlap of 2 somehow conflicting talks is penalized.\nWe must have the overlap/duration API to allow for indexing. Should we also provide a helper method to calculate the overlap during penalization? Probably we can't: LocalDate and Integer don't have a common interface with a \"subtract\" method.", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487882770", "createdAt": "2020-09-14T12:45:29Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -86,8 +89,12 @@ protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFact\n                         equal((leftRequiredAttendance, rightRequiredAttendance, leftAssignment) -> rightRequiredAttendance\n                                 .getMeeting(),\n                                 MeetingAssignment::getMeeting),\n-                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n-                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                        overlaps((attendee1, attendee2, assignment) -> assignment.getStartingTimeGrain().getGrainIndex(),\n+                                (attendee1, attendee2, assignment) -> assignment.getStartingTimeGrain().getGrainIndex() +\n+                                        assignment.getMeeting().getDurationInGrains(),\n+                                assignment -> assignment.getStartingTimeGrain().getGrainIndex(),\n+                                assignment -> assignment.getStartingTimeGrain().getGrainIndex() +\n+                                        assignment.getMeeting().getDurationInGrains()))\n                 .penalizeConfigurable(\"Required attendance conflict\",\n                         (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n                                 .calculateOverlap(leftAssignment));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "671103550e740d691524256ea572ffc5b1e642ee"}, "originalPosition": 33}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18284554f62ed5a776c180e433c3abe420a6399e", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/18284554f62ed5a776c180e433c3abe420a6399e", "committedDate": "2020-09-14T16:51:34Z", "message": "Edit JavaDoc, remove during joiner, move IntervalJoinerTests to JoinerTests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "af7a779c02d15c01ddccd94fd975a736e1e513ed", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/af7a779c02d15c01ddccd94fd975a736e1e513ed", "committedDate": "2020-09-14T16:48:46Z", "message": "Edit JavaDoc, move IntervalJoinerTests to JoinerTests"}, "afterCommit": {"oid": "18284554f62ed5a776c180e433c3abe420a6399e", "author": {"user": {"login": "Christopher-Chianelli", "name": "Christopher Chianelli"}}, "url": "https://github.com/kiegroup/optaplanner/commit/18284554f62ed5a776c180e433c3abe420a6399e", "committedDate": "2020-09-14T16:51:34Z", "message": "Edit JavaDoc, remove during joiner, move IntervalJoinerTests to JoinerTests"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3370, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}