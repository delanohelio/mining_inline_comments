{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2MDM2OTM0", "number": 692, "title": "PLANNER-1850 Add min/max collectors for streams of higher cardinality", "bodyText": "", "createdAt": "2020-02-17T09:44:31Z", "url": "https://github.com/kiegroup/optaplanner/pull/692", "merged": true, "mergeCommit": {"oid": "dc3cf1a947db1c375e4da93e909597e25b124534"}, "closed": true, "closedAt": "2020-02-18T10:08:30Z", "author": {"login": "triceo"}, "timelineItems": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcFJGtvgH2gAyMzc2MDM2OTM0OjVmNDA1Mjk2NjcwNjE5OWIwMmRiZTBkODUyNDBkY2JlZTc5MWZjOTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcFejEzAH2gAyMzc2MDM2OTM0OjE5MTViZTJjYjIwM2UxMzAyMmMyNDJmNDhlYzVkOWUyYjE4OGE3NmU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5f4052966706199b02dbe0d85240dcbee791fc91", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/5f4052966706199b02dbe0d85240dcbee791fc91", "committedDate": "2020-02-17T08:32:11Z", "message": "Rename argument"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c8ee4eb5491b7be8d7d4ba6c264f179a0dbeb5e", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/6c8ee4eb5491b7be8d7d4ba6c264f179a0dbeb5e", "committedDate": "2020-02-17T09:11:51Z", "message": "mapping min/max for uni"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4347e0ebf9a611b8276d0dcaec8ee3a2477e84a", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/c4347e0ebf9a611b8276d0dcaec8ee3a2477e84a", "committedDate": "2020-02-17T09:29:37Z", "message": "mapping min/max for other stream cardinalities"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2d7e6fbe1cddaced0b42a5fbf5acff21302eb52", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/d2d7e6fbe1cddaced0b42a5fbf5acff21302eb52", "committedDate": "2020-02-17T09:43:20Z", "message": "Code reuse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1914927f9c28ccd729de99b158ae6bf0c14f1656", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/1914927f9c28ccd729de99b158ae6bf0c14f1656", "committedDate": "2020-02-17T09:46:34Z", "message": "Fix Javadoc formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78f4d7c477ebc5c2cd20794a26c987a5c2221c6f", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/78f4d7c477ebc5c2cd20794a26c987a5c2221c6f", "committedDate": "2020-02-17T09:55:36Z", "message": "Add a note to docs regarding equals() consistency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0d32f1af0475e22fcf2275277619ac0b57f8173", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/e0d32f1af0475e22fcf2275277619ac0b57f8173", "committedDate": "2020-02-17T11:01:52Z", "message": "Add base test coverage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af1deaa708159d5f89253affda6dd1ce255920e3", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/af1deaa708159d5f89253affda6dd1ce255920e3", "committedDate": "2020-02-17T11:36:14Z", "message": "Finish test coverage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "735f4b99a2fba350ef25278c33a9e1de18c21441", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/735f4b99a2fba350ef25278c33a9e1de18c21441", "committedDate": "2020-02-17T11:36:59Z", "message": "Whitespace"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5NjkwMjU0", "url": "https://github.com/kiegroup/optaplanner/pull/692#pullrequestreview-359690254", "createdAt": "2020-02-17T12:11:11Z", "commit": {"oid": "735f4b99a2fba350ef25278c33a9e1de18c21441"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjoxMToxMVrOFqiS3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjoxMToxMVrOFqiS3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NjM5Ng==", "bodyText": "So, fun problem...\nConstraintCollectors.min(BiFunction)\nConstraintCollectors.min(Comparator)\nThese are ambiguous, for example:\nConstraintCollectors.min((Integer a, Integer b) -> a + b);\nIDE doesn't know which one to pick.\nThis is only going to be a problem with bi-stream. tri-stream and quad-stream are fine.\nIt's also only going to be a problem for BiFunction<A, A, Integer>, as that is ambiguous with Comparator<A>.\nWhat now?\n\nWe can't remove the Comparator one, as that's old API.\nPeople could just cast to whichever they prefer, but that's ugly.\nEssentially the only solution is to rename min(BiFunction) to something like minBi(...), and that's too draconian.\n\nConsidering all of that, I don't see it as a big enough problem to warrant this fix. I'd let people solve this corner case by casting.", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380146396", "createdAt": "2020-02-17T12:11:11Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java", "diffHunk": "@@ -526,36 +526,382 @@ private static Runnable innerCountDistinctLong(CountDistinctLongResultContainer\n     // min\n     // ************************************************************************\n \n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     *     {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.\n+     * <p>\n+     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     *     David (age = 25), Eric (age = 20).\n+     *     Further assume that the Person type compares by age.\n+     *     Such collector returns either Ann or Eric as the minimum element.\n+     *     No guarantees are made on which of the two is returned.\n+     *\n+     * @param <A> type of the matched fact\n+     * @return never null\n+     */\n+    public static <A extends Comparable<A>> UniConstraintCollector<A, ?, A> min() {\n+        return min(Function.identity(), Comparable::compareTo);\n+    }\n+\n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     *     {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.\n+     * <p>\n+     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     *     David (age = 25), Eric (age = 20).\n+     *     Using Person::getAge as the groupValueMapping, the resulting collector returns 20, as that is the minimum\n+     *     age of all the elements.\n+     *\n+     * @param <A> type of the matched fact\n+     * @param <Mapped> type of the result\n+     * @param groupValueMapping never null, maps facts from the matched type to the result type\n+     * @return never null\n+     */\n+    public static <A, Mapped extends Comparable<Mapped>> UniConstraintCollector<A, ?, Mapped> min(\n+            Function<A, Mapped> groupValueMapping) {\n+        return min(groupValueMapping, Comparable::compareTo);\n+    }\n+\n+    /**\n+     * Returns a collector that finds a minimum value in a group of elements, using the provided {@link Comparator}.\n+     * <p>\n+     *     It is expected that the {@link Comparator} is consistent with {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.\n+     * <p>\n+     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     *     David (age = 25), Eric (age = 20).\n+     *     Further assume that the comparator provided treats Person instances as equal when their age equals.\n+     *     Such collector returns either Ann or Eric as the minimum element.\n+     *     No guarantees are made on which of the two is returned.\n+     *\n+     * @param <A> type of the matched fact\n+     * @param comparator never null\n+     * @return never null\n+     */\n     public static <A> UniConstraintCollector<A, ?, A> min(Comparator<A> comparator) {\n-        return minOrMax(comparator, true);\n+        return min(Function.identity(), comparator);\n     }\n \n-    public static <A extends Comparable<A>> UniConstraintCollector<A, ?, A> min() {\n-        return min(Comparable::compareTo);\n+    /**\n+     * Returns a collector that finds a minimum value in a group of elements, using the provided {@link Comparator}.\n+     * <p>\n+     *     It is expected that the {@link Comparator} is consistent with {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.\n+     * <p>\n+     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     *     David (age = 25), Eric (age = 20).\n+     *     Further assume that the {@link Comparator} provided imposes the usual increasing ordering on numbers.\n+     *     Using Person::getAge as the groupValueMapping, the resulting collector returns 20, as that is the minimum\n+     *     age of all the elements.\n+     *\n+     * @param <A> type of the matched fact\n+     * @param <Mapped> type of the result\n+     * @param groupValueMapping never null, maps facts from the matched type to the result type\n+     * @param comparator never null\n+     * @return never null\n+     */\n+    public static <A, Mapped> UniConstraintCollector<A, ?, Mapped> min(Function<A, Mapped> groupValueMapping,\n+            Comparator<Mapped> comparator) {\n+        return minOrMax(groupValueMapping, comparator, true);\n+    }\n+\n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     *     {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.\n+     * <p>\n+     *     Example: Assume the following mapped elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     *     David (age = 25), Eric (age = 20).\n+     *     Further assume that Person compares by age.\n+     *     The resulting collector returns 20, as that is the minimum age of all the elements.\n+     *\n+     * @param <A> type of the first matched fact\n+     * @param <B> type of the second matched fact\n+     * @param <Mapped> type of the result\n+     * @param groupValueMapping never null, maps matched facts to the result type\n+     * @return never null\n+     */\n+    public static <A, B, Mapped extends Comparable<Mapped>> BiConstraintCollector<A, B, ?, Mapped> min(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "735f4b99a2fba350ef25278c33a9e1de18c21441"}, "originalPosition": 115}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78b62fc630d3b830ab111120587f208230554747", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/78b62fc630d3b830ab111120587f208230554747", "committedDate": "2020-02-17T12:17:54Z", "message": "Clean up Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/8ee64c636beda1959871089f79fdf7f04493ad05", "committedDate": "2020-02-17T12:50:19Z", "message": "Simplify Javadoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5NzQ2NTk2", "url": "https://github.com/kiegroup/optaplanner/pull/692#pullrequestreview-359746596", "createdAt": "2020-02-17T13:49:15Z", "commit": {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMTI3NjIy", "url": "https://github.com/kiegroup/optaplanner/pull/692#pullrequestreview-360127622", "createdAt": "2020-02-18T07:55:36Z", "commit": {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwNzo1NTozNlrOFq4Qeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwNzo1NTozNlrOFq4Qeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwNjIzNA==", "bodyText": "Consistency: other javadocs don't ident after the <p>. Note that we also never do </p> (that didn't work well). All in all, I am happy to re-standarize all code on whatever openJDK is doing, but that's for a separate PR. Let's have this PR follow the rest of the code.", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380506234", "createdAt": "2020-02-18T07:55:36Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java", "diffHunk": "@@ -526,36 +526,380 @@ private static Runnable innerCountDistinctLong(CountDistinctLongResultContainer\n     // min\n     // ************************************************************************\n \n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMTI3ODYz", "url": "https://github.com/kiegroup/optaplanner/pull/692#pullrequestreview-360127863", "createdAt": "2020-02-18T07:56:05Z", "commit": {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwNzo1NjowNVrOFq4RTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwNzo1NjowNVrOFq4RTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwNjQ0NQ==", "bodyText": "\"compare to equal\" -> \"compare to zero\" (it's more specific)", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380506445", "createdAt": "2020-02-18T07:56:05Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java", "diffHunk": "@@ -526,36 +526,380 @@ private static Runnable innerCountDistinctLong(CountDistinctLongResultContainer\n     // min\n     // ************************************************************************\n \n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     *     {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMTMxNDE1", "url": "https://github.com/kiegroup/optaplanner/pull/692#pullrequestreview-360131415", "createdAt": "2020-02-18T08:03:38Z", "commit": {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwODowMzozOVrOFq4cDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwODowMzozOVrOFq4cDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwOTE5OQ==", "bodyText": "I would change this paragraph into something like this:\nImportant: The {@link Comparable}'s {@link Comparable#compareTo(Object)} must be <i>consistent with equals</i>, such that <tt>e1.compareTo(e2) == 0</tt> has the same boolean value as <tt>e1.equals(e2)</tt>.\nIn other words, if two elements compare to zero, any of them can be returned by the collector. It can even differ between 2 score calculations on the exact same {@link PlanningSolution} state, due to incremental score calculation.\n\nMotivation:\n\nstart with \"important\" to stand out (we do this in a few other javadocs too).\nUse \"must\" instead of \"It is expected that ...\" because that's more direct, stronger (which is appropriate here) and clearer.\nMimic javadocs of Comparable on OpenJDK, use same terminology and phrasing. See 3th paragraph of class javadoc.", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380509199", "createdAt": "2020-02-18T08:03:39Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java", "diffHunk": "@@ -526,36 +526,380 @@ private static Runnable innerCountDistinctLong(CountDistinctLongResultContainer\n     // min\n     // ************************************************************************\n \n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     *     {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMTMzMzc5", "url": "https://github.com/kiegroup/optaplanner/pull/692#pullrequestreview-360133379", "createdAt": "2020-02-18T08:07:51Z", "commit": {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwODowNzo1MVrOFq4iRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwODowNzo1MVrOFq4iRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxMDc4OA==", "bodyText": "Use {@code Ann(age = 20)} to format example input and output.\nWrap a collection of elements as input or output in [].\nUse formal (pseudo-)code-snippet .groupBy(min(Person::getAge)) instead of assume that the Person type compares by age.\nFind a shorter template for \"input + constraintstream = output\". The \"Such collector\" breaks this flow (too much ceremony).", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380510788", "createdAt": "2020-02-18T08:07:51Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java", "diffHunk": "@@ -526,36 +526,380 @@ private static Runnable innerCountDistinctLong(CountDistinctLongResultContainer\n     // min\n     // ************************************************************************\n \n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     *     {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.\n+     * <p>\n+     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     *     David(age = 25), Eric(age = 20).\n+     *     Further assume that the Person type compares by age.\n+     *     Such collector returns either Ann or Eric as the minimum element.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMTM2OTgw", "url": "https://github.com/kiegroup/optaplanner/pull/692#pullrequestreview-360136980", "createdAt": "2020-02-18T08:15:10Z", "commit": {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwODoxNToxMFrOFq4t_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwODoxNToxMFrOFq4t_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxMzc5MQ==", "bodyText": "Soft suggestion: I'd order this method (min(Function)) before min(Comparator), because we want to stimulate users to use this one (I know, it doesn't change the order in javadocs or code completion, but people do look at the sources too and for us it's a signal too that we consider this one more important).", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380513791", "createdAt": "2020-02-18T08:15:10Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java", "diffHunk": "@@ -526,36 +526,380 @@ private static Runnable innerCountDistinctLong(CountDistinctLongResultContainer\n     // min\n     // ************************************************************************\n \n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     *     {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.\n+     * <p>\n+     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     *     David(age = 25), Eric(age = 20).\n+     *     Further assume that the Person type compares by age.\n+     *     Such collector returns either Ann or Eric as the minimum element.\n+     *\n+     * @param <A> type of the matched fact\n+     * @return never null\n+     */\n+    public static <A extends Comparable<A>> UniConstraintCollector<A, ?, A> min() {\n+        return min(Function.identity(), Comparable::compareTo);\n+    }\n+\n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     *     {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.\n+     * <p>\n+     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     *     David(age = 25), Eric(age = 20).\n+     *     Using Person::getAge as the groupValueMapping, the resulting collector returns 20, as that is the minimum\n+     *     age of all the elements.\n+     *\n+     * @param <A> type of the matched fact\n+     * @param <Mapped> type of the result\n+     * @param groupValueMapping never null, maps facts from the matched type to the result type\n+     * @return never null\n+     */\n+    public static <A, Mapped extends Comparable<Mapped>> UniConstraintCollector<A, ?, Mapped> min(\n+            Function<A, Mapped> groupValueMapping) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0aca482626dc960175a9dc4008696d77f654063", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/a0aca482626dc960175a9dc4008696d77f654063", "committedDate": "2020-02-18T08:25:48Z", "message": "Remove comment indentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c95973d18d0c0ea67798c6340003b46c07874836", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/c95973d18d0c0ea67798c6340003b46c07874836", "committedDate": "2020-02-18T08:29:34Z", "message": "Change comparator wording"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMTQ1MTMw", "url": "https://github.com/kiegroup/optaplanner/pull/692#pullrequestreview-360145130", "createdAt": "2020-02-18T08:30:20Z", "commit": {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwODozMDoyMFrOFq5HPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwODozMDoyMFrOFq5HPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUyMDI1Mg==", "bodyText": "A Class as a firstValue?\nWouldn't it make more sense to either use:\nObject o1 = new Object();\nor use mockito's \"mock()\").\nOr does it need to be a class instance? In that case, let's call it firstClass?", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380520252", "createdAt": "2020-02-18T08:30:20Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/ConstraintCollectorsTest.java", "diffHunk": "@@ -1381,6 +1598,224 @@ public void maxNotComparable() {\n         assertResult(collector, container, null);\n     }\n \n+    @Test\n+    public void maxComparableMapped() {\n+        UniConstraintCollector<Class, ?, String> collector = max(Class::getCanonicalName);\n+        Object container = collector.supplier().get();\n+        // add first value, which becomes the max\n+        Class firstValue = ConstraintCollectorsTest.class;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05"}, "originalPosition": 311}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c6f2f8de381136aa28cb58c6f4c2c3586f3530b", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/7c6f2f8de381136aa28cb58c6f4c2c3586f3530b", "committedDate": "2020-02-18T08:32:51Z", "message": "Reorder methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMTU3MjE1", "url": "https://github.com/kiegroup/optaplanner/pull/692#pullrequestreview-360157215", "createdAt": "2020-02-18T08:51:05Z", "commit": {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwODo1MTowNVrOFq5tLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwODo1MTowNVrOFq5tLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUyOTk2Ng==", "bodyText": "This test smells like its \"abstracted\". (I am not saying it is an abstracted test)\nI personally favor concrete tests a lot of abstracted tests.\nFor example:\n// Concrete test\nassertEquals(7, calculator.sum(2, 5));\nassertEquals(7, calculator.sum(4, 3));\nassertEquals(9, calculator.sum(4, 5));\n\n// Abstracted test\nfor (i = 0; i < 7; i++) {\n  for (j = 0; j < 7; i++) {\n   assertEquals(i + j, calculator.sum(i, j));\n  }\n}\n\nAbstracted tests do more tests, but often don't increase test coverage. They make it hard to read what happens in corner cases - which can lead to invalid tests. And they often copy-paste the mistakes from the unit into the unit test code (especially corner cases).", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380529966", "createdAt": "2020-02-18T08:51:05Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/ConstraintCollectorsTest.java", "diffHunk": "@@ -1324,13 +1325,229 @@ public void minNotComparable() {\n         assertResult(collector, container, null);\n     }\n \n+    @Test\n+    public void minComparableMapped() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05"}, "originalPosition": 67}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "015c6b0d2dce74f4721178590bf61b8e4f1e0a19", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/015c6b0d2dce74f4721178590bf61b8e4f1e0a19", "committedDate": "2020-02-18T09:02:42Z", "message": "Refactor Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8f6218a73581f722307d54bad2ee4bfbf82a51d", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/f8f6218a73581f722307d54bad2ee4bfbf82a51d", "committedDate": "2020-02-18T09:13:46Z", "message": "Mention identity comparisons"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a22c2207a9e79b7bb2b9518bb684af4b41d97298", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/a22c2207a9e79b7bb2b9518bb684af4b41d97298", "committedDate": "2020-02-18T09:20:26Z", "message": "Simplify test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1915be2cb203e13022c242f48ec5d9e2b188a76e", "author": {"user": {"login": "triceo", "name": "Luk\u00e1\u0161 Petrovick\u00fd"}}, "url": "https://github.com/kiegroup/optaplanner/commit/1915be2cb203e13022c242f48ec5d9e2b188a76e", "committedDate": "2020-02-18T09:31:10Z", "message": "Address test code review"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3101, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}