{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxMzEzMzYz", "number": 739, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwOTozMjo1NlrODwVFVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxNTo0ODowN1rODw9Zuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDAzNjcwOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/Score.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwOTozMjo1NlrOGDREXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwOTozMjo1NlrOGDREXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3ODU1OQ==", "bodyText": "Public API change.\nThis is a default method, so that the interface remains 100 % backwards compatible.", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406078559", "createdAt": "2020-04-09T09:32:56Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/Score.java", "diffHunk": "@@ -102,6 +102,22 @@\n      */\n     Score_ divide(double divisor);\n \n+    /**\n+     * Return a Score whose every level is a result of dividing the matching levels in this and the divisor.\n+     * When rounding is needed, it should be floored (as defined by {@link Math#floor(double)}).\n+     * <p>\n+     * If the implementation has a scale/precision, then the unspecified scale/precision of the double divisor\n+     * should have no impact on the returned scale/precision.\n+     * <p>\n+     * Allows division by zero if and only if both levels are zero, in which case the resulting level will also be zero.\n+     * Otherwise {@link ArithmeticException} is thrown.\n+     * @param divisor value by which this Score is to be divided\n+     * @return this / divisor\n+     */\n+    default Score_ divide(Score_ divisor) {\n+        throw new UnsupportedOperationException();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c76a95d9d3bac1f0f4b477d0534b25491254f647"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDU4MTAxOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/buildin/simple/SimpleScore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjoyMDoyNVrOGDWSxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjoyMDoyNVrOGDWSxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE2NDE2NQ==", "bodyText": "Soft suggestion: The empty string should be a named constant.", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406164165", "createdAt": "2020-04-09T12:20:25Z", "author": {"login": "yurloc"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/buildin/simple/SimpleScore.java", "diffHunk": "@@ -133,11 +133,18 @@ public SimpleScore multiply(double multiplicand) {\n \n     @Override\n     public SimpleScore divide(double divisor) {\n-        return new SimpleScore(\n-                (int) Math.floor(initScore / divisor),\n+        int newInitScore = divideInitScore(divisor);\n+        return ofUninitialized(newInitScore,\n                 (int) Math.floor(score / divisor));\n     }\n \n+    @Override\n+    public SimpleScore divide(SimpleScore divisor) {\n+        int newInitScore = divideInitScore(divisor.initScore);\n+        int newScore = divideScoreLevel(score, divisor.score, \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0663a1725a5dcf25094d067507ac0f366133b174"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDYzNzQ1OnYy", "diffSide": "RIGHT", "path": "optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjozNjo0OVrOGDW02w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjozNjo0OVrOGDW02w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3Mjg5MQ==", "bodyText": "Given that s is a ConstraintMatchTotal the variable name seems a bit arbitrary. Is it a mistake?", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406172891", "createdAt": "2020-04-09T12:36:49Z", "author": {"login": "yurloc"}, "path": "optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java", "diffHunk": "@@ -39,9 +43,27 @@\n     }\n \n     private Number getImpact() {\n-        return constraintMatchTotalMap.values().stream()\n-                .mapToInt(ConstraintMatchTotal::getConstraintMatchCount)\n-                .sum();\n+        Score<?> zero = getParentConstraintVerifier().getConstraintStreamScoreDirectorFactory()\n+                .getScoreDefinition()\n+                .getZeroScore();\n+        if (constraintMatchTotalMap.isEmpty()) {\n+            return zero.toLevelNumbers()[0]; // Return zero in the numeric type expected by the caller.\n+        }\n+        // We do not know the matchWeight, so we need to deduce it.\n+        // Constraint matches give us a score, whose levels are in the form of (matchWeight * constraintWeight).\n+        // Here, we strip the constraintWeight.\n+        Score<?> totalMatchWeightedScore = constraintMatchTotalMap.values().stream()\n+                .map(s -> s.getScore().divide(s.getConstraintWeight()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0663a1725a5dcf25094d067507ac0f366133b174"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDY1Njg4OnYy", "diffSide": "RIGHT", "path": "optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjo0MjozOVrOGDXBLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNTowNToyMlrOGDc6Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NjA0Nw==", "bodyText": "IIUC, what this does is that it fails fast if the constraint impacts different score levels with different weights, so -5medium/-5soft is valid but -1medium/-2soft fails here. Is that correct?", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406176047", "createdAt": "2020-04-09T12:42:39Z", "author": {"login": "yurloc"}, "path": "optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java", "diffHunk": "@@ -39,9 +43,27 @@\n     }\n \n     private Number getImpact() {\n-        return constraintMatchTotalMap.values().stream()\n-                .mapToInt(ConstraintMatchTotal::getConstraintMatchCount)\n-                .sum();\n+        Score<?> zero = getParentConstraintVerifier().getConstraintStreamScoreDirectorFactory()\n+                .getScoreDefinition()\n+                .getZeroScore();\n+        if (constraintMatchTotalMap.isEmpty()) {\n+            return zero.toLevelNumbers()[0]; // Return zero in the numeric type expected by the caller.\n+        }\n+        // We do not know the matchWeight, so we need to deduce it.\n+        // Constraint matches give us a score, whose levels are in the form of (matchWeight * constraintWeight).\n+        // Here, we strip the constraintWeight.\n+        Score<?> totalMatchWeightedScore = constraintMatchTotalMap.values().stream()\n+                .map(s -> s.getScore().divide(s.getConstraintWeight()))\n+                .reduce(zero, Score::add);\n+        // Each level of the resulting score now has to be the same number, the matchWeight.\n+        List<Number> matchWeightsFound = Arrays.stream(totalMatchWeightedScore.toLevelNumbers())\n+                .distinct()\n+                .collect(Collectors.toList());\n+        if (matchWeightsFound.size() != 1) {\n+            throw new IllegalStateException(\"Programming error: only one match weight should have been found (\"\n+                    + matchWeightsFound + \").\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0663a1725a5dcf25094d067507ac0f366133b174"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3OTU0Nw==", "bodyText": "If yes, why there is such restriction? Maybe there's a technical limitation related to how Constraint Streams are implemented, that is obvious to you but it makes me ask this question. Maybe it's a general OptaPlanner limitation.\nPlease consider leaving a short explanation in the source code comment if you think that kind of information would be relevant here.", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406179547", "createdAt": "2020-04-09T12:49:07Z", "author": {"login": "yurloc"}, "path": "optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java", "diffHunk": "@@ -39,9 +43,27 @@\n     }\n \n     private Number getImpact() {\n-        return constraintMatchTotalMap.values().stream()\n-                .mapToInt(ConstraintMatchTotal::getConstraintMatchCount)\n-                .sum();\n+        Score<?> zero = getParentConstraintVerifier().getConstraintStreamScoreDirectorFactory()\n+                .getScoreDefinition()\n+                .getZeroScore();\n+        if (constraintMatchTotalMap.isEmpty()) {\n+            return zero.toLevelNumbers()[0]; // Return zero in the numeric type expected by the caller.\n+        }\n+        // We do not know the matchWeight, so we need to deduce it.\n+        // Constraint matches give us a score, whose levels are in the form of (matchWeight * constraintWeight).\n+        // Here, we strip the constraintWeight.\n+        Score<?> totalMatchWeightedScore = constraintMatchTotalMap.values().stream()\n+                .map(s -> s.getScore().divide(s.getConstraintWeight()))\n+                .reduce(zero, Score::add);\n+        // Each level of the resulting score now has to be the same number, the matchWeight.\n+        List<Number> matchWeightsFound = Arrays.stream(totalMatchWeightedScore.toLevelNumbers())\n+                .distinct()\n+                .collect(Collectors.toList());\n+        if (matchWeightsFound.size() != 1) {\n+            throw new IllegalStateException(\"Programming error: only one match weight should have been found (\"\n+                    + matchWeightsFound + \").\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NjA0Nw=="}, "originalCommit": {"oid": "0663a1725a5dcf25094d067507ac0f366133b174"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI0MDg2NQ==", "bodyText": "The score here is matchWeight * constraintWeight * matchCount.\nAt this point, I have already divided by it constraintWeight.\nWhat remains is therefore matchWeight * matchCount. And therefore the value in every level of the score must be the same.\nI believe there already is an explanatory comment in the code.\n(That said, you correctly point out a bug in case where one level of the score is 0. Fixing that.)", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406240865", "createdAt": "2020-04-09T14:22:07Z", "author": {"login": "triceo"}, "path": "optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java", "diffHunk": "@@ -39,9 +43,27 @@\n     }\n \n     private Number getImpact() {\n-        return constraintMatchTotalMap.values().stream()\n-                .mapToInt(ConstraintMatchTotal::getConstraintMatchCount)\n-                .sum();\n+        Score<?> zero = getParentConstraintVerifier().getConstraintStreamScoreDirectorFactory()\n+                .getScoreDefinition()\n+                .getZeroScore();\n+        if (constraintMatchTotalMap.isEmpty()) {\n+            return zero.toLevelNumbers()[0]; // Return zero in the numeric type expected by the caller.\n+        }\n+        // We do not know the matchWeight, so we need to deduce it.\n+        // Constraint matches give us a score, whose levels are in the form of (matchWeight * constraintWeight).\n+        // Here, we strip the constraintWeight.\n+        Score<?> totalMatchWeightedScore = constraintMatchTotalMap.values().stream()\n+                .map(s -> s.getScore().divide(s.getConstraintWeight()))\n+                .reduce(zero, Score::add);\n+        // Each level of the resulting score now has to be the same number, the matchWeight.\n+        List<Number> matchWeightsFound = Arrays.stream(totalMatchWeightedScore.toLevelNumbers())\n+                .distinct()\n+                .collect(Collectors.toList());\n+        if (matchWeightsFound.size() != 1) {\n+            throw new IllegalStateException(\"Programming error: only one match weight should have been found (\"\n+                    + matchWeightsFound + \").\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NjA0Nw=="}, "originalCommit": {"oid": "0663a1725a5dcf25094d067507ac0f366133b174"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI0NDYxOQ==", "bodyText": "For example, consider .penalize(\"something\", HardSoftScore.of(1, 2), something -> 2).\nAssume that this penalty is only applied once. In this case:\n\nmatchCount = 1\nmatchWeight = 2\nconstraintWeight = 1hard/2soft\n\nAnd therefore, from the end:\n\nconstraintMatchScore = -2hard/-4soft\nconstraintMatchScore / constraintWeight = -2hard/-2soft\nmatchWeightsFound = [-2]\nresult = -2", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406244619", "createdAt": "2020-04-09T14:27:19Z", "author": {"login": "triceo"}, "path": "optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java", "diffHunk": "@@ -39,9 +43,27 @@\n     }\n \n     private Number getImpact() {\n-        return constraintMatchTotalMap.values().stream()\n-                .mapToInt(ConstraintMatchTotal::getConstraintMatchCount)\n-                .sum();\n+        Score<?> zero = getParentConstraintVerifier().getConstraintStreamScoreDirectorFactory()\n+                .getScoreDefinition()\n+                .getZeroScore();\n+        if (constraintMatchTotalMap.isEmpty()) {\n+            return zero.toLevelNumbers()[0]; // Return zero in the numeric type expected by the caller.\n+        }\n+        // We do not know the matchWeight, so we need to deduce it.\n+        // Constraint matches give us a score, whose levels are in the form of (matchWeight * constraintWeight).\n+        // Here, we strip the constraintWeight.\n+        Score<?> totalMatchWeightedScore = constraintMatchTotalMap.values().stream()\n+                .map(s -> s.getScore().divide(s.getConstraintWeight()))\n+                .reduce(zero, Score::add);\n+        // Each level of the resulting score now has to be the same number, the matchWeight.\n+        List<Number> matchWeightsFound = Arrays.stream(totalMatchWeightedScore.toLevelNumbers())\n+                .distinct()\n+                .collect(Collectors.toList());\n+        if (matchWeightsFound.size() != 1) {\n+            throw new IllegalStateException(\"Programming error: only one match weight should have been found (\"\n+                    + matchWeightsFound + \").\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NjA0Nw=="}, "originalCommit": {"oid": "0663a1725a5dcf25094d067507ac0f366133b174"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI3MjUxOA==", "bodyText": "Beautiful explanation, thanks! Now it makes perfect sense.", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406272518", "createdAt": "2020-04-09T15:05:22Z", "author": {"login": "yurloc"}, "path": "optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java", "diffHunk": "@@ -39,9 +43,27 @@\n     }\n \n     private Number getImpact() {\n-        return constraintMatchTotalMap.values().stream()\n-                .mapToInt(ConstraintMatchTotal::getConstraintMatchCount)\n-                .sum();\n+        Score<?> zero = getParentConstraintVerifier().getConstraintStreamScoreDirectorFactory()\n+                .getScoreDefinition()\n+                .getZeroScore();\n+        if (constraintMatchTotalMap.isEmpty()) {\n+            return zero.toLevelNumbers()[0]; // Return zero in the numeric type expected by the caller.\n+        }\n+        // We do not know the matchWeight, so we need to deduce it.\n+        // Constraint matches give us a score, whose levels are in the form of (matchWeight * constraintWeight).\n+        // Here, we strip the constraintWeight.\n+        Score<?> totalMatchWeightedScore = constraintMatchTotalMap.values().stream()\n+                .map(s -> s.getScore().divide(s.getConstraintWeight()))\n+                .reduce(zero, Score::add);\n+        // Each level of the resulting score now has to be the same number, the matchWeight.\n+        List<Number> matchWeightsFound = Arrays.stream(totalMatchWeightedScore.toLevelNumbers())\n+                .distinct()\n+                .collect(Collectors.toList());\n+        if (matchWeightsFound.size() != 1) {\n+            throw new IllegalStateException(\"Programming error: only one match weight should have been found (\"\n+                    + matchWeightsFound + \").\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NjA0Nw=="}, "originalCommit": {"oid": "0663a1725a5dcf25094d067507ac0f366133b174"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTMwNjk4OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/AbstractScore.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNToxODoyOFrOGDdcnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNToyNjowM1rOGDdxJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4MTM3Mg==", "bodyText": "Nitpicking: You have just moved one instance of SimpleScore's label to another place. What I was pointing out is that \"\" is the score label of SimpleScore and I noticed the the string literal (\"\") is used multiple times in the SimpleScore class and therefore should be replaced by a constant (provided that all \"\" occurrences have the same meaning, which I presume they do).\nIn another words, what would happen if we decided that SimpleScore will get a new label of simp? We would replace two \"\" occurrences in SimpleScore with \"simp\" and we would probably miss this instance (on line 43).", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406281372", "createdAt": "2020-04-09T15:18:28Z", "author": {"login": "yurloc"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/AbstractScore.java", "diffHunk": "@@ -34,6 +35,74 @@\n \n     protected static final String INIT_LABEL = \"init\";\n \n+    protected static int divideScoreLevel(int score, int scoreDivisor) {\n+        return divideScoreLevel(score, scoreDivisor, null);\n+    }\n+\n+    protected static int divideScoreLevel(int score, int scoreDivisor, String maybeLabel) {\n+        String label = maybeLabel == null ? \"\" : maybeLabel;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e34cde34bd022aa74eaade7f8a453b870f2992c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4Mzk2NQ==", "bodyText": "What would happen is that the exception message would continue to say \"X\" instead of \"Xsimp\".\nI really don't consider this a problem - it was a problem before, where I was propagating something that should have been a constant. I don't anymore.", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406283965", "createdAt": "2020-04-09T15:22:24Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/AbstractScore.java", "diffHunk": "@@ -34,6 +35,74 @@\n \n     protected static final String INIT_LABEL = \"init\";\n \n+    protected static int divideScoreLevel(int score, int scoreDivisor) {\n+        return divideScoreLevel(score, scoreDivisor, null);\n+    }\n+\n+    protected static int divideScoreLevel(int score, int scoreDivisor, String maybeLabel) {\n+        String label = maybeLabel == null ? \"\" : maybeLabel;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4MTM3Mg=="}, "originalCommit": {"oid": "9e34cde34bd022aa74eaade7f8a453b870f2992c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4NjYyOA==", "bodyText": "OK, that's another, valid point of view that I didn't think of.", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406286628", "createdAt": "2020-04-09T15:26:03Z", "author": {"login": "yurloc"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/AbstractScore.java", "diffHunk": "@@ -34,6 +35,74 @@\n \n     protected static final String INIT_LABEL = \"init\";\n \n+    protected static int divideScoreLevel(int score, int scoreDivisor) {\n+        return divideScoreLevel(score, scoreDivisor, null);\n+    }\n+\n+    protected static int divideScoreLevel(int score, int scoreDivisor, String maybeLabel) {\n+        String label = maybeLabel == null ? \"\" : maybeLabel;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4MTM3Mg=="}, "originalCommit": {"oid": "9e34cde34bd022aa74eaade7f8a453b870f2992c"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNjYzNTY1OnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/definition/AbstractScoreDefinition.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxNTozOTozNFrOGEOEAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxNTo0NzowN1rOGEOHGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3Nzg5MA==", "bodyText": "My spider sense is tingling, expecting comments here.\nSee table \"Preferred Scales for Results of Arithmetic Operations\" in BigDecimal Javadoc.", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r407077890", "createdAt": "2020-04-11T15:39:34Z", "author": {"login": "triceo"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/definition/AbstractScoreDefinition.java", "diffHunk": "@@ -30,6 +32,38 @@\n \n     private final String[] levelLabels;\n \n+    protected static int sanitize(int number) {\n+        return number == 0 ? 1 : number;\n+    }\n+\n+    protected static long sanitize(long number) {\n+        return number == 0L ? 1L : number;\n+    }\n+\n+    protected static double sanitize(double number) {\n+        return number == 0d ? 1d : number;\n+    }\n+\n+    protected static BigDecimal sanitize(BigDecimal number) {\n+        return number.signum() == 0 ? BigDecimal.ONE : number;\n+    }\n+\n+    protected static int divide(int dividend, int divisor) {\n+        return (int) Math.floor(divide(dividend, (double) divisor));\n+    }\n+\n+    protected static long divide(long dividend, long divisor) {\n+        return (long) Math.floor(divide(dividend, (double) divisor));\n+    }\n+\n+    protected static double divide(double dividend, double divisor) {\n+        return dividend / divisor;\n+    }\n+\n+    protected static BigDecimal divide(BigDecimal dividend, BigDecimal divisor) {\n+        return dividend.divide(divisor, dividend.scale() - divisor.scale(), RoundingMode.FLOOR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ff0ca627a218c3ac46d81947893f9c9d79e566e"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3ODY4MA==", "bodyText": "This is fine. Our long existing method Score.divide(boolean) has a javadoc that says \"When rounding is needed, it should be floored (as defined by {@link Math#floor(double)}).\" This is consistent with that.", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r407078680", "createdAt": "2020-04-11T15:47:07Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/definition/AbstractScoreDefinition.java", "diffHunk": "@@ -30,6 +32,38 @@\n \n     private final String[] levelLabels;\n \n+    protected static int sanitize(int number) {\n+        return number == 0 ? 1 : number;\n+    }\n+\n+    protected static long sanitize(long number) {\n+        return number == 0L ? 1L : number;\n+    }\n+\n+    protected static double sanitize(double number) {\n+        return number == 0d ? 1d : number;\n+    }\n+\n+    protected static BigDecimal sanitize(BigDecimal number) {\n+        return number.signum() == 0 ? BigDecimal.ONE : number;\n+    }\n+\n+    protected static int divide(int dividend, int divisor) {\n+        return (int) Math.floor(divide(dividend, (double) divisor));\n+    }\n+\n+    protected static long divide(long dividend, long divisor) {\n+        return (long) Math.floor(divide(dividend, (double) divisor));\n+    }\n+\n+    protected static double divide(double dividend, double divisor) {\n+        return dividend / divisor;\n+    }\n+\n+    protected static BigDecimal divide(BigDecimal dividend, BigDecimal divisor) {\n+        return dividend.divide(divisor, dividend.scale() - divisor.scale(), RoundingMode.FLOOR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3Nzg5MA=="}, "originalCommit": {"oid": "5ff0ca627a218c3ac46d81947893f9c9d79e566e"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNjY0MjAwOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/definition/ScoreDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxNTo0NzoyNlrOGEOHQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxNTo0NzoyNlrOGEOHQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3ODcyMQ==", "bodyText": "javadoc link to Score", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r407078721", "createdAt": "2020-04-11T15:47:26Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/definition/ScoreDefinition.java", "diffHunk": "@@ -152,4 +152,14 @@ default boolean isNegativeOrZero(S score) {\n      */\n     S buildPessimisticBound(InitializingScoreTrend initializingScoreTrend, S score);\n \n+    /**\n+     * Return a Score whose every level is the result of dividing the matching levels in this and the divisor.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d65e206b977f4cf50dc636d1c7e3c84e7579f439"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNjY0MjUxOnYy", "diffSide": "RIGHT", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/score/buildin/hardsoft/HardSoftScoreDefinitionTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxNTo0ODowN1rOGEOHhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxNTo0ODowN1rOGEOHhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3ODc4OQ==", "bodyText": "Did the buildPessimisticBoundOnlyDown() test get removed?", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r407078789", "createdAt": "2020-04-11T15:48:07Z", "author": {"login": "ge0ffrey"}, "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/score/buildin/hardsoft/HardSoftScoreDefinitionTest.java", "diffHunk": "@@ -89,14 +89,18 @@ public void buildPessimisticBoundOnlyUp() {\n     }\n \n     @Test\n-    public void buildPessimisticBoundOnlyDown() {\n+    public void divideBySanitizedDivisor() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d65e206b977f4cf50dc636d1c7e3c84e7579f439"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4477, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}