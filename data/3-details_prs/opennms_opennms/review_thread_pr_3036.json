{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzODc4MTI0", "number": 3036, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNDo0ODozM1rOEKiv1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwODo1Mjo0MlrOEKzpNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDkwNTE5OnYy", "diffSide": "RIGHT", "path": "features/timeseries/src/main/java/org/opennms/netmgt/timeseries/integration/TimeseriesFetchStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNDo0ODozM1rOGrpNXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzowNToyNFrOGsWRvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQxNzExNg==", "bodyText": "Returning a Callable here seems quite strange. Why not just pass a lambda in the submit function above?", "url": "https://github.com/OpenNMS/opennms/pull/3036#discussion_r448417116", "createdAt": "2020-07-01T14:48:33Z", "author": {"login": "fooker"}, "path": "features/timeseries/src/main/java/org/opennms/netmgt/timeseries/integration/TimeseriesFetchStrategy.java", "diffHunk": "@@ -167,108 +246,15 @@ public FetchResults fetch(long start, long end, long step, int maxrows, Long int\n                 throw Throwables.propagate(e);\n             }\n         }\n-\n-        // Now group the sources by Newts Resource ID, which differs from the OpenNMS Resource ID.\n-        Map<String, List<Source>> sourcesByNewtsResourceId = Maps.newHashMap();\n-        for (Entry<OnmsResource, List<Source>> entry : sourcesByResource.entrySet()) {\n-            final OnmsResource resource = entry.getKey();\n-            for (Source source : entry.getValue()) {\n-                // Gather the values from strings.properties\n-                Utils.convertStringAttributesToConstants(source.getLabel(), resource.getStringPropertyAttributes(), constants);\n-\n-                resources.add(getResourceInfo(resource, source));\n-\n-                // Grab the attribute that matches the source\n-                RrdGraphAttribute rrdGraphAttribute = resource.getRrdGraphAttributes().get(source.getAttribute());\n-\n-                if (rrdGraphAttribute == null && !Strings.isNullOrEmpty(source.getFallbackAttribute())) {\n-                    LOG.error(\"No attribute with name '{}', using fallback-attribute with name '{}'\", source.getAttribute(), source.getFallbackAttribute());\n-                    source.setAttribute(source.getFallbackAttribute());\n-                    source.setFallbackAttribute(null);\n-                    rrdGraphAttribute = resource.getRrdGraphAttributes().get(source.getAttribute());\n-                }\n-\n-                if (rrdGraphAttribute == null) {\n-                    if (relaxed) continue;\n-                    LOG.error(\"No attribute with name: {}\", source.getAttribute());\n-                    return null;\n-                }\n-\n-                // The Newts Resource ID is stored in the rrdFile attribute\n-                String newtsResourceId = rrdGraphAttribute.getRrdRelativePath();\n-                // Remove the file separator prefix, added by the RrdGraphAttribute class\n-                if (newtsResourceId.startsWith(File.separator)) {\n-                    newtsResourceId = newtsResourceId.substring(File.separator.length(), newtsResourceId.length());\n-                }\n-\n-                List<Source> listOfSources = sourcesByNewtsResourceId.get(newtsResourceId);\n-                // Create the list if it doesn't exist\n-                if (listOfSources == null) {\n-                    listOfSources = Lists.newLinkedList();\n-                    sourcesByNewtsResourceId.put(newtsResourceId, listOfSources);\n-                }\n-                listOfSources.add(source);\n-            }\n-        }\n-\n-        // The Newts API only allows us to perform a query using a single (Newts) Resource ID,\n-        // so we perform multiple queries in parallel, and aggregate the results.\n-        Map<String, Future<Collection<Row<Measurement>>>> measurementsByNewtsResourceId = Maps.newHashMapWithExpectedSize(sourcesByNewtsResourceId.size());\n-        for (Entry<String, List<Source>> entry : sourcesByNewtsResourceId.entrySet()) {\n-            measurementsByNewtsResourceId.put(entry.getKey(), threadPool.submit(\n-                    getMeasurementsForResourceCallable(entry.getKey(), entry.getValue(), startTs, endTs, lag)));\n-        }\n-\n-        long[] timestamps = null;\n-        Map<String, double[]> columns = Maps.newHashMap();\n-\n-        for (Entry<String, Future<Collection<Row<Measurement>>>> entry : measurementsByNewtsResourceId.entrySet()) {\n-            Collection<Row<Measurement>> rows;\n-            try {\n-                rows = entry.getValue().get();\n-            } catch (InterruptedException | ExecutionException e) {\n-                throw Throwables.propagate(e);\n-            }\n-\n-            final int N = rows.size();\n-\n-            if (timestamps == null) {\n-                timestamps = new long[N];\n-                int k = 0;\n-                for (final Row<Measurement> row : rows) {\n-                    timestamps[k] = row.getTimestamp().asMillis();\n-                    k++;\n-                }\n-            }\n-\n-            int k = 0;\n-            for (Row<Measurement> row : rows) {\n-                for (Measurement measurement : row.getElements()) {\n-                    double[] column = columns.get(measurement.getName());\n-                    if (column == null) {\n-                        column = new double[N];\n-                        columns.put(measurement.getName(), column);\n-                    }\n-                    column[k] = measurement.getValue();\n-                }\n-                k += 1;\n-            }\n-        }\n-\n-        FetchResults fetchResults = new FetchResults(timestamps, columns, lag.getStep(), constants, new QueryMetadata(resources));\n-        if (relaxed) {\n-            Utils.fillMissingValues(fetchResults, sources);\n-        }\n-        LOG.trace(\"Fetch results: {}\", fetchResults);\n-        return fetchResults;\n+        return sourcesByResource;\n     }\n \n-    private Callable<Collection<Row<Measurement>>> getMeasurementsForResourceCallable(final String resourceId, final List<Source> listOfSources, final Optional<Timestamp> start, final Optional<Timestamp> end, final LateAggregationParams lag) {\n-        return new Callable<Collection<Row<Measurement>>>() {\n+    private Callable<Map<Source, List<Sample>>> getMeasurementsForResourceCallable(final String resourceId, final List<Source> listOfSources, final Instant start, final Instant end, final LateAggregationParams lag) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9898d8d5fe02117d98c5098905d08a7e2f602ad"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE1NTUxOQ==", "bodyText": "\ud83d\udc4d fixed", "url": "https://github.com/OpenNMS/opennms/pull/3036#discussion_r449155519", "createdAt": "2020-07-02T17:05:24Z", "author": {"login": "patrick-schweizer"}, "path": "features/timeseries/src/main/java/org/opennms/netmgt/timeseries/integration/TimeseriesFetchStrategy.java", "diffHunk": "@@ -167,108 +246,15 @@ public FetchResults fetch(long start, long end, long step, int maxrows, Long int\n                 throw Throwables.propagate(e);\n             }\n         }\n-\n-        // Now group the sources by Newts Resource ID, which differs from the OpenNMS Resource ID.\n-        Map<String, List<Source>> sourcesByNewtsResourceId = Maps.newHashMap();\n-        for (Entry<OnmsResource, List<Source>> entry : sourcesByResource.entrySet()) {\n-            final OnmsResource resource = entry.getKey();\n-            for (Source source : entry.getValue()) {\n-                // Gather the values from strings.properties\n-                Utils.convertStringAttributesToConstants(source.getLabel(), resource.getStringPropertyAttributes(), constants);\n-\n-                resources.add(getResourceInfo(resource, source));\n-\n-                // Grab the attribute that matches the source\n-                RrdGraphAttribute rrdGraphAttribute = resource.getRrdGraphAttributes().get(source.getAttribute());\n-\n-                if (rrdGraphAttribute == null && !Strings.isNullOrEmpty(source.getFallbackAttribute())) {\n-                    LOG.error(\"No attribute with name '{}', using fallback-attribute with name '{}'\", source.getAttribute(), source.getFallbackAttribute());\n-                    source.setAttribute(source.getFallbackAttribute());\n-                    source.setFallbackAttribute(null);\n-                    rrdGraphAttribute = resource.getRrdGraphAttributes().get(source.getAttribute());\n-                }\n-\n-                if (rrdGraphAttribute == null) {\n-                    if (relaxed) continue;\n-                    LOG.error(\"No attribute with name: {}\", source.getAttribute());\n-                    return null;\n-                }\n-\n-                // The Newts Resource ID is stored in the rrdFile attribute\n-                String newtsResourceId = rrdGraphAttribute.getRrdRelativePath();\n-                // Remove the file separator prefix, added by the RrdGraphAttribute class\n-                if (newtsResourceId.startsWith(File.separator)) {\n-                    newtsResourceId = newtsResourceId.substring(File.separator.length(), newtsResourceId.length());\n-                }\n-\n-                List<Source> listOfSources = sourcesByNewtsResourceId.get(newtsResourceId);\n-                // Create the list if it doesn't exist\n-                if (listOfSources == null) {\n-                    listOfSources = Lists.newLinkedList();\n-                    sourcesByNewtsResourceId.put(newtsResourceId, listOfSources);\n-                }\n-                listOfSources.add(source);\n-            }\n-        }\n-\n-        // The Newts API only allows us to perform a query using a single (Newts) Resource ID,\n-        // so we perform multiple queries in parallel, and aggregate the results.\n-        Map<String, Future<Collection<Row<Measurement>>>> measurementsByNewtsResourceId = Maps.newHashMapWithExpectedSize(sourcesByNewtsResourceId.size());\n-        for (Entry<String, List<Source>> entry : sourcesByNewtsResourceId.entrySet()) {\n-            measurementsByNewtsResourceId.put(entry.getKey(), threadPool.submit(\n-                    getMeasurementsForResourceCallable(entry.getKey(), entry.getValue(), startTs, endTs, lag)));\n-        }\n-\n-        long[] timestamps = null;\n-        Map<String, double[]> columns = Maps.newHashMap();\n-\n-        for (Entry<String, Future<Collection<Row<Measurement>>>> entry : measurementsByNewtsResourceId.entrySet()) {\n-            Collection<Row<Measurement>> rows;\n-            try {\n-                rows = entry.getValue().get();\n-            } catch (InterruptedException | ExecutionException e) {\n-                throw Throwables.propagate(e);\n-            }\n-\n-            final int N = rows.size();\n-\n-            if (timestamps == null) {\n-                timestamps = new long[N];\n-                int k = 0;\n-                for (final Row<Measurement> row : rows) {\n-                    timestamps[k] = row.getTimestamp().asMillis();\n-                    k++;\n-                }\n-            }\n-\n-            int k = 0;\n-            for (Row<Measurement> row : rows) {\n-                for (Measurement measurement : row.getElements()) {\n-                    double[] column = columns.get(measurement.getName());\n-                    if (column == null) {\n-                        column = new double[N];\n-                        columns.put(measurement.getName(), column);\n-                    }\n-                    column[k] = measurement.getValue();\n-                }\n-                k += 1;\n-            }\n-        }\n-\n-        FetchResults fetchResults = new FetchResults(timestamps, columns, lag.getStep(), constants, new QueryMetadata(resources));\n-        if (relaxed) {\n-            Utils.fillMissingValues(fetchResults, sources);\n-        }\n-        LOG.trace(\"Fetch results: {}\", fetchResults);\n-        return fetchResults;\n+        return sourcesByResource;\n     }\n \n-    private Callable<Collection<Row<Measurement>>> getMeasurementsForResourceCallable(final String resourceId, final List<Source> listOfSources, final Optional<Timestamp> start, final Optional<Timestamp> end, final LateAggregationParams lag) {\n-        return new Callable<Collection<Row<Measurement>>>() {\n+    private Callable<Map<Source, List<Sample>>> getMeasurementsForResourceCallable(final String resourceId, final List<Source> listOfSources, final Instant start, final Instant end, final LateAggregationParams lag) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQxNzExNg=="}, "originalCommit": {"oid": "d9898d8d5fe02117d98c5098905d08a7e2f602ad"}, "originalPosition": 301}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzY3MzUxOnYy", "diffSide": "RIGHT", "path": "features/timeseries/src/main/java/org/opennms/netmgt/timeseries/integration/persistence/TimeseriesPersistOperationBuilder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwODo1Mjo0MlrOGsDqlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODoyNjo0MlrOGsYz-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg1MDU4MA==", "bodyText": "This metric may be not detailed enough. I see two problems here:\n\nThis measures to calls to the implementation which we maybe want to inspect separately.\nWe also measure the time needed to build the list of samples to insert/index.", "url": "https://github.com/OpenNMS/opennms/pull/3036#discussion_r448850580", "createdAt": "2020-07-02T08:52:42Z", "author": {"login": "fooker"}, "path": "features/timeseries/src/main/java/org/opennms/netmgt/timeseries/integration/persistence/TimeseriesPersistOperationBuilder.java", "diffHunk": "@@ -122,8 +122,10 @@ public void setAttributeMetadata(String metricIdentifier, String name) {\n \n     @Override\n     public void commit() {\n-        writer.insert(getSamplesToInsert());\n-        writer.index(getSamplesToIndex());\n+        try(final Timer.Context context = commitTimer.time()) {\n+            writer.insert(getSamplesToInsert());\n+            writer.index(getSamplesToIndex());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9898d8d5fe02117d98c5098905d08a7e2f602ad"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2MzU5Nw==", "bodyText": "This measures to calls to the implementation which we maybe want to inspect separately.\n\nTrue, we measure the overall time to collect the samples. You think we should turn that into 2 separate timers?\n\nWe also measure the time needed to build the list of samples to insert/index.\n\nThe actual insert happens in a different thread (managed by the ringbuffer).\nWe measure the insert times separately:\nmetadata.write.db\nsamples.write.ts", "url": "https://github.com/OpenNMS/opennms/pull/3036#discussion_r449163597", "createdAt": "2020-07-02T17:19:48Z", "author": {"login": "patrick-schweizer"}, "path": "features/timeseries/src/main/java/org/opennms/netmgt/timeseries/integration/persistence/TimeseriesPersistOperationBuilder.java", "diffHunk": "@@ -122,8 +122,10 @@ public void setAttributeMetadata(String metricIdentifier, String name) {\n \n     @Override\n     public void commit() {\n-        writer.insert(getSamplesToInsert());\n-        writer.index(getSamplesToIndex());\n+        try(final Timer.Context context = commitTimer.time()) {\n+            writer.insert(getSamplesToInsert());\n+            writer.index(getSamplesToIndex());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg1MDU4MA=="}, "originalCommit": {"oid": "d9898d8d5fe02117d98c5098905d08a7e2f602ad"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5NzA0OQ==", "bodyText": "Ok, if this is the collect part only, a single metric is fine", "url": "https://github.com/OpenNMS/opennms/pull/3036#discussion_r449197049", "createdAt": "2020-07-02T18:26:42Z", "author": {"login": "fooker"}, "path": "features/timeseries/src/main/java/org/opennms/netmgt/timeseries/integration/persistence/TimeseriesPersistOperationBuilder.java", "diffHunk": "@@ -122,8 +122,10 @@ public void setAttributeMetadata(String metricIdentifier, String name) {\n \n     @Override\n     public void commit() {\n-        writer.insert(getSamplesToInsert());\n-        writer.index(getSamplesToIndex());\n+        try(final Timer.Context context = commitTimer.time()) {\n+            writer.insert(getSamplesToInsert());\n+            writer.index(getSamplesToIndex());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg1MDU4MA=="}, "originalCommit": {"oid": "d9898d8d5fe02117d98c5098905d08a7e2f602ad"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 696, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}