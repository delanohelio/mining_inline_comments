{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1MDUwMTc0", "number": 2874, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDozNzowMFrODZoQHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDozNzowMFrODZoQHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjAwNDc5OnYy", "diffSide": "RIGHT", "path": "core/ipc/rpc/kafka/src/main/java/org/opennms/core/ipc/rpc/kafka/KafkaRpcServerManager.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDozNzowMFrOFgIAbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxODoxOToxMVrOFgmJdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIyOTkzNQ==", "bodyText": "This is a problem - if a Minion doesn't have a module loaded it still consumes the relevant requests and drops them silently.", "url": "https://github.com/OpenNMS/opennms/pull/2874#discussion_r369229935", "createdAt": "2020-01-21T20:37:00Z", "author": {"login": "j-white"}, "path": "core/ipc/rpc/kafka/src/main/java/org/opennms/core/ipc/rpc/kafka/KafkaRpcServerManager.java", "diffHunk": "@@ -258,40 +256,24 @@ public void run() {\n                             if (rpcMessage.getTotalChunks() > 1) {\n                                 // Handle multiple chunks\n                                 boolean allChunksReceived = handleChunks(rpcMessage);\n-                                if(!allChunksReceived) {\n+                                if (!allChunksReceived) {\n                                     continue;\n                                 }\n                                 rpcContent = messageCache.get(rpcId);\n                                 //Remove rpcId from cache.\n                                 messageCache.remove(rpcId);\n                                 currentChunkCache.remove(rpcId);\n                             }\n-                            //Build child span from rpcMessage and start minion span.\n-                            Tracer.SpanBuilder spanBuilder = buildSpanFromRpcMessage(rpcMessage);\n-                            Span minionSpan = spanBuilder.start();\n-\n-                            RpcRequest request = module.unmarshalRequest(rpcContent.toStringUtf8());\n-                            setTagsOnMinion(rpcMessage, request, minionSpan);\n-\n-                            CompletableFuture<RpcResponse> future = module.execute(request);\n-                            future.whenComplete((res, ex) -> {\n-                                final RpcResponse response;\n-                                if (ex != null) {\n-                                    // An exception occurred, store the exception in a new response\n-                                    LOG.warn(\"An error occured while executing a call in {}.\", module.getId(), ex);\n-                                    response = module.createResponseWithException(ex);\n-                                    minionSpan.log(ex.getMessage());\n-                                    minionSpan.setTag(TAG_RPC_FAILED, \"true\");\n-                                } else {\n-                                    // No exception occurred, use the given response\n-                                    response = res;\n-                                }\n-                                // Finish minion Span\n-                                minionSpan.finish();\n-                                sendResponse(rpcId, response);\n-                            });\n+                            final RpcModule module = modulesById.get(rpcMessage.getModuleId());\n+                            if(module == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36288cf055b079ce690b6819f3694acf9c92e076"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI0NjU4MQ==", "bodyText": "yeah.  If you are considering a scenario where certain modules are loaded on one minion and rest of the modules are loaded on another minion, that may not work with this approach.", "url": "https://github.com/OpenNMS/opennms/pull/2874#discussion_r369246581", "createdAt": "2020-01-21T21:15:24Z", "author": {"login": "cgorantla"}, "path": "core/ipc/rpc/kafka/src/main/java/org/opennms/core/ipc/rpc/kafka/KafkaRpcServerManager.java", "diffHunk": "@@ -258,40 +256,24 @@ public void run() {\n                             if (rpcMessage.getTotalChunks() > 1) {\n                                 // Handle multiple chunks\n                                 boolean allChunksReceived = handleChunks(rpcMessage);\n-                                if(!allChunksReceived) {\n+                                if (!allChunksReceived) {\n                                     continue;\n                                 }\n                                 rpcContent = messageCache.get(rpcId);\n                                 //Remove rpcId from cache.\n                                 messageCache.remove(rpcId);\n                                 currentChunkCache.remove(rpcId);\n                             }\n-                            //Build child span from rpcMessage and start minion span.\n-                            Tracer.SpanBuilder spanBuilder = buildSpanFromRpcMessage(rpcMessage);\n-                            Span minionSpan = spanBuilder.start();\n-\n-                            RpcRequest request = module.unmarshalRequest(rpcContent.toStringUtf8());\n-                            setTagsOnMinion(rpcMessage, request, minionSpan);\n-\n-                            CompletableFuture<RpcResponse> future = module.execute(request);\n-                            future.whenComplete((res, ex) -> {\n-                                final RpcResponse response;\n-                                if (ex != null) {\n-                                    // An exception occurred, store the exception in a new response\n-                                    LOG.warn(\"An error occured while executing a call in {}.\", module.getId(), ex);\n-                                    response = module.createResponseWithException(ex);\n-                                    minionSpan.log(ex.getMessage());\n-                                    minionSpan.setTag(TAG_RPC_FAILED, \"true\");\n-                                } else {\n-                                    // No exception occurred, use the given response\n-                                    response = res;\n-                                }\n-                                // Finish minion Span\n-                                minionSpan.finish();\n-                                sendResponse(rpcId, response);\n-                            });\n+                            final RpcModule module = modulesById.get(rpcMessage.getModuleId());\n+                            if(module == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIyOTkzNQ=="}, "originalCommit": {"oid": "36288cf055b079ce690b6819f3694acf9c92e076"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcyMTYxNA==", "bodyText": "I realized that we can't disable RPC as that would disable Echo module as well which is needed  for maintaining minion status.  We can still create a topic specific to Echo and subscribe to it by default.  subscribe to generic rpc-request topic only if at least one of the other rpc modules are loaded.  Let me know what do you think.", "url": "https://github.com/OpenNMS/opennms/pull/2874#discussion_r369721614", "createdAt": "2020-01-22T18:14:36Z", "author": {"login": "cgorantla"}, "path": "core/ipc/rpc/kafka/src/main/java/org/opennms/core/ipc/rpc/kafka/KafkaRpcServerManager.java", "diffHunk": "@@ -258,40 +256,24 @@ public void run() {\n                             if (rpcMessage.getTotalChunks() > 1) {\n                                 // Handle multiple chunks\n                                 boolean allChunksReceived = handleChunks(rpcMessage);\n-                                if(!allChunksReceived) {\n+                                if (!allChunksReceived) {\n                                     continue;\n                                 }\n                                 rpcContent = messageCache.get(rpcId);\n                                 //Remove rpcId from cache.\n                                 messageCache.remove(rpcId);\n                                 currentChunkCache.remove(rpcId);\n                             }\n-                            //Build child span from rpcMessage and start minion span.\n-                            Tracer.SpanBuilder spanBuilder = buildSpanFromRpcMessage(rpcMessage);\n-                            Span minionSpan = spanBuilder.start();\n-\n-                            RpcRequest request = module.unmarshalRequest(rpcContent.toStringUtf8());\n-                            setTagsOnMinion(rpcMessage, request, minionSpan);\n-\n-                            CompletableFuture<RpcResponse> future = module.execute(request);\n-                            future.whenComplete((res, ex) -> {\n-                                final RpcResponse response;\n-                                if (ex != null) {\n-                                    // An exception occurred, store the exception in a new response\n-                                    LOG.warn(\"An error occured while executing a call in {}.\", module.getId(), ex);\n-                                    response = module.createResponseWithException(ex);\n-                                    minionSpan.log(ex.getMessage());\n-                                    minionSpan.setTag(TAG_RPC_FAILED, \"true\");\n-                                } else {\n-                                    // No exception occurred, use the given response\n-                                    response = res;\n-                                }\n-                                // Finish minion Span\n-                                minionSpan.finish();\n-                                sendResponse(rpcId, response);\n-                            });\n+                            final RpcModule module = modulesById.get(rpcMessage.getModuleId());\n+                            if(module == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIyOTkzNQ=="}, "originalCommit": {"oid": "36288cf055b079ce690b6819f3694acf9c92e076"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcyMzc2Ng==", "bodyText": "Or introduce two more Minion Status, RPC_UP, SINK_UP", "url": "https://github.com/OpenNMS/opennms/pull/2874#discussion_r369723766", "createdAt": "2020-01-22T18:19:11Z", "author": {"login": "cgorantla"}, "path": "core/ipc/rpc/kafka/src/main/java/org/opennms/core/ipc/rpc/kafka/KafkaRpcServerManager.java", "diffHunk": "@@ -258,40 +256,24 @@ public void run() {\n                             if (rpcMessage.getTotalChunks() > 1) {\n                                 // Handle multiple chunks\n                                 boolean allChunksReceived = handleChunks(rpcMessage);\n-                                if(!allChunksReceived) {\n+                                if (!allChunksReceived) {\n                                     continue;\n                                 }\n                                 rpcContent = messageCache.get(rpcId);\n                                 //Remove rpcId from cache.\n                                 messageCache.remove(rpcId);\n                                 currentChunkCache.remove(rpcId);\n                             }\n-                            //Build child span from rpcMessage and start minion span.\n-                            Tracer.SpanBuilder spanBuilder = buildSpanFromRpcMessage(rpcMessage);\n-                            Span minionSpan = spanBuilder.start();\n-\n-                            RpcRequest request = module.unmarshalRequest(rpcContent.toStringUtf8());\n-                            setTagsOnMinion(rpcMessage, request, minionSpan);\n-\n-                            CompletableFuture<RpcResponse> future = module.execute(request);\n-                            future.whenComplete((res, ex) -> {\n-                                final RpcResponse response;\n-                                if (ex != null) {\n-                                    // An exception occurred, store the exception in a new response\n-                                    LOG.warn(\"An error occured while executing a call in {}.\", module.getId(), ex);\n-                                    response = module.createResponseWithException(ex);\n-                                    minionSpan.log(ex.getMessage());\n-                                    minionSpan.setTag(TAG_RPC_FAILED, \"true\");\n-                                } else {\n-                                    // No exception occurred, use the given response\n-                                    response = res;\n-                                }\n-                                // Finish minion Span\n-                                minionSpan.finish();\n-                                sendResponse(rpcId, response);\n-                            });\n+                            final RpcModule module = modulesById.get(rpcMessage.getModuleId());\n+                            if(module == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIyOTkzNQ=="}, "originalCommit": {"oid": "36288cf055b079ce690b6819f3694acf9c92e076"}, "originalPosition": 207}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 734, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}