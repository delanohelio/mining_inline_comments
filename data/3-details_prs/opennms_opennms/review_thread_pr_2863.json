{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwNDk2NTI2", "number": 2863, "reviewThreads": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDowMTowN1rODc_J1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMzowOFrODe6U9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNzIxNDMwOnYy", "diffSide": "LEFT", "path": "core/ipc/sink/aws-sqs/server/src/main/java/org/opennms/core/ipc/sink/aws/sqs/server/AmazonSQSMessageConsumerManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDowMTowN1rOFlVAXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDowMTowN1rOFlVAXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY4NTc4OQ==", "bodyText": "Unnecessary changes.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374685789", "createdAt": "2020-02-04T14:01:07Z", "author": {"login": "j-white"}, "path": "core/ipc/sink/aws-sqs/server/src/main/java/org/opennms/core/ipc/sink/aws/sqs/server/AmazonSQSMessageConsumerManager.java", "diffHunk": "@@ -28,18 +28,6 @@\n \n package org.opennms.core.ipc.sink.aws.sqs.server;\n \n-import com.amazonaws.services.sqs.AmazonSQS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODUxNzYyOnYy", "diffSide": "RIGHT", "path": "core/ipc/grpc/common/src/main/proto/ipc.proto", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDowNTo1MlrOFlhvjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNjoyMDo0MVrOFmhV0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NDQ3OQ==", "bodyText": "Unit of time?", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374894479", "createdAt": "2020-02-04T20:05:52Z", "author": {"login": "j-white"}, "path": "core/ipc/grpc/common/src/main/proto/ipc.proto", "diffHunk": "@@ -0,0 +1,47 @@\n+syntax = \"proto3\";\n+\n+option java_multiple_files = true;\n+option java_package = \"org.opennms.core.ipc.grpc.common\";\n+option java_outer_classname = \"MinionIpc\";\n+\n+// service definitions of IPC between Minion and OpenNMS\n+service OpenNMSIpc {\n+    // Streams RPC messages between OpenNMS and Minion.\n+    rpc RpcStreaming (stream RpcResponseProto) returns (stream RpcRequestProto) {\n+    }\n+    // Streams Sink messages from Minion to OpenNMS\n+    rpc SinkStreaming (stream SinkMessage) returns (Empty) {\n+    }\n+}\n+\n+message Empty {\n+\n+}\n+\n+\n+message RpcRequestProto {\n+    string rpc_id = 1;\n+    bytes rpc_content = 2;\n+    string system_id = 3;\n+    string location = 4;\n+    string module_id = 5;\n+    uint64 expiration_time = 6;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMTU3OQ==", "bodyText": "Didn't understand.  uint64 from proto maps to long in java", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r375531579", "createdAt": "2020-02-05T21:58:11Z", "author": {"login": "cgorantla"}, "path": "core/ipc/grpc/common/src/main/proto/ipc.proto", "diffHunk": "@@ -0,0 +1,47 @@\n+syntax = \"proto3\";\n+\n+option java_multiple_files = true;\n+option java_package = \"org.opennms.core.ipc.grpc.common\";\n+option java_outer_classname = \"MinionIpc\";\n+\n+// service definitions of IPC between Minion and OpenNMS\n+service OpenNMSIpc {\n+    // Streams RPC messages between OpenNMS and Minion.\n+    rpc RpcStreaming (stream RpcResponseProto) returns (stream RpcRequestProto) {\n+    }\n+    // Streams Sink messages from Minion to OpenNMS\n+    rpc SinkStreaming (stream SinkMessage) returns (Empty) {\n+    }\n+}\n+\n+message Empty {\n+\n+}\n+\n+\n+message RpcRequestProto {\n+    string rpc_id = 1;\n+    bytes rpc_content = 2;\n+    string system_id = 3;\n+    string location = 4;\n+    string module_id = 5;\n+    uint64 expiration_time = 6;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NDQ3OQ=="}, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU0MDg0Mw==", "bodyText": "Looking at this field it's unclear if this is seconds, milliseconds, a relative duration or a timestamp.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r375540843", "createdAt": "2020-02-05T22:20:34Z", "author": {"login": "j-white"}, "path": "core/ipc/grpc/common/src/main/proto/ipc.proto", "diffHunk": "@@ -0,0 +1,47 @@\n+syntax = \"proto3\";\n+\n+option java_multiple_files = true;\n+option java_package = \"org.opennms.core.ipc.grpc.common\";\n+option java_outer_classname = \"MinionIpc\";\n+\n+// service definitions of IPC between Minion and OpenNMS\n+service OpenNMSIpc {\n+    // Streams RPC messages between OpenNMS and Minion.\n+    rpc RpcStreaming (stream RpcResponseProto) returns (stream RpcRequestProto) {\n+    }\n+    // Streams Sink messages from Minion to OpenNMS\n+    rpc SinkStreaming (stream SinkMessage) returns (Empty) {\n+    }\n+}\n+\n+message Empty {\n+\n+}\n+\n+\n+message RpcRequestProto {\n+    string rpc_id = 1;\n+    bytes rpc_content = 2;\n+    string system_id = 3;\n+    string location = 4;\n+    string module_id = 5;\n+    uint64 expiration_time = 6;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NDQ3OQ=="}, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkzNTQ0Mw==", "bodyText": "field name expiration_time seems reasonable. Added comment to specify that it is  absolute time elapsed since the epoch in msec", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r375935443", "createdAt": "2020-02-06T16:19:05Z", "author": {"login": "cgorantla"}, "path": "core/ipc/grpc/common/src/main/proto/ipc.proto", "diffHunk": "@@ -0,0 +1,47 @@\n+syntax = \"proto3\";\n+\n+option java_multiple_files = true;\n+option java_package = \"org.opennms.core.ipc.grpc.common\";\n+option java_outer_classname = \"MinionIpc\";\n+\n+// service definitions of IPC between Minion and OpenNMS\n+service OpenNMSIpc {\n+    // Streams RPC messages between OpenNMS and Minion.\n+    rpc RpcStreaming (stream RpcResponseProto) returns (stream RpcRequestProto) {\n+    }\n+    // Streams Sink messages from Minion to OpenNMS\n+    rpc SinkStreaming (stream SinkMessage) returns (Empty) {\n+    }\n+}\n+\n+message Empty {\n+\n+}\n+\n+\n+message RpcRequestProto {\n+    string rpc_id = 1;\n+    bytes rpc_content = 2;\n+    string system_id = 3;\n+    string location = 4;\n+    string module_id = 5;\n+    uint64 expiration_time = 6;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NDQ3OQ=="}, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkzNjQ2NQ==", "bodyText": "That works too. Thanks.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r375936465", "createdAt": "2020-02-06T16:20:41Z", "author": {"login": "j-white"}, "path": "core/ipc/grpc/common/src/main/proto/ipc.proto", "diffHunk": "@@ -0,0 +1,47 @@\n+syntax = \"proto3\";\n+\n+option java_multiple_files = true;\n+option java_package = \"org.opennms.core.ipc.grpc.common\";\n+option java_outer_classname = \"MinionIpc\";\n+\n+// service definitions of IPC between Minion and OpenNMS\n+service OpenNMSIpc {\n+    // Streams RPC messages between OpenNMS and Minion.\n+    rpc RpcStreaming (stream RpcResponseProto) returns (stream RpcRequestProto) {\n+    }\n+    // Streams Sink messages from Minion to OpenNMS\n+    rpc SinkStreaming (stream SinkMessage) returns (Empty) {\n+    }\n+}\n+\n+message Empty {\n+\n+}\n+\n+\n+message RpcRequestProto {\n+    string rpc_id = 1;\n+    bytes rpc_content = 2;\n+    string system_id = 3;\n+    string location = 4;\n+    string module_id = 5;\n+    uint64 expiration_time = 6;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NDQ3OQ=="}, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODUxOTA0OnYy", "diffSide": "RIGHT", "path": "core/ipc/grpc/common/src/main/proto/ipc.proto", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDowNjoyM1rOFlhwbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDowNjoyM1rOFlhwbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NDcwMQ==", "bodyText": "Can we add the system_id of the Minion in these too?", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374894701", "createdAt": "2020-02-04T20:06:23Z", "author": {"login": "j-white"}, "path": "core/ipc/grpc/common/src/main/proto/ipc.proto", "diffHunk": "@@ -0,0 +1,47 @@\n+syntax = \"proto3\";\n+\n+option java_multiple_files = true;\n+option java_package = \"org.opennms.core.ipc.grpc.common\";\n+option java_outer_classname = \"MinionIpc\";\n+\n+// service definitions of IPC between Minion and OpenNMS\n+service OpenNMSIpc {\n+    // Streams RPC messages between OpenNMS and Minion.\n+    rpc RpcStreaming (stream RpcResponseProto) returns (stream RpcRequestProto) {\n+    }\n+    // Streams Sink messages from Minion to OpenNMS\n+    rpc SinkStreaming (stream SinkMessage) returns (Empty) {\n+    }\n+}\n+\n+message Empty {\n+\n+}\n+\n+\n+message RpcRequestProto {\n+    string rpc_id = 1;\n+    bytes rpc_content = 2;\n+    string system_id = 3;\n+    string location = 4;\n+    string module_id = 5;\n+    uint64 expiration_time = 6;\n+    map<string, string> tracing_info = 7;\n+}\n+\n+message RpcResponseProto {\n+    string rpc_id = 1;\n+    bytes rpc_content = 2;\n+    string system_id = 3;\n+    string location = 4;\n+    string module_id = 5;\n+    map<string, string> tracing_info = 6;\n+}\n+\n+message SinkMessage {\n+    string message_id = 1;\n+    bytes content = 2;\n+    string location = 3;\n+    string module_id = 4;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODUyMjY3OnYy", "diffSide": "RIGHT", "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDowNzo0N1rOFlhytw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDowNzo0N1rOFlhytw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NTI4Nw==", "bodyText": "We should add documentation here that describes the basics of how the client works.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374895287", "createdAt": "2020-02-04T20:07:47Z", "author": {"login": "j-white"}, "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODUyNDE4OnYy", "diffSide": "RIGHT", "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDowODoxNlrOFlhzng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNjowODo1MFrOFmg4rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NTUxOA==", "bodyText": "Use ByteString.wrap instead - bytes wont change.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374895518", "createdAt": "2020-02-04T20:08:16Z", "author": {"login": "j-white"}, "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinionGrpcClient.class);\n+    private static final long SINK_BLOCKING_TIMEOUT = 3000;\n+    private static final int SINK_BLOCKING_THREAD_POOL_SIZE = 100;\n+    private ManagedChannel channel;\n+    private OpenNMSIpcGrpc.OpenNMSIpcStub asyncStub;\n+    private Properties properties;\n+    private BundleContext bundleContext;\n+    private MinionIdentity minionIdentity;\n+    private ConfigurationAdmin configAdmin;\n+    private StreamObserver<RpcResponseProto> rpcStream;\n+    private StreamObserver<SinkMessage> sinkStream;\n+    private ConnectivityState currentChannelState;\n+    private MetricRegistry metrics;\n+    private TracerRegistry tracerRegistry;\n+    private final ThreadFactory requestHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-request-handler-%d\")\n+            .build();\n+    private final ThreadFactory blockingSinkMessageThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"blocking-sink-message-%d\")\n+            .build();\n+    private final ExecutorService requestHandlerExecutor = Executors.newCachedThreadPool(requestHandlerThreadFactory);\n+    private final Map<String, RpcModule<RpcRequest, RpcResponse>> registerdModules = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService blockingSinkMessageScheduler = Executors.newScheduledThreadPool(SINK_BLOCKING_THREAD_POOL_SIZE,\n+            blockingSinkMessageThreadFactory);\n+\n+\n+    public MinionGrpcClient(MinionIdentity identity, ConfigurationAdmin configAdmin) {\n+        this.minionIdentity = identity;\n+        this.configAdmin = configAdmin;\n+    }\n+\n+\n+    public void start() throws IOException {\n+        properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_CLIENT_PID);\n+        String host = PropertiesUtils.getProperty(properties, GRPC_HOST, DEFAULT_GRPC_HOST);\n+        int port = PropertiesUtils.getProperty(properties, GRPC_PORT, DEFAULT_GRPC_PORT);\n+        boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+        int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+\n+        NettyChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(host, port)\n+                .keepAliveWithoutCalls(true)\n+                .maxInboundMessageSize(maxInboundMessageSize);\n+\n+        if (tlsEnabled) {\n+            channel = channelBuilder\n+                    .negotiationType(NegotiationType.TLS)\n+                    .sslContext(buildSslContext().build())\n+                    .build();\n+            LOG.info(\"TLS enabled for gRPC\");\n+        } else {\n+            channel = channelBuilder.usePlaintext().build();\n+        }\n+\n+        asyncStub = OpenNMSIpcGrpc.newStub(channel);\n+        initializeRpcStub();\n+        initializeSinkStub();\n+        if (tracerRegistry != null) {\n+            tracerRegistry.init(minionIdentity.getLocation() + \"@\" + minionIdentity.getId());\n+        }\n+        LOG.info(\"Minion at location {} with systemId {} started\", minionIdentity.getLocation(), minionIdentity.getId());\n+\n+    }\n+\n+    private SslContextBuilder buildSslContext() throws SSLException {\n+        SslContextBuilder builder = GrpcSslContexts.forClient();\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        String clientPrivateKeyFilePath = properties.getProperty(CLIENT_PRIVATE_KEY_FILE_PATH);\n+        String trustCertCollectionFilePath = properties.getProperty(TRUST_CERTIFICATE_FILE_PATH);\n+\n+        if (trustCertCollectionFilePath != null) {\n+            builder.trustManager(new File(trustCertCollectionFilePath));\n+        }\n+        if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {\n+            builder.keyManager(new File(clientCertChainFilePath), new File(clientPrivateKeyFilePath));\n+        }\n+        return builder;\n+    }\n+\n+    private void initializeRpcStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            rpcStream = asyncStub.rpcStreaming(new RpcMessageHandler());\n+            // Need to send minion headers to gRPC server in order to register.\n+            sendMinionHeaders();\n+            LOG.info(\"Initialized RPC stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+    private void initializeSinkStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            sinkStream = asyncStub.sinkStreaming(new EmptyMessageReceiver());\n+            LOG.info(\"Initialized Sink stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void bind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            if (registerdModules.containsKey(rpcModule.getId())) {\n+                LOG.warn(\" {} module is already registered\", rpcModule.getId());\n+            } else {\n+                registerdModules.put(rpcModule.getId(), rpcModule);\n+                LOG.info(\"Registered module {} with gRPC IPC client\", rpcModule.getId());\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void unbind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            registerdModules.remove(rpcModule.getId());\n+            LOG.info(\"Removing module {} from gRPC IPC client.\", rpcModule.getId());\n+        }\n+    }\n+\n+    private boolean hasChangedToReadyState() {\n+        ConnectivityState prevState = currentChannelState;\n+        return !prevState.equals(ConnectivityState.READY) && getChannelState().equals(ConnectivityState.READY);\n+    }\n+\n+    public void shutdown() {\n+        requestHandlerExecutor.shutdownNow();\n+        blockingSinkMessageScheduler.shutdownNow();\n+        registerdModules.clear();\n+        if (rpcStream != null) {\n+            rpcStream.onCompleted();\n+        }\n+        channel.shutdown();\n+        LOG.info(\"Minion at location {} with systemId {} stopped\", minionIdentity.getLocation(), minionIdentity.getId());\n+    }\n+\n+    public void setBundleContext(BundleContext bundleContext) {\n+        this.bundleContext = bundleContext;\n+    }\n+\n+\n+    @Override\n+    public String getMetricDomain() {\n+        return SINK_METRIC_PRODUCER_DOMAIN;\n+    }\n+\n+    @Override\n+    public BundleContext getBundleContext() {\n+        return bundleContext;\n+    }\n+\n+    @Override\n+    public Tracer getTracer() {\n+        if (tracerRegistry != null) {\n+            return tracerRegistry.getTracer();\n+        }\n+        return GlobalTracer.get();\n+    }\n+\n+    @Override\n+    public MetricRegistry getMetrics() {\n+        if (metrics == null) {\n+            return new MetricRegistry();\n+        }\n+        return metrics;\n+    }\n+\n+    public void setMetrics(MetricRegistry metrics) {\n+        this.metrics = metrics;\n+    }\n+\n+    public TracerRegistry getTracerRegistry() {\n+        return tracerRegistry;\n+    }\n+\n+    public void setTracerRegistry(TracerRegistry tracerRegistry) {\n+        this.tracerRegistry = tracerRegistry;\n+    }\n+\n+    ConnectivityState getChannelState() {\n+        return currentChannelState = channel.getState(true);\n+    }\n+\n+\n+    @Override\n+    public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String metadata, T message) {\n+\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) {\n+            byte[] sinkMessageContent = module.marshal(message);\n+            String messageId = UUID.randomUUID().toString();\n+            SinkMessage.Builder sinkMessageBuilder = SinkMessage.newBuilder()\n+                    .setMessageId(messageId)\n+                    .setLocation(minionIdentity.getLocation())\n+                    .setModuleId(module.getId())\n+                    .setContent(ByteString.copyFrom(sinkMessageContent));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkxNTk2Mw==", "bodyText": "Looks like  ByteString.wrap is not public.  There is no alternative way of other than copyFrom", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r375915963", "createdAt": "2020-02-06T15:48:52Z", "author": {"login": "cgorantla"}, "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinionGrpcClient.class);\n+    private static final long SINK_BLOCKING_TIMEOUT = 3000;\n+    private static final int SINK_BLOCKING_THREAD_POOL_SIZE = 100;\n+    private ManagedChannel channel;\n+    private OpenNMSIpcGrpc.OpenNMSIpcStub asyncStub;\n+    private Properties properties;\n+    private BundleContext bundleContext;\n+    private MinionIdentity minionIdentity;\n+    private ConfigurationAdmin configAdmin;\n+    private StreamObserver<RpcResponseProto> rpcStream;\n+    private StreamObserver<SinkMessage> sinkStream;\n+    private ConnectivityState currentChannelState;\n+    private MetricRegistry metrics;\n+    private TracerRegistry tracerRegistry;\n+    private final ThreadFactory requestHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-request-handler-%d\")\n+            .build();\n+    private final ThreadFactory blockingSinkMessageThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"blocking-sink-message-%d\")\n+            .build();\n+    private final ExecutorService requestHandlerExecutor = Executors.newCachedThreadPool(requestHandlerThreadFactory);\n+    private final Map<String, RpcModule<RpcRequest, RpcResponse>> registerdModules = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService blockingSinkMessageScheduler = Executors.newScheduledThreadPool(SINK_BLOCKING_THREAD_POOL_SIZE,\n+            blockingSinkMessageThreadFactory);\n+\n+\n+    public MinionGrpcClient(MinionIdentity identity, ConfigurationAdmin configAdmin) {\n+        this.minionIdentity = identity;\n+        this.configAdmin = configAdmin;\n+    }\n+\n+\n+    public void start() throws IOException {\n+        properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_CLIENT_PID);\n+        String host = PropertiesUtils.getProperty(properties, GRPC_HOST, DEFAULT_GRPC_HOST);\n+        int port = PropertiesUtils.getProperty(properties, GRPC_PORT, DEFAULT_GRPC_PORT);\n+        boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+        int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+\n+        NettyChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(host, port)\n+                .keepAliveWithoutCalls(true)\n+                .maxInboundMessageSize(maxInboundMessageSize);\n+\n+        if (tlsEnabled) {\n+            channel = channelBuilder\n+                    .negotiationType(NegotiationType.TLS)\n+                    .sslContext(buildSslContext().build())\n+                    .build();\n+            LOG.info(\"TLS enabled for gRPC\");\n+        } else {\n+            channel = channelBuilder.usePlaintext().build();\n+        }\n+\n+        asyncStub = OpenNMSIpcGrpc.newStub(channel);\n+        initializeRpcStub();\n+        initializeSinkStub();\n+        if (tracerRegistry != null) {\n+            tracerRegistry.init(minionIdentity.getLocation() + \"@\" + minionIdentity.getId());\n+        }\n+        LOG.info(\"Minion at location {} with systemId {} started\", minionIdentity.getLocation(), minionIdentity.getId());\n+\n+    }\n+\n+    private SslContextBuilder buildSslContext() throws SSLException {\n+        SslContextBuilder builder = GrpcSslContexts.forClient();\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        String clientPrivateKeyFilePath = properties.getProperty(CLIENT_PRIVATE_KEY_FILE_PATH);\n+        String trustCertCollectionFilePath = properties.getProperty(TRUST_CERTIFICATE_FILE_PATH);\n+\n+        if (trustCertCollectionFilePath != null) {\n+            builder.trustManager(new File(trustCertCollectionFilePath));\n+        }\n+        if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {\n+            builder.keyManager(new File(clientCertChainFilePath), new File(clientPrivateKeyFilePath));\n+        }\n+        return builder;\n+    }\n+\n+    private void initializeRpcStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            rpcStream = asyncStub.rpcStreaming(new RpcMessageHandler());\n+            // Need to send minion headers to gRPC server in order to register.\n+            sendMinionHeaders();\n+            LOG.info(\"Initialized RPC stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+    private void initializeSinkStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            sinkStream = asyncStub.sinkStreaming(new EmptyMessageReceiver());\n+            LOG.info(\"Initialized Sink stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void bind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            if (registerdModules.containsKey(rpcModule.getId())) {\n+                LOG.warn(\" {} module is already registered\", rpcModule.getId());\n+            } else {\n+                registerdModules.put(rpcModule.getId(), rpcModule);\n+                LOG.info(\"Registered module {} with gRPC IPC client\", rpcModule.getId());\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void unbind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            registerdModules.remove(rpcModule.getId());\n+            LOG.info(\"Removing module {} from gRPC IPC client.\", rpcModule.getId());\n+        }\n+    }\n+\n+    private boolean hasChangedToReadyState() {\n+        ConnectivityState prevState = currentChannelState;\n+        return !prevState.equals(ConnectivityState.READY) && getChannelState().equals(ConnectivityState.READY);\n+    }\n+\n+    public void shutdown() {\n+        requestHandlerExecutor.shutdownNow();\n+        blockingSinkMessageScheduler.shutdownNow();\n+        registerdModules.clear();\n+        if (rpcStream != null) {\n+            rpcStream.onCompleted();\n+        }\n+        channel.shutdown();\n+        LOG.info(\"Minion at location {} with systemId {} stopped\", minionIdentity.getLocation(), minionIdentity.getId());\n+    }\n+\n+    public void setBundleContext(BundleContext bundleContext) {\n+        this.bundleContext = bundleContext;\n+    }\n+\n+\n+    @Override\n+    public String getMetricDomain() {\n+        return SINK_METRIC_PRODUCER_DOMAIN;\n+    }\n+\n+    @Override\n+    public BundleContext getBundleContext() {\n+        return bundleContext;\n+    }\n+\n+    @Override\n+    public Tracer getTracer() {\n+        if (tracerRegistry != null) {\n+            return tracerRegistry.getTracer();\n+        }\n+        return GlobalTracer.get();\n+    }\n+\n+    @Override\n+    public MetricRegistry getMetrics() {\n+        if (metrics == null) {\n+            return new MetricRegistry();\n+        }\n+        return metrics;\n+    }\n+\n+    public void setMetrics(MetricRegistry metrics) {\n+        this.metrics = metrics;\n+    }\n+\n+    public TracerRegistry getTracerRegistry() {\n+        return tracerRegistry;\n+    }\n+\n+    public void setTracerRegistry(TracerRegistry tracerRegistry) {\n+        this.tracerRegistry = tracerRegistry;\n+    }\n+\n+    ConnectivityState getChannelState() {\n+        return currentChannelState = channel.getState(true);\n+    }\n+\n+\n+    @Override\n+    public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String metadata, T message) {\n+\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) {\n+            byte[] sinkMessageContent = module.marshal(message);\n+            String messageId = UUID.randomUUID().toString();\n+            SinkMessage.Builder sinkMessageBuilder = SinkMessage.newBuilder()\n+                    .setMessageId(messageId)\n+                    .setLocation(minionIdentity.getLocation())\n+                    .setModuleId(module.getId())\n+                    .setContent(ByteString.copyFrom(sinkMessageContent));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NTUxOA=="}, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkyOTAwNQ==", "bodyText": "Ack. Missed that.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r375929005", "createdAt": "2020-02-06T16:08:50Z", "author": {"login": "j-white"}, "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinionGrpcClient.class);\n+    private static final long SINK_BLOCKING_TIMEOUT = 3000;\n+    private static final int SINK_BLOCKING_THREAD_POOL_SIZE = 100;\n+    private ManagedChannel channel;\n+    private OpenNMSIpcGrpc.OpenNMSIpcStub asyncStub;\n+    private Properties properties;\n+    private BundleContext bundleContext;\n+    private MinionIdentity minionIdentity;\n+    private ConfigurationAdmin configAdmin;\n+    private StreamObserver<RpcResponseProto> rpcStream;\n+    private StreamObserver<SinkMessage> sinkStream;\n+    private ConnectivityState currentChannelState;\n+    private MetricRegistry metrics;\n+    private TracerRegistry tracerRegistry;\n+    private final ThreadFactory requestHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-request-handler-%d\")\n+            .build();\n+    private final ThreadFactory blockingSinkMessageThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"blocking-sink-message-%d\")\n+            .build();\n+    private final ExecutorService requestHandlerExecutor = Executors.newCachedThreadPool(requestHandlerThreadFactory);\n+    private final Map<String, RpcModule<RpcRequest, RpcResponse>> registerdModules = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService blockingSinkMessageScheduler = Executors.newScheduledThreadPool(SINK_BLOCKING_THREAD_POOL_SIZE,\n+            blockingSinkMessageThreadFactory);\n+\n+\n+    public MinionGrpcClient(MinionIdentity identity, ConfigurationAdmin configAdmin) {\n+        this.minionIdentity = identity;\n+        this.configAdmin = configAdmin;\n+    }\n+\n+\n+    public void start() throws IOException {\n+        properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_CLIENT_PID);\n+        String host = PropertiesUtils.getProperty(properties, GRPC_HOST, DEFAULT_GRPC_HOST);\n+        int port = PropertiesUtils.getProperty(properties, GRPC_PORT, DEFAULT_GRPC_PORT);\n+        boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+        int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+\n+        NettyChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(host, port)\n+                .keepAliveWithoutCalls(true)\n+                .maxInboundMessageSize(maxInboundMessageSize);\n+\n+        if (tlsEnabled) {\n+            channel = channelBuilder\n+                    .negotiationType(NegotiationType.TLS)\n+                    .sslContext(buildSslContext().build())\n+                    .build();\n+            LOG.info(\"TLS enabled for gRPC\");\n+        } else {\n+            channel = channelBuilder.usePlaintext().build();\n+        }\n+\n+        asyncStub = OpenNMSIpcGrpc.newStub(channel);\n+        initializeRpcStub();\n+        initializeSinkStub();\n+        if (tracerRegistry != null) {\n+            tracerRegistry.init(minionIdentity.getLocation() + \"@\" + minionIdentity.getId());\n+        }\n+        LOG.info(\"Minion at location {} with systemId {} started\", minionIdentity.getLocation(), minionIdentity.getId());\n+\n+    }\n+\n+    private SslContextBuilder buildSslContext() throws SSLException {\n+        SslContextBuilder builder = GrpcSslContexts.forClient();\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        String clientPrivateKeyFilePath = properties.getProperty(CLIENT_PRIVATE_KEY_FILE_PATH);\n+        String trustCertCollectionFilePath = properties.getProperty(TRUST_CERTIFICATE_FILE_PATH);\n+\n+        if (trustCertCollectionFilePath != null) {\n+            builder.trustManager(new File(trustCertCollectionFilePath));\n+        }\n+        if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {\n+            builder.keyManager(new File(clientCertChainFilePath), new File(clientPrivateKeyFilePath));\n+        }\n+        return builder;\n+    }\n+\n+    private void initializeRpcStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            rpcStream = asyncStub.rpcStreaming(new RpcMessageHandler());\n+            // Need to send minion headers to gRPC server in order to register.\n+            sendMinionHeaders();\n+            LOG.info(\"Initialized RPC stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+    private void initializeSinkStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            sinkStream = asyncStub.sinkStreaming(new EmptyMessageReceiver());\n+            LOG.info(\"Initialized Sink stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void bind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            if (registerdModules.containsKey(rpcModule.getId())) {\n+                LOG.warn(\" {} module is already registered\", rpcModule.getId());\n+            } else {\n+                registerdModules.put(rpcModule.getId(), rpcModule);\n+                LOG.info(\"Registered module {} with gRPC IPC client\", rpcModule.getId());\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void unbind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            registerdModules.remove(rpcModule.getId());\n+            LOG.info(\"Removing module {} from gRPC IPC client.\", rpcModule.getId());\n+        }\n+    }\n+\n+    private boolean hasChangedToReadyState() {\n+        ConnectivityState prevState = currentChannelState;\n+        return !prevState.equals(ConnectivityState.READY) && getChannelState().equals(ConnectivityState.READY);\n+    }\n+\n+    public void shutdown() {\n+        requestHandlerExecutor.shutdownNow();\n+        blockingSinkMessageScheduler.shutdownNow();\n+        registerdModules.clear();\n+        if (rpcStream != null) {\n+            rpcStream.onCompleted();\n+        }\n+        channel.shutdown();\n+        LOG.info(\"Minion at location {} with systemId {} stopped\", minionIdentity.getLocation(), minionIdentity.getId());\n+    }\n+\n+    public void setBundleContext(BundleContext bundleContext) {\n+        this.bundleContext = bundleContext;\n+    }\n+\n+\n+    @Override\n+    public String getMetricDomain() {\n+        return SINK_METRIC_PRODUCER_DOMAIN;\n+    }\n+\n+    @Override\n+    public BundleContext getBundleContext() {\n+        return bundleContext;\n+    }\n+\n+    @Override\n+    public Tracer getTracer() {\n+        if (tracerRegistry != null) {\n+            return tracerRegistry.getTracer();\n+        }\n+        return GlobalTracer.get();\n+    }\n+\n+    @Override\n+    public MetricRegistry getMetrics() {\n+        if (metrics == null) {\n+            return new MetricRegistry();\n+        }\n+        return metrics;\n+    }\n+\n+    public void setMetrics(MetricRegistry metrics) {\n+        this.metrics = metrics;\n+    }\n+\n+    public TracerRegistry getTracerRegistry() {\n+        return tracerRegistry;\n+    }\n+\n+    public void setTracerRegistry(TracerRegistry tracerRegistry) {\n+        this.tracerRegistry = tracerRegistry;\n+    }\n+\n+    ConnectivityState getChannelState() {\n+        return currentChannelState = channel.getState(true);\n+    }\n+\n+\n+    @Override\n+    public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String metadata, T message) {\n+\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) {\n+            byte[] sinkMessageContent = module.marshal(message);\n+            String messageId = UUID.randomUUID().toString();\n+            SinkMessage.Builder sinkMessageBuilder = SinkMessage.newBuilder()\n+                    .setMessageId(messageId)\n+                    .setLocation(minionIdentity.getLocation())\n+                    .setModuleId(module.getId())\n+                    .setContent(ByteString.copyFrom(sinkMessageContent));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NTUxOA=="}, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 306}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODUyNTYzOnYy", "diffSide": "RIGHT", "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDowODo0MFrOFlh0cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNTo0Njo1M1rOFmgAxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NTcyOA==", "bodyText": "If module doesn't have async policy, then block?", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374895728", "createdAt": "2020-02-04T20:08:40Z", "author": {"login": "j-white"}, "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinionGrpcClient.class);\n+    private static final long SINK_BLOCKING_TIMEOUT = 3000;\n+    private static final int SINK_BLOCKING_THREAD_POOL_SIZE = 100;\n+    private ManagedChannel channel;\n+    private OpenNMSIpcGrpc.OpenNMSIpcStub asyncStub;\n+    private Properties properties;\n+    private BundleContext bundleContext;\n+    private MinionIdentity minionIdentity;\n+    private ConfigurationAdmin configAdmin;\n+    private StreamObserver<RpcResponseProto> rpcStream;\n+    private StreamObserver<SinkMessage> sinkStream;\n+    private ConnectivityState currentChannelState;\n+    private MetricRegistry metrics;\n+    private TracerRegistry tracerRegistry;\n+    private final ThreadFactory requestHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-request-handler-%d\")\n+            .build();\n+    private final ThreadFactory blockingSinkMessageThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"blocking-sink-message-%d\")\n+            .build();\n+    private final ExecutorService requestHandlerExecutor = Executors.newCachedThreadPool(requestHandlerThreadFactory);\n+    private final Map<String, RpcModule<RpcRequest, RpcResponse>> registerdModules = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService blockingSinkMessageScheduler = Executors.newScheduledThreadPool(SINK_BLOCKING_THREAD_POOL_SIZE,\n+            blockingSinkMessageThreadFactory);\n+\n+\n+    public MinionGrpcClient(MinionIdentity identity, ConfigurationAdmin configAdmin) {\n+        this.minionIdentity = identity;\n+        this.configAdmin = configAdmin;\n+    }\n+\n+\n+    public void start() throws IOException {\n+        properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_CLIENT_PID);\n+        String host = PropertiesUtils.getProperty(properties, GRPC_HOST, DEFAULT_GRPC_HOST);\n+        int port = PropertiesUtils.getProperty(properties, GRPC_PORT, DEFAULT_GRPC_PORT);\n+        boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+        int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+\n+        NettyChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(host, port)\n+                .keepAliveWithoutCalls(true)\n+                .maxInboundMessageSize(maxInboundMessageSize);\n+\n+        if (tlsEnabled) {\n+            channel = channelBuilder\n+                    .negotiationType(NegotiationType.TLS)\n+                    .sslContext(buildSslContext().build())\n+                    .build();\n+            LOG.info(\"TLS enabled for gRPC\");\n+        } else {\n+            channel = channelBuilder.usePlaintext().build();\n+        }\n+\n+        asyncStub = OpenNMSIpcGrpc.newStub(channel);\n+        initializeRpcStub();\n+        initializeSinkStub();\n+        if (tracerRegistry != null) {\n+            tracerRegistry.init(minionIdentity.getLocation() + \"@\" + minionIdentity.getId());\n+        }\n+        LOG.info(\"Minion at location {} with systemId {} started\", minionIdentity.getLocation(), minionIdentity.getId());\n+\n+    }\n+\n+    private SslContextBuilder buildSslContext() throws SSLException {\n+        SslContextBuilder builder = GrpcSslContexts.forClient();\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        String clientPrivateKeyFilePath = properties.getProperty(CLIENT_PRIVATE_KEY_FILE_PATH);\n+        String trustCertCollectionFilePath = properties.getProperty(TRUST_CERTIFICATE_FILE_PATH);\n+\n+        if (trustCertCollectionFilePath != null) {\n+            builder.trustManager(new File(trustCertCollectionFilePath));\n+        }\n+        if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {\n+            builder.keyManager(new File(clientCertChainFilePath), new File(clientPrivateKeyFilePath));\n+        }\n+        return builder;\n+    }\n+\n+    private void initializeRpcStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            rpcStream = asyncStub.rpcStreaming(new RpcMessageHandler());\n+            // Need to send minion headers to gRPC server in order to register.\n+            sendMinionHeaders();\n+            LOG.info(\"Initialized RPC stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+    private void initializeSinkStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            sinkStream = asyncStub.sinkStreaming(new EmptyMessageReceiver());\n+            LOG.info(\"Initialized Sink stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void bind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            if (registerdModules.containsKey(rpcModule.getId())) {\n+                LOG.warn(\" {} module is already registered\", rpcModule.getId());\n+            } else {\n+                registerdModules.put(rpcModule.getId(), rpcModule);\n+                LOG.info(\"Registered module {} with gRPC IPC client\", rpcModule.getId());\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void unbind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            registerdModules.remove(rpcModule.getId());\n+            LOG.info(\"Removing module {} from gRPC IPC client.\", rpcModule.getId());\n+        }\n+    }\n+\n+    private boolean hasChangedToReadyState() {\n+        ConnectivityState prevState = currentChannelState;\n+        return !prevState.equals(ConnectivityState.READY) && getChannelState().equals(ConnectivityState.READY);\n+    }\n+\n+    public void shutdown() {\n+        requestHandlerExecutor.shutdownNow();\n+        blockingSinkMessageScheduler.shutdownNow();\n+        registerdModules.clear();\n+        if (rpcStream != null) {\n+            rpcStream.onCompleted();\n+        }\n+        channel.shutdown();\n+        LOG.info(\"Minion at location {} with systemId {} stopped\", minionIdentity.getLocation(), minionIdentity.getId());\n+    }\n+\n+    public void setBundleContext(BundleContext bundleContext) {\n+        this.bundleContext = bundleContext;\n+    }\n+\n+\n+    @Override\n+    public String getMetricDomain() {\n+        return SINK_METRIC_PRODUCER_DOMAIN;\n+    }\n+\n+    @Override\n+    public BundleContext getBundleContext() {\n+        return bundleContext;\n+    }\n+\n+    @Override\n+    public Tracer getTracer() {\n+        if (tracerRegistry != null) {\n+            return tracerRegistry.getTracer();\n+        }\n+        return GlobalTracer.get();\n+    }\n+\n+    @Override\n+    public MetricRegistry getMetrics() {\n+        if (metrics == null) {\n+            return new MetricRegistry();\n+        }\n+        return metrics;\n+    }\n+\n+    public void setMetrics(MetricRegistry metrics) {\n+        this.metrics = metrics;\n+    }\n+\n+    public TracerRegistry getTracerRegistry() {\n+        return tracerRegistry;\n+    }\n+\n+    public void setTracerRegistry(TracerRegistry tracerRegistry) {\n+        this.tracerRegistry = tracerRegistry;\n+    }\n+\n+    ConnectivityState getChannelState() {\n+        return currentChannelState = channel.getState(true);\n+    }\n+\n+\n+    @Override\n+    public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String metadata, T message) {\n+\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) {\n+            byte[] sinkMessageContent = module.marshal(message);\n+            String messageId = UUID.randomUUID().toString();\n+            SinkMessage.Builder sinkMessageBuilder = SinkMessage.newBuilder()\n+                    .setMessageId(messageId)\n+                    .setLocation(minionIdentity.getLocation())\n+                    .setModuleId(module.getId())\n+                    .setContent(ByteString.copyFrom(sinkMessageContent));\n+\n+            if (module.getId().equals(HEARTBEAT_MODULE_ID)) {\n+                if (rpcStream == null || sinkStream == null || hasChangedToReadyState()) {\n+                    initializeSinkStub();\n+                    initializeRpcStub();\n+                }\n+            }\n+            setTagsForSink(sinkMessageBuilder);\n+            // If module has asyncpolicy, keep attempting to send message.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 315}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkxNDY5NA==", "bodyText": "If module has async policy set then we should block here till we are able to send this message.\nIf module has no async policy set, we should attempt to send now and don't block dispatch.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r375914694", "createdAt": "2020-02-06T15:46:53Z", "author": {"login": "cgorantla"}, "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinionGrpcClient.class);\n+    private static final long SINK_BLOCKING_TIMEOUT = 3000;\n+    private static final int SINK_BLOCKING_THREAD_POOL_SIZE = 100;\n+    private ManagedChannel channel;\n+    private OpenNMSIpcGrpc.OpenNMSIpcStub asyncStub;\n+    private Properties properties;\n+    private BundleContext bundleContext;\n+    private MinionIdentity minionIdentity;\n+    private ConfigurationAdmin configAdmin;\n+    private StreamObserver<RpcResponseProto> rpcStream;\n+    private StreamObserver<SinkMessage> sinkStream;\n+    private ConnectivityState currentChannelState;\n+    private MetricRegistry metrics;\n+    private TracerRegistry tracerRegistry;\n+    private final ThreadFactory requestHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-request-handler-%d\")\n+            .build();\n+    private final ThreadFactory blockingSinkMessageThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"blocking-sink-message-%d\")\n+            .build();\n+    private final ExecutorService requestHandlerExecutor = Executors.newCachedThreadPool(requestHandlerThreadFactory);\n+    private final Map<String, RpcModule<RpcRequest, RpcResponse>> registerdModules = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService blockingSinkMessageScheduler = Executors.newScheduledThreadPool(SINK_BLOCKING_THREAD_POOL_SIZE,\n+            blockingSinkMessageThreadFactory);\n+\n+\n+    public MinionGrpcClient(MinionIdentity identity, ConfigurationAdmin configAdmin) {\n+        this.minionIdentity = identity;\n+        this.configAdmin = configAdmin;\n+    }\n+\n+\n+    public void start() throws IOException {\n+        properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_CLIENT_PID);\n+        String host = PropertiesUtils.getProperty(properties, GRPC_HOST, DEFAULT_GRPC_HOST);\n+        int port = PropertiesUtils.getProperty(properties, GRPC_PORT, DEFAULT_GRPC_PORT);\n+        boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+        int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+\n+        NettyChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(host, port)\n+                .keepAliveWithoutCalls(true)\n+                .maxInboundMessageSize(maxInboundMessageSize);\n+\n+        if (tlsEnabled) {\n+            channel = channelBuilder\n+                    .negotiationType(NegotiationType.TLS)\n+                    .sslContext(buildSslContext().build())\n+                    .build();\n+            LOG.info(\"TLS enabled for gRPC\");\n+        } else {\n+            channel = channelBuilder.usePlaintext().build();\n+        }\n+\n+        asyncStub = OpenNMSIpcGrpc.newStub(channel);\n+        initializeRpcStub();\n+        initializeSinkStub();\n+        if (tracerRegistry != null) {\n+            tracerRegistry.init(minionIdentity.getLocation() + \"@\" + minionIdentity.getId());\n+        }\n+        LOG.info(\"Minion at location {} with systemId {} started\", minionIdentity.getLocation(), minionIdentity.getId());\n+\n+    }\n+\n+    private SslContextBuilder buildSslContext() throws SSLException {\n+        SslContextBuilder builder = GrpcSslContexts.forClient();\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        String clientPrivateKeyFilePath = properties.getProperty(CLIENT_PRIVATE_KEY_FILE_PATH);\n+        String trustCertCollectionFilePath = properties.getProperty(TRUST_CERTIFICATE_FILE_PATH);\n+\n+        if (trustCertCollectionFilePath != null) {\n+            builder.trustManager(new File(trustCertCollectionFilePath));\n+        }\n+        if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {\n+            builder.keyManager(new File(clientCertChainFilePath), new File(clientPrivateKeyFilePath));\n+        }\n+        return builder;\n+    }\n+\n+    private void initializeRpcStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            rpcStream = asyncStub.rpcStreaming(new RpcMessageHandler());\n+            // Need to send minion headers to gRPC server in order to register.\n+            sendMinionHeaders();\n+            LOG.info(\"Initialized RPC stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+    private void initializeSinkStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            sinkStream = asyncStub.sinkStreaming(new EmptyMessageReceiver());\n+            LOG.info(\"Initialized Sink stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void bind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            if (registerdModules.containsKey(rpcModule.getId())) {\n+                LOG.warn(\" {} module is already registered\", rpcModule.getId());\n+            } else {\n+                registerdModules.put(rpcModule.getId(), rpcModule);\n+                LOG.info(\"Registered module {} with gRPC IPC client\", rpcModule.getId());\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void unbind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            registerdModules.remove(rpcModule.getId());\n+            LOG.info(\"Removing module {} from gRPC IPC client.\", rpcModule.getId());\n+        }\n+    }\n+\n+    private boolean hasChangedToReadyState() {\n+        ConnectivityState prevState = currentChannelState;\n+        return !prevState.equals(ConnectivityState.READY) && getChannelState().equals(ConnectivityState.READY);\n+    }\n+\n+    public void shutdown() {\n+        requestHandlerExecutor.shutdownNow();\n+        blockingSinkMessageScheduler.shutdownNow();\n+        registerdModules.clear();\n+        if (rpcStream != null) {\n+            rpcStream.onCompleted();\n+        }\n+        channel.shutdown();\n+        LOG.info(\"Minion at location {} with systemId {} stopped\", minionIdentity.getLocation(), minionIdentity.getId());\n+    }\n+\n+    public void setBundleContext(BundleContext bundleContext) {\n+        this.bundleContext = bundleContext;\n+    }\n+\n+\n+    @Override\n+    public String getMetricDomain() {\n+        return SINK_METRIC_PRODUCER_DOMAIN;\n+    }\n+\n+    @Override\n+    public BundleContext getBundleContext() {\n+        return bundleContext;\n+    }\n+\n+    @Override\n+    public Tracer getTracer() {\n+        if (tracerRegistry != null) {\n+            return tracerRegistry.getTracer();\n+        }\n+        return GlobalTracer.get();\n+    }\n+\n+    @Override\n+    public MetricRegistry getMetrics() {\n+        if (metrics == null) {\n+            return new MetricRegistry();\n+        }\n+        return metrics;\n+    }\n+\n+    public void setMetrics(MetricRegistry metrics) {\n+        this.metrics = metrics;\n+    }\n+\n+    public TracerRegistry getTracerRegistry() {\n+        return tracerRegistry;\n+    }\n+\n+    public void setTracerRegistry(TracerRegistry tracerRegistry) {\n+        this.tracerRegistry = tracerRegistry;\n+    }\n+\n+    ConnectivityState getChannelState() {\n+        return currentChannelState = channel.getState(true);\n+    }\n+\n+\n+    @Override\n+    public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String metadata, T message) {\n+\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) {\n+            byte[] sinkMessageContent = module.marshal(message);\n+            String messageId = UUID.randomUUID().toString();\n+            SinkMessage.Builder sinkMessageBuilder = SinkMessage.newBuilder()\n+                    .setMessageId(messageId)\n+                    .setLocation(minionIdentity.getLocation())\n+                    .setModuleId(module.getId())\n+                    .setContent(ByteString.copyFrom(sinkMessageContent));\n+\n+            if (module.getId().equals(HEARTBEAT_MODULE_ID)) {\n+                if (rpcStream == null || sinkStream == null || hasChangedToReadyState()) {\n+                    initializeSinkStub();\n+                    initializeRpcStub();\n+                }\n+            }\n+            setTagsForSink(sinkMessageBuilder);\n+            // If module has asyncpolicy, keep attempting to send message.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NTcyOA=="}, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 315}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODUyNzk0OnYy", "diffSide": "RIGHT", "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDowOToyM1rOFlh1xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDowOToyM1rOFlh1xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NjA2OQ==", "bodyText": "We should include the module and message id in the log.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374896069", "createdAt": "2020-02-04T20:09:23Z", "author": {"login": "j-white"}, "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinionGrpcClient.class);\n+    private static final long SINK_BLOCKING_TIMEOUT = 3000;\n+    private static final int SINK_BLOCKING_THREAD_POOL_SIZE = 100;\n+    private ManagedChannel channel;\n+    private OpenNMSIpcGrpc.OpenNMSIpcStub asyncStub;\n+    private Properties properties;\n+    private BundleContext bundleContext;\n+    private MinionIdentity minionIdentity;\n+    private ConfigurationAdmin configAdmin;\n+    private StreamObserver<RpcResponseProto> rpcStream;\n+    private StreamObserver<SinkMessage> sinkStream;\n+    private ConnectivityState currentChannelState;\n+    private MetricRegistry metrics;\n+    private TracerRegistry tracerRegistry;\n+    private final ThreadFactory requestHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-request-handler-%d\")\n+            .build();\n+    private final ThreadFactory blockingSinkMessageThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"blocking-sink-message-%d\")\n+            .build();\n+    private final ExecutorService requestHandlerExecutor = Executors.newCachedThreadPool(requestHandlerThreadFactory);\n+    private final Map<String, RpcModule<RpcRequest, RpcResponse>> registerdModules = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService blockingSinkMessageScheduler = Executors.newScheduledThreadPool(SINK_BLOCKING_THREAD_POOL_SIZE,\n+            blockingSinkMessageThreadFactory);\n+\n+\n+    public MinionGrpcClient(MinionIdentity identity, ConfigurationAdmin configAdmin) {\n+        this.minionIdentity = identity;\n+        this.configAdmin = configAdmin;\n+    }\n+\n+\n+    public void start() throws IOException {\n+        properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_CLIENT_PID);\n+        String host = PropertiesUtils.getProperty(properties, GRPC_HOST, DEFAULT_GRPC_HOST);\n+        int port = PropertiesUtils.getProperty(properties, GRPC_PORT, DEFAULT_GRPC_PORT);\n+        boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+        int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+\n+        NettyChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(host, port)\n+                .keepAliveWithoutCalls(true)\n+                .maxInboundMessageSize(maxInboundMessageSize);\n+\n+        if (tlsEnabled) {\n+            channel = channelBuilder\n+                    .negotiationType(NegotiationType.TLS)\n+                    .sslContext(buildSslContext().build())\n+                    .build();\n+            LOG.info(\"TLS enabled for gRPC\");\n+        } else {\n+            channel = channelBuilder.usePlaintext().build();\n+        }\n+\n+        asyncStub = OpenNMSIpcGrpc.newStub(channel);\n+        initializeRpcStub();\n+        initializeSinkStub();\n+        if (tracerRegistry != null) {\n+            tracerRegistry.init(minionIdentity.getLocation() + \"@\" + minionIdentity.getId());\n+        }\n+        LOG.info(\"Minion at location {} with systemId {} started\", minionIdentity.getLocation(), minionIdentity.getId());\n+\n+    }\n+\n+    private SslContextBuilder buildSslContext() throws SSLException {\n+        SslContextBuilder builder = GrpcSslContexts.forClient();\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        String clientPrivateKeyFilePath = properties.getProperty(CLIENT_PRIVATE_KEY_FILE_PATH);\n+        String trustCertCollectionFilePath = properties.getProperty(TRUST_CERTIFICATE_FILE_PATH);\n+\n+        if (trustCertCollectionFilePath != null) {\n+            builder.trustManager(new File(trustCertCollectionFilePath));\n+        }\n+        if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {\n+            builder.keyManager(new File(clientCertChainFilePath), new File(clientPrivateKeyFilePath));\n+        }\n+        return builder;\n+    }\n+\n+    private void initializeRpcStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            rpcStream = asyncStub.rpcStreaming(new RpcMessageHandler());\n+            // Need to send minion headers to gRPC server in order to register.\n+            sendMinionHeaders();\n+            LOG.info(\"Initialized RPC stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+    private void initializeSinkStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            sinkStream = asyncStub.sinkStreaming(new EmptyMessageReceiver());\n+            LOG.info(\"Initialized Sink stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void bind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            if (registerdModules.containsKey(rpcModule.getId())) {\n+                LOG.warn(\" {} module is already registered\", rpcModule.getId());\n+            } else {\n+                registerdModules.put(rpcModule.getId(), rpcModule);\n+                LOG.info(\"Registered module {} with gRPC IPC client\", rpcModule.getId());\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void unbind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            registerdModules.remove(rpcModule.getId());\n+            LOG.info(\"Removing module {} from gRPC IPC client.\", rpcModule.getId());\n+        }\n+    }\n+\n+    private boolean hasChangedToReadyState() {\n+        ConnectivityState prevState = currentChannelState;\n+        return !prevState.equals(ConnectivityState.READY) && getChannelState().equals(ConnectivityState.READY);\n+    }\n+\n+    public void shutdown() {\n+        requestHandlerExecutor.shutdownNow();\n+        blockingSinkMessageScheduler.shutdownNow();\n+        registerdModules.clear();\n+        if (rpcStream != null) {\n+            rpcStream.onCompleted();\n+        }\n+        channel.shutdown();\n+        LOG.info(\"Minion at location {} with systemId {} stopped\", minionIdentity.getLocation(), minionIdentity.getId());\n+    }\n+\n+    public void setBundleContext(BundleContext bundleContext) {\n+        this.bundleContext = bundleContext;\n+    }\n+\n+\n+    @Override\n+    public String getMetricDomain() {\n+        return SINK_METRIC_PRODUCER_DOMAIN;\n+    }\n+\n+    @Override\n+    public BundleContext getBundleContext() {\n+        return bundleContext;\n+    }\n+\n+    @Override\n+    public Tracer getTracer() {\n+        if (tracerRegistry != null) {\n+            return tracerRegistry.getTracer();\n+        }\n+        return GlobalTracer.get();\n+    }\n+\n+    @Override\n+    public MetricRegistry getMetrics() {\n+        if (metrics == null) {\n+            return new MetricRegistry();\n+        }\n+        return metrics;\n+    }\n+\n+    public void setMetrics(MetricRegistry metrics) {\n+        this.metrics = metrics;\n+    }\n+\n+    public TracerRegistry getTracerRegistry() {\n+        return tracerRegistry;\n+    }\n+\n+    public void setTracerRegistry(TracerRegistry tracerRegistry) {\n+        this.tracerRegistry = tracerRegistry;\n+    }\n+\n+    ConnectivityState getChannelState() {\n+        return currentChannelState = channel.getState(true);\n+    }\n+\n+\n+    @Override\n+    public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String metadata, T message) {\n+\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) {\n+            byte[] sinkMessageContent = module.marshal(message);\n+            String messageId = UUID.randomUUID().toString();\n+            SinkMessage.Builder sinkMessageBuilder = SinkMessage.newBuilder()\n+                    .setMessageId(messageId)\n+                    .setLocation(minionIdentity.getLocation())\n+                    .setModuleId(module.getId())\n+                    .setContent(ByteString.copyFrom(sinkMessageContent));\n+\n+            if (module.getId().equals(HEARTBEAT_MODULE_ID)) {\n+                if (rpcStream == null || sinkStream == null || hasChangedToReadyState()) {\n+                    initializeSinkStub();\n+                    initializeRpcStub();\n+                }\n+            }\n+            setTagsForSink(sinkMessageBuilder);\n+            // If module has asyncpolicy, keep attempting to send message.\n+            if (module.getAsyncPolicy() != null) {\n+                sendBlockingSinkMessage(sinkMessageBuilder.build());\n+            } else {\n+                sendSinkMessage(sinkMessageBuilder.build());\n+            }\n+        }\n+    }\n+\n+    private void sendBlockingSinkMessage(SinkMessage sinkMessage) {\n+        boolean succeeded = sendSinkMessage(sinkMessage);\n+        if (succeeded) {\n+            return;\n+        }\n+        //Recursively try to send sink message until it succeeds.\n+        scheduleSinkMessageAfterDelay(sinkMessage);\n+    }\n+\n+    private boolean scheduleSinkMessageAfterDelay(SinkMessage sinkMessage) {\n+        ScheduledFuture<Boolean> future = blockingSinkMessageScheduler.schedule(\n+                () -> sendSinkMessage(sinkMessage), SINK_BLOCKING_TIMEOUT, TimeUnit.MILLISECONDS);\n+        try {\n+            boolean succeeded = future.get();\n+            if (succeeded) {\n+                return true;\n+            }\n+        } catch (InterruptedException | ExecutionException e) {\n+            LOG.error(\"Error while attempting to send sink message to gRPC IPC server\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 342}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODUzMDgzOnYy", "diffSide": "RIGHT", "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDoxMDoyMFrOFlh3eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDoxMDoyMFrOFlh3eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NjUwNQ==", "bodyText": "I think we should add a trace or debug level message here.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374896505", "createdAt": "2020-02-04T20:10:20Z", "author": {"login": "j-white"}, "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinionGrpcClient.class);\n+    private static final long SINK_BLOCKING_TIMEOUT = 3000;\n+    private static final int SINK_BLOCKING_THREAD_POOL_SIZE = 100;\n+    private ManagedChannel channel;\n+    private OpenNMSIpcGrpc.OpenNMSIpcStub asyncStub;\n+    private Properties properties;\n+    private BundleContext bundleContext;\n+    private MinionIdentity minionIdentity;\n+    private ConfigurationAdmin configAdmin;\n+    private StreamObserver<RpcResponseProto> rpcStream;\n+    private StreamObserver<SinkMessage> sinkStream;\n+    private ConnectivityState currentChannelState;\n+    private MetricRegistry metrics;\n+    private TracerRegistry tracerRegistry;\n+    private final ThreadFactory requestHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-request-handler-%d\")\n+            .build();\n+    private final ThreadFactory blockingSinkMessageThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"blocking-sink-message-%d\")\n+            .build();\n+    private final ExecutorService requestHandlerExecutor = Executors.newCachedThreadPool(requestHandlerThreadFactory);\n+    private final Map<String, RpcModule<RpcRequest, RpcResponse>> registerdModules = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService blockingSinkMessageScheduler = Executors.newScheduledThreadPool(SINK_BLOCKING_THREAD_POOL_SIZE,\n+            blockingSinkMessageThreadFactory);\n+\n+\n+    public MinionGrpcClient(MinionIdentity identity, ConfigurationAdmin configAdmin) {\n+        this.minionIdentity = identity;\n+        this.configAdmin = configAdmin;\n+    }\n+\n+\n+    public void start() throws IOException {\n+        properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_CLIENT_PID);\n+        String host = PropertiesUtils.getProperty(properties, GRPC_HOST, DEFAULT_GRPC_HOST);\n+        int port = PropertiesUtils.getProperty(properties, GRPC_PORT, DEFAULT_GRPC_PORT);\n+        boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+        int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+\n+        NettyChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(host, port)\n+                .keepAliveWithoutCalls(true)\n+                .maxInboundMessageSize(maxInboundMessageSize);\n+\n+        if (tlsEnabled) {\n+            channel = channelBuilder\n+                    .negotiationType(NegotiationType.TLS)\n+                    .sslContext(buildSslContext().build())\n+                    .build();\n+            LOG.info(\"TLS enabled for gRPC\");\n+        } else {\n+            channel = channelBuilder.usePlaintext().build();\n+        }\n+\n+        asyncStub = OpenNMSIpcGrpc.newStub(channel);\n+        initializeRpcStub();\n+        initializeSinkStub();\n+        if (tracerRegistry != null) {\n+            tracerRegistry.init(minionIdentity.getLocation() + \"@\" + minionIdentity.getId());\n+        }\n+        LOG.info(\"Minion at location {} with systemId {} started\", minionIdentity.getLocation(), minionIdentity.getId());\n+\n+    }\n+\n+    private SslContextBuilder buildSslContext() throws SSLException {\n+        SslContextBuilder builder = GrpcSslContexts.forClient();\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        String clientPrivateKeyFilePath = properties.getProperty(CLIENT_PRIVATE_KEY_FILE_PATH);\n+        String trustCertCollectionFilePath = properties.getProperty(TRUST_CERTIFICATE_FILE_PATH);\n+\n+        if (trustCertCollectionFilePath != null) {\n+            builder.trustManager(new File(trustCertCollectionFilePath));\n+        }\n+        if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {\n+            builder.keyManager(new File(clientCertChainFilePath), new File(clientPrivateKeyFilePath));\n+        }\n+        return builder;\n+    }\n+\n+    private void initializeRpcStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            rpcStream = asyncStub.rpcStreaming(new RpcMessageHandler());\n+            // Need to send minion headers to gRPC server in order to register.\n+            sendMinionHeaders();\n+            LOG.info(\"Initialized RPC stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+    private void initializeSinkStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            sinkStream = asyncStub.sinkStreaming(new EmptyMessageReceiver());\n+            LOG.info(\"Initialized Sink stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void bind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            if (registerdModules.containsKey(rpcModule.getId())) {\n+                LOG.warn(\" {} module is already registered\", rpcModule.getId());\n+            } else {\n+                registerdModules.put(rpcModule.getId(), rpcModule);\n+                LOG.info(\"Registered module {} with gRPC IPC client\", rpcModule.getId());\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void unbind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            registerdModules.remove(rpcModule.getId());\n+            LOG.info(\"Removing module {} from gRPC IPC client.\", rpcModule.getId());\n+        }\n+    }\n+\n+    private boolean hasChangedToReadyState() {\n+        ConnectivityState prevState = currentChannelState;\n+        return !prevState.equals(ConnectivityState.READY) && getChannelState().equals(ConnectivityState.READY);\n+    }\n+\n+    public void shutdown() {\n+        requestHandlerExecutor.shutdownNow();\n+        blockingSinkMessageScheduler.shutdownNow();\n+        registerdModules.clear();\n+        if (rpcStream != null) {\n+            rpcStream.onCompleted();\n+        }\n+        channel.shutdown();\n+        LOG.info(\"Minion at location {} with systemId {} stopped\", minionIdentity.getLocation(), minionIdentity.getId());\n+    }\n+\n+    public void setBundleContext(BundleContext bundleContext) {\n+        this.bundleContext = bundleContext;\n+    }\n+\n+\n+    @Override\n+    public String getMetricDomain() {\n+        return SINK_METRIC_PRODUCER_DOMAIN;\n+    }\n+\n+    @Override\n+    public BundleContext getBundleContext() {\n+        return bundleContext;\n+    }\n+\n+    @Override\n+    public Tracer getTracer() {\n+        if (tracerRegistry != null) {\n+            return tracerRegistry.getTracer();\n+        }\n+        return GlobalTracer.get();\n+    }\n+\n+    @Override\n+    public MetricRegistry getMetrics() {\n+        if (metrics == null) {\n+            return new MetricRegistry();\n+        }\n+        return metrics;\n+    }\n+\n+    public void setMetrics(MetricRegistry metrics) {\n+        this.metrics = metrics;\n+    }\n+\n+    public TracerRegistry getTracerRegistry() {\n+        return tracerRegistry;\n+    }\n+\n+    public void setTracerRegistry(TracerRegistry tracerRegistry) {\n+        this.tracerRegistry = tracerRegistry;\n+    }\n+\n+    ConnectivityState getChannelState() {\n+        return currentChannelState = channel.getState(true);\n+    }\n+\n+\n+    @Override\n+    public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String metadata, T message) {\n+\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) {\n+            byte[] sinkMessageContent = module.marshal(message);\n+            String messageId = UUID.randomUUID().toString();\n+            SinkMessage.Builder sinkMessageBuilder = SinkMessage.newBuilder()\n+                    .setMessageId(messageId)\n+                    .setLocation(minionIdentity.getLocation())\n+                    .setModuleId(module.getId())\n+                    .setContent(ByteString.copyFrom(sinkMessageContent));\n+\n+            if (module.getId().equals(HEARTBEAT_MODULE_ID)) {\n+                if (rpcStream == null || sinkStream == null || hasChangedToReadyState()) {\n+                    initializeSinkStub();\n+                    initializeRpcStub();\n+                }\n+            }\n+            setTagsForSink(sinkMessageBuilder);\n+            // If module has asyncpolicy, keep attempting to send message.\n+            if (module.getAsyncPolicy() != null) {\n+                sendBlockingSinkMessage(sinkMessageBuilder.build());\n+            } else {\n+                sendSinkMessage(sinkMessageBuilder.build());\n+            }\n+        }\n+    }\n+\n+    private void sendBlockingSinkMessage(SinkMessage sinkMessage) {\n+        boolean succeeded = sendSinkMessage(sinkMessage);\n+        if (succeeded) {\n+            return;\n+        }\n+        //Recursively try to send sink message until it succeeds.\n+        scheduleSinkMessageAfterDelay(sinkMessage);\n+    }\n+\n+    private boolean scheduleSinkMessageAfterDelay(SinkMessage sinkMessage) {\n+        ScheduledFuture<Boolean> future = blockingSinkMessageScheduler.schedule(\n+                () -> sendSinkMessage(sinkMessage), SINK_BLOCKING_TIMEOUT, TimeUnit.MILLISECONDS);\n+        try {\n+            boolean succeeded = future.get();\n+            if (succeeded) {\n+                return true;\n+            }\n+        } catch (InterruptedException | ExecutionException e) {\n+            LOG.error(\"Error while attempting to send sink message to gRPC IPC server\", e);\n+        }\n+        return scheduleSinkMessageAfterDelay(sinkMessage);\n+    }\n+\n+\n+    private synchronized boolean sendSinkMessage(SinkMessage sinkMessage) {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            if (sinkStream != null) {\n+                try {\n+                    sinkStream.onNext(sinkMessage);\n+                    return true;\n+                } catch (Throwable e) {\n+                    LOG.error(\"Exception while sending sinkMessage to gRPC IPC server\", e);\n+                }\n+            }\n+        } else {\n+            LOG.info(\"gRPC IPC server is not in ready state\");\n+        }\n+        return false;\n+    }\n+\n+\n+    private void sendMinionHeaders() {\n+        RpcResponseProto rpcHeader = RpcResponseProto.newBuilder()\n+                .setLocation(minionIdentity.getLocation())\n+                .setSystemId(minionIdentity.getId())\n+                .setModuleId(MINION_HEADERS_MODULE)\n+                .setRpcId(minionIdentity.getId())\n+                .build();\n+        sendRpcResponse(rpcHeader);\n+        LOG.info(\"Sending Minion Headers from SystemId {} to gRPC server\", minionIdentity.getId());\n+    }\n+\n+    private void processRpcRequest(RpcRequestProto requestProto) {\n+        long currentTime = requestProto.getExpirationTime();\n+        if (requestProto.getExpirationTime() < currentTime) {\n+            return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 379}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODUzNDI0OnYy", "diffSide": "RIGHT", "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDoxMTozMFrOFlh5iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDoxMTozMFrOFlh5iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NzAzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            minionSpan.setTag(TAG_RPC_FAILED, \"true\");\n          \n          \n            \n                            minionSpan.setTag(TAG_RPC_FAILED, Boolean.TRUE.toString());", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374897033", "createdAt": "2020-02-04T20:11:30Z", "author": {"login": "j-white"}, "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinionGrpcClient.class);\n+    private static final long SINK_BLOCKING_TIMEOUT = 3000;\n+    private static final int SINK_BLOCKING_THREAD_POOL_SIZE = 100;\n+    private ManagedChannel channel;\n+    private OpenNMSIpcGrpc.OpenNMSIpcStub asyncStub;\n+    private Properties properties;\n+    private BundleContext bundleContext;\n+    private MinionIdentity minionIdentity;\n+    private ConfigurationAdmin configAdmin;\n+    private StreamObserver<RpcResponseProto> rpcStream;\n+    private StreamObserver<SinkMessage> sinkStream;\n+    private ConnectivityState currentChannelState;\n+    private MetricRegistry metrics;\n+    private TracerRegistry tracerRegistry;\n+    private final ThreadFactory requestHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-request-handler-%d\")\n+            .build();\n+    private final ThreadFactory blockingSinkMessageThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"blocking-sink-message-%d\")\n+            .build();\n+    private final ExecutorService requestHandlerExecutor = Executors.newCachedThreadPool(requestHandlerThreadFactory);\n+    private final Map<String, RpcModule<RpcRequest, RpcResponse>> registerdModules = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService blockingSinkMessageScheduler = Executors.newScheduledThreadPool(SINK_BLOCKING_THREAD_POOL_SIZE,\n+            blockingSinkMessageThreadFactory);\n+\n+\n+    public MinionGrpcClient(MinionIdentity identity, ConfigurationAdmin configAdmin) {\n+        this.minionIdentity = identity;\n+        this.configAdmin = configAdmin;\n+    }\n+\n+\n+    public void start() throws IOException {\n+        properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_CLIENT_PID);\n+        String host = PropertiesUtils.getProperty(properties, GRPC_HOST, DEFAULT_GRPC_HOST);\n+        int port = PropertiesUtils.getProperty(properties, GRPC_PORT, DEFAULT_GRPC_PORT);\n+        boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+        int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+\n+        NettyChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(host, port)\n+                .keepAliveWithoutCalls(true)\n+                .maxInboundMessageSize(maxInboundMessageSize);\n+\n+        if (tlsEnabled) {\n+            channel = channelBuilder\n+                    .negotiationType(NegotiationType.TLS)\n+                    .sslContext(buildSslContext().build())\n+                    .build();\n+            LOG.info(\"TLS enabled for gRPC\");\n+        } else {\n+            channel = channelBuilder.usePlaintext().build();\n+        }\n+\n+        asyncStub = OpenNMSIpcGrpc.newStub(channel);\n+        initializeRpcStub();\n+        initializeSinkStub();\n+        if (tracerRegistry != null) {\n+            tracerRegistry.init(minionIdentity.getLocation() + \"@\" + minionIdentity.getId());\n+        }\n+        LOG.info(\"Minion at location {} with systemId {} started\", minionIdentity.getLocation(), minionIdentity.getId());\n+\n+    }\n+\n+    private SslContextBuilder buildSslContext() throws SSLException {\n+        SslContextBuilder builder = GrpcSslContexts.forClient();\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        String clientPrivateKeyFilePath = properties.getProperty(CLIENT_PRIVATE_KEY_FILE_PATH);\n+        String trustCertCollectionFilePath = properties.getProperty(TRUST_CERTIFICATE_FILE_PATH);\n+\n+        if (trustCertCollectionFilePath != null) {\n+            builder.trustManager(new File(trustCertCollectionFilePath));\n+        }\n+        if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {\n+            builder.keyManager(new File(clientCertChainFilePath), new File(clientPrivateKeyFilePath));\n+        }\n+        return builder;\n+    }\n+\n+    private void initializeRpcStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            rpcStream = asyncStub.rpcStreaming(new RpcMessageHandler());\n+            // Need to send minion headers to gRPC server in order to register.\n+            sendMinionHeaders();\n+            LOG.info(\"Initialized RPC stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+    private void initializeSinkStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            sinkStream = asyncStub.sinkStreaming(new EmptyMessageReceiver());\n+            LOG.info(\"Initialized Sink stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void bind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            if (registerdModules.containsKey(rpcModule.getId())) {\n+                LOG.warn(\" {} module is already registered\", rpcModule.getId());\n+            } else {\n+                registerdModules.put(rpcModule.getId(), rpcModule);\n+                LOG.info(\"Registered module {} with gRPC IPC client\", rpcModule.getId());\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void unbind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            registerdModules.remove(rpcModule.getId());\n+            LOG.info(\"Removing module {} from gRPC IPC client.\", rpcModule.getId());\n+        }\n+    }\n+\n+    private boolean hasChangedToReadyState() {\n+        ConnectivityState prevState = currentChannelState;\n+        return !prevState.equals(ConnectivityState.READY) && getChannelState().equals(ConnectivityState.READY);\n+    }\n+\n+    public void shutdown() {\n+        requestHandlerExecutor.shutdownNow();\n+        blockingSinkMessageScheduler.shutdownNow();\n+        registerdModules.clear();\n+        if (rpcStream != null) {\n+            rpcStream.onCompleted();\n+        }\n+        channel.shutdown();\n+        LOG.info(\"Minion at location {} with systemId {} stopped\", minionIdentity.getLocation(), minionIdentity.getId());\n+    }\n+\n+    public void setBundleContext(BundleContext bundleContext) {\n+        this.bundleContext = bundleContext;\n+    }\n+\n+\n+    @Override\n+    public String getMetricDomain() {\n+        return SINK_METRIC_PRODUCER_DOMAIN;\n+    }\n+\n+    @Override\n+    public BundleContext getBundleContext() {\n+        return bundleContext;\n+    }\n+\n+    @Override\n+    public Tracer getTracer() {\n+        if (tracerRegistry != null) {\n+            return tracerRegistry.getTracer();\n+        }\n+        return GlobalTracer.get();\n+    }\n+\n+    @Override\n+    public MetricRegistry getMetrics() {\n+        if (metrics == null) {\n+            return new MetricRegistry();\n+        }\n+        return metrics;\n+    }\n+\n+    public void setMetrics(MetricRegistry metrics) {\n+        this.metrics = metrics;\n+    }\n+\n+    public TracerRegistry getTracerRegistry() {\n+        return tracerRegistry;\n+    }\n+\n+    public void setTracerRegistry(TracerRegistry tracerRegistry) {\n+        this.tracerRegistry = tracerRegistry;\n+    }\n+\n+    ConnectivityState getChannelState() {\n+        return currentChannelState = channel.getState(true);\n+    }\n+\n+\n+    @Override\n+    public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String metadata, T message) {\n+\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) {\n+            byte[] sinkMessageContent = module.marshal(message);\n+            String messageId = UUID.randomUUID().toString();\n+            SinkMessage.Builder sinkMessageBuilder = SinkMessage.newBuilder()\n+                    .setMessageId(messageId)\n+                    .setLocation(minionIdentity.getLocation())\n+                    .setModuleId(module.getId())\n+                    .setContent(ByteString.copyFrom(sinkMessageContent));\n+\n+            if (module.getId().equals(HEARTBEAT_MODULE_ID)) {\n+                if (rpcStream == null || sinkStream == null || hasChangedToReadyState()) {\n+                    initializeSinkStub();\n+                    initializeRpcStub();\n+                }\n+            }\n+            setTagsForSink(sinkMessageBuilder);\n+            // If module has asyncpolicy, keep attempting to send message.\n+            if (module.getAsyncPolicy() != null) {\n+                sendBlockingSinkMessage(sinkMessageBuilder.build());\n+            } else {\n+                sendSinkMessage(sinkMessageBuilder.build());\n+            }\n+        }\n+    }\n+\n+    private void sendBlockingSinkMessage(SinkMessage sinkMessage) {\n+        boolean succeeded = sendSinkMessage(sinkMessage);\n+        if (succeeded) {\n+            return;\n+        }\n+        //Recursively try to send sink message until it succeeds.\n+        scheduleSinkMessageAfterDelay(sinkMessage);\n+    }\n+\n+    private boolean scheduleSinkMessageAfterDelay(SinkMessage sinkMessage) {\n+        ScheduledFuture<Boolean> future = blockingSinkMessageScheduler.schedule(\n+                () -> sendSinkMessage(sinkMessage), SINK_BLOCKING_TIMEOUT, TimeUnit.MILLISECONDS);\n+        try {\n+            boolean succeeded = future.get();\n+            if (succeeded) {\n+                return true;\n+            }\n+        } catch (InterruptedException | ExecutionException e) {\n+            LOG.error(\"Error while attempting to send sink message to gRPC IPC server\", e);\n+        }\n+        return scheduleSinkMessageAfterDelay(sinkMessage);\n+    }\n+\n+\n+    private synchronized boolean sendSinkMessage(SinkMessage sinkMessage) {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            if (sinkStream != null) {\n+                try {\n+                    sinkStream.onNext(sinkMessage);\n+                    return true;\n+                } catch (Throwable e) {\n+                    LOG.error(\"Exception while sending sinkMessage to gRPC IPC server\", e);\n+                }\n+            }\n+        } else {\n+            LOG.info(\"gRPC IPC server is not in ready state\");\n+        }\n+        return false;\n+    }\n+\n+\n+    private void sendMinionHeaders() {\n+        RpcResponseProto rpcHeader = RpcResponseProto.newBuilder()\n+                .setLocation(minionIdentity.getLocation())\n+                .setSystemId(minionIdentity.getId())\n+                .setModuleId(MINION_HEADERS_MODULE)\n+                .setRpcId(minionIdentity.getId())\n+                .build();\n+        sendRpcResponse(rpcHeader);\n+        LOG.info(\"Sending Minion Headers from SystemId {} to gRPC server\", minionIdentity.getId());\n+    }\n+\n+    private void processRpcRequest(RpcRequestProto requestProto) {\n+        long currentTime = requestProto.getExpirationTime();\n+        if (requestProto.getExpirationTime() < currentTime) {\n+            return;\n+        }\n+        String moduleId = requestProto.getModuleId();\n+        if (Strings.isNullOrEmpty(moduleId)) {\n+            return;\n+        }\n+        LOG.debug(\"Received RPC request with RpcID:{} for module {}\", requestProto.getRpcId(), requestProto.getModuleId());\n+        RpcModule<RpcRequest, RpcResponse> rpcModule = registerdModules.get(moduleId);\n+        if (rpcModule == null) {\n+            return;\n+        }\n+        //Build child span from rpcMessage and start minion span.\n+        Tracer.SpanBuilder spanBuilder = buildSpanFromRpcMessage(requestProto);\n+        Span minionSpan = spanBuilder.start();\n+        setTagsForRpc(requestProto, minionSpan);\n+\n+        RpcRequest rpcRequest = rpcModule.unmarshalRequest(requestProto.getRpcContent().toStringUtf8());\n+        CompletableFuture<RpcResponse> future = rpcModule.execute(rpcRequest);\n+        future.whenComplete((res, ex) -> {\n+            final RpcResponse rpcResponse;\n+            if (ex != null) {\n+                // An exception occurred, store the exception in a new response\n+                LOG.warn(\"An error occured while executing a call in {}.\", rpcModule.getId(), ex);\n+                rpcResponse = rpcModule.createResponseWithException(ex);\n+                minionSpan.log(ex.getMessage());\n+                minionSpan.setTag(TAG_RPC_FAILED, \"true\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 404}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODUzNzc4OnYy", "diffSide": "RIGHT", "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDoxMjo0N1rOFlh73A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDoxMjo0N1rOFlh73A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NzYyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .setRpcContent(ByteString.copyFrom(responseAsString.getBytes()))\n          \n          \n            \n                                .setRpcContent(ByteString.copyFrom(responseAsString, StandardCharsets.UTF_8))\n          \n      \n    \n    \n  \n\navoid copying bytes twice.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374897628", "createdAt": "2020-02-04T20:12:47Z", "author": {"login": "j-white"}, "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinionGrpcClient.class);\n+    private static final long SINK_BLOCKING_TIMEOUT = 3000;\n+    private static final int SINK_BLOCKING_THREAD_POOL_SIZE = 100;\n+    private ManagedChannel channel;\n+    private OpenNMSIpcGrpc.OpenNMSIpcStub asyncStub;\n+    private Properties properties;\n+    private BundleContext bundleContext;\n+    private MinionIdentity minionIdentity;\n+    private ConfigurationAdmin configAdmin;\n+    private StreamObserver<RpcResponseProto> rpcStream;\n+    private StreamObserver<SinkMessage> sinkStream;\n+    private ConnectivityState currentChannelState;\n+    private MetricRegistry metrics;\n+    private TracerRegistry tracerRegistry;\n+    private final ThreadFactory requestHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-request-handler-%d\")\n+            .build();\n+    private final ThreadFactory blockingSinkMessageThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"blocking-sink-message-%d\")\n+            .build();\n+    private final ExecutorService requestHandlerExecutor = Executors.newCachedThreadPool(requestHandlerThreadFactory);\n+    private final Map<String, RpcModule<RpcRequest, RpcResponse>> registerdModules = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService blockingSinkMessageScheduler = Executors.newScheduledThreadPool(SINK_BLOCKING_THREAD_POOL_SIZE,\n+            blockingSinkMessageThreadFactory);\n+\n+\n+    public MinionGrpcClient(MinionIdentity identity, ConfigurationAdmin configAdmin) {\n+        this.minionIdentity = identity;\n+        this.configAdmin = configAdmin;\n+    }\n+\n+\n+    public void start() throws IOException {\n+        properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_CLIENT_PID);\n+        String host = PropertiesUtils.getProperty(properties, GRPC_HOST, DEFAULT_GRPC_HOST);\n+        int port = PropertiesUtils.getProperty(properties, GRPC_PORT, DEFAULT_GRPC_PORT);\n+        boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+        int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+\n+        NettyChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(host, port)\n+                .keepAliveWithoutCalls(true)\n+                .maxInboundMessageSize(maxInboundMessageSize);\n+\n+        if (tlsEnabled) {\n+            channel = channelBuilder\n+                    .negotiationType(NegotiationType.TLS)\n+                    .sslContext(buildSslContext().build())\n+                    .build();\n+            LOG.info(\"TLS enabled for gRPC\");\n+        } else {\n+            channel = channelBuilder.usePlaintext().build();\n+        }\n+\n+        asyncStub = OpenNMSIpcGrpc.newStub(channel);\n+        initializeRpcStub();\n+        initializeSinkStub();\n+        if (tracerRegistry != null) {\n+            tracerRegistry.init(minionIdentity.getLocation() + \"@\" + minionIdentity.getId());\n+        }\n+        LOG.info(\"Minion at location {} with systemId {} started\", minionIdentity.getLocation(), minionIdentity.getId());\n+\n+    }\n+\n+    private SslContextBuilder buildSslContext() throws SSLException {\n+        SslContextBuilder builder = GrpcSslContexts.forClient();\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        String clientPrivateKeyFilePath = properties.getProperty(CLIENT_PRIVATE_KEY_FILE_PATH);\n+        String trustCertCollectionFilePath = properties.getProperty(TRUST_CERTIFICATE_FILE_PATH);\n+\n+        if (trustCertCollectionFilePath != null) {\n+            builder.trustManager(new File(trustCertCollectionFilePath));\n+        }\n+        if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {\n+            builder.keyManager(new File(clientCertChainFilePath), new File(clientPrivateKeyFilePath));\n+        }\n+        return builder;\n+    }\n+\n+    private void initializeRpcStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            rpcStream = asyncStub.rpcStreaming(new RpcMessageHandler());\n+            // Need to send minion headers to gRPC server in order to register.\n+            sendMinionHeaders();\n+            LOG.info(\"Initialized RPC stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+    private void initializeSinkStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            sinkStream = asyncStub.sinkStreaming(new EmptyMessageReceiver());\n+            LOG.info(\"Initialized Sink stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void bind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            if (registerdModules.containsKey(rpcModule.getId())) {\n+                LOG.warn(\" {} module is already registered\", rpcModule.getId());\n+            } else {\n+                registerdModules.put(rpcModule.getId(), rpcModule);\n+                LOG.info(\"Registered module {} with gRPC IPC client\", rpcModule.getId());\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void unbind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            registerdModules.remove(rpcModule.getId());\n+            LOG.info(\"Removing module {} from gRPC IPC client.\", rpcModule.getId());\n+        }\n+    }\n+\n+    private boolean hasChangedToReadyState() {\n+        ConnectivityState prevState = currentChannelState;\n+        return !prevState.equals(ConnectivityState.READY) && getChannelState().equals(ConnectivityState.READY);\n+    }\n+\n+    public void shutdown() {\n+        requestHandlerExecutor.shutdownNow();\n+        blockingSinkMessageScheduler.shutdownNow();\n+        registerdModules.clear();\n+        if (rpcStream != null) {\n+            rpcStream.onCompleted();\n+        }\n+        channel.shutdown();\n+        LOG.info(\"Minion at location {} with systemId {} stopped\", minionIdentity.getLocation(), minionIdentity.getId());\n+    }\n+\n+    public void setBundleContext(BundleContext bundleContext) {\n+        this.bundleContext = bundleContext;\n+    }\n+\n+\n+    @Override\n+    public String getMetricDomain() {\n+        return SINK_METRIC_PRODUCER_DOMAIN;\n+    }\n+\n+    @Override\n+    public BundleContext getBundleContext() {\n+        return bundleContext;\n+    }\n+\n+    @Override\n+    public Tracer getTracer() {\n+        if (tracerRegistry != null) {\n+            return tracerRegistry.getTracer();\n+        }\n+        return GlobalTracer.get();\n+    }\n+\n+    @Override\n+    public MetricRegistry getMetrics() {\n+        if (metrics == null) {\n+            return new MetricRegistry();\n+        }\n+        return metrics;\n+    }\n+\n+    public void setMetrics(MetricRegistry metrics) {\n+        this.metrics = metrics;\n+    }\n+\n+    public TracerRegistry getTracerRegistry() {\n+        return tracerRegistry;\n+    }\n+\n+    public void setTracerRegistry(TracerRegistry tracerRegistry) {\n+        this.tracerRegistry = tracerRegistry;\n+    }\n+\n+    ConnectivityState getChannelState() {\n+        return currentChannelState = channel.getState(true);\n+    }\n+\n+\n+    @Override\n+    public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String metadata, T message) {\n+\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) {\n+            byte[] sinkMessageContent = module.marshal(message);\n+            String messageId = UUID.randomUUID().toString();\n+            SinkMessage.Builder sinkMessageBuilder = SinkMessage.newBuilder()\n+                    .setMessageId(messageId)\n+                    .setLocation(minionIdentity.getLocation())\n+                    .setModuleId(module.getId())\n+                    .setContent(ByteString.copyFrom(sinkMessageContent));\n+\n+            if (module.getId().equals(HEARTBEAT_MODULE_ID)) {\n+                if (rpcStream == null || sinkStream == null || hasChangedToReadyState()) {\n+                    initializeSinkStub();\n+                    initializeRpcStub();\n+                }\n+            }\n+            setTagsForSink(sinkMessageBuilder);\n+            // If module has asyncpolicy, keep attempting to send message.\n+            if (module.getAsyncPolicy() != null) {\n+                sendBlockingSinkMessage(sinkMessageBuilder.build());\n+            } else {\n+                sendSinkMessage(sinkMessageBuilder.build());\n+            }\n+        }\n+    }\n+\n+    private void sendBlockingSinkMessage(SinkMessage sinkMessage) {\n+        boolean succeeded = sendSinkMessage(sinkMessage);\n+        if (succeeded) {\n+            return;\n+        }\n+        //Recursively try to send sink message until it succeeds.\n+        scheduleSinkMessageAfterDelay(sinkMessage);\n+    }\n+\n+    private boolean scheduleSinkMessageAfterDelay(SinkMessage sinkMessage) {\n+        ScheduledFuture<Boolean> future = blockingSinkMessageScheduler.schedule(\n+                () -> sendSinkMessage(sinkMessage), SINK_BLOCKING_TIMEOUT, TimeUnit.MILLISECONDS);\n+        try {\n+            boolean succeeded = future.get();\n+            if (succeeded) {\n+                return true;\n+            }\n+        } catch (InterruptedException | ExecutionException e) {\n+            LOG.error(\"Error while attempting to send sink message to gRPC IPC server\", e);\n+        }\n+        return scheduleSinkMessageAfterDelay(sinkMessage);\n+    }\n+\n+\n+    private synchronized boolean sendSinkMessage(SinkMessage sinkMessage) {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            if (sinkStream != null) {\n+                try {\n+                    sinkStream.onNext(sinkMessage);\n+                    return true;\n+                } catch (Throwable e) {\n+                    LOG.error(\"Exception while sending sinkMessage to gRPC IPC server\", e);\n+                }\n+            }\n+        } else {\n+            LOG.info(\"gRPC IPC server is not in ready state\");\n+        }\n+        return false;\n+    }\n+\n+\n+    private void sendMinionHeaders() {\n+        RpcResponseProto rpcHeader = RpcResponseProto.newBuilder()\n+                .setLocation(minionIdentity.getLocation())\n+                .setSystemId(minionIdentity.getId())\n+                .setModuleId(MINION_HEADERS_MODULE)\n+                .setRpcId(minionIdentity.getId())\n+                .build();\n+        sendRpcResponse(rpcHeader);\n+        LOG.info(\"Sending Minion Headers from SystemId {} to gRPC server\", minionIdentity.getId());\n+    }\n+\n+    private void processRpcRequest(RpcRequestProto requestProto) {\n+        long currentTime = requestProto.getExpirationTime();\n+        if (requestProto.getExpirationTime() < currentTime) {\n+            return;\n+        }\n+        String moduleId = requestProto.getModuleId();\n+        if (Strings.isNullOrEmpty(moduleId)) {\n+            return;\n+        }\n+        LOG.debug(\"Received RPC request with RpcID:{} for module {}\", requestProto.getRpcId(), requestProto.getModuleId());\n+        RpcModule<RpcRequest, RpcResponse> rpcModule = registerdModules.get(moduleId);\n+        if (rpcModule == null) {\n+            return;\n+        }\n+        //Build child span from rpcMessage and start minion span.\n+        Tracer.SpanBuilder spanBuilder = buildSpanFromRpcMessage(requestProto);\n+        Span minionSpan = spanBuilder.start();\n+        setTagsForRpc(requestProto, minionSpan);\n+\n+        RpcRequest rpcRequest = rpcModule.unmarshalRequest(requestProto.getRpcContent().toStringUtf8());\n+        CompletableFuture<RpcResponse> future = rpcModule.execute(rpcRequest);\n+        future.whenComplete((res, ex) -> {\n+            final RpcResponse rpcResponse;\n+            if (ex != null) {\n+                // An exception occurred, store the exception in a new response\n+                LOG.warn(\"An error occured while executing a call in {}.\", rpcModule.getId(), ex);\n+                rpcResponse = rpcModule.createResponseWithException(ex);\n+                minionSpan.log(ex.getMessage());\n+                minionSpan.setTag(TAG_RPC_FAILED, \"true\");\n+            } else {\n+                // No exception occurred, use the given response\n+                rpcResponse = res;\n+            }\n+            minionSpan.finish();\n+            // Construct response using the same rpcId;\n+            String responseAsString = rpcModule.marshalResponse(rpcResponse);\n+            RpcResponseProto responseProto = RpcResponseProto.newBuilder()\n+                    .setRpcId(requestProto.getRpcId())\n+                    .setSystemId(minionIdentity.getId())\n+                    .setLocation(requestProto.getLocation())\n+                    .setModuleId(requestProto.getModuleId())\n+                    .setRpcContent(ByteString.copyFrom(responseAsString.getBytes()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 417}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODU0MDU1OnYy", "diffSide": "RIGHT", "path": "core/ipc/grpc/client/src/main/resources/OSGI-INF/blueprint/blueprint.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDoxMzozNVrOFlh9iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDoxMzozNVrOFlh9iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5ODA1Ng==", "bodyText": "gRpc vs grpc prefixes for bean names.\nSame in other blueprint too.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374898056", "createdAt": "2020-02-04T20:13:35Z", "author": {"login": "j-white"}, "path": "core/ipc/grpc/client/src/main/resources/OSGI-INF/blueprint/blueprint.xml", "diffHunk": "@@ -0,0 +1,64 @@\n+<blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n+           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+           xmlns:cm=\"http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.3.0\"\n+           xmlns:ext=\"http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.5.0\"\n+           xsi:schemaLocation=\"\n+\t\thttp://www.osgi.org/xmlns/blueprint/v1.0.0\n+\t\thttps://osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n+\t\thttp://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.3.0\n+\t\thttp://aries.apache.org/schemas/blueprint-cm/blueprint-cm-1.3.0.xsd\n+\t\thttp://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.5.0\n+\t\thttp://aries.apache.org/schemas/blueprint-ext/blueprint-ext-1.5.xsd\n+\t\thttp://camel.apache.org/schema/blueprint\n+\t\thttp://camel.apache.org/schema/blueprint/camel-blueprint-2.19.1.xsd\n+\">\n+\n+  <cm:property-placeholder id=\"serverProperties\" persistent-id=\"org.opennms.core.ipc.grpc.client\"\n+                           update-strategy=\"reload\">\n+    <cm:default-properties>\n+      <cm:property name=\"host\" value=\"localhost\"/>\n+      <cm:property name=\"port\" value=\"8990\"/>\n+      <cm:property name=\"tlsEnabled\" value=\"false\"/>\n+    </cm:default-properties>\n+  </cm:property-placeholder>\n+\n+  <reference id=\"configAdmin\" interface=\"org.osgi.service.cm.ConfigurationAdmin\"/>\n+\n+  <!-- Provided by minion-core -->\n+  <reference id=\"minionIdentity\" interface=\"org.opennms.distributed.core.api.MinionIdentity\"/>\n+\n+  <reference id=\"tracerRegistry\" interface=\"org.opennms.core.tracing.api.TracerRegistry\"/>\n+\n+  <bean id=\"grpcClient\" class=\"org.opennms.core.ipc.grpc.client.MinionGrpcClient\"\n+        init-method=\"start\" destroy-method=\"shutdown\">\n+    <argument ref=\"minionIdentity\"/>\n+    <argument ref=\"configAdmin\"/>\n+    <property name=\"metrics\" ref=\"gRpcSinkMetricRegistry\"/>\n+    <property name=\"tracerRegistry\" ref=\"tracerRegistry\"/>\n+  </bean>\n+\n+  <service ref=\"grpcClient\" interface=\"org.opennms.core.ipc.sink.api.MessageDispatcherFactory\"/>\n+\n+  <reference-list id=\"rpcModulesRef\" interface=\"org.opennms.core.rpc.api.RpcModule\" availability=\"optional\">\n+    <reference-listener bind-method=\"bind\" unbind-method=\"unbind\" ref=\"grpcClient\"/>\n+  </reference-list>\n+\n+  <!-- GRPC Health Check -->\n+  <bean id=\"grpcHealthCheck\" class=\"org.opennms.core.ipc.grpc.client.GrpcHealthCheck\">\n+    <argument ref=\"grpcClient\"/>\n+  </bean>\n+\n+  <service ref=\"grpcHealthCheck\" interface=\"org.opennms.core.health.api.HealthCheck\"/>\n+\n+  <!-- Sink Metrics -->\n+  <bean id=\"gRpcSinkMetricRegistry\" class=\"com.codahale.metrics.MetricRegistry\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODU0MzA1OnYy", "diffSide": "RIGHT", "path": "core/ipc/grpc/server/src/main/java/org/opennms/core/ipc/grpc/server/OpennmsGrpcServer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDoxNDoyNlrOFlh_LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDoxNDoyNlrOFlh_LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5ODQ3Nw==", "bodyText": "Would also be nice to have some high level docs here.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374898477", "createdAt": "2020-02-04T20:14:26Z", "author": {"login": "j-white"}, "path": "core/ipc/grpc/server/src/main/java/org/opennms/core/ipc/grpc/server/OpennmsGrpcServer.java", "diffHunk": "@@ -0,0 +1,685 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.server;\n+\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.DEFAULT_GRPC_TTL;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_SERVER_PID;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_SERVER_PORT;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_TTL_PROPERTY;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.SERVER_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_CONSUMER_DOMAIN;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_TIMEOUT;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.DelayQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.Empty;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageConsumerManager;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RemoteExecutionException;\n+import org.opennms.core.rpc.api.RequestTimedOutException;\n+import org.opennms.core.rpc.api.RpcClient;\n+import org.opennms.core.rpc.api.RpcClientFactory;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.rpc.api.RpcResponseHandler;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.Identity;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.JmxReporter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.Timer;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.LinkedListMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.Server;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyServerBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.ClientAuth;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslProvider;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.References;\n+import io.opentracing.Scope;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class OpennmsGrpcServer extends AbstractMessageConsumerManager implements RpcClientFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODU0NjA1OnYy", "diffSide": "RIGHT", "path": "core/ipc/grpc/server/src/main/java/org/opennms/core/ipc/grpc/server/OpennmsGrpcServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDoxNTozM1rOFliBQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNjoxNTo0MVrOFmhJqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5OTAwOQ==", "bodyText": "How does this iterator behave when the underlying collection changes? Should we clear the entry from the map when new handlers get registered?", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374899009", "createdAt": "2020-02-04T20:15:33Z", "author": {"login": "j-white"}, "path": "core/ipc/grpc/server/src/main/java/org/opennms/core/ipc/grpc/server/OpennmsGrpcServer.java", "diffHunk": "@@ -0,0 +1,685 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.server;\n+\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.DEFAULT_GRPC_TTL;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_SERVER_PID;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_SERVER_PORT;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_TTL_PROPERTY;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.SERVER_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_CONSUMER_DOMAIN;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_TIMEOUT;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.DelayQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.Empty;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageConsumerManager;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RemoteExecutionException;\n+import org.opennms.core.rpc.api.RequestTimedOutException;\n+import org.opennms.core.rpc.api.RpcClient;\n+import org.opennms.core.rpc.api.RpcClientFactory;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.rpc.api.RpcResponseHandler;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.Identity;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.JmxReporter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.Timer;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.LinkedListMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.Server;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyServerBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.ClientAuth;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslProvider;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.References;\n+import io.opentracing.Scope;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class OpennmsGrpcServer extends AbstractMessageConsumerManager implements RpcClientFactory {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(OpennmsGrpcServer.class);\n+    private ConfigurationAdmin configAdmin;\n+    private Server server;\n+    private String location;\n+    private Identity identity;\n+    private Properties properties;\n+    private long ttl;\n+    private MetricRegistry rpcMetrics;\n+    private MetricRegistry sinkMetrics;\n+    private JmxReporter rpcMetricsReporter;\n+    private JmxReporter sinkMetricsReporter;\n+    private TracerRegistry tracerRegistry;\n+    private AtomicBoolean closed = new AtomicBoolean(false);\n+    private final ThreadFactory responseHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-response-handler-%d\")\n+            .build();\n+    private final ThreadFactory timerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-timeout-tracker-%d\")\n+            .build();\n+    private final ThreadFactory sinkConsumerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"sink-consumer-%d\")\n+            .build();\n+\n+    // RPC timeout executor thread retrieves elements from delay queue used to timeout rpc requests.\n+    private final ExecutorService rpcTimeoutExecutor = Executors.newSingleThreadExecutor(timerThreadFactory);\n+    // Each RPC response is handled on a new thread which does unmarshalling and returning response to corresponding module.\n+    private final ExecutorService responseHandlerExecutor = Executors.newCachedThreadPool(responseHandlerThreadFactory);\n+    // This map used to maintain all the requests that are sent with unique Id and all the context related to the request.\n+    private final Map<String, RpcResponseHandler> rpcResponseMap = new ConcurrentHashMap<>();\n+    // Delay queue maintains the priority queue of RPC requests and times out the requests if no response was received\n+    // within the delay specified.\n+    private DelayQueue<RpcResponseHandler> rpcTimeoutQueue = new DelayQueue<>();\n+    // Maintains map of minionId and rpc handler for that minion. Used for directed RPC requests.\n+    private Map<String, StreamObserver<RpcRequestProto>> rpcHandlerByMinionId = new HashMap<>();\n+    // Maintains multi element map of location and rpc handlers for that location.\n+    // Used to get one of the rpc handlers for a specific location.\n+    private Multimap<String, StreamObserver<RpcRequestProto>> rpcHandlerByLocation = LinkedListMultimap.create();\n+    // Maintains the state of iteration for the list of minions for a given location.\n+    private Map<Collection<StreamObserver<RpcRequestProto>>, Iterator<StreamObserver<RpcRequestProto>>> rpcHandlerIteratorMap = new HashMap<>();\n+    // Maintains the map of sink modules by it's id.\n+    private final Map<String, SinkModule<?, Message>> sinkModulesById = new ConcurrentHashMap<>();\n+    // Maintains the map of sink consumer executor and by module Id.\n+    private final Map<String, ExecutorService> sinkConsumersByModuleId = new ConcurrentHashMap<>();\n+\n+\n+    public void start() throws IOException {\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(RpcClientFactory.LOG_PREFIX)) {\n+            properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_SERVER_PID);\n+            int port = PropertiesUtils.getProperty(properties, GRPC_SERVER_PORT, DEFAULT_GRPC_PORT);\n+            int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+            ttl = PropertiesUtils.getProperty(properties, GRPC_TTL_PROPERTY, DEFAULT_GRPC_TTL);\n+            boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+\n+            NettyServerBuilder serverBuilder = NettyServerBuilder.forAddress(new InetSocketAddress(port))\n+                    .addService(new OpennmsIpcService())\n+                    .maxInboundMessageSize(maxInboundMessageSize);\n+            if (tlsEnabled) {\n+                SslContextBuilder sslContextBuilder = getSslContextBuilder();\n+                if (sslContextBuilder != null) {\n+                    serverBuilder.sslContext(sslContextBuilder.build());\n+                    LOG.info(\"TLS enabled for gRPC\");\n+                }\n+            }\n+            server = serverBuilder.build();\n+            rpcTimeoutExecutor.execute(this::handleRpcTimeouts);\n+            rpcMetricsReporter = JmxReporter.forRegistry(getRpcMetrics())\n+                    .inDomain(JMX_DOMAIN_RPC)\n+                    .build();\n+            rpcMetricsReporter.start();\n+            sinkMetricsReporter = JmxReporter.forRegistry(getRpcMetrics())\n+                    .inDomain(SINK_METRIC_CONSUMER_DOMAIN)\n+                    .build();\n+            sinkMetricsReporter.start();\n+            server.start();\n+            // Initialize tracer from tracer registry.\n+            if (tracerRegistry != null) {\n+                tracerRegistry.init(identity.getId());\n+            }\n+            LOG.info(\"OpenNMS gRPC server started\");\n+        }\n+    }\n+\n+\n+    private SslContextBuilder getSslContextBuilder() {\n+        String certChainFilePath = properties.getProperty(SERVER_CERTIFICATE_FILE_PATH);\n+        String privateKeyFilePath = properties.getProperty(PRIVATE_KEY_FILE_PATH);\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        if (Strings.isNullOrEmpty(certChainFilePath) || Strings.isNullOrEmpty(privateKeyFilePath)) {\n+            return null;\n+        }\n+\n+        SslContextBuilder sslClientContextBuilder = SslContextBuilder.forServer(new File(certChainFilePath),\n+                new File(privateKeyFilePath));\n+        if (!Strings.isNullOrEmpty(clientCertChainFilePath)) {\n+            sslClientContextBuilder.trustManager(new File(clientCertChainFilePath));\n+            sslClientContextBuilder.clientAuth(ClientAuth.REQUIRE);\n+        }\n+        return GrpcSslContexts.configure(sslClientContextBuilder,\n+                SslProvider.OPENSSL);\n+    }\n+\n+\n+    @Override\n+    protected void startConsumingForModule(SinkModule<?, Message> module) throws Exception {\n+        if (sinkConsumersByModuleId.get(module.getId()) == null) {\n+            int numOfThreads = getNumConsumerThreads(module);\n+            ExecutorService executor = Executors.newFixedThreadPool(numOfThreads, sinkConsumerThreadFactory);\n+            sinkConsumersByModuleId.put(module.getId(), executor);\n+            LOG.info(\"Adding {} consumers for module: {}\", numOfThreads, module.getId());\n+        }\n+        sinkModulesById.putIfAbsent(module.getId(), module);\n+    }\n+\n+    @Override\n+    protected void stopConsumingForModule(SinkModule<?, Message> module) throws Exception {\n+\n+        ExecutorService executor = sinkConsumersByModuleId.get(module.getId());\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+        LOG.info(\"Stopped consumers for module: {}\", module.getId());\n+        sinkModulesById.remove(module.getId());\n+    }\n+\n+    @Override\n+    public <S extends RpcRequest, T extends RpcResponse> RpcClient<S, T> getClient(RpcModule<S, T> module) {\n+\n+        return new RpcClient<S, T>() {\n+            @Override\n+            public CompletableFuture<T> execute(S request) {\n+                if (request.getLocation() == null || request.getLocation().equals(getLocation())) {\n+                    // The request is for the current location, invoke it directly\n+                    return module.execute(request);\n+                }\n+                final Map<String, String> loggingContext = Logging.getCopyOfContextMap();\n+\n+                Span span = getTracer().buildSpan(module.getId()).start();\n+                String marshalRequest = module.marshalRequest(request);\n+                String rpcId = UUID.randomUUID().toString();\n+                CompletableFuture<T> future = new CompletableFuture<T>();\n+                Long timeToLive = request.getTimeToLiveMs();\n+                timeToLive = (timeToLive != null && timeToLive > 0) ? timeToLive : ttl;\n+                long expirationTime = System.currentTimeMillis() + timeToLive;\n+                RpcResponseHandlerImpl responseHandler = new RpcResponseHandlerImpl<S, T>(future,\n+                        module, rpcId, request.getLocation(), expirationTime, span, loggingContext);\n+                rpcResponseMap.put(rpcId, responseHandler);\n+                rpcTimeoutQueue.offer(responseHandler);\n+                RpcRequestProto.Builder builder = RpcRequestProto.newBuilder()\n+                        .setRpcId(rpcId)\n+                        .setLocation(request.getLocation())\n+                        .setModuleId(module.getId())\n+                        .setRpcContent(ByteString.copyFrom(marshalRequest.getBytes()));\n+                if (!Strings.isNullOrEmpty(request.getSystemId())) {\n+                    builder.setSystemId(request.getSystemId());\n+                }\n+                addTracingInfo(request, span, builder);\n+                RpcRequestProto requestProto = builder.build();\n+\n+                boolean succeeded = sendRequest(requestProto);\n+\n+                addMetrics(request, requestProto.getSerializedSize());\n+                if (!succeeded) {\n+                    RpcClientFactory.markFailed(getRpcMetrics(), request.getLocation(), module.getId());\n+                    future.completeExceptionally(new RuntimeException(\"No minion found at location \" + request.getLocation()));\n+                    return future;\n+                }\n+                LOG.debug(\"RPC request from module: {} with RpcId:{} sent to minion at location {}\", module.getId(), rpcId, request.getLocation());\n+                return future;\n+            }\n+\n+            private void addMetrics(RpcRequest request, int messageLen) {\n+                RpcClientFactory.markRpcCount(getRpcMetrics(), request.getLocation(), module.getId());\n+                RpcClientFactory.updateRequestSize(getRpcMetrics(), request.getLocation(), module.getId(), messageLen);\n+            }\n+\n+            private void addTracingInfo(RpcRequest request, Span span, RpcRequestProto.Builder builder) {\n+                //Add tags to span.\n+                span.setTag(TAG_LOCATION, request.getLocation());\n+                if (request.getSystemId() != null) {\n+                    span.setTag(TAG_SYSTEM_ID, request.getSystemId());\n+                }\n+                request.getTracingInfo().forEach(span::setTag);\n+                TracingInfoCarrier tracingInfoCarrier = new TracingInfoCarrier();\n+                getTracer().inject(span.context(), Format.Builtin.TEXT_MAP, tracingInfoCarrier);\n+                // Tracer adds it's own metadata.\n+                tracingInfoCarrier.getTracingInfoMap().forEach(builder::putTracingInfo);\n+                //Add custom tags from RpcRequest.\n+                request.getTracingInfo().forEach(builder::putTracingInfo);\n+            }\n+        };\n+    }\n+\n+\n+    private void handleRpcTimeouts() {\n+        while (!closed.get()) {\n+            try {\n+                RpcResponseHandler responseHandler = rpcTimeoutQueue.take();\n+                if (!responseHandler.isProcessed()) {\n+                    LOG.warn(\"RPC request from module: {} with RpcId:{} timedout \", responseHandler.getRpcModule().getId(),\n+                            responseHandler.getRpcId());\n+                    responseHandlerExecutor.execute(() -> responseHandler.sendResponse(null));\n+                }\n+            } catch (InterruptedException e) {\n+                LOG.info(\"interrupted while waiting for an element from rpcTimeoutQueue\", e);\n+                Thread.currentThread().interrupt();\n+                break;\n+            } catch (Exception e) {\n+                LOG.warn(\"error while sending response from timeout handler\", e);\n+            }\n+        }\n+    }\n+\n+\n+    private void handleResponse(RpcResponseProto responseProto) {\n+\n+        if (Strings.isNullOrEmpty(responseProto.getRpcId())) {\n+            return;\n+        }\n+        // Handle response from the Minion.\n+        RpcResponseHandler responseHandler = rpcResponseMap.get(responseProto.getRpcId());\n+        if (responseHandler != null && responseProto.getRpcContent() != null) {\n+            responseHandler.sendResponse(responseProto.getRpcContent().toStringUtf8());\n+        } else {\n+            LOG.debug(\"Received a response for request for module: {} with RpcId:{}, but no outstanding request was found with this id.\" +\n+                    \"The request may have timed out\", responseProto.getModuleId(), responseProto.getRpcId());\n+        }\n+    }\n+\n+    private boolean sendRequest(RpcRequestProto requestProto) {\n+        StreamObserver<RpcRequestProto> rpcHandler = getRpcHandler(requestProto.getLocation(), requestProto.getSystemId());\n+        if (rpcHandler == null) {\n+            LOG.warn(\"No RPC handlers found for location {}\", requestProto.getLocation());\n+            return false;\n+        }\n+        try {\n+            sendRpcRequest(rpcHandler, requestProto);\n+            return true;\n+        } catch (Throwable e) {\n+            LOG.error(\"Encountered exception while sending request {}\", requestProto, e);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Writing message through stream observer is not thread safe.\n+     */\n+    private synchronized void sendRpcRequest(StreamObserver<RpcRequestProto> rpcHandler, RpcRequestProto rpcMessage) {\n+        rpcHandler.onNext(rpcMessage);\n+    }\n+\n+    private synchronized StreamObserver<RpcRequestProto> getRpcHandler(String location, String systemId) {\n+\n+        if (!Strings.isNullOrEmpty(systemId)) {\n+            return rpcHandlerByMinionId.get(systemId);\n+        }\n+        Collection<StreamObserver<RpcRequestProto>> streamObservers = rpcHandlerByLocation.get(location);\n+        if (streamObservers.isEmpty()) {\n+            return null;\n+        }\n+        Iterator<StreamObserver<RpcRequestProto>> iterator = rpcHandlerIteratorMap.get(streamObservers);\n+        if (iterator == null) {\n+            iterator = Iterables.cycle(streamObservers).iterator();\n+            rpcHandlerIteratorMap.put(streamObservers, iterator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 387}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkzMzM1Mw==", "bodyText": "Handled this differently with location as key and updating iterator in add/remove handler methods.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r375933353", "createdAt": "2020-02-06T16:15:41Z", "author": {"login": "cgorantla"}, "path": "core/ipc/grpc/server/src/main/java/org/opennms/core/ipc/grpc/server/OpennmsGrpcServer.java", "diffHunk": "@@ -0,0 +1,685 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.server;\n+\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.DEFAULT_GRPC_TTL;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_SERVER_PID;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_SERVER_PORT;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_TTL_PROPERTY;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.SERVER_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_CONSUMER_DOMAIN;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_TIMEOUT;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.DelayQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.Empty;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageConsumerManager;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RemoteExecutionException;\n+import org.opennms.core.rpc.api.RequestTimedOutException;\n+import org.opennms.core.rpc.api.RpcClient;\n+import org.opennms.core.rpc.api.RpcClientFactory;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.rpc.api.RpcResponseHandler;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.Identity;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.JmxReporter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.Timer;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.LinkedListMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.Server;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyServerBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.ClientAuth;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslProvider;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.References;\n+import io.opentracing.Scope;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class OpennmsGrpcServer extends AbstractMessageConsumerManager implements RpcClientFactory {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(OpennmsGrpcServer.class);\n+    private ConfigurationAdmin configAdmin;\n+    private Server server;\n+    private String location;\n+    private Identity identity;\n+    private Properties properties;\n+    private long ttl;\n+    private MetricRegistry rpcMetrics;\n+    private MetricRegistry sinkMetrics;\n+    private JmxReporter rpcMetricsReporter;\n+    private JmxReporter sinkMetricsReporter;\n+    private TracerRegistry tracerRegistry;\n+    private AtomicBoolean closed = new AtomicBoolean(false);\n+    private final ThreadFactory responseHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-response-handler-%d\")\n+            .build();\n+    private final ThreadFactory timerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-timeout-tracker-%d\")\n+            .build();\n+    private final ThreadFactory sinkConsumerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"sink-consumer-%d\")\n+            .build();\n+\n+    // RPC timeout executor thread retrieves elements from delay queue used to timeout rpc requests.\n+    private final ExecutorService rpcTimeoutExecutor = Executors.newSingleThreadExecutor(timerThreadFactory);\n+    // Each RPC response is handled on a new thread which does unmarshalling and returning response to corresponding module.\n+    private final ExecutorService responseHandlerExecutor = Executors.newCachedThreadPool(responseHandlerThreadFactory);\n+    // This map used to maintain all the requests that are sent with unique Id and all the context related to the request.\n+    private final Map<String, RpcResponseHandler> rpcResponseMap = new ConcurrentHashMap<>();\n+    // Delay queue maintains the priority queue of RPC requests and times out the requests if no response was received\n+    // within the delay specified.\n+    private DelayQueue<RpcResponseHandler> rpcTimeoutQueue = new DelayQueue<>();\n+    // Maintains map of minionId and rpc handler for that minion. Used for directed RPC requests.\n+    private Map<String, StreamObserver<RpcRequestProto>> rpcHandlerByMinionId = new HashMap<>();\n+    // Maintains multi element map of location and rpc handlers for that location.\n+    // Used to get one of the rpc handlers for a specific location.\n+    private Multimap<String, StreamObserver<RpcRequestProto>> rpcHandlerByLocation = LinkedListMultimap.create();\n+    // Maintains the state of iteration for the list of minions for a given location.\n+    private Map<Collection<StreamObserver<RpcRequestProto>>, Iterator<StreamObserver<RpcRequestProto>>> rpcHandlerIteratorMap = new HashMap<>();\n+    // Maintains the map of sink modules by it's id.\n+    private final Map<String, SinkModule<?, Message>> sinkModulesById = new ConcurrentHashMap<>();\n+    // Maintains the map of sink consumer executor and by module Id.\n+    private final Map<String, ExecutorService> sinkConsumersByModuleId = new ConcurrentHashMap<>();\n+\n+\n+    public void start() throws IOException {\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(RpcClientFactory.LOG_PREFIX)) {\n+            properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_SERVER_PID);\n+            int port = PropertiesUtils.getProperty(properties, GRPC_SERVER_PORT, DEFAULT_GRPC_PORT);\n+            int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+            ttl = PropertiesUtils.getProperty(properties, GRPC_TTL_PROPERTY, DEFAULT_GRPC_TTL);\n+            boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+\n+            NettyServerBuilder serverBuilder = NettyServerBuilder.forAddress(new InetSocketAddress(port))\n+                    .addService(new OpennmsIpcService())\n+                    .maxInboundMessageSize(maxInboundMessageSize);\n+            if (tlsEnabled) {\n+                SslContextBuilder sslContextBuilder = getSslContextBuilder();\n+                if (sslContextBuilder != null) {\n+                    serverBuilder.sslContext(sslContextBuilder.build());\n+                    LOG.info(\"TLS enabled for gRPC\");\n+                }\n+            }\n+            server = serverBuilder.build();\n+            rpcTimeoutExecutor.execute(this::handleRpcTimeouts);\n+            rpcMetricsReporter = JmxReporter.forRegistry(getRpcMetrics())\n+                    .inDomain(JMX_DOMAIN_RPC)\n+                    .build();\n+            rpcMetricsReporter.start();\n+            sinkMetricsReporter = JmxReporter.forRegistry(getRpcMetrics())\n+                    .inDomain(SINK_METRIC_CONSUMER_DOMAIN)\n+                    .build();\n+            sinkMetricsReporter.start();\n+            server.start();\n+            // Initialize tracer from tracer registry.\n+            if (tracerRegistry != null) {\n+                tracerRegistry.init(identity.getId());\n+            }\n+            LOG.info(\"OpenNMS gRPC server started\");\n+        }\n+    }\n+\n+\n+    private SslContextBuilder getSslContextBuilder() {\n+        String certChainFilePath = properties.getProperty(SERVER_CERTIFICATE_FILE_PATH);\n+        String privateKeyFilePath = properties.getProperty(PRIVATE_KEY_FILE_PATH);\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        if (Strings.isNullOrEmpty(certChainFilePath) || Strings.isNullOrEmpty(privateKeyFilePath)) {\n+            return null;\n+        }\n+\n+        SslContextBuilder sslClientContextBuilder = SslContextBuilder.forServer(new File(certChainFilePath),\n+                new File(privateKeyFilePath));\n+        if (!Strings.isNullOrEmpty(clientCertChainFilePath)) {\n+            sslClientContextBuilder.trustManager(new File(clientCertChainFilePath));\n+            sslClientContextBuilder.clientAuth(ClientAuth.REQUIRE);\n+        }\n+        return GrpcSslContexts.configure(sslClientContextBuilder,\n+                SslProvider.OPENSSL);\n+    }\n+\n+\n+    @Override\n+    protected void startConsumingForModule(SinkModule<?, Message> module) throws Exception {\n+        if (sinkConsumersByModuleId.get(module.getId()) == null) {\n+            int numOfThreads = getNumConsumerThreads(module);\n+            ExecutorService executor = Executors.newFixedThreadPool(numOfThreads, sinkConsumerThreadFactory);\n+            sinkConsumersByModuleId.put(module.getId(), executor);\n+            LOG.info(\"Adding {} consumers for module: {}\", numOfThreads, module.getId());\n+        }\n+        sinkModulesById.putIfAbsent(module.getId(), module);\n+    }\n+\n+    @Override\n+    protected void stopConsumingForModule(SinkModule<?, Message> module) throws Exception {\n+\n+        ExecutorService executor = sinkConsumersByModuleId.get(module.getId());\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+        LOG.info(\"Stopped consumers for module: {}\", module.getId());\n+        sinkModulesById.remove(module.getId());\n+    }\n+\n+    @Override\n+    public <S extends RpcRequest, T extends RpcResponse> RpcClient<S, T> getClient(RpcModule<S, T> module) {\n+\n+        return new RpcClient<S, T>() {\n+            @Override\n+            public CompletableFuture<T> execute(S request) {\n+                if (request.getLocation() == null || request.getLocation().equals(getLocation())) {\n+                    // The request is for the current location, invoke it directly\n+                    return module.execute(request);\n+                }\n+                final Map<String, String> loggingContext = Logging.getCopyOfContextMap();\n+\n+                Span span = getTracer().buildSpan(module.getId()).start();\n+                String marshalRequest = module.marshalRequest(request);\n+                String rpcId = UUID.randomUUID().toString();\n+                CompletableFuture<T> future = new CompletableFuture<T>();\n+                Long timeToLive = request.getTimeToLiveMs();\n+                timeToLive = (timeToLive != null && timeToLive > 0) ? timeToLive : ttl;\n+                long expirationTime = System.currentTimeMillis() + timeToLive;\n+                RpcResponseHandlerImpl responseHandler = new RpcResponseHandlerImpl<S, T>(future,\n+                        module, rpcId, request.getLocation(), expirationTime, span, loggingContext);\n+                rpcResponseMap.put(rpcId, responseHandler);\n+                rpcTimeoutQueue.offer(responseHandler);\n+                RpcRequestProto.Builder builder = RpcRequestProto.newBuilder()\n+                        .setRpcId(rpcId)\n+                        .setLocation(request.getLocation())\n+                        .setModuleId(module.getId())\n+                        .setRpcContent(ByteString.copyFrom(marshalRequest.getBytes()));\n+                if (!Strings.isNullOrEmpty(request.getSystemId())) {\n+                    builder.setSystemId(request.getSystemId());\n+                }\n+                addTracingInfo(request, span, builder);\n+                RpcRequestProto requestProto = builder.build();\n+\n+                boolean succeeded = sendRequest(requestProto);\n+\n+                addMetrics(request, requestProto.getSerializedSize());\n+                if (!succeeded) {\n+                    RpcClientFactory.markFailed(getRpcMetrics(), request.getLocation(), module.getId());\n+                    future.completeExceptionally(new RuntimeException(\"No minion found at location \" + request.getLocation()));\n+                    return future;\n+                }\n+                LOG.debug(\"RPC request from module: {} with RpcId:{} sent to minion at location {}\", module.getId(), rpcId, request.getLocation());\n+                return future;\n+            }\n+\n+            private void addMetrics(RpcRequest request, int messageLen) {\n+                RpcClientFactory.markRpcCount(getRpcMetrics(), request.getLocation(), module.getId());\n+                RpcClientFactory.updateRequestSize(getRpcMetrics(), request.getLocation(), module.getId(), messageLen);\n+            }\n+\n+            private void addTracingInfo(RpcRequest request, Span span, RpcRequestProto.Builder builder) {\n+                //Add tags to span.\n+                span.setTag(TAG_LOCATION, request.getLocation());\n+                if (request.getSystemId() != null) {\n+                    span.setTag(TAG_SYSTEM_ID, request.getSystemId());\n+                }\n+                request.getTracingInfo().forEach(span::setTag);\n+                TracingInfoCarrier tracingInfoCarrier = new TracingInfoCarrier();\n+                getTracer().inject(span.context(), Format.Builtin.TEXT_MAP, tracingInfoCarrier);\n+                // Tracer adds it's own metadata.\n+                tracingInfoCarrier.getTracingInfoMap().forEach(builder::putTracingInfo);\n+                //Add custom tags from RpcRequest.\n+                request.getTracingInfo().forEach(builder::putTracingInfo);\n+            }\n+        };\n+    }\n+\n+\n+    private void handleRpcTimeouts() {\n+        while (!closed.get()) {\n+            try {\n+                RpcResponseHandler responseHandler = rpcTimeoutQueue.take();\n+                if (!responseHandler.isProcessed()) {\n+                    LOG.warn(\"RPC request from module: {} with RpcId:{} timedout \", responseHandler.getRpcModule().getId(),\n+                            responseHandler.getRpcId());\n+                    responseHandlerExecutor.execute(() -> responseHandler.sendResponse(null));\n+                }\n+            } catch (InterruptedException e) {\n+                LOG.info(\"interrupted while waiting for an element from rpcTimeoutQueue\", e);\n+                Thread.currentThread().interrupt();\n+                break;\n+            } catch (Exception e) {\n+                LOG.warn(\"error while sending response from timeout handler\", e);\n+            }\n+        }\n+    }\n+\n+\n+    private void handleResponse(RpcResponseProto responseProto) {\n+\n+        if (Strings.isNullOrEmpty(responseProto.getRpcId())) {\n+            return;\n+        }\n+        // Handle response from the Minion.\n+        RpcResponseHandler responseHandler = rpcResponseMap.get(responseProto.getRpcId());\n+        if (responseHandler != null && responseProto.getRpcContent() != null) {\n+            responseHandler.sendResponse(responseProto.getRpcContent().toStringUtf8());\n+        } else {\n+            LOG.debug(\"Received a response for request for module: {} with RpcId:{}, but no outstanding request was found with this id.\" +\n+                    \"The request may have timed out\", responseProto.getModuleId(), responseProto.getRpcId());\n+        }\n+    }\n+\n+    private boolean sendRequest(RpcRequestProto requestProto) {\n+        StreamObserver<RpcRequestProto> rpcHandler = getRpcHandler(requestProto.getLocation(), requestProto.getSystemId());\n+        if (rpcHandler == null) {\n+            LOG.warn(\"No RPC handlers found for location {}\", requestProto.getLocation());\n+            return false;\n+        }\n+        try {\n+            sendRpcRequest(rpcHandler, requestProto);\n+            return true;\n+        } catch (Throwable e) {\n+            LOG.error(\"Encountered exception while sending request {}\", requestProto, e);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Writing message through stream observer is not thread safe.\n+     */\n+    private synchronized void sendRpcRequest(StreamObserver<RpcRequestProto> rpcHandler, RpcRequestProto rpcMessage) {\n+        rpcHandler.onNext(rpcMessage);\n+    }\n+\n+    private synchronized StreamObserver<RpcRequestProto> getRpcHandler(String location, String systemId) {\n+\n+        if (!Strings.isNullOrEmpty(systemId)) {\n+            return rpcHandlerByMinionId.get(systemId);\n+        }\n+        Collection<StreamObserver<RpcRequestProto>> streamObservers = rpcHandlerByLocation.get(location);\n+        if (streamObservers.isEmpty()) {\n+            return null;\n+        }\n+        Iterator<StreamObserver<RpcRequestProto>> iterator = rpcHandlerIteratorMap.get(streamObservers);\n+        if (iterator == null) {\n+            iterator = Iterables.cycle(streamObservers).iterator();\n+            rpcHandlerIteratorMap.put(streamObservers, iterator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5OTAwOQ=="}, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 387}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODU0Nzg1OnYy", "diffSide": "RIGHT", "path": "pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDoxNjoxMFrOFliCSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDoxNjoxMFrOFliCSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5OTI3NQ==", "bodyText": "Is it possible to just upgrade our protobufVersion to match?", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374899275", "createdAt": "2020-02-04T20:16:10Z", "author": {"login": "j-white"}, "path": "pom.xml", "diffHunk": "@@ -1282,6 +1284,7 @@\n     <paxExamVersion>4.13.1</paxExamVersion>\n     <paxSwissboxVersion>1.8.2</paxSwissboxVersion>\n     <paxWebVersion>7.2.8</paxWebVersion>\n+    <protobufgRPCVersion>3.9.0</protobufgRPCVersion>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzMzMzg2OnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/grpc-introduction.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowMzowNFrOFoTVFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowMzowNFrOFoTVFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwNDA1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == Minion with GRPC strategy\n          \n          \n            \n            == Minion with GRPC Strategy", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377804052", "createdAt": "2020-02-11T18:03:04Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/grpc-introduction.adoc", "diffHunk": "@@ -0,0 +1,13 @@\n+\n+// Allow GitHub image rendering\n+:imagesdir: ../../images\n+\n+== Minion with GRPC strategy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzMzNjE4OnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/grpc-introduction.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowMzo0MFrOFoTWfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowMzo0MFrOFoTWfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwNDQxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            _Minions_ and _{opennms-product-name}_  can communicate via link:https://grpc.io/[gRPC] for both _RPC_ and _Sink_ Pattern.\n          \n          \n            \n            _Minions_ and _{opennms-product-name}_ can communicate via link:https://grpc.io/[gRPC] for both _RPC_ and _Sink_ patterns.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377804415", "createdAt": "2020-02-11T18:03:40Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/grpc-introduction.adoc", "diffHunk": "@@ -0,0 +1,13 @@\n+\n+// Allow GitHub image rendering\n+:imagesdir: ../../images\n+\n+== Minion with GRPC strategy\n+\n+_Minions_ and _{opennms-product-name}_  can communicate via link:https://grpc.io/[gRPC] for both _RPC_ and _Sink_ Pattern.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzMzODc2OnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/grpc-introduction.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowNDozMlrOFoTYJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowNDozMlrOFoTYJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwNDgzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            RPC pattern on GRPC strategy uses bi-directional streaming to send requests from _{opennms-product-name}_ and get response back from Minion.\n          \n          \n            \n            RPC pattern on GRPC strategy uses bidirectional streaming to send requests from _{opennms-product-name}_ and get responses back from Minion.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377804836", "createdAt": "2020-02-11T18:04:32Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/grpc-introduction.adoc", "diffHunk": "@@ -0,0 +1,13 @@\n+\n+// Allow GitHub image rendering\n+:imagesdir: ../../images\n+\n+== Minion with GRPC strategy\n+\n+_Minions_ and _{opennms-product-name}_  can communicate via link:https://grpc.io/[gRPC] for both _RPC_ and _Sink_ Pattern.\n+While using `GRPC` strategy minion runs a _gRPC_ client which connects to _{opennms-product-name}_ gRPC server on a custom port.\n+\n+RPC pattern on GRPC strategy uses bi-directional streaming to send requests from _{opennms-product-name}_ and get response back from Minion.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzMzOTk1OnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/grpc-introduction.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowNDo1OVrOFoTY7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowNDo1OVrOFoTY7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwNTAzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Sink pattern on GRPC strategy uses uni-directional streaming to send sink messages from minion to _{opennms-product-name}_.\n          \n          \n            \n            Sink pattern on GRPC strategy uses unidirectional streaming to send sink messages from Minion to _{opennms-product-name}_.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377805036", "createdAt": "2020-02-11T18:04:59Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/grpc-introduction.adoc", "diffHunk": "@@ -0,0 +1,13 @@\n+\n+// Allow GitHub image rendering\n+:imagesdir: ../../images\n+\n+== Minion with GRPC strategy\n+\n+_Minions_ and _{opennms-product-name}_  can communicate via link:https://grpc.io/[gRPC] for both _RPC_ and _Sink_ Pattern.\n+While using `GRPC` strategy minion runs a _gRPC_ client which connects to _{opennms-product-name}_ gRPC server on a custom port.\n+\n+RPC pattern on GRPC strategy uses bi-directional streaming to send requests from _{opennms-product-name}_ and get response back from Minion.\n+Sink pattern on GRPC strategy uses uni-directional streaming to send sink messages from minion to _{opennms-product-name}_.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM0MTgxOnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/grpc-introduction.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowNTozNlrOFoTaHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowNTozNlrOFoTaHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwNTM0Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            While using `GRPC` strategy minion runs a _gRPC_ client which connects to _{opennms-product-name}_ gRPC server on a custom port.\n          \n          \n            \n            While using `GRPC` strategy, Minion runs a _gRPC_ client that connects to _{opennms-product-name}_ gRPC server on a custom port.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377805342", "createdAt": "2020-02-11T18:05:36Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/grpc-introduction.adoc", "diffHunk": "@@ -0,0 +1,13 @@\n+\n+// Allow GitHub image rendering\n+:imagesdir: ../../images\n+\n+== Minion with GRPC strategy\n+\n+_Minions_ and _{opennms-product-name}_  can communicate via link:https://grpc.io/[gRPC] for both _RPC_ and _Sink_ Pattern.\n+While using `GRPC` strategy minion runs a _gRPC_ client which connects to _{opennms-product-name}_ gRPC server on a custom port.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM0NDM3OnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/grpc-introduction.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowNjoyMFrOFoTbrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowNjoyMFrOFoTbrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwNTc0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This section describes how you can setup _{opennms-product-name}_ to use `gRPC` for the communication with _Minions_.\n          \n          \n            \n            This section describes how you can set up _{opennms-product-name}_ to use `gRPC` for communication with _Minions_.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377805740", "createdAt": "2020-02-11T18:06:20Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/grpc-introduction.adoc", "diffHunk": "@@ -0,0 +1,13 @@\n+\n+// Allow GitHub image rendering\n+:imagesdir: ../../images\n+\n+== Minion with GRPC strategy\n+\n+_Minions_ and _{opennms-product-name}_  can communicate via link:https://grpc.io/[gRPC] for both _RPC_ and _Sink_ Pattern.\n+While using `GRPC` strategy minion runs a _gRPC_ client which connects to _{opennms-product-name}_ gRPC server on a custom port.\n+\n+RPC pattern on GRPC strategy uses bi-directional streaming to send requests from _{opennms-product-name}_ and get response back from Minion.\n+Sink pattern on GRPC strategy uses uni-directional streaming to send sink messages from minion to _{opennms-product-name}_.\n+\n+This section describes how you can setup _{opennms-product-name}_ to use `gRPC` for the communication with _Minions_.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM3MDI4OnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxNToxNVrOFoTssg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxNToxNVrOFoTssg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMDA5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===== Step 1: Disable ActiveMQ for RPC and Sink\n          \n          \n            \n            ===== Step 1: Disable ActiveMQ for RPC and Sink.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377810098", "createdAt": "2020-02-11T18:15:15Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "diffHunk": "@@ -0,0 +1,109 @@\n+\n+==== Configure Minion\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Disable ActiveMQ for RPC and Sink", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM3MTI4OnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxNToyOVrOFoTtTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxNToyOVrOFoTtTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMDI1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===== Step 2: Enable GRPC for RPC and Sink\n          \n          \n            \n            ===== Step 2: Enable GRPC for RPC and Sink.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377810252", "createdAt": "2020-02-11T18:15:29Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "diffHunk": "@@ -0,0 +1,109 @@\n+\n+==== Configure Minion\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Disable ActiveMQ for RPC and Sink\n+\n+.Disable ActiveMQ on _Minion_ startup\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/disable-activemq.boot\n+!minion-jms\n+!opennms-core-ipc-rpc-jms\n+!opennms-core-ipc-sink-camel\n+EOF\n+----\n+\n+===== Step 2: Enable GRPC for RPC and Sink", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM3MTkyOnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxNTo0NFrOFoTttQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxNTo0NFrOFoTttQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMDM1Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===== Step 3: Configure gRPC server info\n          \n          \n            \n            ===== Step 3: Configure gRPC server information.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377810357", "createdAt": "2020-02-11T18:15:44Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "diffHunk": "@@ -0,0 +1,109 @@\n+\n+==== Configure Minion\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Disable ActiveMQ for RPC and Sink\n+\n+.Disable ActiveMQ on _Minion_ startup\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/disable-activemq.boot\n+!minion-jms\n+!opennms-core-ipc-rpc-jms\n+!opennms-core-ipc-sink-camel\n+EOF\n+----\n+\n+===== Step 2: Enable GRPC for RPC and Sink\n+\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/grpc.boot\n+opennms-core-ipc-grpc-client\n+EOF\n+----\n+\n+===== Step 3: Configure gRPC server info", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM3MjYyOnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxNTo1N1rOFoTuMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxNTo1N1rOFoTuMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMDQ4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            .Add gRPC server for RPC/Sink communication\n          \n          \n            \n            .Add gRPC server for RPC/Sink communication.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377810483", "createdAt": "2020-02-11T18:15:57Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "diffHunk": "@@ -0,0 +1,109 @@\n+\n+==== Configure Minion\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Disable ActiveMQ for RPC and Sink\n+\n+.Disable ActiveMQ on _Minion_ startup\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/disable-activemq.boot\n+!minion-jms\n+!opennms-core-ipc-rpc-jms\n+!opennms-core-ipc-sink-camel\n+EOF\n+----\n+\n+===== Step 2: Enable GRPC for RPC and Sink\n+\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/grpc.boot\n+opennms-core-ipc-grpc-client\n+EOF\n+----\n+\n+===== Step 3: Configure gRPC server info\n+\n+.Add gRPC server for RPC/Sink communication", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM3NDI1OnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxNjoyOVrOFoTvQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxNjoyOVrOFoTvQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMDc1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===== Step 4: Enable and configure TLS on gRPC client\n          \n          \n            \n            ===== Step 4: Enable and configure TLS on gRPC client.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377810755", "createdAt": "2020-02-11T18:16:29Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "diffHunk": "@@ -0,0 +1,109 @@\n+\n+==== Configure Minion\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Disable ActiveMQ for RPC and Sink\n+\n+.Disable ActiveMQ on _Minion_ startup\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/disable-activemq.boot\n+!minion-jms\n+!opennms-core-ipc-rpc-jms\n+!opennms-core-ipc-sink-camel\n+EOF\n+----\n+\n+===== Step 2: Enable GRPC for RPC and Sink\n+\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/grpc.boot\n+opennms-core-ipc-grpc-client\n+EOF\n+----\n+\n+===== Step 3: Configure gRPC server info\n+\n+.Add gRPC server for RPC/Sink communication\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+host=localhost\n+port=8990\n+EOF\n+----\n+\n+===== Step 4: Enable and configure TLS on gRPC client", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM3ODE0OnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxNzozNVrOFoTxoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxNzozNVrOFoTxoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMTM2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===== Step 4: Configure max message size if default 10MB is not sufficient.\n          \n          \n            \n            ===== Step 5: Configure max. message size if default of 10MB is not sufficient.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377811361", "createdAt": "2020-02-11T18:17:35Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "diffHunk": "@@ -0,0 +1,109 @@\n+\n+==== Configure Minion\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Disable ActiveMQ for RPC and Sink\n+\n+.Disable ActiveMQ on _Minion_ startup\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/disable-activemq.boot\n+!minion-jms\n+!opennms-core-ipc-rpc-jms\n+!opennms-core-ipc-sink-camel\n+EOF\n+----\n+\n+===== Step 2: Enable GRPC for RPC and Sink\n+\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/grpc.boot\n+opennms-core-ipc-grpc-client\n+EOF\n+----\n+\n+===== Step 3: Configure gRPC server info\n+\n+.Add gRPC server for RPC/Sink communication\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+host=localhost\n+port=8990\n+EOF\n+----\n+\n+===== Step 4: Enable and configure TLS on gRPC client\n+\n+.Enable TLS and configure TLS certificates and private keys.\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+tls.enabled=true\n+trust.cert.filepath=/custom-path/ca.crt\n+client.cert.filepath=/custom-path/client.crt\n+client.private.key.filepath=/custom-path/client.pem\n+EOF\n+----\n+\n+===== Step 4: Configure max message size if default 10MB is not sufficient.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM3OTQxOnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxNzo1OVrOFoTycg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxNzo1OVrOFoTycg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMTU3MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            (needs to be configured both on server and client)\n          \n          \n            \n            (needs to be configured on both server and client)", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377811570", "createdAt": "2020-02-11T18:17:59Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "diffHunk": "@@ -0,0 +1,109 @@\n+\n+==== Configure Minion\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Disable ActiveMQ for RPC and Sink\n+\n+.Disable ActiveMQ on _Minion_ startup\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/disable-activemq.boot\n+!minion-jms\n+!opennms-core-ipc-rpc-jms\n+!opennms-core-ipc-sink-camel\n+EOF\n+----\n+\n+===== Step 2: Enable GRPC for RPC and Sink\n+\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/grpc.boot\n+opennms-core-ipc-grpc-client\n+EOF\n+----\n+\n+===== Step 3: Configure gRPC server info\n+\n+.Add gRPC server for RPC/Sink communication\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+host=localhost\n+port=8990\n+EOF\n+----\n+\n+===== Step 4: Enable and configure TLS on gRPC client\n+\n+.Enable TLS and configure TLS certificates and private keys.\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+tls.enabled=true\n+trust.cert.filepath=/custom-path/ca.crt\n+client.cert.filepath=/custom-path/client.crt\n+client.private.key.filepath=/custom-path/client.pem\n+EOF\n+----\n+\n+===== Step 4: Configure max message size if default 10MB is not sufficient.\n+(needs to be configured both on server and client)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM4MDk4OnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxODoyM1rOFoTzWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxODoyM1rOFoTzWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMTgwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            .Configure max message size\n          \n          \n            \n            .Configure max. message size", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377811802", "createdAt": "2020-02-11T18:18:23Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "diffHunk": "@@ -0,0 +1,109 @@\n+\n+==== Configure Minion\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Disable ActiveMQ for RPC and Sink\n+\n+.Disable ActiveMQ on _Minion_ startup\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/disable-activemq.boot\n+!minion-jms\n+!opennms-core-ipc-rpc-jms\n+!opennms-core-ipc-sink-camel\n+EOF\n+----\n+\n+===== Step 2: Enable GRPC for RPC and Sink\n+\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/grpc.boot\n+opennms-core-ipc-grpc-client\n+EOF\n+----\n+\n+===== Step 3: Configure gRPC server info\n+\n+.Add gRPC server for RPC/Sink communication\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+host=localhost\n+port=8990\n+EOF\n+----\n+\n+===== Step 4: Enable and configure TLS on gRPC client\n+\n+.Enable TLS and configure TLS certificates and private keys.\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+tls.enabled=true\n+trust.cert.filepath=/custom-path/ca.crt\n+client.cert.filepath=/custom-path/client.crt\n+client.private.key.filepath=/custom-path/client.pem\n+EOF\n+----\n+\n+===== Step 4: Configure max message size if default 10MB is not sufficient.\n+(needs to be configured both on server and client)\n+\n+.Configure max message size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM4NDMzOnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxOTozMVrOFoT1mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxOTozMVrOFoT1mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMjM3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===== Step 5: Restart Minion to apply changes\n          \n          \n            \n            ===== Step 6: Restart Minion to apply changes.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377812376", "createdAt": "2020-02-11T18:19:31Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "diffHunk": "@@ -0,0 +1,109 @@\n+\n+==== Configure Minion\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Disable ActiveMQ for RPC and Sink\n+\n+.Disable ActiveMQ on _Minion_ startup\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/disable-activemq.boot\n+!minion-jms\n+!opennms-core-ipc-rpc-jms\n+!opennms-core-ipc-sink-camel\n+EOF\n+----\n+\n+===== Step 2: Enable GRPC for RPC and Sink\n+\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/grpc.boot\n+opennms-core-ipc-grpc-client\n+EOF\n+----\n+\n+===== Step 3: Configure gRPC server info\n+\n+.Add gRPC server for RPC/Sink communication\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+host=localhost\n+port=8990\n+EOF\n+----\n+\n+===== Step 4: Enable and configure TLS on gRPC client\n+\n+.Enable TLS and configure TLS certificates and private keys.\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+tls.enabled=true\n+trust.cert.filepath=/custom-path/ca.crt\n+client.cert.filepath=/custom-path/client.crt\n+client.private.key.filepath=/custom-path/client.pem\n+EOF\n+----\n+\n+===== Step 4: Configure max message size if default 10MB is not sufficient.\n+(needs to be configured both on server and client)\n+\n+.Configure max message size\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+max.message.size=10485760\n+EOF\n+----\n+\n+===== Step 5: Restart Minion to apply changes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM4NTQ3OnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxOTo1NFrOFoT2VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxOTo1NFrOFoT2VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMjU2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===== Step 6: Verify GRPC configuration and connectivity\n          \n          \n            \n            ===== Step 7: Verify GRPC configuration and connectivity.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377812565", "createdAt": "2020-02-11T18:19:54Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "diffHunk": "@@ -0,0 +1,109 @@\n+\n+==== Configure Minion\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Disable ActiveMQ for RPC and Sink\n+\n+.Disable ActiveMQ on _Minion_ startup\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/disable-activemq.boot\n+!minion-jms\n+!opennms-core-ipc-rpc-jms\n+!opennms-core-ipc-sink-camel\n+EOF\n+----\n+\n+===== Step 2: Enable GRPC for RPC and Sink\n+\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/grpc.boot\n+opennms-core-ipc-grpc-client\n+EOF\n+----\n+\n+===== Step 3: Configure gRPC server info\n+\n+.Add gRPC server for RPC/Sink communication\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+host=localhost\n+port=8990\n+EOF\n+----\n+\n+===== Step 4: Enable and configure TLS on gRPC client\n+\n+.Enable TLS and configure TLS certificates and private keys.\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+tls.enabled=true\n+trust.cert.filepath=/custom-path/ca.crt\n+client.cert.filepath=/custom-path/client.crt\n+client.private.key.filepath=/custom-path/client.pem\n+EOF\n+----\n+\n+===== Step 4: Configure max message size if default 10MB is not sufficient.\n+(needs to be configured both on server and client)\n+\n+.Configure max message size\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+max.message.size=10485760\n+EOF\n+----\n+\n+===== Step 5: Restart Minion to apply changes\n+\n+[source, shell]\n+----\n+systemctl restart minion\n+----\n+\n+===== Step 6: Verify GRPC configuration and connectivity", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM4NTk5OnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMDowNlrOFoT2rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMDowNlrOFoT2rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMjY1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            .Login to Karaf Shell\n          \n          \n            \n            .Login to Karaf shell", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377812654", "createdAt": "2020-02-11T18:20:06Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "diffHunk": "@@ -0,0 +1,109 @@\n+\n+==== Configure Minion\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Disable ActiveMQ for RPC and Sink\n+\n+.Disable ActiveMQ on _Minion_ startup\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/disable-activemq.boot\n+!minion-jms\n+!opennms-core-ipc-rpc-jms\n+!opennms-core-ipc-sink-camel\n+EOF\n+----\n+\n+===== Step 2: Enable GRPC for RPC and Sink\n+\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/grpc.boot\n+opennms-core-ipc-grpc-client\n+EOF\n+----\n+\n+===== Step 3: Configure gRPC server info\n+\n+.Add gRPC server for RPC/Sink communication\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+host=localhost\n+port=8990\n+EOF\n+----\n+\n+===== Step 4: Enable and configure TLS on gRPC client\n+\n+.Enable TLS and configure TLS certificates and private keys.\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+tls.enabled=true\n+trust.cert.filepath=/custom-path/ca.crt\n+client.cert.filepath=/custom-path/client.crt\n+client.private.key.filepath=/custom-path/client.pem\n+EOF\n+----\n+\n+===== Step 4: Configure max message size if default 10MB is not sufficient.\n+(needs to be configured both on server and client)\n+\n+.Configure max message size\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+max.message.size=10485760\n+EOF\n+----\n+\n+===== Step 5: Restart Minion to apply changes\n+\n+[source, shell]\n+----\n+systemctl restart minion\n+----\n+\n+===== Step 6: Verify GRPC configuration and connectivity\n+\n+.Login to Karaf Shell", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM4NzUwOnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMDozOFrOFoT3zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMDozOFrOFoT3zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMjk0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===== Step 7. Verify Minion functionality\n          \n          \n            \n            ===== Step 8. Verify Minion functionality.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377812943", "createdAt": "2020-02-11T18:20:38Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-minion.adoc", "diffHunk": "@@ -0,0 +1,109 @@\n+\n+==== Configure Minion\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Disable ActiveMQ for RPC and Sink\n+\n+.Disable ActiveMQ on _Minion_ startup\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/disable-activemq.boot\n+!minion-jms\n+!opennms-core-ipc-rpc-jms\n+!opennms-core-ipc-sink-camel\n+EOF\n+----\n+\n+===== Step 2: Enable GRPC for RPC and Sink\n+\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/featuresBoot.d/grpc.boot\n+opennms-core-ipc-grpc-client\n+EOF\n+----\n+\n+===== Step 3: Configure gRPC server info\n+\n+.Add gRPC server for RPC/Sink communication\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+host=localhost\n+port=8990\n+EOF\n+----\n+\n+===== Step 4: Enable and configure TLS on gRPC client\n+\n+.Enable TLS and configure TLS certificates and private keys.\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+tls.enabled=true\n+trust.cert.filepath=/custom-path/ca.crt\n+client.cert.filepath=/custom-path/client.crt\n+client.private.key.filepath=/custom-path/client.pem\n+EOF\n+----\n+\n+===== Step 4: Configure max message size if default 10MB is not sufficient.\n+(needs to be configured both on server and client)\n+\n+.Configure max message size\n+[source, shell]\n+----\n+cat <<EOF >${MINION_HOME}/etc/org.opennms.core.ipc.grpc.client.cfg\n+max.message.size=10485760\n+EOF\n+----\n+\n+===== Step 5: Restart Minion to apply changes\n+\n+[source, shell]\n+----\n+systemctl restart minion\n+----\n+\n+===== Step 6: Verify GRPC configuration and connectivity\n+\n+.Login to Karaf Shell\n+[source, shell]\n+----\n+ssh admin@localhost -p 8201\n+----\n+\n+.Test if gRPC client can connect to _{opennms-product-name}_ gRPC server\n+[source, shell]\n+----\n+feature:list | grep opennms-core-ipc-grpc-client\n+opennms-core-ipc-grpc-client                \u2502 26.0.0.SNAPSHOT  \u2502 x        \u2502 Started\n+----\n+\n+.Test connectivity to Kafka\n+[source, shell]\n+----\n+opennms-health:check\n+Verifying the health of the container\n+\n+Connecting to OpenNMS ReST API   [ Success  ]\n+Verifying installed bundles      [ Success  ]\n+Connecting to gRPC IPC Server    [ Success  ]\n+\n+=> Everything is awesome\n+----\n+\n+===== Step 7. Verify Minion functionality", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM5MTcyOnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-opennms.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMTo1OVrOFoT6dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMTo1OVrOFoT6dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMzYyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===== Step 3: Enable and configure TLS on gRPC server\n          \n          \n            \n            ===== Step 3: Enable and configure TLS on gRPC server.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377813621", "createdAt": "2020-02-11T18:21:59Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-opennms.adoc", "diffHunk": "@@ -0,0 +1,57 @@\n+\n+==== Configure {opennms-product-name}\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Set GRPC as IPC strategy.\n+[source, shell]\n+----\n+cat <<EOF >${OPENNMS_HOME}/etc/opennms.properties.d/grpc.properties\n+org.opennms.core.ipc.ipc.strategy=osgi\n+EOF\n+----\n+\n+===== Step 2: Add GRPC Server feature.\n+\n+[source, shell]\n+----\n+cat <<EOF >${OPENNMS_HOME}/etc/featuresBoot.d/grpc.boot\n+opennms-core-ipc-grpc-server\n+EOF\n+----\n+\n+===== Step 3: Enable and configure TLS on gRPC server", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM5MjUxOnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-opennms.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMjoxNlrOFoT7Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMjoxNlrOFoT7Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMzc2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===== Step 4: Configure max message size if default 10MB is not sufficient.\n          \n          \n            \n            ===== Step 4: Configure max. message size if default of 10MB is not sufficient.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377813766", "createdAt": "2020-02-11T18:22:16Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-opennms.adoc", "diffHunk": "@@ -0,0 +1,57 @@\n+\n+==== Configure {opennms-product-name}\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Set GRPC as IPC strategy.\n+[source, shell]\n+----\n+cat <<EOF >${OPENNMS_HOME}/etc/opennms.properties.d/grpc.properties\n+org.opennms.core.ipc.ipc.strategy=osgi\n+EOF\n+----\n+\n+===== Step 2: Add GRPC Server feature.\n+\n+[source, shell]\n+----\n+cat <<EOF >${OPENNMS_HOME}/etc/featuresBoot.d/grpc.boot\n+opennms-core-ipc-grpc-server\n+EOF\n+----\n+\n+===== Step 3: Enable and configure TLS on gRPC server\n+\n+.Enable TLS and configure TLS certificates and private keys.\n+[source, shell]\n+----\n+cat <<EOF >${OPENNMS_HOME}/etc/org.opennms.core.ipc.grpc.server.cfg\n+tls.enabled=true\n+server.cert.filepath=/custom-path/server.crt\n+server.private.key.filepath=/custom-path/server.pem\n+client.cert.filepath=/custom-path/client.crt\n+EOF\n+----\n+\n+===== Step 4: Configure max message size if default 10MB is not sufficient.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM5MzMzOnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-opennms.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMjozNVrOFoT7kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMjozNVrOFoT7kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMzkwNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            (needs to be configured both on server and client)\n          \n          \n            \n            (needs to be configured on both server and client)", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377813905", "createdAt": "2020-02-11T18:22:35Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-opennms.adoc", "diffHunk": "@@ -0,0 +1,57 @@\n+\n+==== Configure {opennms-product-name}\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Set GRPC as IPC strategy.\n+[source, shell]\n+----\n+cat <<EOF >${OPENNMS_HOME}/etc/opennms.properties.d/grpc.properties\n+org.opennms.core.ipc.ipc.strategy=osgi\n+EOF\n+----\n+\n+===== Step 2: Add GRPC Server feature.\n+\n+[source, shell]\n+----\n+cat <<EOF >${OPENNMS_HOME}/etc/featuresBoot.d/grpc.boot\n+opennms-core-ipc-grpc-server\n+EOF\n+----\n+\n+===== Step 3: Enable and configure TLS on gRPC server\n+\n+.Enable TLS and configure TLS certificates and private keys.\n+[source, shell]\n+----\n+cat <<EOF >${OPENNMS_HOME}/etc/org.opennms.core.ipc.grpc.server.cfg\n+tls.enabled=true\n+server.cert.filepath=/custom-path/server.crt\n+server.private.key.filepath=/custom-path/server.pem\n+client.cert.filepath=/custom-path/client.crt\n+EOF\n+----\n+\n+===== Step 4: Configure max message size if default 10MB is not sufficient.\n+(needs to be configured both on server and client)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM5NDEwOnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-opennms.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMjo1MlrOFoT8EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMjo1MlrOFoT8EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxNDAzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            .Configure max message size\n          \n          \n            \n            .Configure max. message size", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377814033", "createdAt": "2020-02-11T18:22:52Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-opennms.adoc", "diffHunk": "@@ -0,0 +1,57 @@\n+\n+==== Configure {opennms-product-name}\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Set GRPC as IPC strategy.\n+[source, shell]\n+----\n+cat <<EOF >${OPENNMS_HOME}/etc/opennms.properties.d/grpc.properties\n+org.opennms.core.ipc.ipc.strategy=osgi\n+EOF\n+----\n+\n+===== Step 2: Add GRPC Server feature.\n+\n+[source, shell]\n+----\n+cat <<EOF >${OPENNMS_HOME}/etc/featuresBoot.d/grpc.boot\n+opennms-core-ipc-grpc-server\n+EOF\n+----\n+\n+===== Step 3: Enable and configure TLS on gRPC server\n+\n+.Enable TLS and configure TLS certificates and private keys.\n+[source, shell]\n+----\n+cat <<EOF >${OPENNMS_HOME}/etc/org.opennms.core.ipc.grpc.server.cfg\n+tls.enabled=true\n+server.cert.filepath=/custom-path/server.crt\n+server.private.key.filepath=/custom-path/server.pem\n+client.cert.filepath=/custom-path/client.crt\n+EOF\n+----\n+\n+===== Step 4: Configure max message size if default 10MB is not sufficient.\n+(needs to be configured both on server and client)\n+\n+.Configure max message size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM5NTEwOnYy", "diffSide": "RIGHT", "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-opennms.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMzowOFrOFoT8rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMzowOFrOFoT8rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxNDE5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===== Step 5: Restart {opennms-product-name}\n          \n          \n            \n            ===== Step 5: Restart {opennms-product-name}.", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r377814191", "createdAt": "2020-02-11T18:23:08Z", "author": {"login": "Bonrob2"}, "path": "opennms-doc/guide-install/src/asciidoc/text/minion-grpc/steps-opennms.adoc", "diffHunk": "@@ -0,0 +1,57 @@\n+\n+==== Configure {opennms-product-name}\n+\n+// No section numbers for step-by-step guide\n+:!sectnums:\n+\n+===== Step 1: Set GRPC as IPC strategy.\n+[source, shell]\n+----\n+cat <<EOF >${OPENNMS_HOME}/etc/opennms.properties.d/grpc.properties\n+org.opennms.core.ipc.ipc.strategy=osgi\n+EOF\n+----\n+\n+===== Step 2: Add GRPC Server feature.\n+\n+[source, shell]\n+----\n+cat <<EOF >${OPENNMS_HOME}/etc/featuresBoot.d/grpc.boot\n+opennms-core-ipc-grpc-server\n+EOF\n+----\n+\n+===== Step 3: Enable and configure TLS on gRPC server\n+\n+.Enable TLS and configure TLS certificates and private keys.\n+[source, shell]\n+----\n+cat <<EOF >${OPENNMS_HOME}/etc/org.opennms.core.ipc.grpc.server.cfg\n+tls.enabled=true\n+server.cert.filepath=/custom-path/server.crt\n+server.private.key.filepath=/custom-path/server.pem\n+client.cert.filepath=/custom-path/client.crt\n+EOF\n+----\n+\n+===== Step 4: Configure max message size if default 10MB is not sufficient.\n+(needs to be configured both on server and client)\n+\n+.Configure max message size\n+[source, shell]\n+----\n+cat <<EOF >${OPENNMS_HOME}/etc/org.opennms.core.ipc.grpc.server.cfg\n+max.message.size=10485760\n+EOF\n+----\n+\n+\n+===== Step 5: Restart {opennms-product-name}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 719, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}