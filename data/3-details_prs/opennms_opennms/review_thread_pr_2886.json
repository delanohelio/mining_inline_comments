{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0NzcwMzI4", "number": 2886, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMToxNzo1NVrODfwJIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTo0OToyMFrODhPAZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjIxMjE3OnYy", "diffSide": "RIGHT", "path": "core/web-assets/src/main/assets/js/apps/onms-classifications/views/modals/new-rule-modal.html", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMToxNzo1NVrOFpo_Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMToxNzo1NVrOFpo_Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwNzQzMQ==", "bodyText": "Maybe show a CIDR in placeholder?", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r379207431", "createdAt": "2020-02-14T01:17:55Z", "author": {"login": "Naicisum"}, "path": "core/web-assets/src/main/assets/js/apps/onms-classifications/views/modals/new-rule-modal.html", "diffHunk": "@@ -35,7 +35,7 @@ <h5 class=\"modal-title\" ng-show=\"classification.id !== undefined\">Edit Classific\n       <div class=\"form-row\">\n         <div class=\"form-group col-md-8\">\n           <label class=\"col-form-label\" for=\"rule.srcAddress\">Source IP Address</label>\n-          <input class=\"form-control\" type=\"text\" id=\"rule.srcAddress\" name=\"srcAddress\" placeholder=\"127.0.0.1\" ng-model=\"classification.srcAddress\"\n+          <input class=\"form-control\" type=\"text\" id=\"rule.srcAddress\" name=\"srcAddress\" placeholder=\"127.0.0.1,10.0.0.0-10.255.255.255\" ng-model=\"classification.srcAddress\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45f0c6027321e81a9fff8f427c87ecdfa4dd7447"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjIxMjgwOnYy", "diffSide": "RIGHT", "path": "core/web-assets/src/main/assets/js/apps/onms-classifications/views/modals/new-rule-modal.html", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMToxODoyMlrOFpo_bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMToxODoyMlrOFpo_bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwNzUzNA==", "bodyText": "Same as srcAddress, CIDR in placeholder", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r379207534", "createdAt": "2020-02-14T01:18:22Z", "author": {"login": "Naicisum"}, "path": "core/web-assets/src/main/assets/js/apps/onms-classifications/views/modals/new-rule-modal.html", "diffHunk": "@@ -49,7 +49,7 @@ <h5 class=\"modal-title\" ng-show=\"classification.id !== undefined\">Edit Classific\n       <div class=\"form-row\">\n         <div class=\"form-group col-md-8\">\n           <label class=\"col-form-label\" for=\"rule.dstAddress\">Destination IP Address</label>\n-          <input class=\"form-control\" type=\"text\" id=\"rule.dstAddress\" name=\"dstAddress\" placeholder=\"127.0.0.1\" ng-model=\"classification.dstAddress\"\n+          <input class=\"form-control\" type=\"text\" id=\"rule.dstAddress\" name=\"dstAddress\" placeholder=\"127.0.0.1,10.0.0.0-10.255.255.255\" ng-model=\"classification.dstAddress\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45f0c6027321e81a9fff8f427c87ecdfa4dd7447"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjI1MDM3OnYy", "diffSide": "RIGHT", "path": "features/flows/classification/engine/impl/src/test/java/org/opennms/netmgt/flows/classification/internal/DefaultClassificationEngineTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMTo0MTo1OFrOFppVvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMTo0MTo1OFrOFppVvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzI0Ng==", "bodyText": "Create a CIDR test rule?", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r379213246", "createdAt": "2020-02-14T01:41:58Z", "author": {"login": "Naicisum"}, "path": "features/flows/classification/engine/impl/src/test/java/org/opennms/netmgt/flows/classification/internal/DefaultClassificationEngineTest.java", "diffHunk": "@@ -94,14 +94,15 @@ public void verifyRuleEngineWithOmnidirectionals() {\n         assertNull(engine.classify(new ClassificationRequestBuilder().withSrcPort(7331).withDstPort(9999).build()));\n     }\n \n+    // TODO MVR add CIDR test\n     @Test\n     public void verifyRuleEngineExtended() {\n         // Define Rule set\n         DefaultClassificationEngine engine = new DefaultClassificationEngine(() -> Lists.newArrayList(\n                 new RuleBuilder().withName(\"SSH\").withDstPort(\"22\").withPosition(1).build(),\n                 new RuleBuilder().withName(\"HTTP_CUSTOM\").withDstAddress(\"192.168.0.1\").withDstPort(\"80\").withPosition(2).build(),\n                 new RuleBuilder().withName(\"HTTP\").withDstPort(\"80\").withPosition(3).build(),\n-                new RuleBuilder().withName(\"DUMMY\").withDstAddress(\"192.168.1.*\").withDstPort(\"8000-9000,80,8080\").withPosition(4).build(),\n+                new RuleBuilder().withName(\"DUMMY\").withDstAddress(\"192.168.1.0-192.168.1.255,10.10.5.3\").withDstPort(\"8000-9000,80,8080\").withPosition(4).build(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45f0c6027321e81a9fff8f427c87ecdfa4dd7447"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjI1MDczOnYy", "diffSide": "RIGHT", "path": "features/flows/classification/engine/impl/src/test/java/org/opennms/netmgt/flows/classification/internal/DefaultClassificationEngineTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMTo0MjoxMFrOFppV8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMTo0MjoxMFrOFppV8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzI5OA==", "bodyText": "Test the CIDR rule?", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r379213298", "createdAt": "2020-02-14T01:42:10Z", "author": {"login": "Naicisum"}, "path": "features/flows/classification/engine/impl/src/test/java/org/opennms/netmgt/flows/classification/internal/DefaultClassificationEngineTest.java", "diffHunk": "@@ -138,6 +139,13 @@ public void verifyRuleEngineExtended() {\n                         .withDstPort(80)\n                         .withDstAddress(\"192.168.0.2\")\n                         .withProtocol(ProtocolType.TCP).build()));\n+        assertEquals(\"DUMMY\", engine.classify(new ClassificationRequestBuilder()\n+                .withLocation(\"Default\")\n+                .withSrcAddress(\"127.0.0.1\")\n+                .withDstAddress(\"10.10.5.3\")\n+                .withSrcPort(5213)\n+                .withDstPort(8080)\n+                .withProtocol(ProtocolType.TCP).build()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45f0c6027321e81a9fff8f427c87ecdfa4dd7447"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjI1Mjc3OnYy", "diffSide": "RIGHT", "path": "features/flows/classification/engine/impl/src/test/java/org/opennms/netmgt/flows/classification/internal/value/IpValueTest.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMTo0MzozMlrOFppXIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwOToyNzozMlrOFrgsIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzYwMw==", "bodyText": "Wouldn't this be true? Value is apart of ipValue on declaration.", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r379213603", "createdAt": "2020-02-14T01:43:32Z", "author": {"login": "Naicisum"}, "path": "features/flows/classification/engine/impl/src/test/java/org/opennms/netmgt/flows/classification/internal/value/IpValueTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020-2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.flows.classification.internal.value;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+import org.junit.Test;\n+import org.opennms.core.network.IPAddress;\n+import org.opennms.core.network.IPAddressRange;\n+\n+public class IpValueTest {\n+\n+    @Test\n+    public void verifyRangedValues() {\n+        final IpValue ipValue = new IpValue(\"10.1.1.1-10.1.1.100\");\n+        final IPAddressRange range = new IPAddressRange(\"10.1.1.1\", \"10.1.1.100\");\n+        for (IPAddress address : range) {\n+            assertThat(ipValue.isInRange(address.toUserString()), is(true));\n+        }\n+    }\n+\n+    @Test\n+    public void verifySingleValue() {\n+        final IpValue ipValue = new IpValue(\"192.168.0.1\");\n+        assertThat(ipValue.isInRange(\"192.168.0.0\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.1\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.2\"), is(false));\n+    }\n+\n+    @Test\n+    public void verifyMultiValues() {\n+        final IpValue ipValue = new IpValue(\"192.168.0.1, 192.168.0.2, 192.168.0.10\");\n+        assertThat(ipValue.isInRange(\"192.168.0.0\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.1\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.2\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.3\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.4\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.5\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.6\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.7\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.8\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.9\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.10\"), is(true));\n+    }\n+\n+    @Test\n+    public void verifyCIDRValue() {\n+        final IpValue ipValue = new IpValue(\"10.0.0.5,192.168.0.0/24\");\n+        for (IPAddress ipAddress : new IPAddressRange(\"192.168.0.0\", \"192.168.0.255\")) {\n+            assertThat(ipValue.isInRange(ipAddress.toUserString()), is(true));\n+        }\n+        assertThat(ipValue.isInRange(\"10.0.0.5\"), is(false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45f0c6027321e81a9fff8f427c87ecdfa4dd7447"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzgwMA==", "bodyText": "Should also test CIDR values that are not on network address. IE. 10.0.0.0/24 is the same as 10.0.0.1/24 and 10.0.0.255/24", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r379213800", "createdAt": "2020-02-14T01:44:47Z", "author": {"login": "Naicisum"}, "path": "features/flows/classification/engine/impl/src/test/java/org/opennms/netmgt/flows/classification/internal/value/IpValueTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020-2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.flows.classification.internal.value;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+import org.junit.Test;\n+import org.opennms.core.network.IPAddress;\n+import org.opennms.core.network.IPAddressRange;\n+\n+public class IpValueTest {\n+\n+    @Test\n+    public void verifyRangedValues() {\n+        final IpValue ipValue = new IpValue(\"10.1.1.1-10.1.1.100\");\n+        final IPAddressRange range = new IPAddressRange(\"10.1.1.1\", \"10.1.1.100\");\n+        for (IPAddress address : range) {\n+            assertThat(ipValue.isInRange(address.toUserString()), is(true));\n+        }\n+    }\n+\n+    @Test\n+    public void verifySingleValue() {\n+        final IpValue ipValue = new IpValue(\"192.168.0.1\");\n+        assertThat(ipValue.isInRange(\"192.168.0.0\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.1\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.2\"), is(false));\n+    }\n+\n+    @Test\n+    public void verifyMultiValues() {\n+        final IpValue ipValue = new IpValue(\"192.168.0.1, 192.168.0.2, 192.168.0.10\");\n+        assertThat(ipValue.isInRange(\"192.168.0.0\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.1\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.2\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.3\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.4\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.5\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.6\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.7\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.8\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.9\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.10\"), is(true));\n+    }\n+\n+    @Test\n+    public void verifyCIDRValue() {\n+        final IpValue ipValue = new IpValue(\"10.0.0.5,192.168.0.0/24\");\n+        for (IPAddress ipAddress : new IPAddressRange(\"192.168.0.0\", \"192.168.0.255\")) {\n+            assertThat(ipValue.isInRange(ipAddress.toUserString()), is(true));\n+        }\n+        assertThat(ipValue.isInRange(\"10.0.0.5\"), is(false));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzYwMw=="}, "originalCommit": {"oid": "45f0c6027321e81a9fff8f427c87ecdfa4dd7447"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyMzAzMQ==", "bodyText": "Not sure what you mean with the latest comment.", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r379323031", "createdAt": "2020-02-14T09:18:21Z", "author": {"login": "mvrueden"}, "path": "features/flows/classification/engine/impl/src/test/java/org/opennms/netmgt/flows/classification/internal/value/IpValueTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020-2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.flows.classification.internal.value;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+import org.junit.Test;\n+import org.opennms.core.network.IPAddress;\n+import org.opennms.core.network.IPAddressRange;\n+\n+public class IpValueTest {\n+\n+    @Test\n+    public void verifyRangedValues() {\n+        final IpValue ipValue = new IpValue(\"10.1.1.1-10.1.1.100\");\n+        final IPAddressRange range = new IPAddressRange(\"10.1.1.1\", \"10.1.1.100\");\n+        for (IPAddress address : range) {\n+            assertThat(ipValue.isInRange(address.toUserString()), is(true));\n+        }\n+    }\n+\n+    @Test\n+    public void verifySingleValue() {\n+        final IpValue ipValue = new IpValue(\"192.168.0.1\");\n+        assertThat(ipValue.isInRange(\"192.168.0.0\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.1\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.2\"), is(false));\n+    }\n+\n+    @Test\n+    public void verifyMultiValues() {\n+        final IpValue ipValue = new IpValue(\"192.168.0.1, 192.168.0.2, 192.168.0.10\");\n+        assertThat(ipValue.isInRange(\"192.168.0.0\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.1\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.2\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.3\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.4\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.5\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.6\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.7\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.8\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.9\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.10\"), is(true));\n+    }\n+\n+    @Test\n+    public void verifyCIDRValue() {\n+        final IpValue ipValue = new IpValue(\"10.0.0.5,192.168.0.0/24\");\n+        for (IPAddress ipAddress : new IPAddressRange(\"192.168.0.0\", \"192.168.0.255\")) {\n+            assertThat(ipValue.isInRange(ipAddress.toUserString()), is(true));\n+        }\n+        assertThat(ipValue.isInRange(\"10.0.0.5\"), is(false));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzYwMw=="}, "originalCommit": {"oid": "45f0c6027321e81a9fff8f427c87ecdfa4dd7447"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA2NzUyNw==", "bodyText": "Not everyone will use the standard CIDR notation of 192.168.0.0/24, some will use 192.168.0.1/24 instead. Both are identical and valid.", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r381067527", "createdAt": "2020-02-19T04:08:14Z", "author": {"login": "Naicisum"}, "path": "features/flows/classification/engine/impl/src/test/java/org/opennms/netmgt/flows/classification/internal/value/IpValueTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020-2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.flows.classification.internal.value;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+import org.junit.Test;\n+import org.opennms.core.network.IPAddress;\n+import org.opennms.core.network.IPAddressRange;\n+\n+public class IpValueTest {\n+\n+    @Test\n+    public void verifyRangedValues() {\n+        final IpValue ipValue = new IpValue(\"10.1.1.1-10.1.1.100\");\n+        final IPAddressRange range = new IPAddressRange(\"10.1.1.1\", \"10.1.1.100\");\n+        for (IPAddress address : range) {\n+            assertThat(ipValue.isInRange(address.toUserString()), is(true));\n+        }\n+    }\n+\n+    @Test\n+    public void verifySingleValue() {\n+        final IpValue ipValue = new IpValue(\"192.168.0.1\");\n+        assertThat(ipValue.isInRange(\"192.168.0.0\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.1\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.2\"), is(false));\n+    }\n+\n+    @Test\n+    public void verifyMultiValues() {\n+        final IpValue ipValue = new IpValue(\"192.168.0.1, 192.168.0.2, 192.168.0.10\");\n+        assertThat(ipValue.isInRange(\"192.168.0.0\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.1\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.2\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.3\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.4\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.5\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.6\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.7\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.8\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.9\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.10\"), is(true));\n+    }\n+\n+    @Test\n+    public void verifyCIDRValue() {\n+        final IpValue ipValue = new IpValue(\"10.0.0.5,192.168.0.0/24\");\n+        for (IPAddress ipAddress : new IPAddressRange(\"192.168.0.0\", \"192.168.0.255\")) {\n+            assertThat(ipValue.isInRange(ipAddress.toUserString()), is(true));\n+        }\n+        assertThat(ipValue.isInRange(\"10.0.0.5\"), is(false));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzYwMw=="}, "originalCommit": {"oid": "45f0c6027321e81a9fff8f427c87ecdfa4dd7447"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE2ODY3Mg==", "bodyText": "Yes, that is true. Internally it is already working as expected, but adding a few more test cases to cover these is a good idea.", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r381168672", "createdAt": "2020-02-19T09:27:32Z", "author": {"login": "mvrueden"}, "path": "features/flows/classification/engine/impl/src/test/java/org/opennms/netmgt/flows/classification/internal/value/IpValueTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020-2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.flows.classification.internal.value;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+import org.junit.Test;\n+import org.opennms.core.network.IPAddress;\n+import org.opennms.core.network.IPAddressRange;\n+\n+public class IpValueTest {\n+\n+    @Test\n+    public void verifyRangedValues() {\n+        final IpValue ipValue = new IpValue(\"10.1.1.1-10.1.1.100\");\n+        final IPAddressRange range = new IPAddressRange(\"10.1.1.1\", \"10.1.1.100\");\n+        for (IPAddress address : range) {\n+            assertThat(ipValue.isInRange(address.toUserString()), is(true));\n+        }\n+    }\n+\n+    @Test\n+    public void verifySingleValue() {\n+        final IpValue ipValue = new IpValue(\"192.168.0.1\");\n+        assertThat(ipValue.isInRange(\"192.168.0.0\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.1\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.2\"), is(false));\n+    }\n+\n+    @Test\n+    public void verifyMultiValues() {\n+        final IpValue ipValue = new IpValue(\"192.168.0.1, 192.168.0.2, 192.168.0.10\");\n+        assertThat(ipValue.isInRange(\"192.168.0.0\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.1\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.2\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.3\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.4\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.5\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.6\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.7\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.8\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.9\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.10\"), is(true));\n+    }\n+\n+    @Test\n+    public void verifyCIDRValue() {\n+        final IpValue ipValue = new IpValue(\"10.0.0.5,192.168.0.0/24\");\n+        for (IPAddress ipAddress : new IPAddressRange(\"192.168.0.0\", \"192.168.0.255\")) {\n+            assertThat(ipValue.isInRange(ipAddress.toUserString()), is(true));\n+        }\n+        assertThat(ipValue.isInRange(\"10.0.0.5\"), is(false));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzYwMw=="}, "originalCommit": {"oid": "45f0c6027321e81a9fff8f427c87ecdfa4dd7447"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjI1NDQ2OnYy", "diffSide": "RIGHT", "path": "features/flows/classification/engine/impl/src/test/java/org/opennms/netmgt/flows/classification/internal/value/IpValueTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMTo0NToxMVrOFppYOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMTo0NToxMVrOFppYOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzg4Mw==", "bodyText": "Should test IPV6 CIDR", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r379213883", "createdAt": "2020-02-14T01:45:11Z", "author": {"login": "Naicisum"}, "path": "features/flows/classification/engine/impl/src/test/java/org/opennms/netmgt/flows/classification/internal/value/IpValueTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020-2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.flows.classification.internal.value;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+import org.junit.Test;\n+import org.opennms.core.network.IPAddress;\n+import org.opennms.core.network.IPAddressRange;\n+\n+public class IpValueTest {\n+\n+    @Test\n+    public void verifyRangedValues() {\n+        final IpValue ipValue = new IpValue(\"10.1.1.1-10.1.1.100\");\n+        final IPAddressRange range = new IPAddressRange(\"10.1.1.1\", \"10.1.1.100\");\n+        for (IPAddress address : range) {\n+            assertThat(ipValue.isInRange(address.toUserString()), is(true));\n+        }\n+    }\n+\n+    @Test\n+    public void verifySingleValue() {\n+        final IpValue ipValue = new IpValue(\"192.168.0.1\");\n+        assertThat(ipValue.isInRange(\"192.168.0.0\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.1\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.2\"), is(false));\n+    }\n+\n+    @Test\n+    public void verifyMultiValues() {\n+        final IpValue ipValue = new IpValue(\"192.168.0.1, 192.168.0.2, 192.168.0.10\");\n+        assertThat(ipValue.isInRange(\"192.168.0.0\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.1\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.2\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.3\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.4\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.5\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.6\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.7\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.8\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.9\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.10\"), is(true));\n+    }\n+\n+    @Test\n+    public void verifyCIDRValue() {\n+        final IpValue ipValue = new IpValue(\"10.0.0.5,192.168.0.0/24\");\n+        for (IPAddress ipAddress : new IPAddressRange(\"192.168.0.0\", \"192.168.0.255\")) {\n+            assertThat(ipValue.isInRange(ipAddress.toUserString()), is(true));\n+        }\n+        assertThat(ipValue.isInRange(\"10.0.0.5\"), is(false));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void verifyCIDRValueNotAllowedInRange() {\n+        new IpValue(\"192.0.0.0/8-192.168.0.0/24\");\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void verifyWildcard() {\n+        new IpValue(\"*\");\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void verifyInvalidIpAddress() {\n+        new IpValue(\"300.400.500.600\");\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void verifyInvalidIpAddressRanges() {\n+        new IpValue(\"192.168.0.1-a.b.c.d\");\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void verifyInvalidIpAddressRangeEndIsBefore() {\n+        new IpValue(\"192.168.10.255-192.168.0.1\");\n+    }\n+\n+    @Test\n+    public void verifySingleValueIpV6() {\n+        final IpValue value = new IpValue(\"2001:0DB8:0:CD30::1\");\n+        assertThat(value.isInRange(\"2001:0DB8:0:CD30::1\"), is(true));\n+        assertThat(value.isInRange(\"2001:0DB8:0:CD30::2\"), is(false));\n+        assertThat(value.isInRange(\"192.168.0.1\"), is(false)); // incompatible, should be false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45f0c6027321e81a9fff8f427c87ecdfa4dd7447"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjI1NTM1OnYy", "diffSide": "RIGHT", "path": "opennms-doc/releasenotes/src/asciidoc/releasenotes/whatsnew.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMTo0NTo0NVrOFppYww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMTo0NTo0NVrOFppYww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxNDAxOQ==", "bodyText": "Update for CIDR", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r379214019", "createdAt": "2020-02-14T01:45:45Z", "author": {"login": "Naicisum"}, "path": "opennms-doc/releasenotes/src/asciidoc/releasenotes/whatsnew.adoc", "diffHunk": "@@ -11,6 +11,13 @@\n \n === Breaking Changes\n \n+The Flow Classification UI accepted invalid ip address values, e.g. `10,192.1,168.1,5.1-160`.\n+When upgrading {opennms-product-name} existing Flow Classification Rules may be considered invalid.\n+In this case they are silently ignored by the Flow Classification Engine.\n+In order to assure no invalid Flow Classification Rules exist, please run the OSGi shell command `opennms-classification:list-invalid-rules` to list all invalid rules.\n+If there are any invalid rules, they must be manually fixed using the Flow Classification UI.\n+For more details, refer to issue https://issues.opennms.org/browse/NMS-12422[NMS-12422].\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45f0c6027321e81a9fff8f427c87ecdfa4dd7447"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1OTgxNDQ1OnYy", "diffSide": "RIGHT", "path": "features/flows/classification/engine/impl/src/main/java/org/opennms/netmgt/flows/classification/internal/value/IpValue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxMjoyMTo1M1rOFrmFPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxMzowMDoyOVrOFrnJ-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI1NzAyMQ==", "bodyText": "The examples should be v6 address or the class name is misleading", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r381257021", "createdAt": "2020-02-19T12:21:53Z", "author": {"login": "fooker"}, "path": "features/flows/classification/engine/impl/src/main/java/org/opennms/netmgt/flows/classification/internal/value/IpValue.java", "diffHunk": "@@ -67,26 +71,149 @@ private void parse(final StringValue input) {\n                 }\n                 // Ensure each range is an ip address\n                 for (StringValue rangedValue : rangedValues) {\n-                    verifyIpAddress(rangedValue);\n+                    if (rangedValue.contains(\"/\")) {\n+                        throw new IllegalArgumentException(\"Ranged value may not contain a CIDR expression\");\n+                    }\n                 }\n-                // Verify the range itself\n-                final IPAddressRange range = new IPAddressRange(rangedValues.get(0).getValue(), rangedValues.get(1).getValue());\n-                ranges.add(range);\n+                ranges.add(new IpAddressRange(rangedValues.get(0), rangedValues.get(1)));\n             } else {\n-                verifyIpAddress(eachValue);\n-                ranges.add(new IPAddressRange(eachValue.getValue(), eachValue.getValue()));\n+                ranges.add(new IpAddressRange(eachValue));\n             }\n         }\n     }\n \n     public boolean isInRange(final String address) {\n-        return ranges.stream().anyMatch(r -> r.contains(address));\n+        return ranges.stream().anyMatch(r -> r.isInRange(address));\n     }\n \n-    private static void verifyIpAddress(final StringValue stringValue) {\n-        Objects.requireNonNull(stringValue);\n-        if (!InetAddresses.isInetAddress(stringValue.getValue())) {\n-            throw new IllegalArgumentException(\"Provided ip address '\" + stringValue.getValue() + \"' is invalid\");\n+    private static class IpAddressRange {\n+\n+        private final IpAddressMatcher matcher;\n+\n+        private IpAddressRange(final StringValue from, final StringValue to) {\n+            this.matcher = new IpAddressRangeMatcher(from.getValue(), to.getValue());\n+        }\n+\n+        private IpAddressRange(final StringValue eachValue) {\n+            if (eachValue.contains(\"/\")) {\n+                this.matcher = new IpV6CidrExpressionMatcher(eachValue.getValue());\n+            } else {\n+                this.matcher = new IpAddressRangeMatcher(eachValue.getValue());\n+            }\n+        }\n+\n+        public boolean isInRange(String input) {\n+            return matcher.matches(input);\n+        }\n+    }\n+\n+    private interface IpAddressMatcher {\n+        boolean matches(String address);\n+    }\n+\n+    private static class IpAddressRangeMatcher implements IpAddressMatcher {\n+\n+        private final IPAddressRange range;\n+\n+        private IpAddressRangeMatcher(final String from, final String to) {\n+            verifyIpAddress(from);\n+            verifyIpAddress(to);\n+            this.range = new IPAddressRange(from, to);\n+        }\n+\n+        public IpAddressRangeMatcher(String value) {\n+            verifyIpAddress(value);\n+            this.range = new IPAddressRange(value);\n+        }\n+\n+        @Override\n+        public boolean matches(String address) {\n+            return range.contains(address);\n+        }\n+\n+        private static void verifyIpAddress(final String value) {\n+            Objects.requireNonNull(value);\n+            if (!InetAddresses.isInetAddress(value)) {\n+                throw new IllegalArgumentException(\"Provided ip address '\" + value + \"' is invalid\");\n+            }\n+        }\n+    }\n+\n+    // Inspired by spring-security-web's IpAddressMatcher\n+    public final static class IpV6CidrExpressionMatcher implements IpAddressMatcher {\n+\n+        private final int nMaskBits;\n+        private final InetAddress requiredAddress;\n+\n+        /**\n+         * Takes a specific IP address or a range specified using the\n+         * IP/Netmask (e.g. 192.168.1.0/24 or 202.24.0.0/14).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02ea7563d0fb02de4fb7d8bf1a521db5e6af31b"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI3NDYxNw==", "bodyText": "Yes, that is true.", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r381274617", "createdAt": "2020-02-19T13:00:29Z", "author": {"login": "mvrueden"}, "path": "features/flows/classification/engine/impl/src/main/java/org/opennms/netmgt/flows/classification/internal/value/IpValue.java", "diffHunk": "@@ -67,26 +71,149 @@ private void parse(final StringValue input) {\n                 }\n                 // Ensure each range is an ip address\n                 for (StringValue rangedValue : rangedValues) {\n-                    verifyIpAddress(rangedValue);\n+                    if (rangedValue.contains(\"/\")) {\n+                        throw new IllegalArgumentException(\"Ranged value may not contain a CIDR expression\");\n+                    }\n                 }\n-                // Verify the range itself\n-                final IPAddressRange range = new IPAddressRange(rangedValues.get(0).getValue(), rangedValues.get(1).getValue());\n-                ranges.add(range);\n+                ranges.add(new IpAddressRange(rangedValues.get(0), rangedValues.get(1)));\n             } else {\n-                verifyIpAddress(eachValue);\n-                ranges.add(new IPAddressRange(eachValue.getValue(), eachValue.getValue()));\n+                ranges.add(new IpAddressRange(eachValue));\n             }\n         }\n     }\n \n     public boolean isInRange(final String address) {\n-        return ranges.stream().anyMatch(r -> r.contains(address));\n+        return ranges.stream().anyMatch(r -> r.isInRange(address));\n     }\n \n-    private static void verifyIpAddress(final StringValue stringValue) {\n-        Objects.requireNonNull(stringValue);\n-        if (!InetAddresses.isInetAddress(stringValue.getValue())) {\n-            throw new IllegalArgumentException(\"Provided ip address '\" + stringValue.getValue() + \"' is invalid\");\n+    private static class IpAddressRange {\n+\n+        private final IpAddressMatcher matcher;\n+\n+        private IpAddressRange(final StringValue from, final StringValue to) {\n+            this.matcher = new IpAddressRangeMatcher(from.getValue(), to.getValue());\n+        }\n+\n+        private IpAddressRange(final StringValue eachValue) {\n+            if (eachValue.contains(\"/\")) {\n+                this.matcher = new IpV6CidrExpressionMatcher(eachValue.getValue());\n+            } else {\n+                this.matcher = new IpAddressRangeMatcher(eachValue.getValue());\n+            }\n+        }\n+\n+        public boolean isInRange(String input) {\n+            return matcher.matches(input);\n+        }\n+    }\n+\n+    private interface IpAddressMatcher {\n+        boolean matches(String address);\n+    }\n+\n+    private static class IpAddressRangeMatcher implements IpAddressMatcher {\n+\n+        private final IPAddressRange range;\n+\n+        private IpAddressRangeMatcher(final String from, final String to) {\n+            verifyIpAddress(from);\n+            verifyIpAddress(to);\n+            this.range = new IPAddressRange(from, to);\n+        }\n+\n+        public IpAddressRangeMatcher(String value) {\n+            verifyIpAddress(value);\n+            this.range = new IPAddressRange(value);\n+        }\n+\n+        @Override\n+        public boolean matches(String address) {\n+            return range.contains(address);\n+        }\n+\n+        private static void verifyIpAddress(final String value) {\n+            Objects.requireNonNull(value);\n+            if (!InetAddresses.isInetAddress(value)) {\n+                throw new IllegalArgumentException(\"Provided ip address '\" + value + \"' is invalid\");\n+            }\n+        }\n+    }\n+\n+    // Inspired by spring-security-web's IpAddressMatcher\n+    public final static class IpV6CidrExpressionMatcher implements IpAddressMatcher {\n+\n+        private final int nMaskBits;\n+        private final InetAddress requiredAddress;\n+\n+        /**\n+         * Takes a specific IP address or a range specified using the\n+         * IP/Netmask (e.g. 192.168.1.0/24 or 202.24.0.0/14).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI1NzAyMQ=="}, "originalCommit": {"oid": "e02ea7563d0fb02de4fb7d8bf1a521db5e6af31b"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1OTgzNDMxOnYy", "diffSide": "RIGHT", "path": "features/flows/classification/engine/impl/src/main/java/org/opennms/netmgt/flows/classification/internal/value/IpValue.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxMjoyOTowNFrOFrmRbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxMjoyOTowNFrOFrmRbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI2MDE0MQ==", "bodyText": "The calculation of the mask can be moved to the constructor, right?", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r381260141", "createdAt": "2020-02-19T12:29:04Z", "author": {"login": "fooker"}, "path": "features/flows/classification/engine/impl/src/main/java/org/opennms/netmgt/flows/classification/internal/value/IpValue.java", "diffHunk": "@@ -67,26 +71,149 @@ private void parse(final StringValue input) {\n                 }\n                 // Ensure each range is an ip address\n                 for (StringValue rangedValue : rangedValues) {\n-                    verifyIpAddress(rangedValue);\n+                    if (rangedValue.contains(\"/\")) {\n+                        throw new IllegalArgumentException(\"Ranged value may not contain a CIDR expression\");\n+                    }\n                 }\n-                // Verify the range itself\n-                final IPAddressRange range = new IPAddressRange(rangedValues.get(0).getValue(), rangedValues.get(1).getValue());\n-                ranges.add(range);\n+                ranges.add(new IpAddressRange(rangedValues.get(0), rangedValues.get(1)));\n             } else {\n-                verifyIpAddress(eachValue);\n-                ranges.add(new IPAddressRange(eachValue.getValue(), eachValue.getValue()));\n+                ranges.add(new IpAddressRange(eachValue));\n             }\n         }\n     }\n \n     public boolean isInRange(final String address) {\n-        return ranges.stream().anyMatch(r -> r.contains(address));\n+        return ranges.stream().anyMatch(r -> r.isInRange(address));\n     }\n \n-    private static void verifyIpAddress(final StringValue stringValue) {\n-        Objects.requireNonNull(stringValue);\n-        if (!InetAddresses.isInetAddress(stringValue.getValue())) {\n-            throw new IllegalArgumentException(\"Provided ip address '\" + stringValue.getValue() + \"' is invalid\");\n+    private static class IpAddressRange {\n+\n+        private final IpAddressMatcher matcher;\n+\n+        private IpAddressRange(final StringValue from, final StringValue to) {\n+            this.matcher = new IpAddressRangeMatcher(from.getValue(), to.getValue());\n+        }\n+\n+        private IpAddressRange(final StringValue eachValue) {\n+            if (eachValue.contains(\"/\")) {\n+                this.matcher = new IpV6CidrExpressionMatcher(eachValue.getValue());\n+            } else {\n+                this.matcher = new IpAddressRangeMatcher(eachValue.getValue());\n+            }\n+        }\n+\n+        public boolean isInRange(String input) {\n+            return matcher.matches(input);\n+        }\n+    }\n+\n+    private interface IpAddressMatcher {\n+        boolean matches(String address);\n+    }\n+\n+    private static class IpAddressRangeMatcher implements IpAddressMatcher {\n+\n+        private final IPAddressRange range;\n+\n+        private IpAddressRangeMatcher(final String from, final String to) {\n+            verifyIpAddress(from);\n+            verifyIpAddress(to);\n+            this.range = new IPAddressRange(from, to);\n+        }\n+\n+        public IpAddressRangeMatcher(String value) {\n+            verifyIpAddress(value);\n+            this.range = new IPAddressRange(value);\n+        }\n+\n+        @Override\n+        public boolean matches(String address) {\n+            return range.contains(address);\n+        }\n+\n+        private static void verifyIpAddress(final String value) {\n+            Objects.requireNonNull(value);\n+            if (!InetAddresses.isInetAddress(value)) {\n+                throw new IllegalArgumentException(\"Provided ip address '\" + value + \"' is invalid\");\n+            }\n+        }\n+    }\n+\n+    // Inspired by spring-security-web's IpAddressMatcher\n+    public final static class IpV6CidrExpressionMatcher implements IpAddressMatcher {\n+\n+        private final int nMaskBits;\n+        private final InetAddress requiredAddress;\n+\n+        /**\n+         * Takes a specific IP address or a range specified using the\n+         * IP/Netmask (e.g. 192.168.1.0/24 or 202.24.0.0/14).\n+         *\n+         * @param ipAddress the address or range of addresses from which the request must come.\n+         */\n+        public IpV6CidrExpressionMatcher(String ipAddress) {\n+            if (ipAddress.indexOf('/') > 0) {\n+                String[] addressAndMask = StringUtils.split(ipAddress, \"/\");\n+                ipAddress = addressAndMask[0];\n+                nMaskBits = Integer.parseInt(addressAndMask[1]);\n+            } else {\n+                nMaskBits = -1;\n+            }\n+            requiredAddress = parseAddress(ipAddress);\n+            boolean isIpV6 = requiredAddress instanceof Inet6Address;\n+            rangeCheck(nMaskBits, 0, isIpV6 ? 128 : 32);\n+        }\n+\n+        @Override\n+        public boolean matches(String address) {\n+            InetAddress remoteAddress = parseAddress(address);\n+\n+            if (!requiredAddress.getClass().equals(remoteAddress.getClass())) {\n+                return false;\n+            }\n+\n+            if (nMaskBits < 0) {\n+                return remoteAddress.equals(requiredAddress);\n+            }\n+\n+            byte[] remAddr = remoteAddress.getAddress();\n+            byte[] reqAddr = requiredAddress.getAddress();\n+\n+            int oddBits = nMaskBits % 8;\n+            int nMaskBytes = nMaskBits/8 + (oddBits == 0 ? 0 : 1);\n+            byte[] mask = new byte[nMaskBytes];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02ea7563d0fb02de4fb7d8bf1a521db5e6af31b"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTc1NDYyOnYy", "diffSide": "RIGHT", "path": "features/flows/classification/engine/impl/src/main/java/org/opennms/netmgt/flows/classification/internal/value/IpValue.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTo0OToyMFrOFr44lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTo0OToyMFrOFr44lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2NTA3OA==", "bodyText": "Is this class even needed? As IpAddressMatcher already dispatches, it can be included directly in the parent class. And it would solve the IpAddressRange vs IPAddressRange conflict.", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r381565078", "createdAt": "2020-02-19T21:49:20Z", "author": {"login": "fooker"}, "path": "features/flows/classification/engine/impl/src/main/java/org/opennms/netmgt/flows/classification/internal/value/IpValue.java", "diffHunk": "@@ -67,26 +71,143 @@ private void parse(final StringValue input) {\n                 }\n                 // Ensure each range is an ip address\n                 for (StringValue rangedValue : rangedValues) {\n-                    verifyIpAddress(rangedValue);\n+                    if (rangedValue.contains(\"/\")) {\n+                        throw new IllegalArgumentException(\"Ranged value may not contain a CIDR expression\");\n+                    }\n                 }\n-                // Verify the range itself\n-                final IPAddressRange range = new IPAddressRange(rangedValues.get(0).getValue(), rangedValues.get(1).getValue());\n-                ranges.add(range);\n+                ranges.add(new IpAddressRange(rangedValues.get(0), rangedValues.get(1)));\n             } else {\n-                verifyIpAddress(eachValue);\n-                ranges.add(new IPAddressRange(eachValue.getValue(), eachValue.getValue()));\n+                ranges.add(new IpAddressRange(eachValue));\n             }\n         }\n     }\n \n     public boolean isInRange(final String address) {\n-        return ranges.stream().anyMatch(r -> r.contains(address));\n+        return ranges.stream().anyMatch(r -> r.isInRange(address));\n     }\n \n-    private static void verifyIpAddress(final StringValue stringValue) {\n-        Objects.requireNonNull(stringValue);\n-        if (!InetAddresses.isInetAddress(stringValue.getValue())) {\n-            throw new IllegalArgumentException(\"Provided ip address '\" + stringValue.getValue() + \"' is invalid\");\n+    private static class IpAddressRange {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f73aa29b0bbdbaed84ed82f189b122decddd50f"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 747, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}