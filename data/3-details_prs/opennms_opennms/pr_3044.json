{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4NzYzMTM4", "number": 3044, "title": "NMS-12736: Add documentation for TcpListener", "bodyText": "All Contributors\n\n Have you read and followed our Contribution Guidelines?\n Have you made an issue in the OpenNMS issue tracker?If so, you should:\n\nupdate the title of this PR to be of the format: ${JIRA-ISSUE-NUMBER}: subject of pull request\nupdate the JIRA link at the bottom of this comment to refer to the real issue number\nprefix your commit messages with the issue number, if possible\n\n\n Have you made a comment in that issue which points back to this PR?\n Have you updated the JIRA link at the bottom of this comment to link to your issue?\n If this is a new or updated feature, is there documentation for the new behavior?\n If this is new code, are there unit and/or integration tests?\n If this PR targets a foundation-* branch, does it avoid changing files in $OPENNMS_HOME/etc/?\n\nPull Request Process\nOne or more reviewers should be assigned to each PR.\nIf you know that a particular person is subject matter expert in the area your PR affects, feel free to assign one or more reviewers when you create this PR, otherwise reviewers will be assigned for you.\nIf you have made additions or changes to the documentation, or if you need documentation for these code changes, please make sure a technical writer has looked it over.\nOnce the reviewer(s) accept the PR and the branch passes continuous integration, the PR is eligible for merge.\nAt that time, if you have commit access (are an OpenNMS Group employee or a member of the Order of the Green Polo) you are welcome to merge the PR.\nOtherwise, a reviewer can merge it for you.\nThanks for taking time to contribute!\nExternal References\n\nJIRA (Issue Tracker): http://issues.opennms.org/browse/NMS-12736", "createdAt": "2020-06-23T19:05:03Z", "url": "https://github.com/OpenNMS/opennms/pull/3044", "merged": true, "mergeCommit": {"oid": "6de0612c11208da786599762098aa7ebd586dba3"}, "closed": true, "closedAt": "2020-07-06T13:28:23Z", "author": {"login": "Bonrob2"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABct3Yr6gH2gAyNDM4NzYzMTM4OjE3ZTI4MTAxYzBlMmVlNTc5M2JhOTc4Y2RlNjdjNTc0Y2E5ODlmOWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcwl8WPgFqTQ0MDY1NDUxNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "17e28101c0e2ee5793ba978cde67c574ca989f9b", "author": {"user": {"login": "Bonrob2", "name": null}}, "url": "https://github.com/OpenNMS/opennms/commit/17e28101c0e2ee5793ba978cde67c574ca989f9b", "committedDate": "2020-06-22T21:04:25Z", "message": "NMS-12666: Updating Developer's Guide\n\nNMS-12666: In addressing a different Jira issue, I thought I needed to work in the Developer's Guide. After fixing some other issues with the guide including typos and broken links, I realized I need to address the other issue in the Admin Guide."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5dd4b201ab709e84fff4afa9f6f48df78f70c17c", "author": {"user": {"login": "Bonrob2", "name": null}}, "url": "https://github.com/OpenNMS/opennms/commit/5dd4b201ab709e84fff4afa9f6f48df78f70c17c", "committedDate": "2020-06-22T21:51:38Z", "message": "NMS-12736: document tcplistener\n\nNMS-12736: Adding examples of tcplistener as per customer request."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77112ec5ea2b5fd8e604540bccac3e4a68092601", "author": {"user": {"login": "Bonrob2", "name": null}}, "url": "https://github.com/OpenNMS/opennms/commit/77112ec5ea2b5fd8e604540bccac3e4a68092601", "committedDate": "2020-06-23T15:03:09Z", "message": "NMS-12736: tcplistener doc updates\n\nNMS-12736: tcplistener doc updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845", "author": {"user": {"login": "Bonrob2", "name": null}}, "url": "https://github.com/OpenNMS/opennms/commit/79b01bdcdde6bef1d7cdac586797ffb85cf5b845", "committedDate": "2020-06-23T19:02:52Z", "message": "NMS-12736 - document TCPlistener\n\nNMS-12736: added examples on configuring TCPlistener in BMP and IPFIX."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2ODAwODYw", "url": "https://github.com/OpenNMS/opennms/pull/3044#pullrequestreview-436800860", "createdAt": "2020-06-24T16:13:16Z", "commit": {"oid": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNjoxMzoxNlrOGoZVUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNjoxNzo1M1rOGoZgZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAxMTI4Mw==", "bodyText": "Is this true? As far I remember we have parsers on the Minion as described here: https://docs.opennms.org/opennms/releases/26.1.1/guide-admin/guide-admin.html#_push_sensor_data_through_minion\n@fooker can you verify this here?", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445011283", "createdAt": "2020-06-24T16:13:16Z", "author": {"login": "indigo423"}, "path": "opennms-doc/guide-admin/src/asciidoc/text/telemetryd/introduction.adoc", "diffHunk": "@@ -2,68 +2,80 @@\n // Allow GitHub image rendering\n :imagesdir: ../../images\n \n-The telemetry daemon (telemetryd) provides an extensible framework that can be used to handle sensor data pushed to _{opennms-product-name}_.\n-The framework can be used to implement support for a variety of applications which use different protocols to transfer metrics.\n-Using _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n+The telemetry daemon (telemetryd) provides an extensible framework you can use to handle sensor data pushed to _{opennms-product-name}_.\n+Use the framework to support applications that use different protocols to transfer metrics.\n+With _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n \n .Generic component overview of components in telemetryd\n image::telemetryd/telemetryd-overview.png[]\n \n The configuration is split in two parts.\n-_Listeners_ and attached _Parsers_ on one side, are responsible for receiving telemetry data transported over a specific protocol and parse the protocol according to its specification.\n+_Listeners_ and attached _Parsers_ on one side, receive telemetry data transported over a specific protocol and parse the protocol according to its specification.\n On the other side, _Adapters_ pick up the parsed data and enrich it before persisting it.\n \n-_Queues_ are used to transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n+_Queues_ transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n \n === _Listeners_ and _Parsers_\n-_Listeners_ are responsible for receiving sensor data from some external source and hand them off to _Parsers_ which handles the transport protocol format and extracts the transported data.\n+_Listeners_ receive sensor data from an external source and hand them off to _Parsers_, which handle the transport protocol format and extract the transported data.\n \n A _Listener_ does the transport protocol handling like opening a socket and accepting incoming connections.\n-The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extract all available information out of the received message.\n+The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extracts all available information out of the received message.\n For further processing, the extracted data is handed over to the configured queue.\n \n-For example: A _Listener_ may open a UDP socket for receiving packets and a assigned _Parser_ parses the incoming IPFix packets.\n+For example: a _Listener_ may open a UDP socket for receiving packets and an assigned _Parser_ parses the incoming IPFIX packets.\n \n-_Parsers_ and _Listeners_ must work together in a tight manner.\n-Therefore they can not be combined in any possible combination.\n-Which _Parser_ is supported by which _Listener_ is described in the documentation of each _Parser_ accordingly.\n+_Parsers_ and _Listeners_ must work together closely.\n+Therefore, they can not be combined in any random way.\n+Which _Parser_ is supported by which _Listener_ is described in the documentation of each respective _Parser_.\n \n-TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. It specifies the maximum delta in seconds between exporter and Minion timestamps. If violated an alarm will be generated for the exporting device. The default value is 0, so clock skew detection is disabled. Furthermore, a parameter `clockSkewEventRate` can be used to rate-limit clock skew events. The default is `3600` seconds, so every hour an event will be sent.\n+TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. \n+It specifies the maximum delta in seconds between exporter and Minion time stamps. \n+If violated, an alarm will be generated for the exporting device. \n+The default value is 0, so clock skew detection is disabled. \n+Furthermore, a parameter `clockSkewEventRate` can be used to rate-limit clock skew events.\n+The default is `3600` seconds, so every hour an event will be sent.\n+\n+==== Working with Minions\n+While {opennms-product-name} can operate as both a listener and a parser, Minion cannot.\n+A Minion receives data (listens). \n+Listeners on Minion must use parsers on {opennms-product-name} or Sentinel to process the data. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAxNDExOA==", "bodyText": "line break", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445014118", "createdAt": "2020-06-24T16:17:53Z", "author": {"login": "indigo423"}, "path": "opennms-doc/guide-development/src/asciidoc/text/docs/include-source.adoc", "diffHunk": "@@ -6,15 +6,15 @@\n === Code Snippets\n \n You can include code snippets, configuration- or source code files in the documentation.\n-You can enable syntax highlighting by providing the given language parameter, this will work on source code or configuration.\n+You can enable syntax highlighting by providing the given language parameter. This will work on source code or configuration.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3ODI5NDY2", "url": "https://github.com/OpenNMS/opennms/pull/3044#pullrequestreview-437829466", "createdAt": "2020-06-25T20:21:02Z", "commit": {"oid": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMDoyMTowMlrOGpKapw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMDozMDoyMFrOGpKsmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxNTQ2Mw==", "bodyText": "While being here already, it is quite a strange place to mentioned it here. This feature is only supported by the netflow and ipfix parsers.", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445815463", "createdAt": "2020-06-25T20:21:02Z", "author": {"login": "fooker"}, "path": "opennms-doc/guide-admin/src/asciidoc/text/telemetryd/introduction.adoc", "diffHunk": "@@ -2,68 +2,80 @@\n // Allow GitHub image rendering\n :imagesdir: ../../images\n \n-The telemetry daemon (telemetryd) provides an extensible framework that can be used to handle sensor data pushed to _{opennms-product-name}_.\n-The framework can be used to implement support for a variety of applications which use different protocols to transfer metrics.\n-Using _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n+The telemetry daemon (telemetryd) provides an extensible framework you can use to handle sensor data pushed to _{opennms-product-name}_.\n+Use the framework to support applications that use different protocols to transfer metrics.\n+With _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n \n .Generic component overview of components in telemetryd\n image::telemetryd/telemetryd-overview.png[]\n \n The configuration is split in two parts.\n-_Listeners_ and attached _Parsers_ on one side, are responsible for receiving telemetry data transported over a specific protocol and parse the protocol according to its specification.\n+_Listeners_ and attached _Parsers_ on one side, receive telemetry data transported over a specific protocol and parse the protocol according to its specification.\n On the other side, _Adapters_ pick up the parsed data and enrich it before persisting it.\n \n-_Queues_ are used to transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n+_Queues_ transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n \n === _Listeners_ and _Parsers_\n-_Listeners_ are responsible for receiving sensor data from some external source and hand them off to _Parsers_ which handles the transport protocol format and extracts the transported data.\n+_Listeners_ receive sensor data from an external source and hand them off to _Parsers_, which handle the transport protocol format and extract the transported data.\n \n A _Listener_ does the transport protocol handling like opening a socket and accepting incoming connections.\n-The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extract all available information out of the received message.\n+The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extracts all available information out of the received message.\n For further processing, the extracted data is handed over to the configured queue.\n \n-For example: A _Listener_ may open a UDP socket for receiving packets and a assigned _Parser_ parses the incoming IPFix packets.\n+For example: a _Listener_ may open a UDP socket for receiving packets and an assigned _Parser_ parses the incoming IPFIX packets.\n \n-_Parsers_ and _Listeners_ must work together in a tight manner.\n-Therefore they can not be combined in any possible combination.\n-Which _Parser_ is supported by which _Listener_ is described in the documentation of each _Parser_ accordingly.\n+_Parsers_ and _Listeners_ must work together closely.\n+Therefore, they can not be combined in any random way.\n+Which _Parser_ is supported by which _Listener_ is described in the documentation of each respective _Parser_.\n \n-TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. It specifies the maximum delta in seconds between exporter and Minion timestamps. If violated an alarm will be generated for the exporting device. The default value is 0, so clock skew detection is disabled. Furthermore, a parameter `clockSkewEventRate` can be used to rate-limit clock skew events. The default is `3600` seconds, so every hour an event will be sent.\n+TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxNTcwMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If violated, an alarm will be generated for the exporting device. \n          \n          \n            \n            If exceeded, an alarm will be generated for the exporting device.", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445815701", "createdAt": "2020-06-25T20:21:29Z", "author": {"login": "fooker"}, "path": "opennms-doc/guide-admin/src/asciidoc/text/telemetryd/introduction.adoc", "diffHunk": "@@ -2,68 +2,80 @@\n // Allow GitHub image rendering\n :imagesdir: ../../images\n \n-The telemetry daemon (telemetryd) provides an extensible framework that can be used to handle sensor data pushed to _{opennms-product-name}_.\n-The framework can be used to implement support for a variety of applications which use different protocols to transfer metrics.\n-Using _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n+The telemetry daemon (telemetryd) provides an extensible framework you can use to handle sensor data pushed to _{opennms-product-name}_.\n+Use the framework to support applications that use different protocols to transfer metrics.\n+With _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n \n .Generic component overview of components in telemetryd\n image::telemetryd/telemetryd-overview.png[]\n \n The configuration is split in two parts.\n-_Listeners_ and attached _Parsers_ on one side, are responsible for receiving telemetry data transported over a specific protocol and parse the protocol according to its specification.\n+_Listeners_ and attached _Parsers_ on one side, receive telemetry data transported over a specific protocol and parse the protocol according to its specification.\n On the other side, _Adapters_ pick up the parsed data and enrich it before persisting it.\n \n-_Queues_ are used to transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n+_Queues_ transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n \n === _Listeners_ and _Parsers_\n-_Listeners_ are responsible for receiving sensor data from some external source and hand them off to _Parsers_ which handles the transport protocol format and extracts the transported data.\n+_Listeners_ receive sensor data from an external source and hand them off to _Parsers_, which handle the transport protocol format and extract the transported data.\n \n A _Listener_ does the transport protocol handling like opening a socket and accepting incoming connections.\n-The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extract all available information out of the received message.\n+The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extracts all available information out of the received message.\n For further processing, the extracted data is handed over to the configured queue.\n \n-For example: A _Listener_ may open a UDP socket for receiving packets and a assigned _Parser_ parses the incoming IPFix packets.\n+For example: a _Listener_ may open a UDP socket for receiving packets and an assigned _Parser_ parses the incoming IPFIX packets.\n \n-_Parsers_ and _Listeners_ must work together in a tight manner.\n-Therefore they can not be combined in any possible combination.\n-Which _Parser_ is supported by which _Listener_ is described in the documentation of each _Parser_ accordingly.\n+_Parsers_ and _Listeners_ must work together closely.\n+Therefore, they can not be combined in any random way.\n+Which _Parser_ is supported by which _Listener_ is described in the documentation of each respective _Parser_.\n \n-TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. It specifies the maximum delta in seconds between exporter and Minion timestamps. If violated an alarm will be generated for the exporting device. The default value is 0, so clock skew detection is disabled. Furthermore, a parameter `clockSkewEventRate` can be used to rate-limit clock skew events. The default is `3600` seconds, so every hour an event will be sent.\n+TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. \n+It specifies the maximum delta in seconds between exporter and Minion time stamps. \n+If violated, an alarm will be generated for the exporting device. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxNjcwNQ==", "bodyText": "@indigo423 has a point there. The listeners and parsers run on the minion whereas the adapters are executed on the sentinel. The main opennms instance can be both.", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445816705", "createdAt": "2020-06-25T20:23:33Z", "author": {"login": "fooker"}, "path": "opennms-doc/guide-admin/src/asciidoc/text/telemetryd/introduction.adoc", "diffHunk": "@@ -2,68 +2,80 @@\n // Allow GitHub image rendering\n :imagesdir: ../../images\n \n-The telemetry daemon (telemetryd) provides an extensible framework that can be used to handle sensor data pushed to _{opennms-product-name}_.\n-The framework can be used to implement support for a variety of applications which use different protocols to transfer metrics.\n-Using _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n+The telemetry daemon (telemetryd) provides an extensible framework you can use to handle sensor data pushed to _{opennms-product-name}_.\n+Use the framework to support applications that use different protocols to transfer metrics.\n+With _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n \n .Generic component overview of components in telemetryd\n image::telemetryd/telemetryd-overview.png[]\n \n The configuration is split in two parts.\n-_Listeners_ and attached _Parsers_ on one side, are responsible for receiving telemetry data transported over a specific protocol and parse the protocol according to its specification.\n+_Listeners_ and attached _Parsers_ on one side, receive telemetry data transported over a specific protocol and parse the protocol according to its specification.\n On the other side, _Adapters_ pick up the parsed data and enrich it before persisting it.\n \n-_Queues_ are used to transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n+_Queues_ transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n \n === _Listeners_ and _Parsers_\n-_Listeners_ are responsible for receiving sensor data from some external source and hand them off to _Parsers_ which handles the transport protocol format and extracts the transported data.\n+_Listeners_ receive sensor data from an external source and hand them off to _Parsers_, which handle the transport protocol format and extract the transported data.\n \n A _Listener_ does the transport protocol handling like opening a socket and accepting incoming connections.\n-The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extract all available information out of the received message.\n+The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extracts all available information out of the received message.\n For further processing, the extracted data is handed over to the configured queue.\n \n-For example: A _Listener_ may open a UDP socket for receiving packets and a assigned _Parser_ parses the incoming IPFix packets.\n+For example: a _Listener_ may open a UDP socket for receiving packets and an assigned _Parser_ parses the incoming IPFIX packets.\n \n-_Parsers_ and _Listeners_ must work together in a tight manner.\n-Therefore they can not be combined in any possible combination.\n-Which _Parser_ is supported by which _Listener_ is described in the documentation of each _Parser_ accordingly.\n+_Parsers_ and _Listeners_ must work together closely.\n+Therefore, they can not be combined in any random way.\n+Which _Parser_ is supported by which _Listener_ is described in the documentation of each respective _Parser_.\n \n-TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. It specifies the maximum delta in seconds between exporter and Minion timestamps. If violated an alarm will be generated for the exporting device. The default value is 0, so clock skew detection is disabled. Furthermore, a parameter `clockSkewEventRate` can be used to rate-limit clock skew events. The default is `3600` seconds, so every hour an event will be sent.\n+TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. \n+It specifies the maximum delta in seconds between exporter and Minion time stamps. \n+If violated, an alarm will be generated for the exporting device. \n+The default value is 0, so clock skew detection is disabled. \n+Furthermore, a parameter `clockSkewEventRate` can be used to rate-limit clock skew events.\n+The default is `3600` seconds, so every hour an event will be sent.\n+\n+==== Working with Minions\n+While {opennms-product-name} can operate as both a listener and a parser, Minion cannot.\n+A Minion receives data (listens). \n+Listeners on Minion must use parsers on {opennms-product-name} or Sentinel to process the data. ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAxMTI4Mw=="}, "originalCommit": {"oid": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxNjg5OA==", "bodyText": "Is there something missing?", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445816898", "createdAt": "2020-06-25T20:23:56Z", "author": {"login": "fooker"}, "path": "opennms-doc/guide-admin/src/asciidoc/text/telemetryd/introduction.adoc", "diffHunk": "@@ -2,68 +2,80 @@\n // Allow GitHub image rendering\n :imagesdir: ../../images\n \n-The telemetry daemon (telemetryd) provides an extensible framework that can be used to handle sensor data pushed to _{opennms-product-name}_.\n-The framework can be used to implement support for a variety of applications which use different protocols to transfer metrics.\n-Using _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n+The telemetry daemon (telemetryd) provides an extensible framework you can use to handle sensor data pushed to _{opennms-product-name}_.\n+Use the framework to support applications that use different protocols to transfer metrics.\n+With _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n \n .Generic component overview of components in telemetryd\n image::telemetryd/telemetryd-overview.png[]\n \n The configuration is split in two parts.\n-_Listeners_ and attached _Parsers_ on one side, are responsible for receiving telemetry data transported over a specific protocol and parse the protocol according to its specification.\n+_Listeners_ and attached _Parsers_ on one side, receive telemetry data transported over a specific protocol and parse the protocol according to its specification.\n On the other side, _Adapters_ pick up the parsed data and enrich it before persisting it.\n \n-_Queues_ are used to transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n+_Queues_ transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n \n === _Listeners_ and _Parsers_\n-_Listeners_ are responsible for receiving sensor data from some external source and hand them off to _Parsers_ which handles the transport protocol format and extracts the transported data.\n+_Listeners_ receive sensor data from an external source and hand them off to _Parsers_, which handle the transport protocol format and extract the transported data.\n \n A _Listener_ does the transport protocol handling like opening a socket and accepting incoming connections.\n-The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extract all available information out of the received message.\n+The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extracts all available information out of the received message.\n For further processing, the extracted data is handed over to the configured queue.\n \n-For example: A _Listener_ may open a UDP socket for receiving packets and a assigned _Parser_ parses the incoming IPFix packets.\n+For example: a _Listener_ may open a UDP socket for receiving packets and an assigned _Parser_ parses the incoming IPFIX packets.\n \n-_Parsers_ and _Listeners_ must work together in a tight manner.\n-Therefore they can not be combined in any possible combination.\n-Which _Parser_ is supported by which _Listener_ is described in the documentation of each _Parser_ accordingly.\n+_Parsers_ and _Listeners_ must work together closely.\n+Therefore, they can not be combined in any random way.\n+Which _Parser_ is supported by which _Listener_ is described in the documentation of each respective _Parser_.\n \n-TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. It specifies the maximum delta in seconds between exporter and Minion timestamps. If violated an alarm will be generated for the exporting device. The default value is 0, so clock skew detection is disabled. Furthermore, a parameter `clockSkewEventRate` can be used to rate-limit clock skew events. The default is `3600` seconds, so every hour an event will be sent.\n+TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. \n+It specifies the maximum delta in seconds between exporter and Minion time stamps. \n+If violated, an alarm will be generated for the exporting device. \n+The default value is 0, so clock skew detection is disabled. \n+Furthermore, a parameter `clockSkewEventRate` can be used to rate-limit clock skew events.\n+The default is `3600` seconds, so every hour an event will be sent.\n+\n+==== Working with Minions\n+While {opennms-product-name} can operate as both a listener and a parser, Minion cannot.\n+A Minion receives data (listens). \n+Listeners on Minion must use parsers on {opennms-product-name} or Sentinel to process the data. \n+\n+Be aware that", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxODg4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            admin@minion()> config:property-set parsers.0.class-name org.opennms.netmgt.telemetry.protocols.common.parser.ForwardParser\n          \n          \n            \n            admin@minion()> config:property-set parsers.0.class-name org.opennms.netmgt.telemetry.protocols.bmp.parser.BmpParser", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445818887", "createdAt": "2020-06-25T20:27:57Z", "author": {"login": "fooker"}, "path": "opennms-doc/guide-admin/src/asciidoc/text/telemetryd/protocols/bmp.adoc", "diffHunk": "@@ -32,6 +32,25 @@ The BMP Parser accepts BMP connections from router packets using a <<telemetryd-\n | `bulkhead.maxWaitDurationMs`  | Limits the amount of time to wait for a saturated bulkhead (in milliseconds). | no       | 5 Minutes\n |===\n \n+===== Configure BMP Listener on a Minion\n+\n+To enable and configure a _TCP Listener_ for BMP on Minion, connect to the _Karaf Console_ and set the following properties:\n+\n+[source]\n+----\n+$ ssh -p 8201 admin@localhost\n+...\n+admin@minion()> config:edit --alias tcp-5000 --factory org.opennms.features.telemetry.listeners\n+admin@minion()> config:property-set name BMP\n+admin@minion()> config:property-set class-name org.opennms.netmgt.telemetry.listeners.TcpListener\n+admin@minion()> config:property-set parameters.port 50000\n+admin@minion()> config:property-set parsers.0.name BMP \n+admin@minion()> config:property-set parsers.0.class-name org.opennms.netmgt.telemetry.protocols.common.parser.ForwardParser", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxOTcyNg==", "bodyText": "Isn't \"timestamp\" a single word as it's used as a technical term?", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445819726", "createdAt": "2020-06-25T20:29:40Z", "author": {"login": "fooker"}, "path": "opennms-doc/guide-admin/src/asciidoc/text/telemetryd/protocols/ipfix.adoc", "diffHunk": "@@ -25,8 +24,8 @@ The IPFIX UDP Parser supports protocol detection.\n [options=\"header, autowidth\"]\n |===\n | Parameter             | Description                                                                    | Required | Default value\n-| `templateTimeout`     | Templates must be re-declared in the given duration or they will be dropped    | no       | 30 minutes\n-| `maxClockSkew`        | The maximum delta in seconds between exporter and Minion timestamps.       | no       | 0\n+| `templateTimeout`     | Templates must be redeclared in the given duration or they will be dropped.    | no       | 30 minutes\n+| `maxClockSkew`        | The maximum delta in seconds between exporter and Minion time stamps.       | no       | 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgyMDA1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            admin@minion()> config:property-set parsers.0.class-name org.opennms.netmgt.telemetry.protocols.common.parser.ForwardParser\n          \n          \n            \n            admin@minion()> config:property-set parsers.0.class-name org.opennms.netmgt.telemetry.protocols.netflow.parser.IpfixTcpParser", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445820056", "createdAt": "2020-06-25T20:30:20Z", "author": {"login": "fooker"}, "path": "opennms-doc/guide-admin/src/asciidoc/text/telemetryd/protocols/ipfix.adoc", "diffHunk": "@@ -48,12 +47,31 @@ The IPFIX TCP Parser accepts packets received by a <<telemetryd-listener-tcp, TC\n \n This parser does not currently have any configurable parameters.\n \n+===== Configure IPFIX Listener on a Minion\n+\n+To enable and configure a _TCP Listener_ for IPFIX on Minion, connect to the _Karaf Console_ and set the following properties:\n+\n+[source]\n+----\n+$ ssh -p 8201 admin@localhost\n+...\n+admin@minion()> config:edit --alias tcp-5000 --factory org.opennms.features.telemetry.listeners\n+admin@minion()> config:property-set name IPFIX\n+admin@minion()> config:property-set class-name org.opennms.netmgt.telemetry.listeners.TcpListener\n+admin@minion()> config:property-set parameters.port 50000\n+admin@minion()> config:property-set parsers.0.name IPFIX \n+admin@minion()> config:property-set parsers.0.class-name org.opennms.netmgt.telemetry.protocols.common.parser.ForwardParser", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35fb26b4841669cf7dc96e532dd26ce9ba241397", "author": {"user": {"login": "Bonrob2", "name": null}}, "url": "https://github.com/OpenNMS/opennms/commit/35fb26b4841669cf7dc96e532dd26ce9ba241397", "committedDate": "2020-06-26T15:10:23Z", "message": "NMS-12736: add docs for TCP listener\n\nNMS-12736: updated tcp listener documentatation based on PR feedback."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "373f959a47be944e737cbb0d9560798da793f55b", "author": {"user": {"login": "Bonrob2", "name": null}}, "url": "https://github.com/OpenNMS/opennms/commit/373f959a47be944e737cbb0d9560798da793f55b", "committedDate": "2020-06-26T15:15:34Z", "message": "NMS-12736: updated developer guide\n\nNMS-12736: updated developer guide to address feedback. Line space break."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "640853180783cb0a14df572e898c9dec1aec311c", "author": {"user": {"login": "Bonrob2", "name": null}}, "url": "https://github.com/OpenNMS/opennms/commit/640853180783cb0a14df572e898c9dec1aec311c", "committedDate": "2020-06-26T21:11:56Z", "message": "NMS-12736:tcplistener doc updates\n\nNMS-12736:tcplistener updates - to address feedback from Dustin."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNjU0NTE1", "url": "https://github.com/OpenNMS/opennms/pull/3044#pullrequestreview-440654515", "createdAt": "2020-07-01T08:26:51Z", "commit": {"oid": "640853180783cb0a14df572e898c9dec1aec311c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3698, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}