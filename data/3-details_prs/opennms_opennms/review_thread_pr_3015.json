{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5NzY5Mjcz", "number": 3015, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMjowMzozNlrOD9xEhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDoyMDoyOFrOD-PhSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDkzNzAyOnYy", "diffSide": "RIGHT", "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/RemotePollerd.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMjowMzozNlrOGXdI5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODowNjo1NVrOGXsgWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0Nzg0NA==", "bodyText": "Do we need to enforce storeByGroup here?", "url": "https://github.com/OpenNMS/opennms/pull/3015#discussion_r427247844", "createdAt": "2020-05-19T12:03:36Z", "author": {"login": "christianpape"}, "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/RemotePollerd.java", "diffHunk": "@@ -321,25 +327,52 @@ public void saveResponseTimeData(final String locationName, final OnmsMonitoredS\n             return;\n         }\n \n-        // FIXME: We don't need to recompute this everytime\n-        RrdRepository repository = new RrdRepository();\n-        repository.setStep(pollerConfig.getStep(pkg));\n-        repository.setHeartBeat(repository.getHeartBeat());\n-        repository.setRraList(pollerConfig.getRRAList(pkg));\n+        // TODO: Apply thresholding\n+\n+        final RrdRepository repository = new RrdRepository();\n+        repository.setStep(this.pollerConfig.getStep(pkg));\n+        repository.setHeartBeat(repository.getStep() * 2);\n+        repository.setRraList(this.pollerConfig.getRRAList(pkg));\n         repository.setRrdBaseDir(new File(rrdRepository));\n \n-        // FIXME: Use collectionset builder for this\n-        LatencyCollectionResource latencyResource = new LatencyCollectionResource(monSvc.getServiceName(), InetAddressUtils.toIpAddrString(monSvc.getIpAddress()), locationName);\n-        LatencyCollectionAttributeType latencyType = new LatencyCollectionAttributeType(rrdBaseName, dsName);\n-        latencyResource.addAttribute(new LatencyCollectionAttribute(latencyResource,\n-                latencyType, dsName, responseTime));\n+        // Prefer ds-name over \"response-time\" for primary response-time value\n+        final Map<String, Number> properties = Maps.newHashMap(pollStatus.getProperties());\n+        if (!properties.containsKey(dsName) && properties.containsKey(PollStatus.PROPERTY_RESPONSE_TIME)) {\n+            properties.put(dsName, properties.get(PollStatus.PROPERTY_RESPONSE_TIME));\n+            properties.remove(PollStatus.PROPERTY_RESPONSE_TIME);\n+        }\n \n-        ServiceParameters params = new ServiceParameters(Collections.emptyMap());\n-        CollectionSetVisitor persister = persisterFactory.createPersister(params, repository, false, true, true);\n+        // Build collection agent\n+        final CollectionAgentDTO agent = new CollectionAgentDTO();\n+        agent.setAddress(monSvc.getIpAddress());\n+        agent.setForeignId(monSvc.getForeignId());\n+        agent.setForeignSource(monSvc.getForeignSource());\n+        agent.setNodeId(monSvc.getNodeId());\n+        agent.setNodeLabel(monSvc.getIpInterface().getNode().getLabel());\n+        agent.setLocationName(locationName);\n+        agent.setStorageResourcePath(ResourcePath.get(LocationUtils.isDefaultLocationName(residentLocationName)\n+                                                      ? ResourcePath.get()\n+                                                      : ResourcePath.get(ResourcePath.sanitize(residentLocationName)),\n+                                                      InetAddressUtils.str(monSvc.getIpAddress())));\n+        agent.setStoreByForeignSource(false);\n+\n+        // Create collection set from response times as gauges and persist\n+        final CollectionSetBuilder collectionSetBuilder = new CollectionSetBuilder(agent);\n+        final RemoteLatencyResource resource = new RemoteLatencyResource(locationName, InetAddressUtils.str(monSvc.getIpAddress()), svcName);\n+        for (final Map.Entry<String, Number> e: properties.entrySet()) {\n+            final String key = PollStatus.PROPERTY_RESPONSE_TIME.equals(e.getKey())\n+                               ? dsName\n+                               : e.getKey();\n+\n+            collectionSetBuilder.withGauge(resource, rrdBaseName, key, e.getValue());\n+        }\n \n-        SingleResourceCollectionSet collectionSet = new SingleResourceCollectionSet(latencyResource, new Date());\n-        collectionSet.setStatus(CollectionStatus.SUCCEEDED);\n-        collectionSet.visit(persister);\n+        collectionSetBuilder.build()\n+                            .visit(this.persisterFactory.createPersister(new ServiceParameters(Collections.emptyMap()),\n+                                                                         repository,\n+                                                                         false,\n+                                                                         true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb34a14ac17858089e6cbefad11fb30162f50e8b"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ5OTU3Mw==", "bodyText": "Yes. Response Times are always stored by group. Allowing to configure this would require to add another level in folder hierarchy, because we have to store multiple \"response\" tracks.", "url": "https://github.com/OpenNMS/opennms/pull/3015#discussion_r427499573", "createdAt": "2020-05-19T18:06:52Z", "author": {"login": "fooker"}, "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/RemotePollerd.java", "diffHunk": "@@ -321,25 +327,52 @@ public void saveResponseTimeData(final String locationName, final OnmsMonitoredS\n             return;\n         }\n \n-        // FIXME: We don't need to recompute this everytime\n-        RrdRepository repository = new RrdRepository();\n-        repository.setStep(pollerConfig.getStep(pkg));\n-        repository.setHeartBeat(repository.getHeartBeat());\n-        repository.setRraList(pollerConfig.getRRAList(pkg));\n+        // TODO: Apply thresholding\n+\n+        final RrdRepository repository = new RrdRepository();\n+        repository.setStep(this.pollerConfig.getStep(pkg));\n+        repository.setHeartBeat(repository.getStep() * 2);\n+        repository.setRraList(this.pollerConfig.getRRAList(pkg));\n         repository.setRrdBaseDir(new File(rrdRepository));\n \n-        // FIXME: Use collectionset builder for this\n-        LatencyCollectionResource latencyResource = new LatencyCollectionResource(monSvc.getServiceName(), InetAddressUtils.toIpAddrString(monSvc.getIpAddress()), locationName);\n-        LatencyCollectionAttributeType latencyType = new LatencyCollectionAttributeType(rrdBaseName, dsName);\n-        latencyResource.addAttribute(new LatencyCollectionAttribute(latencyResource,\n-                latencyType, dsName, responseTime));\n+        // Prefer ds-name over \"response-time\" for primary response-time value\n+        final Map<String, Number> properties = Maps.newHashMap(pollStatus.getProperties());\n+        if (!properties.containsKey(dsName) && properties.containsKey(PollStatus.PROPERTY_RESPONSE_TIME)) {\n+            properties.put(dsName, properties.get(PollStatus.PROPERTY_RESPONSE_TIME));\n+            properties.remove(PollStatus.PROPERTY_RESPONSE_TIME);\n+        }\n \n-        ServiceParameters params = new ServiceParameters(Collections.emptyMap());\n-        CollectionSetVisitor persister = persisterFactory.createPersister(params, repository, false, true, true);\n+        // Build collection agent\n+        final CollectionAgentDTO agent = new CollectionAgentDTO();\n+        agent.setAddress(monSvc.getIpAddress());\n+        agent.setForeignId(monSvc.getForeignId());\n+        agent.setForeignSource(monSvc.getForeignSource());\n+        agent.setNodeId(monSvc.getNodeId());\n+        agent.setNodeLabel(monSvc.getIpInterface().getNode().getLabel());\n+        agent.setLocationName(locationName);\n+        agent.setStorageResourcePath(ResourcePath.get(LocationUtils.isDefaultLocationName(residentLocationName)\n+                                                      ? ResourcePath.get()\n+                                                      : ResourcePath.get(ResourcePath.sanitize(residentLocationName)),\n+                                                      InetAddressUtils.str(monSvc.getIpAddress())));\n+        agent.setStoreByForeignSource(false);\n+\n+        // Create collection set from response times as gauges and persist\n+        final CollectionSetBuilder collectionSetBuilder = new CollectionSetBuilder(agent);\n+        final RemoteLatencyResource resource = new RemoteLatencyResource(locationName, InetAddressUtils.str(monSvc.getIpAddress()), svcName);\n+        for (final Map.Entry<String, Number> e: properties.entrySet()) {\n+            final String key = PollStatus.PROPERTY_RESPONSE_TIME.equals(e.getKey())\n+                               ? dsName\n+                               : e.getKey();\n+\n+            collectionSetBuilder.withGauge(resource, rrdBaseName, key, e.getValue());\n+        }\n \n-        SingleResourceCollectionSet collectionSet = new SingleResourceCollectionSet(latencyResource, new Date());\n-        collectionSet.setStatus(CollectionStatus.SUCCEEDED);\n-        collectionSet.visit(persister);\n+        collectionSetBuilder.build()\n+                            .visit(this.persisterFactory.createPersister(new ServiceParameters(Collections.emptyMap()),\n+                                                                         repository,\n+                                                                         false,\n+                                                                         true,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0Nzg0NA=="}, "originalCommit": {"oid": "fb34a14ac17858089e6cbefad11fb30162f50e8b"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ5OTYxMQ==", "bodyText": "Yes. Response Times are always stored by group. Allowing to configure this would require to add another level in folder hierarchy, because we have to store multiple \"response\" tracks.", "url": "https://github.com/OpenNMS/opennms/pull/3015#discussion_r427499611", "createdAt": "2020-05-19T18:06:55Z", "author": {"login": "fooker"}, "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/RemotePollerd.java", "diffHunk": "@@ -321,25 +327,52 @@ public void saveResponseTimeData(final String locationName, final OnmsMonitoredS\n             return;\n         }\n \n-        // FIXME: We don't need to recompute this everytime\n-        RrdRepository repository = new RrdRepository();\n-        repository.setStep(pollerConfig.getStep(pkg));\n-        repository.setHeartBeat(repository.getHeartBeat());\n-        repository.setRraList(pollerConfig.getRRAList(pkg));\n+        // TODO: Apply thresholding\n+\n+        final RrdRepository repository = new RrdRepository();\n+        repository.setStep(this.pollerConfig.getStep(pkg));\n+        repository.setHeartBeat(repository.getStep() * 2);\n+        repository.setRraList(this.pollerConfig.getRRAList(pkg));\n         repository.setRrdBaseDir(new File(rrdRepository));\n \n-        // FIXME: Use collectionset builder for this\n-        LatencyCollectionResource latencyResource = new LatencyCollectionResource(monSvc.getServiceName(), InetAddressUtils.toIpAddrString(monSvc.getIpAddress()), locationName);\n-        LatencyCollectionAttributeType latencyType = new LatencyCollectionAttributeType(rrdBaseName, dsName);\n-        latencyResource.addAttribute(new LatencyCollectionAttribute(latencyResource,\n-                latencyType, dsName, responseTime));\n+        // Prefer ds-name over \"response-time\" for primary response-time value\n+        final Map<String, Number> properties = Maps.newHashMap(pollStatus.getProperties());\n+        if (!properties.containsKey(dsName) && properties.containsKey(PollStatus.PROPERTY_RESPONSE_TIME)) {\n+            properties.put(dsName, properties.get(PollStatus.PROPERTY_RESPONSE_TIME));\n+            properties.remove(PollStatus.PROPERTY_RESPONSE_TIME);\n+        }\n \n-        ServiceParameters params = new ServiceParameters(Collections.emptyMap());\n-        CollectionSetVisitor persister = persisterFactory.createPersister(params, repository, false, true, true);\n+        // Build collection agent\n+        final CollectionAgentDTO agent = new CollectionAgentDTO();\n+        agent.setAddress(monSvc.getIpAddress());\n+        agent.setForeignId(monSvc.getForeignId());\n+        agent.setForeignSource(monSvc.getForeignSource());\n+        agent.setNodeId(monSvc.getNodeId());\n+        agent.setNodeLabel(monSvc.getIpInterface().getNode().getLabel());\n+        agent.setLocationName(locationName);\n+        agent.setStorageResourcePath(ResourcePath.get(LocationUtils.isDefaultLocationName(residentLocationName)\n+                                                      ? ResourcePath.get()\n+                                                      : ResourcePath.get(ResourcePath.sanitize(residentLocationName)),\n+                                                      InetAddressUtils.str(monSvc.getIpAddress())));\n+        agent.setStoreByForeignSource(false);\n+\n+        // Create collection set from response times as gauges and persist\n+        final CollectionSetBuilder collectionSetBuilder = new CollectionSetBuilder(agent);\n+        final RemoteLatencyResource resource = new RemoteLatencyResource(locationName, InetAddressUtils.str(monSvc.getIpAddress()), svcName);\n+        for (final Map.Entry<String, Number> e: properties.entrySet()) {\n+            final String key = PollStatus.PROPERTY_RESPONSE_TIME.equals(e.getKey())\n+                               ? dsName\n+                               : e.getKey();\n+\n+            collectionSetBuilder.withGauge(resource, rrdBaseName, key, e.getValue());\n+        }\n \n-        SingleResourceCollectionSet collectionSet = new SingleResourceCollectionSet(latencyResource, new Date());\n-        collectionSet.setStatus(CollectionStatus.SUCCEEDED);\n-        collectionSet.visit(persister);\n+        collectionSetBuilder.build()\n+                            .visit(this.persisterFactory.createPersister(new ServiceParameters(Collections.emptyMap()),\n+                                                                         repository,\n+                                                                         false,\n+                                                                         true,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0Nzg0NA=="}, "originalCommit": {"oid": "fb34a14ac17858089e6cbefad11fb30162f50e8b"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTkxNDA2OnYy", "diffSide": "RIGHT", "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/RemotePollerd.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDoxODoxMVrOGYOGuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMTo0NToxOVrOGdt6PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA1MDEwNA==", "bodyText": "Should be easy to apply thresholding now that we have the CollectionSet.", "url": "https://github.com/OpenNMS/opennms/pull/3015#discussion_r428050104", "createdAt": "2020-05-20T14:18:11Z", "author": {"login": "j-white"}, "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/RemotePollerd.java", "diffHunk": "@@ -321,25 +327,52 @@ public void saveResponseTimeData(final String locationName, final OnmsMonitoredS\n             return;\n         }\n \n-        // FIXME: We don't need to recompute this everytime\n-        RrdRepository repository = new RrdRepository();\n-        repository.setStep(pollerConfig.getStep(pkg));\n-        repository.setHeartBeat(repository.getHeartBeat());\n-        repository.setRraList(pollerConfig.getRRAList(pkg));\n+        // TODO: Apply thresholding", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb34a14ac17858089e6cbefad11fb30162f50e8b"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgxNDA3Ng==", "bodyText": "There is a issue for that: https://issues.opennms.org/browse/NMS-12721", "url": "https://github.com/OpenNMS/opennms/pull/3015#discussion_r433814076", "createdAt": "2020-06-02T11:45:19Z", "author": {"login": "fooker"}, "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/RemotePollerd.java", "diffHunk": "@@ -321,25 +327,52 @@ public void saveResponseTimeData(final String locationName, final OnmsMonitoredS\n             return;\n         }\n \n-        // FIXME: We don't need to recompute this everytime\n-        RrdRepository repository = new RrdRepository();\n-        repository.setStep(pollerConfig.getStep(pkg));\n-        repository.setHeartBeat(repository.getHeartBeat());\n-        repository.setRraList(pollerConfig.getRRAList(pkg));\n+        // TODO: Apply thresholding", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA1MDEwNA=="}, "originalCommit": {"oid": "fb34a14ac17858089e6cbefad11fb30162f50e8b"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTkyNTg2OnYy", "diffSide": "RIGHT", "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/RemotePollerd.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDoyMDoyOFrOGYON-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMTo1MDozNVrOGduFBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA1MTk2Mg==", "bodyText": "Can we move this to the org.opennms.netmgt.collection.support.builder package of the org.opennms.features.collection.api module?\nI've been trying to collect all of the resource types there :)", "url": "https://github.com/OpenNMS/opennms/pull/3015#discussion_r428051962", "createdAt": "2020-05-20T14:20:28Z", "author": {"login": "j-white"}, "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/RemotePollerd.java", "diffHunk": "@@ -358,4 +391,49 @@ private String getServiceParameter(final Service svc, final String key) {\n     @Override\n     public void afterPropertiesSet() throws Exception {\n     }\n+\n+    public static class RemoteLatencyResource extends AbstractResource {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb34a14ac17858089e6cbefad11fb30162f50e8b"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgxNjgzOQ==", "bodyText": "Done", "url": "https://github.com/OpenNMS/opennms/pull/3015#discussion_r433816839", "createdAt": "2020-06-02T11:50:35Z", "author": {"login": "fooker"}, "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/RemotePollerd.java", "diffHunk": "@@ -358,4 +391,49 @@ private String getServiceParameter(final Service svc, final String key) {\n     @Override\n     public void afterPropertiesSet() throws Exception {\n     }\n+\n+    public static class RemoteLatencyResource extends AbstractResource {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA1MTk2Mg=="}, "originalCommit": {"oid": "fb34a14ac17858089e6cbefad11fb30162f50e8b"}, "originalPosition": 183}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 663, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}