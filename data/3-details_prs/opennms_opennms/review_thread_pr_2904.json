{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwODkzMTcz", "number": 2904, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzo0MDozNlrODj5Y_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwOTozNDo0MVrODkkymg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTY3MDM3OnYy", "diffSide": "LEFT", "path": "features/telemetry/common/src/main/java/org/opennms/netmgt/telemetry/common/ipc/TelemetrySinkModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzo0MDozNlrOFv9Q7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwOTowMzo1OVrOFw9PWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMTE1MQ==", "bodyText": "Can we set a fake source rather than keeping it null? I'm thinking host=0.0.0.0 and port=0", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385831151", "createdAt": "2020-02-28T17:40:36Z", "author": {"login": "j-white"}, "path": "features/telemetry/common/src/main/java/org/opennms/netmgt/telemetry/common/ipc/TelemetrySinkModule.java", "diffHunk": "@@ -120,17 +120,23 @@ public int getCompletionIntervalMs() {\n \n             @Override\n             public Object key(TelemetryMessage telemetryMessage) {\n-                return telemetryMessage.getSource();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg3OTMyMg==", "bodyText": "Done.", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r386879322", "createdAt": "2020-03-03T09:03:59Z", "author": {"login": "fooker"}, "path": "features/telemetry/common/src/main/java/org/opennms/netmgt/telemetry/common/ipc/TelemetrySinkModule.java", "diffHunk": "@@ -120,17 +120,23 @@ public int getCompletionIntervalMs() {\n \n             @Override\n             public Object key(TelemetryMessage telemetryMessage) {\n-                return telemetryMessage.getSource();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMTE1MQ=="}, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTY3MjUxOnYy", "diffSide": "LEFT", "path": ".circleci/config.yml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzo0MToyMFrOFv9SHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzo0MToyMFrOFv9SHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMTQ1NA==", "bodyText": "I'll revert this once we get the OpenBMP Message API artifact published.", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385831454", "createdAt": "2020-02-28T17:41:20Z", "author": {"login": "j-white"}, "path": ".circleci/config.yml", "diffHunk": "@@ -1,701 +0,0 @@\n-version: 2.1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTY3NDk0OnYy", "diffSide": "RIGHT", "path": "features/telemetry/protocols/bmp/adapter/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzo0MTo1OVrOFv9TcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDo1NTowMVrOFxf--g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMTc5Mw==", "bodyText": "This is what I need to get published.", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385831793", "createdAt": "2020-02-28T17:41:59Z", "author": {"login": "j-white"}, "path": "features/telemetry/protocols/bmp/adapter/pom.xml", "diffHunk": "@@ -75,5 +82,20 @@\n       <artifactId>hamcrest-library</artifactId>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>\n+      <groupId>org.mockito</groupId>\n+      <artifactId>mockito-core</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.opennms.core.test-api</groupId>\n+      <artifactId>org.opennms.core.test-api.lib</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0ODU3MA==", "bodyText": "Artifacts are now available in Maven Central.", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r387448570", "createdAt": "2020-03-04T04:55:01Z", "author": {"login": "j-white"}, "path": "features/telemetry/protocols/bmp/adapter/pom.xml", "diffHunk": "@@ -75,5 +82,20 @@\n       <artifactId>hamcrest-library</artifactId>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>\n+      <groupId>org.mockito</groupId>\n+      <artifactId>mockito-core</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.opennms.core.test-api</groupId>\n+      <artifactId>org.opennms.core.test-api.lib</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMTc5Mw=="}, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTY3ODc3OnYy", "diffSide": "RIGHT", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/BmpTelemetryAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzo0MzoyMVrOFv9VqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzo0MzoyMVrOFv9VqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMjM2MQ==", "bodyText": "Use BmpAdapterTools.addressAsStr", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385832361", "createdAt": "2020-02-28T17:43:21Z", "author": {"login": "j-white"}, "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/BmpTelemetryAdapter.java", "diffHunk": "@@ -111,7 +111,7 @@ public BmpTelemetryAdapter(final AdapterDefinition adapterConfig,\n         builder.withTimestamp(Date.from(timestamp(stats.getPeer().getTimestamp())));\n         builder.withStringAttribute(peerResource, \"bmp\", \"address\", peerAddress);\n         builder.withStringAttribute(peerResource, \"bmp\", \"as\", Long.toString(stats.getPeer().getAs()));\n-        builder.withStringAttribute(peerResource, \"bmp\", \"id\", Long.toString(stats.getPeer().getId()));\n+        builder.withStringAttribute(peerResource, \"bmp\", \"id\", InetAddressUtils.str(address(stats.getPeer().getId())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTY4MDQ0OnYy", "diffSide": "RIGHT", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpKafkaProducer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzo0Mzo1M1rOFv9Wnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwODo1NzoxMVrOFxkryQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMjYwNw==", "bodyText": "TODO", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385832607", "createdAt": "2020-02-28T17:43:53Z", "author": {"login": "j-white"}, "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpKafkaProducer.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import java.util.Map;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.opennms.core.utils.StringUtils;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+\n+public class BmpKafkaProducer implements BmpMessageHandler {\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpKafkaProducer.class);\n+\n+    private final KafkaProducer<String, String> producer;\n+\n+    public BmpKafkaProducer(final AdapterDefinition adapterConfig) {\n+        this.producer = buildProducer(adapterConfig);\n+    }\n+\n+    private static KafkaProducer<String, String> buildProducer(final AdapterDefinition adapterConfig) {\n+        final Map<String, Object> kafkaConfig = Maps.newHashMap();\n+        for (final Map.Entry<String, String> entry : adapterConfig.getParameterMap().entrySet()) {\n+            StringUtils.truncatePrefix(entry.getKey(), \"kafka.\").ifPresent(key -> {\n+                kafkaConfig.put(key, entry.getValue());\n+            });\n+        }\n+\n+        // TODO fooker: Apply defaults (steal from https://github.com/SNAS/openbmp/blob/1a615a3c75a0143cc87ec70458471f0af67d3929/Server/src/kafka/MsgBusImpl_kafka.cpp#L162)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzUyNTU3Nw==", "bodyText": "Deferred to https://issues.opennms.org/browse/NMS-12574", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r387525577", "createdAt": "2020-03-04T08:57:11Z", "author": {"login": "fooker"}, "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpKafkaProducer.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import java.util.Map;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.opennms.core.utils.StringUtils;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+\n+public class BmpKafkaProducer implements BmpMessageHandler {\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpKafkaProducer.class);\n+\n+    private final KafkaProducer<String, String> producer;\n+\n+    public BmpKafkaProducer(final AdapterDefinition adapterConfig) {\n+        this.producer = buildProducer(adapterConfig);\n+    }\n+\n+    private static KafkaProducer<String, String> buildProducer(final AdapterDefinition adapterConfig) {\n+        final Map<String, Object> kafkaConfig = Maps.newHashMap();\n+        for (final Map.Entry<String, String> entry : adapterConfig.getParameterMap().entrySet()) {\n+            StringUtils.truncatePrefix(entry.getKey(), \"kafka.\").ifPresent(key -> {\n+                kafkaConfig.put(key, entry.getValue());\n+            });\n+        }\n+\n+        // TODO fooker: Apply defaults (steal from https://github.com/SNAS/openbmp/blob/1a615a3c75a0143cc87ec70458471f0af67d3929/Server/src/kafka/MsgBusImpl_kafka.cpp#L162)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMjYwNw=="}, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTY4MTE1OnYy", "diffSide": "RIGHT", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpKafkaProducer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzo0NDowN1rOFv9XGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOToxNDo1NVrOFxlPig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMjczMA==", "bodyText": "FIXME", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385832730", "createdAt": "2020-02-28T17:44:07Z", "author": {"login": "j-white"}, "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpKafkaProducer.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import java.util.Map;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.opennms.core.utils.StringUtils;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+\n+public class BmpKafkaProducer implements BmpMessageHandler {\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpKafkaProducer.class);\n+\n+    private final KafkaProducer<String, String> producer;\n+\n+    public BmpKafkaProducer(final AdapterDefinition adapterConfig) {\n+        this.producer = buildProducer(adapterConfig);\n+    }\n+\n+    private static KafkaProducer<String, String> buildProducer(final AdapterDefinition adapterConfig) {\n+        final Map<String, Object> kafkaConfig = Maps.newHashMap();\n+        for (final Map.Entry<String, String> entry : adapterConfig.getParameterMap().entrySet()) {\n+            StringUtils.truncatePrefix(entry.getKey(), \"kafka.\").ifPresent(key -> {\n+                kafkaConfig.put(key, entry.getValue());\n+            });\n+        }\n+\n+        // TODO fooker: Apply defaults (steal from https://github.com/SNAS/openbmp/blob/1a615a3c75a0143cc87ec70458471f0af67d3929/Server/src/kafka/MsgBusImpl_kafka.cpp#L162)\n+\n+        return new KafkaProducer<>(kafkaConfig, new StringSerializer(), new StringSerializer());\n+    }\n+\n+    @Override\n+    public void handle(Message message) {\n+        final StringBuffer buffer = new StringBuffer();\n+        message.serialize(buffer);\n+\n+        final String topic = message.getType().getTopic();\n+        // FIXME: Make prefix configurable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzUzNDczMA==", "bodyText": "Implemented.", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r387534730", "createdAt": "2020-03-04T09:14:55Z", "author": {"login": "fooker"}, "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpKafkaProducer.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import java.util.Map;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.opennms.core.utils.StringUtils;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+\n+public class BmpKafkaProducer implements BmpMessageHandler {\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpKafkaProducer.class);\n+\n+    private final KafkaProducer<String, String> producer;\n+\n+    public BmpKafkaProducer(final AdapterDefinition adapterConfig) {\n+        this.producer = buildProducer(adapterConfig);\n+    }\n+\n+    private static KafkaProducer<String, String> buildProducer(final AdapterDefinition adapterConfig) {\n+        final Map<String, Object> kafkaConfig = Maps.newHashMap();\n+        for (final Map.Entry<String, String> entry : adapterConfig.getParameterMap().entrySet()) {\n+            StringUtils.truncatePrefix(entry.getKey(), \"kafka.\").ifPresent(key -> {\n+                kafkaConfig.put(key, entry.getValue());\n+            });\n+        }\n+\n+        // TODO fooker: Apply defaults (steal from https://github.com/SNAS/openbmp/blob/1a615a3c75a0143cc87ec70458471f0af67d3929/Server/src/kafka/MsgBusImpl_kafka.cpp#L162)\n+\n+        return new KafkaProducer<>(kafkaConfig, new StringSerializer(), new StringSerializer());\n+    }\n+\n+    @Override\n+    public void handle(Message message) {\n+        final StringBuffer buffer = new StringBuffer();\n+        message.serialize(buffer);\n+\n+        final String topic = message.getType().getTopic();\n+        // FIXME: Make prefix configurable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMjczMA=="}, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTcwMDU5OnYy", "diffSide": "RIGHT", "path": "features/telemetry/registry/src/main/java/org/opennms/netmgt/telemetry/protocols/registry/impl/TelemetryServiceRegistryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzo1MDo1OVrOFv9jRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwODo1NDoyN1rOFxkmMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzNTg0NA==", "bodyText": "This seems like a reasonable fix -  only set properties that are writeable - caveat is that it makes it harder to detect mis-configured properties.\nIf the property is not writeable, maybe we could call some known function on the bean to validate?", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385835844", "createdAt": "2020-02-28T17:50:59Z", "author": {"login": "j-white"}, "path": "features/telemetry/registry/src/main/java/org/opennms/netmgt/telemetry/protocols/registry/impl/TelemetryServiceRegistryImpl.java", "diffHunk": "@@ -121,7 +121,13 @@ public T getService(BD beanDefinition) {\n             final T service = (T) registration.getServiceFactory().createBean(beanDefinition);\n \n             final BeanWrapper wrapper = PropertyAccessorFactory.forBeanPropertyAccess(service);\n-            wrapper.setPropertyValues(beanDefinition.getParameterMap());\n+//            wrapper.setPropertyValues(beanDefinition.getParameterMap());\n+            // TODO fooker: Workaround for unknown properties in BmpIntegrationAdapter (kafka.*)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzUyNDE0NA==", "bodyText": "Deferred to https://issues.opennms.org/browse/NMS-12573", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r387524144", "createdAt": "2020-03-04T08:54:27Z", "author": {"login": "fooker"}, "path": "features/telemetry/registry/src/main/java/org/opennms/netmgt/telemetry/protocols/registry/impl/TelemetryServiceRegistryImpl.java", "diffHunk": "@@ -121,7 +121,13 @@ public T getService(BD beanDefinition) {\n             final T service = (T) registration.getServiceFactory().createBean(beanDefinition);\n \n             final BeanWrapper wrapper = PropertyAccessorFactory.forBeanPropertyAccess(service);\n-            wrapper.setPropertyValues(beanDefinition.getParameterMap());\n+//            wrapper.setPropertyValues(beanDefinition.getParameterMap());\n+            // TODO fooker: Workaround for unknown properties in BmpIntegrationAdapter (kafka.*)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzNTg0NA=="}, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTcwNTU5OnYy", "diffSide": "RIGHT", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpIntegrationAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzo1Mjo0OFrOFv9mcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwOToyOTo0OFrOFw-HIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzNjY1Nw==", "bodyText": "TODO: Async DNS resolution. Use address for now and defer to separate JIRA issue?", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385836657", "createdAt": "2020-02-28T17:52:48Z", "author": {"login": "j-white"}, "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpIntegrationAdapter.java", "diffHunk": "@@ -0,0 +1,724 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.address;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.asAttr;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributeOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributesOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.isV4;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.timestamp;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.uint32;\n+\n+import java.net.InetAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+import org.opennms.core.utils.InetAddressUtils;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLog;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLogEntry;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Record;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Type;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.BaseAttribute;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Collector;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Peer;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Router;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Stat;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.UnicastPrefix;\n+import org.opennms.netmgt.telemetry.protocols.bmp.transport.Transport;\n+import org.opennms.netmgt.telemetry.protocols.collection.AbstractAdapter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+public class BmpIntegrationAdapter extends AbstractAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpIntegrationAdapter.class);\n+\n+    private final AtomicLong sequence = new AtomicLong();\n+\n+    private final BmpMessageHandler handler;\n+\n+    public enum Error {\n+        // Message Header Error\n+        CONNECTION_NOT_SYNCHRONIZED(\"Connection not synchronized\"),\n+        BAD_MESSAGE_LENGTH(\"Bad message header length\"),\n+        BAD_MESSAGE_TYPE(\"Bad message header type\"),\n+\n+        // Open Message Error\n+        UNSUPPORTED_VERSION_NUMBER(\"Unsupported BGP version\"),\n+        BAD_PEER_AS(\"Incorrect peer AS\"),\n+        BAD_BGP_IDENTIFIER(\"Bad BGP ID\"),\n+        UNSUPPORTED_OPTIONAL_PARAMETER(\"Unsupported optinal parameter\"),\n+        AUTHENTICATION_FAILURE(\"Authentication failure\"),\n+        UNACCEPTABLE_HOLD_TIME(\"Unacceptable hold time\"),\n+\n+        // Update Message Error\n+        MALFORMED_ATTRIBUTE_LIST(\"Malformed attribute list\"),\n+        UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE(\"Unrecognized well known attribute\"),\n+        MISSING_WELL_KNOWN_ATTRIBUTE(\"Missing well known attribute\"),\n+        ATTRIBUTE_FLAGS_ERROR(\"Update attribute flags error\"),\n+        ATTRIBUTE_LENGTH_ERROR(\"Update attribute length error\"),\n+        INVALID_ORIGIN_ATTRIBUTE(\"Invalid origin\"),\n+        ROUTING_LOOP(\"Routing loop\"),\n+        INVALID_NEXT_HOP_ATTRIBUTE(\"Invalid next hop address/attribute\"),\n+        OPTIONAL_ATTRIBUTE_ERROR(\"Update optional attribute error\"),\n+        INVALID_NETWORK_FIELD(\"Invalid network field\"),\n+        MALFORMED_AS_PATH(\"Malformed AS_PATH\"),\n+\n+        // Hold Timer Expired\n+        HOLD_TIMER_EXPIRED(\"Hold timer expired\"),\n+\n+        // FSM Error\n+        FSM_ERROR(\"FSM error\"),\n+\n+        // Cease\n+        MAXIMUM_NUMBER_OF_PREFIXES_REACHED(\"Maximum number of prefixes reached\"),\n+        ADMINISTRATIVE_SHUTDOWN(\"Administrative shutdown\"),\n+        PEER_DECONFIGURED(\"Peer de-configured\"),\n+        ADMINISTRATIVE_RESET(\"Administrative reset\"),\n+        CONNECTION_RESET(\"Connection rejected\"),\n+        OTHER_CONFIGURATION_CHANGE(\"Other configuration change\"),\n+        CONNECTION_COLLISION_RESOLUTION(\"Connection collision resolution\"),\n+        OUT_OF_RESOURCES(\"Maximum number of prefixes reached\"),\n+\n+        UNKNOWN(\"Unknown notification type\"),\n+        ;\n+\n+        private String errorText;\n+\n+        Error(final String errorText) {\n+            this.errorText = errorText;\n+        }\n+\n+        public String getErrorText() {\n+            return errorText;\n+        }\n+\n+        public static Error from(final int code, final int subcode) {\n+            switch ((code << 8) + subcode) {\n+                case (1 << 8) + 1: return CONNECTION_NOT_SYNCHRONIZED;\n+                case (1 << 8) + 2: return BAD_MESSAGE_LENGTH;\n+                case (1 << 8) + 3: return BAD_MESSAGE_TYPE;\n+\n+                case (2 << 8) + 1: return UNSUPPORTED_VERSION_NUMBER;\n+                case (2 << 8) + 2: return BAD_PEER_AS;\n+                case (2 << 8) + 3: return BAD_BGP_IDENTIFIER;\n+                case (2 << 8) + 4: return UNSUPPORTED_OPTIONAL_PARAMETER;\n+                case (2 << 8) + 5: return AUTHENTICATION_FAILURE;\n+                case (2 << 8) + 6: return UNACCEPTABLE_HOLD_TIME;\n+\n+                case (3 << 8) + 1: return MALFORMED_ATTRIBUTE_LIST;\n+                case (3 << 8) + 2: return UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 3: return MISSING_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 4: return ATTRIBUTE_FLAGS_ERROR;\n+                case (3 << 8) + 5: return ATTRIBUTE_LENGTH_ERROR;\n+                case (3 << 8) + 6: return INVALID_ORIGIN_ATTRIBUTE;\n+                case (3 << 8) + 7: return ROUTING_LOOP;\n+                case (3 << 8) + 8: return INVALID_NEXT_HOP_ATTRIBUTE;\n+                case (3 << 8) + 9: return OPTIONAL_ATTRIBUTE_ERROR;\n+                case (3 << 8) + 10: return INVALID_NETWORK_FIELD;\n+                case (3 << 8) + 11: return MALFORMED_AS_PATH;\n+\n+                case (4 << 8) + 1: return HOLD_TIMER_EXPIRED;\n+\n+                case (5 << 8) + 1: return FSM_ERROR;\n+\n+                case (6 << 8) + 1: return MAXIMUM_NUMBER_OF_PREFIXES_REACHED;\n+                case (6 << 8) + 2: return ADMINISTRATIVE_SHUTDOWN;\n+                case (6 << 8) + 3: return PEER_DECONFIGURED;\n+                case (6 << 8) + 4: return ADMINISTRATIVE_RESET;\n+                case (6 << 8) + 5: return CONNECTION_RESET;\n+                case (6 << 8) + 6: return OTHER_CONFIGURATION_CHANGE;\n+                case (6 << 8) + 7: return CONNECTION_COLLISION_RESOLUTION;\n+                case (6 << 8) + 8: return OUT_OF_RESOURCES;\n+\n+                default:\n+                    LOG.warn(\"Unknown Notification Packet Code: {}/{}\", code, subcode);\n+                    return UNKNOWN;\n+            }\n+        }\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = new BmpKafkaProducer(adapterConfig);\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry,\n+                                 final BmpMessageHandler handler) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = Objects.requireNonNull(handler);\n+    }\n+\n+    private void handleHeartbeatMessage(final Transport.Message message,\n+                                        final Transport.Heartbeat heartbeat,\n+                                        final Context context) {\n+        final Collector collector = new Collector();\n+\n+        switch (heartbeat.getMode()) {\n+            case STARTED:\n+                collector.action = Collector.Action.STARTED;\n+                break;\n+            case STOPPED:\n+                collector.action = Collector.Action.STOPPED;\n+                break;\n+            case PERIODIC:\n+                collector.action = Collector.Action.HEARTBEAT;\n+                break;\n+            case CHANGE:\n+                collector.action = Collector.Action.CHANGE;\n+                break;\n+        }\n+\n+        collector.sequence = sequence.getAndIncrement();\n+        collector.adminId = context.adminId;\n+        collector.hash = context.collectorHashId;\n+        collector.routers = Lists.transform(heartbeat.getRoutersList(), BmpAdapterTools::address);\n+        collector.timestamp = context.timestamp;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.COLLECTOR, ImmutableList.of(collector)));\n+    }\n+\n+    private void handleInitiationMessage(final Transport.Message message,\n+                                         final Transport.InitiationPacket initiation,\n+                                         final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.INIT;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = initiation.getSysName();\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = initiation.getSysDesc();\n+        router.termCode = null;\n+        router.termReason = null;\n+        router.initData = initiation.getMessage();\n+        router.termData = null;\n+        router.timestamp = context.timestamp;\n+        router.bgpId = initiation.hasBgpId() ? BmpAdapterTools.address(initiation.getBgpId()) : null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handleTerminationMessage(final Transport.Message message,\n+                                          final Transport.TerminationPacket termination,\n+                                          final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.TERM;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = null;\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg5MzYwMA==", "bodyText": "Deferred to https://issues.opennms.org/browse/NMS-12569", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r386893600", "createdAt": "2020-03-03T09:29:48Z", "author": {"login": "fooker"}, "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpIntegrationAdapter.java", "diffHunk": "@@ -0,0 +1,724 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.address;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.asAttr;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributeOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributesOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.isV4;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.timestamp;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.uint32;\n+\n+import java.net.InetAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+import org.opennms.core.utils.InetAddressUtils;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLog;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLogEntry;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Record;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Type;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.BaseAttribute;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Collector;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Peer;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Router;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Stat;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.UnicastPrefix;\n+import org.opennms.netmgt.telemetry.protocols.bmp.transport.Transport;\n+import org.opennms.netmgt.telemetry.protocols.collection.AbstractAdapter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+public class BmpIntegrationAdapter extends AbstractAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpIntegrationAdapter.class);\n+\n+    private final AtomicLong sequence = new AtomicLong();\n+\n+    private final BmpMessageHandler handler;\n+\n+    public enum Error {\n+        // Message Header Error\n+        CONNECTION_NOT_SYNCHRONIZED(\"Connection not synchronized\"),\n+        BAD_MESSAGE_LENGTH(\"Bad message header length\"),\n+        BAD_MESSAGE_TYPE(\"Bad message header type\"),\n+\n+        // Open Message Error\n+        UNSUPPORTED_VERSION_NUMBER(\"Unsupported BGP version\"),\n+        BAD_PEER_AS(\"Incorrect peer AS\"),\n+        BAD_BGP_IDENTIFIER(\"Bad BGP ID\"),\n+        UNSUPPORTED_OPTIONAL_PARAMETER(\"Unsupported optinal parameter\"),\n+        AUTHENTICATION_FAILURE(\"Authentication failure\"),\n+        UNACCEPTABLE_HOLD_TIME(\"Unacceptable hold time\"),\n+\n+        // Update Message Error\n+        MALFORMED_ATTRIBUTE_LIST(\"Malformed attribute list\"),\n+        UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE(\"Unrecognized well known attribute\"),\n+        MISSING_WELL_KNOWN_ATTRIBUTE(\"Missing well known attribute\"),\n+        ATTRIBUTE_FLAGS_ERROR(\"Update attribute flags error\"),\n+        ATTRIBUTE_LENGTH_ERROR(\"Update attribute length error\"),\n+        INVALID_ORIGIN_ATTRIBUTE(\"Invalid origin\"),\n+        ROUTING_LOOP(\"Routing loop\"),\n+        INVALID_NEXT_HOP_ATTRIBUTE(\"Invalid next hop address/attribute\"),\n+        OPTIONAL_ATTRIBUTE_ERROR(\"Update optional attribute error\"),\n+        INVALID_NETWORK_FIELD(\"Invalid network field\"),\n+        MALFORMED_AS_PATH(\"Malformed AS_PATH\"),\n+\n+        // Hold Timer Expired\n+        HOLD_TIMER_EXPIRED(\"Hold timer expired\"),\n+\n+        // FSM Error\n+        FSM_ERROR(\"FSM error\"),\n+\n+        // Cease\n+        MAXIMUM_NUMBER_OF_PREFIXES_REACHED(\"Maximum number of prefixes reached\"),\n+        ADMINISTRATIVE_SHUTDOWN(\"Administrative shutdown\"),\n+        PEER_DECONFIGURED(\"Peer de-configured\"),\n+        ADMINISTRATIVE_RESET(\"Administrative reset\"),\n+        CONNECTION_RESET(\"Connection rejected\"),\n+        OTHER_CONFIGURATION_CHANGE(\"Other configuration change\"),\n+        CONNECTION_COLLISION_RESOLUTION(\"Connection collision resolution\"),\n+        OUT_OF_RESOURCES(\"Maximum number of prefixes reached\"),\n+\n+        UNKNOWN(\"Unknown notification type\"),\n+        ;\n+\n+        private String errorText;\n+\n+        Error(final String errorText) {\n+            this.errorText = errorText;\n+        }\n+\n+        public String getErrorText() {\n+            return errorText;\n+        }\n+\n+        public static Error from(final int code, final int subcode) {\n+            switch ((code << 8) + subcode) {\n+                case (1 << 8) + 1: return CONNECTION_NOT_SYNCHRONIZED;\n+                case (1 << 8) + 2: return BAD_MESSAGE_LENGTH;\n+                case (1 << 8) + 3: return BAD_MESSAGE_TYPE;\n+\n+                case (2 << 8) + 1: return UNSUPPORTED_VERSION_NUMBER;\n+                case (2 << 8) + 2: return BAD_PEER_AS;\n+                case (2 << 8) + 3: return BAD_BGP_IDENTIFIER;\n+                case (2 << 8) + 4: return UNSUPPORTED_OPTIONAL_PARAMETER;\n+                case (2 << 8) + 5: return AUTHENTICATION_FAILURE;\n+                case (2 << 8) + 6: return UNACCEPTABLE_HOLD_TIME;\n+\n+                case (3 << 8) + 1: return MALFORMED_ATTRIBUTE_LIST;\n+                case (3 << 8) + 2: return UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 3: return MISSING_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 4: return ATTRIBUTE_FLAGS_ERROR;\n+                case (3 << 8) + 5: return ATTRIBUTE_LENGTH_ERROR;\n+                case (3 << 8) + 6: return INVALID_ORIGIN_ATTRIBUTE;\n+                case (3 << 8) + 7: return ROUTING_LOOP;\n+                case (3 << 8) + 8: return INVALID_NEXT_HOP_ATTRIBUTE;\n+                case (3 << 8) + 9: return OPTIONAL_ATTRIBUTE_ERROR;\n+                case (3 << 8) + 10: return INVALID_NETWORK_FIELD;\n+                case (3 << 8) + 11: return MALFORMED_AS_PATH;\n+\n+                case (4 << 8) + 1: return HOLD_TIMER_EXPIRED;\n+\n+                case (5 << 8) + 1: return FSM_ERROR;\n+\n+                case (6 << 8) + 1: return MAXIMUM_NUMBER_OF_PREFIXES_REACHED;\n+                case (6 << 8) + 2: return ADMINISTRATIVE_SHUTDOWN;\n+                case (6 << 8) + 3: return PEER_DECONFIGURED;\n+                case (6 << 8) + 4: return ADMINISTRATIVE_RESET;\n+                case (6 << 8) + 5: return CONNECTION_RESET;\n+                case (6 << 8) + 6: return OTHER_CONFIGURATION_CHANGE;\n+                case (6 << 8) + 7: return CONNECTION_COLLISION_RESOLUTION;\n+                case (6 << 8) + 8: return OUT_OF_RESOURCES;\n+\n+                default:\n+                    LOG.warn(\"Unknown Notification Packet Code: {}/{}\", code, subcode);\n+                    return UNKNOWN;\n+            }\n+        }\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = new BmpKafkaProducer(adapterConfig);\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry,\n+                                 final BmpMessageHandler handler) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = Objects.requireNonNull(handler);\n+    }\n+\n+    private void handleHeartbeatMessage(final Transport.Message message,\n+                                        final Transport.Heartbeat heartbeat,\n+                                        final Context context) {\n+        final Collector collector = new Collector();\n+\n+        switch (heartbeat.getMode()) {\n+            case STARTED:\n+                collector.action = Collector.Action.STARTED;\n+                break;\n+            case STOPPED:\n+                collector.action = Collector.Action.STOPPED;\n+                break;\n+            case PERIODIC:\n+                collector.action = Collector.Action.HEARTBEAT;\n+                break;\n+            case CHANGE:\n+                collector.action = Collector.Action.CHANGE;\n+                break;\n+        }\n+\n+        collector.sequence = sequence.getAndIncrement();\n+        collector.adminId = context.adminId;\n+        collector.hash = context.collectorHashId;\n+        collector.routers = Lists.transform(heartbeat.getRoutersList(), BmpAdapterTools::address);\n+        collector.timestamp = context.timestamp;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.COLLECTOR, ImmutableList.of(collector)));\n+    }\n+\n+    private void handleInitiationMessage(final Transport.Message message,\n+                                         final Transport.InitiationPacket initiation,\n+                                         final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.INIT;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = initiation.getSysName();\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = initiation.getSysDesc();\n+        router.termCode = null;\n+        router.termReason = null;\n+        router.initData = initiation.getMessage();\n+        router.termData = null;\n+        router.timestamp = context.timestamp;\n+        router.bgpId = initiation.hasBgpId() ? BmpAdapterTools.address(initiation.getBgpId()) : null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handleTerminationMessage(final Transport.Message message,\n+                                          final Transport.TerminationPacket termination,\n+                                          final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.TERM;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = null;\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzNjY1Nw=="}, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTcwNjQ1OnYy", "diffSide": "RIGHT", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpIntegrationAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzo1MzowOVrOFv9nBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwOTozMTo1MFrOFw-L_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzNjgwNQ==", "bodyText": "TODO: Implement not or defer to JIRA?", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385836805", "createdAt": "2020-02-28T17:53:09Z", "author": {"login": "j-white"}, "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpIntegrationAdapter.java", "diffHunk": "@@ -0,0 +1,724 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.address;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.asAttr;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributeOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributesOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.isV4;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.timestamp;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.uint32;\n+\n+import java.net.InetAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+import org.opennms.core.utils.InetAddressUtils;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLog;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLogEntry;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Record;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Type;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.BaseAttribute;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Collector;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Peer;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Router;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Stat;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.UnicastPrefix;\n+import org.opennms.netmgt.telemetry.protocols.bmp.transport.Transport;\n+import org.opennms.netmgt.telemetry.protocols.collection.AbstractAdapter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+public class BmpIntegrationAdapter extends AbstractAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpIntegrationAdapter.class);\n+\n+    private final AtomicLong sequence = new AtomicLong();\n+\n+    private final BmpMessageHandler handler;\n+\n+    public enum Error {\n+        // Message Header Error\n+        CONNECTION_NOT_SYNCHRONIZED(\"Connection not synchronized\"),\n+        BAD_MESSAGE_LENGTH(\"Bad message header length\"),\n+        BAD_MESSAGE_TYPE(\"Bad message header type\"),\n+\n+        // Open Message Error\n+        UNSUPPORTED_VERSION_NUMBER(\"Unsupported BGP version\"),\n+        BAD_PEER_AS(\"Incorrect peer AS\"),\n+        BAD_BGP_IDENTIFIER(\"Bad BGP ID\"),\n+        UNSUPPORTED_OPTIONAL_PARAMETER(\"Unsupported optinal parameter\"),\n+        AUTHENTICATION_FAILURE(\"Authentication failure\"),\n+        UNACCEPTABLE_HOLD_TIME(\"Unacceptable hold time\"),\n+\n+        // Update Message Error\n+        MALFORMED_ATTRIBUTE_LIST(\"Malformed attribute list\"),\n+        UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE(\"Unrecognized well known attribute\"),\n+        MISSING_WELL_KNOWN_ATTRIBUTE(\"Missing well known attribute\"),\n+        ATTRIBUTE_FLAGS_ERROR(\"Update attribute flags error\"),\n+        ATTRIBUTE_LENGTH_ERROR(\"Update attribute length error\"),\n+        INVALID_ORIGIN_ATTRIBUTE(\"Invalid origin\"),\n+        ROUTING_LOOP(\"Routing loop\"),\n+        INVALID_NEXT_HOP_ATTRIBUTE(\"Invalid next hop address/attribute\"),\n+        OPTIONAL_ATTRIBUTE_ERROR(\"Update optional attribute error\"),\n+        INVALID_NETWORK_FIELD(\"Invalid network field\"),\n+        MALFORMED_AS_PATH(\"Malformed AS_PATH\"),\n+\n+        // Hold Timer Expired\n+        HOLD_TIMER_EXPIRED(\"Hold timer expired\"),\n+\n+        // FSM Error\n+        FSM_ERROR(\"FSM error\"),\n+\n+        // Cease\n+        MAXIMUM_NUMBER_OF_PREFIXES_REACHED(\"Maximum number of prefixes reached\"),\n+        ADMINISTRATIVE_SHUTDOWN(\"Administrative shutdown\"),\n+        PEER_DECONFIGURED(\"Peer de-configured\"),\n+        ADMINISTRATIVE_RESET(\"Administrative reset\"),\n+        CONNECTION_RESET(\"Connection rejected\"),\n+        OTHER_CONFIGURATION_CHANGE(\"Other configuration change\"),\n+        CONNECTION_COLLISION_RESOLUTION(\"Connection collision resolution\"),\n+        OUT_OF_RESOURCES(\"Maximum number of prefixes reached\"),\n+\n+        UNKNOWN(\"Unknown notification type\"),\n+        ;\n+\n+        private String errorText;\n+\n+        Error(final String errorText) {\n+            this.errorText = errorText;\n+        }\n+\n+        public String getErrorText() {\n+            return errorText;\n+        }\n+\n+        public static Error from(final int code, final int subcode) {\n+            switch ((code << 8) + subcode) {\n+                case (1 << 8) + 1: return CONNECTION_NOT_SYNCHRONIZED;\n+                case (1 << 8) + 2: return BAD_MESSAGE_LENGTH;\n+                case (1 << 8) + 3: return BAD_MESSAGE_TYPE;\n+\n+                case (2 << 8) + 1: return UNSUPPORTED_VERSION_NUMBER;\n+                case (2 << 8) + 2: return BAD_PEER_AS;\n+                case (2 << 8) + 3: return BAD_BGP_IDENTIFIER;\n+                case (2 << 8) + 4: return UNSUPPORTED_OPTIONAL_PARAMETER;\n+                case (2 << 8) + 5: return AUTHENTICATION_FAILURE;\n+                case (2 << 8) + 6: return UNACCEPTABLE_HOLD_TIME;\n+\n+                case (3 << 8) + 1: return MALFORMED_ATTRIBUTE_LIST;\n+                case (3 << 8) + 2: return UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 3: return MISSING_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 4: return ATTRIBUTE_FLAGS_ERROR;\n+                case (3 << 8) + 5: return ATTRIBUTE_LENGTH_ERROR;\n+                case (3 << 8) + 6: return INVALID_ORIGIN_ATTRIBUTE;\n+                case (3 << 8) + 7: return ROUTING_LOOP;\n+                case (3 << 8) + 8: return INVALID_NEXT_HOP_ATTRIBUTE;\n+                case (3 << 8) + 9: return OPTIONAL_ATTRIBUTE_ERROR;\n+                case (3 << 8) + 10: return INVALID_NETWORK_FIELD;\n+                case (3 << 8) + 11: return MALFORMED_AS_PATH;\n+\n+                case (4 << 8) + 1: return HOLD_TIMER_EXPIRED;\n+\n+                case (5 << 8) + 1: return FSM_ERROR;\n+\n+                case (6 << 8) + 1: return MAXIMUM_NUMBER_OF_PREFIXES_REACHED;\n+                case (6 << 8) + 2: return ADMINISTRATIVE_SHUTDOWN;\n+                case (6 << 8) + 3: return PEER_DECONFIGURED;\n+                case (6 << 8) + 4: return ADMINISTRATIVE_RESET;\n+                case (6 << 8) + 5: return CONNECTION_RESET;\n+                case (6 << 8) + 6: return OTHER_CONFIGURATION_CHANGE;\n+                case (6 << 8) + 7: return CONNECTION_COLLISION_RESOLUTION;\n+                case (6 << 8) + 8: return OUT_OF_RESOURCES;\n+\n+                default:\n+                    LOG.warn(\"Unknown Notification Packet Code: {}/{}\", code, subcode);\n+                    return UNKNOWN;\n+            }\n+        }\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = new BmpKafkaProducer(adapterConfig);\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry,\n+                                 final BmpMessageHandler handler) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = Objects.requireNonNull(handler);\n+    }\n+\n+    private void handleHeartbeatMessage(final Transport.Message message,\n+                                        final Transport.Heartbeat heartbeat,\n+                                        final Context context) {\n+        final Collector collector = new Collector();\n+\n+        switch (heartbeat.getMode()) {\n+            case STARTED:\n+                collector.action = Collector.Action.STARTED;\n+                break;\n+            case STOPPED:\n+                collector.action = Collector.Action.STOPPED;\n+                break;\n+            case PERIODIC:\n+                collector.action = Collector.Action.HEARTBEAT;\n+                break;\n+            case CHANGE:\n+                collector.action = Collector.Action.CHANGE;\n+                break;\n+        }\n+\n+        collector.sequence = sequence.getAndIncrement();\n+        collector.adminId = context.adminId;\n+        collector.hash = context.collectorHashId;\n+        collector.routers = Lists.transform(heartbeat.getRoutersList(), BmpAdapterTools::address);\n+        collector.timestamp = context.timestamp;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.COLLECTOR, ImmutableList.of(collector)));\n+    }\n+\n+    private void handleInitiationMessage(final Transport.Message message,\n+                                         final Transport.InitiationPacket initiation,\n+                                         final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.INIT;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = initiation.getSysName();\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = initiation.getSysDesc();\n+        router.termCode = null;\n+        router.termReason = null;\n+        router.initData = initiation.getMessage();\n+        router.termData = null;\n+        router.timestamp = context.timestamp;\n+        router.bgpId = initiation.hasBgpId() ? BmpAdapterTools.address(initiation.getBgpId()) : null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handleTerminationMessage(final Transport.Message message,\n+                                          final Transport.TerminationPacket termination,\n+                                          final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.TERM;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = null;\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = null;\n+        router.termCode = termination.getReason();\n+\n+        switch (router.termCode) {\n+            case 0:\n+                router.termReason = \"Session administratively closed.  The session might be re-initiated\";\n+                break;\n+            case 1:\n+                router.termReason = \"Unspecified reason\";\n+                break;\n+            case 2:\n+                router.termReason = \"Out of resources.  The router has exhausted resources available for the BMP session\";\n+                break;\n+            case 3:\n+                router.termReason = \"Redundant connection.  The router has determined that this connection is redundant with another one\";\n+                break;\n+            case 4:\n+                router.termReason = \"Session permanently administratively closed, will not be re-initiated\";\n+                break;\n+            default:\n+                router.termReason = \"Unknown reason\";\n+        }\n+\n+        router.initData = null;\n+        router.termData = termination.getMessage();\n+        router.timestamp = context.timestamp;\n+        router.bgpId = null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handlePeerUpNotification(final Transport.Message message,\n+                                          final Transport.PeerUpPacket peerUp,\n+                                          final Context context) {\n+        final Transport.Peer bgpPeer = peerUp.getPeer();\n+\n+        final Peer peer = new Peer();\n+        peer.action = Peer.Action.UP;\n+        peer.sequence = sequence.getAndIncrement();\n+        peer.name = InetAddressUtils.str(address(bgpPeer.getAddress())); // TODO: resolve Ip via DNS?\n+        peer.hash = Record.hash(bgpPeer.getAddress(),\n+                                bgpPeer.getDistinguisher(),\n+                                context.routerHashId);\n+        peer.routerHash = context.routerHashId;\n+        peer.remoteBgpId = address(peerUp.getRecvMsg().getId());\n+        peer.routerIp = context.sourceAddress;\n+        peer.timestamp = timestamp(bgpPeer.getTimestamp());\n+        peer.remoteAsn = uint32(peerUp.getRecvMsg().getAs());\n+        peer.remoteIp = address(bgpPeer.getAddress());\n+        peer.peerRd = asAttr((int) bgpPeer.getDistinguisher());\n+        peer.remotePort = peerUp.getRemotePort();\n+        peer.localAsn = uint32(peerUp.getSendMsg().getAs());\n+        peer.localIp = address(peerUp.getLocalAddress());\n+        peer.localPort = peerUp.getLocalPort();\n+        peer.localBgpId = address(peerUp.getSendMsg().getId());\n+        peer.infoData = peerUp.getMessage();\n+        peer.advertisedCapabilities = \"\"; // TODO: Not parsed right now\n+        peer.receivedCapabilities = \"\"; // TODO: Not parsed right now\n+        peer.remoteHolddown = uint32(peerUp.getRecvMsg().getHoldTime());\n+        peer.advertisedHolddown = uint32(peerUp.getSendMsg().getHoldTime());\n+        peer.bmpReason = null;\n+        peer.bgpErrorCode = null;\n+        peer.bgpErrorSubcode = null;\n+        peer.errorText = null;\n+        peer.l3vpn = bgpPeer.getType() == Transport.Peer.Type.RD_INSTANCE;\n+        peer.prePolicy = bgpPeer.getFlags().getPolicy() == Transport.Peer.Flags.Policy.PRE_POLICY;\n+        peer.ipv4 = isV4(bgpPeer.getAddress());\n+        peer.locRib = false; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg5NDg0NQ==", "bodyText": "Deferred to https://issues.opennms.org/browse/NMS-12570", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r386894845", "createdAt": "2020-03-03T09:31:50Z", "author": {"login": "fooker"}, "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpIntegrationAdapter.java", "diffHunk": "@@ -0,0 +1,724 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.address;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.asAttr;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributeOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributesOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.isV4;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.timestamp;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.uint32;\n+\n+import java.net.InetAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+import org.opennms.core.utils.InetAddressUtils;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLog;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLogEntry;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Record;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Type;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.BaseAttribute;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Collector;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Peer;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Router;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Stat;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.UnicastPrefix;\n+import org.opennms.netmgt.telemetry.protocols.bmp.transport.Transport;\n+import org.opennms.netmgt.telemetry.protocols.collection.AbstractAdapter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+public class BmpIntegrationAdapter extends AbstractAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpIntegrationAdapter.class);\n+\n+    private final AtomicLong sequence = new AtomicLong();\n+\n+    private final BmpMessageHandler handler;\n+\n+    public enum Error {\n+        // Message Header Error\n+        CONNECTION_NOT_SYNCHRONIZED(\"Connection not synchronized\"),\n+        BAD_MESSAGE_LENGTH(\"Bad message header length\"),\n+        BAD_MESSAGE_TYPE(\"Bad message header type\"),\n+\n+        // Open Message Error\n+        UNSUPPORTED_VERSION_NUMBER(\"Unsupported BGP version\"),\n+        BAD_PEER_AS(\"Incorrect peer AS\"),\n+        BAD_BGP_IDENTIFIER(\"Bad BGP ID\"),\n+        UNSUPPORTED_OPTIONAL_PARAMETER(\"Unsupported optinal parameter\"),\n+        AUTHENTICATION_FAILURE(\"Authentication failure\"),\n+        UNACCEPTABLE_HOLD_TIME(\"Unacceptable hold time\"),\n+\n+        // Update Message Error\n+        MALFORMED_ATTRIBUTE_LIST(\"Malformed attribute list\"),\n+        UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE(\"Unrecognized well known attribute\"),\n+        MISSING_WELL_KNOWN_ATTRIBUTE(\"Missing well known attribute\"),\n+        ATTRIBUTE_FLAGS_ERROR(\"Update attribute flags error\"),\n+        ATTRIBUTE_LENGTH_ERROR(\"Update attribute length error\"),\n+        INVALID_ORIGIN_ATTRIBUTE(\"Invalid origin\"),\n+        ROUTING_LOOP(\"Routing loop\"),\n+        INVALID_NEXT_HOP_ATTRIBUTE(\"Invalid next hop address/attribute\"),\n+        OPTIONAL_ATTRIBUTE_ERROR(\"Update optional attribute error\"),\n+        INVALID_NETWORK_FIELD(\"Invalid network field\"),\n+        MALFORMED_AS_PATH(\"Malformed AS_PATH\"),\n+\n+        // Hold Timer Expired\n+        HOLD_TIMER_EXPIRED(\"Hold timer expired\"),\n+\n+        // FSM Error\n+        FSM_ERROR(\"FSM error\"),\n+\n+        // Cease\n+        MAXIMUM_NUMBER_OF_PREFIXES_REACHED(\"Maximum number of prefixes reached\"),\n+        ADMINISTRATIVE_SHUTDOWN(\"Administrative shutdown\"),\n+        PEER_DECONFIGURED(\"Peer de-configured\"),\n+        ADMINISTRATIVE_RESET(\"Administrative reset\"),\n+        CONNECTION_RESET(\"Connection rejected\"),\n+        OTHER_CONFIGURATION_CHANGE(\"Other configuration change\"),\n+        CONNECTION_COLLISION_RESOLUTION(\"Connection collision resolution\"),\n+        OUT_OF_RESOURCES(\"Maximum number of prefixes reached\"),\n+\n+        UNKNOWN(\"Unknown notification type\"),\n+        ;\n+\n+        private String errorText;\n+\n+        Error(final String errorText) {\n+            this.errorText = errorText;\n+        }\n+\n+        public String getErrorText() {\n+            return errorText;\n+        }\n+\n+        public static Error from(final int code, final int subcode) {\n+            switch ((code << 8) + subcode) {\n+                case (1 << 8) + 1: return CONNECTION_NOT_SYNCHRONIZED;\n+                case (1 << 8) + 2: return BAD_MESSAGE_LENGTH;\n+                case (1 << 8) + 3: return BAD_MESSAGE_TYPE;\n+\n+                case (2 << 8) + 1: return UNSUPPORTED_VERSION_NUMBER;\n+                case (2 << 8) + 2: return BAD_PEER_AS;\n+                case (2 << 8) + 3: return BAD_BGP_IDENTIFIER;\n+                case (2 << 8) + 4: return UNSUPPORTED_OPTIONAL_PARAMETER;\n+                case (2 << 8) + 5: return AUTHENTICATION_FAILURE;\n+                case (2 << 8) + 6: return UNACCEPTABLE_HOLD_TIME;\n+\n+                case (3 << 8) + 1: return MALFORMED_ATTRIBUTE_LIST;\n+                case (3 << 8) + 2: return UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 3: return MISSING_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 4: return ATTRIBUTE_FLAGS_ERROR;\n+                case (3 << 8) + 5: return ATTRIBUTE_LENGTH_ERROR;\n+                case (3 << 8) + 6: return INVALID_ORIGIN_ATTRIBUTE;\n+                case (3 << 8) + 7: return ROUTING_LOOP;\n+                case (3 << 8) + 8: return INVALID_NEXT_HOP_ATTRIBUTE;\n+                case (3 << 8) + 9: return OPTIONAL_ATTRIBUTE_ERROR;\n+                case (3 << 8) + 10: return INVALID_NETWORK_FIELD;\n+                case (3 << 8) + 11: return MALFORMED_AS_PATH;\n+\n+                case (4 << 8) + 1: return HOLD_TIMER_EXPIRED;\n+\n+                case (5 << 8) + 1: return FSM_ERROR;\n+\n+                case (6 << 8) + 1: return MAXIMUM_NUMBER_OF_PREFIXES_REACHED;\n+                case (6 << 8) + 2: return ADMINISTRATIVE_SHUTDOWN;\n+                case (6 << 8) + 3: return PEER_DECONFIGURED;\n+                case (6 << 8) + 4: return ADMINISTRATIVE_RESET;\n+                case (6 << 8) + 5: return CONNECTION_RESET;\n+                case (6 << 8) + 6: return OTHER_CONFIGURATION_CHANGE;\n+                case (6 << 8) + 7: return CONNECTION_COLLISION_RESOLUTION;\n+                case (6 << 8) + 8: return OUT_OF_RESOURCES;\n+\n+                default:\n+                    LOG.warn(\"Unknown Notification Packet Code: {}/{}\", code, subcode);\n+                    return UNKNOWN;\n+            }\n+        }\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = new BmpKafkaProducer(adapterConfig);\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry,\n+                                 final BmpMessageHandler handler) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = Objects.requireNonNull(handler);\n+    }\n+\n+    private void handleHeartbeatMessage(final Transport.Message message,\n+                                        final Transport.Heartbeat heartbeat,\n+                                        final Context context) {\n+        final Collector collector = new Collector();\n+\n+        switch (heartbeat.getMode()) {\n+            case STARTED:\n+                collector.action = Collector.Action.STARTED;\n+                break;\n+            case STOPPED:\n+                collector.action = Collector.Action.STOPPED;\n+                break;\n+            case PERIODIC:\n+                collector.action = Collector.Action.HEARTBEAT;\n+                break;\n+            case CHANGE:\n+                collector.action = Collector.Action.CHANGE;\n+                break;\n+        }\n+\n+        collector.sequence = sequence.getAndIncrement();\n+        collector.adminId = context.adminId;\n+        collector.hash = context.collectorHashId;\n+        collector.routers = Lists.transform(heartbeat.getRoutersList(), BmpAdapterTools::address);\n+        collector.timestamp = context.timestamp;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.COLLECTOR, ImmutableList.of(collector)));\n+    }\n+\n+    private void handleInitiationMessage(final Transport.Message message,\n+                                         final Transport.InitiationPacket initiation,\n+                                         final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.INIT;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = initiation.getSysName();\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = initiation.getSysDesc();\n+        router.termCode = null;\n+        router.termReason = null;\n+        router.initData = initiation.getMessage();\n+        router.termData = null;\n+        router.timestamp = context.timestamp;\n+        router.bgpId = initiation.hasBgpId() ? BmpAdapterTools.address(initiation.getBgpId()) : null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handleTerminationMessage(final Transport.Message message,\n+                                          final Transport.TerminationPacket termination,\n+                                          final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.TERM;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = null;\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = null;\n+        router.termCode = termination.getReason();\n+\n+        switch (router.termCode) {\n+            case 0:\n+                router.termReason = \"Session administratively closed.  The session might be re-initiated\";\n+                break;\n+            case 1:\n+                router.termReason = \"Unspecified reason\";\n+                break;\n+            case 2:\n+                router.termReason = \"Out of resources.  The router has exhausted resources available for the BMP session\";\n+                break;\n+            case 3:\n+                router.termReason = \"Redundant connection.  The router has determined that this connection is redundant with another one\";\n+                break;\n+            case 4:\n+                router.termReason = \"Session permanently administratively closed, will not be re-initiated\";\n+                break;\n+            default:\n+                router.termReason = \"Unknown reason\";\n+        }\n+\n+        router.initData = null;\n+        router.termData = termination.getMessage();\n+        router.timestamp = context.timestamp;\n+        router.bgpId = null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handlePeerUpNotification(final Transport.Message message,\n+                                          final Transport.PeerUpPacket peerUp,\n+                                          final Context context) {\n+        final Transport.Peer bgpPeer = peerUp.getPeer();\n+\n+        final Peer peer = new Peer();\n+        peer.action = Peer.Action.UP;\n+        peer.sequence = sequence.getAndIncrement();\n+        peer.name = InetAddressUtils.str(address(bgpPeer.getAddress())); // TODO: resolve Ip via DNS?\n+        peer.hash = Record.hash(bgpPeer.getAddress(),\n+                                bgpPeer.getDistinguisher(),\n+                                context.routerHashId);\n+        peer.routerHash = context.routerHashId;\n+        peer.remoteBgpId = address(peerUp.getRecvMsg().getId());\n+        peer.routerIp = context.sourceAddress;\n+        peer.timestamp = timestamp(bgpPeer.getTimestamp());\n+        peer.remoteAsn = uint32(peerUp.getRecvMsg().getAs());\n+        peer.remoteIp = address(bgpPeer.getAddress());\n+        peer.peerRd = asAttr((int) bgpPeer.getDistinguisher());\n+        peer.remotePort = peerUp.getRemotePort();\n+        peer.localAsn = uint32(peerUp.getSendMsg().getAs());\n+        peer.localIp = address(peerUp.getLocalAddress());\n+        peer.localPort = peerUp.getLocalPort();\n+        peer.localBgpId = address(peerUp.getSendMsg().getId());\n+        peer.infoData = peerUp.getMessage();\n+        peer.advertisedCapabilities = \"\"; // TODO: Not parsed right now\n+        peer.receivedCapabilities = \"\"; // TODO: Not parsed right now\n+        peer.remoteHolddown = uint32(peerUp.getRecvMsg().getHoldTime());\n+        peer.advertisedHolddown = uint32(peerUp.getSendMsg().getHoldTime());\n+        peer.bmpReason = null;\n+        peer.bgpErrorCode = null;\n+        peer.bgpErrorSubcode = null;\n+        peer.errorText = null;\n+        peer.l3vpn = bgpPeer.getType() == Transport.Peer.Type.RD_INSTANCE;\n+        peer.prePolicy = bgpPeer.getFlags().getPolicy() == Transport.Peer.Flags.Policy.PRE_POLICY;\n+        peer.ipv4 = isV4(bgpPeer.getAddress());\n+        peer.locRib = false; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzNjgwNQ=="}, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 321}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTcwNzkxOnYy", "diffSide": "RIGHT", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpIntegrationAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzo1MzozOFrOFv9n5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMDo0NDoyM1rOFxAs-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzNzAyOQ==", "bodyText": "FIXME: Defer?", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385837029", "createdAt": "2020-02-28T17:53:38Z", "author": {"login": "j-white"}, "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpIntegrationAdapter.java", "diffHunk": "@@ -0,0 +1,724 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.address;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.asAttr;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributeOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributesOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.isV4;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.timestamp;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.uint32;\n+\n+import java.net.InetAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+import org.opennms.core.utils.InetAddressUtils;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLog;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLogEntry;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Record;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Type;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.BaseAttribute;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Collector;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Peer;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Router;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Stat;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.UnicastPrefix;\n+import org.opennms.netmgt.telemetry.protocols.bmp.transport.Transport;\n+import org.opennms.netmgt.telemetry.protocols.collection.AbstractAdapter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+public class BmpIntegrationAdapter extends AbstractAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpIntegrationAdapter.class);\n+\n+    private final AtomicLong sequence = new AtomicLong();\n+\n+    private final BmpMessageHandler handler;\n+\n+    public enum Error {\n+        // Message Header Error\n+        CONNECTION_NOT_SYNCHRONIZED(\"Connection not synchronized\"),\n+        BAD_MESSAGE_LENGTH(\"Bad message header length\"),\n+        BAD_MESSAGE_TYPE(\"Bad message header type\"),\n+\n+        // Open Message Error\n+        UNSUPPORTED_VERSION_NUMBER(\"Unsupported BGP version\"),\n+        BAD_PEER_AS(\"Incorrect peer AS\"),\n+        BAD_BGP_IDENTIFIER(\"Bad BGP ID\"),\n+        UNSUPPORTED_OPTIONAL_PARAMETER(\"Unsupported optinal parameter\"),\n+        AUTHENTICATION_FAILURE(\"Authentication failure\"),\n+        UNACCEPTABLE_HOLD_TIME(\"Unacceptable hold time\"),\n+\n+        // Update Message Error\n+        MALFORMED_ATTRIBUTE_LIST(\"Malformed attribute list\"),\n+        UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE(\"Unrecognized well known attribute\"),\n+        MISSING_WELL_KNOWN_ATTRIBUTE(\"Missing well known attribute\"),\n+        ATTRIBUTE_FLAGS_ERROR(\"Update attribute flags error\"),\n+        ATTRIBUTE_LENGTH_ERROR(\"Update attribute length error\"),\n+        INVALID_ORIGIN_ATTRIBUTE(\"Invalid origin\"),\n+        ROUTING_LOOP(\"Routing loop\"),\n+        INVALID_NEXT_HOP_ATTRIBUTE(\"Invalid next hop address/attribute\"),\n+        OPTIONAL_ATTRIBUTE_ERROR(\"Update optional attribute error\"),\n+        INVALID_NETWORK_FIELD(\"Invalid network field\"),\n+        MALFORMED_AS_PATH(\"Malformed AS_PATH\"),\n+\n+        // Hold Timer Expired\n+        HOLD_TIMER_EXPIRED(\"Hold timer expired\"),\n+\n+        // FSM Error\n+        FSM_ERROR(\"FSM error\"),\n+\n+        // Cease\n+        MAXIMUM_NUMBER_OF_PREFIXES_REACHED(\"Maximum number of prefixes reached\"),\n+        ADMINISTRATIVE_SHUTDOWN(\"Administrative shutdown\"),\n+        PEER_DECONFIGURED(\"Peer de-configured\"),\n+        ADMINISTRATIVE_RESET(\"Administrative reset\"),\n+        CONNECTION_RESET(\"Connection rejected\"),\n+        OTHER_CONFIGURATION_CHANGE(\"Other configuration change\"),\n+        CONNECTION_COLLISION_RESOLUTION(\"Connection collision resolution\"),\n+        OUT_OF_RESOURCES(\"Maximum number of prefixes reached\"),\n+\n+        UNKNOWN(\"Unknown notification type\"),\n+        ;\n+\n+        private String errorText;\n+\n+        Error(final String errorText) {\n+            this.errorText = errorText;\n+        }\n+\n+        public String getErrorText() {\n+            return errorText;\n+        }\n+\n+        public static Error from(final int code, final int subcode) {\n+            switch ((code << 8) + subcode) {\n+                case (1 << 8) + 1: return CONNECTION_NOT_SYNCHRONIZED;\n+                case (1 << 8) + 2: return BAD_MESSAGE_LENGTH;\n+                case (1 << 8) + 3: return BAD_MESSAGE_TYPE;\n+\n+                case (2 << 8) + 1: return UNSUPPORTED_VERSION_NUMBER;\n+                case (2 << 8) + 2: return BAD_PEER_AS;\n+                case (2 << 8) + 3: return BAD_BGP_IDENTIFIER;\n+                case (2 << 8) + 4: return UNSUPPORTED_OPTIONAL_PARAMETER;\n+                case (2 << 8) + 5: return AUTHENTICATION_FAILURE;\n+                case (2 << 8) + 6: return UNACCEPTABLE_HOLD_TIME;\n+\n+                case (3 << 8) + 1: return MALFORMED_ATTRIBUTE_LIST;\n+                case (3 << 8) + 2: return UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 3: return MISSING_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 4: return ATTRIBUTE_FLAGS_ERROR;\n+                case (3 << 8) + 5: return ATTRIBUTE_LENGTH_ERROR;\n+                case (3 << 8) + 6: return INVALID_ORIGIN_ATTRIBUTE;\n+                case (3 << 8) + 7: return ROUTING_LOOP;\n+                case (3 << 8) + 8: return INVALID_NEXT_HOP_ATTRIBUTE;\n+                case (3 << 8) + 9: return OPTIONAL_ATTRIBUTE_ERROR;\n+                case (3 << 8) + 10: return INVALID_NETWORK_FIELD;\n+                case (3 << 8) + 11: return MALFORMED_AS_PATH;\n+\n+                case (4 << 8) + 1: return HOLD_TIMER_EXPIRED;\n+\n+                case (5 << 8) + 1: return FSM_ERROR;\n+\n+                case (6 << 8) + 1: return MAXIMUM_NUMBER_OF_PREFIXES_REACHED;\n+                case (6 << 8) + 2: return ADMINISTRATIVE_SHUTDOWN;\n+                case (6 << 8) + 3: return PEER_DECONFIGURED;\n+                case (6 << 8) + 4: return ADMINISTRATIVE_RESET;\n+                case (6 << 8) + 5: return CONNECTION_RESET;\n+                case (6 << 8) + 6: return OTHER_CONFIGURATION_CHANGE;\n+                case (6 << 8) + 7: return CONNECTION_COLLISION_RESOLUTION;\n+                case (6 << 8) + 8: return OUT_OF_RESOURCES;\n+\n+                default:\n+                    LOG.warn(\"Unknown Notification Packet Code: {}/{}\", code, subcode);\n+                    return UNKNOWN;\n+            }\n+        }\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = new BmpKafkaProducer(adapterConfig);\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry,\n+                                 final BmpMessageHandler handler) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = Objects.requireNonNull(handler);\n+    }\n+\n+    private void handleHeartbeatMessage(final Transport.Message message,\n+                                        final Transport.Heartbeat heartbeat,\n+                                        final Context context) {\n+        final Collector collector = new Collector();\n+\n+        switch (heartbeat.getMode()) {\n+            case STARTED:\n+                collector.action = Collector.Action.STARTED;\n+                break;\n+            case STOPPED:\n+                collector.action = Collector.Action.STOPPED;\n+                break;\n+            case PERIODIC:\n+                collector.action = Collector.Action.HEARTBEAT;\n+                break;\n+            case CHANGE:\n+                collector.action = Collector.Action.CHANGE;\n+                break;\n+        }\n+\n+        collector.sequence = sequence.getAndIncrement();\n+        collector.adminId = context.adminId;\n+        collector.hash = context.collectorHashId;\n+        collector.routers = Lists.transform(heartbeat.getRoutersList(), BmpAdapterTools::address);\n+        collector.timestamp = context.timestamp;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.COLLECTOR, ImmutableList.of(collector)));\n+    }\n+\n+    private void handleInitiationMessage(final Transport.Message message,\n+                                         final Transport.InitiationPacket initiation,\n+                                         final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.INIT;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = initiation.getSysName();\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = initiation.getSysDesc();\n+        router.termCode = null;\n+        router.termReason = null;\n+        router.initData = initiation.getMessage();\n+        router.termData = null;\n+        router.timestamp = context.timestamp;\n+        router.bgpId = initiation.hasBgpId() ? BmpAdapterTools.address(initiation.getBgpId()) : null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handleTerminationMessage(final Transport.Message message,\n+                                          final Transport.TerminationPacket termination,\n+                                          final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.TERM;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = null;\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = null;\n+        router.termCode = termination.getReason();\n+\n+        switch (router.termCode) {\n+            case 0:\n+                router.termReason = \"Session administratively closed.  The session might be re-initiated\";\n+                break;\n+            case 1:\n+                router.termReason = \"Unspecified reason\";\n+                break;\n+            case 2:\n+                router.termReason = \"Out of resources.  The router has exhausted resources available for the BMP session\";\n+                break;\n+            case 3:\n+                router.termReason = \"Redundant connection.  The router has determined that this connection is redundant with another one\";\n+                break;\n+            case 4:\n+                router.termReason = \"Session permanently administratively closed, will not be re-initiated\";\n+                break;\n+            default:\n+                router.termReason = \"Unknown reason\";\n+        }\n+\n+        router.initData = null;\n+        router.termData = termination.getMessage();\n+        router.timestamp = context.timestamp;\n+        router.bgpId = null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handlePeerUpNotification(final Transport.Message message,\n+                                          final Transport.PeerUpPacket peerUp,\n+                                          final Context context) {\n+        final Transport.Peer bgpPeer = peerUp.getPeer();\n+\n+        final Peer peer = new Peer();\n+        peer.action = Peer.Action.UP;\n+        peer.sequence = sequence.getAndIncrement();\n+        peer.name = InetAddressUtils.str(address(bgpPeer.getAddress())); // TODO: resolve Ip via DNS?\n+        peer.hash = Record.hash(bgpPeer.getAddress(),\n+                                bgpPeer.getDistinguisher(),\n+                                context.routerHashId);\n+        peer.routerHash = context.routerHashId;\n+        peer.remoteBgpId = address(peerUp.getRecvMsg().getId());\n+        peer.routerIp = context.sourceAddress;\n+        peer.timestamp = timestamp(bgpPeer.getTimestamp());\n+        peer.remoteAsn = uint32(peerUp.getRecvMsg().getAs());\n+        peer.remoteIp = address(bgpPeer.getAddress());\n+        peer.peerRd = asAttr((int) bgpPeer.getDistinguisher());\n+        peer.remotePort = peerUp.getRemotePort();\n+        peer.localAsn = uint32(peerUp.getSendMsg().getAs());\n+        peer.localIp = address(peerUp.getLocalAddress());\n+        peer.localPort = peerUp.getLocalPort();\n+        peer.localBgpId = address(peerUp.getSendMsg().getId());\n+        peer.infoData = peerUp.getMessage();\n+        peer.advertisedCapabilities = \"\"; // TODO: Not parsed right now\n+        peer.receivedCapabilities = \"\"; // TODO: Not parsed right now\n+        peer.remoteHolddown = uint32(peerUp.getRecvMsg().getHoldTime());\n+        peer.advertisedHolddown = uint32(peerUp.getSendMsg().getHoldTime());\n+        peer.bmpReason = null;\n+        peer.bgpErrorCode = null;\n+        peer.bgpErrorSubcode = null;\n+        peer.errorText = null;\n+        peer.l3vpn = bgpPeer.getType() == Transport.Peer.Type.RD_INSTANCE;\n+        peer.prePolicy = bgpPeer.getFlags().getPolicy() == Transport.Peer.Flags.Policy.PRE_POLICY;\n+        peer.ipv4 = isV4(bgpPeer.getAddress());\n+        peer.locRib = false; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+        peer.locRibFiltered = false; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+        peer.tableName = \"\"; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.PEER, ImmutableList.of(peer)));\n+    }\n+\n+    private void handlePeerDownNotification(final Transport.Message message,\n+                                            final Transport.PeerDownPacket peerDown,\n+                                            final Context context) {\n+        final Transport.Peer bgpPeer = peerDown.getPeer();\n+\n+        final Peer peer = new Peer();\n+        peer.action = Peer.Action.DOWN;\n+        peer.sequence = sequence.getAndIncrement();\n+        peer.name = InetAddressUtils.str(address(bgpPeer.getAddress())); // TODO: resolve Ip via DNS?\n+        peer.hash = Record.hash(bgpPeer.getAddress(),\n+                bgpPeer.getDistinguisher(),\n+                context.routerHashId);\n+        peer.routerHash = context.routerHashId;\n+        peer.remoteBgpId = address(bgpPeer.getId());\n+        peer.routerIp = context.sourceAddress;\n+        peer.timestamp = timestamp(bgpPeer.getTimestamp());\n+        peer.remoteAsn = uint32(bgpPeer.getAs());\n+        peer.remoteIp = address(bgpPeer.getAddress());\n+        peer.peerRd = asAttr((int) bgpPeer.getDistinguisher());\n+        peer.remotePort = null;\n+        peer.localAsn = null;\n+        peer.localIp = null;\n+        peer.localPort = null;\n+        peer.localBgpId = null;\n+        peer.infoData = null;\n+        peer.advertisedCapabilities = null;\n+        peer.receivedCapabilities = null;\n+        peer.remoteHolddown = null;\n+        peer.advertisedHolddown = null;\n+        peer.bmpReason = peerDown.getReasonCase().getNumber() - 1;\n+\n+        switch (peerDown.getReasonCase().getNumber()) {\n+            case 2:\n+                peer.bgpErrorCode = peerDown.getLocalBgpNotification().getCode();\n+                peer.bgpErrorSubcode = peerDown.getLocalBgpNotification().getSubcode();\n+                break;\n+            case 4:\n+                peer.bgpErrorCode = peerDown.getRemoteBgpNotification().getCode();\n+                peer.bgpErrorSubcode = peerDown.getRemoteBgpNotification().getSubcode();\n+                break;\n+            default:\n+                peer.bgpErrorCode = null;\n+                peer.bgpErrorSubcode = null;\n+        }\n+\n+        if (peer.bgpErrorCode != null && peer.bgpErrorSubcode != null) {\n+            peer.errorText = Error.from(peer.bgpErrorCode, peer.bgpErrorSubcode).getErrorText();\n+        }\n+\n+        peer.l3vpn = bgpPeer.getType() == Transport.Peer.Type.RD_INSTANCE;\n+        peer.prePolicy = bgpPeer.getFlags().getPolicy() == Transport.Peer.Flags.Policy.PRE_POLICY;\n+        peer.ipv4 = isV4(bgpPeer.getAddress());\n+        peer.locRib = false; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+        peer.locRibFiltered = false; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+        peer.tableName = \"\"; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.PEER, ImmutableList.of(peer)));\n+    }\n+\n+    private void handleStatisticReport(final Transport.Message message,\n+                                       final Transport.StatisticsReportPacket statisticsReport,\n+                                       final Context context) {\n+        final Transport.Peer peer = statisticsReport.getPeer();\n+\n+        final Stat stat = new Stat();\n+        stat.action = Stat.Action.ADD;\n+        stat.sequence = sequence.getAndIncrement();\n+        stat.routerHash = Record.hash(context.sourceAddress.getHostAddress(), Integer.toString(context.sourcePort), context.collectorHashId);\n+        stat.routerIp = context.sourceAddress;\n+        stat.peerHash = Record.hash(peer.getAddress(), peer.getDistinguisher(), stat.routerHash);\n+        stat.peerIp = address(peer.getAddress());\n+        stat.peerAsn = uint32(peer.getAs());\n+        stat.timestamp = timestamp(peer.getTimestamp());\n+        stat.prefixesRejected = statisticsReport.getRejected().getCount();\n+        stat.knownDupPrefixes = statisticsReport.getDuplicatePrefix().getCount();\n+        stat.knownDupWithdraws = statisticsReport.getDuplicateWithdraw().getCount();\n+        stat.invalidClusterList = statisticsReport.getInvalidUpdateDueToClusterListLoop().getCount();\n+        stat.invalidAsPath = statisticsReport.getInvalidUpdateDueToAsPathLoop().getCount();\n+        stat.invalidOriginatorId = statisticsReport.getInvalidUpdateDueToOriginatorId().getCount();\n+        stat.invalidAsConfed = statisticsReport.getInvalidUpdateDueToAsConfedLoop().getCount();\n+        stat.prefixesPrePolicy = statisticsReport.getAdjRibIn().getValue();\n+        stat.prefixesPostPolicy = statisticsReport.getLocRib().getValue();\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.BMP_STAT, ImmutableList.of(stat)));\n+    }\n+\n+    private BaseAttribute toBaseAttributeRecord(final Transport.RouteMonitoringPacket routeMonitoring,\n+                                                final Context context) {\n+        final Transport.Peer peer = routeMonitoring.getPeer();\n+\n+        final BaseAttribute baseAttr = new BaseAttribute();\n+        baseAttr.action = BaseAttribute.Action.ADD; // Action is always ADD - attributes are never withdrawn\n+        baseAttr.sequence = this.sequence.getAndIncrement();\n+        baseAttr.routerHash = context.getRouterHash();\n+        baseAttr.routerIp = context.sourceAddress;\n+        baseAttr.peerHash = Record.hash(peer.getAddress(), peer.getDistinguisher(), baseAttr.routerHash);\n+        baseAttr.peerIp = address(peer.getAddress());\n+        baseAttr.peerAsn = uint32(peer.getAs());\n+        baseAttr.timestamp = context.timestamp;\n+\n+        // Derive the origin of the prefix from the path attributes - default to an empty string if not set\n+        baseAttr.origin = getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.ORIGIN)\n+                .map(attr -> attr.getOrigin().name().toLowerCase()).orElse(\"\");\n+\n+        // Build the AS path from the path attributes - default to an empty string if not set\n+        // See UpdateMsg::parseAttr_AsPath in the OpenBMP collector for the corresponding logic\n+        baseAttr.asPathCount = 0;\n+\n+        baseAttr.asPath = getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.AS_PATH)\n+                .map(asPathAttr -> {\n+                    final StringBuilder asPath = new StringBuilder();\n+\n+                    asPathAttr.getAsPath().getSegmentsList().forEach(segment -> {\n+                        if (Transport.RouteMonitoringPacket.PathAttribute.AsPath.Segment.Type.AS_SET.equals(segment.getType())) {\n+                            asPath.append(\"{\");\n+                        }\n+                        segment.getPathsList().forEach(segmentPath -> {\n+                            asPath.append(segmentPath);\n+                            asPath.append(\" \");\n+                            baseAttr.asPathCount++;\n+                            baseAttr.originAs = uint32(segmentPath);\n+                        });\n+                        if (Transport.RouteMonitoringPacket.PathAttribute.AsPath.Segment.Type.AS_SET.equals(segment.getType())) {\n+                            asPath.append(\"}\");\n+                        }\n+                    });\n+\n+                    return asPath.toString();\n+                })\n+                .orElse(\"\");\n+\n+        // Derive the next hop from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.NEXT_HOP)\n+                .map(attr -> attr.getNextHop().getAddress())\n+                .ifPresent(nextHop -> {\n+                    baseAttr.nextHop = address(nextHop);\n+                    baseAttr.nextHopIpv4 = isV4(nextHop);\n+                });\n+\n+        // Derive the Multi Exit Discriminator (MED) from the path attributes (lower values are preferred)\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.MULTI_EXIT_DISC)\n+                .map(attr -> attr.getMultiExitDisc().getDiscriminator())\n+                .ifPresent(med -> {\n+                    baseAttr.med = uint32(med);\n+                });\n+\n+        // Derive the local preference from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.LOCAL_PREF)\n+                .map(attr -> attr.getLocalPref().getPreference())\n+                .ifPresent(localPref -> {\n+                    baseAttr.localPref = uint32(localPref);\n+                });\n+\n+        // Derive the aggregator from the path attributes\n+        // See UpdateMsg::parseAttr_Aggegator in the OpenBMP collector for the corresponding logic\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.AGGREGATOR)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getAggregator)\n+                .ifPresent(agg -> {\n+                    baseAttr.aggregator = String.format(\"%d %s\", agg.getAs(), BmpAdapterTools.addressAsStr(agg.getAddress()));\n+                });\n+\n+        // Derive the community list from the path attributes\n+        baseAttr.communityList = getPathAttributesOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.COMMUNITY)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getCommunity)\n+                .map(BmpAdapterTools::asAttr)\n+                .collect(Collectors.joining(\" \"));\n+\n+        // Derive the extended community list from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.EXTENDED_COMMUNITIES)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getExtendedCommunities)\n+                .ifPresent(extendedCommunities -> {\n+                    baseAttr.extCommunityList = extendedCommunities.getExtendedCommunitiesList().stream()\n+                            .map(extendedCommunity -> String.format(\"%d:%s\",\n+                                    uint32(extendedCommunity.getType()),\n+                                    extendedCommunity.getValue()))\n+                            .collect(Collectors.joining(\" \"));\n+                });\n+\n+        // Derive the cluster list from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.CLUSTER_LIST)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getClusterList)\n+                .ifPresent(clusterList -> {\n+                    baseAttr.clusterList = clusterList.getClusterIdList().stream()\n+                            .map(BmpAdapterTools::addressAsStr)\n+                            .collect(Collectors.joining(\" \"));\n+                });\n+\n+        // Derive the large community list from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.LARGE_COMMUNITIES)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getLargeCommunities)\n+                .ifPresent(largeCommunities -> {\n+                    baseAttr.largeCommunityList = largeCommunities.getLargeCommunitiesList().stream()\n+                            .map(largeCommunity -> String.format(\"%d:%d:%d\",\n+                                    uint32(largeCommunity.getGlobalAdministrator()),\n+                                    uint32(largeCommunity.getLocalDataPart1()),\n+                                    uint32(largeCommunity.getLocalDataPart2())))\n+                            .collect(Collectors.joining(\" \"));\n+                });\n+\n+        // Derive the originator id from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.ORIGINATOR_ID)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getOriginatorId)\n+                .ifPresent(originatorId -> {\n+                    baseAttr.originatorId = Long.toString(uint32(originatorId));\n+                });\n+\n+        // Set the atomic flag is the atomic aggregate path attribute is present\n+        baseAttr.atomicAgg = getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.ATOMIC_AGGREGATE)\n+                .isPresent();\n+\n+        // Compute hash - fields [ as path, next hop, aggregator, origin, med, local pref, community list, ext community list, peer hash ]\n+        baseAttr.hash = Record.hash(baseAttr.asPath,\n+                                    Record.nullSafeStr(baseAttr.nextHop),\n+                                    baseAttr.aggregator,\n+                                    baseAttr.origin,\n+                                    Record.nullSafeStr(baseAttr.med),\n+                                    Record.nullSafeStr(baseAttr.localPref),\n+                                    baseAttr.communityList,\n+                                    baseAttr.extCommunityList,\n+                                    baseAttr.peerHash);\n+\n+        return baseAttr;\n+    }\n+\n+    private UnicastPrefix toUnicastPrefixRecord(final Transport.RouteMonitoringPacket routeMonitoring,\n+                                                final Transport.RouteMonitoringPacket.Route route,\n+                                                final BaseAttribute baseAttr,\n+                                                final Context context) {\n+        final Transport.Peer peer = routeMonitoring.getPeer();\n+\n+        final UnicastPrefix unicastPrefix = new UnicastPrefix();\n+        unicastPrefix.sequence = this.sequence.incrementAndGet();\n+        unicastPrefix.routerHash = context.getRouterHash();\n+        unicastPrefix.routerIp = context.sourceAddress;\n+        unicastPrefix.peerHash = Record.hash(peer.getAddress(), peer.getDistinguisher(), unicastPrefix.routerHash);\n+        unicastPrefix.peerIp = address(peer.getAddress());\n+        unicastPrefix.peerAsn = uint32(peer.getAs());\n+        unicastPrefix.timestamp = context.timestamp;\n+        unicastPrefix.prefix = address(route.getPrefix());\n+        unicastPrefix.length = route.getLength();\n+        unicastPrefix.ipv4 = isV4(route.getPrefix());\n+        // TODO: Populate path id and labels attributes - see NMS-12560\n+        unicastPrefix.pathId = 0;\n+        unicastPrefix.labels = null;\n+        unicastPrefix.prePolicy = Transport.Peer.Flags.Policy.PRE_POLICY.equals(peer.getFlags().getPolicy());\n+\n+        // Augment with base attributes if present\n+        if (baseAttr != null) {\n+            unicastPrefix.baseAttrHash = baseAttr.hash;\n+            unicastPrefix.origin = baseAttr.origin;\n+            unicastPrefix.asPath = baseAttr.asPath;\n+            unicastPrefix.asPathCount = baseAttr.asPathCount;\n+            unicastPrefix.originAs = baseAttr.originAs;\n+            unicastPrefix.nextHop = baseAttr.nextHop;\n+            unicastPrefix.med = baseAttr.med;\n+            unicastPrefix.localPref = baseAttr.localPref;\n+            unicastPrefix.aggregator = baseAttr.aggregator;\n+            unicastPrefix.communityList = baseAttr.communityList;\n+            unicastPrefix.extCommunityList = baseAttr.extCommunityList;\n+            unicastPrefix.clusterList = baseAttr.clusterList;\n+            unicastPrefix.atomicAgg = baseAttr.atomicAgg;\n+            unicastPrefix.nextHopIpv4 = baseAttr.nextHopIpv4;\n+            unicastPrefix.originatorId = baseAttr.originatorId;\n+            unicastPrefix.largeCommunityList = baseAttr.largeCommunityList;\n+        }\n+        // FIXME: isAdjIn?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 593}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjkzNjA1OQ==", "bodyText": "Implemented.", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r386936059", "createdAt": "2020-03-03T10:44:23Z", "author": {"login": "fooker"}, "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpIntegrationAdapter.java", "diffHunk": "@@ -0,0 +1,724 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.address;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.asAttr;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributeOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributesOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.isV4;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.timestamp;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.uint32;\n+\n+import java.net.InetAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+import org.opennms.core.utils.InetAddressUtils;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLog;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLogEntry;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Record;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Type;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.BaseAttribute;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Collector;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Peer;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Router;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Stat;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.UnicastPrefix;\n+import org.opennms.netmgt.telemetry.protocols.bmp.transport.Transport;\n+import org.opennms.netmgt.telemetry.protocols.collection.AbstractAdapter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+public class BmpIntegrationAdapter extends AbstractAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpIntegrationAdapter.class);\n+\n+    private final AtomicLong sequence = new AtomicLong();\n+\n+    private final BmpMessageHandler handler;\n+\n+    public enum Error {\n+        // Message Header Error\n+        CONNECTION_NOT_SYNCHRONIZED(\"Connection not synchronized\"),\n+        BAD_MESSAGE_LENGTH(\"Bad message header length\"),\n+        BAD_MESSAGE_TYPE(\"Bad message header type\"),\n+\n+        // Open Message Error\n+        UNSUPPORTED_VERSION_NUMBER(\"Unsupported BGP version\"),\n+        BAD_PEER_AS(\"Incorrect peer AS\"),\n+        BAD_BGP_IDENTIFIER(\"Bad BGP ID\"),\n+        UNSUPPORTED_OPTIONAL_PARAMETER(\"Unsupported optinal parameter\"),\n+        AUTHENTICATION_FAILURE(\"Authentication failure\"),\n+        UNACCEPTABLE_HOLD_TIME(\"Unacceptable hold time\"),\n+\n+        // Update Message Error\n+        MALFORMED_ATTRIBUTE_LIST(\"Malformed attribute list\"),\n+        UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE(\"Unrecognized well known attribute\"),\n+        MISSING_WELL_KNOWN_ATTRIBUTE(\"Missing well known attribute\"),\n+        ATTRIBUTE_FLAGS_ERROR(\"Update attribute flags error\"),\n+        ATTRIBUTE_LENGTH_ERROR(\"Update attribute length error\"),\n+        INVALID_ORIGIN_ATTRIBUTE(\"Invalid origin\"),\n+        ROUTING_LOOP(\"Routing loop\"),\n+        INVALID_NEXT_HOP_ATTRIBUTE(\"Invalid next hop address/attribute\"),\n+        OPTIONAL_ATTRIBUTE_ERROR(\"Update optional attribute error\"),\n+        INVALID_NETWORK_FIELD(\"Invalid network field\"),\n+        MALFORMED_AS_PATH(\"Malformed AS_PATH\"),\n+\n+        // Hold Timer Expired\n+        HOLD_TIMER_EXPIRED(\"Hold timer expired\"),\n+\n+        // FSM Error\n+        FSM_ERROR(\"FSM error\"),\n+\n+        // Cease\n+        MAXIMUM_NUMBER_OF_PREFIXES_REACHED(\"Maximum number of prefixes reached\"),\n+        ADMINISTRATIVE_SHUTDOWN(\"Administrative shutdown\"),\n+        PEER_DECONFIGURED(\"Peer de-configured\"),\n+        ADMINISTRATIVE_RESET(\"Administrative reset\"),\n+        CONNECTION_RESET(\"Connection rejected\"),\n+        OTHER_CONFIGURATION_CHANGE(\"Other configuration change\"),\n+        CONNECTION_COLLISION_RESOLUTION(\"Connection collision resolution\"),\n+        OUT_OF_RESOURCES(\"Maximum number of prefixes reached\"),\n+\n+        UNKNOWN(\"Unknown notification type\"),\n+        ;\n+\n+        private String errorText;\n+\n+        Error(final String errorText) {\n+            this.errorText = errorText;\n+        }\n+\n+        public String getErrorText() {\n+            return errorText;\n+        }\n+\n+        public static Error from(final int code, final int subcode) {\n+            switch ((code << 8) + subcode) {\n+                case (1 << 8) + 1: return CONNECTION_NOT_SYNCHRONIZED;\n+                case (1 << 8) + 2: return BAD_MESSAGE_LENGTH;\n+                case (1 << 8) + 3: return BAD_MESSAGE_TYPE;\n+\n+                case (2 << 8) + 1: return UNSUPPORTED_VERSION_NUMBER;\n+                case (2 << 8) + 2: return BAD_PEER_AS;\n+                case (2 << 8) + 3: return BAD_BGP_IDENTIFIER;\n+                case (2 << 8) + 4: return UNSUPPORTED_OPTIONAL_PARAMETER;\n+                case (2 << 8) + 5: return AUTHENTICATION_FAILURE;\n+                case (2 << 8) + 6: return UNACCEPTABLE_HOLD_TIME;\n+\n+                case (3 << 8) + 1: return MALFORMED_ATTRIBUTE_LIST;\n+                case (3 << 8) + 2: return UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 3: return MISSING_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 4: return ATTRIBUTE_FLAGS_ERROR;\n+                case (3 << 8) + 5: return ATTRIBUTE_LENGTH_ERROR;\n+                case (3 << 8) + 6: return INVALID_ORIGIN_ATTRIBUTE;\n+                case (3 << 8) + 7: return ROUTING_LOOP;\n+                case (3 << 8) + 8: return INVALID_NEXT_HOP_ATTRIBUTE;\n+                case (3 << 8) + 9: return OPTIONAL_ATTRIBUTE_ERROR;\n+                case (3 << 8) + 10: return INVALID_NETWORK_FIELD;\n+                case (3 << 8) + 11: return MALFORMED_AS_PATH;\n+\n+                case (4 << 8) + 1: return HOLD_TIMER_EXPIRED;\n+\n+                case (5 << 8) + 1: return FSM_ERROR;\n+\n+                case (6 << 8) + 1: return MAXIMUM_NUMBER_OF_PREFIXES_REACHED;\n+                case (6 << 8) + 2: return ADMINISTRATIVE_SHUTDOWN;\n+                case (6 << 8) + 3: return PEER_DECONFIGURED;\n+                case (6 << 8) + 4: return ADMINISTRATIVE_RESET;\n+                case (6 << 8) + 5: return CONNECTION_RESET;\n+                case (6 << 8) + 6: return OTHER_CONFIGURATION_CHANGE;\n+                case (6 << 8) + 7: return CONNECTION_COLLISION_RESOLUTION;\n+                case (6 << 8) + 8: return OUT_OF_RESOURCES;\n+\n+                default:\n+                    LOG.warn(\"Unknown Notification Packet Code: {}/{}\", code, subcode);\n+                    return UNKNOWN;\n+            }\n+        }\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = new BmpKafkaProducer(adapterConfig);\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry,\n+                                 final BmpMessageHandler handler) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = Objects.requireNonNull(handler);\n+    }\n+\n+    private void handleHeartbeatMessage(final Transport.Message message,\n+                                        final Transport.Heartbeat heartbeat,\n+                                        final Context context) {\n+        final Collector collector = new Collector();\n+\n+        switch (heartbeat.getMode()) {\n+            case STARTED:\n+                collector.action = Collector.Action.STARTED;\n+                break;\n+            case STOPPED:\n+                collector.action = Collector.Action.STOPPED;\n+                break;\n+            case PERIODIC:\n+                collector.action = Collector.Action.HEARTBEAT;\n+                break;\n+            case CHANGE:\n+                collector.action = Collector.Action.CHANGE;\n+                break;\n+        }\n+\n+        collector.sequence = sequence.getAndIncrement();\n+        collector.adminId = context.adminId;\n+        collector.hash = context.collectorHashId;\n+        collector.routers = Lists.transform(heartbeat.getRoutersList(), BmpAdapterTools::address);\n+        collector.timestamp = context.timestamp;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.COLLECTOR, ImmutableList.of(collector)));\n+    }\n+\n+    private void handleInitiationMessage(final Transport.Message message,\n+                                         final Transport.InitiationPacket initiation,\n+                                         final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.INIT;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = initiation.getSysName();\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = initiation.getSysDesc();\n+        router.termCode = null;\n+        router.termReason = null;\n+        router.initData = initiation.getMessage();\n+        router.termData = null;\n+        router.timestamp = context.timestamp;\n+        router.bgpId = initiation.hasBgpId() ? BmpAdapterTools.address(initiation.getBgpId()) : null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handleTerminationMessage(final Transport.Message message,\n+                                          final Transport.TerminationPacket termination,\n+                                          final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.TERM;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = null;\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = null;\n+        router.termCode = termination.getReason();\n+\n+        switch (router.termCode) {\n+            case 0:\n+                router.termReason = \"Session administratively closed.  The session might be re-initiated\";\n+                break;\n+            case 1:\n+                router.termReason = \"Unspecified reason\";\n+                break;\n+            case 2:\n+                router.termReason = \"Out of resources.  The router has exhausted resources available for the BMP session\";\n+                break;\n+            case 3:\n+                router.termReason = \"Redundant connection.  The router has determined that this connection is redundant with another one\";\n+                break;\n+            case 4:\n+                router.termReason = \"Session permanently administratively closed, will not be re-initiated\";\n+                break;\n+            default:\n+                router.termReason = \"Unknown reason\";\n+        }\n+\n+        router.initData = null;\n+        router.termData = termination.getMessage();\n+        router.timestamp = context.timestamp;\n+        router.bgpId = null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handlePeerUpNotification(final Transport.Message message,\n+                                          final Transport.PeerUpPacket peerUp,\n+                                          final Context context) {\n+        final Transport.Peer bgpPeer = peerUp.getPeer();\n+\n+        final Peer peer = new Peer();\n+        peer.action = Peer.Action.UP;\n+        peer.sequence = sequence.getAndIncrement();\n+        peer.name = InetAddressUtils.str(address(bgpPeer.getAddress())); // TODO: resolve Ip via DNS?\n+        peer.hash = Record.hash(bgpPeer.getAddress(),\n+                                bgpPeer.getDistinguisher(),\n+                                context.routerHashId);\n+        peer.routerHash = context.routerHashId;\n+        peer.remoteBgpId = address(peerUp.getRecvMsg().getId());\n+        peer.routerIp = context.sourceAddress;\n+        peer.timestamp = timestamp(bgpPeer.getTimestamp());\n+        peer.remoteAsn = uint32(peerUp.getRecvMsg().getAs());\n+        peer.remoteIp = address(bgpPeer.getAddress());\n+        peer.peerRd = asAttr((int) bgpPeer.getDistinguisher());\n+        peer.remotePort = peerUp.getRemotePort();\n+        peer.localAsn = uint32(peerUp.getSendMsg().getAs());\n+        peer.localIp = address(peerUp.getLocalAddress());\n+        peer.localPort = peerUp.getLocalPort();\n+        peer.localBgpId = address(peerUp.getSendMsg().getId());\n+        peer.infoData = peerUp.getMessage();\n+        peer.advertisedCapabilities = \"\"; // TODO: Not parsed right now\n+        peer.receivedCapabilities = \"\"; // TODO: Not parsed right now\n+        peer.remoteHolddown = uint32(peerUp.getRecvMsg().getHoldTime());\n+        peer.advertisedHolddown = uint32(peerUp.getSendMsg().getHoldTime());\n+        peer.bmpReason = null;\n+        peer.bgpErrorCode = null;\n+        peer.bgpErrorSubcode = null;\n+        peer.errorText = null;\n+        peer.l3vpn = bgpPeer.getType() == Transport.Peer.Type.RD_INSTANCE;\n+        peer.prePolicy = bgpPeer.getFlags().getPolicy() == Transport.Peer.Flags.Policy.PRE_POLICY;\n+        peer.ipv4 = isV4(bgpPeer.getAddress());\n+        peer.locRib = false; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+        peer.locRibFiltered = false; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+        peer.tableName = \"\"; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.PEER, ImmutableList.of(peer)));\n+    }\n+\n+    private void handlePeerDownNotification(final Transport.Message message,\n+                                            final Transport.PeerDownPacket peerDown,\n+                                            final Context context) {\n+        final Transport.Peer bgpPeer = peerDown.getPeer();\n+\n+        final Peer peer = new Peer();\n+        peer.action = Peer.Action.DOWN;\n+        peer.sequence = sequence.getAndIncrement();\n+        peer.name = InetAddressUtils.str(address(bgpPeer.getAddress())); // TODO: resolve Ip via DNS?\n+        peer.hash = Record.hash(bgpPeer.getAddress(),\n+                bgpPeer.getDistinguisher(),\n+                context.routerHashId);\n+        peer.routerHash = context.routerHashId;\n+        peer.remoteBgpId = address(bgpPeer.getId());\n+        peer.routerIp = context.sourceAddress;\n+        peer.timestamp = timestamp(bgpPeer.getTimestamp());\n+        peer.remoteAsn = uint32(bgpPeer.getAs());\n+        peer.remoteIp = address(bgpPeer.getAddress());\n+        peer.peerRd = asAttr((int) bgpPeer.getDistinguisher());\n+        peer.remotePort = null;\n+        peer.localAsn = null;\n+        peer.localIp = null;\n+        peer.localPort = null;\n+        peer.localBgpId = null;\n+        peer.infoData = null;\n+        peer.advertisedCapabilities = null;\n+        peer.receivedCapabilities = null;\n+        peer.remoteHolddown = null;\n+        peer.advertisedHolddown = null;\n+        peer.bmpReason = peerDown.getReasonCase().getNumber() - 1;\n+\n+        switch (peerDown.getReasonCase().getNumber()) {\n+            case 2:\n+                peer.bgpErrorCode = peerDown.getLocalBgpNotification().getCode();\n+                peer.bgpErrorSubcode = peerDown.getLocalBgpNotification().getSubcode();\n+                break;\n+            case 4:\n+                peer.bgpErrorCode = peerDown.getRemoteBgpNotification().getCode();\n+                peer.bgpErrorSubcode = peerDown.getRemoteBgpNotification().getSubcode();\n+                break;\n+            default:\n+                peer.bgpErrorCode = null;\n+                peer.bgpErrorSubcode = null;\n+        }\n+\n+        if (peer.bgpErrorCode != null && peer.bgpErrorSubcode != null) {\n+            peer.errorText = Error.from(peer.bgpErrorCode, peer.bgpErrorSubcode).getErrorText();\n+        }\n+\n+        peer.l3vpn = bgpPeer.getType() == Transport.Peer.Type.RD_INSTANCE;\n+        peer.prePolicy = bgpPeer.getFlags().getPolicy() == Transport.Peer.Flags.Policy.PRE_POLICY;\n+        peer.ipv4 = isV4(bgpPeer.getAddress());\n+        peer.locRib = false; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+        peer.locRibFiltered = false; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+        peer.tableName = \"\"; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.PEER, ImmutableList.of(peer)));\n+    }\n+\n+    private void handleStatisticReport(final Transport.Message message,\n+                                       final Transport.StatisticsReportPacket statisticsReport,\n+                                       final Context context) {\n+        final Transport.Peer peer = statisticsReport.getPeer();\n+\n+        final Stat stat = new Stat();\n+        stat.action = Stat.Action.ADD;\n+        stat.sequence = sequence.getAndIncrement();\n+        stat.routerHash = Record.hash(context.sourceAddress.getHostAddress(), Integer.toString(context.sourcePort), context.collectorHashId);\n+        stat.routerIp = context.sourceAddress;\n+        stat.peerHash = Record.hash(peer.getAddress(), peer.getDistinguisher(), stat.routerHash);\n+        stat.peerIp = address(peer.getAddress());\n+        stat.peerAsn = uint32(peer.getAs());\n+        stat.timestamp = timestamp(peer.getTimestamp());\n+        stat.prefixesRejected = statisticsReport.getRejected().getCount();\n+        stat.knownDupPrefixes = statisticsReport.getDuplicatePrefix().getCount();\n+        stat.knownDupWithdraws = statisticsReport.getDuplicateWithdraw().getCount();\n+        stat.invalidClusterList = statisticsReport.getInvalidUpdateDueToClusterListLoop().getCount();\n+        stat.invalidAsPath = statisticsReport.getInvalidUpdateDueToAsPathLoop().getCount();\n+        stat.invalidOriginatorId = statisticsReport.getInvalidUpdateDueToOriginatorId().getCount();\n+        stat.invalidAsConfed = statisticsReport.getInvalidUpdateDueToAsConfedLoop().getCount();\n+        stat.prefixesPrePolicy = statisticsReport.getAdjRibIn().getValue();\n+        stat.prefixesPostPolicy = statisticsReport.getLocRib().getValue();\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.BMP_STAT, ImmutableList.of(stat)));\n+    }\n+\n+    private BaseAttribute toBaseAttributeRecord(final Transport.RouteMonitoringPacket routeMonitoring,\n+                                                final Context context) {\n+        final Transport.Peer peer = routeMonitoring.getPeer();\n+\n+        final BaseAttribute baseAttr = new BaseAttribute();\n+        baseAttr.action = BaseAttribute.Action.ADD; // Action is always ADD - attributes are never withdrawn\n+        baseAttr.sequence = this.sequence.getAndIncrement();\n+        baseAttr.routerHash = context.getRouterHash();\n+        baseAttr.routerIp = context.sourceAddress;\n+        baseAttr.peerHash = Record.hash(peer.getAddress(), peer.getDistinguisher(), baseAttr.routerHash);\n+        baseAttr.peerIp = address(peer.getAddress());\n+        baseAttr.peerAsn = uint32(peer.getAs());\n+        baseAttr.timestamp = context.timestamp;\n+\n+        // Derive the origin of the prefix from the path attributes - default to an empty string if not set\n+        baseAttr.origin = getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.ORIGIN)\n+                .map(attr -> attr.getOrigin().name().toLowerCase()).orElse(\"\");\n+\n+        // Build the AS path from the path attributes - default to an empty string if not set\n+        // See UpdateMsg::parseAttr_AsPath in the OpenBMP collector for the corresponding logic\n+        baseAttr.asPathCount = 0;\n+\n+        baseAttr.asPath = getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.AS_PATH)\n+                .map(asPathAttr -> {\n+                    final StringBuilder asPath = new StringBuilder();\n+\n+                    asPathAttr.getAsPath().getSegmentsList().forEach(segment -> {\n+                        if (Transport.RouteMonitoringPacket.PathAttribute.AsPath.Segment.Type.AS_SET.equals(segment.getType())) {\n+                            asPath.append(\"{\");\n+                        }\n+                        segment.getPathsList().forEach(segmentPath -> {\n+                            asPath.append(segmentPath);\n+                            asPath.append(\" \");\n+                            baseAttr.asPathCount++;\n+                            baseAttr.originAs = uint32(segmentPath);\n+                        });\n+                        if (Transport.RouteMonitoringPacket.PathAttribute.AsPath.Segment.Type.AS_SET.equals(segment.getType())) {\n+                            asPath.append(\"}\");\n+                        }\n+                    });\n+\n+                    return asPath.toString();\n+                })\n+                .orElse(\"\");\n+\n+        // Derive the next hop from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.NEXT_HOP)\n+                .map(attr -> attr.getNextHop().getAddress())\n+                .ifPresent(nextHop -> {\n+                    baseAttr.nextHop = address(nextHop);\n+                    baseAttr.nextHopIpv4 = isV4(nextHop);\n+                });\n+\n+        // Derive the Multi Exit Discriminator (MED) from the path attributes (lower values are preferred)\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.MULTI_EXIT_DISC)\n+                .map(attr -> attr.getMultiExitDisc().getDiscriminator())\n+                .ifPresent(med -> {\n+                    baseAttr.med = uint32(med);\n+                });\n+\n+        // Derive the local preference from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.LOCAL_PREF)\n+                .map(attr -> attr.getLocalPref().getPreference())\n+                .ifPresent(localPref -> {\n+                    baseAttr.localPref = uint32(localPref);\n+                });\n+\n+        // Derive the aggregator from the path attributes\n+        // See UpdateMsg::parseAttr_Aggegator in the OpenBMP collector for the corresponding logic\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.AGGREGATOR)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getAggregator)\n+                .ifPresent(agg -> {\n+                    baseAttr.aggregator = String.format(\"%d %s\", agg.getAs(), BmpAdapterTools.addressAsStr(agg.getAddress()));\n+                });\n+\n+        // Derive the community list from the path attributes\n+        baseAttr.communityList = getPathAttributesOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.COMMUNITY)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getCommunity)\n+                .map(BmpAdapterTools::asAttr)\n+                .collect(Collectors.joining(\" \"));\n+\n+        // Derive the extended community list from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.EXTENDED_COMMUNITIES)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getExtendedCommunities)\n+                .ifPresent(extendedCommunities -> {\n+                    baseAttr.extCommunityList = extendedCommunities.getExtendedCommunitiesList().stream()\n+                            .map(extendedCommunity -> String.format(\"%d:%s\",\n+                                    uint32(extendedCommunity.getType()),\n+                                    extendedCommunity.getValue()))\n+                            .collect(Collectors.joining(\" \"));\n+                });\n+\n+        // Derive the cluster list from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.CLUSTER_LIST)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getClusterList)\n+                .ifPresent(clusterList -> {\n+                    baseAttr.clusterList = clusterList.getClusterIdList().stream()\n+                            .map(BmpAdapterTools::addressAsStr)\n+                            .collect(Collectors.joining(\" \"));\n+                });\n+\n+        // Derive the large community list from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.LARGE_COMMUNITIES)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getLargeCommunities)\n+                .ifPresent(largeCommunities -> {\n+                    baseAttr.largeCommunityList = largeCommunities.getLargeCommunitiesList().stream()\n+                            .map(largeCommunity -> String.format(\"%d:%d:%d\",\n+                                    uint32(largeCommunity.getGlobalAdministrator()),\n+                                    uint32(largeCommunity.getLocalDataPart1()),\n+                                    uint32(largeCommunity.getLocalDataPart2())))\n+                            .collect(Collectors.joining(\" \"));\n+                });\n+\n+        // Derive the originator id from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.ORIGINATOR_ID)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getOriginatorId)\n+                .ifPresent(originatorId -> {\n+                    baseAttr.originatorId = Long.toString(uint32(originatorId));\n+                });\n+\n+        // Set the atomic flag is the atomic aggregate path attribute is present\n+        baseAttr.atomicAgg = getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.ATOMIC_AGGREGATE)\n+                .isPresent();\n+\n+        // Compute hash - fields [ as path, next hop, aggregator, origin, med, local pref, community list, ext community list, peer hash ]\n+        baseAttr.hash = Record.hash(baseAttr.asPath,\n+                                    Record.nullSafeStr(baseAttr.nextHop),\n+                                    baseAttr.aggregator,\n+                                    baseAttr.origin,\n+                                    Record.nullSafeStr(baseAttr.med),\n+                                    Record.nullSafeStr(baseAttr.localPref),\n+                                    baseAttr.communityList,\n+                                    baseAttr.extCommunityList,\n+                                    baseAttr.peerHash);\n+\n+        return baseAttr;\n+    }\n+\n+    private UnicastPrefix toUnicastPrefixRecord(final Transport.RouteMonitoringPacket routeMonitoring,\n+                                                final Transport.RouteMonitoringPacket.Route route,\n+                                                final BaseAttribute baseAttr,\n+                                                final Context context) {\n+        final Transport.Peer peer = routeMonitoring.getPeer();\n+\n+        final UnicastPrefix unicastPrefix = new UnicastPrefix();\n+        unicastPrefix.sequence = this.sequence.incrementAndGet();\n+        unicastPrefix.routerHash = context.getRouterHash();\n+        unicastPrefix.routerIp = context.sourceAddress;\n+        unicastPrefix.peerHash = Record.hash(peer.getAddress(), peer.getDistinguisher(), unicastPrefix.routerHash);\n+        unicastPrefix.peerIp = address(peer.getAddress());\n+        unicastPrefix.peerAsn = uint32(peer.getAs());\n+        unicastPrefix.timestamp = context.timestamp;\n+        unicastPrefix.prefix = address(route.getPrefix());\n+        unicastPrefix.length = route.getLength();\n+        unicastPrefix.ipv4 = isV4(route.getPrefix());\n+        // TODO: Populate path id and labels attributes - see NMS-12560\n+        unicastPrefix.pathId = 0;\n+        unicastPrefix.labels = null;\n+        unicastPrefix.prePolicy = Transport.Peer.Flags.Policy.PRE_POLICY.equals(peer.getFlags().getPolicy());\n+\n+        // Augment with base attributes if present\n+        if (baseAttr != null) {\n+            unicastPrefix.baseAttrHash = baseAttr.hash;\n+            unicastPrefix.origin = baseAttr.origin;\n+            unicastPrefix.asPath = baseAttr.asPath;\n+            unicastPrefix.asPathCount = baseAttr.asPathCount;\n+            unicastPrefix.originAs = baseAttr.originAs;\n+            unicastPrefix.nextHop = baseAttr.nextHop;\n+            unicastPrefix.med = baseAttr.med;\n+            unicastPrefix.localPref = baseAttr.localPref;\n+            unicastPrefix.aggregator = baseAttr.aggregator;\n+            unicastPrefix.communityList = baseAttr.communityList;\n+            unicastPrefix.extCommunityList = baseAttr.extCommunityList;\n+            unicastPrefix.clusterList = baseAttr.clusterList;\n+            unicastPrefix.atomicAgg = baseAttr.atomicAgg;\n+            unicastPrefix.nextHopIpv4 = baseAttr.nextHopIpv4;\n+            unicastPrefix.originatorId = baseAttr.originatorId;\n+            unicastPrefix.largeCommunityList = baseAttr.largeCommunityList;\n+        }\n+        // FIXME: isAdjIn?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzNzAyOQ=="}, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 593}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5Njc4MTA2OnYy", "diffSide": "RIGHT", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpIntegrationAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwOTozNDo0MVrOFw-Sdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwOTozNDo0MVrOFw-Sdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg5NjUwMg==", "bodyText": "Deferred to https://issues.opennms.org/browse/NMS-12571", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r386896502", "createdAt": "2020-03-03T09:34:41Z", "author": {"login": "fooker"}, "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpIntegrationAdapter.java", "diffHunk": "@@ -0,0 +1,724 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.address;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.asAttr;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributeOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributesOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.isV4;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.timestamp;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.uint32;\n+\n+import java.net.InetAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+import org.opennms.core.utils.InetAddressUtils;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLog;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLogEntry;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Record;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Type;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.BaseAttribute;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Collector;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Peer;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Router;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Stat;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.UnicastPrefix;\n+import org.opennms.netmgt.telemetry.protocols.bmp.transport.Transport;\n+import org.opennms.netmgt.telemetry.protocols.collection.AbstractAdapter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+public class BmpIntegrationAdapter extends AbstractAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpIntegrationAdapter.class);\n+\n+    private final AtomicLong sequence = new AtomicLong();\n+\n+    private final BmpMessageHandler handler;\n+\n+    public enum Error {\n+        // Message Header Error\n+        CONNECTION_NOT_SYNCHRONIZED(\"Connection not synchronized\"),\n+        BAD_MESSAGE_LENGTH(\"Bad message header length\"),\n+        BAD_MESSAGE_TYPE(\"Bad message header type\"),\n+\n+        // Open Message Error\n+        UNSUPPORTED_VERSION_NUMBER(\"Unsupported BGP version\"),\n+        BAD_PEER_AS(\"Incorrect peer AS\"),\n+        BAD_BGP_IDENTIFIER(\"Bad BGP ID\"),\n+        UNSUPPORTED_OPTIONAL_PARAMETER(\"Unsupported optinal parameter\"),\n+        AUTHENTICATION_FAILURE(\"Authentication failure\"),\n+        UNACCEPTABLE_HOLD_TIME(\"Unacceptable hold time\"),\n+\n+        // Update Message Error\n+        MALFORMED_ATTRIBUTE_LIST(\"Malformed attribute list\"),\n+        UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE(\"Unrecognized well known attribute\"),\n+        MISSING_WELL_KNOWN_ATTRIBUTE(\"Missing well known attribute\"),\n+        ATTRIBUTE_FLAGS_ERROR(\"Update attribute flags error\"),\n+        ATTRIBUTE_LENGTH_ERROR(\"Update attribute length error\"),\n+        INVALID_ORIGIN_ATTRIBUTE(\"Invalid origin\"),\n+        ROUTING_LOOP(\"Routing loop\"),\n+        INVALID_NEXT_HOP_ATTRIBUTE(\"Invalid next hop address/attribute\"),\n+        OPTIONAL_ATTRIBUTE_ERROR(\"Update optional attribute error\"),\n+        INVALID_NETWORK_FIELD(\"Invalid network field\"),\n+        MALFORMED_AS_PATH(\"Malformed AS_PATH\"),\n+\n+        // Hold Timer Expired\n+        HOLD_TIMER_EXPIRED(\"Hold timer expired\"),\n+\n+        // FSM Error\n+        FSM_ERROR(\"FSM error\"),\n+\n+        // Cease\n+        MAXIMUM_NUMBER_OF_PREFIXES_REACHED(\"Maximum number of prefixes reached\"),\n+        ADMINISTRATIVE_SHUTDOWN(\"Administrative shutdown\"),\n+        PEER_DECONFIGURED(\"Peer de-configured\"),\n+        ADMINISTRATIVE_RESET(\"Administrative reset\"),\n+        CONNECTION_RESET(\"Connection rejected\"),\n+        OTHER_CONFIGURATION_CHANGE(\"Other configuration change\"),\n+        CONNECTION_COLLISION_RESOLUTION(\"Connection collision resolution\"),\n+        OUT_OF_RESOURCES(\"Maximum number of prefixes reached\"),\n+\n+        UNKNOWN(\"Unknown notification type\"),\n+        ;\n+\n+        private String errorText;\n+\n+        Error(final String errorText) {\n+            this.errorText = errorText;\n+        }\n+\n+        public String getErrorText() {\n+            return errorText;\n+        }\n+\n+        public static Error from(final int code, final int subcode) {\n+            switch ((code << 8) + subcode) {\n+                case (1 << 8) + 1: return CONNECTION_NOT_SYNCHRONIZED;\n+                case (1 << 8) + 2: return BAD_MESSAGE_LENGTH;\n+                case (1 << 8) + 3: return BAD_MESSAGE_TYPE;\n+\n+                case (2 << 8) + 1: return UNSUPPORTED_VERSION_NUMBER;\n+                case (2 << 8) + 2: return BAD_PEER_AS;\n+                case (2 << 8) + 3: return BAD_BGP_IDENTIFIER;\n+                case (2 << 8) + 4: return UNSUPPORTED_OPTIONAL_PARAMETER;\n+                case (2 << 8) + 5: return AUTHENTICATION_FAILURE;\n+                case (2 << 8) + 6: return UNACCEPTABLE_HOLD_TIME;\n+\n+                case (3 << 8) + 1: return MALFORMED_ATTRIBUTE_LIST;\n+                case (3 << 8) + 2: return UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 3: return MISSING_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 4: return ATTRIBUTE_FLAGS_ERROR;\n+                case (3 << 8) + 5: return ATTRIBUTE_LENGTH_ERROR;\n+                case (3 << 8) + 6: return INVALID_ORIGIN_ATTRIBUTE;\n+                case (3 << 8) + 7: return ROUTING_LOOP;\n+                case (3 << 8) + 8: return INVALID_NEXT_HOP_ATTRIBUTE;\n+                case (3 << 8) + 9: return OPTIONAL_ATTRIBUTE_ERROR;\n+                case (3 << 8) + 10: return INVALID_NETWORK_FIELD;\n+                case (3 << 8) + 11: return MALFORMED_AS_PATH;\n+\n+                case (4 << 8) + 1: return HOLD_TIMER_EXPIRED;\n+\n+                case (5 << 8) + 1: return FSM_ERROR;\n+\n+                case (6 << 8) + 1: return MAXIMUM_NUMBER_OF_PREFIXES_REACHED;\n+                case (6 << 8) + 2: return ADMINISTRATIVE_SHUTDOWN;\n+                case (6 << 8) + 3: return PEER_DECONFIGURED;\n+                case (6 << 8) + 4: return ADMINISTRATIVE_RESET;\n+                case (6 << 8) + 5: return CONNECTION_RESET;\n+                case (6 << 8) + 6: return OTHER_CONFIGURATION_CHANGE;\n+                case (6 << 8) + 7: return CONNECTION_COLLISION_RESOLUTION;\n+                case (6 << 8) + 8: return OUT_OF_RESOURCES;\n+\n+                default:\n+                    LOG.warn(\"Unknown Notification Packet Code: {}/{}\", code, subcode);\n+                    return UNKNOWN;\n+            }\n+        }\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = new BmpKafkaProducer(adapterConfig);\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry,\n+                                 final BmpMessageHandler handler) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = Objects.requireNonNull(handler);\n+    }\n+\n+    private void handleHeartbeatMessage(final Transport.Message message,\n+                                        final Transport.Heartbeat heartbeat,\n+                                        final Context context) {\n+        final Collector collector = new Collector();\n+\n+        switch (heartbeat.getMode()) {\n+            case STARTED:\n+                collector.action = Collector.Action.STARTED;\n+                break;\n+            case STOPPED:\n+                collector.action = Collector.Action.STOPPED;\n+                break;\n+            case PERIODIC:\n+                collector.action = Collector.Action.HEARTBEAT;\n+                break;\n+            case CHANGE:\n+                collector.action = Collector.Action.CHANGE;\n+                break;\n+        }\n+\n+        collector.sequence = sequence.getAndIncrement();\n+        collector.adminId = context.adminId;\n+        collector.hash = context.collectorHashId;\n+        collector.routers = Lists.transform(heartbeat.getRoutersList(), BmpAdapterTools::address);\n+        collector.timestamp = context.timestamp;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.COLLECTOR, ImmutableList.of(collector)));\n+    }\n+\n+    private void handleInitiationMessage(final Transport.Message message,\n+                                         final Transport.InitiationPacket initiation,\n+                                         final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.INIT;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = initiation.getSysName();\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = initiation.getSysDesc();\n+        router.termCode = null;\n+        router.termReason = null;\n+        router.initData = initiation.getMessage();\n+        router.termData = null;\n+        router.timestamp = context.timestamp;\n+        router.bgpId = initiation.hasBgpId() ? BmpAdapterTools.address(initiation.getBgpId()) : null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handleTerminationMessage(final Transport.Message message,\n+                                          final Transport.TerminationPacket termination,\n+                                          final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.TERM;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = null;\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = null;\n+        router.termCode = termination.getReason();\n+\n+        switch (router.termCode) {\n+            case 0:\n+                router.termReason = \"Session administratively closed.  The session might be re-initiated\";\n+                break;\n+            case 1:\n+                router.termReason = \"Unspecified reason\";\n+                break;\n+            case 2:\n+                router.termReason = \"Out of resources.  The router has exhausted resources available for the BMP session\";\n+                break;\n+            case 3:\n+                router.termReason = \"Redundant connection.  The router has determined that this connection is redundant with another one\";\n+                break;\n+            case 4:\n+                router.termReason = \"Session permanently administratively closed, will not be re-initiated\";\n+                break;\n+            default:\n+                router.termReason = \"Unknown reason\";\n+        }\n+\n+        router.initData = null;\n+        router.termData = termination.getMessage();\n+        router.timestamp = context.timestamp;\n+        router.bgpId = null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handlePeerUpNotification(final Transport.Message message,\n+                                          final Transport.PeerUpPacket peerUp,\n+                                          final Context context) {\n+        final Transport.Peer bgpPeer = peerUp.getPeer();\n+\n+        final Peer peer = new Peer();\n+        peer.action = Peer.Action.UP;\n+        peer.sequence = sequence.getAndIncrement();\n+        peer.name = InetAddressUtils.str(address(bgpPeer.getAddress())); // TODO: resolve Ip via DNS?\n+        peer.hash = Record.hash(bgpPeer.getAddress(),\n+                                bgpPeer.getDistinguisher(),\n+                                context.routerHashId);\n+        peer.routerHash = context.routerHashId;\n+        peer.remoteBgpId = address(peerUp.getRecvMsg().getId());\n+        peer.routerIp = context.sourceAddress;\n+        peer.timestamp = timestamp(bgpPeer.getTimestamp());\n+        peer.remoteAsn = uint32(peerUp.getRecvMsg().getAs());\n+        peer.remoteIp = address(bgpPeer.getAddress());\n+        peer.peerRd = asAttr((int) bgpPeer.getDistinguisher());\n+        peer.remotePort = peerUp.getRemotePort();\n+        peer.localAsn = uint32(peerUp.getSendMsg().getAs());\n+        peer.localIp = address(peerUp.getLocalAddress());\n+        peer.localPort = peerUp.getLocalPort();\n+        peer.localBgpId = address(peerUp.getSendMsg().getId());\n+        peer.infoData = peerUp.getMessage();\n+        peer.advertisedCapabilities = \"\"; // TODO: Not parsed right now", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f626f518049b1493071e145636f0647909a4dec"}, "originalPosition": 310}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 784, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}