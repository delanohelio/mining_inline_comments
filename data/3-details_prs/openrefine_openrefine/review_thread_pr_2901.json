{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1MjEwNTQz", "number": 2901, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTo0MTozM1rOENNiag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjo0OToxN1rOENQ0BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjg4NzQ2OnYy", "diffSide": "RIGHT", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTo0MTozM1rOGvw9_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTo0MTozM1rOGvw9_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczODU1Ng==", "bodyText": "Isn't it possible to simplify this code by pulling the if (update.isNew()) inside, just when the QAWarning is generated? I think this only affects the type of warning you emit, so that should get rid of a lot of duplicated code.", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452738556", "createdAt": "2020-07-10T09:41:33Z", "author": {"login": "wetneb"}, "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizer.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.openrefine.wikidata.qa.scrutinizers;\n+\n+import org.openrefine.wikidata.qa.QAWarning;\n+import org.openrefine.wikidata.updates.ItemUpdate;\n+import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Snak;\n+import org.wikidata.wdtk.datamodel.interfaces.SnakGroup;\n+import org.wikidata.wdtk.datamodel.interfaces.Statement;\n+import org.wikidata.wdtk.datamodel.interfaces.Value;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ItemRequiresScrutinizer extends EditScrutinizer {\n+\n+    public static final String newItem_type = \"item-requires-certain-other-statement\";\n+    public static final String existingItem_type = \"item-should-have-certain-other-statement\";\n+    public static String ITEM_REQUIRES_CONSTRAINT_QID = \"Q21503247\";\n+    public static String ITEM_REQUIRES_PROPERTY_PID = \"P2306\";\n+    public static String ITEM_OF_PROPERTY_CONSTRAINT_PID = \"P2305\";\n+\n+    class ItemRequiresConstraint {\n+        final PropertyIdValue itemRequiresPid;\n+        final List<Value> itemList;\n+\n+        ItemRequiresConstraint(Statement statement) {\n+            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n+            PropertyIdValue pid = null;\n+            this.itemList = new ArrayList<>();\n+            for(SnakGroup group : specs) {\n+                for (Snak snak : group.getSnaks()) {\n+                    if (group.getProperty().getId().equals(ITEM_REQUIRES_PROPERTY_PID)){\n+                        pid = (PropertyIdValue) snak.getValue();\n+                    }\n+                    if (group.getProperty().getId().equals(ITEM_OF_PROPERTY_CONSTRAINT_PID)){\n+                        this.itemList.add(snak.getValue());\n+                    }\n+                }\n+            }\n+            this.itemRequiresPid = pid;\n+        }\n+    }\n+\n+    @Override\n+    public void scrutinize(ItemUpdate update) {\n+        Map<PropertyIdValue, Set<Value>> propertyIdValueValueMap = new HashMap<>();\n+        for (Statement statement : update.getAddedStatements()) {\n+            PropertyIdValue pid = statement.getClaim().getMainSnak().getPropertyId();\n+            Value value = statement.getClaim().getMainSnak().getValue();\n+            Set<Value> values;\n+            if (value != null) {\n+                if (propertyIdValueValueMap.containsKey(pid)) {\n+                    values = propertyIdValueValueMap.get(pid);\n+                } else {\n+                    values = new HashSet<>();\n+                }\n+                values.add(value);\n+                propertyIdValueValueMap.put(pid, values);\n+            }\n+        }\n+\n+        if (update.isNew()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e10d9ad9fc6079528ba59ea84addf8df59621b7a"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjg4NzcxOnYy", "diffSide": "RIGHT", "path": "extensions/wikidata/module/langs/translation-en.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTo0MTozN1rOGvw-IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTo0MTozN1rOGvw-IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczODU5Mg==", "bodyText": "The other issue bodies do not tend to give instructions to the user, but rather to indicate in plain terms what the issue is (leaving it to them to decide what to do about it). I think it is quite important not to be too explicit about what the fix should be in the second warning below, since it can be ignored in certain cases.", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452738592", "createdAt": "2020-07-10T09:41:37Z", "author": {"login": "wetneb"}, "path": "extensions/wikidata/module/langs/translation-en.json", "diffHunk": "@@ -148,6 +148,10 @@\n     \"warnings-messages/multi-valued-property-is-required-for-new-item/body\": \"This property is expected to have more than one statement on each item but it has single statement, for instance on {example_entity}.\",\n     \"warnings-messages/multi-valued-property-is-required-for-existing-item/title\": \"{property_entity} should have more than one statement on existing items.\",\n     \"warnings-messages/multi-valued-property-is-required-for-existing-item/body\": \"This property is expected to have more than one statement on each item but it has single statement, for instance on {example_entity}. If the item already has statements with this property in Wikidata, then this warning can be ignored.\",\n+    \"warnings-messages/item-requires-certain-other-statement/title\": \"{property_entity} requires statement with property {added_property_entity}.\",\n+    \"warnings-messages/item-requires-certain-other-statement/body\": \"Add the required statement with {property_entity} such as item with property {example_entity}.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e10d9ad9fc6079528ba59ea84addf8df59621b7a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjg5MDI0OnYy", "diffSide": "RIGHT", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTo0MjoyM1rOGvw_qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTo0MjoyM1rOGvw_qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczODk4NQ==", "bodyText": "Let's stick to camelCase and not mix it with underscores.", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452738985", "createdAt": "2020-07-10T09:42:23Z", "author": {"login": "wetneb"}, "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizer.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.openrefine.wikidata.qa.scrutinizers;\n+\n+import org.openrefine.wikidata.qa.QAWarning;\n+import org.openrefine.wikidata.updates.ItemUpdate;\n+import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Snak;\n+import org.wikidata.wdtk.datamodel.interfaces.SnakGroup;\n+import org.wikidata.wdtk.datamodel.interfaces.Statement;\n+import org.wikidata.wdtk.datamodel.interfaces.Value;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ItemRequiresScrutinizer extends EditScrutinizer {\n+\n+    public static final String newItem_type = \"item-requires-certain-other-statement\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e10d9ad9fc6079528ba59ea84addf8df59621b7a"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjg5MzYzOnYy", "diffSide": "RIGHT", "path": "extensions/wikidata/tests/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTo0MzoyNlrOGvxBvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTo0MzoyNlrOGvxBvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczOTUxOQ==", "bodyText": "It would be good to have a test for constraint violations on new items, too.", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452739519", "createdAt": "2020-07-10T09:43:26Z", "author": {"login": "wetneb"}, "path": "extensions/wikidata/tests/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizerTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.openrefine.wikidata.qa.scrutinizers;\n+\n+import org.openrefine.wikidata.qa.ConstraintFetcher;\n+import org.openrefine.wikidata.testing.TestingData;\n+import org.openrefine.wikidata.updates.ItemUpdate;\n+import org.openrefine.wikidata.updates.ItemUpdateBuilder;\n+import org.testng.annotations.Test;\n+import org.wikidata.wdtk.datamodel.helpers.Datamodel;\n+import org.wikidata.wdtk.datamodel.implementation.StatementImpl;\n+import org.wikidata.wdtk.datamodel.interfaces.ItemIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Snak;\n+import org.wikidata.wdtk.datamodel.interfaces.SnakGroup;\n+import org.wikidata.wdtk.datamodel.interfaces.Statement;\n+import org.wikidata.wdtk.datamodel.interfaces.Value;\n+import org.wikidata.wdtk.datamodel.interfaces.ValueSnak;\n+\n+import java.util.List;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.openrefine.wikidata.qa.scrutinizers.ItemRequiresScrutinizer.ITEM_OF_PROPERTY_CONSTRAINT_PID;\n+import static org.openrefine.wikidata.qa.scrutinizers.ItemRequiresScrutinizer.ITEM_REQUIRES_CONSTRAINT_QID;\n+import static org.openrefine.wikidata.qa.scrutinizers.ItemRequiresScrutinizer.ITEM_REQUIRES_PROPERTY_PID;\n+\n+public class ItemRequiresScrutinizerTest extends ScrutinizerTest {\n+\n+    public static PropertyIdValue propertyIdValue = Datamodel.makeWikidataPropertyIdValue(\"P157\");\n+    public static ItemIdValue itemValue = Datamodel.makeWikidataItemIdValue(\"Q3187975\");\n+    public static ItemIdValue entityIdValue = Datamodel.makeWikidataItemIdValue(ITEM_REQUIRES_CONSTRAINT_QID);\n+    public static PropertyIdValue propertyParameterPID = Datamodel.makeWikidataPropertyIdValue(ITEM_REQUIRES_PROPERTY_PID);\n+    public static PropertyIdValue propertyParameterValue = Datamodel.makeWikidataPropertyIdValue(\"P1196\");\n+    public static PropertyIdValue itemParameterPID = Datamodel.makeWikidataPropertyIdValue(ITEM_OF_PROPERTY_CONSTRAINT_PID);\n+    public static Value requiredValue = Datamodel.makeWikidataItemIdValue(\"Q149086\");\n+\n+    @Override\n+    public EditScrutinizer getScrutinizer() {\n+        return new ItemRequiresScrutinizer();\n+    }\n+\n+    @Test\n+    public void testTrigger() {\n+        ItemIdValue idA = TestingData.existingId;\n+        Snak mainSnak = Datamodel.makeValueSnak(propertyIdValue, itemValue);\n+        Statement statement = new StatementImpl(\"P157\", mainSnak, idA);\n+        ItemUpdate updateA = new ItemUpdateBuilder(idA).addStatement(statement).build();\n+\n+        Snak qualifierSnak1 = Datamodel.makeValueSnak(propertyParameterPID, propertyParameterValue);\n+        Snak qualifierSnak2 = Datamodel.makeValueSnak(itemParameterPID, requiredValue);\n+        List<SnakGroup> constraintQualifiers = makeSnakGroupList(qualifierSnak1, qualifierSnak2);\n+        List<Statement> constraintDefinitions = constraintParameterStatementList(entityIdValue, constraintQualifiers);\n+\n+        ConstraintFetcher fetcher = mock(ConstraintFetcher.class);\n+        when(fetcher.getConstraintsByType(propertyIdValue, ITEM_REQUIRES_CONSTRAINT_QID)).thenReturn(constraintDefinitions);\n+        setFetcher(fetcher);\n+\n+        scrutinize(updateA);\n+        assertWarningsRaised(ItemRequiresScrutinizer.existingItem_type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e10d9ad9fc6079528ba59ea84addf8df59621b7a"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzM0NDA2OnYy", "diffSide": "RIGHT", "path": "extensions/wikidata/module/langs/translation-en.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjoyMzoyOVrOGv1S1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjoyMzoyOVrOGv1S1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwOTQyOA==", "bodyText": "Thanks! Now in the second part of your message you write such as item with property {example_entity} but I do not think example_entity is a property here - it is an example item where the conflict was found. So perhaps we could rephrase that as such as on item {example_entity}?", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452809428", "createdAt": "2020-07-10T12:23:29Z", "author": {"login": "wetneb"}, "path": "extensions/wikidata/module/langs/translation-en.json", "diffHunk": "@@ -148,6 +148,10 @@\n     \"warnings-messages/multi-valued-property-is-required-for-new-item/body\": \"This property is expected to have more than one statement on each item but it has single statement, for instance on {example_entity}.\",\n     \"warnings-messages/multi-valued-property-is-required-for-existing-item/title\": \"{property_entity} should have more than one statement on existing items.\",\n     \"warnings-messages/multi-valued-property-is-required-for-existing-item/body\": \"This property is expected to have more than one statement on each item but it has single statement, for instance on {example_entity}. If the item already has statements with this property in Wikidata, then this warning can be ignored.\",\n+    \"warnings-messages/item-requires-certain-other-statement/title\": \"{property_entity} requires statement with property {added_property_entity}.\",\n+    \"warnings-messages/item-requires-certain-other-statement/body\": \"This property is expected to have another statement with property {added_property_entity} such as item with property {example_entity}.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae26863db88ad4c1ddbc91725d72477b8dd3271d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzM1MDUwOnYy", "diffSide": "RIGHT", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjoyNTozNFrOGv1Wwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjozMDowOVrOGv1evw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMDQzNA==", "bodyText": "The severity should also be adapted depending on whether the the update.isNew() or not", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452810434", "createdAt": "2020-07-10T12:25:34Z", "author": {"login": "wetneb"}, "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package org.openrefine.wikidata.qa.scrutinizers;\n+\n+import org.openrefine.wikidata.qa.QAWarning;\n+import org.openrefine.wikidata.updates.ItemUpdate;\n+import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Snak;\n+import org.wikidata.wdtk.datamodel.interfaces.SnakGroup;\n+import org.wikidata.wdtk.datamodel.interfaces.Statement;\n+import org.wikidata.wdtk.datamodel.interfaces.Value;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ItemRequiresScrutinizer extends EditScrutinizer {\n+\n+    public static final String newItemType = \"item-requires-certain-other-statement\";\n+    public static final String existingItemType = \"item-should-have-certain-other-statement\";\n+    public static String ITEM_REQUIRES_CONSTRAINT_QID = \"Q21503247\";\n+    public static String ITEM_REQUIRES_PROPERTY_PID = \"P2306\";\n+    public static String ITEM_OF_PROPERTY_CONSTRAINT_PID = \"P2305\";\n+\n+    class ItemRequiresConstraint {\n+        final PropertyIdValue itemRequiresPid;\n+        final List<Value> itemList;\n+\n+        ItemRequiresConstraint(Statement statement) {\n+            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n+            PropertyIdValue pid = null;\n+            this.itemList = new ArrayList<>();\n+            for(SnakGroup group : specs) {\n+                for (Snak snak : group.getSnaks()) {\n+                    if (group.getProperty().getId().equals(ITEM_REQUIRES_PROPERTY_PID)){\n+                        pid = (PropertyIdValue) snak.getValue();\n+                    }\n+                    if (group.getProperty().getId().equals(ITEM_OF_PROPERTY_CONSTRAINT_PID)){\n+                        this.itemList.add(snak.getValue());\n+                    }\n+                }\n+            }\n+            this.itemRequiresPid = pid;\n+        }\n+    }\n+\n+    @Override\n+    public void scrutinize(ItemUpdate update) {\n+        Map<PropertyIdValue, Set<Value>> propertyIdValueValueMap = new HashMap<>();\n+        for (Statement statement : update.getAddedStatements()) {\n+            PropertyIdValue pid = statement.getClaim().getMainSnak().getPropertyId();\n+            Value value = statement.getClaim().getMainSnak().getValue();\n+            Set<Value> values;\n+            if (value != null) {\n+                if (propertyIdValueValueMap.containsKey(pid)) {\n+                    values = propertyIdValueValueMap.get(pid);\n+                } else {\n+                    values = new HashSet<>();\n+                }\n+                values.add(value);\n+                propertyIdValueValueMap.put(pid, values);\n+            }\n+        }\n+\n+        for (PropertyIdValue propertyId : propertyIdValueValueMap.keySet()) {\n+            List<Statement> constraintDefinitions = _fetcher.getConstraintsByType(propertyId, ITEM_REQUIRES_CONSTRAINT_QID);\n+            for (Statement statement : constraintDefinitions) {\n+                ItemRequiresConstraint constraint = new ItemRequiresConstraint(statement);\n+                PropertyIdValue itemRequiresPid = constraint.itemRequiresPid;\n+                List<Value> itemList = constraint.itemList;\n+                if (!propertyIdValueValueMap.containsKey(itemRequiresPid)) {\n+                    QAWarning issue = new QAWarning(update.isNew() ? newItemType : existingItemType, propertyId.getId() + itemRequiresPid.getId(), QAWarning.Severity.WARNING, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae26863db88ad4c1ddbc91725d72477b8dd3271d"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjQ3OQ==", "bodyText": "Sorry, missed by me.", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452812479", "createdAt": "2020-07-10T12:30:09Z", "author": {"login": "darecoder"}, "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package org.openrefine.wikidata.qa.scrutinizers;\n+\n+import org.openrefine.wikidata.qa.QAWarning;\n+import org.openrefine.wikidata.updates.ItemUpdate;\n+import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Snak;\n+import org.wikidata.wdtk.datamodel.interfaces.SnakGroup;\n+import org.wikidata.wdtk.datamodel.interfaces.Statement;\n+import org.wikidata.wdtk.datamodel.interfaces.Value;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ItemRequiresScrutinizer extends EditScrutinizer {\n+\n+    public static final String newItemType = \"item-requires-certain-other-statement\";\n+    public static final String existingItemType = \"item-should-have-certain-other-statement\";\n+    public static String ITEM_REQUIRES_CONSTRAINT_QID = \"Q21503247\";\n+    public static String ITEM_REQUIRES_PROPERTY_PID = \"P2306\";\n+    public static String ITEM_OF_PROPERTY_CONSTRAINT_PID = \"P2305\";\n+\n+    class ItemRequiresConstraint {\n+        final PropertyIdValue itemRequiresPid;\n+        final List<Value> itemList;\n+\n+        ItemRequiresConstraint(Statement statement) {\n+            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n+            PropertyIdValue pid = null;\n+            this.itemList = new ArrayList<>();\n+            for(SnakGroup group : specs) {\n+                for (Snak snak : group.getSnaks()) {\n+                    if (group.getProperty().getId().equals(ITEM_REQUIRES_PROPERTY_PID)){\n+                        pid = (PropertyIdValue) snak.getValue();\n+                    }\n+                    if (group.getProperty().getId().equals(ITEM_OF_PROPERTY_CONSTRAINT_PID)){\n+                        this.itemList.add(snak.getValue());\n+                    }\n+                }\n+            }\n+            this.itemRequiresPid = pid;\n+        }\n+    }\n+\n+    @Override\n+    public void scrutinize(ItemUpdate update) {\n+        Map<PropertyIdValue, Set<Value>> propertyIdValueValueMap = new HashMap<>();\n+        for (Statement statement : update.getAddedStatements()) {\n+            PropertyIdValue pid = statement.getClaim().getMainSnak().getPropertyId();\n+            Value value = statement.getClaim().getMainSnak().getValue();\n+            Set<Value> values;\n+            if (value != null) {\n+                if (propertyIdValueValueMap.containsKey(pid)) {\n+                    values = propertyIdValueValueMap.get(pid);\n+                } else {\n+                    values = new HashSet<>();\n+                }\n+                values.add(value);\n+                propertyIdValueValueMap.put(pid, values);\n+            }\n+        }\n+\n+        for (PropertyIdValue propertyId : propertyIdValueValueMap.keySet()) {\n+            List<Statement> constraintDefinitions = _fetcher.getConstraintsByType(propertyId, ITEM_REQUIRES_CONSTRAINT_QID);\n+            for (Statement statement : constraintDefinitions) {\n+                ItemRequiresConstraint constraint = new ItemRequiresConstraint(statement);\n+                PropertyIdValue itemRequiresPid = constraint.itemRequiresPid;\n+                List<Value> itemList = constraint.itemList;\n+                if (!propertyIdValueValueMap.containsKey(itemRequiresPid)) {\n+                    QAWarning issue = new QAWarning(update.isNew() ? newItemType : existingItemType, propertyId.getId() + itemRequiresPid.getId(), QAWarning.Severity.WARNING, 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMDQzNA=="}, "originalCommit": {"oid": "ae26863db88ad4c1ddbc91725d72477b8dd3271d"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzQyNDA0OnYy", "diffSide": "RIGHT", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjo0OToxN1rOGv2DSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMzo0Nzo1OVrOGv4Dfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgyMTgzMg==", "bodyText": "If I am not wrong, the two branches of this if { } else if {} are identical, so you could deduplicate the code with an OR (||) in your first if. But because of that, I\u00a0am wondering if the else if branch should not be different: we probably want to display a different message for such a violation. If property A requires property B with a list of allowed values, and we have a violation in the else if branch here, we should say that although there is indeed a statement with property B, it does not have one of the allowed values, hence the violation. That probably means having 4 different violation messages for this constraint in total!", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452821832", "createdAt": "2020-07-10T12:49:17Z", "author": {"login": "wetneb"}, "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizer.java", "diffHunk": "@@ -62,27 +63,26 @@ public void scrutinize(ItemUpdate update) {\n             }\n         }\n \n-        for(PropertyIdValue propertyId : propertyIdValueValueMap.keySet()){\n+        for (PropertyIdValue propertyId : propertyIdValueValueMap.keySet()) {\n             List<Statement> constraintDefinitions = _fetcher.getConstraintsByType(propertyId, ITEM_REQUIRES_CONSTRAINT_QID);\n             for (Statement statement : constraintDefinitions) {\n                 ItemRequiresConstraint constraint = new ItemRequiresConstraint(statement);\n                 PropertyIdValue itemRequiresPid = constraint.itemRequiresPid;\n                 List<Value> itemList = constraint.itemList;\n                 if (!propertyIdValueValueMap.containsKey(itemRequiresPid)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5e0c0228201994ab82fcc86dbff3ccb3e2aa0a7"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgzMjQxMw==", "bodyText": "I'm not having a clear idea about this, how can we have 4 different violation messages?\nProperty A requires property B with a set of allowed values, then the violations will be:\n\nIt doesn't have property B, then we don't have to check about the values\nIt does have property B but it doesn't have the required value.\n\nCan you specific the other two?", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452832413", "createdAt": "2020-07-10T13:09:38Z", "author": {"login": "darecoder"}, "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizer.java", "diffHunk": "@@ -62,27 +63,26 @@ public void scrutinize(ItemUpdate update) {\n             }\n         }\n \n-        for(PropertyIdValue propertyId : propertyIdValueValueMap.keySet()){\n+        for (PropertyIdValue propertyId : propertyIdValueValueMap.keySet()) {\n             List<Statement> constraintDefinitions = _fetcher.getConstraintsByType(propertyId, ITEM_REQUIRES_CONSTRAINT_QID);\n             for (Statement statement : constraintDefinitions) {\n                 ItemRequiresConstraint constraint = new ItemRequiresConstraint(statement);\n                 PropertyIdValue itemRequiresPid = constraint.itemRequiresPid;\n                 List<Value> itemList = constraint.itemList;\n                 if (!propertyIdValueValueMap.containsKey(itemRequiresPid)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgyMTgzMg=="}, "originalCommit": {"oid": "c5e0c0228201994ab82fcc86dbff3ccb3e2aa0a7"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjg1NDY1NQ==", "bodyText": "Sure:\n\nIt doesn't have property B, and we don't have to check about the values. And the item where the constraint is found already exists.\nIt does have property B but it doesn't have the required value. And the item where the constraint is found already exists.\nIt doesn't have property B, and we don't have to check about the values. And the item where the constraint is found is new.\nIt does have property B but it doesn't have the required value. And the item where the constraint is found is new.", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452854655", "createdAt": "2020-07-10T13:47:59Z", "author": {"login": "wetneb"}, "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizer.java", "diffHunk": "@@ -62,27 +63,26 @@ public void scrutinize(ItemUpdate update) {\n             }\n         }\n \n-        for(PropertyIdValue propertyId : propertyIdValueValueMap.keySet()){\n+        for (PropertyIdValue propertyId : propertyIdValueValueMap.keySet()) {\n             List<Statement> constraintDefinitions = _fetcher.getConstraintsByType(propertyId, ITEM_REQUIRES_CONSTRAINT_QID);\n             for (Statement statement : constraintDefinitions) {\n                 ItemRequiresConstraint constraint = new ItemRequiresConstraint(statement);\n                 PropertyIdValue itemRequiresPid = constraint.itemRequiresPid;\n                 List<Value> itemList = constraint.itemList;\n                 if (!propertyIdValueValueMap.containsKey(itemRequiresPid)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgyMTgzMg=="}, "originalCommit": {"oid": "c5e0c0228201994ab82fcc86dbff3ccb3e2aa0a7"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2660, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}