{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2MzI0MTQ0", "number": 2906, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMDozMDoyOFrOENC6IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMzo1NDo1OFrOENGDcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTE0NTkzOnYy", "diffSide": "RIGHT", "path": "main/src/com/google/refine/commands/recon/GuessTypesOfColumnCommand.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMDozMDoyOFrOGvgtsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMToyNjoxMVrOGviYaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3MjI0MA==", "bodyText": "10 seconds should be fine for any reasonable service, but I wonder if it will be enough for Wikidata.", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452472240", "createdAt": "2020-07-09T20:30:28Z", "author": {"login": "tfmorris"}, "path": "main/src/com/google/refine/commands/recon/GuessTypesOfColumnCommand.java", "diffHunk": "@@ -170,70 +183,66 @@ protected IndividualQuery(String query, int limit) {\n         \n         String queriesString = ParsingUtilities.defaultWriter.writeValueAsString(queryMap);\n         try {\n-            URL url = new URL(serviceUrl);\n-            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-            {\n-                connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\n-                connection.setConnectTimeout(30000);\n-                connection.setDoOutput(true);\n-                \n-                DataOutputStream dos = new DataOutputStream(connection.getOutputStream());\n-                try {\n-                    String body = \"queries=\" + ParsingUtilities.encode(queriesString);\n-                    \n-                    dos.writeBytes(body);\n-                } finally {\n-                    dos.flush();\n-                    dos.close();\n+            RequestConfig defaultRequestConfig = RequestConfig.custom()\n+                    .setConnectTimeout(30 * 1000)\n+                    .setConnectionRequestTimeout(30 * 1000)\n+                    .setSocketTimeout(10 * 1000).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5OTU2MA==", "bodyText": "10 seconds will indeed be too short for Wikidata, complex queries can take 1 sec so batches of 10 queries would be likely to overrun.", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452499560", "createdAt": "2020-07-09T21:26:11Z", "author": {"login": "wetneb"}, "path": "main/src/com/google/refine/commands/recon/GuessTypesOfColumnCommand.java", "diffHunk": "@@ -170,70 +183,66 @@ protected IndividualQuery(String query, int limit) {\n         \n         String queriesString = ParsingUtilities.defaultWriter.writeValueAsString(queryMap);\n         try {\n-            URL url = new URL(serviceUrl);\n-            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-            {\n-                connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\n-                connection.setConnectTimeout(30000);\n-                connection.setDoOutput(true);\n-                \n-                DataOutputStream dos = new DataOutputStream(connection.getOutputStream());\n-                try {\n-                    String body = \"queries=\" + ParsingUtilities.encode(queriesString);\n-                    \n-                    dos.writeBytes(body);\n-                } finally {\n-                    dos.flush();\n-                    dos.close();\n+            RequestConfig defaultRequestConfig = RequestConfig.custom()\n+                    .setConnectTimeout(30 * 1000)\n+                    .setConnectionRequestTimeout(30 * 1000)\n+                    .setSocketTimeout(10 * 1000).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3MjI0MA=="}, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTE2NzQ0OnYy", "diffSide": "RIGHT", "path": "main/src/com/google/refine/commands/recon/GuessTypesOfColumnCommand.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMDozNzozMlrOGvg7Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMTo0NTo0NVrOGvi57A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3NTcyNg==", "bodyText": "Could you just use LaxRedirectStrategy here?\nThe docs only mention 301, 302, & 307. Is the lack of 308 a documentation oversight or a missing capability?", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452475726", "createdAt": "2020-07-09T20:37:32Z", "author": {"login": "tfmorris"}, "path": "main/src/com/google/refine/commands/recon/GuessTypesOfColumnCommand.java", "diffHunk": "@@ -170,70 +183,66 @@ protected IndividualQuery(String query, int limit) {\n         \n         String queriesString = ParsingUtilities.defaultWriter.writeValueAsString(queryMap);\n         try {\n-            URL url = new URL(serviceUrl);\n-            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-            {\n-                connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\n-                connection.setConnectTimeout(30000);\n-                connection.setDoOutput(true);\n-                \n-                DataOutputStream dos = new DataOutputStream(connection.getOutputStream());\n-                try {\n-                    String body = \"queries=\" + ParsingUtilities.encode(queriesString);\n-                    \n-                    dos.writeBytes(body);\n-                } finally {\n-                    dos.flush();\n-                    dos.close();\n+            RequestConfig defaultRequestConfig = RequestConfig.custom()\n+                    .setConnectTimeout(30 * 1000)\n+                    .setConnectionRequestTimeout(30 * 1000)\n+                    .setSocketTimeout(10 * 1000).build();\n+\n+            HttpClientBuilder httpClientBuilder = HttpClients.custom()\n+                    .setUserAgent(RefineServlet.getUserAgent())\n+                    .setRedirectStrategy(new DefaultRedirectStrategy(new String[] {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUwMTM5Mw==", "bodyText": "Thank you! The amazing thing is that I first defined my own subclass of DefaultRedirectStrategy and picked the same LaxRedirectStrategy name for it.\nAbout HTTP 308: all I know is that it works with the HTTP 308 that Wikidata serves at the moment. Where did you see the mention of these specific codes?", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452501393", "createdAt": "2020-07-09T21:30:08Z", "author": {"login": "wetneb"}, "path": "main/src/com/google/refine/commands/recon/GuessTypesOfColumnCommand.java", "diffHunk": "@@ -170,70 +183,66 @@ protected IndividualQuery(String query, int limit) {\n         \n         String queriesString = ParsingUtilities.defaultWriter.writeValueAsString(queryMap);\n         try {\n-            URL url = new URL(serviceUrl);\n-            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-            {\n-                connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\n-                connection.setConnectTimeout(30000);\n-                connection.setDoOutput(true);\n-                \n-                DataOutputStream dos = new DataOutputStream(connection.getOutputStream());\n-                try {\n-                    String body = \"queries=\" + ParsingUtilities.encode(queriesString);\n-                    \n-                    dos.writeBytes(body);\n-                } finally {\n-                    dos.flush();\n-                    dos.close();\n+            RequestConfig defaultRequestConfig = RequestConfig.custom()\n+                    .setConnectTimeout(30 * 1000)\n+                    .setConnectionRequestTimeout(30 * 1000)\n+                    .setSocketTimeout(10 * 1000).build();\n+\n+            HttpClientBuilder httpClientBuilder = HttpClients.custom()\n+                    .setUserAgent(RefineServlet.getUserAgent())\n+                    .setRedirectStrategy(new DefaultRedirectStrategy(new String[] {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3NTcyNg=="}, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUwODE0MA==", "bodyText": "308 is newer, so it's probably a doc oversight. Doc page is here: https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/impl/client/DefaultRedirectStrategy.html", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452508140", "createdAt": "2020-07-09T21:45:45Z", "author": {"login": "tfmorris"}, "path": "main/src/com/google/refine/commands/recon/GuessTypesOfColumnCommand.java", "diffHunk": "@@ -170,70 +183,66 @@ protected IndividualQuery(String query, int limit) {\n         \n         String queriesString = ParsingUtilities.defaultWriter.writeValueAsString(queryMap);\n         try {\n-            URL url = new URL(serviceUrl);\n-            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-            {\n-                connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\n-                connection.setConnectTimeout(30000);\n-                connection.setDoOutput(true);\n-                \n-                DataOutputStream dos = new DataOutputStream(connection.getOutputStream());\n-                try {\n-                    String body = \"queries=\" + ParsingUtilities.encode(queriesString);\n-                    \n-                    dos.writeBytes(body);\n-                } finally {\n-                    dos.flush();\n-                    dos.close();\n+            RequestConfig defaultRequestConfig = RequestConfig.custom()\n+                    .setConnectTimeout(30 * 1000)\n+                    .setConnectionRequestTimeout(30 * 1000)\n+                    .setSocketTimeout(10 * 1000).build();\n+\n+            HttpClientBuilder httpClientBuilder = HttpClients.custom()\n+                    .setUserAgent(RefineServlet.getUserAgent())\n+                    .setRedirectStrategy(new DefaultRedirectStrategy(new String[] {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3NTcyNg=="}, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTE4NzM0OnYy", "diffSide": "RIGHT", "path": "main/src/com/google/refine/model/recon/ReconciledDataExtensionJob.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMDo0Mzo1NVrOGvhHnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMTozMjoxNFrOGvii_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3ODg3Ng==", "bodyText": "Old code used a connection timeout of 5 sec. I'm not sure if there was a reason and 30 sec seems fine to me, so just noting the difference.", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452478876", "createdAt": "2020-07-09T20:43:55Z", "author": {"login": "tfmorris"}, "path": "main/src/com/google/refine/model/recon/ReconciledDataExtensionJob.java", "diffHunk": "@@ -206,29 +226,49 @@ public ReconciledDataExtensionJob(DataExtensionConfig obj, String endpoint) {\n         }\n     }\n \n+    /**\n+     * @todo this should be refactored to be unified with the HTTP querying code\n+     * from StandardReconConfig. We should ideally extract a library to query\n+     * reconciliation services and expose it as such for others to reuse.\n+     */\n+    \n     static protected InputStream performQuery(String endpoint, String query) throws IOException {\n-        URL url = new URL(endpoint);\n-\n-        URLConnection connection = url.openConnection();\n-        connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n-        connection.setConnectTimeout(5000);\n-        connection.setDoOutput(true);\n-\n-        DataOutputStream dos = new DataOutputStream(connection.getOutputStream());\n-        try {\n-            String body = \"extend=\" + ParsingUtilities.encode(query);\n-\n-            dos.writeBytes(body);\n-        } finally {\n-            dos.flush();\n-            dos.close();\n+        HttpPost request = new HttpPost(endpoint);\n+        List<NameValuePair> body = Collections.singletonList(\n+                new BasicNameValuePair(\"queries\", query));\n+        request.setEntity(new UrlEncodedFormEntity(body, Consts.UTF_8));\n+        \n+        try (CloseableHttpResponse response = getHttpClient().execute(request)) {\n+            StatusLine statusLine = response.getStatusLine();\n+            if (statusLine.getStatusCode() >= 400) {\n+                throw new IOException(\"Data extension query failed - code: \"\n+                        + Integer.toString(statusLine.getStatusCode())\n+                        + \" message: \" + statusLine.getReasonPhrase());\n+            } else {\n+                return response.getEntity().getContent();\n+            }\n         }\n+    }\n \n-        connection.connect();\n+    private static CloseableHttpClient getHttpClient() {\n+        if (httpClient != null) {\n+            return httpClient;\n+        }\n+        RequestConfig defaultRequestConfig = RequestConfig.custom()\n+                .setConnectTimeout(30 * 1000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUwMjI3MA==", "bodyText": "Yes, I think it makes sense to use the same connection settings for reconciliation endpoints, and I anticipate this code being refactored to be shared.", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452502270", "createdAt": "2020-07-09T21:32:14Z", "author": {"login": "wetneb"}, "path": "main/src/com/google/refine/model/recon/ReconciledDataExtensionJob.java", "diffHunk": "@@ -206,29 +226,49 @@ public ReconciledDataExtensionJob(DataExtensionConfig obj, String endpoint) {\n         }\n     }\n \n+    /**\n+     * @todo this should be refactored to be unified with the HTTP querying code\n+     * from StandardReconConfig. We should ideally extract a library to query\n+     * reconciliation services and expose it as such for others to reuse.\n+     */\n+    \n     static protected InputStream performQuery(String endpoint, String query) throws IOException {\n-        URL url = new URL(endpoint);\n-\n-        URLConnection connection = url.openConnection();\n-        connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n-        connection.setConnectTimeout(5000);\n-        connection.setDoOutput(true);\n-\n-        DataOutputStream dos = new DataOutputStream(connection.getOutputStream());\n-        try {\n-            String body = \"extend=\" + ParsingUtilities.encode(query);\n-\n-            dos.writeBytes(body);\n-        } finally {\n-            dos.flush();\n-            dos.close();\n+        HttpPost request = new HttpPost(endpoint);\n+        List<NameValuePair> body = Collections.singletonList(\n+                new BasicNameValuePair(\"queries\", query));\n+        request.setEntity(new UrlEncodedFormEntity(body, Consts.UTF_8));\n+        \n+        try (CloseableHttpResponse response = getHttpClient().execute(request)) {\n+            StatusLine statusLine = response.getStatusLine();\n+            if (statusLine.getStatusCode() >= 400) {\n+                throw new IOException(\"Data extension query failed - code: \"\n+                        + Integer.toString(statusLine.getStatusCode())\n+                        + \" message: \" + statusLine.getReasonPhrase());\n+            } else {\n+                return response.getEntity().getContent();\n+            }\n         }\n+    }\n \n-        connection.connect();\n+    private static CloseableHttpClient getHttpClient() {\n+        if (httpClient != null) {\n+            return httpClient;\n+        }\n+        RequestConfig defaultRequestConfig = RequestConfig.custom()\n+                .setConnectTimeout(30 * 1000)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3ODg3Ng=="}, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTIwNjI5OnYy", "diffSide": "RIGHT", "path": "main/src/com/google/refine/model/recon/ReconciledDataExtensionJob.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMDo1MDowNVrOGvhTRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzoxOTo1OVrOGxxbzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ4MTg2MA==", "bodyText": "Is this  (and CloseableHttpClient) thread-safe? I haven't traced how this is used, but it seems unusual and perhaps risky to be reusing it in multiple, perhaps simultaneous, performQuery() method calls.", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452481860", "createdAt": "2020-07-09T20:50:05Z", "author": {"login": "tfmorris"}, "path": "main/src/com/google/refine/model/recon/ReconciledDataExtensionJob.java", "diffHunk": "@@ -206,29 +226,49 @@ public ReconciledDataExtensionJob(DataExtensionConfig obj, String endpoint) {\n         }\n     }\n \n+    /**\n+     * @todo this should be refactored to be unified with the HTTP querying code\n+     * from StandardReconConfig. We should ideally extract a library to query\n+     * reconciliation services and expose it as such for others to reuse.\n+     */\n+    \n     static protected InputStream performQuery(String endpoint, String query) throws IOException {\n-        URL url = new URL(endpoint);\n-\n-        URLConnection connection = url.openConnection();\n-        connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n-        connection.setConnectTimeout(5000);\n-        connection.setDoOutput(true);\n-\n-        DataOutputStream dos = new DataOutputStream(connection.getOutputStream());\n-        try {\n-            String body = \"extend=\" + ParsingUtilities.encode(query);\n-\n-            dos.writeBytes(body);\n-        } finally {\n-            dos.flush();\n-            dos.close();\n+        HttpPost request = new HttpPost(endpoint);\n+        List<NameValuePair> body = Collections.singletonList(\n+                new BasicNameValuePair(\"queries\", query));\n+        request.setEntity(new UrlEncodedFormEntity(body, Consts.UTF_8));\n+        \n+        try (CloseableHttpResponse response = getHttpClient().execute(request)) {\n+            StatusLine statusLine = response.getStatusLine();\n+            if (statusLine.getStatusCode() >= 400) {\n+                throw new IOException(\"Data extension query failed - code: \"\n+                        + Integer.toString(statusLine.getStatusCode())\n+                        + \" message: \" + statusLine.getReasonPhrase());\n+            } else {\n+                return response.getEntity().getContent();\n+            }\n         }\n+    }\n \n-        connection.connect();\n+    private static CloseableHttpClient getHttpClient() {\n+        if (httpClient != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUwMzY3NA==", "bodyText": "In the current architecture it should not be used concurrently but for good measure I can instantiate it with\nMultiThreadedHttpConnectionManager (https://hc.apache.org/httpclient-3.x/threading.html)", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452503674", "createdAt": "2020-07-09T21:35:29Z", "author": {"login": "wetneb"}, "path": "main/src/com/google/refine/model/recon/ReconciledDataExtensionJob.java", "diffHunk": "@@ -206,29 +226,49 @@ public ReconciledDataExtensionJob(DataExtensionConfig obj, String endpoint) {\n         }\n     }\n \n+    /**\n+     * @todo this should be refactored to be unified with the HTTP querying code\n+     * from StandardReconConfig. We should ideally extract a library to query\n+     * reconciliation services and expose it as such for others to reuse.\n+     */\n+    \n     static protected InputStream performQuery(String endpoint, String query) throws IOException {\n-        URL url = new URL(endpoint);\n-\n-        URLConnection connection = url.openConnection();\n-        connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n-        connection.setConnectTimeout(5000);\n-        connection.setDoOutput(true);\n-\n-        DataOutputStream dos = new DataOutputStream(connection.getOutputStream());\n-        try {\n-            String body = \"extend=\" + ParsingUtilities.encode(query);\n-\n-            dos.writeBytes(body);\n-        } finally {\n-            dos.flush();\n-            dos.close();\n+        HttpPost request = new HttpPost(endpoint);\n+        List<NameValuePair> body = Collections.singletonList(\n+                new BasicNameValuePair(\"queries\", query));\n+        request.setEntity(new UrlEncodedFormEntity(body, Consts.UTF_8));\n+        \n+        try (CloseableHttpResponse response = getHttpClient().execute(request)) {\n+            StatusLine statusLine = response.getStatusLine();\n+            if (statusLine.getStatusCode() >= 400) {\n+                throw new IOException(\"Data extension query failed - code: \"\n+                        + Integer.toString(statusLine.getStatusCode())\n+                        + \" message: \" + statusLine.getReasonPhrase());\n+            } else {\n+                return response.getEntity().getContent();\n+            }\n         }\n+    }\n \n-        connection.connect();\n+    private static CloseableHttpClient getHttpClient() {\n+        if (httpClient != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ4MTg2MA=="}, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg0MzM0Mg==", "bodyText": "This actually belongs to a different library, so let's keep it that way - a Job only gets executed in a single thread anyway, so no need to add this overhead anyway.", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r454843342", "createdAt": "2020-07-15T07:19:59Z", "author": {"login": "wetneb"}, "path": "main/src/com/google/refine/model/recon/ReconciledDataExtensionJob.java", "diffHunk": "@@ -206,29 +226,49 @@ public ReconciledDataExtensionJob(DataExtensionConfig obj, String endpoint) {\n         }\n     }\n \n+    /**\n+     * @todo this should be refactored to be unified with the HTTP querying code\n+     * from StandardReconConfig. We should ideally extract a library to query\n+     * reconciliation services and expose it as such for others to reuse.\n+     */\n+    \n     static protected InputStream performQuery(String endpoint, String query) throws IOException {\n-        URL url = new URL(endpoint);\n-\n-        URLConnection connection = url.openConnection();\n-        connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n-        connection.setConnectTimeout(5000);\n-        connection.setDoOutput(true);\n-\n-        DataOutputStream dos = new DataOutputStream(connection.getOutputStream());\n-        try {\n-            String body = \"extend=\" + ParsingUtilities.encode(query);\n-\n-            dos.writeBytes(body);\n-        } finally {\n-            dos.flush();\n-            dos.close();\n+        HttpPost request = new HttpPost(endpoint);\n+        List<NameValuePair> body = Collections.singletonList(\n+                new BasicNameValuePair(\"queries\", query));\n+        request.setEntity(new UrlEncodedFormEntity(body, Consts.UTF_8));\n+        \n+        try (CloseableHttpResponse response = getHttpClient().execute(request)) {\n+            StatusLine statusLine = response.getStatusLine();\n+            if (statusLine.getStatusCode() >= 400) {\n+                throw new IOException(\"Data extension query failed - code: \"\n+                        + Integer.toString(statusLine.getStatusCode())\n+                        + \" message: \" + statusLine.getReasonPhrase());\n+            } else {\n+                return response.getEntity().getContent();\n+            }\n         }\n+    }\n \n-        connection.connect();\n+    private static CloseableHttpClient getHttpClient() {\n+        if (httpClient != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ4MTg2MA=="}, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTIwOTgwOnYy", "diffSide": "RIGHT", "path": "main/src/com/google/refine/model/recon/ReconciledDataExtensionJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMDo1MToxNFrOGvhVhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMDo1MToxNFrOGvhVhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ4MjQzOQ==", "bodyText": "Unused imports should be removed", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452482439", "createdAt": "2020-07-09T20:51:14Z", "author": {"login": "tfmorris"}, "path": "main/src/com/google/refine/model/recon/ReconciledDataExtensionJob.java", "diffHunk": "@@ -44,12 +44,28 @@\n import java.net.URL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTIyNTExOnYy", "diffSide": "RIGHT", "path": "main/src/com/google/refine/model/recon/StandardReconConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMDo1NTozOFrOGvhezA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMTozNzowM1rOGvirIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ4NDgxMg==", "bodyText": "Since there's no issue with static access, can't this just be initialized in the constructor?", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452484812", "createdAt": "2020-07-09T20:55:38Z", "author": {"login": "tfmorris"}, "path": "main/src/com/google/refine/model/recon/StandardReconConfig.java", "diffHunk": "@@ -154,6 +165,9 @@ public String toString() {\n     @JsonProperty(\"limit\")\n     final private int limit;\n \n+    // initialized lazily\n+    private CloseableHttpClient httpClient = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUwNDM1NQ==", "bodyText": "My intention was to try to avoid any overhead there, since this class is deserialized quite often (as soon as you have a reconciled column in the project, it will get saved / restored every time you save the ColumnModel)", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452504355", "createdAt": "2020-07-09T21:37:03Z", "author": {"login": "wetneb"}, "path": "main/src/com/google/refine/model/recon/StandardReconConfig.java", "diffHunk": "@@ -154,6 +165,9 @@ public String toString() {\n     @JsonProperty(\"limit\")\n     final private int limit;\n \n+    // initialized lazily\n+    private CloseableHttpClient httpClient = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ4NDgxMg=="}, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTI1NDM4OnYy", "diffSide": "RIGHT", "path": "main/tests/server/src/com/google/refine/importers/WikitextImporterTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMTowNDo1MlrOGvhwyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMTozNzozM1rOGvir5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ4OTQxNw==", "bodyText": "I have a feeling I may not want to know the answer to this, but why does an importer test have a dependency on reconciliation? That seems very odd.", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452489417", "createdAt": "2020-07-09T21:04:52Z", "author": {"login": "tfmorris"}, "path": "main/tests/server/src/com/google/refine/importers/WikitextImporterTests.java", "diffHunk": "@@ -51,12 +53,16 @@\n import org.testng.annotations.BeforeTest;\n import org.testng.annotations.Test;\n \n-import com.google.refine.importers.WikitextImporter;\n+import com.google.refine.model.Recon;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUwNDU0OA==", "bodyText": "Because the importer itself depends on reconciliation to create reconciled cells?", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452504548", "createdAt": "2020-07-09T21:37:33Z", "author": {"login": "wetneb"}, "path": "main/tests/server/src/com/google/refine/importers/WikitextImporterTests.java", "diffHunk": "@@ -51,12 +53,16 @@\n import org.testng.annotations.BeforeTest;\n import org.testng.annotations.Test;\n \n-import com.google.refine.importers.WikitextImporter;\n+import com.google.refine.model.Recon;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ4OTQxNw=="}, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTY2MTI5OnYy", "diffSide": "RIGHT", "path": "main/src/com/google/refine/commands/recon/GuessTypesOfColumnCommand.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMzo1NDo1OFrOGvljHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNDo1MjozOVrOGv6coQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU1MTQ1NQ==", "bodyText": "This needs to handle a JsonParseException either here or in the surrounding try/except block.", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452551455", "createdAt": "2020-07-09T23:54:58Z", "author": {"login": "tfmorris"}, "path": "main/src/com/google/refine/commands/recon/GuessTypesOfColumnCommand.java", "diffHunk": "@@ -170,70 +183,66 @@ protected IndividualQuery(String query, int limit) {\n         \n         String queriesString = ParsingUtilities.defaultWriter.writeValueAsString(queryMap);\n         try {\n-            URL url = new URL(serviceUrl);\n-            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-            {\n-                connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\n-                connection.setConnectTimeout(30000);\n-                connection.setDoOutput(true);\n-                \n-                DataOutputStream dos = new DataOutputStream(connection.getOutputStream());\n-                try {\n-                    String body = \"queries=\" + ParsingUtilities.encode(queriesString);\n-                    \n-                    dos.writeBytes(body);\n-                } finally {\n-                    dos.flush();\n-                    dos.close();\n+            RequestConfig defaultRequestConfig = RequestConfig.custom()\n+                    .setConnectTimeout(30 * 1000)\n+                    .setConnectionRequestTimeout(30 * 1000)\n+                    .setSocketTimeout(10 * 1000).build();\n+\n+            HttpClientBuilder httpClientBuilder = HttpClients.custom()\n+                    .setUserAgent(RefineServlet.getUserAgent())\n+                    .setRedirectStrategy(new DefaultRedirectStrategy(new String[] {\n+                            HttpGet.METHOD_NAME,\n+                            HttpHead.METHOD_NAME,\n+                            HttpPost.METHOD_NAME }))\n+                    .setDefaultRequestConfig(defaultRequestConfig);\n+            \n+            CloseableHttpClient httpClient = httpClientBuilder.build();\n+            HttpPost request = new HttpPost(serviceUrl);\n+            List<NameValuePair> body = Collections.singletonList(\n+                    new BasicNameValuePair(\"queries\", queriesString));\n+            request.setEntity(new UrlEncodedFormEntity(body, Consts.UTF_8));\n+            \n+            try (CloseableHttpResponse response = httpClient.execute(request)) {\n+                StatusLine statusLine = response.getStatusLine();\n+                if (statusLine.getStatusCode() >= 400) {\n+                    throw new IOException(\"Failed  - code:\" \n+                            + Integer.toString(statusLine.getStatusCode()) \n+                            + \" message: \" + statusLine.getReasonPhrase());\n                 }\n                 \n-                connection.connect();\n-            }\n-\n-            if (connection.getResponseCode() >= 400) {\n-                InputStream is = connection.getErrorStream();\n-                throw new IOException(\"Failed  - code:\" \n-                        + Integer.toString(connection.getResponseCode()) \n-                        + \" message: \" + is == null ? \"\" : ParsingUtilities.inputStreamToString(is));\n-            } else {\n-                InputStream is = connection.getInputStream();\n-                try {\n-                    String s = ParsingUtilities.inputStreamToString(is);\n-                    ObjectNode o = ParsingUtilities.evaluateJsonStringToObjectNode(s);\n+                String s = ParsingUtilities.inputStreamToString(response.getEntity().getContent());\n+                ObjectNode o = ParsingUtilities.evaluateJsonStringToObjectNode(s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc2OTEwNQ==", "bodyText": "JsonException is a sublcass of IOException, so isn't the current handling of IOException enough? What specific action do you want to take when a JsonParseException is raised?", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452769105", "createdAt": "2020-07-10T10:46:01Z", "author": {"login": "wetneb"}, "path": "main/src/com/google/refine/commands/recon/GuessTypesOfColumnCommand.java", "diffHunk": "@@ -170,70 +183,66 @@ protected IndividualQuery(String query, int limit) {\n         \n         String queriesString = ParsingUtilities.defaultWriter.writeValueAsString(queryMap);\n         try {\n-            URL url = new URL(serviceUrl);\n-            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-            {\n-                connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\n-                connection.setConnectTimeout(30000);\n-                connection.setDoOutput(true);\n-                \n-                DataOutputStream dos = new DataOutputStream(connection.getOutputStream());\n-                try {\n-                    String body = \"queries=\" + ParsingUtilities.encode(queriesString);\n-                    \n-                    dos.writeBytes(body);\n-                } finally {\n-                    dos.flush();\n-                    dos.close();\n+            RequestConfig defaultRequestConfig = RequestConfig.custom()\n+                    .setConnectTimeout(30 * 1000)\n+                    .setConnectionRequestTimeout(30 * 1000)\n+                    .setSocketTimeout(10 * 1000).build();\n+\n+            HttpClientBuilder httpClientBuilder = HttpClients.custom()\n+                    .setUserAgent(RefineServlet.getUserAgent())\n+                    .setRedirectStrategy(new DefaultRedirectStrategy(new String[] {\n+                            HttpGet.METHOD_NAME,\n+                            HttpHead.METHOD_NAME,\n+                            HttpPost.METHOD_NAME }))\n+                    .setDefaultRequestConfig(defaultRequestConfig);\n+            \n+            CloseableHttpClient httpClient = httpClientBuilder.build();\n+            HttpPost request = new HttpPost(serviceUrl);\n+            List<NameValuePair> body = Collections.singletonList(\n+                    new BasicNameValuePair(\"queries\", queriesString));\n+            request.setEntity(new UrlEncodedFormEntity(body, Consts.UTF_8));\n+            \n+            try (CloseableHttpResponse response = httpClient.execute(request)) {\n+                StatusLine statusLine = response.getStatusLine();\n+                if (statusLine.getStatusCode() >= 400) {\n+                    throw new IOException(\"Failed  - code:\" \n+                            + Integer.toString(statusLine.getStatusCode()) \n+                            + \" message: \" + statusLine.getReasonPhrase());\n                 }\n                 \n-                connection.connect();\n-            }\n-\n-            if (connection.getResponseCode() >= 400) {\n-                InputStream is = connection.getErrorStream();\n-                throw new IOException(\"Failed  - code:\" \n-                        + Integer.toString(connection.getResponseCode()) \n-                        + \" message: \" + is == null ? \"\" : ParsingUtilities.inputStreamToString(is));\n-            } else {\n-                InputStream is = connection.getInputStream();\n-                try {\n-                    String s = ParsingUtilities.inputStreamToString(is);\n-                    ObjectNode o = ParsingUtilities.evaluateJsonStringToObjectNode(s);\n+                String s = ParsingUtilities.inputStreamToString(response.getEntity().getContent());\n+                ObjectNode o = ParsingUtilities.evaluateJsonStringToObjectNode(s);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU1MTQ1NQ=="}, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjg5Mzg1Nw==", "bodyText": "OK, there must be some other issue then. The goal is to have OpenRefine return an error to the user rather than just stay frozen with its spinner up as shown by the screen capture and server traceback in issue #2903.", "url": "https://github.com/OpenRefine/OpenRefine/pull/2906#discussion_r452893857", "createdAt": "2020-07-10T14:52:39Z", "author": {"login": "tfmorris"}, "path": "main/src/com/google/refine/commands/recon/GuessTypesOfColumnCommand.java", "diffHunk": "@@ -170,70 +183,66 @@ protected IndividualQuery(String query, int limit) {\n         \n         String queriesString = ParsingUtilities.defaultWriter.writeValueAsString(queryMap);\n         try {\n-            URL url = new URL(serviceUrl);\n-            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-            {\n-                connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\n-                connection.setConnectTimeout(30000);\n-                connection.setDoOutput(true);\n-                \n-                DataOutputStream dos = new DataOutputStream(connection.getOutputStream());\n-                try {\n-                    String body = \"queries=\" + ParsingUtilities.encode(queriesString);\n-                    \n-                    dos.writeBytes(body);\n-                } finally {\n-                    dos.flush();\n-                    dos.close();\n+            RequestConfig defaultRequestConfig = RequestConfig.custom()\n+                    .setConnectTimeout(30 * 1000)\n+                    .setConnectionRequestTimeout(30 * 1000)\n+                    .setSocketTimeout(10 * 1000).build();\n+\n+            HttpClientBuilder httpClientBuilder = HttpClients.custom()\n+                    .setUserAgent(RefineServlet.getUserAgent())\n+                    .setRedirectStrategy(new DefaultRedirectStrategy(new String[] {\n+                            HttpGet.METHOD_NAME,\n+                            HttpHead.METHOD_NAME,\n+                            HttpPost.METHOD_NAME }))\n+                    .setDefaultRequestConfig(defaultRequestConfig);\n+            \n+            CloseableHttpClient httpClient = httpClientBuilder.build();\n+            HttpPost request = new HttpPost(serviceUrl);\n+            List<NameValuePair> body = Collections.singletonList(\n+                    new BasicNameValuePair(\"queries\", queriesString));\n+            request.setEntity(new UrlEncodedFormEntity(body, Consts.UTF_8));\n+            \n+            try (CloseableHttpResponse response = httpClient.execute(request)) {\n+                StatusLine statusLine = response.getStatusLine();\n+                if (statusLine.getStatusCode() >= 400) {\n+                    throw new IOException(\"Failed  - code:\" \n+                            + Integer.toString(statusLine.getStatusCode()) \n+                            + \" message: \" + statusLine.getReasonPhrase());\n                 }\n                 \n-                connection.connect();\n-            }\n-\n-            if (connection.getResponseCode() >= 400) {\n-                InputStream is = connection.getErrorStream();\n-                throw new IOException(\"Failed  - code:\" \n-                        + Integer.toString(connection.getResponseCode()) \n-                        + \" message: \" + is == null ? \"\" : ParsingUtilities.inputStreamToString(is));\n-            } else {\n-                InputStream is = connection.getInputStream();\n-                try {\n-                    String s = ParsingUtilities.inputStreamToString(is);\n-                    ObjectNode o = ParsingUtilities.evaluateJsonStringToObjectNode(s);\n+                String s = ParsingUtilities.inputStreamToString(response.getEntity().getContent());\n+                ObjectNode o = ParsingUtilities.evaluateJsonStringToObjectNode(s);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU1MTQ1NQ=="}, "originalCommit": {"oid": "13ac77ded2810604d28eef97a06259e870c5fce0"}, "originalPosition": 139}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2664, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}