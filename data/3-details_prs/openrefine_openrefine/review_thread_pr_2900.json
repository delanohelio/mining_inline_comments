{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1MTI4NDM1", "number": 2900, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNzoyNTo0OFrOEL9Lgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNzoyNTo0OFrOEL9Lgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTcyMTYyOnYy", "diffSide": "LEFT", "path": "main/src/com/google/refine/clustering/binning/FingerprintKeyer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNzoyNTo0OFrOGtyOqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTowMzoyMFrOGuLwWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY2MjA1Ng==", "bodyText": "Random thought: to make sure we are not missing any of these cases by expressing the conversion with your regular expression, would it make sense to just transform this deleted code into a unit test which would check that all the behaviour is preserved for all the cases listed here?", "url": "https://github.com/OpenRefine/OpenRefine/pull/2900#discussion_r450662056", "createdAt": "2020-07-07T07:25:48Z", "author": {"login": "wetneb"}, "path": "main/src/com/google/refine/clustering/binning/FingerprintKeyer.java", "diffHunk": "@@ -69,222 +96,32 @@ public String key(String s, Object... o) {\n         return b.toString();\n     }\n \n+    protected String normalize(String s) {\n+        s = stripDiacritics(s);\n+        s = stripNonDiacritics(s);\n+        return s;\n+    }\n+\n+    @Deprecated\n     protected String asciify(String s) {\n-        char[] c = s.toCharArray();\n-        StringBuffer b = new StringBuffer();\n-        for (char element : c) {\n-            b.append(translate(element));\n-        }\n-        return b.toString();\n+        return normalize(s);\n     }\n-    \n-    /**\n-     * Translate the given unicode char in the closest ASCII representation\n-     * NOTE: this function deals only with latin-1 supplement and latin-1 extended code charts\n-     */\n-    private char translate(char c) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de51a9178bb775b280442c4e2300afda68391545"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MDI4MA==", "bodyText": "Good idea. I did that and updated the normalization with some substitutions for visually similar characters which are not normally considered the same. I also switched to the more powerful compatibility decomposition (NFKD) from the canonical decomposition (NFD) which is a bigger hammer, but this is intended to be a relatively blunt instrument. When we expose normalization as a function, we can allow more fine grained control.\nThe current code should handle all characters in the old table the same, except for O with stroke which is now \"oe\" instead of \"o\", and provide equivalent semantics for all characters and ligatures which were not included in the old table.\nWe need to decide (eventually) whether we want to continue the practice of aggressively folding Latin characters to their nearest ASCII equivalent even if the Java normalization code doesn't. The Latin Extended B and Latin Extended C characters (and probably others) would require us to do our own mappings. Latin Basic, Latin-1 Supplement, Latin Extended A and Latin Extended Additional are fully covered.", "url": "https://github.com/OpenRefine/OpenRefine/pull/2900#discussion_r451080280", "createdAt": "2020-07-07T19:03:20Z", "author": {"login": "tfmorris"}, "path": "main/src/com/google/refine/clustering/binning/FingerprintKeyer.java", "diffHunk": "@@ -69,222 +96,32 @@ public String key(String s, Object... o) {\n         return b.toString();\n     }\n \n+    protected String normalize(String s) {\n+        s = stripDiacritics(s);\n+        s = stripNonDiacritics(s);\n+        return s;\n+    }\n+\n+    @Deprecated\n     protected String asciify(String s) {\n-        char[] c = s.toCharArray();\n-        StringBuffer b = new StringBuffer();\n-        for (char element : c) {\n-            b.append(translate(element));\n-        }\n-        return b.toString();\n+        return normalize(s);\n     }\n-    \n-    /**\n-     * Translate the given unicode char in the closest ASCII representation\n-     * NOTE: this function deals only with latin-1 supplement and latin-1 extended code charts\n-     */\n-    private char translate(char c) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY2MjA1Ng=="}, "originalCommit": {"oid": "de51a9178bb775b280442c4e2300afda68391545"}, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2658, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}