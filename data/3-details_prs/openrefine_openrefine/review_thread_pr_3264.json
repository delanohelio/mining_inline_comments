{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNjMwMTQ2", "number": 3264, "reviewThreads": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNDo1OTowMVrOE4M1ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo1MDoyNlrOE9sC-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzY2MDQ2OnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNDo1OTowMVrOHx-waQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNDo1OTowMVrOHx-waQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE3MDQ3Mw==", "bodyText": "I think we've lost the definition of startsWith()", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522170473", "createdAt": "2020-11-12T14:59:01Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzY2OTY2OnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTowMDo1M1rOHx-2RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTowMDo1M1rOHx-2RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE3MTk3Mg==", "bodyText": "Do we need a definition of titlecase? (also is it worth flagging that acronyms will get converted to title case as well which can sometimes be an issue?)", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522171972", "createdAt": "2020-11-12T15:00:53Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzY4MDEzOnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTowMzoxN1rOHx-9FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTowMzoxN1rOHx-9FQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE3MzcxNw==", "bodyText": "I might use an example of `substring(0, -1) here as it demonstrates how to return a full string except the last character - which I think is a slightly more common use case and also demonstrates the use of zero in substring", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522173717", "createdAt": "2020-11-12T15:03:17Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzY4ODE3OnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTowNDo1NlrOHx_CJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMDo0MToyMVrOHyNj7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE3NTAxNQ==", "bodyText": "Can we think of a more realistic example for this?", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522175015", "createdAt": "2020-11-12T15:04:56Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQxMzAzOQ==", "bodyText": "\"Th\u00eds t\u00e9xt was opt\u00edc\u00e1lly rec\u00f3gn\u00edz\u00e9d\".replaceChars(\"\u00e1\u00e9\u00ed\u00f3\u00fa\", \"aeiou\")\n\n:) I'm sure I could find an example that's actually text-recognized but something like this.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522413039", "createdAt": "2020-11-12T20:41:21Z", "author": {"login": "allanaaa"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE3NTAxNQ=="}, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Mzc5NTMxOnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNToyNzo0N1rOHyAGSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNToyNzo0N1rOHyAGSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE5MjQ1Nw==", "bodyText": "I think \"to store in a cell\" rather than \"to capture it in a cell\" - especially as \"capture\" has a specific meaning in relation to regular expressions (see other comments)", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522192457", "createdAt": "2020-11-12T15:27:47Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to capture it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzgwMzI3OnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNToyOToyMFrOHyALTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMDo0Mjo1N1rOHyNnMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE5Mzc0Mw==", "bodyText": "It returns an array of any \"capture groups\" specified in the regular expressions - i.e. those parts of the regular expression in brackets ( ). I think it's worth using the regular expression terminology here as it will be the same terminology used in any regular expression tutorial a user might find elsewhere", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522193743", "createdAt": "2020-11-12T15:29:20Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQxMzg3NA==", "bodyText": "match(s, p)#\n\n\nAttempts to match the string s in its entirety against the regex pattern p and, if the pattern is found, outputs an array of all capturing groups (found in order). For example, \"230.22398, 12.3480\".match(/.(\\d\\d\\d\\d)/) returns an array of 1 substring: [ \"3480\" ]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\nYou will need to convert the array to a string to store it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\nRemember to enclose your regex in forward slashes, and to escape characters and use parentheses as needed. Parentheses are required to denote a desired substring (capturing group); for example, \u201c.(\\d\\d\\d\\d)\u201d would return an array containing a single value, while \u201c(.)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax value.match(/.(desired-substring-regex).*/).\n\nI really don't love the phrase \"capture group\" or \"capturing group\" - it's really hard to work it in as though it's casual language. Maybe I can just link to a definition somewhere?", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522413874", "createdAt": "2020-11-12T20:42:57Z", "author": {"login": "allanaaa"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE5Mzc0Mw=="}, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Mzg0NDkxOnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTozNzozM1rOHyAlEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTozODoyMFrOHyAnfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIwMDMzOA==", "bodyText": "To be in line with regular expression terminology we should use \"escape\" rather than \"cancel out\". Also as above I think \"capture groups\" rather than \"desired substring\".", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522200338", "createdAt": "2020-11-12T15:37:33Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to capture it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to cancel out characters and use parentheses as needed. Parentheses are required to denote a desired substring; for example, \u201c.*(\\d\\d\\d\\d)\u201d would return one array value, while \u201c(.*)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIwMDk1Nw==", "bodyText": "I think \"would return an array containing a single value\" would be clearer than \"would return one array value\"", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522200957", "createdAt": "2020-11-12T15:38:20Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to capture it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to cancel out characters and use parentheses as needed. Parentheses are required to denote a desired substring; for example, \u201c.*(\\d\\d\\d\\d)\u201d would return one array value, while \u201c(.*)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIwMDMzOA=="}, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Mzg1ODM4OnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo0MDoxNFrOHyAtZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo0ODo0N1rOHyBIXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIwMjQ3MA==", "bodyText": "find can find a literal string as well as a pattern", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522202470", "createdAt": "2020-11-12T15:40:14Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to capture it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to cancel out characters and use parentheses as needed. Parentheses are required to denote a desired substring; for example, \u201c.*(\\d\\d\\d\\d)\u201d would return one array value, while \u201c(.*)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the cell contains value \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|value.match(/\\d{6}/) |null (does not match the full string)|\n+|value.match(/.*\\d{6}.*/) |[ ] (no indicated substring)|\n+|value.match(/.*(\\d{6}).*/) |[ \"123456\" ] (array with one value)|\n+|value.match(/(.*)(\\d{6})(.*)/) |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+###### find(s, p)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIwOTM3Mw==", "bodyText": "I see you've explained this further down - I think it is worth saying up front - maybe re-ordering the paragraphs?", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522209373", "createdAt": "2020-11-12T15:48:47Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to capture it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to cancel out characters and use parentheses as needed. Parentheses are required to denote a desired substring; for example, \u201c.*(\\d\\d\\d\\d)\u201d would return one array value, while \u201c(.*)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the cell contains value \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|value.match(/\\d{6}/) |null (does not match the full string)|\n+|value.match(/.*\\d{6}.*/) |[ ] (no indicated substring)|\n+|value.match(/.*(\\d{6}).*/) |[ \"123456\" ] (array with one value)|\n+|value.match(/(.*)(\\d{6})(.*)/) |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+###### find(s, p)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIwMjQ3MA=="}, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Mzg5NTQ2OnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo0NzozOFrOHyBEzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo0NzozOFrOHyBEzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIwODQ2MQ==", "bodyText": "I'm not sure about this description. find() differs from match() in several ways:\n\nIt can accept a literal string as well as a regular expression as the thing to find\nIt will find all occurrences of the literal/regular expression in the string\nIt will return all occurrences of the literal/regular expression in an array (no need for capture groups)\n\nAt least I think it is worth saying \"find() will search out\" rather than \"find() can search out\" - as it isn't an option", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522208461", "createdAt": "2020-11-12T15:47:38Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to capture it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to cancel out characters and use parentheses as needed. Parentheses are required to denote a desired substring; for example, \u201c.*(\\d\\d\\d\\d)\u201d would return one array value, while \u201c(.*)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the cell contains value \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|value.match(/\\d{6}/) |null (does not match the full string)|\n+|value.match(/.*\\d{6}.*/) |[ ] (no indicated substring)|\n+|value.match(/.*(\\d{6}).*/) |[ \"123456\" ] (array with one value)|\n+|value.match(/(.*)(\\d{6})(.*)/) |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+###### find(s, p)\n+\n+Outputs, into an array, all consecutive substrings inside string s that match the [regex](#grel-supported-regex) pattern p. Unlike match(), find() can search out and return several occurrences of the same pattern in a string, because it is not evaluating the regex against the string in its entirety. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzkyODk2OnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo1NDoxNVrOHyBZXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo1NDoxNVrOHyBZXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxMzcyNQ==", "bodyText": "From what I can see toNumber() only actually works on a string - so I think we should say toNumber(s) rather than (o). Returns s converted to a number (if the string can be recognised as a number). toNumber does accept a number as input, and in that case it just returns the number", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522213725", "createdAt": "2020-11-12T15:54:15Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to capture it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to cancel out characters and use parentheses as needed. Parentheses are required to denote a desired substring; for example, \u201c.*(\\d\\d\\d\\d)\u201d would return one array value, while \u201c(.*)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the cell contains value \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|value.match(/\\d{6}/) |null (does not match the full string)|\n+|value.match(/.*\\d{6}.*/) |[ ] (no indicated substring)|\n+|value.match(/.*(\\d{6}).*/) |[ \"123456\" ] (array with one value)|\n+|value.match(/(.*)(\\d{6})(.*)/) |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+###### find(s, p)\n+\n+Outputs, into an array, all consecutive substrings inside string s that match the [regex](#grel-supported-regex) pattern p. Unlike match(), find() can search out and return several occurrences of the same pattern in a string, because it is not evaluating the regex against the string in its entirety. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a string instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \u201cfine is\u201d ].\n+\n+### String parsing and splitting\n+\n+###### toNumber(o)\n+\n+Returns o converted to a number.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzkzMzgxOnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo1NToxMlrOHyBcVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo1NToxMlrOHyBcVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxNDQ4NQ==", "bodyText": "I think we should refer to the \"The separator\" rather than \"The sep\" after we've explained that sep = separator", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522214485", "createdAt": "2020-11-12T15:55:12Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to capture it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to cancel out characters and use parentheses as needed. Parentheses are required to denote a desired substring; for example, \u201c.*(\\d\\d\\d\\d)\u201d would return one array value, while \u201c(.*)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the cell contains value \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|value.match(/\\d{6}/) |null (does not match the full string)|\n+|value.match(/.*\\d{6}.*/) |[ ] (no indicated substring)|\n+|value.match(/.*(\\d{6}).*/) |[ \"123456\" ] (array with one value)|\n+|value.match(/(.*)(\\d{6})(.*)/) |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+###### find(s, p)\n+\n+Outputs, into an array, all consecutive substrings inside string s that match the [regex](#grel-supported-regex) pattern p. Unlike match(), find() can search out and return several occurrences of the same pattern in a string, because it is not evaluating the regex against the string in its entirety. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a string instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \u201cfine is\u201d ].\n+\n+### String parsing and splitting\n+\n+###### toNumber(o)\n+\n+Returns o converted to a number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by the separator sep. The sep can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\u201d, \u201c air\u201d ]. Note that the space characters are retained but the separator is removed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Mzk0NjIyOnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo1Nzo0OFrOHyBkFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo1Nzo0OFrOHyBkFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxNjQ3MA==", "bodyText": "Since this entry is just about strings we can simplify here to just be the string case", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522216470", "createdAt": "2020-11-12T15:57:48Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to capture it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to cancel out characters and use parentheses as needed. Parentheses are required to denote a desired substring; for example, \u201c.*(\\d\\d\\d\\d)\u201d would return one array value, while \u201c(.*)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the cell contains value \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|value.match(/\\d{6}/) |null (does not match the full string)|\n+|value.match(/.*\\d{6}.*/) |[ ] (no indicated substring)|\n+|value.match(/.*(\\d{6}).*/) |[ \"123456\" ] (array with one value)|\n+|value.match(/(.*)(\\d{6})(.*)/) |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+###### find(s, p)\n+\n+Outputs, into an array, all consecutive substrings inside string s that match the [regex](#grel-supported-regex) pattern p. Unlike match(), find() can search out and return several occurrences of the same pattern in a string, because it is not evaluating the regex against the string in its entirety. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a string instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \u201cfine is\u201d ].\n+\n+### String parsing and splitting\n+\n+###### toNumber(o)\n+\n+Returns o converted to a number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by the separator sep. The sep can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\u201d, \u201c air\u201d ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ inter, nation, ali ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by the separator sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\u201cHenryCTaylor\u201d.splitByCharType()` will result in an array of [ H, enry, CT, aylor ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ BE, 1, A, 3, E ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ inter, nation, alization ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ par, a, llel ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1 or d1, s2 or d2, s timeUnit (optional))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Mzk1MjUzOnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo1OTowMlrOHyBoCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo1OTowMlrOHyBoCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxNzQ4MA==", "bodyText": "is it worth mentioning the string indicating the mode must be in inverted commas? \"html\" not just html", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522217480", "createdAt": "2020-11-12T15:59:02Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to capture it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to cancel out characters and use parentheses as needed. Parentheses are required to denote a desired substring; for example, \u201c.*(\\d\\d\\d\\d)\u201d would return one array value, while \u201c(.*)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the cell contains value \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|value.match(/\\d{6}/) |null (does not match the full string)|\n+|value.match(/.*\\d{6}.*/) |[ ] (no indicated substring)|\n+|value.match(/.*(\\d{6}).*/) |[ \"123456\" ] (array with one value)|\n+|value.match(/(.*)(\\d{6})(.*)/) |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+###### find(s, p)\n+\n+Outputs, into an array, all consecutive substrings inside string s that match the [regex](#grel-supported-regex) pattern p. Unlike match(), find() can search out and return several occurrences of the same pattern in a string, because it is not evaluating the regex against the string in its entirety. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a string instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \u201cfine is\u201d ].\n+\n+### String parsing and splitting\n+\n+###### toNumber(o)\n+\n+Returns o converted to a number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by the separator sep. The sep can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\u201d, \u201c air\u201d ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ inter, nation, ali ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by the separator sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\u201cHenryCTaylor\u201d.splitByCharType()` will result in an array of [ H, enry, CT, aylor ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ BE, 1, A, 3, E ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ inter, nation, alization ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ par, a, llel ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1 or d1, s2 or d2, s timeUnit (optional))\n+\n+Takes two strings or two dates and compares them, returning a string. The two objects must be the same data type. For strings, diff() returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". For dates, see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: html, xml, csv, url, javascript. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Mzk1NTg4OnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo1OTozNFrOHyBp8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo1OTozNFrOHyBp8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxNzk2OQ==", "bodyText": "as above - indicate mode must be in inverted commas", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522217969", "createdAt": "2020-11-12T15:59:34Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to capture it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to cancel out characters and use parentheses as needed. Parentheses are required to denote a desired substring; for example, \u201c.*(\\d\\d\\d\\d)\u201d would return one array value, while \u201c(.*)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the cell contains value \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|value.match(/\\d{6}/) |null (does not match the full string)|\n+|value.match(/.*\\d{6}.*/) |[ ] (no indicated substring)|\n+|value.match(/.*(\\d{6}).*/) |[ \"123456\" ] (array with one value)|\n+|value.match(/(.*)(\\d{6})(.*)/) |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+###### find(s, p)\n+\n+Outputs, into an array, all consecutive substrings inside string s that match the [regex](#grel-supported-regex) pattern p. Unlike match(), find() can search out and return several occurrences of the same pattern in a string, because it is not evaluating the regex against the string in its entirety. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a string instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \u201cfine is\u201d ].\n+\n+### String parsing and splitting\n+\n+###### toNumber(o)\n+\n+Returns o converted to a number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by the separator sep. The sep can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\u201d, \u201c air\u201d ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ inter, nation, ali ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by the separator sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\u201cHenryCTaylor\u201d.splitByCharType()` will result in an array of [ H, enry, CT, aylor ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ BE, 1, A, 3, E ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ inter, nation, alization ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ par, a, llel ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1 or d1, s2 or d2, s timeUnit (optional))\n+\n+Takes two strings or two dates and compares them, returning a string. The two objects must be the same data type. For strings, diff() returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". For dates, see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: html, xml, csv, url, javascript. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: html, xml, csv, url, javascript. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Mzk3NDgyOnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjowMzoyOFrOHyB13A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjowMzoyOFrOHyB13A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIyMTAyMA==", "bodyText": "This is a slightly odd string example? As it looks like an array", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522221020", "createdAt": "2020-11-12T16:03:28Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to capture it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to cancel out characters and use parentheses as needed. Parentheses are required to denote a desired substring; for example, \u201c.*(\\d\\d\\d\\d)\u201d would return one array value, while \u201c(.*)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the cell contains value \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|value.match(/\\d{6}/) |null (does not match the full string)|\n+|value.match(/.*\\d{6}.*/) |[ ] (no indicated substring)|\n+|value.match(/.*(\\d{6}).*/) |[ \"123456\" ] (array with one value)|\n+|value.match(/(.*)(\\d{6})(.*)/) |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+###### find(s, p)\n+\n+Outputs, into an array, all consecutive substrings inside string s that match the [regex](#grel-supported-regex) pattern p. Unlike match(), find() can search out and return several occurrences of the same pattern in a string, because it is not evaluating the regex against the string in its entirety. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a string instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \u201cfine is\u201d ].\n+\n+### String parsing and splitting\n+\n+###### toNumber(o)\n+\n+Returns o converted to a number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by the separator sep. The sep can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\u201d, \u201c air\u201d ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ inter, nation, ali ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by the separator sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\u201cHenryCTaylor\u201d.splitByCharType()` will result in an array of [ H, enry, CT, aylor ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ BE, 1, A, 3, E ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ inter, nation, alization ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ par, a, llel ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1 or d1, s2 or d2, s timeUnit (optional))\n+\n+Takes two strings or two dates and compares them, returning a string. The two objects must be the same data type. For strings, diff() returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". For dates, see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: html, xml, csv, url, javascript. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: html, xml, csv, url, javascript. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. \n+\n+###### md5(o)\n+\n+Returns the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of an object. If fed something other than a string (array, number, date, etc.), md5() will convert it to a string and deliver the hash of the string. For example, `\"[ and, or, not ]\".md5()` will return 80fd34c2da7787a20c6c5e32e4899459.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Mzk4MDUwOnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjowNDozN1rOHyB5dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMDo0NTo0MFrOHyNssg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIyMTk0Mw==", "bodyText": "We may wish to indicate the encoding algorithm needs to be in inverted commas", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522221943", "createdAt": "2020-11-12T16:04:37Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to capture it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to cancel out characters and use parentheses as needed. Parentheses are required to denote a desired substring; for example, \u201c.*(\\d\\d\\d\\d)\u201d would return one array value, while \u201c(.*)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the cell contains value \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|value.match(/\\d{6}/) |null (does not match the full string)|\n+|value.match(/.*\\d{6}.*/) |[ ] (no indicated substring)|\n+|value.match(/.*(\\d{6}).*/) |[ \"123456\" ] (array with one value)|\n+|value.match(/(.*)(\\d{6})(.*)/) |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+###### find(s, p)\n+\n+Outputs, into an array, all consecutive substrings inside string s that match the [regex](#grel-supported-regex) pattern p. Unlike match(), find() can search out and return several occurrences of the same pattern in a string, because it is not evaluating the regex against the string in its entirety. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a string instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \u201cfine is\u201d ].\n+\n+### String parsing and splitting\n+\n+###### toNumber(o)\n+\n+Returns o converted to a number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by the separator sep. The sep can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\u201d, \u201c air\u201d ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ inter, nation, ali ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by the separator sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\u201cHenryCTaylor\u201d.splitByCharType()` will result in an array of [ H, enry, CT, aylor ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ BE, 1, A, 3, E ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ inter, nation, alization ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ par, a, llel ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1 or d1, s2 or d2, s timeUnit (optional))\n+\n+Takes two strings or two dates and compares them, returning a string. The two objects must be the same data type. For strings, diff() returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". For dates, see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: html, xml, csv, url, javascript. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: html, xml, csv, url, javascript. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. \n+\n+###### md5(o)\n+\n+Returns the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of an object. If fed something other than a string (array, number, date, etc.), md5() will convert it to a string and deliver the hash of the string. For example, `\"[ and, or, not ]\".md5()` will return 80fd34c2da7787a20c6c5e32e4899459.\n+\n+###### sha1(o)\n+\n+Returns the [SHA-1 hash](https://en.wikipedia.org/wiki/SHA-1) of an object. If fed something other than a string (array, number, date, etc.), sha1() will convert it to a string and deliver the hash of the string. For example, `\"[ and, or, not ]\".sha1()` will return a6664fc5476a043cabc179da1e3ce736e3959bbc.\n+\n+###### phonetic(s, s encoding)\n+\n+Returns a phonetic encoding of a string, based on an available phonetic algorithm. See the [section on phonetic clustering](cellediting#clustering-methods) for more information. Can be one of the following supported phonetic methods: [metaphone, doublemetaphone, metaphone3](https://www.wikipedia.org/wiki/Metaphone), [soundex](https://en.wikipedia.org/wiki/Soundex), [cologne](https://en.wikipedia.org/wiki/Cologne_phonetics). For example, \u201cRuth Prawer Jhabvala\u201c.phonetic(metaphone3) outputs the string \u201cR0PRRJPF\u201d.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQxNTI4Mg==", "bodyText": "Done, but will leave this open to remind myself in case we need to change some text based on #3330 .", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522415282", "createdAt": "2020-11-12T20:45:40Z", "author": {"login": "allanaaa"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to capture it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to cancel out characters and use parentheses as needed. Parentheses are required to denote a desired substring; for example, \u201c.*(\\d\\d\\d\\d)\u201d would return one array value, while \u201c(.*)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the cell contains value \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|value.match(/\\d{6}/) |null (does not match the full string)|\n+|value.match(/.*\\d{6}.*/) |[ ] (no indicated substring)|\n+|value.match(/.*(\\d{6}).*/) |[ \"123456\" ] (array with one value)|\n+|value.match(/(.*)(\\d{6})(.*)/) |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+###### find(s, p)\n+\n+Outputs, into an array, all consecutive substrings inside string s that match the [regex](#grel-supported-regex) pattern p. Unlike match(), find() can search out and return several occurrences of the same pattern in a string, because it is not evaluating the regex against the string in its entirety. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a string instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \u201cfine is\u201d ].\n+\n+### String parsing and splitting\n+\n+###### toNumber(o)\n+\n+Returns o converted to a number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by the separator sep. The sep can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\u201d, \u201c air\u201d ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ inter, nation, ali ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by the separator sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\u201cHenryCTaylor\u201d.splitByCharType()` will result in an array of [ H, enry, CT, aylor ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ BE, 1, A, 3, E ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ inter, nation, alization ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ par, a, llel ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1 or d1, s2 or d2, s timeUnit (optional))\n+\n+Takes two strings or two dates and compares them, returning a string. The two objects must be the same data type. For strings, diff() returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". For dates, see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: html, xml, csv, url, javascript. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: html, xml, csv, url, javascript. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. \n+\n+###### md5(o)\n+\n+Returns the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of an object. If fed something other than a string (array, number, date, etc.), md5() will convert it to a string and deliver the hash of the string. For example, `\"[ and, or, not ]\".md5()` will return 80fd34c2da7787a20c6c5e32e4899459.\n+\n+###### sha1(o)\n+\n+Returns the [SHA-1 hash](https://en.wikipedia.org/wiki/SHA-1) of an object. If fed something other than a string (array, number, date, etc.), sha1() will convert it to a string and deliver the hash of the string. For example, `\"[ and, or, not ]\".sha1()` will return a6664fc5476a043cabc179da1e3ce736e3959bbc.\n+\n+###### phonetic(s, s encoding)\n+\n+Returns a phonetic encoding of a string, based on an available phonetic algorithm. See the [section on phonetic clustering](cellediting#clustering-methods) for more information. Can be one of the following supported phonetic methods: [metaphone, doublemetaphone, metaphone3](https://www.wikipedia.org/wiki/Metaphone), [soundex](https://en.wikipedia.org/wiki/Soundex), [cologne](https://en.wikipedia.org/wiki/Cologne_phonetics). For example, \u201cRuth Prawer Jhabvala\u201c.phonetic(metaphone3) outputs the string \u201cR0PRRJPF\u201d.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIyMTk0Mw=="}, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 227}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Mzk4Mzc5OnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjowNToxN1rOHyB7fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjowNToxN1rOHyB7fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIyMjQ2Mg==", "bodyText": "as above - maybe a simpler string in the example", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522222462", "createdAt": "2020-11-12T16:05:17Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,537 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \"asdfsd\" into a date or a number, but you can convert the number \"123\" into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \"null\".\n+\n+### Testing string characteristics\n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\u201cfood\u201d.endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase. For example, `\"Once upon a midnight dreary\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string hard.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(1, -1)` returns the string rofoun.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \"a\").\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"all the big cows lumber\".replaceChars(\"aeiou\", \"A!IOU\")` returns the string \u201cAll th! bIg cOws lUmb!r\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, returns an array of the desired substrings (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [3480]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to capture it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to cancel out characters and use parentheses as needed. Parentheses are required to denote a desired substring; for example, \u201c.*(\\d\\d\\d\\d)\u201d would return one array value, while \u201c(.*)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the cell contains value \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|value.match(/\\d{6}/) |null (does not match the full string)|\n+|value.match(/.*\\d{6}.*/) |[ ] (no indicated substring)|\n+|value.match(/.*(\\d{6}).*/) |[ \"123456\" ] (array with one value)|\n+|value.match(/(.*)(\\d{6})(.*)/) |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+###### find(s, p)\n+\n+Outputs, into an array, all consecutive substrings inside string s that match the [regex](#grel-supported-regex) pattern p. Unlike match(), find() can search out and return several occurrences of the same pattern in a string, because it is not evaluating the regex against the string in its entirety. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a string instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \u201cfine is\u201d ].\n+\n+### String parsing and splitting\n+\n+###### toNumber(o)\n+\n+Returns o converted to a number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by the separator sep. The sep can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\u201d, \u201c air\u201d ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ inter, nation, ali ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by the separator sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\u201cHenryCTaylor\u201d.splitByCharType()` will result in an array of [ H, enry, CT, aylor ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ BE, 1, A, 3, E ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ inter, nation, alization ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ par, a, llel ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1 or d1, s2 or d2, s timeUnit (optional))\n+\n+Takes two strings or two dates and compares them, returning a string. The two objects must be the same data type. For strings, diff() returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". For dates, see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: html, xml, csv, url, javascript. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: html, xml, csv, url, javascript. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. \n+\n+###### md5(o)\n+\n+Returns the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of an object. If fed something other than a string (array, number, date, etc.), md5() will convert it to a string and deliver the hash of the string. For example, `\"[ and, or, not ]\".md5()` will return 80fd34c2da7787a20c6c5e32e4899459.\n+\n+###### sha1(o)\n+\n+Returns the [SHA-1 hash](https://en.wikipedia.org/wiki/SHA-1) of an object. If fed something other than a string (array, number, date, etc.), sha1() will convert it to a string and deliver the hash of the string. For example, `\"[ and, or, not ]\".sha1()` will return a6664fc5476a043cabc179da1e3ce736e3959bbc.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDAxMDEyOnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/expressions.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjoxMDo1M1rOHyCL-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMDozOTo1NlrOHyNhQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIyNjY4Mw==", "bodyText": "I would format tables like this with inline code formatting in the first column: | `value` | instead of | value |. The same applies to all other tables which list variables, fields, or anything that would be typed in an expression editor.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522226683", "createdAt": "2020-11-12T16:10:53Z", "author": {"login": "wetneb"}, "path": "docs/docs/manual/expressions.md", "diffHunk": "@@ -1,57 +1,414 @@\n ---\n-\n id: expressions\n-\n title: Expressions\n-\n sidebar_label: Expressions\n-\n ---\n \n-\n ## Overview\n \n+You can use expressions in multiple places in OpenRefine to extend data cleanup and manipulation. \n+\n+Expressions are available with the following functions:\n+* <span class=\"menuItems\">Facet</span>:\n+\n+    *   <span class=\"menuItems\">Custom text facet...</span>\n+    *   <span class=\"menuItems\">Custom numeric facet\u2026</span>\n+    *   You can also manually \u201cchange\u201d most Customized facets after they have been created, which will bring up an expressions window. \n+* <span class=\"menuItems\">Edit cells</span>: \n+\n+    *   <span class=\"menuItems\">Transform\u2026</span>\n+    *   <span class=\"menuItems\">Split multi-valued cells\u2026</span>\n+    *   <span class=\"menuItems\">Join multi-valued cells\u2026</span>\n+* <span class=\"menuItems\">Edit column</span>: \n+\n+    *   <span class=\"menuItems\">Split</span>\n+    *   <span class=\"menuItems\">Join</span>\n+    *   <span class=\"menuItems\">Add column based on this column</span>\n+    *   <span class=\"menuItems\">Add column by fetching URLs</span>\n+\n+In the expressions editor window you will have the opportunity to select one supported language. The default is [GREL (General Refine Expression Language)](#grel-general-refine-expression-language); OpenRefine also comes with support for [Clojure](#clojure) and [Jython](#jython). Extensions may offer support for more expressions languages. \n+\n+These languages have some syntax differences but support most of the same [variables](#variables). For example, the GREL expression `value.split(\" \")[1]` would be written in Jython as `return value.split(\" \")[1]`.\n+\n+This page is a general reference for available functions, variables, and syntax. For examples that use these expressions for common data tasks, look at the [Recipes section on the Wiki](https://github.com/OpenRefine/OpenRefine/wiki/Documentation-For-Users#recipes-and-worked-examples). \n+\n+### Expressions\n+\n+There are significant differences between OpenRefine's expressions and the spreadsheet formulas you may be used to using for data manipulation. OpenRefine does not store formulas in cells and display output dynamically: OpenRefine\u2019s transformations are one-time operations that can change column contents or generate new columns. These are applied using variables such as `value` or `cell` to perform the same modification to each cell in a column. \n+\n+Take the following example:\n+\n+|ID|Friend|Age|\n+|---|---|---|\n+|1.|John Smith|28|\n+|2.|Jane Doe|33|\n+\n+Were you to apply a transformation to the \u201cfriend\u201d column with the expression\n+\n+```\n+ value.split(\" \")[1]\n+```\n+\n+OpenRefine would work through each row, splitting the \u201cfriend\u201d values based on a space character. `value` for row 1 would be \u201cJohn Smith\u201d so the output would be \u201cSmith\u201d (as \"[1]\" selects the second part of the created output); `value` for row 2 would be \u201cJane Doe\u201d so the output would be \u201cDoe.\u201d Using variables, a single expression yields different results for different rows. The old information would be discarded; you couldn't get \"John\" and \"Jane\" back unless you undid the operation in the History tab.\n+\n+For another example, if you were to create a new column based on your data using the expression `row.starred`, it would generate a column of true and false values based on whether your rows were starred at that moment. If you were to then star more rows and unstar some rows, that data would not dynamically update - you would need to run the operation again to have current true/false values. \n+\n+Note that an expression is typically based on one particular column in the data - the column whose drop-down menu is invoked. Many variables are created to stand for things about the cell in that \u201cbase column\u201d of the current row on which the expression is evaluated. There are also variables about rows, which you can use to access cells in other columns.\n+\n+### The expressions editor\n+\n+When you select a function that offers the ability to supply expressions, you will see a window overlay the screen with what we call the expressions editor. \n+\n+![The expressions editor window with a simple expression: value + 10.](/img/expression-editor.png)\n+\n+The expressions editor offers you a field for entering your formula and shows you a preview of its transformation on your first few rows of cells. \n+\n+There is a dropdown menu from which you can choose an expression language. The default is GREL. Jython and Clojure are also offered with the installation package, and you may be able to add more language support with third-party extensions and customizations. \n+\n+There are also tabs for:\n+*   History, which shows you formulas you\u2019ve recently used from across all your projects\n+*   Starred, which shows you formulas from your History that you\u2019ve starred for reuse\n+*   Help, a quick reference to GREL functions.\n+\n+Starring formulas you\u2019ve used in the past can be very helpful for repetitive tasks you\u2019re performing in batches. \n+\n+You can also choose how formula errors are handled: replicate the original cell value, output an error message into the cell, or ouput a blank cell.\n+\n+### Regular expressions\n+\n+OpenRefine offers several fields that support the use of regular expressions (regex), such as in a <span>Text filter</span> or a <span>Replace\u2026</span> operation. GREL and other expressions can also use regular expression markup to extend their functionality. \n+\n+If this is your first time working with regex, you may wish to read [this tutorial specific to the Java syntax that OpenRefine supports](https://docs.oracle.com/javase/tutorial/essential/regex/). We also recommend this [testing and learning tool](https://regexr.com/).\n+\n+#### GREL-supported regex\n+\n+To write a regular expression inside a GREL expression, wrap it between a pair of forward slashes (/) much like the way you would in Javascript. For example, in\n+\n+```\n+value.replace(/\\s+/, \" \")\n+```\n+\n+the regular expression is `\\s+`, and the syntax used in the expression wraps it with forward slashes (`/\\s+/`). Though the regular expression syntax in OpenRefine follows that of Java (normally in Java, you would write regex as a string and escape it like \"\\\\s+\"), a regular expression within a GREL expression is similar to Javascript.\n+\n+Do not use slashes to wrap regular expressions outside of a GREL expression.\n+\n+The [GREL functions](#grel-general-refine-expression-language) that support regex are:\n+*   replace\n+*   match\n+*   partition\n+*   rpartition\n+*   split\n+\n+#### Jython-supported regex\n+\n+You can also use [regex with Jython expressions](http://www.jython.org/docs/library/re.html), instead of GREL, for example with a Custom Text Facet: \n+\n+```\n+python import re g = re.search(ur\"\\u2014 (.*),\\s*BWV\", value) return g.group(1)\n+```\n+\n+#### Clojure-supported regex\n+\n+[Clojure](https://clojure.org/reference/reader) uses the same regex engine as Java, and can be invoked with [re-find](http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/re-find), [re-matches](http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/re-matches), etc. You can use the #\"pattern\" reader macro as described [in the Clojure documentation](https://clojure.org/reference/other_functions#regex). For example, to get the nth element of a returned sequence, you can use the nth function:\n+\n+```\n+clojure (nth (re-find #\"\\u2014 (.*),\\s*BWV\" value) 1)\n+```\n+\n+## Variables\n+\n+Most of the OpenRefine-specific variables have attributes: aspects of the variables that can be called separately. We call these attributes \"member fields\" because they belong to certain variables. For example, you can query a record to find out how many rows it contains with `row.record.rowCount`: `rowCount` is a member field specific to `record`, which is a member field of `row`. Member fields can be called using a dot separator, or with square brackets (`row[\"record\"]`).\n+\n+|Variable |Meaning |\n+|-|-|\n+| value | The value of the cell in the current column of the current row (can be null) |\n+| row | The current row |\n+| row.record | One or more rows grouped together to form a record |\n+| cells | The cells of the current row, with fields that correspond to the column names (or row.cells) |\n+| cell | The cell in the current column of the current row, containing value and other attributes |\n+| cell.recon | The cell's reconciliation information returned from a reconciliation service or provider |\n+| rowIndex | The index value of the current row (the first row is 0) |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQxMjM1NQ==", "bodyText": "I'm torn on this one. With the latest update everything is now formatted this way, but I think I would prefer to have none of it (and remove what was there before). Tables don't really need formatting inside them, I think.\nBut, it's done for now and can probably stay that way.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522412355", "createdAt": "2020-11-12T20:39:56Z", "author": {"login": "allanaaa"}, "path": "docs/docs/manual/expressions.md", "diffHunk": "@@ -1,57 +1,414 @@\n ---\n-\n id: expressions\n-\n title: Expressions\n-\n sidebar_label: Expressions\n-\n ---\n \n-\n ## Overview\n \n+You can use expressions in multiple places in OpenRefine to extend data cleanup and manipulation. \n+\n+Expressions are available with the following functions:\n+* <span class=\"menuItems\">Facet</span>:\n+\n+    *   <span class=\"menuItems\">Custom text facet...</span>\n+    *   <span class=\"menuItems\">Custom numeric facet\u2026</span>\n+    *   You can also manually \u201cchange\u201d most Customized facets after they have been created, which will bring up an expressions window. \n+* <span class=\"menuItems\">Edit cells</span>: \n+\n+    *   <span class=\"menuItems\">Transform\u2026</span>\n+    *   <span class=\"menuItems\">Split multi-valued cells\u2026</span>\n+    *   <span class=\"menuItems\">Join multi-valued cells\u2026</span>\n+* <span class=\"menuItems\">Edit column</span>: \n+\n+    *   <span class=\"menuItems\">Split</span>\n+    *   <span class=\"menuItems\">Join</span>\n+    *   <span class=\"menuItems\">Add column based on this column</span>\n+    *   <span class=\"menuItems\">Add column by fetching URLs</span>\n+\n+In the expressions editor window you will have the opportunity to select one supported language. The default is [GREL (General Refine Expression Language)](#grel-general-refine-expression-language); OpenRefine also comes with support for [Clojure](#clojure) and [Jython](#jython). Extensions may offer support for more expressions languages. \n+\n+These languages have some syntax differences but support most of the same [variables](#variables). For example, the GREL expression `value.split(\" \")[1]` would be written in Jython as `return value.split(\" \")[1]`.\n+\n+This page is a general reference for available functions, variables, and syntax. For examples that use these expressions for common data tasks, look at the [Recipes section on the Wiki](https://github.com/OpenRefine/OpenRefine/wiki/Documentation-For-Users#recipes-and-worked-examples). \n+\n+### Expressions\n+\n+There are significant differences between OpenRefine's expressions and the spreadsheet formulas you may be used to using for data manipulation. OpenRefine does not store formulas in cells and display output dynamically: OpenRefine\u2019s transformations are one-time operations that can change column contents or generate new columns. These are applied using variables such as `value` or `cell` to perform the same modification to each cell in a column. \n+\n+Take the following example:\n+\n+|ID|Friend|Age|\n+|---|---|---|\n+|1.|John Smith|28|\n+|2.|Jane Doe|33|\n+\n+Were you to apply a transformation to the \u201cfriend\u201d column with the expression\n+\n+```\n+ value.split(\" \")[1]\n+```\n+\n+OpenRefine would work through each row, splitting the \u201cfriend\u201d values based on a space character. `value` for row 1 would be \u201cJohn Smith\u201d so the output would be \u201cSmith\u201d (as \"[1]\" selects the second part of the created output); `value` for row 2 would be \u201cJane Doe\u201d so the output would be \u201cDoe.\u201d Using variables, a single expression yields different results for different rows. The old information would be discarded; you couldn't get \"John\" and \"Jane\" back unless you undid the operation in the History tab.\n+\n+For another example, if you were to create a new column based on your data using the expression `row.starred`, it would generate a column of true and false values based on whether your rows were starred at that moment. If you were to then star more rows and unstar some rows, that data would not dynamically update - you would need to run the operation again to have current true/false values. \n+\n+Note that an expression is typically based on one particular column in the data - the column whose drop-down menu is invoked. Many variables are created to stand for things about the cell in that \u201cbase column\u201d of the current row on which the expression is evaluated. There are also variables about rows, which you can use to access cells in other columns.\n+\n+### The expressions editor\n+\n+When you select a function that offers the ability to supply expressions, you will see a window overlay the screen with what we call the expressions editor. \n+\n+![The expressions editor window with a simple expression: value + 10.](/img/expression-editor.png)\n+\n+The expressions editor offers you a field for entering your formula and shows you a preview of its transformation on your first few rows of cells. \n+\n+There is a dropdown menu from which you can choose an expression language. The default is GREL. Jython and Clojure are also offered with the installation package, and you may be able to add more language support with third-party extensions and customizations. \n+\n+There are also tabs for:\n+*   History, which shows you formulas you\u2019ve recently used from across all your projects\n+*   Starred, which shows you formulas from your History that you\u2019ve starred for reuse\n+*   Help, a quick reference to GREL functions.\n+\n+Starring formulas you\u2019ve used in the past can be very helpful for repetitive tasks you\u2019re performing in batches. \n+\n+You can also choose how formula errors are handled: replicate the original cell value, output an error message into the cell, or ouput a blank cell.\n+\n+### Regular expressions\n+\n+OpenRefine offers several fields that support the use of regular expressions (regex), such as in a <span>Text filter</span> or a <span>Replace\u2026</span> operation. GREL and other expressions can also use regular expression markup to extend their functionality. \n+\n+If this is your first time working with regex, you may wish to read [this tutorial specific to the Java syntax that OpenRefine supports](https://docs.oracle.com/javase/tutorial/essential/regex/). We also recommend this [testing and learning tool](https://regexr.com/).\n+\n+#### GREL-supported regex\n+\n+To write a regular expression inside a GREL expression, wrap it between a pair of forward slashes (/) much like the way you would in Javascript. For example, in\n+\n+```\n+value.replace(/\\s+/, \" \")\n+```\n+\n+the regular expression is `\\s+`, and the syntax used in the expression wraps it with forward slashes (`/\\s+/`). Though the regular expression syntax in OpenRefine follows that of Java (normally in Java, you would write regex as a string and escape it like \"\\\\s+\"), a regular expression within a GREL expression is similar to Javascript.\n+\n+Do not use slashes to wrap regular expressions outside of a GREL expression.\n+\n+The [GREL functions](#grel-general-refine-expression-language) that support regex are:\n+*   replace\n+*   match\n+*   partition\n+*   rpartition\n+*   split\n+\n+#### Jython-supported regex\n+\n+You can also use [regex with Jython expressions](http://www.jython.org/docs/library/re.html), instead of GREL, for example with a Custom Text Facet: \n+\n+```\n+python import re g = re.search(ur\"\\u2014 (.*),\\s*BWV\", value) return g.group(1)\n+```\n+\n+#### Clojure-supported regex\n+\n+[Clojure](https://clojure.org/reference/reader) uses the same regex engine as Java, and can be invoked with [re-find](http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/re-find), [re-matches](http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/re-matches), etc. You can use the #\"pattern\" reader macro as described [in the Clojure documentation](https://clojure.org/reference/other_functions#regex). For example, to get the nth element of a returned sequence, you can use the nth function:\n+\n+```\n+clojure (nth (re-find #\"\\u2014 (.*),\\s*BWV\" value) 1)\n+```\n+\n+## Variables\n+\n+Most of the OpenRefine-specific variables have attributes: aspects of the variables that can be called separately. We call these attributes \"member fields\" because they belong to certain variables. For example, you can query a record to find out how many rows it contains with `row.record.rowCount`: `rowCount` is a member field specific to `record`, which is a member field of `row`. Member fields can be called using a dot separator, or with square brackets (`row[\"record\"]`).\n+\n+|Variable |Meaning |\n+|-|-|\n+| value | The value of the cell in the current column of the current row (can be null) |\n+| row | The current row |\n+| row.record | One or more rows grouped together to form a record |\n+| cells | The cells of the current row, with fields that correspond to the column names (or row.cells) |\n+| cell | The cell in the current column of the current row, containing value and other attributes |\n+| cell.recon | The cell's reconciliation information returned from a reconciliation service or provider |\n+| rowIndex | The index value of the current row (the first row is 0) |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIyNjY4Mw=="}, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDAyNTI4OnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/expressions.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjoxNDoxMVrOHyCVvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjoxNDoxMVrOHyCVvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIyOTE4MQ==", "bodyText": "This is an example of what I meant above.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r522229181", "createdAt": "2020-11-12T16:14:11Z", "author": {"login": "wetneb"}, "path": "docs/docs/manual/expressions.md", "diffHunk": "@@ -1,57 +1,414 @@\n ---\n-\n id: expressions\n-\n title: Expressions\n-\n sidebar_label: Expressions\n-\n ---\n \n-\n ## Overview\n \n+You can use expressions in multiple places in OpenRefine to extend data cleanup and manipulation. \n+\n+Expressions are available with the following functions:\n+* <span class=\"menuItems\">Facet</span>:\n+\n+    *   <span class=\"menuItems\">Custom text facet...</span>\n+    *   <span class=\"menuItems\">Custom numeric facet\u2026</span>\n+    *   You can also manually \u201cchange\u201d most Customized facets after they have been created, which will bring up an expressions window. \n+* <span class=\"menuItems\">Edit cells</span>: \n+\n+    *   <span class=\"menuItems\">Transform\u2026</span>\n+    *   <span class=\"menuItems\">Split multi-valued cells\u2026</span>\n+    *   <span class=\"menuItems\">Join multi-valued cells\u2026</span>\n+* <span class=\"menuItems\">Edit column</span>: \n+\n+    *   <span class=\"menuItems\">Split</span>\n+    *   <span class=\"menuItems\">Join</span>\n+    *   <span class=\"menuItems\">Add column based on this column</span>\n+    *   <span class=\"menuItems\">Add column by fetching URLs</span>\n+\n+In the expressions editor window you will have the opportunity to select one supported language. The default is [GREL (General Refine Expression Language)](#grel-general-refine-expression-language); OpenRefine also comes with support for [Clojure](#clojure) and [Jython](#jython). Extensions may offer support for more expressions languages. \n+\n+These languages have some syntax differences but support most of the same [variables](#variables). For example, the GREL expression `value.split(\" \")[1]` would be written in Jython as `return value.split(\" \")[1]`.\n+\n+This page is a general reference for available functions, variables, and syntax. For examples that use these expressions for common data tasks, look at the [Recipes section on the Wiki](https://github.com/OpenRefine/OpenRefine/wiki/Documentation-For-Users#recipes-and-worked-examples). \n+\n+### Expressions\n+\n+There are significant differences between OpenRefine's expressions and the spreadsheet formulas you may be used to using for data manipulation. OpenRefine does not store formulas in cells and display output dynamically: OpenRefine\u2019s transformations are one-time operations that can change column contents or generate new columns. These are applied using variables such as `value` or `cell` to perform the same modification to each cell in a column. \n+\n+Take the following example:\n+\n+|ID|Friend|Age|\n+|---|---|---|\n+|1.|John Smith|28|\n+|2.|Jane Doe|33|\n+\n+Were you to apply a transformation to the \u201cfriend\u201d column with the expression\n+\n+```\n+ value.split(\" \")[1]\n+```\n+\n+OpenRefine would work through each row, splitting the \u201cfriend\u201d values based on a space character. `value` for row 1 would be \u201cJohn Smith\u201d so the output would be \u201cSmith\u201d (as \"[1]\" selects the second part of the created output); `value` for row 2 would be \u201cJane Doe\u201d so the output would be \u201cDoe.\u201d Using variables, a single expression yields different results for different rows. The old information would be discarded; you couldn't get \"John\" and \"Jane\" back unless you undid the operation in the History tab.\n+\n+For another example, if you were to create a new column based on your data using the expression `row.starred`, it would generate a column of true and false values based on whether your rows were starred at that moment. If you were to then star more rows and unstar some rows, that data would not dynamically update - you would need to run the operation again to have current true/false values. \n+\n+Note that an expression is typically based on one particular column in the data - the column whose drop-down menu is invoked. Many variables are created to stand for things about the cell in that \u201cbase column\u201d of the current row on which the expression is evaluated. There are also variables about rows, which you can use to access cells in other columns.\n+\n+### The expressions editor\n+\n+When you select a function that offers the ability to supply expressions, you will see a window overlay the screen with what we call the expressions editor. \n+\n+![The expressions editor window with a simple expression: value + 10.](/img/expression-editor.png)\n+\n+The expressions editor offers you a field for entering your formula and shows you a preview of its transformation on your first few rows of cells. \n+\n+There is a dropdown menu from which you can choose an expression language. The default is GREL. Jython and Clojure are also offered with the installation package, and you may be able to add more language support with third-party extensions and customizations. \n+\n+There are also tabs for:\n+*   History, which shows you formulas you\u2019ve recently used from across all your projects\n+*   Starred, which shows you formulas from your History that you\u2019ve starred for reuse\n+*   Help, a quick reference to GREL functions.\n+\n+Starring formulas you\u2019ve used in the past can be very helpful for repetitive tasks you\u2019re performing in batches. \n+\n+You can also choose how formula errors are handled: replicate the original cell value, output an error message into the cell, or ouput a blank cell.\n+\n+### Regular expressions\n+\n+OpenRefine offers several fields that support the use of regular expressions (regex), such as in a <span>Text filter</span> or a <span>Replace\u2026</span> operation. GREL and other expressions can also use regular expression markup to extend their functionality. \n+\n+If this is your first time working with regex, you may wish to read [this tutorial specific to the Java syntax that OpenRefine supports](https://docs.oracle.com/javase/tutorial/essential/regex/). We also recommend this [testing and learning tool](https://regexr.com/).\n+\n+#### GREL-supported regex\n+\n+To write a regular expression inside a GREL expression, wrap it between a pair of forward slashes (/) much like the way you would in Javascript. For example, in\n+\n+```\n+value.replace(/\\s+/, \" \")\n+```\n+\n+the regular expression is `\\s+`, and the syntax used in the expression wraps it with forward slashes (`/\\s+/`). Though the regular expression syntax in OpenRefine follows that of Java (normally in Java, you would write regex as a string and escape it like \"\\\\s+\"), a regular expression within a GREL expression is similar to Javascript.\n+\n+Do not use slashes to wrap regular expressions outside of a GREL expression.\n+\n+The [GREL functions](#grel-general-refine-expression-language) that support regex are:\n+*   replace\n+*   match\n+*   partition\n+*   rpartition\n+*   split\n+\n+#### Jython-supported regex\n+\n+You can also use [regex with Jython expressions](http://www.jython.org/docs/library/re.html), instead of GREL, for example with a Custom Text Facet: \n+\n+```\n+python import re g = re.search(ur\"\\u2014 (.*),\\s*BWV\", value) return g.group(1)\n+```\n+\n+#### Clojure-supported regex\n+\n+[Clojure](https://clojure.org/reference/reader) uses the same regex engine as Java, and can be invoked with [re-find](http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/re-find), [re-matches](http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/re-matches), etc. You can use the #\"pattern\" reader macro as described [in the Clojure documentation](https://clojure.org/reference/other_functions#regex). For example, to get the nth element of a returned sequence, you can use the nth function:\n+\n+```\n+clojure (nth (re-find #\"\\u2014 (.*),\\s*BWV\" value) 1)\n+```\n+\n+## Variables\n+\n+Most of the OpenRefine-specific variables have attributes: aspects of the variables that can be called separately. We call these attributes \"member fields\" because they belong to certain variables. For example, you can query a record to find out how many rows it contains with `row.record.rowCount`: `rowCount` is a member field specific to `record`, which is a member field of `row`. Member fields can be called using a dot separator, or with square brackets (`row[\"record\"]`).\n+\n+|Variable |Meaning |\n+|-|-|\n+| value | The value of the cell in the current column of the current row (can be null) |\n+| row | The current row |\n+| row.record | One or more rows grouped together to form a record |\n+| cells | The cells of the current row, with fields that correspond to the column names (or row.cells) |\n+| cell | The cell in the current column of the current row, containing value and other attributes |\n+| cell.recon | The cell's reconciliation information returned from a reconciliation service or provider |\n+| rowIndex | The index value of the current row (the first row is 0) |\n+\n+### Row\n+\n+The `row` variable itself is best used to access its member fields, which you can do using either a dot operator or square brackets: `row.index` or `row[\"index\"]`.\n+\n+|Field |Meaning |\n+|-|-|\n+| row.index | The index value of the current row (the first row is 0) |\n+| row.cells | The cells of the row, returned as an array |\n+| row.columnNames | An array of the column names of the row, i.e. the column names in the project. This will report all columns, even those with null cell values in the particular row. |\n+| row.starred | A boolean indicating if the row is starred |\n+| row.flagged | A boolean indicating if the row is flagged |\n+| row.record | The [record](#record) object containing the current row |\n+\n+For array objects such as `row.columnNames` you can preview the array using the expressions window, and output it as a string using `toString(row.columnNames)` or with something like:\n+\n+```forEach(row.columnNames,v,v).join(\"; \")```\n+\n+### Cells\n+\n+The `cells` object is used to call information from the columns in your project. For example, `cells.Foo` returns a [cell](#cell) object representing the cell in the column named \u201cFoo\u201d of the current row. If the column name has spaces, use square brackets, e.g., `cells[\"Postal Code\"]`. There is no `cells.value` - it can only be used with member fields. To get the corresponding column value inside the `cells` variable, use `.value` at the end, for example `cells[\"Postal Code\"].value`. \n+\n+### Cell\n+\n+A `cell` object contains all the data of a cell and is stored as a single object that has two fields.\n+\n+You can use `cell` on its own in the expressions editor to copy all the contents of a column to another column, including reconciliation information. Although the preview in the expressions editor will only show a small representation [object Cell], it will actually copy all the cell's data. Try this with <span class=\"menuItems\">Edit Column</span> \u2192 <span class=\"menuItems\">Add Column based on this column ...</span>.\n+\n+|Field |Meaning |Member fields |\n+|-|-|-|\n+| cell | An object containing the entire contents of the cell | .value, .recon, .errorMessage |\n+| cell.value | The value in the cell, which can be a string, a number, a boolean, null, or an error |  |\n+| cell.recon | An object encapsulating reconciliation results for that cell | See the reconciliation section below |\n+| cell.errorMessage | Returns the message of an *EvalError* instead of the error object itself (use value to return the error object) | .value |\n+\n+### Reconciliation\n \n+Several of the fields here are equivalent to what can be used through [reconciliation facets](reconciling#reconciliation-facets). You must type `cell.recon`; `recon` on its own will not work.\n \n-*   Tipbox for regexp basics - link to a good guide\n-*   Expression Editor \n-    *   Where to find it\n+|Field|Meaning |Member fields |\n+|-|-|-|\n+| cell.recon.judgment | A string, either \"matched\", \"new\", \"none\" |  |\n+| cell.recon.judgmentAction | A string, either \"single\" or \"similar\" (or \"unknown\") |  |\n+| cell.recon.judgmentHistory | A number, the epoch timestamp (in milliseconds) of your judgment  |  |\n+| cell.recon.matched | A boolean, true if judgment is \"matched\" |  |\n+| cell.recon.match | The recon candidate that has been matched against this cell (or null) | .id, .name, .type |\n+| cell.recon.best | The highest scoring recon candidate from the reconciliation service (or null) | .id, .name, .type, .score |\n+| cell.recon.features | An array of reconciliation features to help you assess the accuracy of your matches | .typeMatch, .nameMatch, .nameLevenshtein, .nameWordDistance | \n+| cell.recon.features<br />.typeMatch  | A boolean, true if your chosen type is \"matched\" and false if not (or \"(no type)\" if unreconciled) |  |\n+| cell.recon.features<br />.nameMatch | A boolean, true if the cell and candidate strings are identical and false if not (or \"(unreconciled)\") |  |\n+| cell.recon.features<br />.nameLevenshtein | A number, representing the [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance): larger if the difference is greater between value and candidate |  | \n+| cell.recon.features<br />.nameWordDistance | A number, based on the [word similarity](reconciling#reconciliation-facets) |  |\n+| cell.recon.candidates | An array of the top 3 candidates (default) | .id, .name, .type, .score |\n \n+The `cell.recon.candidates` and `cell.recon.best` objects have a few deeper fields: `id`, `name`, `type`, and `score`. `type` is an array of type identifiers for a list of candidates, or a single string for the best candidate. \n+\n+Arrays such as `cell.recon.candidates` and `cell.recon.candidates.type` can be joined into lists and stored as strings with something like:\n+```\n+forEach(cell.recon.candidates,v,v.name).join(\"; \")\n+```\n+\n+### Record\n+\n+A `row.record` object encapsulates one or more rows that are grouped together, when your project is in records mode. You must call it as `row.record`; `record` will not return values. \n+\n+|Field|Meaning |\n+|-|-|\n+| row.record.index | The index of the current record (starting at 0) |\n+| row.record.cells | The cells of the row |\n+| row.record.fromRowIndex | The row index of the first row in the record |\n+| row.record.toRowIndex | The row index of the last row in the record + 1 (i.e. the next row) |\n+| row.record.rowCount | count of the number of rows in the record |\n \n ## GREL (General Refine Expression Language)\n \n+### Basics\n+\n+GREL is designed to resemble Javascript. Formulas use variables and depend on data types to do things like string manipulation or mathematical calculations:\n+\n+|Example|Output|\n+|---|---|\n+| value + \" (approved)\" | Concatenate two strings; whatever is in the cell gets converted to a string first |\n+| value + 2.239    | Add 2.239 to the existing value (if a number); append text \"2.239\" to the end of the string otherwise |\n+| value.trim().length() &nbsp; &nbsp; | Trim leading and trailing whitespace of the cell value and then output the length of the result |\n+| value.substring(7, 10) | Output the substring of the value from character index 7, 8, and 9 (excluding character index 10) |\n+| value.substring(13) | Output the substring from index 13 to the end of the string |\n+\n+If you're used to Excel, note that the operator for string concatenation is + (not &). Evaluating conditions uses symbols such as <, >, *, /, etc. To check whether two objects are equal, use two equal signs (`value==\"true\"`).\n+\n+### Syntax\n+\n+In OpenRefine expression language function can use either of these two forms:\n+*   functionName(arg0, arg1, ...)\n+*   arg0.functionName(arg1, ...)\n+\n+The second form is a shorthand to make expressions easier to read. It simply pulls the first argument out and appends it to the front of the function, with a dot:\n+\n+|Dot notation |Full notation |\n+|-|-|\n+| value.trim().length() | length(trim(value)) |\n+| value.substring(7, 10) | substring(value, 7, 10) |\n+\n+So, in the dot shorthand, the functions occur from left to right in the order of calling, rather than in the reverse order with parentheses.\n+\n+The dot notation can also be used to access the member fields of [variables](#variables). For referring to column names that contain spaces (anything not a continuous string), use square brackets instead of dot notation:\n+\n+|Example |Description |\n+|-|-|\n+| FirstName.cells | Access the cell in the column named \u201cFirstName\u201d of the current row |\n+| cells[\"First Name\"] | Access the cell in the column called \u201cFirst Name\u201d of the current row |\n+\n+Brackets can also be used to get substrings and sub-arrays, and single items from arrays:\n+\n+|Example |Description |\n+|-|-|\n+| value[1,3] | A substring of value, starting from character 1 up to but excluding character 3 |\n+| \"internationalization\"[1,-2] | Will return \u201cnternationalizati\u201d (negative indexes are counted from the end) |\n+|row.columnNames[5]| Will return the name of the fifth column |\n+\n+Any function that outputs an array can use square brackets to select only one part of the array to output as a string (remember that the index of the items in an array starts with 0). For example, partition() would normally output an array of three items: the part before your chosen fragment, the fragment you've identified, and the part after. Selecting the third part with \"internationalization\".partition(\"nation\")[2] will output \u201calization\u201d (and so will [-1], indicating the final item in the array).\n+\n+### Controls\n+\n+GREL offers controls to support branching and looping (that is, \u201cif\u201d and \u201cfor\u201d functions), but unlike functions, their arguments don't all get evaluated before they get run. A control can decide which part of the code to execute and can affect the environment bindings. Functions, on the other hand, can't do either. Each control decides which of their arguments to evaluate to value, and how.\n+\n+Please note that the GREL control names are case-sensitive: for example, the isError() control can't be called with iserror().\n+\n+#### if(e, expression eTrue, expression eFalse)\n+\n+Expression o is evaluated to a value. If that value is true, then expression eTrue is evaluated and the result is the value of the whole `if` expression. Otherwise, expression eFalse is evaluated and that result is the value.\n+\n+Examples:\n+\n+| Example expression                                                           \t| Result   \t|\n+| ------------------------------------------------------------------------ | ------------ |\n+| `if(\"internationalization\".length() > 10, \"big string\", \"small string\")` | big string |\n+| `if(mod(37, 2) == 0, \"even\", \"odd\")`                                 \t| odd    \t|\n+\n+Nested if (switch case) example:\n+\n+\tif(value == 'Place', 'http://www.example.com/Location',\n+\n+\t \tif(value == 'Person', 'http://www.example.com/Agent',\n+\n+\t  \tif(value == 'Book', 'http://www.example.com/Publication',\n+\n+\tnull)))\n \n+#### with(e1, variable v, e2)\n \n-*   Variables and attributes\n-*   Syntax and controls\n-*   String functions\n-*   Array functions\n-*   Date functions\n-*   Project functions\n-*   Math functions\n+Evaluates expression e1 and binds its value to variable v. Then evaluates expression e2 and returns that result.\n \n-_Content from_\n+| Example expression                                                                       \t| Result \t|\n+| ------------------------------------------------------------------------------------ | ---------- |\n+| `with(\"european union\".split(\" \"), a, a.length())`                               \t| 2   \t|\n+| `with(\"european union\".split(\" \"), a, forEach(a, v, v.length()))`                \t| [ 8, 5 ] |\n+| `with(\"european union\".split(\" \"), a, forEach(a, v, v.length()).sum() / a.length())` | 6.5  \t|\n \n-[https://github.com/OpenRefine/OpenRefine/wiki/General-Refine-Expression-Language](https://github.com/OpenRefine/OpenRefine/wiki/General-Refine-Expression-Language) \n+#### filter(e1, variable v, e test)\n \n-[https://github.com/OpenRefine/OpenRefine/wiki/GREL-Functions](https://github.com/OpenRefine/OpenRefine/wiki/GREL-Functions) \n+Evaluates expression e1 to an array. Then for each array element, binds its value to variable v, evaluates expression test - which should return a boolean. If the boolean is true, pushes v onto the result array.\n \n-[https://github.com/OpenRefine/OpenRefine/wiki/GREL-Other-Functions](https://github.com/OpenRefine/OpenRefine/wiki/GREL-Other-Functions) \n+| Expression                                 \t| Result    \t|\n+| ---------------------------------------------- | ------------- |\n+| `filter([ 3, 4, 8, 7, 9 ], v, mod(v, 2) == 1)` | [ 3, 7, 9 ] |\n \n-etc.\n+#### forEach(e1, variable v, e2)\n \n+Evaluates expression e1 to an array. Then for each array element, binds its value to variable v, evaluates expression e2, and pushes the result onto the result array.\n+\n+| Expression                             \t| Result          \t|\n+| ------------------------------------------ | ------------------- |\n+| `forEach([ 3, 4, 8, 7, 9 ], v, mod(v, 2))` | [ 1, 0, 0, 1, 1 ] |\n+\n+#### forEachIndex(e1, variable i, variable v, e2)\n+\n+Evaluates expression e1 to an array. Then for each array element, binds its index to variable i and its value to variable v, evaluates expression e2, and pushes the result onto the result array.\n+\n+| Expression                                                                  \t| Result                  \t|\n+| ------------------------------------------------------------------------------- | --------------------------- |\n+| `forEachIndex([ \"anne\", \"ben\", \"cindy\" ], i, v, (i + 1) + \". \" + v).join(\", \")` | 1. anne, 2. ben, 3. cindy |\n+\n+#### forRange(n from, n to, n step, variable v, e)\n+\n+Iterates over the variable v starting at from, incrementing by step each time while less than to. At each iteration, evaluates expression e, and pushes the result onto the result array.\n+\n+#### forNonBlank(e, variable v, expression eNonBlank, expression eBlank)\n+\n+Evaluates expression e. If it is non-blank, forNonBlank() binds its value to variable v, evaluates expression eNonBlank and returns the result. Otherwise (if o evaluates to blank), forNonBlank() evaluates expression eBlank and returns that result instead.\n+\n+Unlike other GREL functions beginning with \"for\", forNonBlank() is not iterative. forNonBlank() essentially offers a shorter syntax to achieving the same outcome by using the isNonBlank() function within an \"if\" statement.\n+\n+#### isBlank(e), isNonBlank(e), isNull(e), isNotNull(e), isNumeric(e), isError(e)\n+\n+Evaluates the expression e, and returns a boolean based on the named evaluation.\n+\n+Examples:\n+\n+| Expression      \t| Result  |\n+| ------------------- | ------- |\n+| `isBlank(\"abc\")`\t| false |\n+| `isNonBlank(\"abc\")` | true |\n+| `isNull(\"abc\")` \t| false |\n+| `isNotNull(\"abc\")`\t| true |\n+| `isNumeric(2)`  \t| true  |\n+| `isError(1)`    \t| false |\n+| `isError(\"abc\")`\t| false |\n+| `isError(1 / 0)`\t| true  |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90515aebbd3e961a921bcd972eafc82a2a568af"}, "originalPosition": 358}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyOTgxODc3OnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwOTo0Njo1MFrOH6TiZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNDo1NzoyN1rOH6exgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg5OTU1OA==", "bodyText": "I think the end of the second sentence here should be \"true if it hasn't\"?", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r530899558", "createdAt": "2020-11-26T09:46:50Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,547 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator string (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \u201casdfsd\u201d into a date or a number, but you can convert the number \u201c123\u201d into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \u201cnull\u201d.\n+\n+### Testing string characteristics\n+\n+###### startsWith(s, sub)\n+\n+Returns a boolean indicating whether s starts with sub. For example, `\"food\".startsWith(\"foo\")` returns true, whereas `\"food\".startsWith(\"bar\")` returns false. \n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\"food\".endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase: a capital letter starting each word, and the rest of the letters lowercase. For example, `\"Once upon a midnight DREARY\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string \u201chard\u201d.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(0, -1)` returns the string \u201cprofoun\u201d.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \u201ca\u201d).\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"T\u00e9xt th\u00e1t was opt\u00edc\u00e1lly rec\u00f3gn\u00edz\u00e9d\".replaceChars(\"\u00e1\u00e9\u00ed\u00f3\u00fa\", \"aeiou\")` returns the string \u201cText that was optically recognized\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### find(s, sub or p)\n+\n+Outputs an array of all consecutive substrings inside string s that match the substring or [regex](#grel-supported-regex) pattern p. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in the array [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a sub instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \"fine is\" ].\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, outputs an array of all [capturing groups](https://www.regular-expressions.info/brackets.html) (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [ \"3480\" ]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to store it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to escape characters and use parentheses as needed. Parentheses are required to denote a desired substring (capturing group); for example, \u201c.&#42;(\\d\\d\\d\\d)\u201d would return an array containing a single value, while \u201c(.&#42;)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the value is \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|`value.match(/\\d{6}/)` |null (does not match the full string)|\n+|`value.match(/.*\\d{6}.*/)` |[ ] (no indicated substring)|\n+|`value.match(/.*(\\d{6}).*/)` |[ \"123456\" ] (array with one value)|\n+|`value.match(/(.*)(\\d{6})(.*)/)` |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+### String parsing and splitting\n+\n+###### toNumber(s)\n+\n+Returns a string converted to a number. Will attempt to convert other formats into a string, then into a number. If the value is already a number, it will return the number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by sep. The separator can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\", \" air\" ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ \"inter\", \"nation\", \"ali\" ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\"HenryCTaylor\".splitByCharType()` will result in an array of [ \"H\", \"enry\", \"CT\", \"aylor\" ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ \"BE\", \"1\", \"A\", \"3\", \"E\" ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ \"inter\", \"nation\", \"alization\" ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ \"par\", \"a\", \"llel\" ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1, s2, s timeUnit (optional))\n+\n+Takes two strings and compares them, returning a string. Returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". Also works with dates; see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. \n+\n+###### md5(o)\n+\n+Returns the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of an object. If fed something other than a string (array, number, date, etc.), md5() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".md5()` will return 2c55a1626e31b4e373ceedaa9adc12a3.\n+\n+###### sha1(o)\n+\n+Returns the [SHA-1 hash](https://en.wikipedia.org/wiki/SHA-1) of an object. If fed something other than a string (array, number, date, etc.), sha1() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".sha1()` will return cd05286ee0ff8a830dbdc0c24f1cb68b83b0ef36.\n+\n+###### phonetic(s, s encoding)\n+\n+Returns a phonetic encoding of a string, based on an available phonetic algorithm. See the [section on phonetic clustering](cellediting#clustering-methods) for more information. Can be one of the following supported phonetic methods: [metaphone, doublemetaphone, metaphone3](https://www.wikipedia.org/wiki/Metaphone), [soundex](https://en.wikipedia.org/wiki/Soundex), [cologne](https://en.wikipedia.org/wiki/Cologne_phonetics). Quotes are required around your encoding method. For example, `\"Ruth Prawer Jhabvala\".phonetic(\"metaphone\")` outputs the string \u201cR0PRWRJHBFL\u201d.  \n+\n+###### reinterpret(s, s encoder)\n+\n+Returns s reinterpreted through the given character encoder. You must supply one of the [supported encodings](http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html). Note that quotes are required around your character encoder.\n+\n+When an OpenRefine project is started, data is imported and interpreted. A specific character encoding is identified or manually selected at that time (such as UTF-8). You can reinterpret a column into another specificed encoding using this function. This function may not fix your data; it may be better to use this in conjunction with new projects to test the interpretation, and pre-format your data as needed. \n+\n+###### fingerprint(s)\n+\n+Returns the fingerprint of s, a string that is the first step in [fingerprint clustering methods](cellediting#clustering-methods): it will trim whitespaces, convert all characters to lowercase, remove punctuation, sort words alphabetically, etc. For example, `\"Ruth  Prawer    Jhabvala\".fingerprint()` outputs the string \u201cjhabvala prawer ruth\u201d.\n+\n+###### ngram(s, n)\n+\n+Returns an array of the word n-grams of s. That is, it lists all the possible consecutive combinations of n words in the string. For example, `\"Ruth Prawer Jhabvala\".ngram(2)` would output the array [ \"Ruth Prawer\", \"Prawer Jhabvala\" ]. A word n-gram of 1 simply lists all the words in original order; an n-gram larger than the number of words in the string will only return the original string inside an array (e.g. `\"Ruth Prawer Jhabvala\".ngram(4)` would simply return [\"Ruth Prawer Jhabvala\"]).\n+\n+###### ngramFingerprint(s, n)\n+\n+Returns the [n-gram fingerprint](cellediting#clustering-methods) of s. For example, `\"banana\".ngram(2)` would output \u201canbana\u201d, after first generating the 2-grams \u201cba an na an na\u201d, removing duplicates, and sorting them alphabetically.\n+\n+###### unicode(s)\n+\n+Returns an array of strings describing each character of s in their full unicode notation. For example, `\"Bernice Rubens\".unicode()` outputs [ 66, 101, 114, 110, 105, 99, 101, 32, 82, 117, 98, 101, 110, 115 ].\n+\n+###### unicodeType(s)\n+\n+Returns an array of strings describing each character of s by their unicode type. For example, `\"Bernice Rubens\".unicodeType()` outputs [ \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"space separator\", \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\" ].\n+\n+## Format-based functions (JSON, HTML, XML)\n+\n+###### jsonize(o)\n+\n+Quotes a value as a JSON literal value.\n+\n+###### parseJson(s)\n+\n+Parses a string as JSON. get() can then be used with parseJson(): for example, `parseJson(\" { 'a' : 1 } \").get(\"a\")` returns 1.\n+\n+For example from the following JSON array, let's get all instances called \u201ckeywords\u201d having the same object string name of \u201ctext\u201d, and combine it with the forEach() function to iterate over the array.\n+\n+    {\n+       \"status\":\"OK\",\n+       \"url\":\"\",\n+       \"language\":\"english\",\n+       \"keywords\":[\n+          {\n+             \"text\":\"York en route\",\n+             \"relevance\":\"0.974363\"\n+          },\n+          {\n+             \"text\":\"Anthony Eden\",\n+             \"relevance\":\"0.814394\"\n+          },\n+          {\n+             \"text\":\"President Eisenhower\",\n+             \"relevance\":\"0.700189\"\n+          }\n+       ]\n+    }\n+\n+The GREL expression `forEach(value.parseJson().keywords,v,v.text).join(\":::\")` will output \u201cYork en route:::Anthony Eden:::President Eisenhower\u201d.\n+\n+### Jsoup XML and HTML parsing\n+\n+###### parseHtml(s)\n+Given a cell full of HTML-formatted text, simplifies HTML tags (such as by removing \u201c /\u201d at the end of self-closing tags), closes any unclosed tags, and inserts linebreaks and indents for cleaner code. You cannot pass parseHtml() a URL, but you can pre-fetch HTML with the <span class=\"menuItems\">Add column by fetching URLs</span> menu option. A cell cannot store the output of parseHtml() unless you convert it with toString(). \n+\n+When parseHtml() simplifies HTML, it can sometimes introduce errors. When closing tags, it makes its best guesses based on line breaks, indentation, and the presence of other tags. You may need to manually check the results. \n+\n+You can then extract or select() which portions of the HTML document you need for further splitting, partitioning, etc. An example of extracting all table rows from a div using parseHtml().select() together is described more in depth at [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+###### parseXml(s)\n+Given a cell full of XML-formatted text, returns a full XML document and adds any missing closing tags. You can then extract or select() which portions of the XML document you need for further splitting, partitioning, etc. Functions the same way as parseHtml() is described above. \n+\n+###### select(s, element)\n+Returns an array of all the desired elements from an HTML or XML document, if the element exists. Elements are identified using the [Jsoup selector syntax](https://jsoup.org/apidocs/org/jsoup/select/Selector.html). For example, `value.parseHtml().select(\"img.portrait\")[0]` would return the entirety of the first \u201cimg\u201d tag with the \u201cportrait\u201d class found in the parsed HTML inside `value`. Returns an empty array if no matching element is found. Use with toString() to capture the results in a cell. A tutorial of select() is shown in [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+You can use select() more than once:\n+\n+```\n+value.parseHtml().select(\"div#content\")[0].select(\"tr\").toString()\n+```\n+\n+###### htmlAttr(s, element)\n+Returns a string from an attribute on an HTML element. Use it in conjunction with parseHtml() as in the following example: `value.parseHtml().select(\"a.email\")[0].htmlAttr(\"href\")`.\n+\n+###### xmlAttr(s, element)\n+Returns a string from an attribute on an XML element. Function the same way htmlAttr() is described above. Use it in conjunction with parseXml().\n+\n+###### htmlText(element)\n+Returns a string of the text from within an HTML element (including all child elements), removing HTML tags and line breaks inside the string. Use it in conjunction with parseHtml() and select() to provide an element, as in the following example: `value.parseHtml().select(\"div.footer\")[0].htmlText()`. \n+\n+###### xmlText(element)\n+Returns a string of the text from within an XML element (including all child elements). Functions the same way as htmlText() is described above. Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### wholeText(element)\n+\n+_Works from OpenRefine 3.4.1 beta 644 onwards only_\n+\n+Selects the (unencoded) text of an element and its children, including any newlines and spaces, and returns a string of unencoded, un-normalized text. Use it in conjunction with parseHtml() and select() to provide an element as in the following example: `value.parseHtml().select(\"div.footer\")[0].wholeText()`.\n+\n+###### innerHtml(element)\n+Returns the [inner HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) of an HTML element. This will include text and children elements within the element selected. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### innerXml(element)\n+Returns all the inner XML elements inside your chosen XML element. Does not return the text directly inside your chosen XML element - only the contents of its children. To select the direct text, use ownText(). To select both, use xmlText(). Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### outerHtml(element)\n+Returns the [outer HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/outerHTML) of an HTML element. outerHtml includes the start and end tags of the current element. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### ownText(element)\n+Returns the text directly inside the selected XML or HTML element only, ignoring text inside children elements. Use it in conjunction with a parser and select() to provide an element.\n+\n+## Array functions\n+\n+###### length(a)\n+Returns the size of an array, meaning the number of objects inside it. Arrays can be empty, in which case length() will return 0. \n+\n+###### slice(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. If to is omitted, it is understood to be the end of the array. For example, `[0, 1, 2, 3, 4].slice(1, 3)` returns [ 1, 2 ], and `[ 0, 1, 2, 3, 4].slice(1)` returns [ 1, 2, 3, 4 ]. Also works with strings; see [String functions](#slices-n-from-n-to-optional).\n+\n+###### get(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. \n+\n+If to is omitted, only one array item is returned, as a string, instead of a sub-array. To return a sub-array from one index to the end, you can set the to argument to a very high number such as `value.get(2,999)` or you can use something like `with(value,a,a.get(1,a.length()))` to count the length of each array.\n+\n+Also works with strings; see [get() in String functions](#gets-n-from-n-to-optional).\n+\n+###### inArray(a, s)\n+Returns true if the array contains the desired string, and false otherwise.\n+\n+###### reverse(a)\n+Reverses the array. For example, `[ 0, 1, 2, 3].reverse()` returns the array [ 3, 2, 1, 0 ].\n+\n+###### sort(a)\n+Sorts the array in ascending order. Sorting is case-sensitive, uppercase first and lowercase second. For example, `[ \"al\", \"Joe\", \"Bob\", \"jim\" ].sort()` returns the array [ \"Bob\", \"Joe\", \"al\", \"jim\" ]. \n+\n+###### sum(a)\n+Return the sum of the numbers in the array. For example, `[ 2, 1, 0, 3].sum()` returns 6.\n+\n+###### join(a, sep)\n+Joins the items in the array with sep, and returns it all as a string. For example, `[ \"and\", \"or\", \"not\" ].join(\"/\")` returns the string \u201cand/or/not\u201d.\n+\n+###### uniques(a)\n+Returns the array with duplicates removed. Case-sensitive. For example, `[ \"al\", \"Joe\", \"Bob\", \"Joe\", \"Al\", \"Bob\" ].uniques()` returns the array [ \"Joe\", \"al\", \"Al\", \"Bob\" ]. \n+\n+As of OpenRefine 3.4.1, uniques() reorders the array items it returns; in 3.4 beta 644 and onwards, it preserves the original order (in this case, [ \"al\", \"Joe\", \"Bob\", \"Al\" ]). \n+\n+## Date functions\n+If you have a column full of dates in a more common format (such as yyyy/mm/dd or YYYYMMDD) you can convert these using [\u201cTransform\u201d > \u201cCommon transforms \u2026\u201d > \u201cto date\u201d](cellediting#data-type-transforms), or the GREL function toDate(). You may wish to create a new column with the transformation, in order to also preserve the more human-readable version.\n+\n+OpenRefine uses [Date.parse()](https://www.w3schools.com/jsref/jsref_parse.asp) to recognize a variety of formats and convert them, including converting from other time zones to UTC:\n+\n+![A screenshot of different date formats being converted, and one error.](/img/dates.png)\n+\n+You may need to do some reformatting if your dates are not being recognized by the toDate() function. For example, in the image above, the date that includes \u201c7AM\u201d is giving an error message, but the ones with \u201c2:42 PM\u201d and \u201c3:22PM\u201d are being converted.\n+\n+###### now()\n+\n+Returns the current time in the [ISO 8601 extended format](exploring#data-types). For example, 12:58pm on October 28th 2020 returns [date 2020-10-28T16:58:32Z].\n+\n+###### toDate(o, b monthFirst, s format1, s format2, ...)\n+\n+Returns the inputted object converted to a date object. Without arguments, it returns the ISO 8601 extended format. With arguments, you can control the output format:\n+*   monthFirst: set false if the date is formatted with the day before the month.\n+*   formatN: attempt to parse the date using an ordered list of possible formats. Supply formats based on the [SimpleDateFormat](https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html) syntax (and see the table below for a handy reference). \n+\n+For example, you can parse a column containing dates in different formats, such as cells with \u201cNov-09\u201d and \u201c11/09\u201d, using `value.toDate('MM/yy','MMM-yy').toString('yyyy-MM')` and both will output \u201c2009-11\u201d. For another example, \u201c1/4/2012 13:30:00\u201d can be parsed into a date using `value.toDate('d/M/y H&#58;m&#58;s')`.\n+\n+| Letter | Date or Time Component | Presentation | Examples |\n+|-|-|-|-|\n+| G | Era designator | Text | AD |\n+| y | Year | Year | 1996; 96 |\n+| Y | [Week year](https://en.wikipedia.org/wiki/ISO_week_date#First_week) | Year | 2009; 09 |\n+| M | Month in year | Month | July; Jul; 07 |\n+| w | Week in year | Number | 27 |\n+| W | Week in month | Number | 2 |\n+| D | Day in year | Number | 189 |\n+| d | Day in month | Number | 10 |\n+| F | Day of week in month | Number | 2 |\n+| E | Day name in week | Text | Tuesday; Tue |\n+| u | Day number of week (1 = Monday, ..., 7 = Sunday) | Number | 1 |\n+| a | AM/PM marker | Text | PM |\n+| H | Hour in day (0-23) | Number | 0 |\n+| k | Hour in day (1-24) | Number | 24 |\n+| K | Hour in AM/PM (0-11) | Number | 0 |\n+| h | Hour in AM/PM (1-12) | Number | 12 |\n+| m | Minute in hour | Number | 30 |\n+| s | Second in minute | Number | 55 |\n+| S | Millisecond | Number | 978 |\n+| n | Nanosecond | Number | 789000 |\n+| z | Time zone | General time zone | Pacific Standard Time; PST; GMT-08:00 |\n+| Z | Time zone | RFC 822 time zone | \\-0800 |\n+| X | Time zone | ISO 8601 time zone | \\-08; -0800; -08:00 |\n+\n+###### diff(d1, d2, s timeUnit)\n+\n+Given two dates, returns a number indicating the difference in a given time unit (see the table below). For example, `diff((\"Nov-11\".toDate('MMM-yy')), (\"Nov-09\".toDate('MMM-yy')), \"weeks\")` will return 104, for 104 weeks, or two years. The later date should go first. If the output is negative, invert d1 and d2.\n+\n+Also works with strings; see [diff() in string functions](#diffsd1-sd2-s-timeunit-optional).\n+\n+###### inc(d, n, s timeUnit)\n+\n+Returns a date changed by the given amount in the given unit of time (see the table below). The default unit is \u201chour\u201d. For example, if you want to move a date backwards by two months, use `value.inc(-2,'month')`.\n+\n+###### datePart(d, s timeUnit)\n+\n+Returns part of a date. Data type returned depends on the unit (see the table below). \n+\n+OpenRefine supports the following values for timeUnit:\n+\n+| Unit | Date part returned | Returned data type | Example using [date 2014-03-14T05:30:04.000789000Z] as value |\n+|-|-|-|-|\n+| years | Year | Number | value.datePart(\"years\") -> 2014 |\n+| year | Year | Number | value.datePart(\"year\") -> 2014 |\n+| months | Month | Number | value.datePart(\"months\") -> 2 |\n+| month | Month | Number | value.datePart(\"month\") -> 2 |\n+| weeks | Week of the month | Number | value.datePart(\"weeks\") -> 3 |\n+| week | Week of the month | Number | value.datePart(\"week\") -> 3 |\n+| w | Week of the month | Number | value.datePart(\"w\") -> 3 |\n+| weekday | Day of the week | String | value.datePart(\"weekday\") -> Friday |\n+| hours | Hour | Number | value.datePart(\"hours\") -> 5 |\n+| hour | Hour | Number | value.datePart(\"hour\") -> 5 |\n+| h | Hour | Number | value.datePart(\"h\") -> 5 |\n+| minutes | Minute | Number | value.datePart(\"minutes\") -> 30 |\n+| minute | Minute | Number | value.datePart(\"minute\") -> 30 |\n+| min | Minute | Number | value.datePart(\"min\") -> 30 |\n+| seconds | Seconds | Number | value.datePart(\"seconds\") -> 04 |\n+| sec | Seconds | Number | value.datePart(\"sec\") -> 04 |\n+| s | Seconds | Number | value.datePart(\"s\") -> 04 |\n+| milliseconds | Millseconds | Number | value.datePart(\"milliseconds\") -> 789 |\n+| ms | Millseconds | Number | value.datePart(\"ms\") -> 789 |\n+| S | Millseconds | Number | value.datePart(\"S\") -> 789 |\n+| n | Nanoseconds | Number | value.datePart(\"n\") -> 789000 |\n+| nano | Nanoseconds | Number | value.datePart(\"n\") -> 789000 |\n+| nanos | Nanoseconds | Number | value.datePart(\"n\") -> 789000 |\n+| time | Date expressed as milliseconds since the Unix Epoch | Number | value.datePart(\"time\") -> 1394775004000 |\n+\n+## Math functions\n+\n+For integer division and precision, you can use simple evaluations such as `1 / 2`, which is equivalent to `floor(1/2)` - that is, it returns only whole number results. If either operand is a floating point number, they both get promoted to floating point and a floating point result is returned. You can use `1 / 2.0` or `1.0 / 2` or `1.0 * x / y` (if you're working with variables of unknown contents).\n+\n+:::caution\n+Some of these math functions don't recognize integers when supplied as the first argument in dot notation (e.g., `5.cos()` simply returns 5 instead of the expected result). To ensure operations are successful, always wrap the first argument in brackets, such as `(value).cos()`.\n+:::\n+\n+|Function|Use|Example|\n+|-|-|-|\n+|`abs(n)`|Returns the absolute value of a number.|`abs(-6)` returns 6.|\n+|`acos(n)`|Returns the arc cosine of an angle, in the range 0 through PI.|`acos(0.345)` returns 1.218557541697832.|\n+|`asin(n)`|Returns the arc sine of an angle in the range of -PI/2 through [PI](https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#PI)/2.|`asin(0.345)` returns 0.35223878509706474.|\n+|`atan(n)`|Returns the arc tangent of an angle in the range of -PI/2 through PI/2.|`atan(0.345)` returns 0.3322135507465967.|\n+|`atan2(n1, n2)`|Converts rectangular coordinates (n1, n2) to polar (r, theta). Returns number theta.|`atan2(0.345,0.6)` returns \t0.5218342798144103.|\n+|`ceil(n)`|Returns the ceiling of a number.|`3.7.ceil()` returns 4 and `-3.7.ceil()` returns -3.|\n+|`combin(n1, n2)`|Returns the number of combinations for n2 elements as divided into n1.|`combin(20,2)` returns 190.|\n+|`cos(n)`|Returns the trigonometric cosine of an angle.|`cos(5)` returns 0.28366218546322625.|\n+|`cosh(n)`|Returns the hyperbolic cosine of a value.|`cosh(5)` returns 74.20994852478785.|\n+|`degrees(n)`|Converts an angle from radians to degrees.|`degrees(5)` returns 286.4788975654116.|\n+|`even(n)`|Rounds the number up to the nearest even integer.|`even(5)` returns 6.|\n+|`exp(n)`|Returns [e](https://en.wikipedia.org/wiki/E_(mathematical_constant)) raised to the power of n.|`exp(5)` returns 148.4131591025766.|\n+|`fact(n)`|Returns the factorial of a number, starting from 1.|`fact(5)` returns 120.|\n+|`factn(n1, n2)`|Returns the factorial of n1, starting from n2.|`factn(10,3)` returns 280.|\n+|`floor(n)`|Returns the floor of a number.|`3.7.floor()` returns 3 and `-3.7.floor()` returns -4.|\n+|`gcd(n1, n2)`|Returns the greatest common denominator of the two numbers.|`gcd(95,135)` returns 5.|\n+|`lcm(n1, n2)`|Returns the least common multiple of two numbers.|`lcm(95,135)` returns 2565.|\n+|`ln(n)`|Returns the natural logarithm of n.|`ln(5)` returns 1.6094379124341003.|\n+|`log(n)`|Returns the base 10 logarithm of n.|`log(5)` returns 0.6989700043360189.|\n+|`max(n1, n2)`|Returns the larger of two numbers.|`max(3,10)` returns 10.|\n+|`min(n1, n2)`|Returns the smaller of two numbers.|`min(3,10)` returns 3.|\n+|`mod(n1, n2)`|Returns n1 modulus n2. Note: `value.mod(9)` will work, whereas `74.mod(9)` will not work.|`mod(74, 9)` returns 2. |\n+|`multinomial(n1, n2 \u2026(optional))`|Calculates the multinomial of one number or a series of numbers.|`multinomial(2,3)` returns 10.|\n+|`odd(n)`|Rounds the number up to the nearest odd integer.|`odd(10)` returns 11.|\n+|`pow(n1, n2)`|Returns n1 raised to the power of n2. Note: value.pow(3)` will work, whereas `2.pow(3)` will not work.|`pow(2, 3)` returns 8 (2 cubed) and `pow(3, 2)` returns 9 (3 squared). The square root of any numeric value can be called with `value.pow(0.5)`.|\n+|`quotient(n1, n2)`|Returns the integer portion of a division (truncated, not rounded), when supplied with a numerator and denominator.|`quotient(9,2)` returns 4.|\n+|`radians(n)`|Converts an angle in degrees to radians.|`radians(10)` returns 0.17453292519943295.|\n+|`randomNumber(n lower_bound, n upper_bound)`|Returns a random integer in the interval between the lower and upper bounds (inclusively). Will output a different random number in each cell in a column.|\n+|`round(n)`|Rounds a number to the nearest integer.|`3.7.round()` returns 4 and `-3.7.round()` returns -4.|\n+|`sin(n)`|Returns the trigonometric sine of an angle.|`sin(10)` returns -0.5440211108893698.|\n+|`sinh(n)`|Returns the hyperbolic sine of an angle.|`sinh(10)` returns 11013.232874703393.|\n+|`sum(a)`|Sums the numbers in an array. Ignores non-number items. Returns 0 if the array does not contain numbers.|`sum([ 10, 2, three ])` returns 12.|\n+|`tan(n)`|Returns the trigonometric tangent of an angle.|`tan(10)` returns 0.6483608274590866.|\n+|`tanh(n)`|Returns the hyperbolic tangent of a value.|`tanh(10)` returns 0.9999999958776927.|\n+\n+## Other functions\n+\n+###### type(o)\n+Returns a string with the data type of o, such as undefined, string, number, boolean, etc. For example, a Transform operation using `value.type()` will convert all cells in a column to strings of their data types.\n+\n+###### facetCount(choiceValue, s facetExpression, s columnName)\n+Returns the facet count corresponding to the given choice value, by looking for the facetExpression in the choiceValue in columnName. For example, to create facet counts for the following table, we could generate a new column based on \u201cGift\u201d and enter in `value.facetCount(\"value\", \"Gift\")`. This would add the column we've named \u201cCount\u201d:\n+\n+| Gift | Recipient | Price | Count |\n+|-|-|-|-|\n+| lamp | Mary | 20 | 1 |\n+| clock | John | 57 | 2 |\n+| watch | Amit | 80 | 1 |\n+| clock | Claire | 62 | 2 |\n+\n+The facet expression, wrapped in quotes, can be useful to manipulate the inputted values before counting. For example, you could do a textual cleanup using fingerprint(): `(value.fingerprint()).facetCount(value.fingerprint(),\"Gift\")`.\n+\n+###### hasField(o, s name)\n+Returns a boolean indicating whether o has a member field called name. For example, `cell.recon.hasField(\"match\")` will return false if a reconciliation match hasn\u2019t been selected yet, or true if it does. You cannot chain your desired fields: for example, `cell.hasField(\u201crecon.match\u201d)` will return false even if the above expression returns true).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91b0bca29f37c00090ad5d43d2a78d45a60c5fab"}, "originalPosition": 532}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA4MzY0OA==", "bodyText": "true if it has - has been selected.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r531083648", "createdAt": "2020-11-26T14:57:27Z", "author": {"login": "allanaaa"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,547 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator string (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \u201casdfsd\u201d into a date or a number, but you can convert the number \u201c123\u201d into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \u201cnull\u201d.\n+\n+### Testing string characteristics\n+\n+###### startsWith(s, sub)\n+\n+Returns a boolean indicating whether s starts with sub. For example, `\"food\".startsWith(\"foo\")` returns true, whereas `\"food\".startsWith(\"bar\")` returns false. \n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\"food\".endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase: a capital letter starting each word, and the rest of the letters lowercase. For example, `\"Once upon a midnight DREARY\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string \u201chard\u201d.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(0, -1)` returns the string \u201cprofoun\u201d.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \u201ca\u201d).\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"T\u00e9xt th\u00e1t was opt\u00edc\u00e1lly rec\u00f3gn\u00edz\u00e9d\".replaceChars(\"\u00e1\u00e9\u00ed\u00f3\u00fa\", \"aeiou\")` returns the string \u201cText that was optically recognized\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### find(s, sub or p)\n+\n+Outputs an array of all consecutive substrings inside string s that match the substring or [regex](#grel-supported-regex) pattern p. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in the array [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a sub instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \"fine is\" ].\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, outputs an array of all [capturing groups](https://www.regular-expressions.info/brackets.html) (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [ \"3480\" ]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to store it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to escape characters and use parentheses as needed. Parentheses are required to denote a desired substring (capturing group); for example, \u201c.&#42;(\\d\\d\\d\\d)\u201d would return an array containing a single value, while \u201c(.&#42;)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the value is \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|`value.match(/\\d{6}/)` |null (does not match the full string)|\n+|`value.match(/.*\\d{6}.*/)` |[ ] (no indicated substring)|\n+|`value.match(/.*(\\d{6}).*/)` |[ \"123456\" ] (array with one value)|\n+|`value.match(/(.*)(\\d{6})(.*)/)` |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+### String parsing and splitting\n+\n+###### toNumber(s)\n+\n+Returns a string converted to a number. Will attempt to convert other formats into a string, then into a number. If the value is already a number, it will return the number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by sep. The separator can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\", \" air\" ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ \"inter\", \"nation\", \"ali\" ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\"HenryCTaylor\".splitByCharType()` will result in an array of [ \"H\", \"enry\", \"CT\", \"aylor\" ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ \"BE\", \"1\", \"A\", \"3\", \"E\" ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ \"inter\", \"nation\", \"alization\" ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ \"par\", \"a\", \"llel\" ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1, s2, s timeUnit (optional))\n+\n+Takes two strings and compares them, returning a string. Returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". Also works with dates; see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. \n+\n+###### md5(o)\n+\n+Returns the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of an object. If fed something other than a string (array, number, date, etc.), md5() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".md5()` will return 2c55a1626e31b4e373ceedaa9adc12a3.\n+\n+###### sha1(o)\n+\n+Returns the [SHA-1 hash](https://en.wikipedia.org/wiki/SHA-1) of an object. If fed something other than a string (array, number, date, etc.), sha1() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".sha1()` will return cd05286ee0ff8a830dbdc0c24f1cb68b83b0ef36.\n+\n+###### phonetic(s, s encoding)\n+\n+Returns a phonetic encoding of a string, based on an available phonetic algorithm. See the [section on phonetic clustering](cellediting#clustering-methods) for more information. Can be one of the following supported phonetic methods: [metaphone, doublemetaphone, metaphone3](https://www.wikipedia.org/wiki/Metaphone), [soundex](https://en.wikipedia.org/wiki/Soundex), [cologne](https://en.wikipedia.org/wiki/Cologne_phonetics). Quotes are required around your encoding method. For example, `\"Ruth Prawer Jhabvala\".phonetic(\"metaphone\")` outputs the string \u201cR0PRWRJHBFL\u201d.  \n+\n+###### reinterpret(s, s encoder)\n+\n+Returns s reinterpreted through the given character encoder. You must supply one of the [supported encodings](http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html). Note that quotes are required around your character encoder.\n+\n+When an OpenRefine project is started, data is imported and interpreted. A specific character encoding is identified or manually selected at that time (such as UTF-8). You can reinterpret a column into another specificed encoding using this function. This function may not fix your data; it may be better to use this in conjunction with new projects to test the interpretation, and pre-format your data as needed. \n+\n+###### fingerprint(s)\n+\n+Returns the fingerprint of s, a string that is the first step in [fingerprint clustering methods](cellediting#clustering-methods): it will trim whitespaces, convert all characters to lowercase, remove punctuation, sort words alphabetically, etc. For example, `\"Ruth  Prawer    Jhabvala\".fingerprint()` outputs the string \u201cjhabvala prawer ruth\u201d.\n+\n+###### ngram(s, n)\n+\n+Returns an array of the word n-grams of s. That is, it lists all the possible consecutive combinations of n words in the string. For example, `\"Ruth Prawer Jhabvala\".ngram(2)` would output the array [ \"Ruth Prawer\", \"Prawer Jhabvala\" ]. A word n-gram of 1 simply lists all the words in original order; an n-gram larger than the number of words in the string will only return the original string inside an array (e.g. `\"Ruth Prawer Jhabvala\".ngram(4)` would simply return [\"Ruth Prawer Jhabvala\"]).\n+\n+###### ngramFingerprint(s, n)\n+\n+Returns the [n-gram fingerprint](cellediting#clustering-methods) of s. For example, `\"banana\".ngram(2)` would output \u201canbana\u201d, after first generating the 2-grams \u201cba an na an na\u201d, removing duplicates, and sorting them alphabetically.\n+\n+###### unicode(s)\n+\n+Returns an array of strings describing each character of s in their full unicode notation. For example, `\"Bernice Rubens\".unicode()` outputs [ 66, 101, 114, 110, 105, 99, 101, 32, 82, 117, 98, 101, 110, 115 ].\n+\n+###### unicodeType(s)\n+\n+Returns an array of strings describing each character of s by their unicode type. For example, `\"Bernice Rubens\".unicodeType()` outputs [ \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"space separator\", \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\" ].\n+\n+## Format-based functions (JSON, HTML, XML)\n+\n+###### jsonize(o)\n+\n+Quotes a value as a JSON literal value.\n+\n+###### parseJson(s)\n+\n+Parses a string as JSON. get() can then be used with parseJson(): for example, `parseJson(\" { 'a' : 1 } \").get(\"a\")` returns 1.\n+\n+For example from the following JSON array, let's get all instances called \u201ckeywords\u201d having the same object string name of \u201ctext\u201d, and combine it with the forEach() function to iterate over the array.\n+\n+    {\n+       \"status\":\"OK\",\n+       \"url\":\"\",\n+       \"language\":\"english\",\n+       \"keywords\":[\n+          {\n+             \"text\":\"York en route\",\n+             \"relevance\":\"0.974363\"\n+          },\n+          {\n+             \"text\":\"Anthony Eden\",\n+             \"relevance\":\"0.814394\"\n+          },\n+          {\n+             \"text\":\"President Eisenhower\",\n+             \"relevance\":\"0.700189\"\n+          }\n+       ]\n+    }\n+\n+The GREL expression `forEach(value.parseJson().keywords,v,v.text).join(\":::\")` will output \u201cYork en route:::Anthony Eden:::President Eisenhower\u201d.\n+\n+### Jsoup XML and HTML parsing\n+\n+###### parseHtml(s)\n+Given a cell full of HTML-formatted text, simplifies HTML tags (such as by removing \u201c /\u201d at the end of self-closing tags), closes any unclosed tags, and inserts linebreaks and indents for cleaner code. You cannot pass parseHtml() a URL, but you can pre-fetch HTML with the <span class=\"menuItems\">Add column by fetching URLs</span> menu option. A cell cannot store the output of parseHtml() unless you convert it with toString(). \n+\n+When parseHtml() simplifies HTML, it can sometimes introduce errors. When closing tags, it makes its best guesses based on line breaks, indentation, and the presence of other tags. You may need to manually check the results. \n+\n+You can then extract or select() which portions of the HTML document you need for further splitting, partitioning, etc. An example of extracting all table rows from a div using parseHtml().select() together is described more in depth at [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+###### parseXml(s)\n+Given a cell full of XML-formatted text, returns a full XML document and adds any missing closing tags. You can then extract or select() which portions of the XML document you need for further splitting, partitioning, etc. Functions the same way as parseHtml() is described above. \n+\n+###### select(s, element)\n+Returns an array of all the desired elements from an HTML or XML document, if the element exists. Elements are identified using the [Jsoup selector syntax](https://jsoup.org/apidocs/org/jsoup/select/Selector.html). For example, `value.parseHtml().select(\"img.portrait\")[0]` would return the entirety of the first \u201cimg\u201d tag with the \u201cportrait\u201d class found in the parsed HTML inside `value`. Returns an empty array if no matching element is found. Use with toString() to capture the results in a cell. A tutorial of select() is shown in [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+You can use select() more than once:\n+\n+```\n+value.parseHtml().select(\"div#content\")[0].select(\"tr\").toString()\n+```\n+\n+###### htmlAttr(s, element)\n+Returns a string from an attribute on an HTML element. Use it in conjunction with parseHtml() as in the following example: `value.parseHtml().select(\"a.email\")[0].htmlAttr(\"href\")`.\n+\n+###### xmlAttr(s, element)\n+Returns a string from an attribute on an XML element. Function the same way htmlAttr() is described above. Use it in conjunction with parseXml().\n+\n+###### htmlText(element)\n+Returns a string of the text from within an HTML element (including all child elements), removing HTML tags and line breaks inside the string. Use it in conjunction with parseHtml() and select() to provide an element, as in the following example: `value.parseHtml().select(\"div.footer\")[0].htmlText()`. \n+\n+###### xmlText(element)\n+Returns a string of the text from within an XML element (including all child elements). Functions the same way as htmlText() is described above. Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### wholeText(element)\n+\n+_Works from OpenRefine 3.4.1 beta 644 onwards only_\n+\n+Selects the (unencoded) text of an element and its children, including any newlines and spaces, and returns a string of unencoded, un-normalized text. Use it in conjunction with parseHtml() and select() to provide an element as in the following example: `value.parseHtml().select(\"div.footer\")[0].wholeText()`.\n+\n+###### innerHtml(element)\n+Returns the [inner HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) of an HTML element. This will include text and children elements within the element selected. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### innerXml(element)\n+Returns all the inner XML elements inside your chosen XML element. Does not return the text directly inside your chosen XML element - only the contents of its children. To select the direct text, use ownText(). To select both, use xmlText(). Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### outerHtml(element)\n+Returns the [outer HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/outerHTML) of an HTML element. outerHtml includes the start and end tags of the current element. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### ownText(element)\n+Returns the text directly inside the selected XML or HTML element only, ignoring text inside children elements. Use it in conjunction with a parser and select() to provide an element.\n+\n+## Array functions\n+\n+###### length(a)\n+Returns the size of an array, meaning the number of objects inside it. Arrays can be empty, in which case length() will return 0. \n+\n+###### slice(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. If to is omitted, it is understood to be the end of the array. For example, `[0, 1, 2, 3, 4].slice(1, 3)` returns [ 1, 2 ], and `[ 0, 1, 2, 3, 4].slice(1)` returns [ 1, 2, 3, 4 ]. Also works with strings; see [String functions](#slices-n-from-n-to-optional).\n+\n+###### get(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. \n+\n+If to is omitted, only one array item is returned, as a string, instead of a sub-array. To return a sub-array from one index to the end, you can set the to argument to a very high number such as `value.get(2,999)` or you can use something like `with(value,a,a.get(1,a.length()))` to count the length of each array.\n+\n+Also works with strings; see [get() in String functions](#gets-n-from-n-to-optional).\n+\n+###### inArray(a, s)\n+Returns true if the array contains the desired string, and false otherwise.\n+\n+###### reverse(a)\n+Reverses the array. For example, `[ 0, 1, 2, 3].reverse()` returns the array [ 3, 2, 1, 0 ].\n+\n+###### sort(a)\n+Sorts the array in ascending order. Sorting is case-sensitive, uppercase first and lowercase second. For example, `[ \"al\", \"Joe\", \"Bob\", \"jim\" ].sort()` returns the array [ \"Bob\", \"Joe\", \"al\", \"jim\" ]. \n+\n+###### sum(a)\n+Return the sum of the numbers in the array. For example, `[ 2, 1, 0, 3].sum()` returns 6.\n+\n+###### join(a, sep)\n+Joins the items in the array with sep, and returns it all as a string. For example, `[ \"and\", \"or\", \"not\" ].join(\"/\")` returns the string \u201cand/or/not\u201d.\n+\n+###### uniques(a)\n+Returns the array with duplicates removed. Case-sensitive. For example, `[ \"al\", \"Joe\", \"Bob\", \"Joe\", \"Al\", \"Bob\" ].uniques()` returns the array [ \"Joe\", \"al\", \"Al\", \"Bob\" ]. \n+\n+As of OpenRefine 3.4.1, uniques() reorders the array items it returns; in 3.4 beta 644 and onwards, it preserves the original order (in this case, [ \"al\", \"Joe\", \"Bob\", \"Al\" ]). \n+\n+## Date functions\n+If you have a column full of dates in a more common format (such as yyyy/mm/dd or YYYYMMDD) you can convert these using [\u201cTransform\u201d > \u201cCommon transforms \u2026\u201d > \u201cto date\u201d](cellediting#data-type-transforms), or the GREL function toDate(). You may wish to create a new column with the transformation, in order to also preserve the more human-readable version.\n+\n+OpenRefine uses [Date.parse()](https://www.w3schools.com/jsref/jsref_parse.asp) to recognize a variety of formats and convert them, including converting from other time zones to UTC:\n+\n+![A screenshot of different date formats being converted, and one error.](/img/dates.png)\n+\n+You may need to do some reformatting if your dates are not being recognized by the toDate() function. For example, in the image above, the date that includes \u201c7AM\u201d is giving an error message, but the ones with \u201c2:42 PM\u201d and \u201c3:22PM\u201d are being converted.\n+\n+###### now()\n+\n+Returns the current time in the [ISO 8601 extended format](exploring#data-types). For example, 12:58pm on October 28th 2020 returns [date 2020-10-28T16:58:32Z].\n+\n+###### toDate(o, b monthFirst, s format1, s format2, ...)\n+\n+Returns the inputted object converted to a date object. Without arguments, it returns the ISO 8601 extended format. With arguments, you can control the output format:\n+*   monthFirst: set false if the date is formatted with the day before the month.\n+*   formatN: attempt to parse the date using an ordered list of possible formats. Supply formats based on the [SimpleDateFormat](https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html) syntax (and see the table below for a handy reference). \n+\n+For example, you can parse a column containing dates in different formats, such as cells with \u201cNov-09\u201d and \u201c11/09\u201d, using `value.toDate('MM/yy','MMM-yy').toString('yyyy-MM')` and both will output \u201c2009-11\u201d. For another example, \u201c1/4/2012 13:30:00\u201d can be parsed into a date using `value.toDate('d/M/y H&#58;m&#58;s')`.\n+\n+| Letter | Date or Time Component | Presentation | Examples |\n+|-|-|-|-|\n+| G | Era designator | Text | AD |\n+| y | Year | Year | 1996; 96 |\n+| Y | [Week year](https://en.wikipedia.org/wiki/ISO_week_date#First_week) | Year | 2009; 09 |\n+| M | Month in year | Month | July; Jul; 07 |\n+| w | Week in year | Number | 27 |\n+| W | Week in month | Number | 2 |\n+| D | Day in year | Number | 189 |\n+| d | Day in month | Number | 10 |\n+| F | Day of week in month | Number | 2 |\n+| E | Day name in week | Text | Tuesday; Tue |\n+| u | Day number of week (1 = Monday, ..., 7 = Sunday) | Number | 1 |\n+| a | AM/PM marker | Text | PM |\n+| H | Hour in day (0-23) | Number | 0 |\n+| k | Hour in day (1-24) | Number | 24 |\n+| K | Hour in AM/PM (0-11) | Number | 0 |\n+| h | Hour in AM/PM (1-12) | Number | 12 |\n+| m | Minute in hour | Number | 30 |\n+| s | Second in minute | Number | 55 |\n+| S | Millisecond | Number | 978 |\n+| n | Nanosecond | Number | 789000 |\n+| z | Time zone | General time zone | Pacific Standard Time; PST; GMT-08:00 |\n+| Z | Time zone | RFC 822 time zone | \\-0800 |\n+| X | Time zone | ISO 8601 time zone | \\-08; -0800; -08:00 |\n+\n+###### diff(d1, d2, s timeUnit)\n+\n+Given two dates, returns a number indicating the difference in a given time unit (see the table below). For example, `diff((\"Nov-11\".toDate('MMM-yy')), (\"Nov-09\".toDate('MMM-yy')), \"weeks\")` will return 104, for 104 weeks, or two years. The later date should go first. If the output is negative, invert d1 and d2.\n+\n+Also works with strings; see [diff() in string functions](#diffsd1-sd2-s-timeunit-optional).\n+\n+###### inc(d, n, s timeUnit)\n+\n+Returns a date changed by the given amount in the given unit of time (see the table below). The default unit is \u201chour\u201d. For example, if you want to move a date backwards by two months, use `value.inc(-2,'month')`.\n+\n+###### datePart(d, s timeUnit)\n+\n+Returns part of a date. Data type returned depends on the unit (see the table below). \n+\n+OpenRefine supports the following values for timeUnit:\n+\n+| Unit | Date part returned | Returned data type | Example using [date 2014-03-14T05:30:04.000789000Z] as value |\n+|-|-|-|-|\n+| years | Year | Number | value.datePart(\"years\") -> 2014 |\n+| year | Year | Number | value.datePart(\"year\") -> 2014 |\n+| months | Month | Number | value.datePart(\"months\") -> 2 |\n+| month | Month | Number | value.datePart(\"month\") -> 2 |\n+| weeks | Week of the month | Number | value.datePart(\"weeks\") -> 3 |\n+| week | Week of the month | Number | value.datePart(\"week\") -> 3 |\n+| w | Week of the month | Number | value.datePart(\"w\") -> 3 |\n+| weekday | Day of the week | String | value.datePart(\"weekday\") -> Friday |\n+| hours | Hour | Number | value.datePart(\"hours\") -> 5 |\n+| hour | Hour | Number | value.datePart(\"hour\") -> 5 |\n+| h | Hour | Number | value.datePart(\"h\") -> 5 |\n+| minutes | Minute | Number | value.datePart(\"minutes\") -> 30 |\n+| minute | Minute | Number | value.datePart(\"minute\") -> 30 |\n+| min | Minute | Number | value.datePart(\"min\") -> 30 |\n+| seconds | Seconds | Number | value.datePart(\"seconds\") -> 04 |\n+| sec | Seconds | Number | value.datePart(\"sec\") -> 04 |\n+| s | Seconds | Number | value.datePart(\"s\") -> 04 |\n+| milliseconds | Millseconds | Number | value.datePart(\"milliseconds\") -> 789 |\n+| ms | Millseconds | Number | value.datePart(\"ms\") -> 789 |\n+| S | Millseconds | Number | value.datePart(\"S\") -> 789 |\n+| n | Nanoseconds | Number | value.datePart(\"n\") -> 789000 |\n+| nano | Nanoseconds | Number | value.datePart(\"n\") -> 789000 |\n+| nanos | Nanoseconds | Number | value.datePart(\"n\") -> 789000 |\n+| time | Date expressed as milliseconds since the Unix Epoch | Number | value.datePart(\"time\") -> 1394775004000 |\n+\n+## Math functions\n+\n+For integer division and precision, you can use simple evaluations such as `1 / 2`, which is equivalent to `floor(1/2)` - that is, it returns only whole number results. If either operand is a floating point number, they both get promoted to floating point and a floating point result is returned. You can use `1 / 2.0` or `1.0 / 2` or `1.0 * x / y` (if you're working with variables of unknown contents).\n+\n+:::caution\n+Some of these math functions don't recognize integers when supplied as the first argument in dot notation (e.g., `5.cos()` simply returns 5 instead of the expected result). To ensure operations are successful, always wrap the first argument in brackets, such as `(value).cos()`.\n+:::\n+\n+|Function|Use|Example|\n+|-|-|-|\n+|`abs(n)`|Returns the absolute value of a number.|`abs(-6)` returns 6.|\n+|`acos(n)`|Returns the arc cosine of an angle, in the range 0 through PI.|`acos(0.345)` returns 1.218557541697832.|\n+|`asin(n)`|Returns the arc sine of an angle in the range of -PI/2 through [PI](https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#PI)/2.|`asin(0.345)` returns 0.35223878509706474.|\n+|`atan(n)`|Returns the arc tangent of an angle in the range of -PI/2 through PI/2.|`atan(0.345)` returns 0.3322135507465967.|\n+|`atan2(n1, n2)`|Converts rectangular coordinates (n1, n2) to polar (r, theta). Returns number theta.|`atan2(0.345,0.6)` returns \t0.5218342798144103.|\n+|`ceil(n)`|Returns the ceiling of a number.|`3.7.ceil()` returns 4 and `-3.7.ceil()` returns -3.|\n+|`combin(n1, n2)`|Returns the number of combinations for n2 elements as divided into n1.|`combin(20,2)` returns 190.|\n+|`cos(n)`|Returns the trigonometric cosine of an angle.|`cos(5)` returns 0.28366218546322625.|\n+|`cosh(n)`|Returns the hyperbolic cosine of a value.|`cosh(5)` returns 74.20994852478785.|\n+|`degrees(n)`|Converts an angle from radians to degrees.|`degrees(5)` returns 286.4788975654116.|\n+|`even(n)`|Rounds the number up to the nearest even integer.|`even(5)` returns 6.|\n+|`exp(n)`|Returns [e](https://en.wikipedia.org/wiki/E_(mathematical_constant)) raised to the power of n.|`exp(5)` returns 148.4131591025766.|\n+|`fact(n)`|Returns the factorial of a number, starting from 1.|`fact(5)` returns 120.|\n+|`factn(n1, n2)`|Returns the factorial of n1, starting from n2.|`factn(10,3)` returns 280.|\n+|`floor(n)`|Returns the floor of a number.|`3.7.floor()` returns 3 and `-3.7.floor()` returns -4.|\n+|`gcd(n1, n2)`|Returns the greatest common denominator of the two numbers.|`gcd(95,135)` returns 5.|\n+|`lcm(n1, n2)`|Returns the least common multiple of two numbers.|`lcm(95,135)` returns 2565.|\n+|`ln(n)`|Returns the natural logarithm of n.|`ln(5)` returns 1.6094379124341003.|\n+|`log(n)`|Returns the base 10 logarithm of n.|`log(5)` returns 0.6989700043360189.|\n+|`max(n1, n2)`|Returns the larger of two numbers.|`max(3,10)` returns 10.|\n+|`min(n1, n2)`|Returns the smaller of two numbers.|`min(3,10)` returns 3.|\n+|`mod(n1, n2)`|Returns n1 modulus n2. Note: `value.mod(9)` will work, whereas `74.mod(9)` will not work.|`mod(74, 9)` returns 2. |\n+|`multinomial(n1, n2 \u2026(optional))`|Calculates the multinomial of one number or a series of numbers.|`multinomial(2,3)` returns 10.|\n+|`odd(n)`|Rounds the number up to the nearest odd integer.|`odd(10)` returns 11.|\n+|`pow(n1, n2)`|Returns n1 raised to the power of n2. Note: value.pow(3)` will work, whereas `2.pow(3)` will not work.|`pow(2, 3)` returns 8 (2 cubed) and `pow(3, 2)` returns 9 (3 squared). The square root of any numeric value can be called with `value.pow(0.5)`.|\n+|`quotient(n1, n2)`|Returns the integer portion of a division (truncated, not rounded), when supplied with a numerator and denominator.|`quotient(9,2)` returns 4.|\n+|`radians(n)`|Converts an angle in degrees to radians.|`radians(10)` returns 0.17453292519943295.|\n+|`randomNumber(n lower_bound, n upper_bound)`|Returns a random integer in the interval between the lower and upper bounds (inclusively). Will output a different random number in each cell in a column.|\n+|`round(n)`|Rounds a number to the nearest integer.|`3.7.round()` returns 4 and `-3.7.round()` returns -4.|\n+|`sin(n)`|Returns the trigonometric sine of an angle.|`sin(10)` returns -0.5440211108893698.|\n+|`sinh(n)`|Returns the hyperbolic sine of an angle.|`sinh(10)` returns 11013.232874703393.|\n+|`sum(a)`|Sums the numbers in an array. Ignores non-number items. Returns 0 if the array does not contain numbers.|`sum([ 10, 2, three ])` returns 12.|\n+|`tan(n)`|Returns the trigonometric tangent of an angle.|`tan(10)` returns 0.6483608274590866.|\n+|`tanh(n)`|Returns the hyperbolic tangent of a value.|`tanh(10)` returns 0.9999999958776927.|\n+\n+## Other functions\n+\n+###### type(o)\n+Returns a string with the data type of o, such as undefined, string, number, boolean, etc. For example, a Transform operation using `value.type()` will convert all cells in a column to strings of their data types.\n+\n+###### facetCount(choiceValue, s facetExpression, s columnName)\n+Returns the facet count corresponding to the given choice value, by looking for the facetExpression in the choiceValue in columnName. For example, to create facet counts for the following table, we could generate a new column based on \u201cGift\u201d and enter in `value.facetCount(\"value\", \"Gift\")`. This would add the column we've named \u201cCount\u201d:\n+\n+| Gift | Recipient | Price | Count |\n+|-|-|-|-|\n+| lamp | Mary | 20 | 1 |\n+| clock | John | 57 | 2 |\n+| watch | Amit | 80 | 1 |\n+| clock | Claire | 62 | 2 |\n+\n+The facet expression, wrapped in quotes, can be useful to manipulate the inputted values before counting. For example, you could do a textual cleanup using fingerprint(): `(value.fingerprint()).facetCount(value.fingerprint(),\"Gift\")`.\n+\n+###### hasField(o, s name)\n+Returns a boolean indicating whether o has a member field called name. For example, `cell.recon.hasField(\"match\")` will return false if a reconciliation match hasn\u2019t been selected yet, or true if it does. You cannot chain your desired fields: for example, `cell.hasField(\u201crecon.match\u201d)` will return false even if the above expression returns true).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg5OTU1OA=="}, "originalCommit": {"oid": "91b0bca29f37c00090ad5d43d2a78d45a60c5fab"}, "originalPosition": 532}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyOTgyMzc3OnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwOTo0ODowNVrOH6TlkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNDo1ODoxOVrOH6ezYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwMDM2OA==", "bodyText": "Using \"value\" here feels confusing. Perhaps it would read better if \"value\" was always highlighted as value when it is referring to the OpenRefine variable?", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r530900368", "createdAt": "2020-11-26T09:48:05Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,547 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator string (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \u201casdfsd\u201d into a date or a number, but you can convert the number \u201c123\u201d into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \u201cnull\u201d.\n+\n+### Testing string characteristics\n+\n+###### startsWith(s, sub)\n+\n+Returns a boolean indicating whether s starts with sub. For example, `\"food\".startsWith(\"foo\")` returns true, whereas `\"food\".startsWith(\"bar\")` returns false. \n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\"food\".endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase: a capital letter starting each word, and the rest of the letters lowercase. For example, `\"Once upon a midnight DREARY\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string \u201chard\u201d.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(0, -1)` returns the string \u201cprofoun\u201d.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \u201ca\u201d).\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"T\u00e9xt th\u00e1t was opt\u00edc\u00e1lly rec\u00f3gn\u00edz\u00e9d\".replaceChars(\"\u00e1\u00e9\u00ed\u00f3\u00fa\", \"aeiou\")` returns the string \u201cText that was optically recognized\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### find(s, sub or p)\n+\n+Outputs an array of all consecutive substrings inside string s that match the substring or [regex](#grel-supported-regex) pattern p. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in the array [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a sub instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \"fine is\" ].\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, outputs an array of all [capturing groups](https://www.regular-expressions.info/brackets.html) (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [ \"3480\" ]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to store it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to escape characters and use parentheses as needed. Parentheses are required to denote a desired substring (capturing group); for example, \u201c.&#42;(\\d\\d\\d\\d)\u201d would return an array containing a single value, while \u201c(.&#42;)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the value is \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|`value.match(/\\d{6}/)` |null (does not match the full string)|\n+|`value.match(/.*\\d{6}.*/)` |[ ] (no indicated substring)|\n+|`value.match(/.*(\\d{6}).*/)` |[ \"123456\" ] (array with one value)|\n+|`value.match(/(.*)(\\d{6})(.*)/)` |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+### String parsing and splitting\n+\n+###### toNumber(s)\n+\n+Returns a string converted to a number. Will attempt to convert other formats into a string, then into a number. If the value is already a number, it will return the number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by sep. The separator can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\", \" air\" ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ \"inter\", \"nation\", \"ali\" ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\"HenryCTaylor\".splitByCharType()` will result in an array of [ \"H\", \"enry\", \"CT\", \"aylor\" ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ \"BE\", \"1\", \"A\", \"3\", \"E\" ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ \"inter\", \"nation\", \"alization\" ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ \"par\", \"a\", \"llel\" ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1, s2, s timeUnit (optional))\n+\n+Takes two strings and compares them, returning a string. Returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". Also works with dates; see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. \n+\n+###### md5(o)\n+\n+Returns the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of an object. If fed something other than a string (array, number, date, etc.), md5() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".md5()` will return 2c55a1626e31b4e373ceedaa9adc12a3.\n+\n+###### sha1(o)\n+\n+Returns the [SHA-1 hash](https://en.wikipedia.org/wiki/SHA-1) of an object. If fed something other than a string (array, number, date, etc.), sha1() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".sha1()` will return cd05286ee0ff8a830dbdc0c24f1cb68b83b0ef36.\n+\n+###### phonetic(s, s encoding)\n+\n+Returns a phonetic encoding of a string, based on an available phonetic algorithm. See the [section on phonetic clustering](cellediting#clustering-methods) for more information. Can be one of the following supported phonetic methods: [metaphone, doublemetaphone, metaphone3](https://www.wikipedia.org/wiki/Metaphone), [soundex](https://en.wikipedia.org/wiki/Soundex), [cologne](https://en.wikipedia.org/wiki/Cologne_phonetics). Quotes are required around your encoding method. For example, `\"Ruth Prawer Jhabvala\".phonetic(\"metaphone\")` outputs the string \u201cR0PRWRJHBFL\u201d.  \n+\n+###### reinterpret(s, s encoder)\n+\n+Returns s reinterpreted through the given character encoder. You must supply one of the [supported encodings](http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html). Note that quotes are required around your character encoder.\n+\n+When an OpenRefine project is started, data is imported and interpreted. A specific character encoding is identified or manually selected at that time (such as UTF-8). You can reinterpret a column into another specificed encoding using this function. This function may not fix your data; it may be better to use this in conjunction with new projects to test the interpretation, and pre-format your data as needed. \n+\n+###### fingerprint(s)\n+\n+Returns the fingerprint of s, a string that is the first step in [fingerprint clustering methods](cellediting#clustering-methods): it will trim whitespaces, convert all characters to lowercase, remove punctuation, sort words alphabetically, etc. For example, `\"Ruth  Prawer    Jhabvala\".fingerprint()` outputs the string \u201cjhabvala prawer ruth\u201d.\n+\n+###### ngram(s, n)\n+\n+Returns an array of the word n-grams of s. That is, it lists all the possible consecutive combinations of n words in the string. For example, `\"Ruth Prawer Jhabvala\".ngram(2)` would output the array [ \"Ruth Prawer\", \"Prawer Jhabvala\" ]. A word n-gram of 1 simply lists all the words in original order; an n-gram larger than the number of words in the string will only return the original string inside an array (e.g. `\"Ruth Prawer Jhabvala\".ngram(4)` would simply return [\"Ruth Prawer Jhabvala\"]).\n+\n+###### ngramFingerprint(s, n)\n+\n+Returns the [n-gram fingerprint](cellediting#clustering-methods) of s. For example, `\"banana\".ngram(2)` would output \u201canbana\u201d, after first generating the 2-grams \u201cba an na an na\u201d, removing duplicates, and sorting them alphabetically.\n+\n+###### unicode(s)\n+\n+Returns an array of strings describing each character of s in their full unicode notation. For example, `\"Bernice Rubens\".unicode()` outputs [ 66, 101, 114, 110, 105, 99, 101, 32, 82, 117, 98, 101, 110, 115 ].\n+\n+###### unicodeType(s)\n+\n+Returns an array of strings describing each character of s by their unicode type. For example, `\"Bernice Rubens\".unicodeType()` outputs [ \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"space separator\", \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\" ].\n+\n+## Format-based functions (JSON, HTML, XML)\n+\n+###### jsonize(o)\n+\n+Quotes a value as a JSON literal value.\n+\n+###### parseJson(s)\n+\n+Parses a string as JSON. get() can then be used with parseJson(): for example, `parseJson(\" { 'a' : 1 } \").get(\"a\")` returns 1.\n+\n+For example from the following JSON array, let's get all instances called \u201ckeywords\u201d having the same object string name of \u201ctext\u201d, and combine it with the forEach() function to iterate over the array.\n+\n+    {\n+       \"status\":\"OK\",\n+       \"url\":\"\",\n+       \"language\":\"english\",\n+       \"keywords\":[\n+          {\n+             \"text\":\"York en route\",\n+             \"relevance\":\"0.974363\"\n+          },\n+          {\n+             \"text\":\"Anthony Eden\",\n+             \"relevance\":\"0.814394\"\n+          },\n+          {\n+             \"text\":\"President Eisenhower\",\n+             \"relevance\":\"0.700189\"\n+          }\n+       ]\n+    }\n+\n+The GREL expression `forEach(value.parseJson().keywords,v,v.text).join(\":::\")` will output \u201cYork en route:::Anthony Eden:::President Eisenhower\u201d.\n+\n+### Jsoup XML and HTML parsing\n+\n+###### parseHtml(s)\n+Given a cell full of HTML-formatted text, simplifies HTML tags (such as by removing \u201c /\u201d at the end of self-closing tags), closes any unclosed tags, and inserts linebreaks and indents for cleaner code. You cannot pass parseHtml() a URL, but you can pre-fetch HTML with the <span class=\"menuItems\">Add column by fetching URLs</span> menu option. A cell cannot store the output of parseHtml() unless you convert it with toString(). \n+\n+When parseHtml() simplifies HTML, it can sometimes introduce errors. When closing tags, it makes its best guesses based on line breaks, indentation, and the presence of other tags. You may need to manually check the results. \n+\n+You can then extract or select() which portions of the HTML document you need for further splitting, partitioning, etc. An example of extracting all table rows from a div using parseHtml().select() together is described more in depth at [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+###### parseXml(s)\n+Given a cell full of XML-formatted text, returns a full XML document and adds any missing closing tags. You can then extract or select() which portions of the XML document you need for further splitting, partitioning, etc. Functions the same way as parseHtml() is described above. \n+\n+###### select(s, element)\n+Returns an array of all the desired elements from an HTML or XML document, if the element exists. Elements are identified using the [Jsoup selector syntax](https://jsoup.org/apidocs/org/jsoup/select/Selector.html). For example, `value.parseHtml().select(\"img.portrait\")[0]` would return the entirety of the first \u201cimg\u201d tag with the \u201cportrait\u201d class found in the parsed HTML inside `value`. Returns an empty array if no matching element is found. Use with toString() to capture the results in a cell. A tutorial of select() is shown in [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+You can use select() more than once:\n+\n+```\n+value.parseHtml().select(\"div#content\")[0].select(\"tr\").toString()\n+```\n+\n+###### htmlAttr(s, element)\n+Returns a string from an attribute on an HTML element. Use it in conjunction with parseHtml() as in the following example: `value.parseHtml().select(\"a.email\")[0].htmlAttr(\"href\")`.\n+\n+###### xmlAttr(s, element)\n+Returns a string from an attribute on an XML element. Function the same way htmlAttr() is described above. Use it in conjunction with parseXml().\n+\n+###### htmlText(element)\n+Returns a string of the text from within an HTML element (including all child elements), removing HTML tags and line breaks inside the string. Use it in conjunction with parseHtml() and select() to provide an element, as in the following example: `value.parseHtml().select(\"div.footer\")[0].htmlText()`. \n+\n+###### xmlText(element)\n+Returns a string of the text from within an XML element (including all child elements). Functions the same way as htmlText() is described above. Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### wholeText(element)\n+\n+_Works from OpenRefine 3.4.1 beta 644 onwards only_\n+\n+Selects the (unencoded) text of an element and its children, including any newlines and spaces, and returns a string of unencoded, un-normalized text. Use it in conjunction with parseHtml() and select() to provide an element as in the following example: `value.parseHtml().select(\"div.footer\")[0].wholeText()`.\n+\n+###### innerHtml(element)\n+Returns the [inner HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) of an HTML element. This will include text and children elements within the element selected. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### innerXml(element)\n+Returns all the inner XML elements inside your chosen XML element. Does not return the text directly inside your chosen XML element - only the contents of its children. To select the direct text, use ownText(). To select both, use xmlText(). Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### outerHtml(element)\n+Returns the [outer HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/outerHTML) of an HTML element. outerHtml includes the start and end tags of the current element. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### ownText(element)\n+Returns the text directly inside the selected XML or HTML element only, ignoring text inside children elements. Use it in conjunction with a parser and select() to provide an element.\n+\n+## Array functions\n+\n+###### length(a)\n+Returns the size of an array, meaning the number of objects inside it. Arrays can be empty, in which case length() will return 0. \n+\n+###### slice(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. If to is omitted, it is understood to be the end of the array. For example, `[0, 1, 2, 3, 4].slice(1, 3)` returns [ 1, 2 ], and `[ 0, 1, 2, 3, 4].slice(1)` returns [ 1, 2, 3, 4 ]. Also works with strings; see [String functions](#slices-n-from-n-to-optional).\n+\n+###### get(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. \n+\n+If to is omitted, only one array item is returned, as a string, instead of a sub-array. To return a sub-array from one index to the end, you can set the to argument to a very high number such as `value.get(2,999)` or you can use something like `with(value,a,a.get(1,a.length()))` to count the length of each array.\n+\n+Also works with strings; see [get() in String functions](#gets-n-from-n-to-optional).\n+\n+###### inArray(a, s)\n+Returns true if the array contains the desired string, and false otherwise.\n+\n+###### reverse(a)\n+Reverses the array. For example, `[ 0, 1, 2, 3].reverse()` returns the array [ 3, 2, 1, 0 ].\n+\n+###### sort(a)\n+Sorts the array in ascending order. Sorting is case-sensitive, uppercase first and lowercase second. For example, `[ \"al\", \"Joe\", \"Bob\", \"jim\" ].sort()` returns the array [ \"Bob\", \"Joe\", \"al\", \"jim\" ]. \n+\n+###### sum(a)\n+Return the sum of the numbers in the array. For example, `[ 2, 1, 0, 3].sum()` returns 6.\n+\n+###### join(a, sep)\n+Joins the items in the array with sep, and returns it all as a string. For example, `[ \"and\", \"or\", \"not\" ].join(\"/\")` returns the string \u201cand/or/not\u201d.\n+\n+###### uniques(a)\n+Returns the array with duplicates removed. Case-sensitive. For example, `[ \"al\", \"Joe\", \"Bob\", \"Joe\", \"Al\", \"Bob\" ].uniques()` returns the array [ \"Joe\", \"al\", \"Al\", \"Bob\" ]. \n+\n+As of OpenRefine 3.4.1, uniques() reorders the array items it returns; in 3.4 beta 644 and onwards, it preserves the original order (in this case, [ \"al\", \"Joe\", \"Bob\", \"Al\" ]). \n+\n+## Date functions\n+If you have a column full of dates in a more common format (such as yyyy/mm/dd or YYYYMMDD) you can convert these using [\u201cTransform\u201d > \u201cCommon transforms \u2026\u201d > \u201cto date\u201d](cellediting#data-type-transforms), or the GREL function toDate(). You may wish to create a new column with the transformation, in order to also preserve the more human-readable version.\n+\n+OpenRefine uses [Date.parse()](https://www.w3schools.com/jsref/jsref_parse.asp) to recognize a variety of formats and convert them, including converting from other time zones to UTC:\n+\n+![A screenshot of different date formats being converted, and one error.](/img/dates.png)\n+\n+You may need to do some reformatting if your dates are not being recognized by the toDate() function. For example, in the image above, the date that includes \u201c7AM\u201d is giving an error message, but the ones with \u201c2:42 PM\u201d and \u201c3:22PM\u201d are being converted.\n+\n+###### now()\n+\n+Returns the current time in the [ISO 8601 extended format](exploring#data-types). For example, 12:58pm on October 28th 2020 returns [date 2020-10-28T16:58:32Z].\n+\n+###### toDate(o, b monthFirst, s format1, s format2, ...)\n+\n+Returns the inputted object converted to a date object. Without arguments, it returns the ISO 8601 extended format. With arguments, you can control the output format:\n+*   monthFirst: set false if the date is formatted with the day before the month.\n+*   formatN: attempt to parse the date using an ordered list of possible formats. Supply formats based on the [SimpleDateFormat](https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html) syntax (and see the table below for a handy reference). \n+\n+For example, you can parse a column containing dates in different formats, such as cells with \u201cNov-09\u201d and \u201c11/09\u201d, using `value.toDate('MM/yy','MMM-yy').toString('yyyy-MM')` and both will output \u201c2009-11\u201d. For another example, \u201c1/4/2012 13:30:00\u201d can be parsed into a date using `value.toDate('d/M/y H&#58;m&#58;s')`.\n+\n+| Letter | Date or Time Component | Presentation | Examples |\n+|-|-|-|-|\n+| G | Era designator | Text | AD |\n+| y | Year | Year | 1996; 96 |\n+| Y | [Week year](https://en.wikipedia.org/wiki/ISO_week_date#First_week) | Year | 2009; 09 |\n+| M | Month in year | Month | July; Jul; 07 |\n+| w | Week in year | Number | 27 |\n+| W | Week in month | Number | 2 |\n+| D | Day in year | Number | 189 |\n+| d | Day in month | Number | 10 |\n+| F | Day of week in month | Number | 2 |\n+| E | Day name in week | Text | Tuesday; Tue |\n+| u | Day number of week (1 = Monday, ..., 7 = Sunday) | Number | 1 |\n+| a | AM/PM marker | Text | PM |\n+| H | Hour in day (0-23) | Number | 0 |\n+| k | Hour in day (1-24) | Number | 24 |\n+| K | Hour in AM/PM (0-11) | Number | 0 |\n+| h | Hour in AM/PM (1-12) | Number | 12 |\n+| m | Minute in hour | Number | 30 |\n+| s | Second in minute | Number | 55 |\n+| S | Millisecond | Number | 978 |\n+| n | Nanosecond | Number | 789000 |\n+| z | Time zone | General time zone | Pacific Standard Time; PST; GMT-08:00 |\n+| Z | Time zone | RFC 822 time zone | \\-0800 |\n+| X | Time zone | ISO 8601 time zone | \\-08; -0800; -08:00 |\n+\n+###### diff(d1, d2, s timeUnit)\n+\n+Given two dates, returns a number indicating the difference in a given time unit (see the table below). For example, `diff((\"Nov-11\".toDate('MMM-yy')), (\"Nov-09\".toDate('MMM-yy')), \"weeks\")` will return 104, for 104 weeks, or two years. The later date should go first. If the output is negative, invert d1 and d2.\n+\n+Also works with strings; see [diff() in string functions](#diffsd1-sd2-s-timeunit-optional).\n+\n+###### inc(d, n, s timeUnit)\n+\n+Returns a date changed by the given amount in the given unit of time (see the table below). The default unit is \u201chour\u201d. For example, if you want to move a date backwards by two months, use `value.inc(-2,'month')`.\n+\n+###### datePart(d, s timeUnit)\n+\n+Returns part of a date. Data type returned depends on the unit (see the table below). \n+\n+OpenRefine supports the following values for timeUnit:\n+\n+| Unit | Date part returned | Returned data type | Example using [date 2014-03-14T05:30:04.000789000Z] as value |\n+|-|-|-|-|\n+| years | Year | Number | value.datePart(\"years\") -> 2014 |\n+| year | Year | Number | value.datePart(\"year\") -> 2014 |\n+| months | Month | Number | value.datePart(\"months\") -> 2 |\n+| month | Month | Number | value.datePart(\"month\") -> 2 |\n+| weeks | Week of the month | Number | value.datePart(\"weeks\") -> 3 |\n+| week | Week of the month | Number | value.datePart(\"week\") -> 3 |\n+| w | Week of the month | Number | value.datePart(\"w\") -> 3 |\n+| weekday | Day of the week | String | value.datePart(\"weekday\") -> Friday |\n+| hours | Hour | Number | value.datePart(\"hours\") -> 5 |\n+| hour | Hour | Number | value.datePart(\"hour\") -> 5 |\n+| h | Hour | Number | value.datePart(\"h\") -> 5 |\n+| minutes | Minute | Number | value.datePart(\"minutes\") -> 30 |\n+| minute | Minute | Number | value.datePart(\"minute\") -> 30 |\n+| min | Minute | Number | value.datePart(\"min\") -> 30 |\n+| seconds | Seconds | Number | value.datePart(\"seconds\") -> 04 |\n+| sec | Seconds | Number | value.datePart(\"sec\") -> 04 |\n+| s | Seconds | Number | value.datePart(\"s\") -> 04 |\n+| milliseconds | Millseconds | Number | value.datePart(\"milliseconds\") -> 789 |\n+| ms | Millseconds | Number | value.datePart(\"ms\") -> 789 |\n+| S | Millseconds | Number | value.datePart(\"S\") -> 789 |\n+| n | Nanoseconds | Number | value.datePart(\"n\") -> 789000 |\n+| nano | Nanoseconds | Number | value.datePart(\"n\") -> 789000 |\n+| nanos | Nanoseconds | Number | value.datePart(\"n\") -> 789000 |\n+| time | Date expressed as milliseconds since the Unix Epoch | Number | value.datePart(\"time\") -> 1394775004000 |\n+\n+## Math functions\n+\n+For integer division and precision, you can use simple evaluations such as `1 / 2`, which is equivalent to `floor(1/2)` - that is, it returns only whole number results. If either operand is a floating point number, they both get promoted to floating point and a floating point result is returned. You can use `1 / 2.0` or `1.0 / 2` or `1.0 * x / y` (if you're working with variables of unknown contents).\n+\n+:::caution\n+Some of these math functions don't recognize integers when supplied as the first argument in dot notation (e.g., `5.cos()` simply returns 5 instead of the expected result). To ensure operations are successful, always wrap the first argument in brackets, such as `(value).cos()`.\n+:::\n+\n+|Function|Use|Example|\n+|-|-|-|\n+|`abs(n)`|Returns the absolute value of a number.|`abs(-6)` returns 6.|\n+|`acos(n)`|Returns the arc cosine of an angle, in the range 0 through PI.|`acos(0.345)` returns 1.218557541697832.|\n+|`asin(n)`|Returns the arc sine of an angle in the range of -PI/2 through [PI](https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#PI)/2.|`asin(0.345)` returns 0.35223878509706474.|\n+|`atan(n)`|Returns the arc tangent of an angle in the range of -PI/2 through PI/2.|`atan(0.345)` returns 0.3322135507465967.|\n+|`atan2(n1, n2)`|Converts rectangular coordinates (n1, n2) to polar (r, theta). Returns number theta.|`atan2(0.345,0.6)` returns \t0.5218342798144103.|\n+|`ceil(n)`|Returns the ceiling of a number.|`3.7.ceil()` returns 4 and `-3.7.ceil()` returns -3.|\n+|`combin(n1, n2)`|Returns the number of combinations for n2 elements as divided into n1.|`combin(20,2)` returns 190.|\n+|`cos(n)`|Returns the trigonometric cosine of an angle.|`cos(5)` returns 0.28366218546322625.|\n+|`cosh(n)`|Returns the hyperbolic cosine of a value.|`cosh(5)` returns 74.20994852478785.|\n+|`degrees(n)`|Converts an angle from radians to degrees.|`degrees(5)` returns 286.4788975654116.|\n+|`even(n)`|Rounds the number up to the nearest even integer.|`even(5)` returns 6.|\n+|`exp(n)`|Returns [e](https://en.wikipedia.org/wiki/E_(mathematical_constant)) raised to the power of n.|`exp(5)` returns 148.4131591025766.|\n+|`fact(n)`|Returns the factorial of a number, starting from 1.|`fact(5)` returns 120.|\n+|`factn(n1, n2)`|Returns the factorial of n1, starting from n2.|`factn(10,3)` returns 280.|\n+|`floor(n)`|Returns the floor of a number.|`3.7.floor()` returns 3 and `-3.7.floor()` returns -4.|\n+|`gcd(n1, n2)`|Returns the greatest common denominator of the two numbers.|`gcd(95,135)` returns 5.|\n+|`lcm(n1, n2)`|Returns the least common multiple of two numbers.|`lcm(95,135)` returns 2565.|\n+|`ln(n)`|Returns the natural logarithm of n.|`ln(5)` returns 1.6094379124341003.|\n+|`log(n)`|Returns the base 10 logarithm of n.|`log(5)` returns 0.6989700043360189.|\n+|`max(n1, n2)`|Returns the larger of two numbers.|`max(3,10)` returns 10.|\n+|`min(n1, n2)`|Returns the smaller of two numbers.|`min(3,10)` returns 3.|\n+|`mod(n1, n2)`|Returns n1 modulus n2. Note: `value.mod(9)` will work, whereas `74.mod(9)` will not work.|`mod(74, 9)` returns 2. |\n+|`multinomial(n1, n2 \u2026(optional))`|Calculates the multinomial of one number or a series of numbers.|`multinomial(2,3)` returns 10.|\n+|`odd(n)`|Rounds the number up to the nearest odd integer.|`odd(10)` returns 11.|\n+|`pow(n1, n2)`|Returns n1 raised to the power of n2. Note: value.pow(3)` will work, whereas `2.pow(3)` will not work.|`pow(2, 3)` returns 8 (2 cubed) and `pow(3, 2)` returns 9 (3 squared). The square root of any numeric value can be called with `value.pow(0.5)`.|\n+|`quotient(n1, n2)`|Returns the integer portion of a division (truncated, not rounded), when supplied with a numerator and denominator.|`quotient(9,2)` returns 4.|\n+|`radians(n)`|Converts an angle in degrees to radians.|`radians(10)` returns 0.17453292519943295.|\n+|`randomNumber(n lower_bound, n upper_bound)`|Returns a random integer in the interval between the lower and upper bounds (inclusively). Will output a different random number in each cell in a column.|\n+|`round(n)`|Rounds a number to the nearest integer.|`3.7.round()` returns 4 and `-3.7.round()` returns -4.|\n+|`sin(n)`|Returns the trigonometric sine of an angle.|`sin(10)` returns -0.5440211108893698.|\n+|`sinh(n)`|Returns the hyperbolic sine of an angle.|`sinh(10)` returns 11013.232874703393.|\n+|`sum(a)`|Sums the numbers in an array. Ignores non-number items. Returns 0 if the array does not contain numbers.|`sum([ 10, 2, three ])` returns 12.|\n+|`tan(n)`|Returns the trigonometric tangent of an angle.|`tan(10)` returns 0.6483608274590866.|\n+|`tanh(n)`|Returns the hyperbolic tangent of a value.|`tanh(10)` returns 0.9999999958776927.|\n+\n+## Other functions\n+\n+###### type(o)\n+Returns a string with the data type of o, such as undefined, string, number, boolean, etc. For example, a Transform operation using `value.type()` will convert all cells in a column to strings of their data types.\n+\n+###### facetCount(choiceValue, s facetExpression, s columnName)\n+Returns the facet count corresponding to the given choice value, by looking for the facetExpression in the choiceValue in columnName. For example, to create facet counts for the following table, we could generate a new column based on \u201cGift\u201d and enter in `value.facetCount(\"value\", \"Gift\")`. This would add the column we've named \u201cCount\u201d:\n+\n+| Gift | Recipient | Price | Count |\n+|-|-|-|-|\n+| lamp | Mary | 20 | 1 |\n+| clock | John | 57 | 2 |\n+| watch | Amit | 80 | 1 |\n+| clock | Claire | 62 | 2 |\n+\n+The facet expression, wrapped in quotes, can be useful to manipulate the inputted values before counting. For example, you could do a textual cleanup using fingerprint(): `(value.fingerprint()).facetCount(value.fingerprint(),\"Gift\")`.\n+\n+###### hasField(o, s name)\n+Returns a boolean indicating whether o has a member field called name. For example, `cell.recon.hasField(\"match\")` will return false if a reconciliation match hasn\u2019t been selected yet, or true if it does. You cannot chain your desired fields: for example, `cell.hasField(\u201crecon.match\u201d)` will return false even if the above expression returns true).\n+\n+###### coalesce(o1, o2, o3, ...)\n+Returns the first non-null from a series of values of any kind. For example, `coalesce(value, \"\")` would return an empty string \u201c\u201d if the value was null, but otherwise return the value.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91b0bca29f37c00090ad5d43d2a78d45a60c5fab"}, "originalPosition": 535}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA4NDEzMQ==", "bodyText": "Which value is confusing? \"values of any kind\" or \"if the value was null\" or \"return the value\"?", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r531084131", "createdAt": "2020-11-26T14:58:19Z", "author": {"login": "allanaaa"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,547 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator string (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \u201casdfsd\u201d into a date or a number, but you can convert the number \u201c123\u201d into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \u201cnull\u201d.\n+\n+### Testing string characteristics\n+\n+###### startsWith(s, sub)\n+\n+Returns a boolean indicating whether s starts with sub. For example, `\"food\".startsWith(\"foo\")` returns true, whereas `\"food\".startsWith(\"bar\")` returns false. \n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\"food\".endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase: a capital letter starting each word, and the rest of the letters lowercase. For example, `\"Once upon a midnight DREARY\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string \u201chard\u201d.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(0, -1)` returns the string \u201cprofoun\u201d.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \u201ca\u201d).\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"T\u00e9xt th\u00e1t was opt\u00edc\u00e1lly rec\u00f3gn\u00edz\u00e9d\".replaceChars(\"\u00e1\u00e9\u00ed\u00f3\u00fa\", \"aeiou\")` returns the string \u201cText that was optically recognized\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### find(s, sub or p)\n+\n+Outputs an array of all consecutive substrings inside string s that match the substring or [regex](#grel-supported-regex) pattern p. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in the array [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a sub instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \"fine is\" ].\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, outputs an array of all [capturing groups](https://www.regular-expressions.info/brackets.html) (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [ \"3480\" ]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to store it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to escape characters and use parentheses as needed. Parentheses are required to denote a desired substring (capturing group); for example, \u201c.&#42;(\\d\\d\\d\\d)\u201d would return an array containing a single value, while \u201c(.&#42;)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the value is \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|`value.match(/\\d{6}/)` |null (does not match the full string)|\n+|`value.match(/.*\\d{6}.*/)` |[ ] (no indicated substring)|\n+|`value.match(/.*(\\d{6}).*/)` |[ \"123456\" ] (array with one value)|\n+|`value.match(/(.*)(\\d{6})(.*)/)` |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+### String parsing and splitting\n+\n+###### toNumber(s)\n+\n+Returns a string converted to a number. Will attempt to convert other formats into a string, then into a number. If the value is already a number, it will return the number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by sep. The separator can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\", \" air\" ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ \"inter\", \"nation\", \"ali\" ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\"HenryCTaylor\".splitByCharType()` will result in an array of [ \"H\", \"enry\", \"CT\", \"aylor\" ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ \"BE\", \"1\", \"A\", \"3\", \"E\" ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ \"inter\", \"nation\", \"alization\" ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ \"par\", \"a\", \"llel\" ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1, s2, s timeUnit (optional))\n+\n+Takes two strings and compares them, returning a string. Returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". Also works with dates; see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. \n+\n+###### md5(o)\n+\n+Returns the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of an object. If fed something other than a string (array, number, date, etc.), md5() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".md5()` will return 2c55a1626e31b4e373ceedaa9adc12a3.\n+\n+###### sha1(o)\n+\n+Returns the [SHA-1 hash](https://en.wikipedia.org/wiki/SHA-1) of an object. If fed something other than a string (array, number, date, etc.), sha1() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".sha1()` will return cd05286ee0ff8a830dbdc0c24f1cb68b83b0ef36.\n+\n+###### phonetic(s, s encoding)\n+\n+Returns a phonetic encoding of a string, based on an available phonetic algorithm. See the [section on phonetic clustering](cellediting#clustering-methods) for more information. Can be one of the following supported phonetic methods: [metaphone, doublemetaphone, metaphone3](https://www.wikipedia.org/wiki/Metaphone), [soundex](https://en.wikipedia.org/wiki/Soundex), [cologne](https://en.wikipedia.org/wiki/Cologne_phonetics). Quotes are required around your encoding method. For example, `\"Ruth Prawer Jhabvala\".phonetic(\"metaphone\")` outputs the string \u201cR0PRWRJHBFL\u201d.  \n+\n+###### reinterpret(s, s encoder)\n+\n+Returns s reinterpreted through the given character encoder. You must supply one of the [supported encodings](http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html). Note that quotes are required around your character encoder.\n+\n+When an OpenRefine project is started, data is imported and interpreted. A specific character encoding is identified or manually selected at that time (such as UTF-8). You can reinterpret a column into another specificed encoding using this function. This function may not fix your data; it may be better to use this in conjunction with new projects to test the interpretation, and pre-format your data as needed. \n+\n+###### fingerprint(s)\n+\n+Returns the fingerprint of s, a string that is the first step in [fingerprint clustering methods](cellediting#clustering-methods): it will trim whitespaces, convert all characters to lowercase, remove punctuation, sort words alphabetically, etc. For example, `\"Ruth  Prawer    Jhabvala\".fingerprint()` outputs the string \u201cjhabvala prawer ruth\u201d.\n+\n+###### ngram(s, n)\n+\n+Returns an array of the word n-grams of s. That is, it lists all the possible consecutive combinations of n words in the string. For example, `\"Ruth Prawer Jhabvala\".ngram(2)` would output the array [ \"Ruth Prawer\", \"Prawer Jhabvala\" ]. A word n-gram of 1 simply lists all the words in original order; an n-gram larger than the number of words in the string will only return the original string inside an array (e.g. `\"Ruth Prawer Jhabvala\".ngram(4)` would simply return [\"Ruth Prawer Jhabvala\"]).\n+\n+###### ngramFingerprint(s, n)\n+\n+Returns the [n-gram fingerprint](cellediting#clustering-methods) of s. For example, `\"banana\".ngram(2)` would output \u201canbana\u201d, after first generating the 2-grams \u201cba an na an na\u201d, removing duplicates, and sorting them alphabetically.\n+\n+###### unicode(s)\n+\n+Returns an array of strings describing each character of s in their full unicode notation. For example, `\"Bernice Rubens\".unicode()` outputs [ 66, 101, 114, 110, 105, 99, 101, 32, 82, 117, 98, 101, 110, 115 ].\n+\n+###### unicodeType(s)\n+\n+Returns an array of strings describing each character of s by their unicode type. For example, `\"Bernice Rubens\".unicodeType()` outputs [ \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"space separator\", \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\" ].\n+\n+## Format-based functions (JSON, HTML, XML)\n+\n+###### jsonize(o)\n+\n+Quotes a value as a JSON literal value.\n+\n+###### parseJson(s)\n+\n+Parses a string as JSON. get() can then be used with parseJson(): for example, `parseJson(\" { 'a' : 1 } \").get(\"a\")` returns 1.\n+\n+For example from the following JSON array, let's get all instances called \u201ckeywords\u201d having the same object string name of \u201ctext\u201d, and combine it with the forEach() function to iterate over the array.\n+\n+    {\n+       \"status\":\"OK\",\n+       \"url\":\"\",\n+       \"language\":\"english\",\n+       \"keywords\":[\n+          {\n+             \"text\":\"York en route\",\n+             \"relevance\":\"0.974363\"\n+          },\n+          {\n+             \"text\":\"Anthony Eden\",\n+             \"relevance\":\"0.814394\"\n+          },\n+          {\n+             \"text\":\"President Eisenhower\",\n+             \"relevance\":\"0.700189\"\n+          }\n+       ]\n+    }\n+\n+The GREL expression `forEach(value.parseJson().keywords,v,v.text).join(\":::\")` will output \u201cYork en route:::Anthony Eden:::President Eisenhower\u201d.\n+\n+### Jsoup XML and HTML parsing\n+\n+###### parseHtml(s)\n+Given a cell full of HTML-formatted text, simplifies HTML tags (such as by removing \u201c /\u201d at the end of self-closing tags), closes any unclosed tags, and inserts linebreaks and indents for cleaner code. You cannot pass parseHtml() a URL, but you can pre-fetch HTML with the <span class=\"menuItems\">Add column by fetching URLs</span> menu option. A cell cannot store the output of parseHtml() unless you convert it with toString(). \n+\n+When parseHtml() simplifies HTML, it can sometimes introduce errors. When closing tags, it makes its best guesses based on line breaks, indentation, and the presence of other tags. You may need to manually check the results. \n+\n+You can then extract or select() which portions of the HTML document you need for further splitting, partitioning, etc. An example of extracting all table rows from a div using parseHtml().select() together is described more in depth at [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+###### parseXml(s)\n+Given a cell full of XML-formatted text, returns a full XML document and adds any missing closing tags. You can then extract or select() which portions of the XML document you need for further splitting, partitioning, etc. Functions the same way as parseHtml() is described above. \n+\n+###### select(s, element)\n+Returns an array of all the desired elements from an HTML or XML document, if the element exists. Elements are identified using the [Jsoup selector syntax](https://jsoup.org/apidocs/org/jsoup/select/Selector.html). For example, `value.parseHtml().select(\"img.portrait\")[0]` would return the entirety of the first \u201cimg\u201d tag with the \u201cportrait\u201d class found in the parsed HTML inside `value`. Returns an empty array if no matching element is found. Use with toString() to capture the results in a cell. A tutorial of select() is shown in [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+You can use select() more than once:\n+\n+```\n+value.parseHtml().select(\"div#content\")[0].select(\"tr\").toString()\n+```\n+\n+###### htmlAttr(s, element)\n+Returns a string from an attribute on an HTML element. Use it in conjunction with parseHtml() as in the following example: `value.parseHtml().select(\"a.email\")[0].htmlAttr(\"href\")`.\n+\n+###### xmlAttr(s, element)\n+Returns a string from an attribute on an XML element. Function the same way htmlAttr() is described above. Use it in conjunction with parseXml().\n+\n+###### htmlText(element)\n+Returns a string of the text from within an HTML element (including all child elements), removing HTML tags and line breaks inside the string. Use it in conjunction with parseHtml() and select() to provide an element, as in the following example: `value.parseHtml().select(\"div.footer\")[0].htmlText()`. \n+\n+###### xmlText(element)\n+Returns a string of the text from within an XML element (including all child elements). Functions the same way as htmlText() is described above. Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### wholeText(element)\n+\n+_Works from OpenRefine 3.4.1 beta 644 onwards only_\n+\n+Selects the (unencoded) text of an element and its children, including any newlines and spaces, and returns a string of unencoded, un-normalized text. Use it in conjunction with parseHtml() and select() to provide an element as in the following example: `value.parseHtml().select(\"div.footer\")[0].wholeText()`.\n+\n+###### innerHtml(element)\n+Returns the [inner HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) of an HTML element. This will include text and children elements within the element selected. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### innerXml(element)\n+Returns all the inner XML elements inside your chosen XML element. Does not return the text directly inside your chosen XML element - only the contents of its children. To select the direct text, use ownText(). To select both, use xmlText(). Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### outerHtml(element)\n+Returns the [outer HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/outerHTML) of an HTML element. outerHtml includes the start and end tags of the current element. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### ownText(element)\n+Returns the text directly inside the selected XML or HTML element only, ignoring text inside children elements. Use it in conjunction with a parser and select() to provide an element.\n+\n+## Array functions\n+\n+###### length(a)\n+Returns the size of an array, meaning the number of objects inside it. Arrays can be empty, in which case length() will return 0. \n+\n+###### slice(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. If to is omitted, it is understood to be the end of the array. For example, `[0, 1, 2, 3, 4].slice(1, 3)` returns [ 1, 2 ], and `[ 0, 1, 2, 3, 4].slice(1)` returns [ 1, 2, 3, 4 ]. Also works with strings; see [String functions](#slices-n-from-n-to-optional).\n+\n+###### get(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. \n+\n+If to is omitted, only one array item is returned, as a string, instead of a sub-array. To return a sub-array from one index to the end, you can set the to argument to a very high number such as `value.get(2,999)` or you can use something like `with(value,a,a.get(1,a.length()))` to count the length of each array.\n+\n+Also works with strings; see [get() in String functions](#gets-n-from-n-to-optional).\n+\n+###### inArray(a, s)\n+Returns true if the array contains the desired string, and false otherwise.\n+\n+###### reverse(a)\n+Reverses the array. For example, `[ 0, 1, 2, 3].reverse()` returns the array [ 3, 2, 1, 0 ].\n+\n+###### sort(a)\n+Sorts the array in ascending order. Sorting is case-sensitive, uppercase first and lowercase second. For example, `[ \"al\", \"Joe\", \"Bob\", \"jim\" ].sort()` returns the array [ \"Bob\", \"Joe\", \"al\", \"jim\" ]. \n+\n+###### sum(a)\n+Return the sum of the numbers in the array. For example, `[ 2, 1, 0, 3].sum()` returns 6.\n+\n+###### join(a, sep)\n+Joins the items in the array with sep, and returns it all as a string. For example, `[ \"and\", \"or\", \"not\" ].join(\"/\")` returns the string \u201cand/or/not\u201d.\n+\n+###### uniques(a)\n+Returns the array with duplicates removed. Case-sensitive. For example, `[ \"al\", \"Joe\", \"Bob\", \"Joe\", \"Al\", \"Bob\" ].uniques()` returns the array [ \"Joe\", \"al\", \"Al\", \"Bob\" ]. \n+\n+As of OpenRefine 3.4.1, uniques() reorders the array items it returns; in 3.4 beta 644 and onwards, it preserves the original order (in this case, [ \"al\", \"Joe\", \"Bob\", \"Al\" ]). \n+\n+## Date functions\n+If you have a column full of dates in a more common format (such as yyyy/mm/dd or YYYYMMDD) you can convert these using [\u201cTransform\u201d > \u201cCommon transforms \u2026\u201d > \u201cto date\u201d](cellediting#data-type-transforms), or the GREL function toDate(). You may wish to create a new column with the transformation, in order to also preserve the more human-readable version.\n+\n+OpenRefine uses [Date.parse()](https://www.w3schools.com/jsref/jsref_parse.asp) to recognize a variety of formats and convert them, including converting from other time zones to UTC:\n+\n+![A screenshot of different date formats being converted, and one error.](/img/dates.png)\n+\n+You may need to do some reformatting if your dates are not being recognized by the toDate() function. For example, in the image above, the date that includes \u201c7AM\u201d is giving an error message, but the ones with \u201c2:42 PM\u201d and \u201c3:22PM\u201d are being converted.\n+\n+###### now()\n+\n+Returns the current time in the [ISO 8601 extended format](exploring#data-types). For example, 12:58pm on October 28th 2020 returns [date 2020-10-28T16:58:32Z].\n+\n+###### toDate(o, b monthFirst, s format1, s format2, ...)\n+\n+Returns the inputted object converted to a date object. Without arguments, it returns the ISO 8601 extended format. With arguments, you can control the output format:\n+*   monthFirst: set false if the date is formatted with the day before the month.\n+*   formatN: attempt to parse the date using an ordered list of possible formats. Supply formats based on the [SimpleDateFormat](https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html) syntax (and see the table below for a handy reference). \n+\n+For example, you can parse a column containing dates in different formats, such as cells with \u201cNov-09\u201d and \u201c11/09\u201d, using `value.toDate('MM/yy','MMM-yy').toString('yyyy-MM')` and both will output \u201c2009-11\u201d. For another example, \u201c1/4/2012 13:30:00\u201d can be parsed into a date using `value.toDate('d/M/y H&#58;m&#58;s')`.\n+\n+| Letter | Date or Time Component | Presentation | Examples |\n+|-|-|-|-|\n+| G | Era designator | Text | AD |\n+| y | Year | Year | 1996; 96 |\n+| Y | [Week year](https://en.wikipedia.org/wiki/ISO_week_date#First_week) | Year | 2009; 09 |\n+| M | Month in year | Month | July; Jul; 07 |\n+| w | Week in year | Number | 27 |\n+| W | Week in month | Number | 2 |\n+| D | Day in year | Number | 189 |\n+| d | Day in month | Number | 10 |\n+| F | Day of week in month | Number | 2 |\n+| E | Day name in week | Text | Tuesday; Tue |\n+| u | Day number of week (1 = Monday, ..., 7 = Sunday) | Number | 1 |\n+| a | AM/PM marker | Text | PM |\n+| H | Hour in day (0-23) | Number | 0 |\n+| k | Hour in day (1-24) | Number | 24 |\n+| K | Hour in AM/PM (0-11) | Number | 0 |\n+| h | Hour in AM/PM (1-12) | Number | 12 |\n+| m | Minute in hour | Number | 30 |\n+| s | Second in minute | Number | 55 |\n+| S | Millisecond | Number | 978 |\n+| n | Nanosecond | Number | 789000 |\n+| z | Time zone | General time zone | Pacific Standard Time; PST; GMT-08:00 |\n+| Z | Time zone | RFC 822 time zone | \\-0800 |\n+| X | Time zone | ISO 8601 time zone | \\-08; -0800; -08:00 |\n+\n+###### diff(d1, d2, s timeUnit)\n+\n+Given two dates, returns a number indicating the difference in a given time unit (see the table below). For example, `diff((\"Nov-11\".toDate('MMM-yy')), (\"Nov-09\".toDate('MMM-yy')), \"weeks\")` will return 104, for 104 weeks, or two years. The later date should go first. If the output is negative, invert d1 and d2.\n+\n+Also works with strings; see [diff() in string functions](#diffsd1-sd2-s-timeunit-optional).\n+\n+###### inc(d, n, s timeUnit)\n+\n+Returns a date changed by the given amount in the given unit of time (see the table below). The default unit is \u201chour\u201d. For example, if you want to move a date backwards by two months, use `value.inc(-2,'month')`.\n+\n+###### datePart(d, s timeUnit)\n+\n+Returns part of a date. Data type returned depends on the unit (see the table below). \n+\n+OpenRefine supports the following values for timeUnit:\n+\n+| Unit | Date part returned | Returned data type | Example using [date 2014-03-14T05:30:04.000789000Z] as value |\n+|-|-|-|-|\n+| years | Year | Number | value.datePart(\"years\") -> 2014 |\n+| year | Year | Number | value.datePart(\"year\") -> 2014 |\n+| months | Month | Number | value.datePart(\"months\") -> 2 |\n+| month | Month | Number | value.datePart(\"month\") -> 2 |\n+| weeks | Week of the month | Number | value.datePart(\"weeks\") -> 3 |\n+| week | Week of the month | Number | value.datePart(\"week\") -> 3 |\n+| w | Week of the month | Number | value.datePart(\"w\") -> 3 |\n+| weekday | Day of the week | String | value.datePart(\"weekday\") -> Friday |\n+| hours | Hour | Number | value.datePart(\"hours\") -> 5 |\n+| hour | Hour | Number | value.datePart(\"hour\") -> 5 |\n+| h | Hour | Number | value.datePart(\"h\") -> 5 |\n+| minutes | Minute | Number | value.datePart(\"minutes\") -> 30 |\n+| minute | Minute | Number | value.datePart(\"minute\") -> 30 |\n+| min | Minute | Number | value.datePart(\"min\") -> 30 |\n+| seconds | Seconds | Number | value.datePart(\"seconds\") -> 04 |\n+| sec | Seconds | Number | value.datePart(\"sec\") -> 04 |\n+| s | Seconds | Number | value.datePart(\"s\") -> 04 |\n+| milliseconds | Millseconds | Number | value.datePart(\"milliseconds\") -> 789 |\n+| ms | Millseconds | Number | value.datePart(\"ms\") -> 789 |\n+| S | Millseconds | Number | value.datePart(\"S\") -> 789 |\n+| n | Nanoseconds | Number | value.datePart(\"n\") -> 789000 |\n+| nano | Nanoseconds | Number | value.datePart(\"n\") -> 789000 |\n+| nanos | Nanoseconds | Number | value.datePart(\"n\") -> 789000 |\n+| time | Date expressed as milliseconds since the Unix Epoch | Number | value.datePart(\"time\") -> 1394775004000 |\n+\n+## Math functions\n+\n+For integer division and precision, you can use simple evaluations such as `1 / 2`, which is equivalent to `floor(1/2)` - that is, it returns only whole number results. If either operand is a floating point number, they both get promoted to floating point and a floating point result is returned. You can use `1 / 2.0` or `1.0 / 2` or `1.0 * x / y` (if you're working with variables of unknown contents).\n+\n+:::caution\n+Some of these math functions don't recognize integers when supplied as the first argument in dot notation (e.g., `5.cos()` simply returns 5 instead of the expected result). To ensure operations are successful, always wrap the first argument in brackets, such as `(value).cos()`.\n+:::\n+\n+|Function|Use|Example|\n+|-|-|-|\n+|`abs(n)`|Returns the absolute value of a number.|`abs(-6)` returns 6.|\n+|`acos(n)`|Returns the arc cosine of an angle, in the range 0 through PI.|`acos(0.345)` returns 1.218557541697832.|\n+|`asin(n)`|Returns the arc sine of an angle in the range of -PI/2 through [PI](https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#PI)/2.|`asin(0.345)` returns 0.35223878509706474.|\n+|`atan(n)`|Returns the arc tangent of an angle in the range of -PI/2 through PI/2.|`atan(0.345)` returns 0.3322135507465967.|\n+|`atan2(n1, n2)`|Converts rectangular coordinates (n1, n2) to polar (r, theta). Returns number theta.|`atan2(0.345,0.6)` returns \t0.5218342798144103.|\n+|`ceil(n)`|Returns the ceiling of a number.|`3.7.ceil()` returns 4 and `-3.7.ceil()` returns -3.|\n+|`combin(n1, n2)`|Returns the number of combinations for n2 elements as divided into n1.|`combin(20,2)` returns 190.|\n+|`cos(n)`|Returns the trigonometric cosine of an angle.|`cos(5)` returns 0.28366218546322625.|\n+|`cosh(n)`|Returns the hyperbolic cosine of a value.|`cosh(5)` returns 74.20994852478785.|\n+|`degrees(n)`|Converts an angle from radians to degrees.|`degrees(5)` returns 286.4788975654116.|\n+|`even(n)`|Rounds the number up to the nearest even integer.|`even(5)` returns 6.|\n+|`exp(n)`|Returns [e](https://en.wikipedia.org/wiki/E_(mathematical_constant)) raised to the power of n.|`exp(5)` returns 148.4131591025766.|\n+|`fact(n)`|Returns the factorial of a number, starting from 1.|`fact(5)` returns 120.|\n+|`factn(n1, n2)`|Returns the factorial of n1, starting from n2.|`factn(10,3)` returns 280.|\n+|`floor(n)`|Returns the floor of a number.|`3.7.floor()` returns 3 and `-3.7.floor()` returns -4.|\n+|`gcd(n1, n2)`|Returns the greatest common denominator of the two numbers.|`gcd(95,135)` returns 5.|\n+|`lcm(n1, n2)`|Returns the least common multiple of two numbers.|`lcm(95,135)` returns 2565.|\n+|`ln(n)`|Returns the natural logarithm of n.|`ln(5)` returns 1.6094379124341003.|\n+|`log(n)`|Returns the base 10 logarithm of n.|`log(5)` returns 0.6989700043360189.|\n+|`max(n1, n2)`|Returns the larger of two numbers.|`max(3,10)` returns 10.|\n+|`min(n1, n2)`|Returns the smaller of two numbers.|`min(3,10)` returns 3.|\n+|`mod(n1, n2)`|Returns n1 modulus n2. Note: `value.mod(9)` will work, whereas `74.mod(9)` will not work.|`mod(74, 9)` returns 2. |\n+|`multinomial(n1, n2 \u2026(optional))`|Calculates the multinomial of one number or a series of numbers.|`multinomial(2,3)` returns 10.|\n+|`odd(n)`|Rounds the number up to the nearest odd integer.|`odd(10)` returns 11.|\n+|`pow(n1, n2)`|Returns n1 raised to the power of n2. Note: value.pow(3)` will work, whereas `2.pow(3)` will not work.|`pow(2, 3)` returns 8 (2 cubed) and `pow(3, 2)` returns 9 (3 squared). The square root of any numeric value can be called with `value.pow(0.5)`.|\n+|`quotient(n1, n2)`|Returns the integer portion of a division (truncated, not rounded), when supplied with a numerator and denominator.|`quotient(9,2)` returns 4.|\n+|`radians(n)`|Converts an angle in degrees to radians.|`radians(10)` returns 0.17453292519943295.|\n+|`randomNumber(n lower_bound, n upper_bound)`|Returns a random integer in the interval between the lower and upper bounds (inclusively). Will output a different random number in each cell in a column.|\n+|`round(n)`|Rounds a number to the nearest integer.|`3.7.round()` returns 4 and `-3.7.round()` returns -4.|\n+|`sin(n)`|Returns the trigonometric sine of an angle.|`sin(10)` returns -0.5440211108893698.|\n+|`sinh(n)`|Returns the hyperbolic sine of an angle.|`sinh(10)` returns 11013.232874703393.|\n+|`sum(a)`|Sums the numbers in an array. Ignores non-number items. Returns 0 if the array does not contain numbers.|`sum([ 10, 2, three ])` returns 12.|\n+|`tan(n)`|Returns the trigonometric tangent of an angle.|`tan(10)` returns 0.6483608274590866.|\n+|`tanh(n)`|Returns the hyperbolic tangent of a value.|`tanh(10)` returns 0.9999999958776927.|\n+\n+## Other functions\n+\n+###### type(o)\n+Returns a string with the data type of o, such as undefined, string, number, boolean, etc. For example, a Transform operation using `value.type()` will convert all cells in a column to strings of their data types.\n+\n+###### facetCount(choiceValue, s facetExpression, s columnName)\n+Returns the facet count corresponding to the given choice value, by looking for the facetExpression in the choiceValue in columnName. For example, to create facet counts for the following table, we could generate a new column based on \u201cGift\u201d and enter in `value.facetCount(\"value\", \"Gift\")`. This would add the column we've named \u201cCount\u201d:\n+\n+| Gift | Recipient | Price | Count |\n+|-|-|-|-|\n+| lamp | Mary | 20 | 1 |\n+| clock | John | 57 | 2 |\n+| watch | Amit | 80 | 1 |\n+| clock | Claire | 62 | 2 |\n+\n+The facet expression, wrapped in quotes, can be useful to manipulate the inputted values before counting. For example, you could do a textual cleanup using fingerprint(): `(value.fingerprint()).facetCount(value.fingerprint(),\"Gift\")`.\n+\n+###### hasField(o, s name)\n+Returns a boolean indicating whether o has a member field called name. For example, `cell.recon.hasField(\"match\")` will return false if a reconciliation match hasn\u2019t been selected yet, or true if it does. You cannot chain your desired fields: for example, `cell.hasField(\u201crecon.match\u201d)` will return false even if the above expression returns true).\n+\n+###### coalesce(o1, o2, o3, ...)\n+Returns the first non-null from a series of values of any kind. For example, `coalesce(value, \"\")` would return an empty string \u201c\u201d if the value was null, but otherwise return the value.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwMDM2OA=="}, "originalCommit": {"oid": "91b0bca29f37c00090ad5d43d2a78d45a60c5fab"}, "originalPosition": 535}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyOTg0NDIzOnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwOTo1Mjo0OFrOH6TyAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNDo1OToyNlrOH6e1_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwMzU1Mw==", "bodyText": "This is linking to a javascript function - which isn't used by OpenRefine. I'm not sure we need to state what code is used by OpenRefine here anyway?", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r530903553", "createdAt": "2020-11-26T09:52:48Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,547 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator string (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \u201casdfsd\u201d into a date or a number, but you can convert the number \u201c123\u201d into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \u201cnull\u201d.\n+\n+### Testing string characteristics\n+\n+###### startsWith(s, sub)\n+\n+Returns a boolean indicating whether s starts with sub. For example, `\"food\".startsWith(\"foo\")` returns true, whereas `\"food\".startsWith(\"bar\")` returns false. \n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\"food\".endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase: a capital letter starting each word, and the rest of the letters lowercase. For example, `\"Once upon a midnight DREARY\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string \u201chard\u201d.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(0, -1)` returns the string \u201cprofoun\u201d.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \u201ca\u201d).\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"T\u00e9xt th\u00e1t was opt\u00edc\u00e1lly rec\u00f3gn\u00edz\u00e9d\".replaceChars(\"\u00e1\u00e9\u00ed\u00f3\u00fa\", \"aeiou\")` returns the string \u201cText that was optically recognized\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### find(s, sub or p)\n+\n+Outputs an array of all consecutive substrings inside string s that match the substring or [regex](#grel-supported-regex) pattern p. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in the array [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a sub instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \"fine is\" ].\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, outputs an array of all [capturing groups](https://www.regular-expressions.info/brackets.html) (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [ \"3480\" ]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to store it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to escape characters and use parentheses as needed. Parentheses are required to denote a desired substring (capturing group); for example, \u201c.&#42;(\\d\\d\\d\\d)\u201d would return an array containing a single value, while \u201c(.&#42;)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the value is \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|`value.match(/\\d{6}/)` |null (does not match the full string)|\n+|`value.match(/.*\\d{6}.*/)` |[ ] (no indicated substring)|\n+|`value.match(/.*(\\d{6}).*/)` |[ \"123456\" ] (array with one value)|\n+|`value.match(/(.*)(\\d{6})(.*)/)` |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+### String parsing and splitting\n+\n+###### toNumber(s)\n+\n+Returns a string converted to a number. Will attempt to convert other formats into a string, then into a number. If the value is already a number, it will return the number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by sep. The separator can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\", \" air\" ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ \"inter\", \"nation\", \"ali\" ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\"HenryCTaylor\".splitByCharType()` will result in an array of [ \"H\", \"enry\", \"CT\", \"aylor\" ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ \"BE\", \"1\", \"A\", \"3\", \"E\" ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ \"inter\", \"nation\", \"alization\" ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ \"par\", \"a\", \"llel\" ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1, s2, s timeUnit (optional))\n+\n+Takes two strings and compares them, returning a string. Returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". Also works with dates; see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. \n+\n+###### md5(o)\n+\n+Returns the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of an object. If fed something other than a string (array, number, date, etc.), md5() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".md5()` will return 2c55a1626e31b4e373ceedaa9adc12a3.\n+\n+###### sha1(o)\n+\n+Returns the [SHA-1 hash](https://en.wikipedia.org/wiki/SHA-1) of an object. If fed something other than a string (array, number, date, etc.), sha1() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".sha1()` will return cd05286ee0ff8a830dbdc0c24f1cb68b83b0ef36.\n+\n+###### phonetic(s, s encoding)\n+\n+Returns a phonetic encoding of a string, based on an available phonetic algorithm. See the [section on phonetic clustering](cellediting#clustering-methods) for more information. Can be one of the following supported phonetic methods: [metaphone, doublemetaphone, metaphone3](https://www.wikipedia.org/wiki/Metaphone), [soundex](https://en.wikipedia.org/wiki/Soundex), [cologne](https://en.wikipedia.org/wiki/Cologne_phonetics). Quotes are required around your encoding method. For example, `\"Ruth Prawer Jhabvala\".phonetic(\"metaphone\")` outputs the string \u201cR0PRWRJHBFL\u201d.  \n+\n+###### reinterpret(s, s encoder)\n+\n+Returns s reinterpreted through the given character encoder. You must supply one of the [supported encodings](http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html). Note that quotes are required around your character encoder.\n+\n+When an OpenRefine project is started, data is imported and interpreted. A specific character encoding is identified or manually selected at that time (such as UTF-8). You can reinterpret a column into another specificed encoding using this function. This function may not fix your data; it may be better to use this in conjunction with new projects to test the interpretation, and pre-format your data as needed. \n+\n+###### fingerprint(s)\n+\n+Returns the fingerprint of s, a string that is the first step in [fingerprint clustering methods](cellediting#clustering-methods): it will trim whitespaces, convert all characters to lowercase, remove punctuation, sort words alphabetically, etc. For example, `\"Ruth  Prawer    Jhabvala\".fingerprint()` outputs the string \u201cjhabvala prawer ruth\u201d.\n+\n+###### ngram(s, n)\n+\n+Returns an array of the word n-grams of s. That is, it lists all the possible consecutive combinations of n words in the string. For example, `\"Ruth Prawer Jhabvala\".ngram(2)` would output the array [ \"Ruth Prawer\", \"Prawer Jhabvala\" ]. A word n-gram of 1 simply lists all the words in original order; an n-gram larger than the number of words in the string will only return the original string inside an array (e.g. `\"Ruth Prawer Jhabvala\".ngram(4)` would simply return [\"Ruth Prawer Jhabvala\"]).\n+\n+###### ngramFingerprint(s, n)\n+\n+Returns the [n-gram fingerprint](cellediting#clustering-methods) of s. For example, `\"banana\".ngram(2)` would output \u201canbana\u201d, after first generating the 2-grams \u201cba an na an na\u201d, removing duplicates, and sorting them alphabetically.\n+\n+###### unicode(s)\n+\n+Returns an array of strings describing each character of s in their full unicode notation. For example, `\"Bernice Rubens\".unicode()` outputs [ 66, 101, 114, 110, 105, 99, 101, 32, 82, 117, 98, 101, 110, 115 ].\n+\n+###### unicodeType(s)\n+\n+Returns an array of strings describing each character of s by their unicode type. For example, `\"Bernice Rubens\".unicodeType()` outputs [ \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"space separator\", \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\" ].\n+\n+## Format-based functions (JSON, HTML, XML)\n+\n+###### jsonize(o)\n+\n+Quotes a value as a JSON literal value.\n+\n+###### parseJson(s)\n+\n+Parses a string as JSON. get() can then be used with parseJson(): for example, `parseJson(\" { 'a' : 1 } \").get(\"a\")` returns 1.\n+\n+For example from the following JSON array, let's get all instances called \u201ckeywords\u201d having the same object string name of \u201ctext\u201d, and combine it with the forEach() function to iterate over the array.\n+\n+    {\n+       \"status\":\"OK\",\n+       \"url\":\"\",\n+       \"language\":\"english\",\n+       \"keywords\":[\n+          {\n+             \"text\":\"York en route\",\n+             \"relevance\":\"0.974363\"\n+          },\n+          {\n+             \"text\":\"Anthony Eden\",\n+             \"relevance\":\"0.814394\"\n+          },\n+          {\n+             \"text\":\"President Eisenhower\",\n+             \"relevance\":\"0.700189\"\n+          }\n+       ]\n+    }\n+\n+The GREL expression `forEach(value.parseJson().keywords,v,v.text).join(\":::\")` will output \u201cYork en route:::Anthony Eden:::President Eisenhower\u201d.\n+\n+### Jsoup XML and HTML parsing\n+\n+###### parseHtml(s)\n+Given a cell full of HTML-formatted text, simplifies HTML tags (such as by removing \u201c /\u201d at the end of self-closing tags), closes any unclosed tags, and inserts linebreaks and indents for cleaner code. You cannot pass parseHtml() a URL, but you can pre-fetch HTML with the <span class=\"menuItems\">Add column by fetching URLs</span> menu option. A cell cannot store the output of parseHtml() unless you convert it with toString(). \n+\n+When parseHtml() simplifies HTML, it can sometimes introduce errors. When closing tags, it makes its best guesses based on line breaks, indentation, and the presence of other tags. You may need to manually check the results. \n+\n+You can then extract or select() which portions of the HTML document you need for further splitting, partitioning, etc. An example of extracting all table rows from a div using parseHtml().select() together is described more in depth at [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+###### parseXml(s)\n+Given a cell full of XML-formatted text, returns a full XML document and adds any missing closing tags. You can then extract or select() which portions of the XML document you need for further splitting, partitioning, etc. Functions the same way as parseHtml() is described above. \n+\n+###### select(s, element)\n+Returns an array of all the desired elements from an HTML or XML document, if the element exists. Elements are identified using the [Jsoup selector syntax](https://jsoup.org/apidocs/org/jsoup/select/Selector.html). For example, `value.parseHtml().select(\"img.portrait\")[0]` would return the entirety of the first \u201cimg\u201d tag with the \u201cportrait\u201d class found in the parsed HTML inside `value`. Returns an empty array if no matching element is found. Use with toString() to capture the results in a cell. A tutorial of select() is shown in [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+You can use select() more than once:\n+\n+```\n+value.parseHtml().select(\"div#content\")[0].select(\"tr\").toString()\n+```\n+\n+###### htmlAttr(s, element)\n+Returns a string from an attribute on an HTML element. Use it in conjunction with parseHtml() as in the following example: `value.parseHtml().select(\"a.email\")[0].htmlAttr(\"href\")`.\n+\n+###### xmlAttr(s, element)\n+Returns a string from an attribute on an XML element. Function the same way htmlAttr() is described above. Use it in conjunction with parseXml().\n+\n+###### htmlText(element)\n+Returns a string of the text from within an HTML element (including all child elements), removing HTML tags and line breaks inside the string. Use it in conjunction with parseHtml() and select() to provide an element, as in the following example: `value.parseHtml().select(\"div.footer\")[0].htmlText()`. \n+\n+###### xmlText(element)\n+Returns a string of the text from within an XML element (including all child elements). Functions the same way as htmlText() is described above. Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### wholeText(element)\n+\n+_Works from OpenRefine 3.4.1 beta 644 onwards only_\n+\n+Selects the (unencoded) text of an element and its children, including any newlines and spaces, and returns a string of unencoded, un-normalized text. Use it in conjunction with parseHtml() and select() to provide an element as in the following example: `value.parseHtml().select(\"div.footer\")[0].wholeText()`.\n+\n+###### innerHtml(element)\n+Returns the [inner HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) of an HTML element. This will include text and children elements within the element selected. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### innerXml(element)\n+Returns all the inner XML elements inside your chosen XML element. Does not return the text directly inside your chosen XML element - only the contents of its children. To select the direct text, use ownText(). To select both, use xmlText(). Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### outerHtml(element)\n+Returns the [outer HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/outerHTML) of an HTML element. outerHtml includes the start and end tags of the current element. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### ownText(element)\n+Returns the text directly inside the selected XML or HTML element only, ignoring text inside children elements. Use it in conjunction with a parser and select() to provide an element.\n+\n+## Array functions\n+\n+###### length(a)\n+Returns the size of an array, meaning the number of objects inside it. Arrays can be empty, in which case length() will return 0. \n+\n+###### slice(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. If to is omitted, it is understood to be the end of the array. For example, `[0, 1, 2, 3, 4].slice(1, 3)` returns [ 1, 2 ], and `[ 0, 1, 2, 3, 4].slice(1)` returns [ 1, 2, 3, 4 ]. Also works with strings; see [String functions](#slices-n-from-n-to-optional).\n+\n+###### get(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. \n+\n+If to is omitted, only one array item is returned, as a string, instead of a sub-array. To return a sub-array from one index to the end, you can set the to argument to a very high number such as `value.get(2,999)` or you can use something like `with(value,a,a.get(1,a.length()))` to count the length of each array.\n+\n+Also works with strings; see [get() in String functions](#gets-n-from-n-to-optional).\n+\n+###### inArray(a, s)\n+Returns true if the array contains the desired string, and false otherwise.\n+\n+###### reverse(a)\n+Reverses the array. For example, `[ 0, 1, 2, 3].reverse()` returns the array [ 3, 2, 1, 0 ].\n+\n+###### sort(a)\n+Sorts the array in ascending order. Sorting is case-sensitive, uppercase first and lowercase second. For example, `[ \"al\", \"Joe\", \"Bob\", \"jim\" ].sort()` returns the array [ \"Bob\", \"Joe\", \"al\", \"jim\" ]. \n+\n+###### sum(a)\n+Return the sum of the numbers in the array. For example, `[ 2, 1, 0, 3].sum()` returns 6.\n+\n+###### join(a, sep)\n+Joins the items in the array with sep, and returns it all as a string. For example, `[ \"and\", \"or\", \"not\" ].join(\"/\")` returns the string \u201cand/or/not\u201d.\n+\n+###### uniques(a)\n+Returns the array with duplicates removed. Case-sensitive. For example, `[ \"al\", \"Joe\", \"Bob\", \"Joe\", \"Al\", \"Bob\" ].uniques()` returns the array [ \"Joe\", \"al\", \"Al\", \"Bob\" ]. \n+\n+As of OpenRefine 3.4.1, uniques() reorders the array items it returns; in 3.4 beta 644 and onwards, it preserves the original order (in this case, [ \"al\", \"Joe\", \"Bob\", \"Al\" ]). \n+\n+## Date functions\n+If you have a column full of dates in a more common format (such as yyyy/mm/dd or YYYYMMDD) you can convert these using [\u201cTransform\u201d > \u201cCommon transforms \u2026\u201d > \u201cto date\u201d](cellediting#data-type-transforms), or the GREL function toDate(). You may wish to create a new column with the transformation, in order to also preserve the more human-readable version.\n+\n+OpenRefine uses [Date.parse()](https://www.w3schools.com/jsref/jsref_parse.asp) to recognize a variety of formats and convert them, including converting from other time zones to UTC:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91b0bca29f37c00090ad5d43d2a78d45a60c5fab"}, "originalPosition": 382}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA0Mzc1Mg==", "bodyText": "This could be moved or linked to some reference point in the Technical docs when concerning the frontend UI.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r531043752", "createdAt": "2020-11-26T13:53:18Z", "author": {"login": "thadguidry"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,547 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator string (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \u201casdfsd\u201d into a date or a number, but you can convert the number \u201c123\u201d into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \u201cnull\u201d.\n+\n+### Testing string characteristics\n+\n+###### startsWith(s, sub)\n+\n+Returns a boolean indicating whether s starts with sub. For example, `\"food\".startsWith(\"foo\")` returns true, whereas `\"food\".startsWith(\"bar\")` returns false. \n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\"food\".endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase: a capital letter starting each word, and the rest of the letters lowercase. For example, `\"Once upon a midnight DREARY\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string \u201chard\u201d.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(0, -1)` returns the string \u201cprofoun\u201d.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \u201ca\u201d).\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"T\u00e9xt th\u00e1t was opt\u00edc\u00e1lly rec\u00f3gn\u00edz\u00e9d\".replaceChars(\"\u00e1\u00e9\u00ed\u00f3\u00fa\", \"aeiou\")` returns the string \u201cText that was optically recognized\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### find(s, sub or p)\n+\n+Outputs an array of all consecutive substrings inside string s that match the substring or [regex](#grel-supported-regex) pattern p. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in the array [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a sub instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \"fine is\" ].\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, outputs an array of all [capturing groups](https://www.regular-expressions.info/brackets.html) (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [ \"3480\" ]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to store it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to escape characters and use parentheses as needed. Parentheses are required to denote a desired substring (capturing group); for example, \u201c.&#42;(\\d\\d\\d\\d)\u201d would return an array containing a single value, while \u201c(.&#42;)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the value is \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|`value.match(/\\d{6}/)` |null (does not match the full string)|\n+|`value.match(/.*\\d{6}.*/)` |[ ] (no indicated substring)|\n+|`value.match(/.*(\\d{6}).*/)` |[ \"123456\" ] (array with one value)|\n+|`value.match(/(.*)(\\d{6})(.*)/)` |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+### String parsing and splitting\n+\n+###### toNumber(s)\n+\n+Returns a string converted to a number. Will attempt to convert other formats into a string, then into a number. If the value is already a number, it will return the number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by sep. The separator can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\", \" air\" ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ \"inter\", \"nation\", \"ali\" ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\"HenryCTaylor\".splitByCharType()` will result in an array of [ \"H\", \"enry\", \"CT\", \"aylor\" ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ \"BE\", \"1\", \"A\", \"3\", \"E\" ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ \"inter\", \"nation\", \"alization\" ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ \"par\", \"a\", \"llel\" ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1, s2, s timeUnit (optional))\n+\n+Takes two strings and compares them, returning a string. Returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". Also works with dates; see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. \n+\n+###### md5(o)\n+\n+Returns the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of an object. If fed something other than a string (array, number, date, etc.), md5() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".md5()` will return 2c55a1626e31b4e373ceedaa9adc12a3.\n+\n+###### sha1(o)\n+\n+Returns the [SHA-1 hash](https://en.wikipedia.org/wiki/SHA-1) of an object. If fed something other than a string (array, number, date, etc.), sha1() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".sha1()` will return cd05286ee0ff8a830dbdc0c24f1cb68b83b0ef36.\n+\n+###### phonetic(s, s encoding)\n+\n+Returns a phonetic encoding of a string, based on an available phonetic algorithm. See the [section on phonetic clustering](cellediting#clustering-methods) for more information. Can be one of the following supported phonetic methods: [metaphone, doublemetaphone, metaphone3](https://www.wikipedia.org/wiki/Metaphone), [soundex](https://en.wikipedia.org/wiki/Soundex), [cologne](https://en.wikipedia.org/wiki/Cologne_phonetics). Quotes are required around your encoding method. For example, `\"Ruth Prawer Jhabvala\".phonetic(\"metaphone\")` outputs the string \u201cR0PRWRJHBFL\u201d.  \n+\n+###### reinterpret(s, s encoder)\n+\n+Returns s reinterpreted through the given character encoder. You must supply one of the [supported encodings](http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html). Note that quotes are required around your character encoder.\n+\n+When an OpenRefine project is started, data is imported and interpreted. A specific character encoding is identified or manually selected at that time (such as UTF-8). You can reinterpret a column into another specificed encoding using this function. This function may not fix your data; it may be better to use this in conjunction with new projects to test the interpretation, and pre-format your data as needed. \n+\n+###### fingerprint(s)\n+\n+Returns the fingerprint of s, a string that is the first step in [fingerprint clustering methods](cellediting#clustering-methods): it will trim whitespaces, convert all characters to lowercase, remove punctuation, sort words alphabetically, etc. For example, `\"Ruth  Prawer    Jhabvala\".fingerprint()` outputs the string \u201cjhabvala prawer ruth\u201d.\n+\n+###### ngram(s, n)\n+\n+Returns an array of the word n-grams of s. That is, it lists all the possible consecutive combinations of n words in the string. For example, `\"Ruth Prawer Jhabvala\".ngram(2)` would output the array [ \"Ruth Prawer\", \"Prawer Jhabvala\" ]. A word n-gram of 1 simply lists all the words in original order; an n-gram larger than the number of words in the string will only return the original string inside an array (e.g. `\"Ruth Prawer Jhabvala\".ngram(4)` would simply return [\"Ruth Prawer Jhabvala\"]).\n+\n+###### ngramFingerprint(s, n)\n+\n+Returns the [n-gram fingerprint](cellediting#clustering-methods) of s. For example, `\"banana\".ngram(2)` would output \u201canbana\u201d, after first generating the 2-grams \u201cba an na an na\u201d, removing duplicates, and sorting them alphabetically.\n+\n+###### unicode(s)\n+\n+Returns an array of strings describing each character of s in their full unicode notation. For example, `\"Bernice Rubens\".unicode()` outputs [ 66, 101, 114, 110, 105, 99, 101, 32, 82, 117, 98, 101, 110, 115 ].\n+\n+###### unicodeType(s)\n+\n+Returns an array of strings describing each character of s by their unicode type. For example, `\"Bernice Rubens\".unicodeType()` outputs [ \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"space separator\", \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\" ].\n+\n+## Format-based functions (JSON, HTML, XML)\n+\n+###### jsonize(o)\n+\n+Quotes a value as a JSON literal value.\n+\n+###### parseJson(s)\n+\n+Parses a string as JSON. get() can then be used with parseJson(): for example, `parseJson(\" { 'a' : 1 } \").get(\"a\")` returns 1.\n+\n+For example from the following JSON array, let's get all instances called \u201ckeywords\u201d having the same object string name of \u201ctext\u201d, and combine it with the forEach() function to iterate over the array.\n+\n+    {\n+       \"status\":\"OK\",\n+       \"url\":\"\",\n+       \"language\":\"english\",\n+       \"keywords\":[\n+          {\n+             \"text\":\"York en route\",\n+             \"relevance\":\"0.974363\"\n+          },\n+          {\n+             \"text\":\"Anthony Eden\",\n+             \"relevance\":\"0.814394\"\n+          },\n+          {\n+             \"text\":\"President Eisenhower\",\n+             \"relevance\":\"0.700189\"\n+          }\n+       ]\n+    }\n+\n+The GREL expression `forEach(value.parseJson().keywords,v,v.text).join(\":::\")` will output \u201cYork en route:::Anthony Eden:::President Eisenhower\u201d.\n+\n+### Jsoup XML and HTML parsing\n+\n+###### parseHtml(s)\n+Given a cell full of HTML-formatted text, simplifies HTML tags (such as by removing \u201c /\u201d at the end of self-closing tags), closes any unclosed tags, and inserts linebreaks and indents for cleaner code. You cannot pass parseHtml() a URL, but you can pre-fetch HTML with the <span class=\"menuItems\">Add column by fetching URLs</span> menu option. A cell cannot store the output of parseHtml() unless you convert it with toString(). \n+\n+When parseHtml() simplifies HTML, it can sometimes introduce errors. When closing tags, it makes its best guesses based on line breaks, indentation, and the presence of other tags. You may need to manually check the results. \n+\n+You can then extract or select() which portions of the HTML document you need for further splitting, partitioning, etc. An example of extracting all table rows from a div using parseHtml().select() together is described more in depth at [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+###### parseXml(s)\n+Given a cell full of XML-formatted text, returns a full XML document and adds any missing closing tags. You can then extract or select() which portions of the XML document you need for further splitting, partitioning, etc. Functions the same way as parseHtml() is described above. \n+\n+###### select(s, element)\n+Returns an array of all the desired elements from an HTML or XML document, if the element exists. Elements are identified using the [Jsoup selector syntax](https://jsoup.org/apidocs/org/jsoup/select/Selector.html). For example, `value.parseHtml().select(\"img.portrait\")[0]` would return the entirety of the first \u201cimg\u201d tag with the \u201cportrait\u201d class found in the parsed HTML inside `value`. Returns an empty array if no matching element is found. Use with toString() to capture the results in a cell. A tutorial of select() is shown in [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+You can use select() more than once:\n+\n+```\n+value.parseHtml().select(\"div#content\")[0].select(\"tr\").toString()\n+```\n+\n+###### htmlAttr(s, element)\n+Returns a string from an attribute on an HTML element. Use it in conjunction with parseHtml() as in the following example: `value.parseHtml().select(\"a.email\")[0].htmlAttr(\"href\")`.\n+\n+###### xmlAttr(s, element)\n+Returns a string from an attribute on an XML element. Function the same way htmlAttr() is described above. Use it in conjunction with parseXml().\n+\n+###### htmlText(element)\n+Returns a string of the text from within an HTML element (including all child elements), removing HTML tags and line breaks inside the string. Use it in conjunction with parseHtml() and select() to provide an element, as in the following example: `value.parseHtml().select(\"div.footer\")[0].htmlText()`. \n+\n+###### xmlText(element)\n+Returns a string of the text from within an XML element (including all child elements). Functions the same way as htmlText() is described above. Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### wholeText(element)\n+\n+_Works from OpenRefine 3.4.1 beta 644 onwards only_\n+\n+Selects the (unencoded) text of an element and its children, including any newlines and spaces, and returns a string of unencoded, un-normalized text. Use it in conjunction with parseHtml() and select() to provide an element as in the following example: `value.parseHtml().select(\"div.footer\")[0].wholeText()`.\n+\n+###### innerHtml(element)\n+Returns the [inner HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) of an HTML element. This will include text and children elements within the element selected. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### innerXml(element)\n+Returns all the inner XML elements inside your chosen XML element. Does not return the text directly inside your chosen XML element - only the contents of its children. To select the direct text, use ownText(). To select both, use xmlText(). Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### outerHtml(element)\n+Returns the [outer HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/outerHTML) of an HTML element. outerHtml includes the start and end tags of the current element. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### ownText(element)\n+Returns the text directly inside the selected XML or HTML element only, ignoring text inside children elements. Use it in conjunction with a parser and select() to provide an element.\n+\n+## Array functions\n+\n+###### length(a)\n+Returns the size of an array, meaning the number of objects inside it. Arrays can be empty, in which case length() will return 0. \n+\n+###### slice(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. If to is omitted, it is understood to be the end of the array. For example, `[0, 1, 2, 3, 4].slice(1, 3)` returns [ 1, 2 ], and `[ 0, 1, 2, 3, 4].slice(1)` returns [ 1, 2, 3, 4 ]. Also works with strings; see [String functions](#slices-n-from-n-to-optional).\n+\n+###### get(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. \n+\n+If to is omitted, only one array item is returned, as a string, instead of a sub-array. To return a sub-array from one index to the end, you can set the to argument to a very high number such as `value.get(2,999)` or you can use something like `with(value,a,a.get(1,a.length()))` to count the length of each array.\n+\n+Also works with strings; see [get() in String functions](#gets-n-from-n-to-optional).\n+\n+###### inArray(a, s)\n+Returns true if the array contains the desired string, and false otherwise.\n+\n+###### reverse(a)\n+Reverses the array. For example, `[ 0, 1, 2, 3].reverse()` returns the array [ 3, 2, 1, 0 ].\n+\n+###### sort(a)\n+Sorts the array in ascending order. Sorting is case-sensitive, uppercase first and lowercase second. For example, `[ \"al\", \"Joe\", \"Bob\", \"jim\" ].sort()` returns the array [ \"Bob\", \"Joe\", \"al\", \"jim\" ]. \n+\n+###### sum(a)\n+Return the sum of the numbers in the array. For example, `[ 2, 1, 0, 3].sum()` returns 6.\n+\n+###### join(a, sep)\n+Joins the items in the array with sep, and returns it all as a string. For example, `[ \"and\", \"or\", \"not\" ].join(\"/\")` returns the string \u201cand/or/not\u201d.\n+\n+###### uniques(a)\n+Returns the array with duplicates removed. Case-sensitive. For example, `[ \"al\", \"Joe\", \"Bob\", \"Joe\", \"Al\", \"Bob\" ].uniques()` returns the array [ \"Joe\", \"al\", \"Al\", \"Bob\" ]. \n+\n+As of OpenRefine 3.4.1, uniques() reorders the array items it returns; in 3.4 beta 644 and onwards, it preserves the original order (in this case, [ \"al\", \"Joe\", \"Bob\", \"Al\" ]). \n+\n+## Date functions\n+If you have a column full of dates in a more common format (such as yyyy/mm/dd or YYYYMMDD) you can convert these using [\u201cTransform\u201d > \u201cCommon transforms \u2026\u201d > \u201cto date\u201d](cellediting#data-type-transforms), or the GREL function toDate(). You may wish to create a new column with the transformation, in order to also preserve the more human-readable version.\n+\n+OpenRefine uses [Date.parse()](https://www.w3schools.com/jsref/jsref_parse.asp) to recognize a variety of formats and convert them, including converting from other time zones to UTC:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwMzU1Mw=="}, "originalCommit": {"oid": "91b0bca29f37c00090ad5d43d2a78d45a60c5fab"}, "originalPosition": 382}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA4NDc5OQ==", "bodyText": "My bad - which date.parse() are we using? I would link to it since generally their explanations are more expansive than we want to get.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r531084799", "createdAt": "2020-11-26T14:59:26Z", "author": {"login": "allanaaa"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,547 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator string (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \u201casdfsd\u201d into a date or a number, but you can convert the number \u201c123\u201d into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \u201cnull\u201d.\n+\n+### Testing string characteristics\n+\n+###### startsWith(s, sub)\n+\n+Returns a boolean indicating whether s starts with sub. For example, `\"food\".startsWith(\"foo\")` returns true, whereas `\"food\".startsWith(\"bar\")` returns false. \n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\"food\".endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase: a capital letter starting each word, and the rest of the letters lowercase. For example, `\"Once upon a midnight DREARY\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string \u201chard\u201d.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(0, -1)` returns the string \u201cprofoun\u201d.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \u201ca\u201d).\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"T\u00e9xt th\u00e1t was opt\u00edc\u00e1lly rec\u00f3gn\u00edz\u00e9d\".replaceChars(\"\u00e1\u00e9\u00ed\u00f3\u00fa\", \"aeiou\")` returns the string \u201cText that was optically recognized\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### find(s, sub or p)\n+\n+Outputs an array of all consecutive substrings inside string s that match the substring or [regex](#grel-supported-regex) pattern p. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in the array [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a sub instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \"fine is\" ].\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, outputs an array of all [capturing groups](https://www.regular-expressions.info/brackets.html) (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [ \"3480\" ]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to store it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to escape characters and use parentheses as needed. Parentheses are required to denote a desired substring (capturing group); for example, \u201c.&#42;(\\d\\d\\d\\d)\u201d would return an array containing a single value, while \u201c(.&#42;)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the value is \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|`value.match(/\\d{6}/)` |null (does not match the full string)|\n+|`value.match(/.*\\d{6}.*/)` |[ ] (no indicated substring)|\n+|`value.match(/.*(\\d{6}).*/)` |[ \"123456\" ] (array with one value)|\n+|`value.match(/(.*)(\\d{6})(.*)/)` |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+### String parsing and splitting\n+\n+###### toNumber(s)\n+\n+Returns a string converted to a number. Will attempt to convert other formats into a string, then into a number. If the value is already a number, it will return the number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by sep. The separator can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\", \" air\" ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ \"inter\", \"nation\", \"ali\" ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\"HenryCTaylor\".splitByCharType()` will result in an array of [ \"H\", \"enry\", \"CT\", \"aylor\" ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ \"BE\", \"1\", \"A\", \"3\", \"E\" ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ \"inter\", \"nation\", \"alization\" ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ \"par\", \"a\", \"llel\" ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1, s2, s timeUnit (optional))\n+\n+Takes two strings and compares them, returning a string. Returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". Also works with dates; see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. \n+\n+###### md5(o)\n+\n+Returns the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of an object. If fed something other than a string (array, number, date, etc.), md5() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".md5()` will return 2c55a1626e31b4e373ceedaa9adc12a3.\n+\n+###### sha1(o)\n+\n+Returns the [SHA-1 hash](https://en.wikipedia.org/wiki/SHA-1) of an object. If fed something other than a string (array, number, date, etc.), sha1() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".sha1()` will return cd05286ee0ff8a830dbdc0c24f1cb68b83b0ef36.\n+\n+###### phonetic(s, s encoding)\n+\n+Returns a phonetic encoding of a string, based on an available phonetic algorithm. See the [section on phonetic clustering](cellediting#clustering-methods) for more information. Can be one of the following supported phonetic methods: [metaphone, doublemetaphone, metaphone3](https://www.wikipedia.org/wiki/Metaphone), [soundex](https://en.wikipedia.org/wiki/Soundex), [cologne](https://en.wikipedia.org/wiki/Cologne_phonetics). Quotes are required around your encoding method. For example, `\"Ruth Prawer Jhabvala\".phonetic(\"metaphone\")` outputs the string \u201cR0PRWRJHBFL\u201d.  \n+\n+###### reinterpret(s, s encoder)\n+\n+Returns s reinterpreted through the given character encoder. You must supply one of the [supported encodings](http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html). Note that quotes are required around your character encoder.\n+\n+When an OpenRefine project is started, data is imported and interpreted. A specific character encoding is identified or manually selected at that time (such as UTF-8). You can reinterpret a column into another specificed encoding using this function. This function may not fix your data; it may be better to use this in conjunction with new projects to test the interpretation, and pre-format your data as needed. \n+\n+###### fingerprint(s)\n+\n+Returns the fingerprint of s, a string that is the first step in [fingerprint clustering methods](cellediting#clustering-methods): it will trim whitespaces, convert all characters to lowercase, remove punctuation, sort words alphabetically, etc. For example, `\"Ruth  Prawer    Jhabvala\".fingerprint()` outputs the string \u201cjhabvala prawer ruth\u201d.\n+\n+###### ngram(s, n)\n+\n+Returns an array of the word n-grams of s. That is, it lists all the possible consecutive combinations of n words in the string. For example, `\"Ruth Prawer Jhabvala\".ngram(2)` would output the array [ \"Ruth Prawer\", \"Prawer Jhabvala\" ]. A word n-gram of 1 simply lists all the words in original order; an n-gram larger than the number of words in the string will only return the original string inside an array (e.g. `\"Ruth Prawer Jhabvala\".ngram(4)` would simply return [\"Ruth Prawer Jhabvala\"]).\n+\n+###### ngramFingerprint(s, n)\n+\n+Returns the [n-gram fingerprint](cellediting#clustering-methods) of s. For example, `\"banana\".ngram(2)` would output \u201canbana\u201d, after first generating the 2-grams \u201cba an na an na\u201d, removing duplicates, and sorting them alphabetically.\n+\n+###### unicode(s)\n+\n+Returns an array of strings describing each character of s in their full unicode notation. For example, `\"Bernice Rubens\".unicode()` outputs [ 66, 101, 114, 110, 105, 99, 101, 32, 82, 117, 98, 101, 110, 115 ].\n+\n+###### unicodeType(s)\n+\n+Returns an array of strings describing each character of s by their unicode type. For example, `\"Bernice Rubens\".unicodeType()` outputs [ \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"space separator\", \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\" ].\n+\n+## Format-based functions (JSON, HTML, XML)\n+\n+###### jsonize(o)\n+\n+Quotes a value as a JSON literal value.\n+\n+###### parseJson(s)\n+\n+Parses a string as JSON. get() can then be used with parseJson(): for example, `parseJson(\" { 'a' : 1 } \").get(\"a\")` returns 1.\n+\n+For example from the following JSON array, let's get all instances called \u201ckeywords\u201d having the same object string name of \u201ctext\u201d, and combine it with the forEach() function to iterate over the array.\n+\n+    {\n+       \"status\":\"OK\",\n+       \"url\":\"\",\n+       \"language\":\"english\",\n+       \"keywords\":[\n+          {\n+             \"text\":\"York en route\",\n+             \"relevance\":\"0.974363\"\n+          },\n+          {\n+             \"text\":\"Anthony Eden\",\n+             \"relevance\":\"0.814394\"\n+          },\n+          {\n+             \"text\":\"President Eisenhower\",\n+             \"relevance\":\"0.700189\"\n+          }\n+       ]\n+    }\n+\n+The GREL expression `forEach(value.parseJson().keywords,v,v.text).join(\":::\")` will output \u201cYork en route:::Anthony Eden:::President Eisenhower\u201d.\n+\n+### Jsoup XML and HTML parsing\n+\n+###### parseHtml(s)\n+Given a cell full of HTML-formatted text, simplifies HTML tags (such as by removing \u201c /\u201d at the end of self-closing tags), closes any unclosed tags, and inserts linebreaks and indents for cleaner code. You cannot pass parseHtml() a URL, but you can pre-fetch HTML with the <span class=\"menuItems\">Add column by fetching URLs</span> menu option. A cell cannot store the output of parseHtml() unless you convert it with toString(). \n+\n+When parseHtml() simplifies HTML, it can sometimes introduce errors. When closing tags, it makes its best guesses based on line breaks, indentation, and the presence of other tags. You may need to manually check the results. \n+\n+You can then extract or select() which portions of the HTML document you need for further splitting, partitioning, etc. An example of extracting all table rows from a div using parseHtml().select() together is described more in depth at [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+###### parseXml(s)\n+Given a cell full of XML-formatted text, returns a full XML document and adds any missing closing tags. You can then extract or select() which portions of the XML document you need for further splitting, partitioning, etc. Functions the same way as parseHtml() is described above. \n+\n+###### select(s, element)\n+Returns an array of all the desired elements from an HTML or XML document, if the element exists. Elements are identified using the [Jsoup selector syntax](https://jsoup.org/apidocs/org/jsoup/select/Selector.html). For example, `value.parseHtml().select(\"img.portrait\")[0]` would return the entirety of the first \u201cimg\u201d tag with the \u201cportrait\u201d class found in the parsed HTML inside `value`. Returns an empty array if no matching element is found. Use with toString() to capture the results in a cell. A tutorial of select() is shown in [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+You can use select() more than once:\n+\n+```\n+value.parseHtml().select(\"div#content\")[0].select(\"tr\").toString()\n+```\n+\n+###### htmlAttr(s, element)\n+Returns a string from an attribute on an HTML element. Use it in conjunction with parseHtml() as in the following example: `value.parseHtml().select(\"a.email\")[0].htmlAttr(\"href\")`.\n+\n+###### xmlAttr(s, element)\n+Returns a string from an attribute on an XML element. Function the same way htmlAttr() is described above. Use it in conjunction with parseXml().\n+\n+###### htmlText(element)\n+Returns a string of the text from within an HTML element (including all child elements), removing HTML tags and line breaks inside the string. Use it in conjunction with parseHtml() and select() to provide an element, as in the following example: `value.parseHtml().select(\"div.footer\")[0].htmlText()`. \n+\n+###### xmlText(element)\n+Returns a string of the text from within an XML element (including all child elements). Functions the same way as htmlText() is described above. Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### wholeText(element)\n+\n+_Works from OpenRefine 3.4.1 beta 644 onwards only_\n+\n+Selects the (unencoded) text of an element and its children, including any newlines and spaces, and returns a string of unencoded, un-normalized text. Use it in conjunction with parseHtml() and select() to provide an element as in the following example: `value.parseHtml().select(\"div.footer\")[0].wholeText()`.\n+\n+###### innerHtml(element)\n+Returns the [inner HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) of an HTML element. This will include text and children elements within the element selected. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### innerXml(element)\n+Returns all the inner XML elements inside your chosen XML element. Does not return the text directly inside your chosen XML element - only the contents of its children. To select the direct text, use ownText(). To select both, use xmlText(). Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### outerHtml(element)\n+Returns the [outer HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/outerHTML) of an HTML element. outerHtml includes the start and end tags of the current element. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### ownText(element)\n+Returns the text directly inside the selected XML or HTML element only, ignoring text inside children elements. Use it in conjunction with a parser and select() to provide an element.\n+\n+## Array functions\n+\n+###### length(a)\n+Returns the size of an array, meaning the number of objects inside it. Arrays can be empty, in which case length() will return 0. \n+\n+###### slice(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. If to is omitted, it is understood to be the end of the array. For example, `[0, 1, 2, 3, 4].slice(1, 3)` returns [ 1, 2 ], and `[ 0, 1, 2, 3, 4].slice(1)` returns [ 1, 2, 3, 4 ]. Also works with strings; see [String functions](#slices-n-from-n-to-optional).\n+\n+###### get(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. \n+\n+If to is omitted, only one array item is returned, as a string, instead of a sub-array. To return a sub-array from one index to the end, you can set the to argument to a very high number such as `value.get(2,999)` or you can use something like `with(value,a,a.get(1,a.length()))` to count the length of each array.\n+\n+Also works with strings; see [get() in String functions](#gets-n-from-n-to-optional).\n+\n+###### inArray(a, s)\n+Returns true if the array contains the desired string, and false otherwise.\n+\n+###### reverse(a)\n+Reverses the array. For example, `[ 0, 1, 2, 3].reverse()` returns the array [ 3, 2, 1, 0 ].\n+\n+###### sort(a)\n+Sorts the array in ascending order. Sorting is case-sensitive, uppercase first and lowercase second. For example, `[ \"al\", \"Joe\", \"Bob\", \"jim\" ].sort()` returns the array [ \"Bob\", \"Joe\", \"al\", \"jim\" ]. \n+\n+###### sum(a)\n+Return the sum of the numbers in the array. For example, `[ 2, 1, 0, 3].sum()` returns 6.\n+\n+###### join(a, sep)\n+Joins the items in the array with sep, and returns it all as a string. For example, `[ \"and\", \"or\", \"not\" ].join(\"/\")` returns the string \u201cand/or/not\u201d.\n+\n+###### uniques(a)\n+Returns the array with duplicates removed. Case-sensitive. For example, `[ \"al\", \"Joe\", \"Bob\", \"Joe\", \"Al\", \"Bob\" ].uniques()` returns the array [ \"Joe\", \"al\", \"Al\", \"Bob\" ]. \n+\n+As of OpenRefine 3.4.1, uniques() reorders the array items it returns; in 3.4 beta 644 and onwards, it preserves the original order (in this case, [ \"al\", \"Joe\", \"Bob\", \"Al\" ]). \n+\n+## Date functions\n+If you have a column full of dates in a more common format (such as yyyy/mm/dd or YYYYMMDD) you can convert these using [\u201cTransform\u201d > \u201cCommon transforms \u2026\u201d > \u201cto date\u201d](cellediting#data-type-transforms), or the GREL function toDate(). You may wish to create a new column with the transformation, in order to also preserve the more human-readable version.\n+\n+OpenRefine uses [Date.parse()](https://www.w3schools.com/jsref/jsref_parse.asp) to recognize a variety of formats and convert them, including converting from other time zones to UTC:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwMzU1Mw=="}, "originalCommit": {"oid": "91b0bca29f37c00090ad5d43d2a78d45a60c5fab"}, "originalPosition": 382}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyOTg0ODYyOnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwOTo1Mzo0NlrOH6T0qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwOTo1Mzo0NlrOH6T0qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwNDIzMw==", "bodyText": "I'm not sure we need this introduction to dates in OpenRefine here? It feels out of place in the middle of a GREL reference guide (to me)", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r530904233", "createdAt": "2020-11-26T09:53:46Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,547 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator string (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \u201casdfsd\u201d into a date or a number, but you can convert the number \u201c123\u201d into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \u201cnull\u201d.\n+\n+### Testing string characteristics\n+\n+###### startsWith(s, sub)\n+\n+Returns a boolean indicating whether s starts with sub. For example, `\"food\".startsWith(\"foo\")` returns true, whereas `\"food\".startsWith(\"bar\")` returns false. \n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\"food\".endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase: a capital letter starting each word, and the rest of the letters lowercase. For example, `\"Once upon a midnight DREARY\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string \u201chard\u201d.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(0, -1)` returns the string \u201cprofoun\u201d.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \u201ca\u201d).\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"T\u00e9xt th\u00e1t was opt\u00edc\u00e1lly rec\u00f3gn\u00edz\u00e9d\".replaceChars(\"\u00e1\u00e9\u00ed\u00f3\u00fa\", \"aeiou\")` returns the string \u201cText that was optically recognized\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### find(s, sub or p)\n+\n+Outputs an array of all consecutive substrings inside string s that match the substring or [regex](#grel-supported-regex) pattern p. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in the array [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a sub instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \"fine is\" ].\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, outputs an array of all [capturing groups](https://www.regular-expressions.info/brackets.html) (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [ \"3480\" ]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to store it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to escape characters and use parentheses as needed. Parentheses are required to denote a desired substring (capturing group); for example, \u201c.&#42;(\\d\\d\\d\\d)\u201d would return an array containing a single value, while \u201c(.&#42;)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the value is \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|`value.match(/\\d{6}/)` |null (does not match the full string)|\n+|`value.match(/.*\\d{6}.*/)` |[ ] (no indicated substring)|\n+|`value.match(/.*(\\d{6}).*/)` |[ \"123456\" ] (array with one value)|\n+|`value.match(/(.*)(\\d{6})(.*)/)` |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+### String parsing and splitting\n+\n+###### toNumber(s)\n+\n+Returns a string converted to a number. Will attempt to convert other formats into a string, then into a number. If the value is already a number, it will return the number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by sep. The separator can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\", \" air\" ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ \"inter\", \"nation\", \"ali\" ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\"HenryCTaylor\".splitByCharType()` will result in an array of [ \"H\", \"enry\", \"CT\", \"aylor\" ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ \"BE\", \"1\", \"A\", \"3\", \"E\" ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ \"inter\", \"nation\", \"alization\" ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ \"par\", \"a\", \"llel\" ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1, s2, s timeUnit (optional))\n+\n+Takes two strings and compares them, returning a string. Returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". Also works with dates; see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. \n+\n+###### md5(o)\n+\n+Returns the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of an object. If fed something other than a string (array, number, date, etc.), md5() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".md5()` will return 2c55a1626e31b4e373ceedaa9adc12a3.\n+\n+###### sha1(o)\n+\n+Returns the [SHA-1 hash](https://en.wikipedia.org/wiki/SHA-1) of an object. If fed something other than a string (array, number, date, etc.), sha1() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".sha1()` will return cd05286ee0ff8a830dbdc0c24f1cb68b83b0ef36.\n+\n+###### phonetic(s, s encoding)\n+\n+Returns a phonetic encoding of a string, based on an available phonetic algorithm. See the [section on phonetic clustering](cellediting#clustering-methods) for more information. Can be one of the following supported phonetic methods: [metaphone, doublemetaphone, metaphone3](https://www.wikipedia.org/wiki/Metaphone), [soundex](https://en.wikipedia.org/wiki/Soundex), [cologne](https://en.wikipedia.org/wiki/Cologne_phonetics). Quotes are required around your encoding method. For example, `\"Ruth Prawer Jhabvala\".phonetic(\"metaphone\")` outputs the string \u201cR0PRWRJHBFL\u201d.  \n+\n+###### reinterpret(s, s encoder)\n+\n+Returns s reinterpreted through the given character encoder. You must supply one of the [supported encodings](http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html). Note that quotes are required around your character encoder.\n+\n+When an OpenRefine project is started, data is imported and interpreted. A specific character encoding is identified or manually selected at that time (such as UTF-8). You can reinterpret a column into another specificed encoding using this function. This function may not fix your data; it may be better to use this in conjunction with new projects to test the interpretation, and pre-format your data as needed. \n+\n+###### fingerprint(s)\n+\n+Returns the fingerprint of s, a string that is the first step in [fingerprint clustering methods](cellediting#clustering-methods): it will trim whitespaces, convert all characters to lowercase, remove punctuation, sort words alphabetically, etc. For example, `\"Ruth  Prawer    Jhabvala\".fingerprint()` outputs the string \u201cjhabvala prawer ruth\u201d.\n+\n+###### ngram(s, n)\n+\n+Returns an array of the word n-grams of s. That is, it lists all the possible consecutive combinations of n words in the string. For example, `\"Ruth Prawer Jhabvala\".ngram(2)` would output the array [ \"Ruth Prawer\", \"Prawer Jhabvala\" ]. A word n-gram of 1 simply lists all the words in original order; an n-gram larger than the number of words in the string will only return the original string inside an array (e.g. `\"Ruth Prawer Jhabvala\".ngram(4)` would simply return [\"Ruth Prawer Jhabvala\"]).\n+\n+###### ngramFingerprint(s, n)\n+\n+Returns the [n-gram fingerprint](cellediting#clustering-methods) of s. For example, `\"banana\".ngram(2)` would output \u201canbana\u201d, after first generating the 2-grams \u201cba an na an na\u201d, removing duplicates, and sorting them alphabetically.\n+\n+###### unicode(s)\n+\n+Returns an array of strings describing each character of s in their full unicode notation. For example, `\"Bernice Rubens\".unicode()` outputs [ 66, 101, 114, 110, 105, 99, 101, 32, 82, 117, 98, 101, 110, 115 ].\n+\n+###### unicodeType(s)\n+\n+Returns an array of strings describing each character of s by their unicode type. For example, `\"Bernice Rubens\".unicodeType()` outputs [ \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"space separator\", \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\" ].\n+\n+## Format-based functions (JSON, HTML, XML)\n+\n+###### jsonize(o)\n+\n+Quotes a value as a JSON literal value.\n+\n+###### parseJson(s)\n+\n+Parses a string as JSON. get() can then be used with parseJson(): for example, `parseJson(\" { 'a' : 1 } \").get(\"a\")` returns 1.\n+\n+For example from the following JSON array, let's get all instances called \u201ckeywords\u201d having the same object string name of \u201ctext\u201d, and combine it with the forEach() function to iterate over the array.\n+\n+    {\n+       \"status\":\"OK\",\n+       \"url\":\"\",\n+       \"language\":\"english\",\n+       \"keywords\":[\n+          {\n+             \"text\":\"York en route\",\n+             \"relevance\":\"0.974363\"\n+          },\n+          {\n+             \"text\":\"Anthony Eden\",\n+             \"relevance\":\"0.814394\"\n+          },\n+          {\n+             \"text\":\"President Eisenhower\",\n+             \"relevance\":\"0.700189\"\n+          }\n+       ]\n+    }\n+\n+The GREL expression `forEach(value.parseJson().keywords,v,v.text).join(\":::\")` will output \u201cYork en route:::Anthony Eden:::President Eisenhower\u201d.\n+\n+### Jsoup XML and HTML parsing\n+\n+###### parseHtml(s)\n+Given a cell full of HTML-formatted text, simplifies HTML tags (such as by removing \u201c /\u201d at the end of self-closing tags), closes any unclosed tags, and inserts linebreaks and indents for cleaner code. You cannot pass parseHtml() a URL, but you can pre-fetch HTML with the <span class=\"menuItems\">Add column by fetching URLs</span> menu option. A cell cannot store the output of parseHtml() unless you convert it with toString(). \n+\n+When parseHtml() simplifies HTML, it can sometimes introduce errors. When closing tags, it makes its best guesses based on line breaks, indentation, and the presence of other tags. You may need to manually check the results. \n+\n+You can then extract or select() which portions of the HTML document you need for further splitting, partitioning, etc. An example of extracting all table rows from a div using parseHtml().select() together is described more in depth at [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+###### parseXml(s)\n+Given a cell full of XML-formatted text, returns a full XML document and adds any missing closing tags. You can then extract or select() which portions of the XML document you need for further splitting, partitioning, etc. Functions the same way as parseHtml() is described above. \n+\n+###### select(s, element)\n+Returns an array of all the desired elements from an HTML or XML document, if the element exists. Elements are identified using the [Jsoup selector syntax](https://jsoup.org/apidocs/org/jsoup/select/Selector.html). For example, `value.parseHtml().select(\"img.portrait\")[0]` would return the entirety of the first \u201cimg\u201d tag with the \u201cportrait\u201d class found in the parsed HTML inside `value`. Returns an empty array if no matching element is found. Use with toString() to capture the results in a cell. A tutorial of select() is shown in [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+You can use select() more than once:\n+\n+```\n+value.parseHtml().select(\"div#content\")[0].select(\"tr\").toString()\n+```\n+\n+###### htmlAttr(s, element)\n+Returns a string from an attribute on an HTML element. Use it in conjunction with parseHtml() as in the following example: `value.parseHtml().select(\"a.email\")[0].htmlAttr(\"href\")`.\n+\n+###### xmlAttr(s, element)\n+Returns a string from an attribute on an XML element. Function the same way htmlAttr() is described above. Use it in conjunction with parseXml().\n+\n+###### htmlText(element)\n+Returns a string of the text from within an HTML element (including all child elements), removing HTML tags and line breaks inside the string. Use it in conjunction with parseHtml() and select() to provide an element, as in the following example: `value.parseHtml().select(\"div.footer\")[0].htmlText()`. \n+\n+###### xmlText(element)\n+Returns a string of the text from within an XML element (including all child elements). Functions the same way as htmlText() is described above. Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### wholeText(element)\n+\n+_Works from OpenRefine 3.4.1 beta 644 onwards only_\n+\n+Selects the (unencoded) text of an element and its children, including any newlines and spaces, and returns a string of unencoded, un-normalized text. Use it in conjunction with parseHtml() and select() to provide an element as in the following example: `value.parseHtml().select(\"div.footer\")[0].wholeText()`.\n+\n+###### innerHtml(element)\n+Returns the [inner HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) of an HTML element. This will include text and children elements within the element selected. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### innerXml(element)\n+Returns all the inner XML elements inside your chosen XML element. Does not return the text directly inside your chosen XML element - only the contents of its children. To select the direct text, use ownText(). To select both, use xmlText(). Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### outerHtml(element)\n+Returns the [outer HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/outerHTML) of an HTML element. outerHtml includes the start and end tags of the current element. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### ownText(element)\n+Returns the text directly inside the selected XML or HTML element only, ignoring text inside children elements. Use it in conjunction with a parser and select() to provide an element.\n+\n+## Array functions\n+\n+###### length(a)\n+Returns the size of an array, meaning the number of objects inside it. Arrays can be empty, in which case length() will return 0. \n+\n+###### slice(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. If to is omitted, it is understood to be the end of the array. For example, `[0, 1, 2, 3, 4].slice(1, 3)` returns [ 1, 2 ], and `[ 0, 1, 2, 3, 4].slice(1)` returns [ 1, 2, 3, 4 ]. Also works with strings; see [String functions](#slices-n-from-n-to-optional).\n+\n+###### get(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. \n+\n+If to is omitted, only one array item is returned, as a string, instead of a sub-array. To return a sub-array from one index to the end, you can set the to argument to a very high number such as `value.get(2,999)` or you can use something like `with(value,a,a.get(1,a.length()))` to count the length of each array.\n+\n+Also works with strings; see [get() in String functions](#gets-n-from-n-to-optional).\n+\n+###### inArray(a, s)\n+Returns true if the array contains the desired string, and false otherwise.\n+\n+###### reverse(a)\n+Reverses the array. For example, `[ 0, 1, 2, 3].reverse()` returns the array [ 3, 2, 1, 0 ].\n+\n+###### sort(a)\n+Sorts the array in ascending order. Sorting is case-sensitive, uppercase first and lowercase second. For example, `[ \"al\", \"Joe\", \"Bob\", \"jim\" ].sort()` returns the array [ \"Bob\", \"Joe\", \"al\", \"jim\" ]. \n+\n+###### sum(a)\n+Return the sum of the numbers in the array. For example, `[ 2, 1, 0, 3].sum()` returns 6.\n+\n+###### join(a, sep)\n+Joins the items in the array with sep, and returns it all as a string. For example, `[ \"and\", \"or\", \"not\" ].join(\"/\")` returns the string \u201cand/or/not\u201d.\n+\n+###### uniques(a)\n+Returns the array with duplicates removed. Case-sensitive. For example, `[ \"al\", \"Joe\", \"Bob\", \"Joe\", \"Al\", \"Bob\" ].uniques()` returns the array [ \"Joe\", \"al\", \"Al\", \"Bob\" ]. \n+\n+As of OpenRefine 3.4.1, uniques() reorders the array items it returns; in 3.4 beta 644 and onwards, it preserves the original order (in this case, [ \"al\", \"Joe\", \"Bob\", \"Al\" ]). \n+\n+## Date functions\n+If you have a column full of dates in a more common format (such as yyyy/mm/dd or YYYYMMDD) you can convert these using [\u201cTransform\u201d > \u201cCommon transforms \u2026\u201d > \u201cto date\u201d](cellediting#data-type-transforms), or the GREL function toDate(). You may wish to create a new column with the transformation, in order to also preserve the more human-readable version.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91b0bca29f37c00090ad5d43d2a78d45a60c5fab"}, "originalPosition": 380}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyOTg4MjM5OnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMDowMToxN1rOH6UJQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo1NTo0NlrOH6g2Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwOTUwNQ==", "bodyText": "Should we say this is the current time from the system clock converted to UTC ?", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r530909505", "createdAt": "2020-11-26T10:01:17Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,547 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator string (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \u201casdfsd\u201d into a date or a number, but you can convert the number \u201c123\u201d into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \u201cnull\u201d.\n+\n+### Testing string characteristics\n+\n+###### startsWith(s, sub)\n+\n+Returns a boolean indicating whether s starts with sub. For example, `\"food\".startsWith(\"foo\")` returns true, whereas `\"food\".startsWith(\"bar\")` returns false. \n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\"food\".endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase: a capital letter starting each word, and the rest of the letters lowercase. For example, `\"Once upon a midnight DREARY\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string \u201chard\u201d.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(0, -1)` returns the string \u201cprofoun\u201d.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \u201ca\u201d).\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"T\u00e9xt th\u00e1t was opt\u00edc\u00e1lly rec\u00f3gn\u00edz\u00e9d\".replaceChars(\"\u00e1\u00e9\u00ed\u00f3\u00fa\", \"aeiou\")` returns the string \u201cText that was optically recognized\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### find(s, sub or p)\n+\n+Outputs an array of all consecutive substrings inside string s that match the substring or [regex](#grel-supported-regex) pattern p. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in the array [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a sub instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \"fine is\" ].\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, outputs an array of all [capturing groups](https://www.regular-expressions.info/brackets.html) (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [ \"3480\" ]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to store it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to escape characters and use parentheses as needed. Parentheses are required to denote a desired substring (capturing group); for example, \u201c.&#42;(\\d\\d\\d\\d)\u201d would return an array containing a single value, while \u201c(.&#42;)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the value is \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|`value.match(/\\d{6}/)` |null (does not match the full string)|\n+|`value.match(/.*\\d{6}.*/)` |[ ] (no indicated substring)|\n+|`value.match(/.*(\\d{6}).*/)` |[ \"123456\" ] (array with one value)|\n+|`value.match(/(.*)(\\d{6})(.*)/)` |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+### String parsing and splitting\n+\n+###### toNumber(s)\n+\n+Returns a string converted to a number. Will attempt to convert other formats into a string, then into a number. If the value is already a number, it will return the number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by sep. The separator can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\", \" air\" ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ \"inter\", \"nation\", \"ali\" ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\"HenryCTaylor\".splitByCharType()` will result in an array of [ \"H\", \"enry\", \"CT\", \"aylor\" ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ \"BE\", \"1\", \"A\", \"3\", \"E\" ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ \"inter\", \"nation\", \"alization\" ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ \"par\", \"a\", \"llel\" ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1, s2, s timeUnit (optional))\n+\n+Takes two strings and compares them, returning a string. Returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". Also works with dates; see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. \n+\n+###### md5(o)\n+\n+Returns the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of an object. If fed something other than a string (array, number, date, etc.), md5() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".md5()` will return 2c55a1626e31b4e373ceedaa9adc12a3.\n+\n+###### sha1(o)\n+\n+Returns the [SHA-1 hash](https://en.wikipedia.org/wiki/SHA-1) of an object. If fed something other than a string (array, number, date, etc.), sha1() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".sha1()` will return cd05286ee0ff8a830dbdc0c24f1cb68b83b0ef36.\n+\n+###### phonetic(s, s encoding)\n+\n+Returns a phonetic encoding of a string, based on an available phonetic algorithm. See the [section on phonetic clustering](cellediting#clustering-methods) for more information. Can be one of the following supported phonetic methods: [metaphone, doublemetaphone, metaphone3](https://www.wikipedia.org/wiki/Metaphone), [soundex](https://en.wikipedia.org/wiki/Soundex), [cologne](https://en.wikipedia.org/wiki/Cologne_phonetics). Quotes are required around your encoding method. For example, `\"Ruth Prawer Jhabvala\".phonetic(\"metaphone\")` outputs the string \u201cR0PRWRJHBFL\u201d.  \n+\n+###### reinterpret(s, s encoder)\n+\n+Returns s reinterpreted through the given character encoder. You must supply one of the [supported encodings](http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html). Note that quotes are required around your character encoder.\n+\n+When an OpenRefine project is started, data is imported and interpreted. A specific character encoding is identified or manually selected at that time (such as UTF-8). You can reinterpret a column into another specificed encoding using this function. This function may not fix your data; it may be better to use this in conjunction with new projects to test the interpretation, and pre-format your data as needed. \n+\n+###### fingerprint(s)\n+\n+Returns the fingerprint of s, a string that is the first step in [fingerprint clustering methods](cellediting#clustering-methods): it will trim whitespaces, convert all characters to lowercase, remove punctuation, sort words alphabetically, etc. For example, `\"Ruth  Prawer    Jhabvala\".fingerprint()` outputs the string \u201cjhabvala prawer ruth\u201d.\n+\n+###### ngram(s, n)\n+\n+Returns an array of the word n-grams of s. That is, it lists all the possible consecutive combinations of n words in the string. For example, `\"Ruth Prawer Jhabvala\".ngram(2)` would output the array [ \"Ruth Prawer\", \"Prawer Jhabvala\" ]. A word n-gram of 1 simply lists all the words in original order; an n-gram larger than the number of words in the string will only return the original string inside an array (e.g. `\"Ruth Prawer Jhabvala\".ngram(4)` would simply return [\"Ruth Prawer Jhabvala\"]).\n+\n+###### ngramFingerprint(s, n)\n+\n+Returns the [n-gram fingerprint](cellediting#clustering-methods) of s. For example, `\"banana\".ngram(2)` would output \u201canbana\u201d, after first generating the 2-grams \u201cba an na an na\u201d, removing duplicates, and sorting them alphabetically.\n+\n+###### unicode(s)\n+\n+Returns an array of strings describing each character of s in their full unicode notation. For example, `\"Bernice Rubens\".unicode()` outputs [ 66, 101, 114, 110, 105, 99, 101, 32, 82, 117, 98, 101, 110, 115 ].\n+\n+###### unicodeType(s)\n+\n+Returns an array of strings describing each character of s by their unicode type. For example, `\"Bernice Rubens\".unicodeType()` outputs [ \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"space separator\", \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\" ].\n+\n+## Format-based functions (JSON, HTML, XML)\n+\n+###### jsonize(o)\n+\n+Quotes a value as a JSON literal value.\n+\n+###### parseJson(s)\n+\n+Parses a string as JSON. get() can then be used with parseJson(): for example, `parseJson(\" { 'a' : 1 } \").get(\"a\")` returns 1.\n+\n+For example from the following JSON array, let's get all instances called \u201ckeywords\u201d having the same object string name of \u201ctext\u201d, and combine it with the forEach() function to iterate over the array.\n+\n+    {\n+       \"status\":\"OK\",\n+       \"url\":\"\",\n+       \"language\":\"english\",\n+       \"keywords\":[\n+          {\n+             \"text\":\"York en route\",\n+             \"relevance\":\"0.974363\"\n+          },\n+          {\n+             \"text\":\"Anthony Eden\",\n+             \"relevance\":\"0.814394\"\n+          },\n+          {\n+             \"text\":\"President Eisenhower\",\n+             \"relevance\":\"0.700189\"\n+          }\n+       ]\n+    }\n+\n+The GREL expression `forEach(value.parseJson().keywords,v,v.text).join(\":::\")` will output \u201cYork en route:::Anthony Eden:::President Eisenhower\u201d.\n+\n+### Jsoup XML and HTML parsing\n+\n+###### parseHtml(s)\n+Given a cell full of HTML-formatted text, simplifies HTML tags (such as by removing \u201c /\u201d at the end of self-closing tags), closes any unclosed tags, and inserts linebreaks and indents for cleaner code. You cannot pass parseHtml() a URL, but you can pre-fetch HTML with the <span class=\"menuItems\">Add column by fetching URLs</span> menu option. A cell cannot store the output of parseHtml() unless you convert it with toString(). \n+\n+When parseHtml() simplifies HTML, it can sometimes introduce errors. When closing tags, it makes its best guesses based on line breaks, indentation, and the presence of other tags. You may need to manually check the results. \n+\n+You can then extract or select() which portions of the HTML document you need for further splitting, partitioning, etc. An example of extracting all table rows from a div using parseHtml().select() together is described more in depth at [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+###### parseXml(s)\n+Given a cell full of XML-formatted text, returns a full XML document and adds any missing closing tags. You can then extract or select() which portions of the XML document you need for further splitting, partitioning, etc. Functions the same way as parseHtml() is described above. \n+\n+###### select(s, element)\n+Returns an array of all the desired elements from an HTML or XML document, if the element exists. Elements are identified using the [Jsoup selector syntax](https://jsoup.org/apidocs/org/jsoup/select/Selector.html). For example, `value.parseHtml().select(\"img.portrait\")[0]` would return the entirety of the first \u201cimg\u201d tag with the \u201cportrait\u201d class found in the parsed HTML inside `value`. Returns an empty array if no matching element is found. Use with toString() to capture the results in a cell. A tutorial of select() is shown in [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+You can use select() more than once:\n+\n+```\n+value.parseHtml().select(\"div#content\")[0].select(\"tr\").toString()\n+```\n+\n+###### htmlAttr(s, element)\n+Returns a string from an attribute on an HTML element. Use it in conjunction with parseHtml() as in the following example: `value.parseHtml().select(\"a.email\")[0].htmlAttr(\"href\")`.\n+\n+###### xmlAttr(s, element)\n+Returns a string from an attribute on an XML element. Function the same way htmlAttr() is described above. Use it in conjunction with parseXml().\n+\n+###### htmlText(element)\n+Returns a string of the text from within an HTML element (including all child elements), removing HTML tags and line breaks inside the string. Use it in conjunction with parseHtml() and select() to provide an element, as in the following example: `value.parseHtml().select(\"div.footer\")[0].htmlText()`. \n+\n+###### xmlText(element)\n+Returns a string of the text from within an XML element (including all child elements). Functions the same way as htmlText() is described above. Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### wholeText(element)\n+\n+_Works from OpenRefine 3.4.1 beta 644 onwards only_\n+\n+Selects the (unencoded) text of an element and its children, including any newlines and spaces, and returns a string of unencoded, un-normalized text. Use it in conjunction with parseHtml() and select() to provide an element as in the following example: `value.parseHtml().select(\"div.footer\")[0].wholeText()`.\n+\n+###### innerHtml(element)\n+Returns the [inner HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) of an HTML element. This will include text and children elements within the element selected. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### innerXml(element)\n+Returns all the inner XML elements inside your chosen XML element. Does not return the text directly inside your chosen XML element - only the contents of its children. To select the direct text, use ownText(). To select both, use xmlText(). Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### outerHtml(element)\n+Returns the [outer HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/outerHTML) of an HTML element. outerHtml includes the start and end tags of the current element. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### ownText(element)\n+Returns the text directly inside the selected XML or HTML element only, ignoring text inside children elements. Use it in conjunction with a parser and select() to provide an element.\n+\n+## Array functions\n+\n+###### length(a)\n+Returns the size of an array, meaning the number of objects inside it. Arrays can be empty, in which case length() will return 0. \n+\n+###### slice(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. If to is omitted, it is understood to be the end of the array. For example, `[0, 1, 2, 3, 4].slice(1, 3)` returns [ 1, 2 ], and `[ 0, 1, 2, 3, 4].slice(1)` returns [ 1, 2, 3, 4 ]. Also works with strings; see [String functions](#slices-n-from-n-to-optional).\n+\n+###### get(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. \n+\n+If to is omitted, only one array item is returned, as a string, instead of a sub-array. To return a sub-array from one index to the end, you can set the to argument to a very high number such as `value.get(2,999)` or you can use something like `with(value,a,a.get(1,a.length()))` to count the length of each array.\n+\n+Also works with strings; see [get() in String functions](#gets-n-from-n-to-optional).\n+\n+###### inArray(a, s)\n+Returns true if the array contains the desired string, and false otherwise.\n+\n+###### reverse(a)\n+Reverses the array. For example, `[ 0, 1, 2, 3].reverse()` returns the array [ 3, 2, 1, 0 ].\n+\n+###### sort(a)\n+Sorts the array in ascending order. Sorting is case-sensitive, uppercase first and lowercase second. For example, `[ \"al\", \"Joe\", \"Bob\", \"jim\" ].sort()` returns the array [ \"Bob\", \"Joe\", \"al\", \"jim\" ]. \n+\n+###### sum(a)\n+Return the sum of the numbers in the array. For example, `[ 2, 1, 0, 3].sum()` returns 6.\n+\n+###### join(a, sep)\n+Joins the items in the array with sep, and returns it all as a string. For example, `[ \"and\", \"or\", \"not\" ].join(\"/\")` returns the string \u201cand/or/not\u201d.\n+\n+###### uniques(a)\n+Returns the array with duplicates removed. Case-sensitive. For example, `[ \"al\", \"Joe\", \"Bob\", \"Joe\", \"Al\", \"Bob\" ].uniques()` returns the array [ \"Joe\", \"al\", \"Al\", \"Bob\" ]. \n+\n+As of OpenRefine 3.4.1, uniques() reorders the array items it returns; in 3.4 beta 644 and onwards, it preserves the original order (in this case, [ \"al\", \"Joe\", \"Bob\", \"Al\" ]). \n+\n+## Date functions\n+If you have a column full of dates in a more common format (such as yyyy/mm/dd or YYYYMMDD) you can convert these using [\u201cTransform\u201d > \u201cCommon transforms \u2026\u201d > \u201cto date\u201d](cellediting#data-type-transforms), or the GREL function toDate(). You may wish to create a new column with the transformation, in order to also preserve the more human-readable version.\n+\n+OpenRefine uses [Date.parse()](https://www.w3schools.com/jsref/jsref_parse.asp) to recognize a variety of formats and convert them, including converting from other time zones to UTC:\n+\n+![A screenshot of different date formats being converted, and one error.](/img/dates.png)\n+\n+You may need to do some reformatting if your dates are not being recognized by the toDate() function. For example, in the image above, the date that includes \u201c7AM\u201d is giving an error message, but the ones with \u201c2:42 PM\u201d and \u201c3:22PM\u201d are being converted.\n+\n+###### now()\n+\n+Returns the current time in the [ISO 8601 extended format](exploring#data-types). For example, 12:58pm on October 28th 2020 returns [date 2020-10-28T16:58:32Z].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91b0bca29f37c00090ad5d43d2a78d45a60c5fab"}, "originalPosition": 390}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA1MzYwMg==", "bodyText": "There's always 3 things about date functions in OpenRefine... the datetime, the timezone, the format.  I think mentioning that in the #data-type-transforms section would be wise.  And then here in Expressions -> GREL, I agree with Owen to simplify.\nIn other words, we should have already explained the overarching functionality of Date handling to users already under Transforming data -> Cell editing -> Data-type transforms.  Dates are important enough that they could have their own subsection under #common-transforms, but in that section, I would still avoid tutorial-ly language, and only explain how dates are treated in OpenRefine, their 3 constituent parts that users have control over, and then provide links to the Technical docs.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r531053602", "createdAt": "2020-11-26T14:09:36Z", "author": {"login": "thadguidry"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,547 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator string (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \u201casdfsd\u201d into a date or a number, but you can convert the number \u201c123\u201d into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \u201cnull\u201d.\n+\n+### Testing string characteristics\n+\n+###### startsWith(s, sub)\n+\n+Returns a boolean indicating whether s starts with sub. For example, `\"food\".startsWith(\"foo\")` returns true, whereas `\"food\".startsWith(\"bar\")` returns false. \n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\"food\".endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase: a capital letter starting each word, and the rest of the letters lowercase. For example, `\"Once upon a midnight DREARY\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string \u201chard\u201d.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(0, -1)` returns the string \u201cprofoun\u201d.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \u201ca\u201d).\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"T\u00e9xt th\u00e1t was opt\u00edc\u00e1lly rec\u00f3gn\u00edz\u00e9d\".replaceChars(\"\u00e1\u00e9\u00ed\u00f3\u00fa\", \"aeiou\")` returns the string \u201cText that was optically recognized\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### find(s, sub or p)\n+\n+Outputs an array of all consecutive substrings inside string s that match the substring or [regex](#grel-supported-regex) pattern p. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in the array [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a sub instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \"fine is\" ].\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, outputs an array of all [capturing groups](https://www.regular-expressions.info/brackets.html) (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [ \"3480\" ]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to store it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to escape characters and use parentheses as needed. Parentheses are required to denote a desired substring (capturing group); for example, \u201c.&#42;(\\d\\d\\d\\d)\u201d would return an array containing a single value, while \u201c(.&#42;)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the value is \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|`value.match(/\\d{6}/)` |null (does not match the full string)|\n+|`value.match(/.*\\d{6}.*/)` |[ ] (no indicated substring)|\n+|`value.match(/.*(\\d{6}).*/)` |[ \"123456\" ] (array with one value)|\n+|`value.match(/(.*)(\\d{6})(.*)/)` |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+### String parsing and splitting\n+\n+###### toNumber(s)\n+\n+Returns a string converted to a number. Will attempt to convert other formats into a string, then into a number. If the value is already a number, it will return the number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by sep. The separator can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\", \" air\" ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ \"inter\", \"nation\", \"ali\" ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\"HenryCTaylor\".splitByCharType()` will result in an array of [ \"H\", \"enry\", \"CT\", \"aylor\" ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ \"BE\", \"1\", \"A\", \"3\", \"E\" ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ \"inter\", \"nation\", \"alization\" ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ \"par\", \"a\", \"llel\" ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1, s2, s timeUnit (optional))\n+\n+Takes two strings and compares them, returning a string. Returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". Also works with dates; see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. \n+\n+###### md5(o)\n+\n+Returns the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of an object. If fed something other than a string (array, number, date, etc.), md5() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".md5()` will return 2c55a1626e31b4e373ceedaa9adc12a3.\n+\n+###### sha1(o)\n+\n+Returns the [SHA-1 hash](https://en.wikipedia.org/wiki/SHA-1) of an object. If fed something other than a string (array, number, date, etc.), sha1() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".sha1()` will return cd05286ee0ff8a830dbdc0c24f1cb68b83b0ef36.\n+\n+###### phonetic(s, s encoding)\n+\n+Returns a phonetic encoding of a string, based on an available phonetic algorithm. See the [section on phonetic clustering](cellediting#clustering-methods) for more information. Can be one of the following supported phonetic methods: [metaphone, doublemetaphone, metaphone3](https://www.wikipedia.org/wiki/Metaphone), [soundex](https://en.wikipedia.org/wiki/Soundex), [cologne](https://en.wikipedia.org/wiki/Cologne_phonetics). Quotes are required around your encoding method. For example, `\"Ruth Prawer Jhabvala\".phonetic(\"metaphone\")` outputs the string \u201cR0PRWRJHBFL\u201d.  \n+\n+###### reinterpret(s, s encoder)\n+\n+Returns s reinterpreted through the given character encoder. You must supply one of the [supported encodings](http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html). Note that quotes are required around your character encoder.\n+\n+When an OpenRefine project is started, data is imported and interpreted. A specific character encoding is identified or manually selected at that time (such as UTF-8). You can reinterpret a column into another specificed encoding using this function. This function may not fix your data; it may be better to use this in conjunction with new projects to test the interpretation, and pre-format your data as needed. \n+\n+###### fingerprint(s)\n+\n+Returns the fingerprint of s, a string that is the first step in [fingerprint clustering methods](cellediting#clustering-methods): it will trim whitespaces, convert all characters to lowercase, remove punctuation, sort words alphabetically, etc. For example, `\"Ruth  Prawer    Jhabvala\".fingerprint()` outputs the string \u201cjhabvala prawer ruth\u201d.\n+\n+###### ngram(s, n)\n+\n+Returns an array of the word n-grams of s. That is, it lists all the possible consecutive combinations of n words in the string. For example, `\"Ruth Prawer Jhabvala\".ngram(2)` would output the array [ \"Ruth Prawer\", \"Prawer Jhabvala\" ]. A word n-gram of 1 simply lists all the words in original order; an n-gram larger than the number of words in the string will only return the original string inside an array (e.g. `\"Ruth Prawer Jhabvala\".ngram(4)` would simply return [\"Ruth Prawer Jhabvala\"]).\n+\n+###### ngramFingerprint(s, n)\n+\n+Returns the [n-gram fingerprint](cellediting#clustering-methods) of s. For example, `\"banana\".ngram(2)` would output \u201canbana\u201d, after first generating the 2-grams \u201cba an na an na\u201d, removing duplicates, and sorting them alphabetically.\n+\n+###### unicode(s)\n+\n+Returns an array of strings describing each character of s in their full unicode notation. For example, `\"Bernice Rubens\".unicode()` outputs [ 66, 101, 114, 110, 105, 99, 101, 32, 82, 117, 98, 101, 110, 115 ].\n+\n+###### unicodeType(s)\n+\n+Returns an array of strings describing each character of s by their unicode type. For example, `\"Bernice Rubens\".unicodeType()` outputs [ \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"space separator\", \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\" ].\n+\n+## Format-based functions (JSON, HTML, XML)\n+\n+###### jsonize(o)\n+\n+Quotes a value as a JSON literal value.\n+\n+###### parseJson(s)\n+\n+Parses a string as JSON. get() can then be used with parseJson(): for example, `parseJson(\" { 'a' : 1 } \").get(\"a\")` returns 1.\n+\n+For example from the following JSON array, let's get all instances called \u201ckeywords\u201d having the same object string name of \u201ctext\u201d, and combine it with the forEach() function to iterate over the array.\n+\n+    {\n+       \"status\":\"OK\",\n+       \"url\":\"\",\n+       \"language\":\"english\",\n+       \"keywords\":[\n+          {\n+             \"text\":\"York en route\",\n+             \"relevance\":\"0.974363\"\n+          },\n+          {\n+             \"text\":\"Anthony Eden\",\n+             \"relevance\":\"0.814394\"\n+          },\n+          {\n+             \"text\":\"President Eisenhower\",\n+             \"relevance\":\"0.700189\"\n+          }\n+       ]\n+    }\n+\n+The GREL expression `forEach(value.parseJson().keywords,v,v.text).join(\":::\")` will output \u201cYork en route:::Anthony Eden:::President Eisenhower\u201d.\n+\n+### Jsoup XML and HTML parsing\n+\n+###### parseHtml(s)\n+Given a cell full of HTML-formatted text, simplifies HTML tags (such as by removing \u201c /\u201d at the end of self-closing tags), closes any unclosed tags, and inserts linebreaks and indents for cleaner code. You cannot pass parseHtml() a URL, but you can pre-fetch HTML with the <span class=\"menuItems\">Add column by fetching URLs</span> menu option. A cell cannot store the output of parseHtml() unless you convert it with toString(). \n+\n+When parseHtml() simplifies HTML, it can sometimes introduce errors. When closing tags, it makes its best guesses based on line breaks, indentation, and the presence of other tags. You may need to manually check the results. \n+\n+You can then extract or select() which portions of the HTML document you need for further splitting, partitioning, etc. An example of extracting all table rows from a div using parseHtml().select() together is described more in depth at [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+###### parseXml(s)\n+Given a cell full of XML-formatted text, returns a full XML document and adds any missing closing tags. You can then extract or select() which portions of the XML document you need for further splitting, partitioning, etc. Functions the same way as parseHtml() is described above. \n+\n+###### select(s, element)\n+Returns an array of all the desired elements from an HTML or XML document, if the element exists. Elements are identified using the [Jsoup selector syntax](https://jsoup.org/apidocs/org/jsoup/select/Selector.html). For example, `value.parseHtml().select(\"img.portrait\")[0]` would return the entirety of the first \u201cimg\u201d tag with the \u201cportrait\u201d class found in the parsed HTML inside `value`. Returns an empty array if no matching element is found. Use with toString() to capture the results in a cell. A tutorial of select() is shown in [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+You can use select() more than once:\n+\n+```\n+value.parseHtml().select(\"div#content\")[0].select(\"tr\").toString()\n+```\n+\n+###### htmlAttr(s, element)\n+Returns a string from an attribute on an HTML element. Use it in conjunction with parseHtml() as in the following example: `value.parseHtml().select(\"a.email\")[0].htmlAttr(\"href\")`.\n+\n+###### xmlAttr(s, element)\n+Returns a string from an attribute on an XML element. Function the same way htmlAttr() is described above. Use it in conjunction with parseXml().\n+\n+###### htmlText(element)\n+Returns a string of the text from within an HTML element (including all child elements), removing HTML tags and line breaks inside the string. Use it in conjunction with parseHtml() and select() to provide an element, as in the following example: `value.parseHtml().select(\"div.footer\")[0].htmlText()`. \n+\n+###### xmlText(element)\n+Returns a string of the text from within an XML element (including all child elements). Functions the same way as htmlText() is described above. Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### wholeText(element)\n+\n+_Works from OpenRefine 3.4.1 beta 644 onwards only_\n+\n+Selects the (unencoded) text of an element and its children, including any newlines and spaces, and returns a string of unencoded, un-normalized text. Use it in conjunction with parseHtml() and select() to provide an element as in the following example: `value.parseHtml().select(\"div.footer\")[0].wholeText()`.\n+\n+###### innerHtml(element)\n+Returns the [inner HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) of an HTML element. This will include text and children elements within the element selected. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### innerXml(element)\n+Returns all the inner XML elements inside your chosen XML element. Does not return the text directly inside your chosen XML element - only the contents of its children. To select the direct text, use ownText(). To select both, use xmlText(). Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### outerHtml(element)\n+Returns the [outer HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/outerHTML) of an HTML element. outerHtml includes the start and end tags of the current element. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### ownText(element)\n+Returns the text directly inside the selected XML or HTML element only, ignoring text inside children elements. Use it in conjunction with a parser and select() to provide an element.\n+\n+## Array functions\n+\n+###### length(a)\n+Returns the size of an array, meaning the number of objects inside it. Arrays can be empty, in which case length() will return 0. \n+\n+###### slice(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. If to is omitted, it is understood to be the end of the array. For example, `[0, 1, 2, 3, 4].slice(1, 3)` returns [ 1, 2 ], and `[ 0, 1, 2, 3, 4].slice(1)` returns [ 1, 2, 3, 4 ]. Also works with strings; see [String functions](#slices-n-from-n-to-optional).\n+\n+###### get(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. \n+\n+If to is omitted, only one array item is returned, as a string, instead of a sub-array. To return a sub-array from one index to the end, you can set the to argument to a very high number such as `value.get(2,999)` or you can use something like `with(value,a,a.get(1,a.length()))` to count the length of each array.\n+\n+Also works with strings; see [get() in String functions](#gets-n-from-n-to-optional).\n+\n+###### inArray(a, s)\n+Returns true if the array contains the desired string, and false otherwise.\n+\n+###### reverse(a)\n+Reverses the array. For example, `[ 0, 1, 2, 3].reverse()` returns the array [ 3, 2, 1, 0 ].\n+\n+###### sort(a)\n+Sorts the array in ascending order. Sorting is case-sensitive, uppercase first and lowercase second. For example, `[ \"al\", \"Joe\", \"Bob\", \"jim\" ].sort()` returns the array [ \"Bob\", \"Joe\", \"al\", \"jim\" ]. \n+\n+###### sum(a)\n+Return the sum of the numbers in the array. For example, `[ 2, 1, 0, 3].sum()` returns 6.\n+\n+###### join(a, sep)\n+Joins the items in the array with sep, and returns it all as a string. For example, `[ \"and\", \"or\", \"not\" ].join(\"/\")` returns the string \u201cand/or/not\u201d.\n+\n+###### uniques(a)\n+Returns the array with duplicates removed. Case-sensitive. For example, `[ \"al\", \"Joe\", \"Bob\", \"Joe\", \"Al\", \"Bob\" ].uniques()` returns the array [ \"Joe\", \"al\", \"Al\", \"Bob\" ]. \n+\n+As of OpenRefine 3.4.1, uniques() reorders the array items it returns; in 3.4 beta 644 and onwards, it preserves the original order (in this case, [ \"al\", \"Joe\", \"Bob\", \"Al\" ]). \n+\n+## Date functions\n+If you have a column full of dates in a more common format (such as yyyy/mm/dd or YYYYMMDD) you can convert these using [\u201cTransform\u201d > \u201cCommon transforms \u2026\u201d > \u201cto date\u201d](cellediting#data-type-transforms), or the GREL function toDate(). You may wish to create a new column with the transformation, in order to also preserve the more human-readable version.\n+\n+OpenRefine uses [Date.parse()](https://www.w3schools.com/jsref/jsref_parse.asp) to recognize a variety of formats and convert them, including converting from other time zones to UTC:\n+\n+![A screenshot of different date formats being converted, and one error.](/img/dates.png)\n+\n+You may need to do some reformatting if your dates are not being recognized by the toDate() function. For example, in the image above, the date that includes \u201c7AM\u201d is giving an error message, but the ones with \u201c2:42 PM\u201d and \u201c3:22PM\u201d are being converted.\n+\n+###### now()\n+\n+Returns the current time in the [ISO 8601 extended format](exploring#data-types). For example, 12:58pm on October 28th 2020 returns [date 2020-10-28T16:58:32Z].", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwOTUwNQ=="}, "originalCommit": {"oid": "91b0bca29f37c00090ad5d43d2a78d45a60c5fab"}, "originalPosition": 390}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA1NzAxOA==", "bodyText": "@allanaaa Also, #data-types and other sections needs a clean up pass for code/syntax highlighting.  I see \"null\", null, and true, \"true\", true, etc.  But I think that's part of your 2nd contract (extension) work?", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r531057018", "createdAt": "2020-11-26T14:15:35Z", "author": {"login": "thadguidry"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,547 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator string (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \u201casdfsd\u201d into a date or a number, but you can convert the number \u201c123\u201d into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \u201cnull\u201d.\n+\n+### Testing string characteristics\n+\n+###### startsWith(s, sub)\n+\n+Returns a boolean indicating whether s starts with sub. For example, `\"food\".startsWith(\"foo\")` returns true, whereas `\"food\".startsWith(\"bar\")` returns false. \n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\"food\".endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase: a capital letter starting each word, and the rest of the letters lowercase. For example, `\"Once upon a midnight DREARY\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string \u201chard\u201d.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(0, -1)` returns the string \u201cprofoun\u201d.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \u201ca\u201d).\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"T\u00e9xt th\u00e1t was opt\u00edc\u00e1lly rec\u00f3gn\u00edz\u00e9d\".replaceChars(\"\u00e1\u00e9\u00ed\u00f3\u00fa\", \"aeiou\")` returns the string \u201cText that was optically recognized\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### find(s, sub or p)\n+\n+Outputs an array of all consecutive substrings inside string s that match the substring or [regex](#grel-supported-regex) pattern p. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in the array [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a sub instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \"fine is\" ].\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, outputs an array of all [capturing groups](https://www.regular-expressions.info/brackets.html) (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [ \"3480\" ]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to store it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to escape characters and use parentheses as needed. Parentheses are required to denote a desired substring (capturing group); for example, \u201c.&#42;(\\d\\d\\d\\d)\u201d would return an array containing a single value, while \u201c(.&#42;)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the value is \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|`value.match(/\\d{6}/)` |null (does not match the full string)|\n+|`value.match(/.*\\d{6}.*/)` |[ ] (no indicated substring)|\n+|`value.match(/.*(\\d{6}).*/)` |[ \"123456\" ] (array with one value)|\n+|`value.match(/(.*)(\\d{6})(.*)/)` |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+### String parsing and splitting\n+\n+###### toNumber(s)\n+\n+Returns a string converted to a number. Will attempt to convert other formats into a string, then into a number. If the value is already a number, it will return the number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by sep. The separator can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\", \" air\" ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ \"inter\", \"nation\", \"ali\" ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\"HenryCTaylor\".splitByCharType()` will result in an array of [ \"H\", \"enry\", \"CT\", \"aylor\" ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ \"BE\", \"1\", \"A\", \"3\", \"E\" ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ \"inter\", \"nation\", \"alization\" ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ \"par\", \"a\", \"llel\" ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1, s2, s timeUnit (optional))\n+\n+Takes two strings and compares them, returning a string. Returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". Also works with dates; see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. \n+\n+###### md5(o)\n+\n+Returns the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of an object. If fed something other than a string (array, number, date, etc.), md5() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".md5()` will return 2c55a1626e31b4e373ceedaa9adc12a3.\n+\n+###### sha1(o)\n+\n+Returns the [SHA-1 hash](https://en.wikipedia.org/wiki/SHA-1) of an object. If fed something other than a string (array, number, date, etc.), sha1() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".sha1()` will return cd05286ee0ff8a830dbdc0c24f1cb68b83b0ef36.\n+\n+###### phonetic(s, s encoding)\n+\n+Returns a phonetic encoding of a string, based on an available phonetic algorithm. See the [section on phonetic clustering](cellediting#clustering-methods) for more information. Can be one of the following supported phonetic methods: [metaphone, doublemetaphone, metaphone3](https://www.wikipedia.org/wiki/Metaphone), [soundex](https://en.wikipedia.org/wiki/Soundex), [cologne](https://en.wikipedia.org/wiki/Cologne_phonetics). Quotes are required around your encoding method. For example, `\"Ruth Prawer Jhabvala\".phonetic(\"metaphone\")` outputs the string \u201cR0PRWRJHBFL\u201d.  \n+\n+###### reinterpret(s, s encoder)\n+\n+Returns s reinterpreted through the given character encoder. You must supply one of the [supported encodings](http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html). Note that quotes are required around your character encoder.\n+\n+When an OpenRefine project is started, data is imported and interpreted. A specific character encoding is identified or manually selected at that time (such as UTF-8). You can reinterpret a column into another specificed encoding using this function. This function may not fix your data; it may be better to use this in conjunction with new projects to test the interpretation, and pre-format your data as needed. \n+\n+###### fingerprint(s)\n+\n+Returns the fingerprint of s, a string that is the first step in [fingerprint clustering methods](cellediting#clustering-methods): it will trim whitespaces, convert all characters to lowercase, remove punctuation, sort words alphabetically, etc. For example, `\"Ruth  Prawer    Jhabvala\".fingerprint()` outputs the string \u201cjhabvala prawer ruth\u201d.\n+\n+###### ngram(s, n)\n+\n+Returns an array of the word n-grams of s. That is, it lists all the possible consecutive combinations of n words in the string. For example, `\"Ruth Prawer Jhabvala\".ngram(2)` would output the array [ \"Ruth Prawer\", \"Prawer Jhabvala\" ]. A word n-gram of 1 simply lists all the words in original order; an n-gram larger than the number of words in the string will only return the original string inside an array (e.g. `\"Ruth Prawer Jhabvala\".ngram(4)` would simply return [\"Ruth Prawer Jhabvala\"]).\n+\n+###### ngramFingerprint(s, n)\n+\n+Returns the [n-gram fingerprint](cellediting#clustering-methods) of s. For example, `\"banana\".ngram(2)` would output \u201canbana\u201d, after first generating the 2-grams \u201cba an na an na\u201d, removing duplicates, and sorting them alphabetically.\n+\n+###### unicode(s)\n+\n+Returns an array of strings describing each character of s in their full unicode notation. For example, `\"Bernice Rubens\".unicode()` outputs [ 66, 101, 114, 110, 105, 99, 101, 32, 82, 117, 98, 101, 110, 115 ].\n+\n+###### unicodeType(s)\n+\n+Returns an array of strings describing each character of s by their unicode type. For example, `\"Bernice Rubens\".unicodeType()` outputs [ \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"space separator\", \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\" ].\n+\n+## Format-based functions (JSON, HTML, XML)\n+\n+###### jsonize(o)\n+\n+Quotes a value as a JSON literal value.\n+\n+###### parseJson(s)\n+\n+Parses a string as JSON. get() can then be used with parseJson(): for example, `parseJson(\" { 'a' : 1 } \").get(\"a\")` returns 1.\n+\n+For example from the following JSON array, let's get all instances called \u201ckeywords\u201d having the same object string name of \u201ctext\u201d, and combine it with the forEach() function to iterate over the array.\n+\n+    {\n+       \"status\":\"OK\",\n+       \"url\":\"\",\n+       \"language\":\"english\",\n+       \"keywords\":[\n+          {\n+             \"text\":\"York en route\",\n+             \"relevance\":\"0.974363\"\n+          },\n+          {\n+             \"text\":\"Anthony Eden\",\n+             \"relevance\":\"0.814394\"\n+          },\n+          {\n+             \"text\":\"President Eisenhower\",\n+             \"relevance\":\"0.700189\"\n+          }\n+       ]\n+    }\n+\n+The GREL expression `forEach(value.parseJson().keywords,v,v.text).join(\":::\")` will output \u201cYork en route:::Anthony Eden:::President Eisenhower\u201d.\n+\n+### Jsoup XML and HTML parsing\n+\n+###### parseHtml(s)\n+Given a cell full of HTML-formatted text, simplifies HTML tags (such as by removing \u201c /\u201d at the end of self-closing tags), closes any unclosed tags, and inserts linebreaks and indents for cleaner code. You cannot pass parseHtml() a URL, but you can pre-fetch HTML with the <span class=\"menuItems\">Add column by fetching URLs</span> menu option. A cell cannot store the output of parseHtml() unless you convert it with toString(). \n+\n+When parseHtml() simplifies HTML, it can sometimes introduce errors. When closing tags, it makes its best guesses based on line breaks, indentation, and the presence of other tags. You may need to manually check the results. \n+\n+You can then extract or select() which portions of the HTML document you need for further splitting, partitioning, etc. An example of extracting all table rows from a div using parseHtml().select() together is described more in depth at [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+###### parseXml(s)\n+Given a cell full of XML-formatted text, returns a full XML document and adds any missing closing tags. You can then extract or select() which portions of the XML document you need for further splitting, partitioning, etc. Functions the same way as parseHtml() is described above. \n+\n+###### select(s, element)\n+Returns an array of all the desired elements from an HTML or XML document, if the element exists. Elements are identified using the [Jsoup selector syntax](https://jsoup.org/apidocs/org/jsoup/select/Selector.html). For example, `value.parseHtml().select(\"img.portrait\")[0]` would return the entirety of the first \u201cimg\u201d tag with the \u201cportrait\u201d class found in the parsed HTML inside `value`. Returns an empty array if no matching element is found. Use with toString() to capture the results in a cell. A tutorial of select() is shown in [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+You can use select() more than once:\n+\n+```\n+value.parseHtml().select(\"div#content\")[0].select(\"tr\").toString()\n+```\n+\n+###### htmlAttr(s, element)\n+Returns a string from an attribute on an HTML element. Use it in conjunction with parseHtml() as in the following example: `value.parseHtml().select(\"a.email\")[0].htmlAttr(\"href\")`.\n+\n+###### xmlAttr(s, element)\n+Returns a string from an attribute on an XML element. Function the same way htmlAttr() is described above. Use it in conjunction with parseXml().\n+\n+###### htmlText(element)\n+Returns a string of the text from within an HTML element (including all child elements), removing HTML tags and line breaks inside the string. Use it in conjunction with parseHtml() and select() to provide an element, as in the following example: `value.parseHtml().select(\"div.footer\")[0].htmlText()`. \n+\n+###### xmlText(element)\n+Returns a string of the text from within an XML element (including all child elements). Functions the same way as htmlText() is described above. Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### wholeText(element)\n+\n+_Works from OpenRefine 3.4.1 beta 644 onwards only_\n+\n+Selects the (unencoded) text of an element and its children, including any newlines and spaces, and returns a string of unencoded, un-normalized text. Use it in conjunction with parseHtml() and select() to provide an element as in the following example: `value.parseHtml().select(\"div.footer\")[0].wholeText()`.\n+\n+###### innerHtml(element)\n+Returns the [inner HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) of an HTML element. This will include text and children elements within the element selected. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### innerXml(element)\n+Returns all the inner XML elements inside your chosen XML element. Does not return the text directly inside your chosen XML element - only the contents of its children. To select the direct text, use ownText(). To select both, use xmlText(). Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### outerHtml(element)\n+Returns the [outer HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/outerHTML) of an HTML element. outerHtml includes the start and end tags of the current element. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### ownText(element)\n+Returns the text directly inside the selected XML or HTML element only, ignoring text inside children elements. Use it in conjunction with a parser and select() to provide an element.\n+\n+## Array functions\n+\n+###### length(a)\n+Returns the size of an array, meaning the number of objects inside it. Arrays can be empty, in which case length() will return 0. \n+\n+###### slice(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. If to is omitted, it is understood to be the end of the array. For example, `[0, 1, 2, 3, 4].slice(1, 3)` returns [ 1, 2 ], and `[ 0, 1, 2, 3, 4].slice(1)` returns [ 1, 2, 3, 4 ]. Also works with strings; see [String functions](#slices-n-from-n-to-optional).\n+\n+###### get(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. \n+\n+If to is omitted, only one array item is returned, as a string, instead of a sub-array. To return a sub-array from one index to the end, you can set the to argument to a very high number such as `value.get(2,999)` or you can use something like `with(value,a,a.get(1,a.length()))` to count the length of each array.\n+\n+Also works with strings; see [get() in String functions](#gets-n-from-n-to-optional).\n+\n+###### inArray(a, s)\n+Returns true if the array contains the desired string, and false otherwise.\n+\n+###### reverse(a)\n+Reverses the array. For example, `[ 0, 1, 2, 3].reverse()` returns the array [ 3, 2, 1, 0 ].\n+\n+###### sort(a)\n+Sorts the array in ascending order. Sorting is case-sensitive, uppercase first and lowercase second. For example, `[ \"al\", \"Joe\", \"Bob\", \"jim\" ].sort()` returns the array [ \"Bob\", \"Joe\", \"al\", \"jim\" ]. \n+\n+###### sum(a)\n+Return the sum of the numbers in the array. For example, `[ 2, 1, 0, 3].sum()` returns 6.\n+\n+###### join(a, sep)\n+Joins the items in the array with sep, and returns it all as a string. For example, `[ \"and\", \"or\", \"not\" ].join(\"/\")` returns the string \u201cand/or/not\u201d.\n+\n+###### uniques(a)\n+Returns the array with duplicates removed. Case-sensitive. For example, `[ \"al\", \"Joe\", \"Bob\", \"Joe\", \"Al\", \"Bob\" ].uniques()` returns the array [ \"Joe\", \"al\", \"Al\", \"Bob\" ]. \n+\n+As of OpenRefine 3.4.1, uniques() reorders the array items it returns; in 3.4 beta 644 and onwards, it preserves the original order (in this case, [ \"al\", \"Joe\", \"Bob\", \"Al\" ]). \n+\n+## Date functions\n+If you have a column full of dates in a more common format (such as yyyy/mm/dd or YYYYMMDD) you can convert these using [\u201cTransform\u201d > \u201cCommon transforms \u2026\u201d > \u201cto date\u201d](cellediting#data-type-transforms), or the GREL function toDate(). You may wish to create a new column with the transformation, in order to also preserve the more human-readable version.\n+\n+OpenRefine uses [Date.parse()](https://www.w3schools.com/jsref/jsref_parse.asp) to recognize a variety of formats and convert them, including converting from other time zones to UTC:\n+\n+![A screenshot of different date formats being converted, and one error.](/img/dates.png)\n+\n+You may need to do some reformatting if your dates are not being recognized by the toDate() function. For example, in the image above, the date that includes \u201c7AM\u201d is giving an error message, but the ones with \u201c2:42 PM\u201d and \u201c3:22PM\u201d are being converted.\n+\n+###### now()\n+\n+Returns the current time in the [ISO 8601 extended format](exploring#data-types). For example, 12:58pm on October 28th 2020 returns [date 2020-10-28T16:58:32Z].", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwOTUwNQ=="}, "originalCommit": {"oid": "91b0bca29f37c00090ad5d43d2a78d45a60c5fab"}, "originalPosition": 390}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNzU5OQ==", "bodyText": "Yes, I think dates are worth further expansion somewhere. That bit of text has been moved around a bit as I wasn't sure where to drop it. Maybe under overview > data types, rather than under the transforms.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r531117599", "createdAt": "2020-11-26T15:55:46Z", "author": {"login": "allanaaa"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -0,0 +1,547 @@\n+---\n+id: grelfunctions\n+title: GREL functions\n+sidebar_label: GREL functions\n+---\n+\n+## Reading this reference\n+\n+For the reference below, the function is given in full-length notation and the in-text examples are written in dot notation. Shorthands are used to indicate the kind of [data type](exploring#data-types) used in each function: s for string, b for boolean, n for number, d for date, a for array, as well as with \u201cnull\u201d and \u201cerror.\u201d \n+\n+If a function can take more than one kind of data as input or can output more than one kind of data, that is indicated with more than one letter (as with \u201cs or a\u201d) or with o for object. \n+\n+We also use shorthands for substring (\u201csub\u201d) and separator string (\u201csep\u201d). \n+Optional arguments will say \u201c(optional)\u201d.\n+\n+In places where OpenRefine will accept a string or a regex pattern, you can supply a string by putting it in quotes. If you wish to use any regex notation, wrap the pattern in forward slashes.\n+\n+## Boolean functions\n+\n+###### and(b1, b2, ...)\n+\n+Uses the logical operator AND on two or more booleans to yield a boolean. Evaluates multiple statements into booleans, then returns true if all of the statements are true. For example, `and(1 < 3, 1 < 0)` returns false because one condition is true and one is false.\n+\n+###### or(b1, b2, ...)\n+\n+Uses the logical operator OR on two or more booleans to yield a boolean. For example, `or(1 < 3, 1 > 7)` returns true because at least one of the conditions (the first one) is true.\n+\n+###### not(b)\n+\n+Uses the logical operator NOT on a boolean to yield a boolean. For example, `not(1 > 7)` returns true because 1 > 7 itself is false.\n+\n+###### xor(b1, b2, ...)\n+\n+Uses the logical operator XOR (exclusive-or) on two or more booleans to yield a boolean. Evaluates multiple statements, then returns true if only one of them is true. For example, `xor(1 < 3, 1 < 7)` returns false because more than one of the conditions is true.\n+\n+## String functions\n+\n+###### length(s)\n+\n+Returns the length of string s as a number.\n+\n+###### toString(o, string format (optional))\n+\n+Takes any value type (string, number, date, boolean, error, null) and gives a string version of that value. You can convert between types, within limits (for example, you can't turn the string \u201casdfsd\u201d into a date or a number, but you can convert the number \u201c123\u201d into a string).\n+\n+You can also use toString() to convert numbers to strings with rounding, using an [optional string format](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). For example, if you applied the expression `value.toString(\"%.0f\")` to a column:\n+\n+|Input|Output|\n+|-|-|\n+|3.2|3|\n+|0.8|1|\n+|0.15|0|\n+|100.0|100|\n+\n+You can also convert dates to strings, using date parsing syntax built in to OpenRefine (see [the toDate() function for details](#todateo-boolean-month_first--format1-format2--)). For example,  `value.toString(\"MMM-dd-yyyy\")` would convert the date value [2024-10-15T00:00:00Z] to \u201cOct-15-2024\u201d.\n+\n+Note: In OpenRefine, using toString() on a null cell outputs the string \u201cnull\u201d.\n+\n+### Testing string characteristics\n+\n+###### startsWith(s, sub)\n+\n+Returns a boolean indicating whether s starts with sub. For example, `\"food\".startsWith(\"foo\")` returns true, whereas `\"food\".startsWith(\"bar\")` returns false. \n+\n+###### endsWith(s, sub)\n+\n+Returns a boolean indicating whether s ends with sub. For example, `\"food\".endsWith(\"ood\")` returns true, whereas `\"food\".endsWith(\"odd\")` returns false. \n+\n+###### contains(s, sub or p)\n+\n+Returns a boolean indicating whether s contains sub, which is either a substring or a regex pattern. For example, `\"food\".contains(\"oo\")` returns true whereas `\"food\".contains(\"ee\")` returns false. \n+\n+You can search for a regular expression by wrapping it in forward slashes rather than quotes: `\"rose is a rose\".contains(/\\s+/)` returns true. startsWith() and endsWith() can only take strings, while contains() can take a regex pattern, so you can use contains() to look for beginning and ending string patterns.  \n+\n+### Basic string modification\n+\n+#### Case conversion\n+\n+###### toLowercase(s)\n+\n+Returns string s converted to all lowercase characters.\n+\n+###### toUppercase(s)\n+\n+Returns string s converted to all uppercase characters.\n+\n+###### toTitlecase(s)\n+\n+Returns string s converted into titlecase: a capital letter starting each word, and the rest of the letters lowercase. For example, `\"Once upon a midnight DREARY\".toTitlecase()` returns the string \u201cOnce Upon A Midnight Dreary\u201d.\n+\n+#### Trimming\n+\n+###### trim(s) \n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".trim()` returns the string \u201cisland\u201d. Identical to strip().\n+\n+###### strip(s)\n+\n+Returns a copy of the string s with leading and trailing whitespace removed. For example, `\" island \".strip()` returns the string \u201cisland\u201d. Identical to trim().\n+\n+###### chomp(s, sep)\n+\n+Returns a copy of string s with the string sep removed from the end if s ends with sep; otherwise, just returns s. For example, `\"hardly\".chomp(\"ly\")` and `\"hard\".chomp(\"ly\")` both return the string \u201chard\u201d.\n+\n+#### Substring\n+\n+###### substring(s, n from, n to (optional))\n+\n+Returns the substring of s starting from character index from, and up to (excluding) character index to. If the to argument is omitted, substring will output to the end of s. For example, `\"profound\".substring(3)` returns the string \u201cfound\u201d, and `\"profound\".substring(2, 4)` returns the string \u201cof\u201d.\n+\n+Character indexes start from zero. Negative character indexes count from the end of the string. For example, `\"profound\".substring(0, -1)` returns the string \u201cprofoun\u201d.\n+\n+###### slice(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with arrays; see [Array functions section](#slicea-n-from-n-to-optional).\n+\n+###### get(s, n from, n to (optional))\n+\n+Identical to substring() in relation to strings. Also works with named fields. Also works with arrays; see [Array functions section](#geta-n-or-s-from-n-to-optional).\n+\n+#### Find and replace\n+\n+###### indexOf(s, sub)\n+\n+Returns the first character index of sub as it first occurs in s; or, returns -1 if s does not contain sub. For example, `\"internationalization\".indexOf(\"nation\")` returns 5, whereas `\"internationalization\".indexOf(\"world\")` returns -1.\n+\n+###### lastIndexOf(s, sub)\n+\n+Returns the first character index of sub as it last occurs in s; or, returns -1 if s does not contain sub. For example, `\"parallel\".lastIndexOf(\"a\")` returns 3 (pointing at the second \u201ca\u201d).\n+\n+###### replace(s, s or p find, s replace)\n+\n+Returns the string obtained by replacing the find string with the replace string in the inputted string. For example, `\"The cow jumps over the moon and moos\".replace(\"oo\", \"ee\")` returns the string \u201cThe cow jumps over the meen and mees\u201d. Find can be a regex pattern; if so, replace can also contain capture groups declared in find. \n+\n+You cannot find or replace nulls with this, as null is not a string. You can instead:\n+\n+1. Facet by null and then bulk-edit them to a string, or\n+2. Transform the column with an expression such as `if(value==null,'new',value)`\n+\n+###### replaceChars(s, s find, s replace)\n+\n+Returns the string obtained by replacing a character in s, identified by find, with the corresponding character identified in replace. For example, `\"T\u00e9xt th\u00e1t was opt\u00edc\u00e1lly rec\u00f3gn\u00edz\u00e9d\".replaceChars(\"\u00e1\u00e9\u00ed\u00f3\u00fa\", \"aeiou\")` returns the string \u201cText that was optically recognized\u201d. You cannot use this to replace a single character with more than one character.\n+\n+###### find(s, sub or p)\n+\n+Outputs an array of all consecutive substrings inside string s that match the substring or [regex](#grel-supported-regex) pattern p. For example, `\"abeadsabmoloei\".find(/[aeio]+/)` would result in the array [ \"a\", \"ea\", \"a\", \"o\", \"oei\" ].\n+\n+You can supply a sub instead of p, by putting it in quotes, and OpenRefine will compile it into a regex pattern. Anytime you supply quotes, OpenRefine interprets the contents as a string, not regex. If you wish to use any regex notation, wrap the pattern in forward slashes, for example: `\"OpenRefine is Awesome\".find(/fine\\sis/)` would return [ \"fine is\" ].\n+\n+###### match(s, p)\n+\n+Attempts to match the string s in its entirety against the [regex](#grel-supported-regex) pattern p and, if the pattern is found, outputs an array of all [capturing groups](https://www.regular-expressions.info/brackets.html) (found in order). For example, `\"230.22398, 12.3480\".match(/.*(\\d\\d\\d\\d)/)` returns an array of 1 substring: [ \"3480\" ]. It does not find 2239 as the first sequence with four digits, because the regex indicates the four digits must come at the end of the string.\n+\n+You will need to convert the array to a string to store it in a cell, with a function such as toString(). An empty array [] is returned when there is no match to the desired substrings. A null is output when the entire regex does not match.\n+\n+Remember to enclose your regex in forward slashes, and to escape characters and use parentheses as needed. Parentheses are required to denote a desired substring (capturing group); for example, \u201c.&#42;(\\d\\d\\d\\d)\u201d would return an array containing a single value, while \u201c(.&#42;)(\\d\\d\\d\\d)\u201d would return two. So, if you are looking for a desired substring anywhere within a string, use the syntax `value.match(/.*(desired-substring-regex).*/)`.\n+\n+For example, if the value is \u201chello 123456 goodbye\u201d:\n+\n+|Expression|Result|\n+|-|-|\n+|`value.match(/\\d{6}/)` |null (does not match the full string)|\n+|`value.match(/.*\\d{6}.*/)` |[ ] (no indicated substring)|\n+|`value.match(/.*(\\d{6}).*/)` |[ \"123456\" ] (array with one value)|\n+|`value.match(/(.*)(\\d{6})(.*)/)` |[ \"hello \", \"123456\", \" goodbye\" ] (array with three values)|\n+\n+### String parsing and splitting\n+\n+###### toNumber(s)\n+\n+Returns a string converted to a number. Will attempt to convert other formats into a string, then into a number. If the value is already a number, it will return the number.\n+\n+###### split(s, s or p sep)\n+\n+Returns the array of strings obtained by splitting s by sep. The separator can be either a string or a regex pattern. For example, `\"fire, water, earth, air\".split(\",\")` returns an array of 4 strings: [ \"fire\", \" water\", \" earth\", \" air\" ]. Note that the space characters are retained but the separator is removed.\n+\n+###### splitByLengths(s, n1, n2, ...)\n+\n+Returns the array of strings obtained by splitting s into substrings with the given lengths. For example, `\"internationalization\".splitByLengths(5, 6, 3)` returns an array of 3 strings: [ \"inter\", \"nation\", \"ali\" ]. Excess characters are discarded.\n+\n+###### smartSplit(s, s or p sep (optional))\n+\n+Returns the array of strings obtained by splitting s by sep, or by guessing either tab or comma separation if there is no sep given. Handles quotes properly and understands cancelled characters. The separator can be either a string or a regex pattern. For example, `value.smartSplit(\"\\n\")` will split at a carriage return or a new-line character.\n+\n+Note: `value.[escape](#escapes-s-mode)('javascript')` is useful for previewing unprintable characters prior to using smartSplit().\n+\n+###### splitByCharType(s)\n+\n+Returns an array of strings obtained by splitting s into groups of consecutive characters each time the characters change unicode types. For example, `\"HenryCTaylor\".splitByCharType()` will result in an array of [ \"H\", \"enry\", \"CT\", \"aylor\" ].\n+\n+It is useful for separating letters and numbers: `\"BE1A3E\".splitByCharType()` will result in [ \"BE\", \"1\", \"A\", \"3\", \"E\" ].\n+\n+###### partition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the first occurrence of fragment, and z is the substring after fragment. Fragment can be a string or a regex. For example, `\"internationalization\".partition(\"nation\")` returns 3 strings: [ \"inter\", \"nation\", \"alization\" ]. If s does not contain fragment, it returns an array of [ s, \"\", \"\" ] (the original unpartitioned string, and two empty strings). \n+\n+If the omitFragment boolean is true, for example with `\"internationalization\".partition(\"nation\", true)`, the fragment is not returned. The output is [ \"inter\", \"alization\" ].\n+\n+You can use regex for your fragment. The expresion `\"abcdefgh\".partition(/c.e/)` will output  [\u201cabc\u201d, \"cde\", defgh\u201d ]. \n+\n+###### rpartition(s, s or p fragment, b omitFragment (optional))\n+\n+Returns an array of strings [ a, fragment, z ] where a is the substring within s before the last occurrence of fragment, and z is the substring after the last instance of fragment. (Rpartition means \u201creverse partition.\u201d) For example, `\"parallel\".rpartition(\"a\")` returns 3 strings: [ \"par\", \"a\", \"llel\" ]. \n+\n+Otherwise works identically to partition() above.\n+\n+### Encoding and hashing\n+\n+###### diff(s1, s2, s timeUnit (optional))\n+\n+Takes two strings and compares them, returning a string. Returns the remainder of s2 starting with the first character where they differ. For example, `diff(\"cacti\", \"cactus\")` returns \"us\". Also works with dates; see [Date functions](#diffd1-d2-s-timeunit).\n+\n+###### escape(s, s mode)\n+\n+Escapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#question-marks--showing-in-your-data) for examples of escaping and unescaping.\n+\n+###### unescape(s, s mode)\n+\n+Unescapes s in the given escaping mode. The mode can be one of: \"html\", \"xml\", \"csv\", \"url\", \"javascript\". Note that quotes are required around your mode. See the [recipes](https://github.com/OpenRefine/OpenRefine/wiki/Recipes#atampampt----att) for examples of escaping and unescaping. \n+\n+###### md5(o)\n+\n+Returns the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of an object. If fed something other than a string (array, number, date, etc.), md5() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".md5()` will return 2c55a1626e31b4e373ceedaa9adc12a3.\n+\n+###### sha1(o)\n+\n+Returns the [SHA-1 hash](https://en.wikipedia.org/wiki/SHA-1) of an object. If fed something other than a string (array, number, date, etc.), sha1() will convert it to a string and deliver the hash of the string. For example, `\"internationalization\".sha1()` will return cd05286ee0ff8a830dbdc0c24f1cb68b83b0ef36.\n+\n+###### phonetic(s, s encoding)\n+\n+Returns a phonetic encoding of a string, based on an available phonetic algorithm. See the [section on phonetic clustering](cellediting#clustering-methods) for more information. Can be one of the following supported phonetic methods: [metaphone, doublemetaphone, metaphone3](https://www.wikipedia.org/wiki/Metaphone), [soundex](https://en.wikipedia.org/wiki/Soundex), [cologne](https://en.wikipedia.org/wiki/Cologne_phonetics). Quotes are required around your encoding method. For example, `\"Ruth Prawer Jhabvala\".phonetic(\"metaphone\")` outputs the string \u201cR0PRWRJHBFL\u201d.  \n+\n+###### reinterpret(s, s encoder)\n+\n+Returns s reinterpreted through the given character encoder. You must supply one of the [supported encodings](http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html). Note that quotes are required around your character encoder.\n+\n+When an OpenRefine project is started, data is imported and interpreted. A specific character encoding is identified or manually selected at that time (such as UTF-8). You can reinterpret a column into another specificed encoding using this function. This function may not fix your data; it may be better to use this in conjunction with new projects to test the interpretation, and pre-format your data as needed. \n+\n+###### fingerprint(s)\n+\n+Returns the fingerprint of s, a string that is the first step in [fingerprint clustering methods](cellediting#clustering-methods): it will trim whitespaces, convert all characters to lowercase, remove punctuation, sort words alphabetically, etc. For example, `\"Ruth  Prawer    Jhabvala\".fingerprint()` outputs the string \u201cjhabvala prawer ruth\u201d.\n+\n+###### ngram(s, n)\n+\n+Returns an array of the word n-grams of s. That is, it lists all the possible consecutive combinations of n words in the string. For example, `\"Ruth Prawer Jhabvala\".ngram(2)` would output the array [ \"Ruth Prawer\", \"Prawer Jhabvala\" ]. A word n-gram of 1 simply lists all the words in original order; an n-gram larger than the number of words in the string will only return the original string inside an array (e.g. `\"Ruth Prawer Jhabvala\".ngram(4)` would simply return [\"Ruth Prawer Jhabvala\"]).\n+\n+###### ngramFingerprint(s, n)\n+\n+Returns the [n-gram fingerprint](cellediting#clustering-methods) of s. For example, `\"banana\".ngram(2)` would output \u201canbana\u201d, after first generating the 2-grams \u201cba an na an na\u201d, removing duplicates, and sorting them alphabetically.\n+\n+###### unicode(s)\n+\n+Returns an array of strings describing each character of s in their full unicode notation. For example, `\"Bernice Rubens\".unicode()` outputs [ 66, 101, 114, 110, 105, 99, 101, 32, 82, 117, 98, 101, 110, 115 ].\n+\n+###### unicodeType(s)\n+\n+Returns an array of strings describing each character of s by their unicode type. For example, `\"Bernice Rubens\".unicodeType()` outputs [ \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"space separator\", \"uppercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\", \"lowercase letter\" ].\n+\n+## Format-based functions (JSON, HTML, XML)\n+\n+###### jsonize(o)\n+\n+Quotes a value as a JSON literal value.\n+\n+###### parseJson(s)\n+\n+Parses a string as JSON. get() can then be used with parseJson(): for example, `parseJson(\" { 'a' : 1 } \").get(\"a\")` returns 1.\n+\n+For example from the following JSON array, let's get all instances called \u201ckeywords\u201d having the same object string name of \u201ctext\u201d, and combine it with the forEach() function to iterate over the array.\n+\n+    {\n+       \"status\":\"OK\",\n+       \"url\":\"\",\n+       \"language\":\"english\",\n+       \"keywords\":[\n+          {\n+             \"text\":\"York en route\",\n+             \"relevance\":\"0.974363\"\n+          },\n+          {\n+             \"text\":\"Anthony Eden\",\n+             \"relevance\":\"0.814394\"\n+          },\n+          {\n+             \"text\":\"President Eisenhower\",\n+             \"relevance\":\"0.700189\"\n+          }\n+       ]\n+    }\n+\n+The GREL expression `forEach(value.parseJson().keywords,v,v.text).join(\":::\")` will output \u201cYork en route:::Anthony Eden:::President Eisenhower\u201d.\n+\n+### Jsoup XML and HTML parsing\n+\n+###### parseHtml(s)\n+Given a cell full of HTML-formatted text, simplifies HTML tags (such as by removing \u201c /\u201d at the end of self-closing tags), closes any unclosed tags, and inserts linebreaks and indents for cleaner code. You cannot pass parseHtml() a URL, but you can pre-fetch HTML with the <span class=\"menuItems\">Add column by fetching URLs</span> menu option. A cell cannot store the output of parseHtml() unless you convert it with toString(). \n+\n+When parseHtml() simplifies HTML, it can sometimes introduce errors. When closing tags, it makes its best guesses based on line breaks, indentation, and the presence of other tags. You may need to manually check the results. \n+\n+You can then extract or select() which portions of the HTML document you need for further splitting, partitioning, etc. An example of extracting all table rows from a div using parseHtml().select() together is described more in depth at [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+###### parseXml(s)\n+Given a cell full of XML-formatted text, returns a full XML document and adds any missing closing tags. You can then extract or select() which portions of the XML document you need for further splitting, partitioning, etc. Functions the same way as parseHtml() is described above. \n+\n+###### select(s, element)\n+Returns an array of all the desired elements from an HTML or XML document, if the element exists. Elements are identified using the [Jsoup selector syntax](https://jsoup.org/apidocs/org/jsoup/select/Selector.html). For example, `value.parseHtml().select(\"img.portrait\")[0]` would return the entirety of the first \u201cimg\u201d tag with the \u201cportrait\u201d class found in the parsed HTML inside `value`. Returns an empty array if no matching element is found. Use with toString() to capture the results in a cell. A tutorial of select() is shown in [StrippingHTML](https://github.com/OpenRefine/OpenRefine/wiki/StrippingHTML).\n+\n+You can use select() more than once:\n+\n+```\n+value.parseHtml().select(\"div#content\")[0].select(\"tr\").toString()\n+```\n+\n+###### htmlAttr(s, element)\n+Returns a string from an attribute on an HTML element. Use it in conjunction with parseHtml() as in the following example: `value.parseHtml().select(\"a.email\")[0].htmlAttr(\"href\")`.\n+\n+###### xmlAttr(s, element)\n+Returns a string from an attribute on an XML element. Function the same way htmlAttr() is described above. Use it in conjunction with parseXml().\n+\n+###### htmlText(element)\n+Returns a string of the text from within an HTML element (including all child elements), removing HTML tags and line breaks inside the string. Use it in conjunction with parseHtml() and select() to provide an element, as in the following example: `value.parseHtml().select(\"div.footer\")[0].htmlText()`. \n+\n+###### xmlText(element)\n+Returns a string of the text from within an XML element (including all child elements). Functions the same way as htmlText() is described above. Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### wholeText(element)\n+\n+_Works from OpenRefine 3.4.1 beta 644 onwards only_\n+\n+Selects the (unencoded) text of an element and its children, including any newlines and spaces, and returns a string of unencoded, un-normalized text. Use it in conjunction with parseHtml() and select() to provide an element as in the following example: `value.parseHtml().select(\"div.footer\")[0].wholeText()`.\n+\n+###### innerHtml(element)\n+Returns the [inner HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) of an HTML element. This will include text and children elements within the element selected. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### innerXml(element)\n+Returns all the inner XML elements inside your chosen XML element. Does not return the text directly inside your chosen XML element - only the contents of its children. To select the direct text, use ownText(). To select both, use xmlText(). Use it in conjunction with parseXml() and select() to provide an element.\n+\n+###### outerHtml(element)\n+Returns the [outer HTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/outerHTML) of an HTML element. outerHtml includes the start and end tags of the current element. Use it in conjunction with parseHtml() and select() to provide an element.\n+\n+###### ownText(element)\n+Returns the text directly inside the selected XML or HTML element only, ignoring text inside children elements. Use it in conjunction with a parser and select() to provide an element.\n+\n+## Array functions\n+\n+###### length(a)\n+Returns the size of an array, meaning the number of objects inside it. Arrays can be empty, in which case length() will return 0. \n+\n+###### slice(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. If to is omitted, it is understood to be the end of the array. For example, `[0, 1, 2, 3, 4].slice(1, 3)` returns [ 1, 2 ], and `[ 0, 1, 2, 3, 4].slice(1)` returns [ 1, 2, 3, 4 ]. Also works with strings; see [String functions](#slices-n-from-n-to-optional).\n+\n+###### get(a, n from, n to (optional))\n+Returns a sub-array of a given array, from the first index provided and up to and excluding the optional last index provided. Remember that array objects are indexed starting at 0. \n+\n+If to is omitted, only one array item is returned, as a string, instead of a sub-array. To return a sub-array from one index to the end, you can set the to argument to a very high number such as `value.get(2,999)` or you can use something like `with(value,a,a.get(1,a.length()))` to count the length of each array.\n+\n+Also works with strings; see [get() in String functions](#gets-n-from-n-to-optional).\n+\n+###### inArray(a, s)\n+Returns true if the array contains the desired string, and false otherwise.\n+\n+###### reverse(a)\n+Reverses the array. For example, `[ 0, 1, 2, 3].reverse()` returns the array [ 3, 2, 1, 0 ].\n+\n+###### sort(a)\n+Sorts the array in ascending order. Sorting is case-sensitive, uppercase first and lowercase second. For example, `[ \"al\", \"Joe\", \"Bob\", \"jim\" ].sort()` returns the array [ \"Bob\", \"Joe\", \"al\", \"jim\" ]. \n+\n+###### sum(a)\n+Return the sum of the numbers in the array. For example, `[ 2, 1, 0, 3].sum()` returns 6.\n+\n+###### join(a, sep)\n+Joins the items in the array with sep, and returns it all as a string. For example, `[ \"and\", \"or\", \"not\" ].join(\"/\")` returns the string \u201cand/or/not\u201d.\n+\n+###### uniques(a)\n+Returns the array with duplicates removed. Case-sensitive. For example, `[ \"al\", \"Joe\", \"Bob\", \"Joe\", \"Al\", \"Bob\" ].uniques()` returns the array [ \"Joe\", \"al\", \"Al\", \"Bob\" ]. \n+\n+As of OpenRefine 3.4.1, uniques() reorders the array items it returns; in 3.4 beta 644 and onwards, it preserves the original order (in this case, [ \"al\", \"Joe\", \"Bob\", \"Al\" ]). \n+\n+## Date functions\n+If you have a column full of dates in a more common format (such as yyyy/mm/dd or YYYYMMDD) you can convert these using [\u201cTransform\u201d > \u201cCommon transforms \u2026\u201d > \u201cto date\u201d](cellediting#data-type-transforms), or the GREL function toDate(). You may wish to create a new column with the transformation, in order to also preserve the more human-readable version.\n+\n+OpenRefine uses [Date.parse()](https://www.w3schools.com/jsref/jsref_parse.asp) to recognize a variety of formats and convert them, including converting from other time zones to UTC:\n+\n+![A screenshot of different date formats being converted, and one error.](/img/dates.png)\n+\n+You may need to do some reformatting if your dates are not being recognized by the toDate() function. For example, in the image above, the date that includes \u201c7AM\u201d is giving an error message, but the ones with \u201c2:42 PM\u201d and \u201c3:22PM\u201d are being converted.\n+\n+###### now()\n+\n+Returns the current time in the [ISO 8601 extended format](exploring#data-types). For example, 12:58pm on October 28th 2020 returns [date 2020-10-28T16:58:32Z].", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwOTUwNQ=="}, "originalCommit": {"oid": "91b0bca29f37c00090ad5d43d2a78d45a60c5fab"}, "originalPosition": 390}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTIwMjUxOnYy", "diffSide": "RIGHT", "path": "docs/docs/manual/grelfunctions.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo1MDoyNlrOH6gp_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo1Nzo1MlrOH6g7Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNDQ5NA==", "bodyText": "Sorry - a further refinement. That example only works if you specify the timezone of the original date/time", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r531114494", "createdAt": "2020-11-26T15:50:26Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -377,17 +377,10 @@ Returns the array with duplicates removed. Case-sensitive. For example, `[ \"al\",\n As of OpenRefine 3.4.1, uniques() reorders the array items it returns; in 3.4 beta 644 and onwards, it preserves the original order (in this case, [ \"al\", \"Joe\", \"Bob\", \"Al\" ]). \n \n ## Date functions\n-If you have a column full of dates in a more common format (such as yyyy/mm/dd or YYYYMMDD) you can convert these using [\u201cTransform\u201d > \u201cCommon transforms \u2026\u201d > \u201cto date\u201d](cellediting#data-type-transforms), or the GREL function toDate(). You may wish to create a new column with the transformation, in order to also preserve the more human-readable version.\n-\n-OpenRefine uses [Date.parse()](https://www.w3schools.com/jsref/jsref_parse.asp) to recognize a variety of formats and convert them, including converting from other time zones to UTC:\n-\n-![A screenshot of different date formats being converted, and one error.](/img/dates.png)\n-\n-You may need to do some reformatting if your dates are not being recognized by the toDate() function. For example, in the image above, the date that includes \u201c7AM\u201d is giving an error message, but the ones with \u201c2:42 PM\u201d and \u201c3:22PM\u201d are being converted.\n \n ###### now()\n \n-Returns the current time in the [ISO 8601 extended format](exploring#data-types). For example, 12:58pm on October 28th 2020 returns [date 2020-10-28T16:58:32Z].\n+Returns the current time according to your system clock, in the [ISO 8601 extended format](exploring#data-types) (converted to UTC). For example, 12:58pm on October 28th 2020 returns [date 2020-10-28T16:58:32Z].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "943c4a0d517d22cde7dbc7c2c77a0b2b023760b3"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNTcwNg==", "bodyText": "I mean - for me at 12:58pm (and 32 seconds) on October 28th 2020 now() would return [date 2020-10-28T12:58:00Z]\nAlso - probably should include seconds in the text or have the returned time ending :00", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r531115706", "createdAt": "2020-11-26T15:52:27Z", "author": {"login": "ostephens"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -377,17 +377,10 @@ Returns the array with duplicates removed. Case-sensitive. For example, `[ \"al\",\n As of OpenRefine 3.4.1, uniques() reorders the array items it returns; in 3.4 beta 644 and onwards, it preserves the original order (in this case, [ \"al\", \"Joe\", \"Bob\", \"Al\" ]). \n \n ## Date functions\n-If you have a column full of dates in a more common format (such as yyyy/mm/dd or YYYYMMDD) you can convert these using [\u201cTransform\u201d > \u201cCommon transforms \u2026\u201d > \u201cto date\u201d](cellediting#data-type-transforms), or the GREL function toDate(). You may wish to create a new column with the transformation, in order to also preserve the more human-readable version.\n-\n-OpenRefine uses [Date.parse()](https://www.w3schools.com/jsref/jsref_parse.asp) to recognize a variety of formats and convert them, including converting from other time zones to UTC:\n-\n-![A screenshot of different date formats being converted, and one error.](/img/dates.png)\n-\n-You may need to do some reformatting if your dates are not being recognized by the toDate() function. For example, in the image above, the date that includes \u201c7AM\u201d is giving an error message, but the ones with \u201c2:42 PM\u201d and \u201c3:22PM\u201d are being converted.\n \n ###### now()\n \n-Returns the current time in the [ISO 8601 extended format](exploring#data-types). For example, 12:58pm on October 28th 2020 returns [date 2020-10-28T16:58:32Z].\n+Returns the current time according to your system clock, in the [ISO 8601 extended format](exploring#data-types) (converted to UTC). For example, 12:58pm on October 28th 2020 returns [date 2020-10-28T16:58:32Z].", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNDQ5NA=="}, "originalCommit": {"oid": "943c4a0d517d22cde7dbc7c2c77a0b2b023760b3"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExODg1MQ==", "bodyText": "Of course, I should've formatted that right. Thanks.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3264#discussion_r531118851", "createdAt": "2020-11-26T15:57:52Z", "author": {"login": "allanaaa"}, "path": "docs/docs/manual/grelfunctions.md", "diffHunk": "@@ -377,17 +377,10 @@ Returns the array with duplicates removed. Case-sensitive. For example, `[ \"al\",\n As of OpenRefine 3.4.1, uniques() reorders the array items it returns; in 3.4 beta 644 and onwards, it preserves the original order (in this case, [ \"al\", \"Joe\", \"Bob\", \"Al\" ]). \n \n ## Date functions\n-If you have a column full of dates in a more common format (such as yyyy/mm/dd or YYYYMMDD) you can convert these using [\u201cTransform\u201d > \u201cCommon transforms \u2026\u201d > \u201cto date\u201d](cellediting#data-type-transforms), or the GREL function toDate(). You may wish to create a new column with the transformation, in order to also preserve the more human-readable version.\n-\n-OpenRefine uses [Date.parse()](https://www.w3schools.com/jsref/jsref_parse.asp) to recognize a variety of formats and convert them, including converting from other time zones to UTC:\n-\n-![A screenshot of different date formats being converted, and one error.](/img/dates.png)\n-\n-You may need to do some reformatting if your dates are not being recognized by the toDate() function. For example, in the image above, the date that includes \u201c7AM\u201d is giving an error message, but the ones with \u201c2:42 PM\u201d and \u201c3:22PM\u201d are being converted.\n \n ###### now()\n \n-Returns the current time in the [ISO 8601 extended format](exploring#data-types). For example, 12:58pm on October 28th 2020 returns [date 2020-10-28T16:58:32Z].\n+Returns the current time according to your system clock, in the [ISO 8601 extended format](exploring#data-types) (converted to UTC). For example, 12:58pm on October 28th 2020 returns [date 2020-10-28T16:58:32Z].", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNDQ5NA=="}, "originalCommit": {"oid": "943c4a0d517d22cde7dbc7c2c77a0b2b023760b3"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2903, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}