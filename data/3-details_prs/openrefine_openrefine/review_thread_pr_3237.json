{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1ODk0MDE2", "number": 3237, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxOTo0MTozOFrOE6MIfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxOTo0Mjo0M1rOE6MLaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDUxNjQ1OnYy", "diffSide": "LEFT", "path": "main/src/com/google/refine/model/recon/ReconciledDataExtensionJob.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxOTo0MTozOFrOH1GeOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwNTozMTo0NFrOIAWoQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0MjYxOA==", "bodyText": "I would leave this comment since this refactoring does not address this yet.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3237#discussion_r525442618", "createdAt": "2020-11-17T19:41:38Z", "author": {"login": "wetneb"}, "path": "main/src/com/google/refine/model/recon/ReconciledDataExtensionJob.java", "diffHunk": "@@ -218,46 +203,17 @@ public ReconciledDataExtensionJob(DataExtensionConfig obj, String endpoint) {\n         return map;\n     }\n \n-    /**\n-     * @todo this should be refactored to be unified with the HTTP querying code\n-     * from StandardReconConfig. We should ideally extract a library to query\n-     * reconciliation services and expose it as such for others to reuse.\n-     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e9756988392572780508a84f6d2c1698176915"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyOTQ2Ng==", "bodyText": "My thought here was that the refactoring in this PR was a superset of the suggest recon-only client. Is that not true? What special requirements does reconciliation have? The code that I thought the comment was referring to is just a single line now.\nThe Create Project streaming is a slightly different use, but it's already accommodated in the current code.\nI can add a version of the comment back if it's still relevant, but perhaps we should update it to reflect the current state of affairs.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3237#discussion_r532129466", "createdAt": "2020-11-29T01:47:04Z", "author": {"login": "tfmorris"}, "path": "main/src/com/google/refine/model/recon/ReconciledDataExtensionJob.java", "diffHunk": "@@ -218,46 +203,17 @@ public ReconciledDataExtensionJob(DataExtensionConfig obj, String endpoint) {\n         return map;\n     }\n \n-    /**\n-     * @todo this should be refactored to be unified with the HTTP querying code\n-     * from StandardReconConfig. We should ideally extract a library to query\n-     * reconciliation services and expose it as such for others to reuse.\n-     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0MjYxOA=="}, "originalCommit": {"oid": "52e9756988392572780508a84f6d2c1698176915"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NDc1NA==", "bodyText": "I was thinking about a java library to query reconciliation services. You would be able to construct a reconciliation query with POJOs and send it to a service described by a URL (without having to worry about the JSON serialization of that reconciliation query, for instance). This is more high-level than a HTTP library: it would abstract away the specifics of how reconciliation clients and servers communicate over HTTP.\nSuch a library could also be the basis of a framework to build reconciliation services.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3237#discussion_r532154754", "createdAt": "2020-11-29T04:43:36Z", "author": {"login": "wetneb"}, "path": "main/src/com/google/refine/model/recon/ReconciledDataExtensionJob.java", "diffHunk": "@@ -218,46 +203,17 @@ public ReconciledDataExtensionJob(DataExtensionConfig obj, String endpoint) {\n         return map;\n     }\n \n-    /**\n-     * @todo this should be refactored to be unified with the HTTP querying code\n-     * from StandardReconConfig. We should ideally extract a library to query\n-     * reconciliation services and expose it as such for others to reuse.\n-     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0MjYxOA=="}, "originalCommit": {"oid": "52e9756988392572780508a84f6d2c1698176915"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NzQ3NA==", "bodyText": "That sounds like it has very little, if anything to do with OpenRefine, but I'll put the comment back with a clarification that it's talking about a 3rd party library.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3237#discussion_r532257474", "createdAt": "2020-11-29T19:53:48Z", "author": {"login": "tfmorris"}, "path": "main/src/com/google/refine/model/recon/ReconciledDataExtensionJob.java", "diffHunk": "@@ -218,46 +203,17 @@ public ReconciledDataExtensionJob(DataExtensionConfig obj, String endpoint) {\n         return map;\n     }\n \n-    /**\n-     * @todo this should be refactored to be unified with the HTTP querying code\n-     * from StandardReconConfig. We should ideally extract a library to query\n-     * reconciliation services and expose it as such for others to reuse.\n-     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0MjYxOA=="}, "originalCommit": {"oid": "52e9756988392572780508a84f6d2c1698176915"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI0MTY2Ng==", "bodyText": "I've restored the comment, moved it so it's not on a single line method, and updated it with my limited understanding of what the task is. I've also rebased it to pick up the new CI code and will merge it when the tests pass.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3237#discussion_r537241666", "createdAt": "2020-12-07T05:31:44Z", "author": {"login": "tfmorris"}, "path": "main/src/com/google/refine/model/recon/ReconciledDataExtensionJob.java", "diffHunk": "@@ -218,46 +203,17 @@ public ReconciledDataExtensionJob(DataExtensionConfig obj, String endpoint) {\n         return map;\n     }\n \n-    /**\n-     * @todo this should be refactored to be unified with the HTTP querying code\n-     * from StandardReconConfig. We should ideally extract a library to query\n-     * reconciliation services and expose it as such for others to reuse.\n-     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0MjYxOA=="}, "originalCommit": {"oid": "52e9756988392572780508a84f6d2c1698176915"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDUyMzkyOnYy", "diffSide": "LEFT", "path": "main/src/com/google/refine/model/recon/StandardReconConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxOTo0Mjo0M1rOH1GjUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwMTo1NDozOFrOH7eozg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0MzkyMA==", "bodyText": "I'd also leave this TODO since error reporting should not be in the server logs: users should be notified about it.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3237#discussion_r525443920", "createdAt": "2020-11-17T19:42:43Z", "author": {"login": "wetneb"}, "path": "main/src/com/google/refine/model/recon/StandardReconConfig.java", "diffHunk": "@@ -475,51 +463,40 @@ private CloseableHttpClient getHttpClient() {\n         stringWriter.write(\"}\");\n         String queriesString = stringWriter.toString();\n         \n-        HttpPost request = new HttpPost(service);\n-        List<NameValuePair> body = Collections.singletonList(\n-                new BasicNameValuePair(\"queries\", queriesString));\n-        request.setEntity(new UrlEncodedFormEntity(body, Consts.UTF_8));\n-        \n-        try (CloseableHttpResponse response = getHttpClient().execute(request)) {\n-            StatusLine statusLine = response.getStatusLine();\n-            if (statusLine.getStatusCode() >= 400) {\n-                logger.error(\"Failed  - code: \"\n-                        + Integer.toString(statusLine.getStatusCode())\n-                        + \" message: \" + statusLine.getReasonPhrase());\n+        try {\n+            String responseString = postQueries(service, queriesString);\n+            ObjectNode o = ParsingUtilities.evaluateJsonStringToObjectNode(responseString);\n+\n+            if (o == null) { // utility method returns null instead of throwing\n+                logger.error(\"Failed to parse string as JSON: \" + responseString);\n             } else {\n-                String s = ParsingUtilities.inputStreamToString(response.getEntity().getContent());\n-                ObjectNode o = ParsingUtilities.evaluateJsonStringToObjectNode(s);\n-                if (o == null) { // utility method returns null instead of throwing\n-                    logger.error(\"Failed to parse string as JSON: \" + s);\n-                } else {\n-                    for (int i = 0; i < jobs.size(); i++) {\n-                        StandardReconJob job = (StandardReconJob) jobs.get(i);\n-                        Recon recon = null;\n-\n-                        String text = job.text;\n-                        String key = \"q\" + i;\n-                        if (o.has(key) && o.get(key) instanceof ObjectNode) {\n-                            ObjectNode o2 = (ObjectNode) o.get(key);\n-                            if (o2.has(\"result\") && o2.get(\"result\") instanceof ArrayNode) {\n-                                ArrayNode results = (ArrayNode) o2.get(\"result\");\n-\n-                                recon = createReconServiceResults(text, results, historyEntryID);\n-                            } else {\n-                                logger.warn(\"Service error for text: \" + text + \"\\n  Job code: \" + job.code + \"\\n  Response: \" + o2.toString());\n-                            }\n+                for (int i = 0; i < jobs.size(); i++) {\n+                    StandardReconJob job = (StandardReconJob) jobs.get(i);\n+                    Recon recon = null;\n+\n+                    String text = job.text;\n+                    String key = \"q\" + i;\n+                    if (o.has(key) && o.get(key) instanceof ObjectNode) {\n+                        ObjectNode o2 = (ObjectNode) o.get(key);\n+                        if (o2.has(\"result\") && o2.get(\"result\") instanceof ArrayNode) {\n+                            ArrayNode results = (ArrayNode) o2.get(\"result\");\n+\n+                            recon = createReconServiceResults(text, results, historyEntryID);\n                         } else {\n-                            // TODO: better error reporting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e9756988392572780508a84f6d2c1698176915"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyOTk5OA==", "bodyText": "I think you are just seeing a diff artifact. The exact same text is a couple of lines down, but I've added a second copy.", "url": "https://github.com/OpenRefine/OpenRefine/pull/3237#discussion_r532129998", "createdAt": "2020-11-29T01:54:38Z", "author": {"login": "tfmorris"}, "path": "main/src/com/google/refine/model/recon/StandardReconConfig.java", "diffHunk": "@@ -475,51 +463,40 @@ private CloseableHttpClient getHttpClient() {\n         stringWriter.write(\"}\");\n         String queriesString = stringWriter.toString();\n         \n-        HttpPost request = new HttpPost(service);\n-        List<NameValuePair> body = Collections.singletonList(\n-                new BasicNameValuePair(\"queries\", queriesString));\n-        request.setEntity(new UrlEncodedFormEntity(body, Consts.UTF_8));\n-        \n-        try (CloseableHttpResponse response = getHttpClient().execute(request)) {\n-            StatusLine statusLine = response.getStatusLine();\n-            if (statusLine.getStatusCode() >= 400) {\n-                logger.error(\"Failed  - code: \"\n-                        + Integer.toString(statusLine.getStatusCode())\n-                        + \" message: \" + statusLine.getReasonPhrase());\n+        try {\n+            String responseString = postQueries(service, queriesString);\n+            ObjectNode o = ParsingUtilities.evaluateJsonStringToObjectNode(responseString);\n+\n+            if (o == null) { // utility method returns null instead of throwing\n+                logger.error(\"Failed to parse string as JSON: \" + responseString);\n             } else {\n-                String s = ParsingUtilities.inputStreamToString(response.getEntity().getContent());\n-                ObjectNode o = ParsingUtilities.evaluateJsonStringToObjectNode(s);\n-                if (o == null) { // utility method returns null instead of throwing\n-                    logger.error(\"Failed to parse string as JSON: \" + s);\n-                } else {\n-                    for (int i = 0; i < jobs.size(); i++) {\n-                        StandardReconJob job = (StandardReconJob) jobs.get(i);\n-                        Recon recon = null;\n-\n-                        String text = job.text;\n-                        String key = \"q\" + i;\n-                        if (o.has(key) && o.get(key) instanceof ObjectNode) {\n-                            ObjectNode o2 = (ObjectNode) o.get(key);\n-                            if (o2.has(\"result\") && o2.get(\"result\") instanceof ArrayNode) {\n-                                ArrayNode results = (ArrayNode) o2.get(\"result\");\n-\n-                                recon = createReconServiceResults(text, results, historyEntryID);\n-                            } else {\n-                                logger.warn(\"Service error for text: \" + text + \"\\n  Job code: \" + job.code + \"\\n  Response: \" + o2.toString());\n-                            }\n+                for (int i = 0; i < jobs.size(); i++) {\n+                    StandardReconJob job = (StandardReconJob) jobs.get(i);\n+                    Recon recon = null;\n+\n+                    String text = job.text;\n+                    String key = \"q\" + i;\n+                    if (o.has(key) && o.get(key) instanceof ObjectNode) {\n+                        ObjectNode o2 = (ObjectNode) o.get(key);\n+                        if (o2.has(\"result\") && o2.get(\"result\") instanceof ArrayNode) {\n+                            ArrayNode results = (ArrayNode) o2.get(\"result\");\n+\n+                            recon = createReconServiceResults(text, results, historyEntryID);\n                         } else {\n-                            // TODO: better error reporting", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0MzkyMA=="}, "originalCommit": {"oid": "52e9756988392572780508a84f6d2c1698176915"}, "originalPosition": 143}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2896, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}