{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUwNDI0MzYz", "number": 659, "reviewThreads": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODo1OToxMVrOEPQwEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMzowODo0N1rOEdu0nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NDM4NTQ0OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODo1OToxMVrOGy4XWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMjozMDoxM1rOHGVxpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwNTQ2NQ==", "bodyText": "gRPC ? That's an unexpected dependency.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456005465", "createdAt": "2020-07-16T18:59:11Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -7,21 +7,36 @@\n import org.apache.kafka.common.header.Headers;\n import org.eclipse.microprofile.reactive.messaging.Metadata;\n \n+import io.grpc.Context;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwOTIzNQ==", "bodyText": "Yeah, OpenTelemetry using gRPC Context to pass things around.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456009235", "createdAt": "2020-07-16T19:05:57Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -7,21 +7,36 @@\n import org.apache.kafka.common.header.Headers;\n import org.eclipse.microprofile.reactive.messaging.Metadata;\n \n+import io.grpc.Context;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwNTQ2NQ=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI1MDY2Mg==", "bodyText": "We need to investigate how we can mitigate this in Quarkus. Depending on quarkus-grpc might be a bit too much.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456250662", "createdAt": "2020-07-17T06:46:25Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -7,21 +7,36 @@\n import org.apache.kafka.common.header.Headers;\n import org.eclipse.microprofile.reactive.messaging.Metadata;\n \n+import io.grpc.Context;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwNTQ2NQ=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMDg1OA==", "bodyText": "Any info about this?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476200858", "createdAt": "2020-08-25T06:14:05Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -7,21 +7,36 @@\n import org.apache.kafka.common.header.Headers;\n import org.eclipse.microprofile.reactive.messaging.Metadata;\n \n+import io.grpc.Context;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwNTQ2NQ=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMDI3OA==", "bodyText": "It's only the grpc Context that's needed, not the entirety of grpc", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476410278", "createdAt": "2020-08-25T12:30:13Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -7,21 +7,36 @@\n import org.apache.kafka.common.header.Headers;\n import org.eclipse.microprofile.reactive.messaging.Metadata;\n \n+import io.grpc.Context;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwNTQ2NQ=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjEwNDI5OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNzoyMzo1MlrOGzIPeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMzo0NDowOVrOGzTkqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI2NTU5NA==", "bodyText": "Is this synchronously executed on the same thread from where the message is produced?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456265594", "createdAt": "2020-07-17T07:23:52Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyNzk3Nw==", "bodyText": "Yes, is it blocking?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456327977", "createdAt": "2020-07-17T09:25:13Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI2NTU5NA=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MTI0Mg==", "bodyText": "It's done right before creating the Kafka ProducerRecord, and I don't believe it's blocking", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456451242", "createdAt": "2020-07-17T13:44:09Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI2NTU5NA=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjEzODcyOnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNzozNTowOFrOGzIkEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNTo1NjoxMFrOG0-yCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MDg2Nw==", "bodyText": "is the partition important? Could it help to debug the problem?  Shall we add it as an attribute?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456270867", "createdAt": "2020-07-17T07:35:08Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyODI4Mg==", "bodyText": "Partitions are important. They should be part of the trace (but optional)", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456328282", "createdAt": "2020-07-17T09:25:46Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MDg2Nw=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MTg0NA==", "bodyText": "On the outgoing trace I couldn't see a way to get the partitiion", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456451844", "createdAt": "2020-07-17T13:45:08Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MDg2Nw=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwNzc1NQ==", "bodyText": "I'm a numpty, the partition is set further down as an attribute", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r458207755", "createdAt": "2020-07-21T15:56:10Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MDg2Nw=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjE0NTI3OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNzozNzoxNFrOGzIn-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNTo1NzozNVrOG0-2AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MTg2NA==", "bodyText": "Set these attributes via SemanticAttributes class", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456271864", "createdAt": "2020-07-17T07:37:14Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())\n+                    .setSpanKind(Span.Kind.CONSUMER);\n+\n+            // Handle possible parent span\n+            final SpanContext parentSpan = tracingMetadata.getPreviousSpanContext();\n+            if (parentSpan != null && parentSpan.isValid()) {\n+                spanBuilder.setParent(parentSpan);\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", kafkaRecord.getPartition());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwODc2OA==", "bodyText": "Not released yet", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r458208768", "createdAt": "2020-07-21T15:57:35Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())\n+                    .setSpanKind(Span.Kind.CONSUMER);\n+\n+            // Handle possible parent span\n+            final SpanContext parentSpan = tracingMetadata.getPreviousSpanContext();\n+            if (parentSpan != null && parentSpan.isValid()) {\n+                spanBuilder.setParent(parentSpan);\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", kafkaRecord.getPartition());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MTg2NA=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjE1MDE5OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNzozODozNlrOGzIqoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNzozODozNlrOGzIqoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MjU0NQ==", "bodyText": "We should prefix the span name with the operation send/receive or produce/consume", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456272545", "createdAt": "2020-07-17T07:38:36Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjE1MDc1OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNzozODo0OVrOGzIq_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDowMDowMlrOGzUJoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MjYzOQ==", "bodyText": "We should prefix the span name with the operation send/receive or produce/consume", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456272639", "createdAt": "2020-07-17T07:38:49Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MTU3OQ==", "bodyText": "Why?\nThat's not what is recommended by current OpenTelemetry docs", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456451579", "createdAt": "2020-07-17T13:44:42Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MjYzOQ=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1NTQwNg==", "bodyText": "Where did you find the guidelines?\nThe operation name should be low cardinality which topic name certainly is, but it should represent the operation wich in our case is either consume or produce.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456455406", "createdAt": "2020-07-17T13:51:05Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MjYzOQ=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1NjI1Mg==", "bodyText": "We should also add the topic name to tags. This will help with the data semantics and in aggregation jobs since we cannot rely on the operation name.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456456252", "createdAt": "2020-07-17T13:52:28Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MjYzOQ=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1OTA1OQ==", "bodyText": "https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/messaging.md looks like it has been updated since last I saw, previously it only mentioned topic name.\nTopic name is added to messaging.destination", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456459059", "createdAt": "2020-07-17T13:57:12Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MjYzOQ=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ2MDcwNQ==", "bodyText": "It might be the important fact here is to keep it low cardinality and then describe what it does. produce would be also good but including the topic name is even better.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456460705", "createdAt": "2020-07-17T14:00:02Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MjYzOQ=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjE1NDM2OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNzozOTo1NlrOGzItGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwODoxNTozOVrOHIvWMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzE3Ng==", "bodyText": "This span will not provide any valuable timing information e.g. how long the send operation took. Is there a way to end the span once the message is sent on the wire?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456273176", "createdAt": "2020-07-17T07:39:56Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())\n+                    .setSpanKind(Span.Kind.CONSUMER);\n+\n+            // Handle possible parent span\n+            final SpanContext parentSpan = tracingMetadata.getPreviousSpanContext();\n+            if (parentSpan != null && parentSpan.isValid()) {\n+                spanBuilder.setParent(parentSpan);\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", kafkaRecord.getPartition());\n+            span.setAttribute(\"offset\", kafkaRecord.getOffset());\n+            span.setAttribute(\"messaging.system\", \"kafka\");\n+            span.setAttribute(\"messaging.destination\", kafkaRecord.getTopic());\n+            span.setAttribute(\"messaging.destination_kind\", \"topic\");\n+\n+            kafkaRecord.injectTracingMetadata(tracingMetadata.withSpan(span));\n+\n+            span.end();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MzI5NA==", "bodyText": "The goal of the spans is not to track method execution, but simply to indicate a connector for @Incoming or @Outgoing.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456453294", "createdAt": "2020-07-17T13:47:38Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())\n+                    .setSpanKind(Span.Kind.CONSUMER);\n+\n+            // Handle possible parent span\n+            final SpanContext parentSpan = tracingMetadata.getPreviousSpanContext();\n+            if (parentSpan != null && parentSpan.isValid()) {\n+                spanBuilder.setParent(parentSpan);\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", kafkaRecord.getPartition());\n+            span.setAttribute(\"offset\", kafkaRecord.getOffset());\n+            span.setAttribute(\"messaging.system\", \"kafka\");\n+            span.setAttribute(\"messaging.destination\", kafkaRecord.getTopic());\n+            span.setAttribute(\"messaging.destination_kind\", \"topic\");\n+\n+            kafkaRecord.injectTracingMetadata(tracingMetadata.withSpan(span));\n+\n+            span.end();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzE3Ng=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNDUwOQ==", "bodyText": "We could still register the reception timestamp.\nNote that it's not the record timestamp.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476204509", "createdAt": "2020-08-25T06:23:58Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())\n+                    .setSpanKind(Span.Kind.CONSUMER);\n+\n+            // Handle possible parent span\n+            final SpanContext parentSpan = tracingMetadata.getPreviousSpanContext();\n+            if (parentSpan != null && parentSpan.isValid()) {\n+                spanBuilder.setParent(parentSpan);\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", kafkaRecord.getPartition());\n+            span.setAttribute(\"offset\", kafkaRecord.getOffset());\n+            span.setAttribute(\"messaging.system\", \"kafka\");\n+            span.setAttribute(\"messaging.destination\", kafkaRecord.getTopic());\n+            span.setAttribute(\"messaging.destination_kind\", \"topic\");\n+\n+            kafkaRecord.injectTracingMetadata(tracingMetadata.withSpan(span));\n+\n+            span.end();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzE3Ng=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4NzM0NQ==", "bodyText": "There doesn't appear to be anything defined to represent that in OTeL at present.\nDo you have a suggested name?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476487345", "createdAt": "2020-08-25T14:20:59Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())\n+                    .setSpanKind(Span.Kind.CONSUMER);\n+\n+            // Handle possible parent span\n+            final SpanContext parentSpan = tracingMetadata.getPreviousSpanContext();\n+            if (parentSpan != null && parentSpan.isValid()) {\n+                spanBuilder.setParent(parentSpan);\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", kafkaRecord.getPartition());\n+            span.setAttribute(\"offset\", kafkaRecord.getOffset());\n+            span.setAttribute(\"messaging.system\", \"kafka\");\n+            span.setAttribute(\"messaging.destination\", kafkaRecord.getTopic());\n+            span.setAttribute(\"messaging.destination_kind\", \"topic\");\n+\n+            kafkaRecord.injectTracingMetadata(tracingMetadata.withSpan(span));\n+\n+            span.end();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzE3Ng=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE2NjgwNQ==", "bodyText": "@pavolloffay any hint?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r478166805", "createdAt": "2020-08-27T06:12:33Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())\n+                    .setSpanKind(Span.Kind.CONSUMER);\n+\n+            // Handle possible parent span\n+            final SpanContext parentSpan = tracingMetadata.getPreviousSpanContext();\n+            if (parentSpan != null && parentSpan.isValid()) {\n+                spanBuilder.setParent(parentSpan);\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", kafkaRecord.getPartition());\n+            span.setAttribute(\"offset\", kafkaRecord.getOffset());\n+            span.setAttribute(\"messaging.system\", \"kafka\");\n+            span.setAttribute(\"messaging.destination\", kafkaRecord.getTopic());\n+            span.setAttribute(\"messaging.destination_kind\", \"topic\");\n+\n+            kafkaRecord.injectTracingMetadata(tracingMetadata.withSpan(span));\n+\n+            span.end();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzE3Ng=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODkyNjM4NA==", "bodyText": "I am not sure I follow you here.\nDo you want to record the reception timestamp as the span timestamp? The span start time should be overridable, if the timing you want to record is after the span start I suggest to add a timed event to the span.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r478926384", "createdAt": "2020-08-28T08:15:39Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())\n+                    .setSpanKind(Span.Kind.CONSUMER);\n+\n+            // Handle possible parent span\n+            final SpanContext parentSpan = tracingMetadata.getPreviousSpanContext();\n+            if (parentSpan != null && parentSpan.isValid()) {\n+                spanBuilder.setParent(parentSpan);\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", kafkaRecord.getPartition());\n+            span.setAttribute(\"offset\", kafkaRecord.getOffset());\n+            span.setAttribute(\"messaging.system\", \"kafka\");\n+            span.setAttribute(\"messaging.destination\", kafkaRecord.getTopic());\n+            span.setAttribute(\"messaging.destination_kind\", \"topic\");\n+\n+            kafkaRecord.injectTracingMetadata(tracingMetadata.withSpan(span));\n+\n+            span.end();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzE3Ng=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjE1NjQxOnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/tracing/HeaderInjectAdapter.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNzo0MDozMlrOGzIuNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMjozNzo0OFrOHGWCsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzQ2MA==", "bodyText": "Isn't the add overriding the value?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456273460", "createdAt": "2020-07-17T07:40:32Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/tracing/HeaderInjectAdapter.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.kafka.common.header.Headers;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+\n+public class HeaderInjectAdapter implements HttpTextFormat.Setter<Headers> {\n+    public static final HeaderInjectAdapter SETTER = new HeaderInjectAdapter();\n+\n+    @Override\n+    public void set(Headers headers, String key, String value) {\n+        if (headers != null) {\n+            headers.remove(key).add(key, value.getBytes(StandardCharsets.UTF_8));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MzU4OQ==", "bodyText": "Can't recall right now, but this is the pattern used in the Kafka instrumentation class", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456453589", "createdAt": "2020-07-17T13:48:05Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/tracing/HeaderInjectAdapter.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.kafka.common.header.Headers;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+\n+public class HeaderInjectAdapter implements HttpTextFormat.Setter<Headers> {\n+    public static final HeaderInjectAdapter SETTER = new HeaderInjectAdapter();\n+\n+    @Override\n+    public void set(Headers headers, String key, String value) {\n+        if (headers != null) {\n+            headers.remove(key).add(key, value.getBytes(StandardCharsets.UTF_8));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzQ2MA=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMTg5MQ==", "bodyText": "The equals check on RecordHeader uses key and value, so I think it's necessary to remove the previous one using the key otherwise you could end up with different values as the underlying collection is a List.\nMaybe I'm wrong, but probably better to be safe", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r458211891", "createdAt": "2020-07-21T16:01:52Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/tracing/HeaderInjectAdapter.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.kafka.common.header.Headers;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+\n+public class HeaderInjectAdapter implements HttpTextFormat.Setter<Headers> {\n+    public static final HeaderInjectAdapter SETTER = new HeaderInjectAdapter();\n+\n+    @Override\n+    public void set(Headers headers, String key, String value) {\n+        if (headers != null) {\n+            headers.remove(key).add(key, value.getBytes(StandardCharsets.UTF_8));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzQ2MA=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNTI2NA==", "bodyText": "I was thinking add was appending, but let's check.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476205264", "createdAt": "2020-08-25T06:25:48Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/tracing/HeaderInjectAdapter.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.kafka.common.header.Headers;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+\n+public class HeaderInjectAdapter implements HttpTextFormat.Setter<Headers> {\n+    public static final HeaderInjectAdapter SETTER = new HeaderInjectAdapter();\n+\n+    @Override\n+    public void set(Headers headers, String key, String value) {\n+        if (headers != null) {\n+            headers.remove(key).add(key, value.getBytes(StandardCharsets.UTF_8));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzQ2MA=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNDY0MA==", "bodyText": "Yes add is appending, so we need to remove the previous value to ensure we don't end up with multiples present", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476414640", "createdAt": "2020-08-25T12:37:48Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/tracing/HeaderInjectAdapter.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.kafka.common.header.Headers;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+\n+public class HeaderInjectAdapter implements HttpTextFormat.Setter<Headers> {\n+    public static final HeaderInjectAdapter SETTER = new HeaderInjectAdapter();\n+\n+    @Override\n+    public void set(Headers headers, String key, String value) {\n+        if (headers != null) {\n+            headers.remove(key).add(key, value.getBytes(StandardCharsets.UTF_8));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzQ2MA=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjE2MDAyOnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConnector.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNzo0MTo0NVrOGzIwfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNzo0MTo0NVrOGzIwfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3NDA0NQ==", "bodyText": "missing final?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456274045", "createdAt": "2020-07-17T07:41:45Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConnector.java", "diffHunk": "@@ -77,6 +80,8 @@\n \n     public static final String CONNECTOR_NAME = \"smallrye-kafka\";\n \n+    public static Tracer TRACER = OpenTelemetry.getTracerProvider().get(\"io.smallrye.reactive.messaging.kafka\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjM0NjQ3OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODozNzo0MlrOGzKhrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODozNzo0MlrOGzKhrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwMzAyMQ==", "bodyText": "It would be good to check if the spans belong to the same trace", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456303021", "createdAt": "2020-07-17T08:37:42Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import static io.opentelemetry.trace.Span.Kind.CONSUMER;\n+import static io.opentelemetry.trace.Span.Kind.PRODUCER;\n+import static io.opentelemetry.trace.TracingContextUtils.withSpan;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.jboss.weld.environment.se.Weld;\n+import org.jboss.weld.environment.se.WeldContainer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.exporters.inmemory.InMemorySpanExporter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.reactivex.Flowable;\n+import io.smallrye.config.SmallRyeConfigProviderResolver;\n+import io.smallrye.reactive.messaging.TracingMetadata;\n+import io.smallrye.reactive.messaging.kafka.KafkaConnector;\n+import io.smallrye.reactive.messaging.kafka.KafkaTestBase;\n+import io.smallrye.reactive.messaging.kafka.KafkaUsage;\n+import io.smallrye.reactive.messaging.kafka.MapBasedConfig;\n+\n+public class TracingPropagationTest extends KafkaTestBase {\n+\n+    private WeldContainer container;\n+    private InMemorySpanExporter testExporter;\n+    private SpanProcessor spanProcessor;\n+\n+    @Before\n+    public void setup() {\n+        testExporter = InMemorySpanExporter.create();\n+        spanProcessor = SimpleSpanProcessor.newBuilder(testExporter).build();\n+        OpenTelemetrySdk.getTracerProvider().addSpanProcessor(spanProcessor);\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        if (testExporter != null) {\n+            testExporter.shutdown();\n+        }\n+        if (spanProcessor != null) {\n+            spanProcessor.shutdown();\n+        }\n+\n+        if (container != null) {\n+            container.close();\n+        }\n+\n+        // Release the config objects\n+        SmallRyeConfigProviderResolver.instance().releaseConfig(ConfigProvider.getConfig());\n+    }\n+\n+    @Test\n+    public void testFromAppToKafka() {\n+        KafkaUsage usage = new KafkaUsage();\n+        List<Map.Entry<String, Integer>> messages = new CopyOnWriteArrayList<>();\n+        List<Context> contexts = new CopyOnWriteArrayList<>();\n+        usage.consumeIntegersWithTracing(\"output\", 10, 1, TimeUnit.MINUTES, null,\n+                (key, value) -> messages.add(entry(key, value)),\n+                contexts::add);\n+        deploy(getKafkaSinkConfigForMyAppGeneratingData(), MyAppGeneratingData.class);\n+\n+        await().until(() -> messages.size() >= 10);\n+        List<Integer> values = new ArrayList<>();\n+        assertThat(messages).allSatisfy(entry -> {\n+            assertThat(entry.getValue()).isNotNull();\n+            values.add(entry.getValue());\n+        });\n+        assertThat(values).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        assertThat(contexts).hasSize(10);\n+        assertThat(contexts).doesNotContainNull().doesNotHaveDuplicates();\n+        List<SpanId> spanIds = contexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getSpanId())\n+                .collect(Collectors.toList());\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjM1NTAxOnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODo0MDoxOVrOGzKm6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzo1Mzo1M1rOG1DYog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwNDM2MQ==", "bodyText": "Let's discuss what span context should be used as a parent.\nWhat represents the getPreviousSpanContext? Is it the context derived from the previous Kafka message?\nIf this code is executed synchronously when the user code is sending a message then it might be better to set the current active context as the parent.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456304361", "createdAt": "2020-07-17T08:40:19Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);\n+\n+            if (tracingMetadata.isPresent()) {\n+                // Handle possible parent span\n+                final SpanContext parentSpan = tracingMetadata.get().getPreviousSpanContext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MjQ1OQ==", "bodyText": "That's one of the reasons we didn't like the current Kafka instrumentation for OpenTelemetry: https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/master/instrumentation/kafka-clients-0.11/src/main/java/io/opentelemetry/auto/instrumentation/kafkaclients/TracingIterator.java#L46\nThere's no guarantee that we process a method with @Incoming and then it's @Outgoing with such timing that there couldn't have been a different @Incoming being received before the other @Outgoing is processed, so relying on the context that's on the TRACER would lead to issues.\nAt least that's my understanding of things", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r458282459", "createdAt": "2020-07-21T17:52:37Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);\n+\n+            if (tracingMetadata.isPresent()) {\n+                // Handle possible parent span\n+                final SpanContext parentSpan = tracingMetadata.get().getPreviousSpanContext();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwNDM2MQ=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MzE3MA==", "bodyText": "getPreviousSpanContext() will return the SpanContext, if there is one, from any @Incoming that was processed", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r458283170", "createdAt": "2020-07-21T17:53:53Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);\n+\n+            if (tracingMetadata.isPresent()) {\n+                // Handle possible parent span\n+                final SpanContext parentSpan = tracingMetadata.get().getPreviousSpanContext();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwNDM2MQ=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjM4MDM3OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODo0NzozMlrOGzK2Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODo0NzozMlrOGzK2Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODI1OA==", "bodyText": "Potential leak on the not closed scope.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456308258", "createdAt": "2020-07-17T08:47:32Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);\n+\n+            if (tracingMetadata.isPresent()) {\n+                // Handle possible parent span\n+                final SpanContext parentSpan = tracingMetadata.get().getPreviousSpanContext();\n+                if (parentSpan != null && parentSpan.isValid()) {\n+                    spanBuilder.setParent(parentSpan);\n+                } else {\n+                    spanBuilder.setNoParent();\n+                }\n+\n+                // Handle possible adjacent spans\n+                final SpanContext incomingSpan = tracingMetadata.get().getCurrentSpanContext();\n+                if (incomingSpan != null && incomingSpan.isValid()) {\n+                    spanBuilder.addLink(incomingSpan);\n+                }\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+            TracingContextUtils.currentContextWith(span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjM4MTc0OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODo0Nzo1NFrOGzK29g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNTo1NzoxOFrOG0-1JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODQ3MA==", "bodyText": "SemanticAttributes should be used", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456308470", "createdAt": "2020-07-17T08:47:54Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);\n+\n+            if (tracingMetadata.isPresent()) {\n+                // Handle possible parent span\n+                final SpanContext parentSpan = tracingMetadata.get().getPreviousSpanContext();\n+                if (parentSpan != null && parentSpan.isValid()) {\n+                    spanBuilder.setParent(parentSpan);\n+                } else {\n+                    spanBuilder.setNoParent();\n+                }\n+\n+                // Handle possible adjacent spans\n+                final SpanContext incomingSpan = tracingMetadata.get().getCurrentSpanContext();\n+                if (incomingSpan != null && incomingSpan.isValid()) {\n+                    spanBuilder.addLink(incomingSpan);\n+                }\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+            TracingContextUtils.currentContextWith(span);\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", partition);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MjkwOA==", "bodyText": "In 0.5.0 they weren't there, I can use them now they're there", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456452908", "createdAt": "2020-07-17T13:46:59Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);\n+\n+            if (tracingMetadata.isPresent()) {\n+                // Handle possible parent span\n+                final SpanContext parentSpan = tracingMetadata.get().getPreviousSpanContext();\n+                if (parentSpan != null && parentSpan.isValid()) {\n+                    spanBuilder.setParent(parentSpan);\n+                } else {\n+                    spanBuilder.setNoParent();\n+                }\n+\n+                // Handle possible adjacent spans\n+                final SpanContext incomingSpan = tracingMetadata.get().getCurrentSpanContext();\n+                if (incomingSpan != null && incomingSpan.isValid()) {\n+                    spanBuilder.addLink(incomingSpan);\n+                }\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+            TracingContextUtils.currentContextWith(span);\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", partition);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODQ3MA=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwODU0OA==", "bodyText": "Actually, they're only in master and not 0.6.0", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r458208548", "createdAt": "2020-07-21T15:57:18Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);\n+\n+            if (tracingMetadata.isPresent()) {\n+                // Handle possible parent span\n+                final SpanContext parentSpan = tracingMetadata.get().getPreviousSpanContext();\n+                if (parentSpan != null && parentSpan.isValid()) {\n+                    spanBuilder.setParent(parentSpan);\n+                } else {\n+                    spanBuilder.setNoParent();\n+                }\n+\n+                // Handle possible adjacent spans\n+                final SpanContext incomingSpan = tracingMetadata.get().getCurrentSpanContext();\n+                if (incomingSpan != null && incomingSpan.isValid()) {\n+                    spanBuilder.addLink(incomingSpan);\n+                }\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+            TracingContextUtils.currentContextWith(span);\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", partition);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODQ3MA=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjM5MTE0OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/KafkaUsage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODo1MDo0MFrOGzK8wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMzo0OToyM1rOGzTwpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwOTk1NA==", "bodyText": "Why readCounter is being used?\nnit: getAndIncrement()", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456309954", "createdAt": "2020-07-17T08:50:40Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/KafkaUsage.java", "diffHunk": "@@ -215,6 +220,26 @@ public void consumeStrings(String topicName, int count, long timeout, TimeUnit u\n                 });\n     }\n \n+    public void consumeStringsWithTracing(String topicName, int count, long timeout, TimeUnit unit, Runnable completion,\n+            BiConsumer<String, String> consumer, Consumer<Context> tracingConsumer) {\n+        AtomicLong readCounter = new AtomicLong();\n+        this.consumeStrings(this.continueIfNotExpired(() -> readCounter.get() < (long) count, timeout, unit), completion,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1NDMwOA==", "bodyText": "It counts up to the number of messages we expect to receive.\nAs for the nit, all the other methods use the same method", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456454308", "createdAt": "2020-07-17T13:49:23Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/KafkaUsage.java", "diffHunk": "@@ -215,6 +220,26 @@ public void consumeStrings(String topicName, int count, long timeout, TimeUnit u\n                 });\n     }\n \n+    public void consumeStringsWithTracing(String topicName, int count, long timeout, TimeUnit unit, Runnable completion,\n+            BiConsumer<String, String> consumer, Consumer<Context> tracingConsumer) {\n+        AtomicLong readCounter = new AtomicLong();\n+        this.consumeStrings(this.continueIfNotExpired(() -> readCounter.get() < (long) count, timeout, unit), completion,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwOTk1NA=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjQyNzE2OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOTowMTo0NlrOGzLTZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzo1NzowMFrOG1DgPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNTc0OQ==", "bodyText": "There are missing tests when an active span is created in the test an messages are produced and consumed. In this case the spans created by the instrumentation should by linked to the span in the test.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456315749", "createdAt": "2020-07-17T09:01:46Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import static io.opentelemetry.trace.Span.Kind.CONSUMER;\n+import static io.opentelemetry.trace.Span.Kind.PRODUCER;\n+import static io.opentelemetry.trace.TracingContextUtils.withSpan;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.jboss.weld.environment.se.Weld;\n+import org.jboss.weld.environment.se.WeldContainer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.exporters.inmemory.InMemorySpanExporter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.reactivex.Flowable;\n+import io.smallrye.config.SmallRyeConfigProviderResolver;\n+import io.smallrye.reactive.messaging.TracingMetadata;\n+import io.smallrye.reactive.messaging.kafka.KafkaConnector;\n+import io.smallrye.reactive.messaging.kafka.KafkaTestBase;\n+import io.smallrye.reactive.messaging.kafka.KafkaUsage;\n+import io.smallrye.reactive.messaging.kafka.MapBasedConfig;\n+\n+public class TracingPropagationTest extends KafkaTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1NTIzOQ==", "bodyText": "That's what testFromKafkaToAppToKafka() tests. Spans present on the message from Kafka that we receive into the app.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456455239", "createdAt": "2020-07-17T13:50:49Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import static io.opentelemetry.trace.Span.Kind.CONSUMER;\n+import static io.opentelemetry.trace.Span.Kind.PRODUCER;\n+import static io.opentelemetry.trace.TracingContextUtils.withSpan;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.jboss.weld.environment.se.Weld;\n+import org.jboss.weld.environment.se.WeldContainer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.exporters.inmemory.InMemorySpanExporter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.reactivex.Flowable;\n+import io.smallrye.config.SmallRyeConfigProviderResolver;\n+import io.smallrye.reactive.messaging.TracingMetadata;\n+import io.smallrye.reactive.messaging.kafka.KafkaConnector;\n+import io.smallrye.reactive.messaging.kafka.KafkaTestBase;\n+import io.smallrye.reactive.messaging.kafka.KafkaUsage;\n+import io.smallrye.reactive.messaging.kafka.MapBasedConfig;\n+\n+public class TracingPropagationTest extends KafkaTestBase {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNTc0OQ=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4NTExNw==", "bodyText": "Ah, do you mean inside the method annotated with @Incoming or @Outgoing it creates a span?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r458285117", "createdAt": "2020-07-21T17:57:00Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import static io.opentelemetry.trace.Span.Kind.CONSUMER;\n+import static io.opentelemetry.trace.Span.Kind.PRODUCER;\n+import static io.opentelemetry.trace.TracingContextUtils.withSpan;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.jboss.weld.environment.se.Weld;\n+import org.jboss.weld.environment.se.WeldContainer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.exporters.inmemory.InMemorySpanExporter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.reactivex.Flowable;\n+import io.smallrye.config.SmallRyeConfigProviderResolver;\n+import io.smallrye.reactive.messaging.TracingMetadata;\n+import io.smallrye.reactive.messaging.kafka.KafkaConnector;\n+import io.smallrye.reactive.messaging.kafka.KafkaTestBase;\n+import io.smallrye.reactive.messaging.kafka.KafkaUsage;\n+import io.smallrye.reactive.messaging.kafka.MapBasedConfig;\n+\n+public class TracingPropagationTest extends KafkaTestBase {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNTc0OQ=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzIzMDM2OnYy", "diffSide": "RIGHT", "path": "pom.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNTo0NjozMlrOHEH8ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzoyNjoyMVrOHGX-kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA4NjUwNg==", "bodyText": "Could we bump it to the latest version 0.7.0?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r474086506", "createdAt": "2020-08-20T15:46:32Z", "author": {"login": "pavolloffay"}, "path": "pom.xml", "diffHunk": "@@ -80,6 +80,8 @@\n \n     <jboss-log-manager.version>2.1.17.Final</jboss-log-manager.version>\n \n+    <opentelemetry.version>0.6.0</opentelemetry.version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cedeee96473f8aafbcc7a56684ec4931e27e22a7"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ0NTQ1Ng==", "bodyText": "@kenfinnigan I believe this was done, no?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476445456", "createdAt": "2020-08-25T13:24:59Z", "author": {"login": "cescoffier"}, "path": "pom.xml", "diffHunk": "@@ -80,6 +80,8 @@\n \n     <jboss-log-manager.version>2.1.17.Final</jboss-log-manager.version>\n \n+    <opentelemetry.version>0.6.0</opentelemetry.version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA4NjUwNg=="}, "originalCommit": {"oid": "cedeee96473f8aafbcc7a56684ec4931e27e22a7"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ0NjM1Mw==", "bodyText": "Yes", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476446353", "createdAt": "2020-08-25T13:26:21Z", "author": {"login": "kenfinnigan"}, "path": "pom.xml", "diffHunk": "@@ -80,6 +80,8 @@\n \n     <jboss-log-manager.version>2.1.17.Final</jboss-log-manager.version>\n \n+    <opentelemetry.version>0.6.0</opentelemetry.version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA4NjUwNg=="}, "originalCommit": {"oid": "cedeee96473f8aafbcc7a56684ec4931e27e22a7"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NzA4NDM5OnYy", "diffSide": "RIGHT", "path": "documentation/src/main/doc/modules/connectors/partials/META-INF/connector/smallrye-kafka-incoming.adoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjoxMzoxNVrOHGI-aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzoyNTozM1rOHGX8cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMDU1Mg==", "bodyText": "In Quarkus, it might be a bit more complicated than just true. Does it require the tracing extension to be there?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476200552", "createdAt": "2020-08-25T06:13:15Z", "author": {"login": "cescoffier"}, "path": "documentation/src/main/doc/modules/connectors/partials/META-INF/connector/smallrye-kafka-incoming.adoc", "diffHunk": "@@ -17,6 +17,10 @@ Type: _string_ | false |\n \n Type: _boolean_ | false | `true`\n \n+| *tracing-enabled* | Whether tracing is enabled (default) or disabled\n+\n+Type: _boolean_ | false | `true`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwOTg2MA==", "bodyText": "No, without an implementation of the API present, it's basically a No-Op", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476409860", "createdAt": "2020-08-25T12:29:27Z", "author": {"login": "kenfinnigan"}, "path": "documentation/src/main/doc/modules/connectors/partials/META-INF/connector/smallrye-kafka-incoming.adoc", "diffHunk": "@@ -17,6 +17,10 @@ Type: _string_ | false |\n \n Type: _boolean_ | false | `true`\n \n+| *tracing-enabled* | Whether tracing is enabled (default) or disabled\n+\n+Type: _boolean_ | false | `true`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMDU1Mg=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ0NTgwOA==", "bodyText": "Perfect!", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476445808", "createdAt": "2020-08-25T13:25:33Z", "author": {"login": "cescoffier"}, "path": "documentation/src/main/doc/modules/connectors/partials/META-INF/connector/smallrye-kafka-incoming.adoc", "diffHunk": "@@ -17,6 +17,10 @@ Type: _string_ | false |\n \n Type: _boolean_ | false | `true`\n \n+| *tracing-enabled* | Whether tracing is enabled (default) or disabled\n+\n+Type: _boolean_ | false | `true`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMDU1Mg=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NzA4NTY0OnYy", "diffSide": "RIGHT", "path": "pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjoxMzo1MVrOHGI_PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMjoyOTozOVrOHGVwhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMDc2NQ==", "bodyText": "For my own understanding, it is a regular dependency or a test dependency?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476200765", "createdAt": "2020-08-25T06:13:51Z", "author": {"login": "cescoffier"}, "path": "pom.xml", "diffHunk": "@@ -214,6 +216,22 @@\n         <version>${jboss-log-manager.version}</version>\n       </dependency>\n \n+      <dependency>\n+        <groupId>io.opentelemetry</groupId>\n+        <artifactId>opentelemetry-api</artifactId>\n+        <version>${opentelemetry.version}</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>io.opentelemetry</groupId>\n+        <artifactId>opentelemetry-sdk</artifactId>\n+        <version>${opentelemetry.version}</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>io.opentelemetry</groupId>\n+        <artifactId>opentelemetry-exporters-inmemory</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwOTk4OA==", "bodyText": "Testing only", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476409988", "createdAt": "2020-08-25T12:29:39Z", "author": {"login": "kenfinnigan"}, "path": "pom.xml", "diffHunk": "@@ -214,6 +216,22 @@\n         <version>${jboss-log-manager.version}</version>\n       </dependency>\n \n+      <dependency>\n+        <groupId>io.opentelemetry</groupId>\n+        <artifactId>opentelemetry-api</artifactId>\n+        <version>${opentelemetry.version}</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>io.opentelemetry</groupId>\n+        <artifactId>opentelemetry-sdk</artifactId>\n+        <version>${opentelemetry.version}</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>io.opentelemetry</groupId>\n+        <artifactId>opentelemetry-exporters-inmemory</artifactId>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMDc2NQ=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NzA4NzkzOnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjoxNDo0N1rOHGJAjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMjozMDozM1rOHGVycg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMTEwMA==", "bodyText": "Should it be added only if tracing is enabled?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476201100", "createdAt": "2020-08-25T06:14:47Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -23,8 +28,18 @@ public IncomingKafkaRecord(\n             KafkaCommitHandler commitHandler,\n             KafkaFailureHandler onNack) {\n         this.kafkaMetadata = new IncomingKafkaRecordMetadata<>(record);\n-        this.metadata = Metadata.of(this.kafkaMetadata);\n         this.commitHandler = commitHandler;\n+\n+        TracingMetadata tracingMetadata = TracingMetadata.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMDQ4Mg==", "bodyText": "Probably, will adjust", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476410482", "createdAt": "2020-08-25T12:30:33Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -23,8 +28,18 @@ public IncomingKafkaRecord(\n             KafkaCommitHandler commitHandler,\n             KafkaFailureHandler onNack) {\n         this.kafkaMetadata = new IncomingKafkaRecordMetadata<>(record);\n-        this.metadata = Metadata.of(this.kafkaMetadata);\n         this.commitHandler = commitHandler;\n+\n+        TracingMetadata tracingMetadata = TracingMetadata.empty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMTEwMA=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NzA5MTU3OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjoxNjoxNVrOHGJCyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzoyNTo1OFrOHGX9kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMTY3Mg==", "bodyText": "with metadata not final anymore, we must synchronize access.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476201672", "createdAt": "2020-08-25T06:16:15Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -81,4 +96,8 @@ public Metadata getMetadata() {\n     public CompletionStage<Void> nack(Throwable reason) {\n         return onNack.handle(this, reason);\n     }\n+\n+    public void injectTracingMetadata(TracingMetadata tracingMetadata) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMDcyMA==", "bodyText": "do you mean just making the method synchronized, or something different?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476410720", "createdAt": "2020-08-25T12:30:59Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -81,4 +96,8 @@ public Metadata getMetadata() {\n     public CompletionStage<Void> nack(Throwable reason) {\n         return onNack.handle(this, reason);\n     }\n+\n+    public void injectTracingMetadata(TracingMetadata tracingMetadata) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMTY3Mg=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ0NjA5OA==", "bodyText": "yes, synchronized", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476446098", "createdAt": "2020-08-25T13:25:58Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -81,4 +96,8 @@ public Metadata getMetadata() {\n     public CompletionStage<Void> nack(Throwable reason) {\n         return onNack.handle(this, reason);\n     }\n+\n+    public void injectTracingMetadata(TracingMetadata tracingMetadata) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMTY3Mg=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NzA5NDcyOnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConnector.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjoxNzoyOVrOHGJEng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzoyNjoyMlrOHGX-lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMjE0Mg==", "bodyText": "so even if tracing is disabled we instantiate the tracer? Does it make sense?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476202142", "createdAt": "2020-08-25T06:17:29Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConnector.java", "diffHunk": "@@ -79,6 +82,8 @@\n \n     public static final String CONNECTOR_NAME = \"smallrye-kafka\";\n \n+    public static final Tracer TRACER = OpenTelemetry.getTracerProvider().get(\"io.smallrye.reactive.messaging.kafka\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMTM0Ng==", "bodyText": "There's a small cost yes, even to have the No Op tracer.\nHowever, not setting it like this then means more work to ensure we don't create multiple versions later.\nI don't mind doing that, but that would potentially slow things down a bit on the first use", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476411346", "createdAt": "2020-08-25T12:32:05Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConnector.java", "diffHunk": "@@ -79,6 +82,8 @@\n \n     public static final String CONNECTOR_NAME = \"smallrye-kafka\";\n \n+    public static final Tracer TRACER = OpenTelemetry.getTracerProvider().get(\"io.smallrye.reactive.messaging.kafka\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMjE0Mg=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ0NjM1OA==", "bodyText": "ok, make sense.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476446358", "createdAt": "2020-08-25T13:26:22Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConnector.java", "diffHunk": "@@ -79,6 +82,8 @@\n \n     public static final String CONNECTOR_NAME = \"smallrye-kafka\";\n \n+    public static final Tracer TRACER = OpenTelemetry.getTracerProvider().get(\"io.smallrye.reactive.messaging.kafka\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMjE0Mg=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NzA5ODYxOnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjoxOToxMVrOHGJG6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzoyNjo0OVrOHGX_2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMjcyOA==", "bodyText": "is the \"send\" word defined somewhere? In Kafka, we use \"write\" most of the time.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476202728", "createdAt": "2020-08-25T06:19:11Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -168,6 +180,48 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic + \" send\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMjY5OA==", "bodyText": "It's defined by OpenTelemetry specification. See https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/messaging.md#conventions", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476412698", "createdAt": "2020-08-25T12:34:29Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -168,6 +180,48 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic + \" send\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMjcyOA=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ0NjY4MQ==", "bodyText": "great, don't forget to add this to the documentation.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476446681", "createdAt": "2020-08-25T13:26:49Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -168,6 +180,48 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic + \" send\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMjcyOA=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NzEwMDY1OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjoyMDowMVrOHGJIHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzoyNzo0MFrOHGYCXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMzAzNg==", "bodyText": "This whole block should be externalized in a carefully tested method.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476203036", "createdAt": "2020-08-25T06:20:01Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -168,6 +180,48 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMTg4OA==", "bodyText": "Not sure what you mean. It's all in createOutgoingTrace method, are you suggesting something else?\nOr do you mean there should be unit tests verifying the behavior of just this method?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476411888", "createdAt": "2020-08-25T12:33:04Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -168,6 +180,48 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMzAzNg=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ0NzMyNg==", "bodyText": "Damned missed it.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476447326", "createdAt": "2020-08-25T13:27:40Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -168,6 +180,48 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMzAzNg=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NzEwNjYwOnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjoyMjoyOVrOHGJLsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzozMDoyMFrOHGYJwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMzk1NA==", "bodyText": "let's build a conditional pipeline instead of testing if tracing is enabled every time.\nmulti = ...\nif (getTracingEnabled()) {\n    multi = .... \n}", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476203954", "createdAt": "2020-08-25T06:22:29Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -225,6 +230,7 @@ public KafkaSource(Vertx vertx,\n                     }\n                 })\n                 .map(rec -> commitHandler.received(new IncomingKafkaRecord<>(rec, commitHandler, failureHandler)))\n+                .onItem().invoke(this::incomingTrace)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMjkxMw==", "bodyText": "Ok", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476412913", "createdAt": "2020-08-25T12:34:50Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -225,6 +230,7 @@ public KafkaSource(Vertx vertx,\n                     }\n                 })\n                 .map(rec -> commitHandler.received(new IncomingKafkaRecord<>(rec, commitHandler, failureHandler)))\n+                .onItem().invoke(this::incomingTrace)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMzk1NA=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyNzY0Mg==", "bodyText": "How do I do the onItem() so that it's invoked at the correct place in the stream?\nDo you mean creating two pipelines, one with and one without the onItem()? Or do you mean multi into multi?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476427642", "createdAt": "2020-08-25T12:57:51Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -225,6 +230,7 @@ public KafkaSource(Vertx vertx,\n                     }\n                 })\n                 .map(rec -> commitHandler.received(new IncomingKafkaRecord<>(rec, commitHandler, failureHandler)))\n+                .onItem().invoke(this::incomingTrace)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMzk1NA=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ0OTIxNg==", "bodyText": "Pipelines are \"append-only\".\nYou create one, and append the onItem() if tracing is enabled:\nmulti = ...\nif (getTracingEnabled()) {\n    multi = multi.onItem().invoke(this::incomingTrace); \n}\nmulti = multi....", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476449216", "createdAt": "2020-08-25T13:30:20Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -225,6 +230,7 @@ public KafkaSource(Vertx vertx,\n                     }\n                 })\n                 .map(rec -> commitHandler.received(new IncomingKafkaRecord<>(rec, commitHandler, failureHandler)))\n+                .onItem().invoke(this::incomingTrace)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMzk1NA=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NzExMzA4OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/tracing/HeaderExtractAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjoyNDo1NFrOHGJPVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMjozNToxOFrOHGV9Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNDg4NQ==", "bodyText": "should it fail on multiple values? Is it even possible?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476204885", "createdAt": "2020-08-25T06:24:54Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/tracing/HeaderExtractAdapter.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.Headers;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+\n+public class HeaderExtractAdapter implements HttpTextFormat.Getter<Headers> {\n+    public static final HeaderExtractAdapter GETTER = new HeaderExtractAdapter();\n+\n+    @Override\n+    public String get(Headers headers, String key) {\n+        final Header header = headers.lastHeader(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMzE5NA==", "bodyText": "I think it's specified to only retrieve the last one", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476413194", "createdAt": "2020-08-25T12:35:18Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/tracing/HeaderExtractAdapter.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.Headers;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+\n+public class HeaderExtractAdapter implements HttpTextFormat.Getter<Headers> {\n+    public static final HeaderExtractAdapter GETTER = new HeaderExtractAdapter();\n+\n+    @Override\n+    public String get(Headers headers, String key) {\n+        final Header header = headers.lastHeader(key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNDg4NQ=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NzExODQzOnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/DefaultConfigTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjoyNzowMlrOHGJSow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNDoyNTozOVrOHGas5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNTczMQ==", "bodyText": "That is a bit cumbersome and error-prone.\nIs there something we can do in the base class?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476205731", "createdAt": "2020-08-25T06:27:02Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/DefaultConfigTest.java", "diffHunk": "@@ -89,12 +89,14 @@ private MapBasedConfig getKafkaSinkConfigForMyAppProcessingData(String topicOut,\n         Map<String, Object> config = new HashMap<>();\n         config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n         config.put(prefix + \"topic\", topicOut);\n+        config.put(prefix + \"tracing-enabled\", false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNDg2Mw==", "bodyText": "Will see if something can be done", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476414863", "createdAt": "2020-08-25T12:38:13Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/DefaultConfigTest.java", "diffHunk": "@@ -89,12 +89,14 @@ private MapBasedConfig getKafkaSinkConfigForMyAppProcessingData(String topicOut,\n         Map<String, Object> config = new HashMap<>();\n         config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n         config.put(prefix + \"topic\", topicOut);\n+        config.put(prefix + \"tracing-enabled\", false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNTczMQ=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5MDk4Mg==", "bodyText": "I was thinking I could detect whether it was set in MapBasedConfig and then add it set to false in write() if it wasn't.\nBut I'm not sure that's going to be easy given the different key prefixes and an unknown number of them.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476490982", "createdAt": "2020-08-25T14:25:39Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/DefaultConfigTest.java", "diffHunk": "@@ -89,12 +89,14 @@ private MapBasedConfig getKafkaSinkConfigForMyAppProcessingData(String topicOut,\n         Map<String, Object> config = new HashMap<>();\n         config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n         config.put(prefix + \"topic\", topicOut);\n+        config.put(prefix + \"tracing-enabled\", false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNTczMQ=="}, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NzExOTczOnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/KafkaTestBase.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjoyNzozMVrOHGJTcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjoyNzozMVrOHGJTcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNTkzNg==", "bodyText": "we should wait until the vert.x instance is closed if we want to be totally correct.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476205936", "createdAt": "2020-08-25T06:27:31Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/KafkaTestBase.java", "diffHunk": "@@ -66,7 +66,9 @@ public void setup() {\n \n     @After\n     public void tearDown() {\n-        vertx.close();\n+        if (vertx != null) {\n+            vertx.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NzI3NTI5OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNzoxODo1MVrOHGKv4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNzoxODo1MVrOHGKv4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIyOTYwMQ==", "bodyText": "minor - can be final", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476229601", "createdAt": "2020-08-25T07:18:51Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "diffHunk": "@@ -0,0 +1,392 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import static io.opentelemetry.trace.Span.Kind.CONSUMER;\n+import static io.opentelemetry.trace.Span.Kind.PRODUCER;\n+import static io.opentelemetry.trace.TracingContextUtils.withSpan;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.jboss.weld.environment.se.Weld;\n+import org.jboss.weld.environment.se.WeldContainer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.exporters.inmemory.InMemorySpanExporter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.reactivex.Flowable;\n+import io.smallrye.config.SmallRyeConfigProviderResolver;\n+import io.smallrye.reactive.messaging.TracingMetadata;\n+import io.smallrye.reactive.messaging.kafka.KafkaConnector;\n+import io.smallrye.reactive.messaging.kafka.KafkaTestBase;\n+import io.smallrye.reactive.messaging.kafka.KafkaUsage;\n+import io.smallrye.reactive.messaging.kafka.MapBasedConfig;\n+\n+public class TracingPropagationTest extends KafkaTestBase {\n+\n+    private WeldContainer container;\n+    private InMemorySpanExporter testExporter;\n+    private SpanProcessor spanProcessor;\n+\n+    @Before\n+    public void setup() {\n+        testExporter = InMemorySpanExporter.create();\n+        spanProcessor = SimpleSpanProcessor.newBuilder(testExporter).build();\n+        OpenTelemetrySdk.getTracerProvider().addSpanProcessor(spanProcessor);\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        if (testExporter != null) {\n+            testExporter.shutdown();\n+        }\n+        if (spanProcessor != null) {\n+            spanProcessor.shutdown();\n+        }\n+\n+        if (container != null) {\n+            container.close();\n+        }\n+\n+        // Release the config objects\n+        SmallRyeConfigProviderResolver.instance().releaseConfig(ConfigProvider.getConfig());\n+    }\n+\n+    @Test\n+    public void testFromAppToKafka() {\n+        KafkaUsage usage = new KafkaUsage();\n+        List<Map.Entry<String, Integer>> messages = new CopyOnWriteArrayList<>();\n+        List<Context> contexts = new CopyOnWriteArrayList<>();\n+        usage.consumeIntegersWithTracing(\"output\", 10, 1, TimeUnit.MINUTES, null,\n+                (key, value) -> messages.add(entry(key, value)),\n+                contexts::add);\n+        deploy(getKafkaSinkConfigForMyAppGeneratingData(), MyAppGeneratingData.class);\n+\n+        await().until(() -> messages.size() >= 10);\n+        List<Integer> values = new ArrayList<>();\n+        assertThat(messages).allSatisfy(entry -> {\n+            assertThat(entry.getValue()).isNotNull();\n+            values.add(entry.getValue());\n+        });\n+        assertThat(values).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        assertThat(contexts).hasSize(10);\n+        assertThat(contexts).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<SpanId> spanIds = contexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getSpanId())\n+                .collect(Collectors.toList());\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        List<TraceId> traceIds = contexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(traceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getTraceId()).isIn(traceIds);\n+            assertThat(data.getKind()).isEqualByComparingTo(PRODUCER);\n+            assertThat(data.getParentSpanId().isValid()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppToKafka() {\n+        KafkaUsage usage = new KafkaUsage();\n+        List<Map.Entry<String, Integer>> messages = new CopyOnWriteArrayList<>();\n+        List<Context> receivedContexts = new CopyOnWriteArrayList<>();\n+        usage.consumeIntegersWithTracing(\"result-topic\", 10, 1, TimeUnit.MINUTES, null,\n+                (key, value) -> messages.add(entry(key, value)),\n+                receivedContexts::add);\n+        deploy(getKafkaSinkConfigForMyAppProcessingData(), MyAppProcessingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        List<SpanContext> producedSpanContexts = new CopyOnWriteArrayList<>();\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"some-topic\", null, null, \"a-key\", count.getAndIncrement(),\n+                        createTracingSpan(producedSpanContexts, \"some-topic\")));\n+\n+        await().atMost(Duration.ofMinutes(5)).until(() -> messages.size() >= 10);\n+        List<Integer> values = new ArrayList<>();\n+        assertThat(messages).allSatisfy(entry -> {\n+            assertThat(entry.getValue()).isNotNull();\n+            values.add(entry.getValue());\n+        });\n+        assertThat(values).containsExactly(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+\n+        List<TraceId> producedTraceIds = producedSpanContexts.stream()\n+                .map(SpanContext::getTraceId)\n+                .collect(Collectors.toList());\n+        assertThat(producedTraceIds).hasSize(10);\n+\n+        assertThat(receivedContexts).hasSize(10);\n+        assertThat(receivedContexts).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<SpanId> receivedSpanIds = receivedContexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getSpanId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedSpanIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        List<TraceId> receivedTraceIds = receivedContexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedTraceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+        assertThat(receivedTraceIds).containsExactlyInAnyOrderElementsOf(producedTraceIds);\n+\n+        List<SpanId> receivedParentSpanIds = new ArrayList<>();\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            if (data.getKind().equals(CONSUMER)) {\n+                // Need to skip the spans created during @Incoming processing\n+                continue;\n+            }\n+            assertThat(data.getSpanId()).isIn(receivedSpanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getTraceId()).isIn(producedTraceIds);\n+            assertThat(data.getKind()).isEqualByComparingTo(PRODUCER);\n+            assertThat(data.getParentSpanId().isValid()).isTrue();\n+            receivedParentSpanIds.add(data.getParentSpanId());\n+        }\n+\n+        assertThat(producedSpanContexts.stream()\n+                .map(SpanContext::getSpanId)).containsExactlyElementsOf(receivedParentSpanIds);\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppWithParentSpan() {\n+        KafkaUsage usage = new KafkaUsage();\n+        deploy(getKafkaSinkConfigForMyAppReceivingData(\"parent-stuff\"), MyAppReceivingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        MyAppReceivingData bean = container.getBeanManager().createInstance().select(MyAppReceivingData.class).get();\n+        List<SpanContext> producedSpanContexts = new CopyOnWriteArrayList<>();\n+\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"parent-stuff\", null, null, \"a-key\", count.getAndIncrement(),\n+                        createTracingSpan(producedSpanContexts, \"stuff-topic\")));\n+\n+        await().until(() -> bean.list().size() >= 10);\n+        assertThat(bean.list()).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        List<TraceId> producedTraceIds = producedSpanContexts.stream()\n+                .map(SpanContext::getTraceId)\n+                .collect(Collectors.toList());\n+        assertThat(producedTraceIds).hasSize(10);\n+\n+        assertThat(bean.tracing()).hasSizeGreaterThanOrEqualTo(10);\n+        assertThat(bean.tracing()).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<TraceId> receivedTraceIds = bean.tracing().stream()\n+                .map(tracingMetadata -> tracingMetadata.getCurrentSpanContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedTraceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+        assertThat(receivedTraceIds).containsExactlyInAnyOrderElementsOf(producedTraceIds);\n+\n+        List<SpanId> spanIds = new ArrayList<>();\n+\n+        for (TracingMetadata tracing : bean.tracing()) {\n+            spanIds.add(tracing.getCurrentSpanContext().getSpanId());\n+\n+            assertThat(tracing.getPreviousSpanContext()).isNotNull();\n+            assertThat(tracing.getPreviousSpanContext().getTraceId())\n+                    .isEqualByComparingTo(tracing.getCurrentSpanContext().getTraceId());\n+            assertThat(tracing.getPreviousSpanContext().getSpanId())\n+                    .isNotEqualByComparingTo(tracing.getCurrentSpanContext().getSpanId());\n+        }\n+\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSizeGreaterThanOrEqualTo(10);\n+\n+        List<SpanId> parentIds = bean.tracing().stream()\n+                .map(tracingMetadata -> tracingMetadata.getPreviousSpanContext().getSpanId())\n+                .collect(Collectors.toList());\n+\n+        assertThat(producedSpanContexts.stream()\n+                .map(SpanContext::getSpanId)).containsExactlyElementsOf(parentIds);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getKind()).isEqualByComparingTo(CONSUMER);\n+            assertThat(data.getParentSpanId()).isNotNull();\n+            assertThat(data.getParentSpanId()).isIn(parentIds);\n+        }\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppWithNoParent() {\n+        KafkaUsage usage = new KafkaUsage();\n+        deploy(getKafkaSinkConfigForMyAppReceivingData(\"no-parent-stuff\"), MyAppReceivingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        MyAppReceivingData bean = container.getBeanManager().createInstance().select(MyAppReceivingData.class).get();\n+\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"no-parent-stuff\", null, null, \"a-key\", count.getAndIncrement()));\n+\n+        await().until(() -> bean.list().size() >= 10);\n+        assertThat(bean.list()).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        assertThat(bean.tracing()).hasSizeGreaterThanOrEqualTo(10);\n+        assertThat(bean.tracing()).doesNotContainNull().doesNotHaveDuplicates();\n+        List<SpanId> spanIds = new ArrayList<>();\n+\n+        for (TracingMetadata tracing : bean.tracing()) {\n+            spanIds.add(tracing.getCurrentSpanContext().getSpanId());\n+            assertThat(tracing.getPreviousSpanContext()).isNull();\n+        }\n+\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSizeGreaterThanOrEqualTo(10);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getKind()).isEqualByComparingTo(CONSUMER);\n+            assertThat(data.getParentSpanId().isValid()).isFalse();\n+        }\n+    }\n+\n+    private Iterable<Header> createTracingSpan(List<SpanContext> spanContexts, String topic) {\n+        RecordHeaders proposedHeaders = new RecordHeaders();\n+        final Span span = KafkaConnector.TRACER.spanBuilder(topic).setSpanKind(PRODUCER).startSpan();\n+        final Context context = withSpan(span, Context.current());\n+        OpenTelemetry.getPropagators()\n+                .getHttpTextFormat()\n+                .inject(context, proposedHeaders, (headers, key, value) -> {\n+                    if (headers != null) {\n+                        headers.remove(key).add(key, value.getBytes(StandardCharsets.UTF_8));\n+                    }\n+                });\n+        spanContexts.add(span.getContext());\n+        return proposedHeaders;\n+    }\n+\n+    private <T> void deploy(MapBasedConfig config, Class<T> clazz) {\n+        if (config != null) {\n+            config.write();\n+        } else {\n+            MapBasedConfig.clear();\n+        }\n+\n+        Weld weld = baseWeld();\n+        weld.addBeanClass(clazz);\n+\n+        container = weld.initialize();\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppGeneratingData() {\n+        String prefix = \"mp.messaging.outgoing.kafka.\";\n+        Map<String, Object> config = new HashMap<>();\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.serializer\", IntegerSerializer.class.getName());\n+        config.put(prefix + \"topic\", \"output\");\n+        return new MapBasedConfig(config);\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppProcessingData() {\n+        String prefix = \"mp.messaging.outgoing.kafka.\";\n+        Map<String, Object> config = new HashMap<>();\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.serializer\", IntegerSerializer.class.getName());\n+        config.put(prefix + \"topic\", \"result-topic\");\n+\n+        prefix = \"mp.messaging.incoming.source.\";\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.deserializer\", IntegerDeserializer.class.getName());\n+        config.put(prefix + \"key.deserializer\", StringDeserializer.class.getName());\n+        config.put(prefix + \"topic\", \"some-topic\");\n+        config.put(prefix + \"auto.offset.reset\", \"earliest\");\n+\n+        return new MapBasedConfig(config);\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppReceivingData(String topic) {\n+        Map<String, Object> config = new HashMap<>();\n+\n+        String prefix = \"mp.messaging.incoming.stuff.\";\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.deserializer\", IntegerDeserializer.class.getName());\n+        config.put(prefix + \"key.deserializer\", StringDeserializer.class.getName());\n+        config.put(prefix + \"topic\", topic);\n+        config.put(prefix + \"auto.offset.reset\", \"earliest\");\n+\n+        return new MapBasedConfig(config);\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppGeneratingData {\n+\n+        @Outgoing(\"kafka\")\n+        public Flowable<Integer> source() {\n+            return Flowable.range(0, 10);\n+        }\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppProcessingData {\n+\n+        @Incoming(\"source\")\n+        @Outgoing(\"kafka\")\n+        public Message<Integer> processMessage(Message<Integer> input) {\n+            return input.withPayload(input.getPayload() + 1);\n+        }\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppReceivingData {\n+        private List<TracingMetadata> tracingMetadata = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 373}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NzI3NTQ5OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNzoxODo1NlrOHGKv_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNzoxODo1NlrOHGKv_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIyOTYzMQ==", "bodyText": "minor - can be final", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476229631", "createdAt": "2020-08-25T07:18:56Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "diffHunk": "@@ -0,0 +1,392 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import static io.opentelemetry.trace.Span.Kind.CONSUMER;\n+import static io.opentelemetry.trace.Span.Kind.PRODUCER;\n+import static io.opentelemetry.trace.TracingContextUtils.withSpan;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.jboss.weld.environment.se.Weld;\n+import org.jboss.weld.environment.se.WeldContainer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.exporters.inmemory.InMemorySpanExporter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.reactivex.Flowable;\n+import io.smallrye.config.SmallRyeConfigProviderResolver;\n+import io.smallrye.reactive.messaging.TracingMetadata;\n+import io.smallrye.reactive.messaging.kafka.KafkaConnector;\n+import io.smallrye.reactive.messaging.kafka.KafkaTestBase;\n+import io.smallrye.reactive.messaging.kafka.KafkaUsage;\n+import io.smallrye.reactive.messaging.kafka.MapBasedConfig;\n+\n+public class TracingPropagationTest extends KafkaTestBase {\n+\n+    private WeldContainer container;\n+    private InMemorySpanExporter testExporter;\n+    private SpanProcessor spanProcessor;\n+\n+    @Before\n+    public void setup() {\n+        testExporter = InMemorySpanExporter.create();\n+        spanProcessor = SimpleSpanProcessor.newBuilder(testExporter).build();\n+        OpenTelemetrySdk.getTracerProvider().addSpanProcessor(spanProcessor);\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        if (testExporter != null) {\n+            testExporter.shutdown();\n+        }\n+        if (spanProcessor != null) {\n+            spanProcessor.shutdown();\n+        }\n+\n+        if (container != null) {\n+            container.close();\n+        }\n+\n+        // Release the config objects\n+        SmallRyeConfigProviderResolver.instance().releaseConfig(ConfigProvider.getConfig());\n+    }\n+\n+    @Test\n+    public void testFromAppToKafka() {\n+        KafkaUsage usage = new KafkaUsage();\n+        List<Map.Entry<String, Integer>> messages = new CopyOnWriteArrayList<>();\n+        List<Context> contexts = new CopyOnWriteArrayList<>();\n+        usage.consumeIntegersWithTracing(\"output\", 10, 1, TimeUnit.MINUTES, null,\n+                (key, value) -> messages.add(entry(key, value)),\n+                contexts::add);\n+        deploy(getKafkaSinkConfigForMyAppGeneratingData(), MyAppGeneratingData.class);\n+\n+        await().until(() -> messages.size() >= 10);\n+        List<Integer> values = new ArrayList<>();\n+        assertThat(messages).allSatisfy(entry -> {\n+            assertThat(entry.getValue()).isNotNull();\n+            values.add(entry.getValue());\n+        });\n+        assertThat(values).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        assertThat(contexts).hasSize(10);\n+        assertThat(contexts).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<SpanId> spanIds = contexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getSpanId())\n+                .collect(Collectors.toList());\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        List<TraceId> traceIds = contexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(traceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getTraceId()).isIn(traceIds);\n+            assertThat(data.getKind()).isEqualByComparingTo(PRODUCER);\n+            assertThat(data.getParentSpanId().isValid()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppToKafka() {\n+        KafkaUsage usage = new KafkaUsage();\n+        List<Map.Entry<String, Integer>> messages = new CopyOnWriteArrayList<>();\n+        List<Context> receivedContexts = new CopyOnWriteArrayList<>();\n+        usage.consumeIntegersWithTracing(\"result-topic\", 10, 1, TimeUnit.MINUTES, null,\n+                (key, value) -> messages.add(entry(key, value)),\n+                receivedContexts::add);\n+        deploy(getKafkaSinkConfigForMyAppProcessingData(), MyAppProcessingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        List<SpanContext> producedSpanContexts = new CopyOnWriteArrayList<>();\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"some-topic\", null, null, \"a-key\", count.getAndIncrement(),\n+                        createTracingSpan(producedSpanContexts, \"some-topic\")));\n+\n+        await().atMost(Duration.ofMinutes(5)).until(() -> messages.size() >= 10);\n+        List<Integer> values = new ArrayList<>();\n+        assertThat(messages).allSatisfy(entry -> {\n+            assertThat(entry.getValue()).isNotNull();\n+            values.add(entry.getValue());\n+        });\n+        assertThat(values).containsExactly(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+\n+        List<TraceId> producedTraceIds = producedSpanContexts.stream()\n+                .map(SpanContext::getTraceId)\n+                .collect(Collectors.toList());\n+        assertThat(producedTraceIds).hasSize(10);\n+\n+        assertThat(receivedContexts).hasSize(10);\n+        assertThat(receivedContexts).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<SpanId> receivedSpanIds = receivedContexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getSpanId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedSpanIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        List<TraceId> receivedTraceIds = receivedContexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedTraceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+        assertThat(receivedTraceIds).containsExactlyInAnyOrderElementsOf(producedTraceIds);\n+\n+        List<SpanId> receivedParentSpanIds = new ArrayList<>();\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            if (data.getKind().equals(CONSUMER)) {\n+                // Need to skip the spans created during @Incoming processing\n+                continue;\n+            }\n+            assertThat(data.getSpanId()).isIn(receivedSpanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getTraceId()).isIn(producedTraceIds);\n+            assertThat(data.getKind()).isEqualByComparingTo(PRODUCER);\n+            assertThat(data.getParentSpanId().isValid()).isTrue();\n+            receivedParentSpanIds.add(data.getParentSpanId());\n+        }\n+\n+        assertThat(producedSpanContexts.stream()\n+                .map(SpanContext::getSpanId)).containsExactlyElementsOf(receivedParentSpanIds);\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppWithParentSpan() {\n+        KafkaUsage usage = new KafkaUsage();\n+        deploy(getKafkaSinkConfigForMyAppReceivingData(\"parent-stuff\"), MyAppReceivingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        MyAppReceivingData bean = container.getBeanManager().createInstance().select(MyAppReceivingData.class).get();\n+        List<SpanContext> producedSpanContexts = new CopyOnWriteArrayList<>();\n+\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"parent-stuff\", null, null, \"a-key\", count.getAndIncrement(),\n+                        createTracingSpan(producedSpanContexts, \"stuff-topic\")));\n+\n+        await().until(() -> bean.list().size() >= 10);\n+        assertThat(bean.list()).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        List<TraceId> producedTraceIds = producedSpanContexts.stream()\n+                .map(SpanContext::getTraceId)\n+                .collect(Collectors.toList());\n+        assertThat(producedTraceIds).hasSize(10);\n+\n+        assertThat(bean.tracing()).hasSizeGreaterThanOrEqualTo(10);\n+        assertThat(bean.tracing()).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<TraceId> receivedTraceIds = bean.tracing().stream()\n+                .map(tracingMetadata -> tracingMetadata.getCurrentSpanContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedTraceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+        assertThat(receivedTraceIds).containsExactlyInAnyOrderElementsOf(producedTraceIds);\n+\n+        List<SpanId> spanIds = new ArrayList<>();\n+\n+        for (TracingMetadata tracing : bean.tracing()) {\n+            spanIds.add(tracing.getCurrentSpanContext().getSpanId());\n+\n+            assertThat(tracing.getPreviousSpanContext()).isNotNull();\n+            assertThat(tracing.getPreviousSpanContext().getTraceId())\n+                    .isEqualByComparingTo(tracing.getCurrentSpanContext().getTraceId());\n+            assertThat(tracing.getPreviousSpanContext().getSpanId())\n+                    .isNotEqualByComparingTo(tracing.getCurrentSpanContext().getSpanId());\n+        }\n+\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSizeGreaterThanOrEqualTo(10);\n+\n+        List<SpanId> parentIds = bean.tracing().stream()\n+                .map(tracingMetadata -> tracingMetadata.getPreviousSpanContext().getSpanId())\n+                .collect(Collectors.toList());\n+\n+        assertThat(producedSpanContexts.stream()\n+                .map(SpanContext::getSpanId)).containsExactlyElementsOf(parentIds);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getKind()).isEqualByComparingTo(CONSUMER);\n+            assertThat(data.getParentSpanId()).isNotNull();\n+            assertThat(data.getParentSpanId()).isIn(parentIds);\n+        }\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppWithNoParent() {\n+        KafkaUsage usage = new KafkaUsage();\n+        deploy(getKafkaSinkConfigForMyAppReceivingData(\"no-parent-stuff\"), MyAppReceivingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        MyAppReceivingData bean = container.getBeanManager().createInstance().select(MyAppReceivingData.class).get();\n+\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"no-parent-stuff\", null, null, \"a-key\", count.getAndIncrement()));\n+\n+        await().until(() -> bean.list().size() >= 10);\n+        assertThat(bean.list()).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        assertThat(bean.tracing()).hasSizeGreaterThanOrEqualTo(10);\n+        assertThat(bean.tracing()).doesNotContainNull().doesNotHaveDuplicates();\n+        List<SpanId> spanIds = new ArrayList<>();\n+\n+        for (TracingMetadata tracing : bean.tracing()) {\n+            spanIds.add(tracing.getCurrentSpanContext().getSpanId());\n+            assertThat(tracing.getPreviousSpanContext()).isNull();\n+        }\n+\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSizeGreaterThanOrEqualTo(10);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getKind()).isEqualByComparingTo(CONSUMER);\n+            assertThat(data.getParentSpanId().isValid()).isFalse();\n+        }\n+    }\n+\n+    private Iterable<Header> createTracingSpan(List<SpanContext> spanContexts, String topic) {\n+        RecordHeaders proposedHeaders = new RecordHeaders();\n+        final Span span = KafkaConnector.TRACER.spanBuilder(topic).setSpanKind(PRODUCER).startSpan();\n+        final Context context = withSpan(span, Context.current());\n+        OpenTelemetry.getPropagators()\n+                .getHttpTextFormat()\n+                .inject(context, proposedHeaders, (headers, key, value) -> {\n+                    if (headers != null) {\n+                        headers.remove(key).add(key, value.getBytes(StandardCharsets.UTF_8));\n+                    }\n+                });\n+        spanContexts.add(span.getContext());\n+        return proposedHeaders;\n+    }\n+\n+    private <T> void deploy(MapBasedConfig config, Class<T> clazz) {\n+        if (config != null) {\n+            config.write();\n+        } else {\n+            MapBasedConfig.clear();\n+        }\n+\n+        Weld weld = baseWeld();\n+        weld.addBeanClass(clazz);\n+\n+        container = weld.initialize();\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppGeneratingData() {\n+        String prefix = \"mp.messaging.outgoing.kafka.\";\n+        Map<String, Object> config = new HashMap<>();\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.serializer\", IntegerSerializer.class.getName());\n+        config.put(prefix + \"topic\", \"output\");\n+        return new MapBasedConfig(config);\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppProcessingData() {\n+        String prefix = \"mp.messaging.outgoing.kafka.\";\n+        Map<String, Object> config = new HashMap<>();\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.serializer\", IntegerSerializer.class.getName());\n+        config.put(prefix + \"topic\", \"result-topic\");\n+\n+        prefix = \"mp.messaging.incoming.source.\";\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.deserializer\", IntegerDeserializer.class.getName());\n+        config.put(prefix + \"key.deserializer\", StringDeserializer.class.getName());\n+        config.put(prefix + \"topic\", \"some-topic\");\n+        config.put(prefix + \"auto.offset.reset\", \"earliest\");\n+\n+        return new MapBasedConfig(config);\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppReceivingData(String topic) {\n+        Map<String, Object> config = new HashMap<>();\n+\n+        String prefix = \"mp.messaging.incoming.stuff.\";\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.deserializer\", IntegerDeserializer.class.getName());\n+        config.put(prefix + \"key.deserializer\", StringDeserializer.class.getName());\n+        config.put(prefix + \"topic\", topic);\n+        config.put(prefix + \"auto.offset.reset\", \"earliest\");\n+\n+        return new MapBasedConfig(config);\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppGeneratingData {\n+\n+        @Outgoing(\"kafka\")\n+        public Flowable<Integer> source() {\n+            return Flowable.range(0, 10);\n+        }\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppProcessingData {\n+\n+        @Incoming(\"source\")\n+        @Outgoing(\"kafka\")\n+        public Message<Integer> processMessage(Message<Integer> input) {\n+            return input.withPayload(input.getPayload() + 1);\n+        }\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppReceivingData {\n+        private List<TracingMetadata> tracingMetadata = new ArrayList<>();\n+        private List<Integer> results = new CopyOnWriteArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 374}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NjExMjk1OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMzowODo0N1rOHJEZBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMzo1MDozNlrOHJGw1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3MTE3NQ==", "bodyText": "The signature looks weird getTracingEnabled() it could be .isTracingEnabled()?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r479271175", "createdAt": "2020-08-28T13:08:47Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -264,6 +275,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9c298550d2387d3efcfc8a25f6ae9eeebdba3a7"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTMxMDAzNg==", "bodyText": "I think that's just how the methods are generated, as it's not manually coded", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r479310036", "createdAt": "2020-08-28T13:50:36Z", "author": {"login": "kenfinnigan"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -264,6 +275,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3MTE3NQ=="}, "originalCommit": {"oid": "b9c298550d2387d3efcfc8a25f6ae9eeebdba3a7"}, "originalPosition": 52}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 95, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}