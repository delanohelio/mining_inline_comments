{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0NDIxMzI0", "number": 467, "title": "Fixes #79 - Add support for @Blocking", "bodyText": "", "createdAt": "2020-03-26T21:00:51Z", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467", "merged": true, "mergeCommit": {"oid": "4b5f32b56822b2552b394b56371197ec432b342d"}, "closed": true, "closedAt": "2020-04-03T13:51:00Z", "author": {"login": "kenfinnigan"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRkBKlgFqTM4MjQyMzUxNw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcUA86ZAFqTM4NzI1NzIxMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNDIzNTE3", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#pullrequestreview-382423517", "createdAt": "2020-03-26T21:11:20Z", "commit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMToxMToyMFrOF8apBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMjoxNzozMlrOF8chew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg5NTM2Ng==", "bodyText": "Maybe isExecutionOrdered or isBlockingExecutionOrdered?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398895366", "createdAt": "2020-03-26T21:11:20Z", "author": {"login": "cescoffier"}, "path": "api/src/main/java/io/smallrye/reactive/messaging/MediatorConfiguration.java", "diffHunk": "@@ -41,6 +41,12 @@\n \n     int getNumberOfSubscriberBeforeConnecting();\n \n+    boolean isBlocking();\n+\n+    String getWorkerPoolName();\n+\n+    boolean isOrderedExecution();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg5NjE3Nw==", "bodyText": "@Incomings should not be really used by the user. I would remove it.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398896177", "createdAt": "2020-03-26T21:12:57Z", "author": {"login": "cescoffier"}, "path": "doc/advanced.adoc", "diffHunk": "@@ -158,6 +158,56 @@ The `io.smallrye.reactive.messaging.annotations.Emitter` class is now deprecated\n The `io.smallrye.reactive.messaging.annotations.OnOverflow` annotation is now deprecated and use the one defined in the specification (`org.eclipse.microprofile.reactive.messaging.OnOverflow`).\n ====\n \n+=== @Blocking\n+\n+The `@Blocking` annotation can be used on a method annotated with `@Incomings`, `@Incoming`,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg5NjU2OA==", "bodyText": "Maybe in the snippet use Thread.sleep. So it's really blocking.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398896568", "createdAt": "2020-03-26T21:13:47Z", "author": {"login": "cescoffier"}, "path": "doc/advanced.adoc", "diffHunk": "@@ -158,6 +158,56 @@ The `io.smallrye.reactive.messaging.annotations.Emitter` class is now deprecated\n The `io.smallrye.reactive.messaging.annotations.OnOverflow` annotation is now deprecated and use the one defined in the specification (`org.eclipse.microprofile.reactive.messaging.OnOverflow`).\n ====\n \n+=== @Blocking\n+\n+The `@Blocking` annotation can be used on a method annotated with `@Incomings`, `@Incoming`,\n+or `@Outgoing` to indicate that the method should be executed on a worker pool:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking\n+public String process(String s) {\n+  return s.toUpperCase();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkwMDA4Nw==", "bodyText": "I would reuse the same code so Thread.sleep.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398900087", "createdAt": "2020-03-26T21:20:54Z", "author": {"login": "cescoffier"}, "path": "doc/advanced.adoc", "diffHunk": "@@ -158,6 +158,56 @@ The `io.smallrye.reactive.messaging.annotations.Emitter` class is now deprecated\n The `io.smallrye.reactive.messaging.annotations.OnOverflow` annotation is now deprecated and use the one defined in the specification (`org.eclipse.microprofile.reactive.messaging.OnOverflow`).\n ====\n \n+=== @Blocking\n+\n+The `@Blocking` annotation can be used on a method annotated with `@Incomings`, `@Incoming`,\n+or `@Outgoing` to indicate that the method should be executed on a worker pool:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking\n+public String process(String s) {\n+  return s.toUpperCase();\n+}\n+----\n+\n+If method execution does not need to be ordered,\n+it can be indicated on the `@Blocking` annotation:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking(ordered = false)\n+public String process(String s) {\n+  return s.toUpperCase();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkwMDg5NQ==", "bodyText": "I would reuse the same code so Thread.sleep.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398900895", "createdAt": "2020-03-26T21:22:37Z", "author": {"login": "cescoffier"}, "path": "doc/advanced.adoc", "diffHunk": "@@ -158,6 +158,56 @@ The `io.smallrye.reactive.messaging.annotations.Emitter` class is now deprecated\n The `io.smallrye.reactive.messaging.annotations.OnOverflow` annotation is now deprecated and use the one defined in the specification (`org.eclipse.microprofile.reactive.messaging.OnOverflow`).\n ====\n \n+=== @Blocking\n+\n+The `@Blocking` annotation can be used on a method annotated with `@Incomings`, `@Incoming`,\n+or `@Outgoing` to indicate that the method should be executed on a worker pool:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking\n+public String process(String s) {\n+  return s.toUpperCase();\n+}\n+----\n+\n+If method execution does not need to be ordered,\n+it can be indicated on the `@Blocking` annotation:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking(ordered = false)\n+public String process(String s) {\n+  return s.toUpperCase();\n+}\n+----\n+\n+By default, use of `@Blocking` results in the method being executed in the Vert.x worker pool.\n+If it's desired to execute methods on a custom worker pool,\n+with specific concurrency needs,\n+it can be defined on `@Blocking`:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking(\"my-custom-pool\")\n+public String process(String s) {\n+  return s.toUpperCase();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkwMTg0OA==", "bodyText": "Maybe explain the syntax.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398901848", "createdAt": "2020-03-26T21:24:30Z", "author": {"login": "cescoffier"}, "path": "doc/advanced.adoc", "diffHunk": "@@ -158,6 +158,56 @@ The `io.smallrye.reactive.messaging.annotations.Emitter` class is now deprecated\n The `io.smallrye.reactive.messaging.annotations.OnOverflow` annotation is now deprecated and use the one defined in the specification (`org.eclipse.microprofile.reactive.messaging.OnOverflow`).\n ====\n \n+=== @Blocking\n+\n+The `@Blocking` annotation can be used on a method annotated with `@Incomings`, `@Incoming`,\n+or `@Outgoing` to indicate that the method should be executed on a worker pool:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking\n+public String process(String s) {\n+  return s.toUpperCase();\n+}\n+----\n+\n+If method execution does not need to be ordered,\n+it can be indicated on the `@Blocking` annotation:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking(ordered = false)\n+public String process(String s) {\n+  return s.toUpperCase();\n+}\n+----\n+\n+By default, use of `@Blocking` results in the method being executed in the Vert.x worker pool.\n+If it's desired to execute methods on a custom worker pool,\n+with specific concurrency needs,\n+it can be defined on `@Blocking`:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking(\"my-custom-pool\")\n+public String process(String s) {\n+  return s.toUpperCase();\n+}\n+----\n+\n+Specifying the concurrency for the above worker pool requires the following configuration property to be defined:\n+\n+[source]\n+----\n+smallrye.messaging.worker.my-custom-pool.max-concurrency=3", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkwMzQzNw==", "bodyText": "don't we have a closeAnAwait() method?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398903437", "createdAt": "2020-03-26T21:27:50Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-amqp/src/test/java/io/smallrye/reactive/messaging/amqp/AmqpTestBase.java", "diffHunk": "@@ -45,7 +46,8 @@ public void tearDown() throws InterruptedException {\n \n         CountDownLatch latch = new CountDownLatch(1);\n         usage.close();\n-        vertx.close().subscribe().with(x -> latch.countDown(), f -> latch.countDown());\n+        executionHolder.vertx().close().subscribe().with(x -> latch.countDown(), f -> latch.countDown());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkwODE4NQ==", "bodyText": "For my own curiosity. How does that work?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398908185", "createdAt": "2020-03-26T21:37:31Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConnector.java", "diffHunk": "@@ -39,26 +41,17 @@\n     private List<KafkaSource> sources = new CopyOnWriteArrayList<>();\n     private List<KafkaSink> sinks = new CopyOnWriteArrayList<>();\n \n-    private boolean internalVertxInstance = false;\n     private Vertx vertx;\n \n-    public void terminate(@Observes @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(50) @BeforeDestroyed(ApplicationScoped.class) Object event) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkxMDA5Mg==", "bodyText": "wondering if we could check that only once.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398910092", "createdAt": "2020-03-26T21:41:38Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/AbstractMediator.java", "diffHunk": "@@ -73,6 +80,21 @@ public void initialize(Object bean) {\n         }\n     }\n \n+    protected <T> Uni<T> invokeBlocking(Object... args) {\n+        try {\n+            Objects.requireNonNull(this.invoker, \"Invoker not initialized\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyMDc3MQ==", "bodyText": "Maybe we should log a message.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398920771", "createdAt": "2020-03-26T22:04:58Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/ExecutionHolder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.inject.Inject;\n+\n+import io.vertx.mutiny.core.Vertx;\n+\n+@ApplicationScoped\n+public class ExecutionHolder {\n+\n+    @Inject\n+    private Instance<Vertx> instanceOfVertx;\n+\n+    private boolean internalVertxInstance = false;\n+    private Vertx vertx;\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(200) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        if (internalVertxInstance) {\n+            vertx.close().await().indefinitely();\n+        }\n+    }\n+\n+    @PostConstruct\n+    public void init() {\n+        if (instanceOfVertx == null || instanceOfVertx.isUnsatisfied()) {\n+            internalVertxInstance = true;\n+            this.vertx = Vertx.vertx();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyMTI4NA==", "bodyText": "Action instead of code?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398921284", "createdAt": "2020-03-26T22:06:12Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/WorkerPoolRegistry.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.spi.AnnotatedMethod;\n+import javax.enterprise.inject.spi.AnnotatedType;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+import io.smallrye.reactive.messaging.annotations.Incomings;\n+import io.smallrye.reactive.messaging.helpers.Validation;\n+import io.vertx.core.Handler;\n+import io.vertx.mutiny.core.Promise;\n+import io.vertx.mutiny.core.WorkerExecutor;\n+\n+@ApplicationScoped\n+public class WorkerPoolRegistry {\n+    private static final String WORKER_CONFIG_PREFIX = \"smallrye.messaging.worker\";\n+    private static final String WORKER_CONCURRENCY = \"max-concurrency\";\n+\n+    @Inject\n+    private ExecutionHolder executionHolder;\n+\n+    @Inject\n+    private Instance<Config> configInstance;\n+\n+    private Map<String, Integer> workerDefinitions = new HashMap<>();\n+    private Map<String, WorkerExecutor> workerExecutors = new ConcurrentHashMap<>();\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(100) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        if (!workerExecutors.isEmpty()) {\n+            for (WorkerExecutor executor : workerExecutors.values()) {\n+                executor.close();\n+            }\n+        }\n+    }\n+\n+    public <T> Uni<T> executeWork(Handler<Promise<T>> blockingCodeHandler, String workerName, boolean ordered) {\n+        Objects.requireNonNull(blockingCodeHandler, \"Code to execute not provided\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyMjEyMA==", "bodyText": "Need to be synchronized I guess.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398922120", "createdAt": "2020-03-26T22:08:14Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/WorkerPoolRegistry.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.spi.AnnotatedMethod;\n+import javax.enterprise.inject.spi.AnnotatedType;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+import io.smallrye.reactive.messaging.annotations.Incomings;\n+import io.smallrye.reactive.messaging.helpers.Validation;\n+import io.vertx.core.Handler;\n+import io.vertx.mutiny.core.Promise;\n+import io.vertx.mutiny.core.WorkerExecutor;\n+\n+@ApplicationScoped\n+public class WorkerPoolRegistry {\n+    private static final String WORKER_CONFIG_PREFIX = \"smallrye.messaging.worker\";\n+    private static final String WORKER_CONCURRENCY = \"max-concurrency\";\n+\n+    @Inject\n+    private ExecutionHolder executionHolder;\n+\n+    @Inject\n+    private Instance<Config> configInstance;\n+\n+    private Map<String, Integer> workerDefinitions = new HashMap<>();\n+    private Map<String, WorkerExecutor> workerExecutors = new ConcurrentHashMap<>();\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(100) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        if (!workerExecutors.isEmpty()) {\n+            for (WorkerExecutor executor : workerExecutors.values()) {\n+                executor.close();\n+            }\n+        }\n+    }\n+\n+    public <T> Uni<T> executeWork(Handler<Promise<T>> blockingCodeHandler, String workerName, boolean ordered) {\n+        Objects.requireNonNull(blockingCodeHandler, \"Code to execute not provided\");\n+\n+        if (workerName == null) {\n+            return executionHolder.vertx().executeBlocking(blockingCodeHandler, ordered);\n+        } else {\n+            return getWorker(workerName).executeBlocking(blockingCodeHandler, ordered);\n+        }\n+    }\n+\n+    private WorkerExecutor getWorker(String workerName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyNjIwMw==", "bodyText": "I'm not sure we need to be that precise.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398926203", "createdAt": "2020-03-26T22:17:32Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/test/java/io/smallrye/reactive/messaging/blocking/BlockingProcessorTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package io.smallrye.reactive.messaging.blocking;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Test;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.reactive.messaging.MyCollector;\n+import io.smallrye.reactive.messaging.WeldTestBase;\n+import io.smallrye.reactive.messaging.blocking.beans.BeanConsumingItemsAndProducingItems;\n+import io.smallrye.reactive.messaging.blocking.beans.BeanConsumingItemsAndProducingMessages;\n+import io.smallrye.reactive.messaging.blocking.beans.BeanConsumingMessagesAndProducingItems;\n+import io.smallrye.reactive.messaging.blocking.beans.BeanConsumingMessagesAndProducingMessages;\n+\n+public class BlockingProcessorTest extends WeldTestBase {\n+\n+    private static final List<String> LIST = Multi.createFrom().range(1, 11).map(i -> Integer.toString(i))\n+            .collectItems().asList()\n+            .await().indefinitely();\n+\n+    @Test\n+    public void testBeanConsumingMessagesAndProducingMessages() {\n+        addBeanClass(BeanConsumingMessagesAndProducingMessages.class);\n+        initialize();\n+        MyCollector collector = container.select(MyCollector.class).get();\n+        await().until(collector::hasCompleted);\n+        assertThat(collector.payloads()).isEqualTo(LIST);\n+\n+        BeanConsumingMessagesAndProducingMessages bean = container.select(BeanConsumingMessagesAndProducingMessages.class)\n+                .get();\n+\n+        List<String> threadNames = bean.threads().stream().distinct().collect(Collectors.toList());\n+        assertThat(threadNames.contains(Thread.currentThread().getName())).isFalse();\n+        for (String name : threadNames) {\n+            assertThat(name.startsWith(\"vert.x-worker-thread-\")).isTrue();\n+        }\n+    }\n+\n+    @Test\n+    public void testBeanConsumingMessagesAndProducingItems() {\n+        addBeanClass(BeanConsumingMessagesAndProducingItems.class);\n+        initialize();\n+        MyCollector collector = container.select(MyCollector.class).get();\n+        await().until(collector::hasCompleted);\n+        assertThat(collector.payloads()).isEqualTo(LIST);\n+\n+        BeanConsumingMessagesAndProducingItems bean = container.select(BeanConsumingMessagesAndProducingItems.class).get();\n+\n+        List<String> threadNames = bean.threads().stream().distinct().collect(Collectors.toList());\n+        assertThat(threadNames.contains(Thread.currentThread().getName())).isFalse();\n+        for (String name : threadNames) {\n+            assertThat(name.startsWith(\"vert.x-worker-thread-\")).isTrue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNjMxODEy", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#pullrequestreview-382631812", "createdAt": "2020-03-27T07:37:00Z", "commit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwNzozNzowMFrOF8l9XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwODozMTo0MVrOF8nYig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MDc5Ng==", "bodyText": "I would add a note telling that when possible the initial thread (execution context) is \"restored\" once the blocking operation has been completed. This should also be explained in the doc.\nI would also add a few lines about the configuration.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399080796", "createdAt": "2020-03-27T07:37:00Z", "author": {"login": "cescoffier"}, "path": "api/src/main/java/io/smallrye/reactive/messaging/annotations/Blocking.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package io.smallrye.reactive.messaging.annotations;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Identifies that a particular method performs blocking operations,\n+ * and as such should be executed on a worker thread.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MDk5Mg==", "bodyText": "Instead of NO_VALUE maybe it should be DEFAULT_WORKER_POOL.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399080992", "createdAt": "2020-03-27T07:37:35Z", "author": {"login": "cescoffier"}, "path": "api/src/main/java/io/smallrye/reactive/messaging/annotations/Blocking.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package io.smallrye.reactive.messaging.annotations;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Identifies that a particular method performs blocking operations,\n+ * and as such should be executed on a worker thread.\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(METHOD)\n+public @interface Blocking {\n+    String NO_VALUE = \"<no-value>\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MjIyMQ==", "bodyText": "This requires a bit more explanation.\nSomething like:\nThe blocking processing of the incoming messages is executed on worker threads. However, some combustion may be faster than others. When ordered is set to true, the results are emitted in the same order as the input so the order is preserved. When ordered is set to false, results are emitted as soon as the blocking computation terminated, regardless if the combustion from previous messages has completed.\nthe result of the blocking operation will be emitted in the same order as the input.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399082221", "createdAt": "2020-03-27T07:41:08Z", "author": {"login": "cescoffier"}, "path": "api/src/main/java/io/smallrye/reactive/messaging/annotations/Blocking.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package io.smallrye.reactive.messaging.annotations;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Identifies that a particular method performs blocking operations,\n+ * and as such should be executed on a worker thread.\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(METHOD)\n+public @interface Blocking {\n+    String NO_VALUE = \"<no-value>\";\n+\n+    /**\n+     * Indicates the name of the worker pool to use for execution.\n+     * By default all executions will be performed on the default worker pool.\n+     *\n+     * @return custom worker pool name for blocking execution.\n+     */\n+    String value() default NO_VALUE;\n+\n+    /**\n+     * Indicates whether the execution on the worker pool should be ordered.\n+     * By default all executions are ordered.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4Mjk2Ng==", "bodyText": "... instead of the called thread.\nI would also add something like:\nIf the processing thread is an IO Thread (event loop) is should not be blocked. @Blocking allows to dispatch the blocking operation on a worker thread and once done switch back to the initial thread (if possible).", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399082966", "createdAt": "2020-03-27T07:43:02Z", "author": {"login": "cescoffier"}, "path": "doc/advanced.adoc", "diffHunk": "@@ -158,6 +158,56 @@ The `io.smallrye.reactive.messaging.annotations.Emitter` class is now deprecated\n The `io.smallrye.reactive.messaging.annotations.OnOverflow` annotation is now deprecated and use the one defined in the specification (`org.eclipse.microprofile.reactive.messaging.OnOverflow`).\n ====\n \n+=== @Blocking\n+\n+The `@Blocking` annotation can be used on a method annotated with `@Incomings`, `@Incoming`,\n+or `@Outgoing` to indicate that the method should be executed on a worker pool:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MzI4NQ==", "bodyText": "I would repeat the explanation about ordered.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399083285", "createdAt": "2020-03-27T07:43:50Z", "author": {"login": "cescoffier"}, "path": "doc/advanced.adoc", "diffHunk": "@@ -158,6 +158,56 @@ The `io.smallrye.reactive.messaging.annotations.Emitter` class is now deprecated\n The `io.smallrye.reactive.messaging.annotations.OnOverflow` annotation is now deprecated and use the one defined in the specification (`org.eclipse.microprofile.reactive.messaging.OnOverflow`).\n ====\n \n+=== @Blocking\n+\n+The `@Blocking` annotation can be used on a method annotated with `@Incomings`, `@Incoming`,\n+or `@Outgoing` to indicate that the method should be executed on a worker pool:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking\n+public String process(String s) {\n+  return s.toUpperCase();\n+}\n+----\n+\n+If method execution does not need to be ordered,\n+it can be indicated on the `@Blocking` annotation:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MzU1Mw==", "bodyText": "I would put parenthesis around Vert.x, it's a detail.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399083553", "createdAt": "2020-03-27T07:44:32Z", "author": {"login": "cescoffier"}, "path": "doc/advanced.adoc", "diffHunk": "@@ -158,6 +158,56 @@ The `io.smallrye.reactive.messaging.annotations.Emitter` class is now deprecated\n The `io.smallrye.reactive.messaging.annotations.OnOverflow` annotation is now deprecated and use the one defined in the specification (`org.eclipse.microprofile.reactive.messaging.OnOverflow`).\n ====\n \n+=== @Blocking\n+\n+The `@Blocking` annotation can be used on a method annotated with `@Incomings`, `@Incoming`,\n+or `@Outgoing` to indicate that the method should be executed on a worker pool:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking\n+public String process(String s) {\n+  return s.toUpperCase();\n+}\n+----\n+\n+If method execution does not need to be ordered,\n+it can be indicated on the `@Blocking` annotation:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking(ordered = false)\n+public String process(String s) {\n+  return s.toUpperCase();\n+}\n+----\n+\n+By default, use of `@Blocking` results in the method being executed in the Vert.x worker pool.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MzY3Mw==", "bodyText": "should be mention max concurrency?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399083673", "createdAt": "2020-03-27T07:44:52Z", "author": {"login": "cescoffier"}, "path": "doc/advanced.adoc", "diffHunk": "@@ -158,6 +158,56 @@ The `io.smallrye.reactive.messaging.annotations.Emitter` class is now deprecated\n The `io.smallrye.reactive.messaging.annotations.OnOverflow` annotation is now deprecated and use the one defined in the specification (`org.eclipse.microprofile.reactive.messaging.OnOverflow`).\n ====\n \n+=== @Blocking\n+\n+The `@Blocking` annotation can be used on a method annotated with `@Incomings`, `@Incoming`,\n+or `@Outgoing` to indicate that the method should be executed on a worker pool:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking\n+public String process(String s) {\n+  return s.toUpperCase();\n+}\n+----\n+\n+If method execution does not need to be ordered,\n+it can be indicated on the `@Blocking` annotation:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking(ordered = false)\n+public String process(String s) {\n+  return s.toUpperCase();\n+}\n+----\n+\n+By default, use of `@Blocking` results in the method being executed in the Vert.x worker pool.\n+If it's desired to execute methods on a custom worker pool,\n+with specific concurrency needs,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NDAyOA==", "bodyText": "Also add that it limits the number of concurrent execution, queueing the other operation until the current operation terminates.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399084028", "createdAt": "2020-03-27T07:45:50Z", "author": {"login": "cescoffier"}, "path": "doc/advanced.adoc", "diffHunk": "@@ -158,6 +158,56 @@ The `io.smallrye.reactive.messaging.annotations.Emitter` class is now deprecated\n The `io.smallrye.reactive.messaging.annotations.OnOverflow` annotation is now deprecated and use the one defined in the specification (`org.eclipse.microprofile.reactive.messaging.OnOverflow`).\n ====\n \n+=== @Blocking\n+\n+The `@Blocking` annotation can be used on a method annotated with `@Incomings`, `@Incoming`,\n+or `@Outgoing` to indicate that the method should be executed on a worker pool:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking\n+public String process(String s) {\n+  return s.toUpperCase();\n+}\n+----\n+\n+If method execution does not need to be ordered,\n+it can be indicated on the `@Blocking` annotation:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking(ordered = false)\n+public String process(String s) {\n+  return s.toUpperCase();\n+}\n+----\n+\n+By default, use of `@Blocking` results in the method being executed in the Vert.x worker pool.\n+If it's desired to execute methods on a custom worker pool,\n+with specific concurrency needs,\n+it can be defined on `@Blocking`:\n+\n+[source, java]\n+----\n+@Outgoing(\"Y\")\n+@Incoming(\"X\")\n+@Blocking(\"my-custom-pool\")\n+public String process(String s) {\n+  return s.toUpperCase();\n+}\n+----\n+\n+Specifying the concurrency for the above worker pool requires the following configuration property to be defined:\n+\n+[source]\n+----\n+smallrye.messaging.worker.my-custom-pool.max-concurrency=3", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkwMTg0OA=="}, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NDUwMw==", "bodyText": "Yes.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399084503", "createdAt": "2020-03-27T07:47:05Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/ExecutionHolder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.inject.Inject;\n+\n+import io.vertx.mutiny.core.Vertx;\n+\n+@ApplicationScoped\n+public class ExecutionHolder {\n+\n+    @Inject\n+    private Instance<Vertx> instanceOfVertx;\n+\n+    private boolean internalVertxInstance = false;\n+    private Vertx vertx;\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(200) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        if (internalVertxInstance) {\n+            vertx.close().await().indefinitely();\n+        }\n+    }\n+\n+    @PostConstruct\n+    public void init() {\n+        if (instanceOfVertx == null || instanceOfVertx.isUnsatisfied()) {\n+            internalVertxInstance = true;\n+            this.vertx = Vertx.vertx();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyMDc3MQ=="}, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NDcwOA==", "bodyText": "Not sure about CDI concurrency model. Should it be synchronized? (as well as the accessor)", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399084708", "createdAt": "2020-03-27T07:47:38Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/ExecutionHolder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.inject.Inject;\n+\n+import io.vertx.mutiny.core.Vertx;\n+\n+@ApplicationScoped\n+public class ExecutionHolder {\n+\n+    @Inject\n+    private Instance<Vertx> instanceOfVertx;\n+\n+    private boolean internalVertxInstance = false;\n+    private Vertx vertx;\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(200) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        if (internalVertxInstance) {\n+            vertx.close().await().indefinitely();\n+        }\n+    }\n+\n+    @PostConstruct\n+    public void init() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NTIwMA==", "bodyText": "I would add some javadoc explaining the role of this component:\n\nProvides common runtime services to the connector such as Vertx so it avoids duplicating creation and cleanup in the various connectors.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399085200", "createdAt": "2020-03-27T07:48:49Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/ExecutionHolder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.inject.Inject;\n+\n+import io.vertx.mutiny.core.Vertx;\n+\n+@ApplicationScoped\n+public class ExecutionHolder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NTM2Mg==", "bodyText": "@mkouba Just to verify. Does this work in ArC?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399085362", "createdAt": "2020-03-27T07:49:09Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/ExecutionHolder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.inject.Inject;\n+\n+import io.vertx.mutiny.core.Vertx;\n+\n+@ApplicationScoped\n+public class ExecutionHolder {\n+\n+    @Inject\n+    private Instance<Vertx> instanceOfVertx;\n+\n+    private boolean internalVertxInstance = false;\n+    private Vertx vertx;\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(200) @BeforeDestroyed(ApplicationScoped.class) Object event) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NzA4Nw==", "bodyText": "Not really related to this PR, but I guess we should provide logging facilities in AbstractMediator because that sounds duplicated a few times.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399087087", "createdAt": "2020-03-27T07:53:24Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/AbstractMediator.java", "diffHunk": "@@ -73,6 +80,21 @@ public void initialize(Object bean) {\n         }\n     }\n \n+    protected <T> Uni<T> invokeBlocking(Object... args) {\n+        try {\n+            Objects.requireNonNull(this.invoker, \"Invoker not initialized\");\n+            Objects.requireNonNull(this.workerPoolRegistry, \"Worker pool not initialized\");\n+            return workerPoolRegistry.executeWork(\n+                    future -> future.complete((T) this.invoker.invoke(args)),\n+                    configuration.getWorkerPoolName(),\n+                    configuration.isOrderedExecution());\n+        } catch (RuntimeException e) {\n+            LoggerFactory.getLogger(configuration().methodAsString())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4ODkzNg==", "bodyText": "For safety and logging reason I would do something like:\ntry {\n    T res = (T) this.invoker.invoke(args);\n    if (res == null) {\n         throw new NullPointerException(\"The operation .... has returned null\"\n    }\n   future.complete(res);\n} catch(Throwable e) {\n    future.fail(e);\n}", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399088936", "createdAt": "2020-03-27T07:57:44Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/AbstractMediator.java", "diffHunk": "@@ -73,6 +80,21 @@ public void initialize(Object bean) {\n         }\n     }\n \n+    protected <T> Uni<T> invokeBlocking(Object... args) {\n+        try {\n+            Objects.requireNonNull(this.invoker, \"Invoker not initialized\");\n+            Objects.requireNonNull(this.workerPoolRegistry, \"Worker pool not initialized\");\n+            return workerPoolRegistry.executeWork(\n+                    future -> future.complete((T) this.invoker.invoke(args)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4OTg5MA==", "bodyText": "The message is not totally correct, as you check for method returning Void (NONE).", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399089890", "createdAt": "2020-03-27T07:59:46Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/MediatorConfigurationSupport.java", "diffHunk": "@@ -490,6 +490,29 @@ public Integer processBroadcast(Object outgoing, Supplier<Integer> supplier) {\n         return null;\n     }\n \n+    public void validateBlocking(ValidationOutput validationOutput) {\n+        if (!(validationOutput.production.equals(MediatorConfiguration.Production.INDIVIDUAL_MESSAGE)\n+                || validationOutput.production.equals(MediatorConfiguration.Production.INDIVIDUAL_PAYLOAD)\n+                || validationOutput.production.equals(MediatorConfiguration.Production.NONE))) {\n+            throw getBlockingError(\"The @Blocking annotation is only supported for methods returning Message or a payload\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4OTk2NQ==", "bodyText": "I would add an individual Message or payload.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399089965", "createdAt": "2020-03-27T07:59:59Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/MediatorConfigurationSupport.java", "diffHunk": "@@ -490,6 +490,29 @@ public Integer processBroadcast(Object outgoing, Supplier<Integer> supplier) {\n         return null;\n     }\n \n+    public void validateBlocking(ValidationOutput validationOutput) {\n+        if (!(validationOutput.production.equals(MediatorConfiguration.Production.INDIVIDUAL_MESSAGE)\n+                || validationOutput.production.equals(MediatorConfiguration.Production.INDIVIDUAL_PAYLOAD)\n+                || validationOutput.production.equals(MediatorConfiguration.Production.NONE))) {\n+            throw getBlockingError(\"The @Blocking annotation is only supported for methods returning Message or a payload\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4OTg5MA=="}, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5MDI1MA==", "bodyText": "Same comment.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399090250", "createdAt": "2020-03-27T08:00:42Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/MediatorConfigurationSupport.java", "diffHunk": "@@ -490,6 +490,29 @@ public Integer processBroadcast(Object outgoing, Supplier<Integer> supplier) {\n         return null;\n     }\n \n+    public void validateBlocking(ValidationOutput validationOutput) {\n+        if (!(validationOutput.production.equals(MediatorConfiguration.Production.INDIVIDUAL_MESSAGE)\n+                || validationOutput.production.equals(MediatorConfiguration.Production.INDIVIDUAL_PAYLOAD)\n+                || validationOutput.production.equals(MediatorConfiguration.Production.NONE))) {\n+            throw getBlockingError(\"The @Blocking annotation is only supported for methods returning Message or a payload\");\n+        }\n+\n+        if (!(validationOutput.consumption.equals(MediatorConfiguration.Consumption.MESSAGE)\n+                || validationOutput.consumption.equals(MediatorConfiguration.Consumption.PAYLOAD)\n+                || validationOutput.consumption.equals(MediatorConfiguration.Consumption.NONE))) {\n+            throw getBlockingError(\n+                    \"The @Blocking annotation is only supported for methods with parameters of Message or a payload\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5MDM4NQ==", "bodyText": "You need to also check for Uni.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399090385", "createdAt": "2020-03-27T08:01:05Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/MediatorConfigurationSupport.java", "diffHunk": "@@ -490,6 +490,29 @@ public Integer processBroadcast(Object outgoing, Supplier<Integer> supplier) {\n         return null;\n     }\n \n+    public void validateBlocking(ValidationOutput validationOutput) {\n+        if (!(validationOutput.production.equals(MediatorConfiguration.Production.INDIVIDUAL_MESSAGE)\n+                || validationOutput.production.equals(MediatorConfiguration.Production.INDIVIDUAL_PAYLOAD)\n+                || validationOutput.production.equals(MediatorConfiguration.Production.NONE))) {\n+            throw getBlockingError(\"The @Blocking annotation is only supported for methods returning Message or a payload\");\n+        }\n+\n+        if (!(validationOutput.consumption.equals(MediatorConfiguration.Consumption.MESSAGE)\n+                || validationOutput.consumption.equals(MediatorConfiguration.Consumption.PAYLOAD)\n+                || validationOutput.consumption.equals(MediatorConfiguration.Consumption.NONE))) {\n+            throw getBlockingError(\n+                    \"The @Blocking annotation is only supported for methods with parameters of Message or a payload\");\n+        }\n+\n+        if (ClassUtils.isAssignable(returnType, CompletionStage.class)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5MTg0Nw==", "bodyText": "We may want to refactor and extract this code as it's now duplicated a few times. It can be done in another PR.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399091847", "createdAt": "2020-03-27T08:04:39Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/SubscriberMediator.java", "diffHunk": "@@ -127,20 +127,36 @@ public void onComplete() {\n     }\n \n     private void processMethodReturningVoid() {\n-        this.subscriber = ReactiveStreams.<Message<?>> builder()\n-                .flatMapCompletionStage(managePreProcessingAck())\n-                .map(message -> {\n-                    invoke(message.getPayload());\n-                    return message;\n-                })\n-                .flatMapCompletionStage(x -> {\n-                    if (configuration.getAcknowledgment() == Acknowledgment.Strategy.POST_PROCESSING) {\n-                        return getAckOrCompletion(x);\n-                    } else {\n-                        return CompletableFuture.completedFuture(x);\n-                    }\n-                })\n-                .ignore();\n+        if (configuration.isBlocking()) {\n+            this.subscriber = ReactiveStreams.<Message<?>> builder()\n+                    .flatMapCompletionStage(managePreProcessingAck())\n+                    .flatMapCompletionStage(message -> ((Uni<?>) invokeBlocking(message.getPayload()))\n+                            .subscribeAsCompletionStage()\n+                            .thenApply(x -> message))\n+                    .flatMapCompletionStage(x -> {\n+                        if (configuration.getAcknowledgment() == Acknowledgment.Strategy.POST_PROCESSING) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5Mjc1Mg==", "bodyText": "This should have been tested before (I've added a comment about this case).", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399092752", "createdAt": "2020-03-27T08:06:59Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/PublisherMediator.java", "diffHunk": "@@ -110,17 +110,33 @@ private void produceAPublisherOfMessages() {\n     }\n \n     private void produceIndividualMessages() {\n-        setPublisher(ReactiveStreams.generate(() -> {\n-            Message message = invoke();\n-            Objects.requireNonNull(message,\n-                    \"The method \" + configuration.methodAsString() + \" returned an invalid value: null\");\n-            return message;\n-        }));\n+        if (configuration.isBlocking()) {\n+            setPublisher(ReactiveStreams.<Uni<?>> generate(this::invokeBlocking)\n+                    .flatMapCompletionStage(Uni::subscribeAsCompletionStage)\n+                    .map(message -> {\n+                        Objects.requireNonNull(message,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NDUxOA==", "bodyText": "There is a bug here. It may have been there before.\nPOST_PROCESSING acknowledgment is not handled correctly (well not handled at all).", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399094518", "createdAt": "2020-03-27T08:11:13Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/ProcessorMediator.java", "diffHunk": "@@ -234,44 +234,92 @@ private void processMethodReturningAPublisherOfPayloadsAndConsumingPayloads() {\n     private void processMethodReturningIndividualMessageAndConsumingIndividualItem() {\n         // Item can be message or payload\n         if (configuration.consumption() == MediatorConfiguration.Consumption.PAYLOAD) {\n-            this.processor = ReactiveStreams.<Message> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message) invoke(input.getPayload()))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input.getPayload()))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message) result))\n+                        .buildRs();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NDk5MA==", "bodyText": "Same here.\nPOST_PROCESSING acknowledgment is not handled.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399094990", "createdAt": "2020-03-27T08:12:14Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/ProcessorMediator.java", "diffHunk": "@@ -234,44 +234,92 @@ private void processMethodReturningAPublisherOfPayloadsAndConsumingPayloads() {\n     private void processMethodReturningIndividualMessageAndConsumingIndividualItem() {\n         // Item can be message or payload\n         if (configuration.consumption() == MediatorConfiguration.Consumption.PAYLOAD) {\n-            this.processor = ReactiveStreams.<Message> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message) invoke(input.getPayload()))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input.getPayload()))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message) result))\n+                        .buildRs();\n+            } else {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .map(input -> (Message) invoke(input.getPayload()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NTE2MQ==", "bodyText": "POST_PROCESSING acknowledgment is not handled correctly", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399095161", "createdAt": "2020-03-27T08:12:35Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/ProcessorMediator.java", "diffHunk": "@@ -234,44 +234,92 @@ private void processMethodReturningAPublisherOfPayloadsAndConsumingPayloads() {\n     private void processMethodReturningIndividualMessageAndConsumingIndividualItem() {\n         // Item can be message or payload\n         if (configuration.consumption() == MediatorConfiguration.Consumption.PAYLOAD) {\n-            this.processor = ReactiveStreams.<Message> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message) invoke(input.getPayload()))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input.getPayload()))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message) result))\n+                        .buildRs();\n+            } else {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .map(input -> (Message) invoke(input.getPayload()))\n+                        .buildRs();\n+            }\n         } else {\n-            this.processor = ReactiveStreams.<Message> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message) invoke(input))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message) result))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NTE4Ng==", "bodyText": "POST_PROCESSING acknowledgment is not handled correctly", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399095186", "createdAt": "2020-03-27T08:12:40Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/ProcessorMediator.java", "diffHunk": "@@ -234,44 +234,92 @@ private void processMethodReturningAPublisherOfPayloadsAndConsumingPayloads() {\n     private void processMethodReturningIndividualMessageAndConsumingIndividualItem() {\n         // Item can be message or payload\n         if (configuration.consumption() == MediatorConfiguration.Consumption.PAYLOAD) {\n-            this.processor = ReactiveStreams.<Message> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message) invoke(input.getPayload()))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input.getPayload()))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message) result))\n+                        .buildRs();\n+            } else {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .map(input -> (Message) invoke(input.getPayload()))\n+                        .buildRs();\n+            }\n         } else {\n-            this.processor = ReactiveStreams.<Message> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message) invoke(input))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message) result))\n+                        .buildRs();\n+            } else {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .map(input -> (Message) invoke(input))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NjcwOA==", "bodyText": "I would remove the @Incomings", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399096708", "createdAt": "2020-03-27T08:16:08Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/WorkerPoolRegistry.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.spi.AnnotatedMethod;\n+import javax.enterprise.inject.spi.AnnotatedType;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+import io.smallrye.reactive.messaging.annotations.Incomings;\n+import io.smallrye.reactive.messaging.helpers.Validation;\n+import io.vertx.core.Handler;\n+import io.vertx.mutiny.core.Promise;\n+import io.vertx.mutiny.core.WorkerExecutor;\n+\n+@ApplicationScoped\n+public class WorkerPoolRegistry {\n+    private static final String WORKER_CONFIG_PREFIX = \"smallrye.messaging.worker\";\n+    private static final String WORKER_CONCURRENCY = \"max-concurrency\";\n+\n+    @Inject\n+    private ExecutionHolder executionHolder;\n+\n+    @Inject\n+    private Instance<Config> configInstance;\n+\n+    private Map<String, Integer> workerDefinitions = new HashMap<>();\n+    private Map<String, WorkerExecutor> workerExecutors = new ConcurrentHashMap<>();\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(100) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        if (!workerExecutors.isEmpty()) {\n+            for (WorkerExecutor executor : workerExecutors.values()) {\n+                executor.close();\n+            }\n+        }\n+    }\n+\n+    public <T> Uni<T> executeWork(Handler<Promise<T>> blockingCodeHandler, String workerName, boolean ordered) {\n+        Objects.requireNonNull(blockingCodeHandler, \"Code to execute not provided\");\n+\n+        if (workerName == null) {\n+            return executionHolder.vertx().executeBlocking(blockingCodeHandler, ordered);\n+        } else {\n+            return getWorker(workerName).executeBlocking(blockingCodeHandler, ordered);\n+        }\n+    }\n+\n+    private WorkerExecutor getWorker(String workerName) {\n+        Objects.requireNonNull(workerName, \"Worker Name not specified\");\n+\n+        if (workerExecutors.containsKey(workerName)) {\n+            return workerExecutors.get(workerName);\n+        }\n+        if (workerDefinitions.containsKey(workerName)) {\n+            WorkerExecutor executor = executionHolder.vertx().createSharedWorkerExecutor(workerName,\n+                    workerDefinitions.get(workerName));\n+            if (executor != null) {\n+                workerExecutors.put(workerName, executor);\n+                return executor;\n+            } else {\n+                throw new RuntimeException(\"Failed to create Worker for \" + workerName);\n+            }\n+        }\n+\n+        // Shouldn't get here\n+        throw new IllegalArgumentException(\"@Blocking referred to invalid worker name.\");\n+    }\n+\n+    public <T> void analyzeWorker(AnnotatedType<T> annotatedType) {\n+        Objects.requireNonNull(annotatedType, \"AnnotatedType was empty\");\n+\n+        Set<AnnotatedMethod<? super T>> methods = annotatedType.getMethods();\n+\n+        methods.stream()\n+                .filter(m -> m.isAnnotationPresent(Blocking.class))\n+                .forEach(m -> addWorker(m.getJavaMember()));\n+    }\n+\n+    private void addWorker(Method method) {\n+        Objects.requireNonNull(method, \"Method was empty\");\n+\n+        Blocking blocking = method.getAnnotation(Blocking.class);\n+\n+        // Validate @Blocking is used in conjunction with @Incomings, @Incoming, or @Outgoing\n+        if (!(method.isAnnotationPresent(Incomings.class) || method.isAnnotationPresent(Incoming.class)\n+                || method.isAnnotationPresent(Outgoing.class))) {\n+            throw getBlockingError(method, \"no @Incomings, @Incoming, or @Outgoing present\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NzEwNw==", "bodyText": "Maybe a log message (info) indicating the that the worker pool has been created with concurrency x", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399097107", "createdAt": "2020-03-27T08:16:59Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/WorkerPoolRegistry.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.spi.AnnotatedMethod;\n+import javax.enterprise.inject.spi.AnnotatedType;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+import io.smallrye.reactive.messaging.annotations.Incomings;\n+import io.smallrye.reactive.messaging.helpers.Validation;\n+import io.vertx.core.Handler;\n+import io.vertx.mutiny.core.Promise;\n+import io.vertx.mutiny.core.WorkerExecutor;\n+\n+@ApplicationScoped\n+public class WorkerPoolRegistry {\n+    private static final String WORKER_CONFIG_PREFIX = \"smallrye.messaging.worker\";\n+    private static final String WORKER_CONCURRENCY = \"max-concurrency\";\n+\n+    @Inject\n+    private ExecutionHolder executionHolder;\n+\n+    @Inject\n+    private Instance<Config> configInstance;\n+\n+    private Map<String, Integer> workerDefinitions = new HashMap<>();\n+    private Map<String, WorkerExecutor> workerExecutors = new ConcurrentHashMap<>();\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(100) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        if (!workerExecutors.isEmpty()) {\n+            for (WorkerExecutor executor : workerExecutors.values()) {\n+                executor.close();\n+            }\n+        }\n+    }\n+\n+    public <T> Uni<T> executeWork(Handler<Promise<T>> blockingCodeHandler, String workerName, boolean ordered) {\n+        Objects.requireNonNull(blockingCodeHandler, \"Code to execute not provided\");\n+\n+        if (workerName == null) {\n+            return executionHolder.vertx().executeBlocking(blockingCodeHandler, ordered);\n+        } else {\n+            return getWorker(workerName).executeBlocking(blockingCodeHandler, ordered);\n+        }\n+    }\n+\n+    private WorkerExecutor getWorker(String workerName) {\n+        Objects.requireNonNull(workerName, \"Worker Name not specified\");\n+\n+        if (workerExecutors.containsKey(workerName)) {\n+            return workerExecutors.get(workerName);\n+        }\n+        if (workerDefinitions.containsKey(workerName)) {\n+            WorkerExecutor executor = executionHolder.vertx().createSharedWorkerExecutor(workerName,\n+                    workerDefinitions.get(workerName));\n+            if (executor != null) {\n+                workerExecutors.put(workerName, executor);\n+                return executor;\n+            } else {\n+                throw new RuntimeException(\"Failed to create Worker for \" + workerName);\n+            }\n+        }\n+\n+        // Shouldn't get here\n+        throw new IllegalArgumentException(\"@Blocking referred to invalid worker name.\");\n+    }\n+\n+    public <T> void analyzeWorker(AnnotatedType<T> annotatedType) {\n+        Objects.requireNonNull(annotatedType, \"AnnotatedType was empty\");\n+\n+        Set<AnnotatedMethod<? super T>> methods = annotatedType.getMethods();\n+\n+        methods.stream()\n+                .filter(m -> m.isAnnotationPresent(Blocking.class))\n+                .forEach(m -> addWorker(m.getJavaMember()));\n+    }\n+\n+    private void addWorker(Method method) {\n+        Objects.requireNonNull(method, \"Method was empty\");\n+\n+        Blocking blocking = method.getAnnotation(Blocking.class);\n+\n+        // Validate @Blocking is used in conjunction with @Incomings, @Incoming, or @Outgoing\n+        if (!(method.isAnnotationPresent(Incomings.class) || method.isAnnotationPresent(Incoming.class)\n+                || method.isAnnotationPresent(Outgoing.class))) {\n+            throw getBlockingError(method, \"no @Incomings, @Incoming, or @Outgoing present\");\n+        }\n+\n+        if (!blocking.value().equals(Blocking.NO_VALUE)) {\n+            // Validate @Blocking value is not empty, if set\n+            if (Validation.isBlank(blocking.value())) {\n+                throw getBlockingError(method, \"value is blank or null\");\n+            }\n+\n+            // Validate @Blocking worker pool has configuration to define concurrency\n+            String workerConfigKey = WORKER_CONFIG_PREFIX + \".\" + blocking.value() + \".\" + WORKER_CONCURRENCY;\n+            Optional<Integer> concurrency = configInstance.get().getOptionalValue(workerConfigKey, Integer.class);\n+            if (!concurrency.isPresent()) {\n+                throw getBlockingError(method, workerConfigKey + \" was not defined\");\n+            }\n+\n+            workerDefinitions.put(blocking.value(), concurrency.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NzM2MA==", "bodyText": "Don't we have this method somewhere else?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399097360", "createdAt": "2020-03-27T08:17:30Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/WorkerPoolRegistry.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.spi.AnnotatedMethod;\n+import javax.enterprise.inject.spi.AnnotatedType;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+import io.smallrye.reactive.messaging.annotations.Incomings;\n+import io.smallrye.reactive.messaging.helpers.Validation;\n+import io.vertx.core.Handler;\n+import io.vertx.mutiny.core.Promise;\n+import io.vertx.mutiny.core.WorkerExecutor;\n+\n+@ApplicationScoped\n+public class WorkerPoolRegistry {\n+    private static final String WORKER_CONFIG_PREFIX = \"smallrye.messaging.worker\";\n+    private static final String WORKER_CONCURRENCY = \"max-concurrency\";\n+\n+    @Inject\n+    private ExecutionHolder executionHolder;\n+\n+    @Inject\n+    private Instance<Config> configInstance;\n+\n+    private Map<String, Integer> workerDefinitions = new HashMap<>();\n+    private Map<String, WorkerExecutor> workerExecutors = new ConcurrentHashMap<>();\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(100) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        if (!workerExecutors.isEmpty()) {\n+            for (WorkerExecutor executor : workerExecutors.values()) {\n+                executor.close();\n+            }\n+        }\n+    }\n+\n+    public <T> Uni<T> executeWork(Handler<Promise<T>> blockingCodeHandler, String workerName, boolean ordered) {\n+        Objects.requireNonNull(blockingCodeHandler, \"Code to execute not provided\");\n+\n+        if (workerName == null) {\n+            return executionHolder.vertx().executeBlocking(blockingCodeHandler, ordered);\n+        } else {\n+            return getWorker(workerName).executeBlocking(blockingCodeHandler, ordered);\n+        }\n+    }\n+\n+    private WorkerExecutor getWorker(String workerName) {\n+        Objects.requireNonNull(workerName, \"Worker Name not specified\");\n+\n+        if (workerExecutors.containsKey(workerName)) {\n+            return workerExecutors.get(workerName);\n+        }\n+        if (workerDefinitions.containsKey(workerName)) {\n+            WorkerExecutor executor = executionHolder.vertx().createSharedWorkerExecutor(workerName,\n+                    workerDefinitions.get(workerName));\n+            if (executor != null) {\n+                workerExecutors.put(workerName, executor);\n+                return executor;\n+            } else {\n+                throw new RuntimeException(\"Failed to create Worker for \" + workerName);\n+            }\n+        }\n+\n+        // Shouldn't get here\n+        throw new IllegalArgumentException(\"@Blocking referred to invalid worker name.\");\n+    }\n+\n+    public <T> void analyzeWorker(AnnotatedType<T> annotatedType) {\n+        Objects.requireNonNull(annotatedType, \"AnnotatedType was empty\");\n+\n+        Set<AnnotatedMethod<? super T>> methods = annotatedType.getMethods();\n+\n+        methods.stream()\n+                .filter(m -> m.isAnnotationPresent(Blocking.class))\n+                .forEach(m -> addWorker(m.getJavaMember()));\n+    }\n+\n+    private void addWorker(Method method) {\n+        Objects.requireNonNull(method, \"Method was empty\");\n+\n+        Blocking blocking = method.getAnnotation(Blocking.class);\n+\n+        // Validate @Blocking is used in conjunction with @Incomings, @Incoming, or @Outgoing\n+        if (!(method.isAnnotationPresent(Incomings.class) || method.isAnnotationPresent(Incoming.class)\n+                || method.isAnnotationPresent(Outgoing.class))) {\n+            throw getBlockingError(method, \"no @Incomings, @Incoming, or @Outgoing present\");\n+        }\n+\n+        if (!blocking.value().equals(Blocking.NO_VALUE)) {\n+            // Validate @Blocking value is not empty, if set\n+            if (Validation.isBlank(blocking.value())) {\n+                throw getBlockingError(method, \"value is blank or null\");\n+            }\n+\n+            // Validate @Blocking worker pool has configuration to define concurrency\n+            String workerConfigKey = WORKER_CONFIG_PREFIX + \".\" + blocking.value() + \".\" + WORKER_CONCURRENCY;\n+            Optional<Integer> concurrency = configInstance.get().getOptionalValue(workerConfigKey, Integer.class);\n+            if (!concurrency.isPresent()) {\n+                throw getBlockingError(method, workerConfigKey + \" was not defined\");\n+            }\n+\n+            workerDefinitions.put(blocking.value(), concurrency.get());\n+        }\n+    }\n+\n+    private IllegalArgumentException getBlockingError(Method method, String message) {\n+        return new IllegalArgumentException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMDkzNw==", "bodyText": "Need to also test when the method returns an Uni", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399100937", "createdAt": "2020-03-27T08:25:09Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/test/java/io/smallrye/reactive/messaging/blocking/InvalidBlockingProcessorShapeTest.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package io.smallrye.reactive.messaging.blocking;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.spi.DeploymentException;\n+\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.eclipse.microprofile.reactive.streams.operators.ProcessorBuilder;\n+import org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder;\n+import org.eclipse.microprofile.reactive.streams.operators.ReactiveStreams;\n+import org.junit.Test;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.Flowable;\n+import io.smallrye.reactive.messaging.WeldTestBaseWithoutTails;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+\n+public class InvalidBlockingProcessorShapeTest extends WeldTestBaseWithoutTails {\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingACompletionStageOfMessage() {\n+        addBeanClass(BeanProducingACompletionStageOfMessage.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingACompletionStageOfMessage {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public CompletionStage<Message<String>> process(Message<Integer> value) {\n+            return CompletableFuture.supplyAsync(() -> Integer.toString(value.getPayload() + 1))\n+                    .thenApply(Message::of);\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMTIzNA==", "bodyText": "I would add specific tests for Multi.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399101234", "createdAt": "2020-03-27T08:25:45Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/test/java/io/smallrye/reactive/messaging/blocking/InvalidBlockingProcessorShapeTest.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package io.smallrye.reactive.messaging.blocking;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.spi.DeploymentException;\n+\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.eclipse.microprofile.reactive.streams.operators.ProcessorBuilder;\n+import org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder;\n+import org.eclipse.microprofile.reactive.streams.operators.ReactiveStreams;\n+import org.junit.Test;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.Flowable;\n+import io.smallrye.reactive.messaging.WeldTestBaseWithoutTails;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+\n+public class InvalidBlockingProcessorShapeTest extends WeldTestBaseWithoutTails {\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingACompletionStageOfMessage() {\n+        addBeanClass(BeanProducingACompletionStageOfMessage.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingACompletionStageOfMessage {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public CompletionStage<Message<String>> process(Message<Integer> value) {\n+            return CompletableFuture.supplyAsync(() -> Integer.toString(value.getPayload() + 1))\n+                    .thenApply(Message::of);\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingACompletionStageOfPayloads() {\n+        addBeanClass(BeanProducingACompletionStage.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingACompletionStage {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public CompletionStage<String> process(int value) {\n+            return CompletableFuture.supplyAsync(() -> Integer.toString(value + 1));\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingACompletableFutureOfMessage() {\n+        addBeanClass(BeanProducingACompletableFutureOfMessage.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingACompletableFutureOfMessage {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public CompletionStage<Message<String>> process(Message<Integer> value) {\n+            return CompletableFuture.supplyAsync(() -> Integer.toString(value.getPayload() + 1))\n+                    .thenApply(Message::of);\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingACompletableFutureOfPayloads() {\n+        addBeanClass(BeanProducingACompletableFuture.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingACompletableFuture {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public CompletableFuture<String> process(int value) {\n+            return CompletableFuture.supplyAsync(() -> Integer.toString(value + 1));\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingAProcessorOfMessages() {\n+        addBeanClass(BeanProducingAProcessorOfMessages.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingAProcessorOfMessages {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public Processor<Message<Integer>, Message<String>> process() {\n+            return ReactiveStreams.<Message<Integer>> builder()\n+                    .map(Message::getPayload)\n+                    .map(i -> i + 1)\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i))\n+                    .map(Message::of)\n+                    .buildRs();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingAProcessorBuilderOfMessages() {\n+        addBeanClass(BeanProducingAProcessorBuilderOfMessages.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingAProcessorBuilderOfMessages {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public ProcessorBuilder<Message<Integer>, Message<String>> process() {\n+            return ReactiveStreams.<Message<Integer>> builder()\n+                    .map(Message::getPayload)\n+                    .map(i -> i + 1)\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i))\n+                    .map(Message::of);\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingAProcessorOfPayloads() {\n+        addBeanClass(BeanProducingAProcessorOfPayloads.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingAProcessorOfPayloads {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public Processor<Integer, String> process() {\n+            return ReactiveStreams.<Integer> builder()\n+                    .map(i -> i + 1)\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i))\n+                    .buildRs();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingAProcessorBuilderOfPayloads() {\n+        addBeanClass(BeanProducingAProcessorBuilderOfPayloads.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingAProcessorBuilderOfPayloads {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public ProcessorBuilder<Integer, String> process() {\n+            return ReactiveStreams.<Integer> builder()\n+                    .map(i -> i + 1)\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i));\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingAPublisherOfMessagesAndConsumingIndividualMessage() {\n+        addBeanClass(BeanProducingAPublisherOfMessagesAndConsumingIndividualMessage.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingAPublisherOfMessagesAndConsumingIndividualMessage {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public Publisher<Message<String>> process(Message<Integer> message) {\n+            return ReactiveStreams.of(message)\n+                    .map(Message::getPayload)\n+                    .map(i -> i + 1)\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i))\n+                    .map(Message::of)\n+                    .buildRs();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingAPublisherOfPayloadsAndConsumingIndividualPayload() {\n+        addBeanClass(BeanProducingAPublisherOfPayloadsAndConsumingIndividualPayload.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingAPublisherOfPayloadsAndConsumingIndividualPayload {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public Publisher<String> process(Integer payload) {\n+            return ReactiveStreams.of(payload)\n+                    .map(i -> i + 1)\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i))\n+                    .buildRs();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingAPublisherBuilderOfPayloadsAndConsumingIndividualPayload() {\n+        addBeanClass(BeanProducingAPublisherBuilderOfPayloadsAndConsumingIndividualPayload.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingAPublisherBuilderOfPayloadsAndConsumingIndividualPayload {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public PublisherBuilder<String> process(Integer payload) {\n+            return ReactiveStreams.of(payload)\n+                    .map(i -> i + 1)\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i));\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingAPublisherBuilderOfMessagesAndConsumingIndividualMessage() {\n+        addBeanClass(BeanProducingAPublisherBuilderOfMessagesAndConsumingIndividualMessage.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingAPublisherBuilderOfMessagesAndConsumingIndividualMessage {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public PublisherBuilder<Message<String>> process(Message<Integer> message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMTYyNg==", "bodyText": "Would need tests with Unis", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399101626", "createdAt": "2020-03-27T08:26:31Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/test/java/io/smallrye/reactive/messaging/blocking/InvalidBlockingPublisherShapeTest.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package io.smallrye.reactive.messaging.blocking;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.spi.DeploymentException;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder;\n+import org.eclipse.microprofile.reactive.streams.operators.ReactiveStreams;\n+import org.junit.Test;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.Flowable;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.reactive.messaging.WeldTestBaseWithoutTails;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+\n+public class InvalidBlockingPublisherShapeTest extends WeldTestBaseWithoutTails {\n+    @Test(expected = DeploymentException.class)\n+    public void testPublisherOfMessages() {\n+        addBeanClass(BeanReturningAPublisherOfMessages.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanReturningAPublisherOfMessages {\n+        @Blocking\n+        @Outgoing(\"sink\")\n+        public Publisher<Message<String>> create() {\n+            return ReactiveStreams.of(\"a\", \"b\", \"c\").map(Message::of).buildRs();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testPublisherOfMessagesWithMulti() {\n+        addBeanClass(BeanProducingMessagesAsMulti.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingMessagesAsMulti {\n+        @Blocking\n+        @Outgoing(\"sink\")\n+        public Multi<Message<String>> publisher() {\n+            return Multi.createFrom().range(1, 11).flatMap(i -> Flowable.just(i, i)).map(i -> Integer.toString(i))\n+                    .map(Message::of);\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testProducingPayloadsAsMulti() {\n+        addBeanClass(BeanProducingPayloadAsMulti.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingPayloadAsMulti {\n+        @Blocking\n+        @Outgoing(\"sink\")\n+        public Multi<String> publisher() {\n+            return Multi.createFrom().range(1, 11).flatMap(i -> Flowable.just(i, i)).map(i -> Integer.toString(i));\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testProducingPayloadsAsPublisher() {\n+        addBeanClass(BeanProducingPayloadAsPublisher.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingPayloadAsPublisher {\n+        @Blocking\n+        @Outgoing(\"sink\")\n+        public Publisher<String> publisher() {\n+            return Flowable.range(1, 10).flatMap(i -> Flowable.just(i, i)).map(i -> Integer.toString(i));\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testProducingMessagesAsPublisherBuilder() {\n+        addBeanClass(BeanProducingMessagesAsPublisherBuilder.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingMessagesAsPublisherBuilder {\n+        @Blocking\n+        @Outgoing(\"sink\")\n+        public PublisherBuilder<Message<String>> publisher() {\n+            return ReactiveStreams.fromPublisher(Flowable.range(1, 10))\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i))\n+                    .map(Message::of);\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testProducingPayloadAsPublisherBuilder() {\n+        addBeanClass(BeanProducingPayloadAsPublisherBuilder.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingPayloadAsPublisherBuilder {\n+        @Blocking\n+        @Outgoing(\"sink\")\n+        public PublisherBuilder<String> publisher() {\n+            return ReactiveStreams.fromPublisher(Flowable.range(1, 10))\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i));\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testProduceCompletionStageOfMessage() {\n+        addBeanClass(BeanReturningCompletionStageOfMessage.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanReturningCompletionStageOfMessage {\n+        private AtomicInteger count = new AtomicInteger();\n+        private ExecutorService executor = Executors.newSingleThreadExecutor();\n+\n+        @Blocking\n+        @Outgoing(\"infinite-producer\")\n+        public CompletionStage<Message<Integer>> create() {\n+            return CompletableFuture.supplyAsync(() -> Message.of(count.incrementAndGet()), executor);\n+        }\n+\n+        @PreDestroy\n+        public void cleanup() {\n+            executor.shutdown();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testProduceCompletionStageOfPayload() {\n+        addBeanClass(BeanReturningCompletionStageOfPayload.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanReturningCompletionStageOfPayload {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMTk1NA==", "bodyText": "Need the same with Uni.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399101954", "createdAt": "2020-03-27T08:27:13Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/test/java/io/smallrye/reactive/messaging/blocking/InvalidBlockingSubscriberShapeTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package io.smallrye.reactive.messaging.blocking;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.spi.DeploymentException;\n+\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.streams.operators.ReactiveStreams;\n+import org.junit.Test;\n+import org.reactivestreams.Subscriber;\n+\n+import io.smallrye.reactive.messaging.WeldTestBaseWithoutTails;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+\n+public class InvalidBlockingSubscriberShapeTest extends WeldTestBaseWithoutTails {\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingASubscriberOfMessages() {\n+        addBeanClass(BeanReturningASubscriberOfMessages.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanReturningASubscriberOfMessages {\n+        private List<String> list = new ArrayList<>();\n+\n+        @Blocking\n+        @Incoming(\"count\")\n+        public Subscriber<Message<String>> create() {\n+            return ReactiveStreams.<Message<String>> builder().forEach(m -> list.add(m.getPayload()))\n+                    .build();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingASubscriberOfPayloads() {\n+        addBeanClass(BeanReturningASubscriberOfPayloads.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanReturningASubscriberOfPayloads {\n+        private List<String> list = new ArrayList<>();\n+\n+        @Blocking\n+        @Incoming(\"count\")\n+        public Subscriber<String> create() {\n+            return ReactiveStreams.<String> builder().forEach(m -> list.add(m)).build();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testThatWeCanProduceSubscriberOfMessage() {\n+        addBeanClass(BeanReturningASubscriberOfMessagesButDiscarding.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanReturningASubscriberOfMessagesButDiscarding {\n+        @Blocking\n+        @Incoming(\"subscriber\")\n+        public Subscriber<Message<String>> create() {\n+            return ReactiveStreams.<Message<String>> builder()\n+                    .ignore().build();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testThatWeCanConsumeMessagesFromAMethodReturningACompletionStage() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMjM2Nw==", "bodyText": "I would actually do something really blocking to check the concurrency.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399102367", "createdAt": "2020-03-27T08:28:00Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/test/java/io/smallrye/reactive/messaging/blocking/beans/BeanReturningPayloads.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package io.smallrye.reactive.messaging.blocking.beans;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+\n+@ApplicationScoped\n+public class BeanReturningPayloads {\n+    private AtomicInteger count = new AtomicInteger();\n+    private List<String> threads = new CopyOnWriteArrayList<>();\n+\n+    @Blocking\n+    @Outgoing(\"infinite-producer\")\n+    public int create() {\n+        threads.add(Thread.currentThread().getName());\n+        return count.incrementAndGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMzY0Mg==", "bodyText": "So it makes the hypothesis that the processing is synchronous/blocking? Or priority cannot be enforced right?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399103642", "createdAt": "2020-03-27T08:30:38Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConnector.java", "diffHunk": "@@ -39,26 +41,17 @@\n     private List<KafkaSource> sources = new CopyOnWriteArrayList<>();\n     private List<KafkaSink> sinks = new CopyOnWriteArrayList<>();\n \n-    private boolean internalVertxInstance = false;\n     private Vertx vertx;\n \n-    public void terminate(@Observes @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(50) @BeforeDestroyed(ApplicationScoped.class) Object event) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkwODE4NQ=="}, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMzgyNA==", "bodyText": "With the priority thingy this should not be required anymore.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399103824", "createdAt": "2020-03-27T08:31:02Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -98,7 +98,7 @@ public KafkaSource(Vertx vertx, Config config, String servers) {\n \n     public void closeQuietly() {\n         try {\n-            this.consumer.closeAndAwait();\n+            this.consumer.closeAndForget();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwNDEzOA==", "bodyText": "With the @priority, this should not be required anymore.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399104138", "createdAt": "2020-03-27T08:31:41Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-mqtt-server/src/main/java/io/smallrye/reactive/messaging/mqtt/server/MqttServerSource.java", "diffHunk": "@@ -144,11 +144,7 @@ private static MqttServerOptions mqttServerOptions(Config config) {\n     }\n \n     synchronized void close() {\n-        mqttServer.close()\n-                .onFailure().invoke(t -> logger.warn(\"An exception has been caught while closing the MQTT server\", t))\n-                .onItem().invoke(x -> logger.debug(\"MQTT server closed\"))\n-                .onFailure().recoverWithItem((Void) null)\n-                .await().indefinitely();\n+        mqttServer.closeAndForget();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9d16f3f3ec06b2aac128f20cf29c3f0d21f94ad", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/f9d16f3f3ec06b2aac128f20cf29c3f0d21f94ad", "committedDate": "2020-03-30T17:37:27Z", "message": "Fixes #79 - Implement @Blocking support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "491b1eb5fccf0756ae1b75b9985eff88f5066d26", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/491b1eb5fccf0756ae1b75b9985eff88f5066d26", "committedDate": "2020-03-30T17:54:02Z", "message": "Fix shutdown sequence order and tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cd1087cdab18d4368d5ababe870bb19e2b1c68c", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/5cd1087cdab18d4368d5ababe870bb19e2b1c68c", "committedDate": "2020-03-30T17:55:34Z", "message": "Add tests for Processors and Publishers, and fix issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "557533db96955d1cd81251f283e49aec73605a88", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/557533db96955d1cd81251f283e49aec73605a88", "committedDate": "2020-03-30T17:57:13Z", "message": "Updates based on PR feedback/comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1eac422c4d903c33cb24c8c95a8194139102f936", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/1eac422c4d903c33cb24c8c95a8194139102f936", "committedDate": "2020-03-30T18:17:07Z", "message": "Minor updates based on the recently merged cleanup PR"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/3097a3edb97e4974281cbfb363d3824f4359ee59", "committedDate": "2020-03-26T21:00:12Z", "message": "Add tests for Processors and Publishers, and fix issues"}, "afterCommit": {"oid": "1eac422c4d903c33cb24c8c95a8194139102f936", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/1eac422c4d903c33cb24c8c95a8194139102f936", "committedDate": "2020-03-30T18:17:07Z", "message": "Minor updates based on the recently merged cleanup PR"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1ODkyNzkx", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#pullrequestreview-385892791", "createdAt": "2020-04-01T19:40:07Z", "commit": {"oid": "1eac422c4d903c33cb24c8c95a8194139102f936"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTo0MDowN1rOF_Pxww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDowMjo1N1rOF_QjwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2MzEwNw==", "bodyText": "Could you remove the @Incomings", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401863107", "createdAt": "2020-04-01T19:40:07Z", "author": {"login": "cescoffier"}, "path": "documentation/src/main/doc/modules/ROOT/pages/advanced/blocking.adoc", "diffHunk": "@@ -0,0 +1,50 @@\n+== @Blocking\n+\n+The `@Blocking` annotation can be used on a method annotated with `@Incomings`, `@Incoming`,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eac422c4d903c33cb24c8c95a8194139102f936"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2Mzc2Ng==", "bodyText": "Can you change the title to Handling blocking execution or something like this.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401863766", "createdAt": "2020-04-01T19:41:19Z", "author": {"login": "cescoffier"}, "path": "documentation/src/main/doc/modules/ROOT/nav.adoc", "diffHunk": "@@ -20,6 +20,7 @@\n ** xref:advanced/broadcast.adoc[Broadcasting]\n ** xref:advanced/merge.adoc[Merging]\n ** xref:advanced/incomings.adoc[Multiple @Incoming]\n+** xref:advanced/blocking.adoc[@Blocking]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eac422c4d903c33cb24c8c95a8194139102f936"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2NTg4Ng==", "bodyText": "Why the  close has been removing?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401865886", "createdAt": "2020-04-01T19:44:54Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-amqp/src/test/java/io/smallrye/reactive/messaging/amqp/AmqpSinkTest.java", "diffHunk": "@@ -33,7 +33,6 @@\n     @After\n     public void cleanup() {\n         if (provider != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eac422c4d903c33cb24c8c95a8194139102f936"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2NjE1OA==", "bodyText": "Why has this been removed?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401866158", "createdAt": "2020-04-01T19:45:26Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-amqp/src/test/java/io/smallrye/reactive/messaging/amqp/AmqpSourceTest.java", "diffHunk": "@@ -47,7 +48,6 @@\n     @After\n     public void cleanup() {\n         if (provider != null) {\n-            provider.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eac422c4d903c33cb24c8c95a8194139102f936"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3Mjk5OA==", "bodyText": "Any chance with this?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401872998", "createdAt": "2020-04-01T19:57:34Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/AbstractMediator.java", "diffHunk": "@@ -73,6 +80,21 @@ public void initialize(Object bean) {\n         }\n     }\n \n+    protected <T> Uni<T> invokeBlocking(Object... args) {\n+        try {\n+            Objects.requireNonNull(this.invoker, \"Invoker not initialized\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkxMDA5Mg=="}, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3NDI1Mw==", "bodyText": "Could you add the check?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401874253", "createdAt": "2020-04-01T19:59:50Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/MediatorConfigurationSupport.java", "diffHunk": "@@ -490,6 +490,29 @@ public Integer processBroadcast(Object outgoing, Supplier<Integer> supplier) {\n         return null;\n     }\n \n+    public void validateBlocking(ValidationOutput validationOutput) {\n+        if (!(validationOutput.production.equals(MediatorConfiguration.Production.INDIVIDUAL_MESSAGE)\n+                || validationOutput.production.equals(MediatorConfiguration.Production.INDIVIDUAL_PAYLOAD)\n+                || validationOutput.production.equals(MediatorConfiguration.Production.NONE))) {\n+            throw getBlockingError(\"The @Blocking annotation is only supported for methods returning Message or a payload\");\n+        }\n+\n+        if (!(validationOutput.consumption.equals(MediatorConfiguration.Consumption.MESSAGE)\n+                || validationOutput.consumption.equals(MediatorConfiguration.Consumption.PAYLOAD)\n+                || validationOutput.consumption.equals(MediatorConfiguration.Consumption.NONE))) {\n+            throw getBlockingError(\n+                    \"The @Blocking annotation is only supported for methods with parameters of Message or a payload\");\n+        }\n+\n+        if (ClassUtils.isAssignable(returnType, CompletionStage.class)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5MDM4NQ=="}, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3NDcxMw==", "bodyText": "Can you open an issue?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401874713", "createdAt": "2020-04-01T20:00:42Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/ProcessorMediator.java", "diffHunk": "@@ -234,44 +234,92 @@ private void processMethodReturningAPublisherOfPayloadsAndConsumingPayloads() {\n     private void processMethodReturningIndividualMessageAndConsumingIndividualItem() {\n         // Item can be message or payload\n         if (configuration.consumption() == MediatorConfiguration.Consumption.PAYLOAD) {\n-            this.processor = ReactiveStreams.<Message> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message) invoke(input.getPayload()))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input.getPayload()))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message) result))\n+                        .buildRs();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NDUxOA=="}, "originalCommit": {"oid": "3097a3edb97e4974281cbfb363d3824f4359ee59"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3NTYxNQ==", "bodyText": "We must check that the returned Uni is not null.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401875615", "createdAt": "2020-04-01T20:02:24Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/ProcessorMediator.java", "diffHunk": "@@ -236,44 +245,92 @@ private void processMethodReturningAPublisherOfPayloadsAndConsumingPayloads() {\n     private void processMethodReturningIndividualMessageAndConsumingIndividualItem() {\n         // Item can be message or payload\n         if (configuration.consumption() == MediatorConfiguration.Consumption.PAYLOAD) {\n-            this.processor = ReactiveStreams.<Message<?>> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message<?>) invoke(input.getPayload()))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message<?>> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message<?>> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input.getPayload()))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message<?>) result))\n+                        .buildRs();\n+            } else {\n+                this.processor = ReactiveStreams.<Message<?>> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .map(input -> (Message<?>) invoke(input.getPayload()))\n+                        .buildRs();\n+            }\n         } else {\n-            this.processor = ReactiveStreams.<Message<?>> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message<?>) invoke(input))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message<?>> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message<?>> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eac422c4d903c33cb24c8c95a8194139102f936"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3NTkwNQ==", "bodyText": "we need to verify that result is not null", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401875905", "createdAt": "2020-04-01T20:02:57Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/ProcessorMediator.java", "diffHunk": "@@ -236,44 +245,92 @@ private void processMethodReturningAPublisherOfPayloadsAndConsumingPayloads() {\n     private void processMethodReturningIndividualMessageAndConsumingIndividualItem() {\n         // Item can be message or payload\n         if (configuration.consumption() == MediatorConfiguration.Consumption.PAYLOAD) {\n-            this.processor = ReactiveStreams.<Message<?>> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message<?>) invoke(input.getPayload()))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message<?>> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message<?>> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input.getPayload()))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message<?>) result))\n+                        .buildRs();\n+            } else {\n+                this.processor = ReactiveStreams.<Message<?>> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .map(input -> (Message<?>) invoke(input.getPayload()))\n+                        .buildRs();\n+            }\n         } else {\n-            this.processor = ReactiveStreams.<Message<?>> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message<?>) invoke(input))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message<?>> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message<?>> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message<?>) result))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eac422c4d903c33cb24c8c95a8194139102f936"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MDA2NzM5", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#pullrequestreview-386006739", "createdAt": "2020-04-01T22:59:58Z", "commit": {"oid": "1eac422c4d903c33cb24c8c95a8194139102f936"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMjo1OTo1OFrOF_Vn-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMjo1OTo1OFrOF_Vn-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1ODkwNg==", "bodyText": "For the value, is . allowed as part of the name?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401958906", "createdAt": "2020-04-01T22:59:58Z", "author": {"login": "Emily-Jiang"}, "path": "api/src/main/java/io/smallrye/reactive/messaging/annotations/Blocking.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package io.smallrye.reactive.messaging.annotations;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Identifies that a particular method performs blocking operations,\n+ * and as such should be executed on separate worker.\n+ *\n+ * When possible, the initial threads execution context is _restored_\n+ * once the blocking operation has completed.\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(METHOD)\n+public @interface Blocking {\n+    String DEFAULT_WORKER_POOL = \"<no-value>\";\n+\n+    /**\n+     * Indicates the name of the worker pool to use for execution.\n+     * By default all executions will be performed on the default worker pool.\n+     *\n+     * The maximum concurrency of a custom worker pool can be set with the following configuration key:\n+     * <code>smallrye.messaging.worker.{pool-name}.max-concurrency</code>\n+     *\n+     * @return custom worker pool name for blocking execution.\n+     */\n+    String value() default DEFAULT_WORKER_POOL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eac422c4d903c33cb24c8c95a8194139102f936"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55b4c84d73d1ba592cfed652393d30bf84d470f3", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/55b4c84d73d1ba592cfed652393d30bf84d470f3", "committedDate": "2020-04-02T12:52:55Z", "message": "Updates based on feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NTQ2NTU1", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#pullrequestreview-386546555", "createdAt": "2020-04-02T15:34:07Z", "commit": {"oid": "55b4c84d73d1ba592cfed652393d30bf84d470f3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MDg1MTA1", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#pullrequestreview-387085105", "createdAt": "2020-04-03T09:10:26Z", "commit": {"oid": "55b4c84d73d1ba592cfed652393d30bf84d470f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxMDoyNlrOGANDSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxMDoyNlrOGANDSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2NzAxNg==", "bodyText": "I think the term \"initial threads\" could be a bit confusing for some non-English speakers as the apostrophe is missing and the words are close to \"the initiating thread's context is propogated\". I think it would be better as:\n\"When possible, the context on the worker thread used to execute the method is restored to the context present on the worker thread prior to the method being executed\"    (if you want that meaning).\nOr \"When possible, the context present on the worker thread when the blocking method is run is set to match the context used to run non-blocking methods.\" (if you want that meaning)....and apologies for \"bike shedding\" - as this is such a small point, it is not necessary to change prior to merge.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r402867016", "createdAt": "2020-04-03T09:10:26Z", "author": {"login": "hutchig"}, "path": "api/src/main/java/io/smallrye/reactive/messaging/annotations/Blocking.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package io.smallrye.reactive.messaging.annotations;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Identifies that a particular method performs blocking operations,\n+ * and as such should be executed on separate worker.\n+ *\n+ * When possible, the initial threads execution context is _restored_", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b4c84d73d1ba592cfed652393d30bf84d470f3"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b1e52c164f748ec6f9f8ef5eba26b42d1484671", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/2b1e52c164f748ec6f9f8ef5eba26b42d1484671", "committedDate": "2020-04-03T13:26:54Z", "message": "Update based on feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MjU3MjEx", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#pullrequestreview-387257211", "createdAt": "2020-04-03T13:31:07Z", "commit": {"oid": "2b1e52c164f748ec6f9f8ef5eba26b42d1484671"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2237, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}