{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUwNDI0MzYz", "number": 659, "title": "Initial OpenTelemetry tracing for Kafka", "bodyText": "Fixes Kafka part of #562", "createdAt": "2020-07-16T18:52:10Z", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659", "merged": true, "mergeCommit": {"oid": "8649e6daf87187c38d2b7e66f7b0ae96c6231af5"}, "closed": true, "closedAt": "2020-08-31T18:46:46Z", "author": {"login": "kenfinnigan"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc1kCTbAFqTQ1MDEyODQzMw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdDVT3ngFqTQ3NzcxMzI1NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMTI4NDMz", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#pullrequestreview-450128433", "createdAt": "2020-07-16T18:59:10Z", "commit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODo1OToxMVrOGy4XWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODo1OToxMVrOGy4XWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwNTQ2NQ==", "bodyText": "gRPC ? That's an unexpected dependency.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456005465", "createdAt": "2020-07-16T18:59:11Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -7,21 +7,36 @@\n import org.apache.kafka.common.header.Headers;\n import org.eclipse.microprofile.reactive.messaging.Metadata;\n \n+import io.grpc.Context;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNDI5ODgw", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#pullrequestreview-450429880", "createdAt": "2020-07-17T07:23:52Z", "commit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNzoyMzo1MlrOGzIPeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOTowMTo0NlrOGzLTZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI2NTU5NA==", "bodyText": "Is this synchronously executed on the same thread from where the message is produced?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456265594", "createdAt": "2020-07-17T07:23:52Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MDg2Nw==", "bodyText": "is the partition important? Could it help to debug the problem?  Shall we add it as an attribute?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456270867", "createdAt": "2020-07-17T07:35:08Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MTg2NA==", "bodyText": "Set these attributes via SemanticAttributes class", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456271864", "createdAt": "2020-07-17T07:37:14Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())\n+                    .setSpanKind(Span.Kind.CONSUMER);\n+\n+            // Handle possible parent span\n+            final SpanContext parentSpan = tracingMetadata.getPreviousSpanContext();\n+            if (parentSpan != null && parentSpan.isValid()) {\n+                spanBuilder.setParent(parentSpan);\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", kafkaRecord.getPartition());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MjU0NQ==", "bodyText": "We should prefix the span name with the operation send/receive or produce/consume", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456272545", "createdAt": "2020-07-17T07:38:36Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MjYzOQ==", "bodyText": "We should prefix the span name with the operation send/receive or produce/consume", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456272639", "createdAt": "2020-07-17T07:38:49Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzE3Ng==", "bodyText": "This span will not provide any valuable timing information e.g. how long the send operation took. Is there a way to end the span once the message is sent on the wire?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456273176", "createdAt": "2020-07-17T07:39:56Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())\n+                    .setSpanKind(Span.Kind.CONSUMER);\n+\n+            // Handle possible parent span\n+            final SpanContext parentSpan = tracingMetadata.getPreviousSpanContext();\n+            if (parentSpan != null && parentSpan.isValid()) {\n+                spanBuilder.setParent(parentSpan);\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", kafkaRecord.getPartition());\n+            span.setAttribute(\"offset\", kafkaRecord.getOffset());\n+            span.setAttribute(\"messaging.system\", \"kafka\");\n+            span.setAttribute(\"messaging.destination\", kafkaRecord.getTopic());\n+            span.setAttribute(\"messaging.destination_kind\", \"topic\");\n+\n+            kafkaRecord.injectTracingMetadata(tracingMetadata.withSpan(span));\n+\n+            span.end();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzQ2MA==", "bodyText": "Isn't the add overriding the value?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456273460", "createdAt": "2020-07-17T07:40:32Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/tracing/HeaderInjectAdapter.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.kafka.common.header.Headers;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+\n+public class HeaderInjectAdapter implements HttpTextFormat.Setter<Headers> {\n+    public static final HeaderInjectAdapter SETTER = new HeaderInjectAdapter();\n+\n+    @Override\n+    public void set(Headers headers, String key, String value) {\n+        if (headers != null) {\n+            headers.remove(key).add(key, value.getBytes(StandardCharsets.UTF_8));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3NDA0NQ==", "bodyText": "missing final?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456274045", "createdAt": "2020-07-17T07:41:45Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConnector.java", "diffHunk": "@@ -77,6 +80,8 @@\n \n     public static final String CONNECTOR_NAME = \"smallrye-kafka\";\n \n+    public static Tracer TRACER = OpenTelemetry.getTracerProvider().get(\"io.smallrye.reactive.messaging.kafka\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwMzAyMQ==", "bodyText": "It would be good to check if the spans belong to the same trace", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456303021", "createdAt": "2020-07-17T08:37:42Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import static io.opentelemetry.trace.Span.Kind.CONSUMER;\n+import static io.opentelemetry.trace.Span.Kind.PRODUCER;\n+import static io.opentelemetry.trace.TracingContextUtils.withSpan;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.jboss.weld.environment.se.Weld;\n+import org.jboss.weld.environment.se.WeldContainer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.exporters.inmemory.InMemorySpanExporter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.reactivex.Flowable;\n+import io.smallrye.config.SmallRyeConfigProviderResolver;\n+import io.smallrye.reactive.messaging.TracingMetadata;\n+import io.smallrye.reactive.messaging.kafka.KafkaConnector;\n+import io.smallrye.reactive.messaging.kafka.KafkaTestBase;\n+import io.smallrye.reactive.messaging.kafka.KafkaUsage;\n+import io.smallrye.reactive.messaging.kafka.MapBasedConfig;\n+\n+public class TracingPropagationTest extends KafkaTestBase {\n+\n+    private WeldContainer container;\n+    private InMemorySpanExporter testExporter;\n+    private SpanProcessor spanProcessor;\n+\n+    @Before\n+    public void setup() {\n+        testExporter = InMemorySpanExporter.create();\n+        spanProcessor = SimpleSpanProcessor.newBuilder(testExporter).build();\n+        OpenTelemetrySdk.getTracerProvider().addSpanProcessor(spanProcessor);\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        if (testExporter != null) {\n+            testExporter.shutdown();\n+        }\n+        if (spanProcessor != null) {\n+            spanProcessor.shutdown();\n+        }\n+\n+        if (container != null) {\n+            container.close();\n+        }\n+\n+        // Release the config objects\n+        SmallRyeConfigProviderResolver.instance().releaseConfig(ConfigProvider.getConfig());\n+    }\n+\n+    @Test\n+    public void testFromAppToKafka() {\n+        KafkaUsage usage = new KafkaUsage();\n+        List<Map.Entry<String, Integer>> messages = new CopyOnWriteArrayList<>();\n+        List<Context> contexts = new CopyOnWriteArrayList<>();\n+        usage.consumeIntegersWithTracing(\"output\", 10, 1, TimeUnit.MINUTES, null,\n+                (key, value) -> messages.add(entry(key, value)),\n+                contexts::add);\n+        deploy(getKafkaSinkConfigForMyAppGeneratingData(), MyAppGeneratingData.class);\n+\n+        await().until(() -> messages.size() >= 10);\n+        List<Integer> values = new ArrayList<>();\n+        assertThat(messages).allSatisfy(entry -> {\n+            assertThat(entry.getValue()).isNotNull();\n+            values.add(entry.getValue());\n+        });\n+        assertThat(values).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        assertThat(contexts).hasSize(10);\n+        assertThat(contexts).doesNotContainNull().doesNotHaveDuplicates();\n+        List<SpanId> spanIds = contexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getSpanId())\n+                .collect(Collectors.toList());\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwNDM2MQ==", "bodyText": "Let's discuss what span context should be used as a parent.\nWhat represents the getPreviousSpanContext? Is it the context derived from the previous Kafka message?\nIf this code is executed synchronously when the user code is sending a message then it might be better to set the current active context as the parent.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456304361", "createdAt": "2020-07-17T08:40:19Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);\n+\n+            if (tracingMetadata.isPresent()) {\n+                // Handle possible parent span\n+                final SpanContext parentSpan = tracingMetadata.get().getPreviousSpanContext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODI1OA==", "bodyText": "Potential leak on the not closed scope.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456308258", "createdAt": "2020-07-17T08:47:32Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);\n+\n+            if (tracingMetadata.isPresent()) {\n+                // Handle possible parent span\n+                final SpanContext parentSpan = tracingMetadata.get().getPreviousSpanContext();\n+                if (parentSpan != null && parentSpan.isValid()) {\n+                    spanBuilder.setParent(parentSpan);\n+                } else {\n+                    spanBuilder.setNoParent();\n+                }\n+\n+                // Handle possible adjacent spans\n+                final SpanContext incomingSpan = tracingMetadata.get().getCurrentSpanContext();\n+                if (incomingSpan != null && incomingSpan.isValid()) {\n+                    spanBuilder.addLink(incomingSpan);\n+                }\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+            TracingContextUtils.currentContextWith(span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODQ3MA==", "bodyText": "SemanticAttributes should be used", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456308470", "createdAt": "2020-07-17T08:47:54Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);\n+\n+            if (tracingMetadata.isPresent()) {\n+                // Handle possible parent span\n+                final SpanContext parentSpan = tracingMetadata.get().getPreviousSpanContext();\n+                if (parentSpan != null && parentSpan.isValid()) {\n+                    spanBuilder.setParent(parentSpan);\n+                } else {\n+                    spanBuilder.setNoParent();\n+                }\n+\n+                // Handle possible adjacent spans\n+                final SpanContext incomingSpan = tracingMetadata.get().getCurrentSpanContext();\n+                if (incomingSpan != null && incomingSpan.isValid()) {\n+                    spanBuilder.addLink(incomingSpan);\n+                }\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+            TracingContextUtils.currentContextWith(span);\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", partition);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwOTk1NA==", "bodyText": "Why readCounter is being used?\nnit: getAndIncrement()", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456309954", "createdAt": "2020-07-17T08:50:40Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/KafkaUsage.java", "diffHunk": "@@ -215,6 +220,26 @@ public void consumeStrings(String topicName, int count, long timeout, TimeUnit u\n                 });\n     }\n \n+    public void consumeStringsWithTracing(String topicName, int count, long timeout, TimeUnit unit, Runnable completion,\n+            BiConsumer<String, String> consumer, Consumer<Context> tracingConsumer) {\n+        AtomicLong readCounter = new AtomicLong();\n+        this.consumeStrings(this.continueIfNotExpired(() -> readCounter.get() < (long) count, timeout, unit), completion,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNTc0OQ==", "bodyText": "There are missing tests when an active span is created in the test an messages are produced and consumed. In this case the spans created by the instrumentation should by linked to the span in the test.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456315749", "createdAt": "2020-07-17T09:01:46Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import static io.opentelemetry.trace.Span.Kind.CONSUMER;\n+import static io.opentelemetry.trace.Span.Kind.PRODUCER;\n+import static io.opentelemetry.trace.TracingContextUtils.withSpan;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.jboss.weld.environment.se.Weld;\n+import org.jboss.weld.environment.se.WeldContainer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.exporters.inmemory.InMemorySpanExporter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.reactivex.Flowable;\n+import io.smallrye.config.SmallRyeConfigProviderResolver;\n+import io.smallrye.reactive.messaging.TracingMetadata;\n+import io.smallrye.reactive.messaging.kafka.KafkaConnector;\n+import io.smallrye.reactive.messaging.kafka.KafkaTestBase;\n+import io.smallrye.reactive.messaging.kafka.KafkaUsage;\n+import io.smallrye.reactive.messaging.kafka.MapBasedConfig;\n+\n+public class TracingPropagationTest extends KafkaTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 59}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/55e3a0d309094ab4df8b7d0debf8a55a18dee152", "committedDate": "2020-07-16T18:44:58Z", "message": "Initial OpenTelemetry work"}, "afterCommit": {"oid": "f053535373223ba7ab9fcdb2f824db5b173323e0", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/f053535373223ba7ab9fcdb2f824db5b173323e0", "committedDate": "2020-07-21T18:16:28Z", "message": "Updates based on PR feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f053535373223ba7ab9fcdb2f824db5b173323e0", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/f053535373223ba7ab9fcdb2f824db5b173323e0", "committedDate": "2020-07-21T18:16:28Z", "message": "Updates based on PR feedback"}, "afterCommit": {"oid": "96a605497685d51e6288f59664673a9d1ae724b6", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/96a605497685d51e6288f59664673a9d1ae724b6", "committedDate": "2020-07-23T15:12:06Z", "message": "Add an await to in memory span reporting"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b6d995468ba24376fdcf40d0cb841263782b40c0", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/b6d995468ba24376fdcf40d0cb841263782b40c0", "committedDate": "2020-07-29T15:18:50Z", "message": "Disable tracing in non tracing tests"}, "afterCommit": {"oid": "bcdc0834069592c83fc38c7c069edde4f2d33a1b", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/bcdc0834069592c83fc38c7c069edde4f2d33a1b", "committedDate": "2020-07-29T15:39:36Z", "message": "Disable tracing in non tracing tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bcdc0834069592c83fc38c7c069edde4f2d33a1b", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/bcdc0834069592c83fc38c7c069edde4f2d33a1b", "committedDate": "2020-07-29T15:39:36Z", "message": "Disable tracing in non tracing tests"}, "afterCommit": {"oid": "cedeee96473f8aafbcc7a56684ec4931e27e22a7", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/cedeee96473f8aafbcc7a56684ec4931e27e22a7", "committedDate": "2020-08-19T15:25:53Z", "message": "Disable tracing in non tracing tests\n\n# Conflicts:\n#\tsmallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNzUwODg1", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#pullrequestreview-471750885", "createdAt": "2020-08-20T15:46:31Z", "commit": {"oid": "cedeee96473f8aafbcc7a56684ec4931e27e22a7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNTo0NjozMlrOHEH8ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNTo0NjozMlrOHEH8ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA4NjUwNg==", "bodyText": "Could we bump it to the latest version 0.7.0?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r474086506", "createdAt": "2020-08-20T15:46:32Z", "author": {"login": "pavolloffay"}, "path": "pom.xml", "diffHunk": "@@ -80,6 +80,8 @@\n \n     <jboss-log-manager.version>2.1.17.Final</jboss-log-manager.version>\n \n+    <opentelemetry.version>0.6.0</opentelemetry.version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cedeee96473f8aafbcc7a56684ec4931e27e22a7"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cedeee96473f8aafbcc7a56684ec4931e27e22a7", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/cedeee96473f8aafbcc7a56684ec4931e27e22a7", "committedDate": "2020-08-19T15:25:53Z", "message": "Disable tracing in non tracing tests\n\n# Conflicts:\n#\tsmallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java"}, "afterCommit": {"oid": "d15af1af3133dddd929ec6fd6c98a1e0dabe4269", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/d15af1af3133dddd929ec6fd6c98a1e0dabe4269", "committedDate": "2020-08-20T17:51:02Z", "message": "Update to OTeL 0.7.1 and use new SemanticAttributes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d15af1af3133dddd929ec6fd6c98a1e0dabe4269", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/d15af1af3133dddd929ec6fd6c98a1e0dabe4269", "committedDate": "2020-08-20T17:51:02Z", "message": "Update to OTeL 0.7.1 and use new SemanticAttributes"}, "afterCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/b8e755370fa58767e50ac58eeac6b3ab80d0087a", "committedDate": "2020-08-24T13:04:25Z", "message": "Update to OTeL 0.7.1 and use new SemanticAttributes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MTYyNDk1", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#pullrequestreview-474162495", "createdAt": "2020-08-25T06:13:15Z", "commit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjoxMzoxNVrOHGI-aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjoyNzozMVrOHGJTcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMDU1Mg==", "bodyText": "In Quarkus, it might be a bit more complicated than just true. Does it require the tracing extension to be there?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476200552", "createdAt": "2020-08-25T06:13:15Z", "author": {"login": "cescoffier"}, "path": "documentation/src/main/doc/modules/connectors/partials/META-INF/connector/smallrye-kafka-incoming.adoc", "diffHunk": "@@ -17,6 +17,10 @@ Type: _string_ | false |\n \n Type: _boolean_ | false | `true`\n \n+| *tracing-enabled* | Whether tracing is enabled (default) or disabled\n+\n+Type: _boolean_ | false | `true`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMDc2NQ==", "bodyText": "For my own understanding, it is a regular dependency or a test dependency?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476200765", "createdAt": "2020-08-25T06:13:51Z", "author": {"login": "cescoffier"}, "path": "pom.xml", "diffHunk": "@@ -214,6 +216,22 @@\n         <version>${jboss-log-manager.version}</version>\n       </dependency>\n \n+      <dependency>\n+        <groupId>io.opentelemetry</groupId>\n+        <artifactId>opentelemetry-api</artifactId>\n+        <version>${opentelemetry.version}</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>io.opentelemetry</groupId>\n+        <artifactId>opentelemetry-sdk</artifactId>\n+        <version>${opentelemetry.version}</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>io.opentelemetry</groupId>\n+        <artifactId>opentelemetry-exporters-inmemory</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMDg1OA==", "bodyText": "Any info about this?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476200858", "createdAt": "2020-08-25T06:14:05Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -7,21 +7,36 @@\n import org.apache.kafka.common.header.Headers;\n import org.eclipse.microprofile.reactive.messaging.Metadata;\n \n+import io.grpc.Context;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwNTQ2NQ=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMTEwMA==", "bodyText": "Should it be added only if tracing is enabled?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476201100", "createdAt": "2020-08-25T06:14:47Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -23,8 +28,18 @@ public IncomingKafkaRecord(\n             KafkaCommitHandler commitHandler,\n             KafkaFailureHandler onNack) {\n         this.kafkaMetadata = new IncomingKafkaRecordMetadata<>(record);\n-        this.metadata = Metadata.of(this.kafkaMetadata);\n         this.commitHandler = commitHandler;\n+\n+        TracingMetadata tracingMetadata = TracingMetadata.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMTY3Mg==", "bodyText": "with metadata not final anymore, we must synchronize access.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476201672", "createdAt": "2020-08-25T06:16:15Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -81,4 +96,8 @@ public Metadata getMetadata() {\n     public CompletionStage<Void> nack(Throwable reason) {\n         return onNack.handle(this, reason);\n     }\n+\n+    public void injectTracingMetadata(TracingMetadata tracingMetadata) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMjE0Mg==", "bodyText": "so even if tracing is disabled we instantiate the tracer? Does it make sense?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476202142", "createdAt": "2020-08-25T06:17:29Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConnector.java", "diffHunk": "@@ -79,6 +82,8 @@\n \n     public static final String CONNECTOR_NAME = \"smallrye-kafka\";\n \n+    public static final Tracer TRACER = OpenTelemetry.getTracerProvider().get(\"io.smallrye.reactive.messaging.kafka\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMjcyOA==", "bodyText": "is the \"send\" word defined somewhere? In Kafka, we use \"write\" most of the time.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476202728", "createdAt": "2020-08-25T06:19:11Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -168,6 +180,48 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic + \" send\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMzAzNg==", "bodyText": "This whole block should be externalized in a carefully tested method.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476203036", "createdAt": "2020-08-25T06:20:01Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -168,6 +180,48 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMzk1NA==", "bodyText": "let's build a conditional pipeline instead of testing if tracing is enabled every time.\nmulti = ...\nif (getTracingEnabled()) {\n    multi = .... \n}", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476203954", "createdAt": "2020-08-25T06:22:29Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -225,6 +230,7 @@ public KafkaSource(Vertx vertx,\n                     }\n                 })\n                 .map(rec -> commitHandler.received(new IncomingKafkaRecord<>(rec, commitHandler, failureHandler)))\n+                .onItem().invoke(this::incomingTrace)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNDUwOQ==", "bodyText": "We could still register the reception timestamp.\nNote that it's not the record timestamp.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476204509", "createdAt": "2020-08-25T06:23:58Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())\n+                    .setSpanKind(Span.Kind.CONSUMER);\n+\n+            // Handle possible parent span\n+            final SpanContext parentSpan = tracingMetadata.getPreviousSpanContext();\n+            if (parentSpan != null && parentSpan.isValid()) {\n+                spanBuilder.setParent(parentSpan);\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", kafkaRecord.getPartition());\n+            span.setAttribute(\"offset\", kafkaRecord.getOffset());\n+            span.setAttribute(\"messaging.system\", \"kafka\");\n+            span.setAttribute(\"messaging.destination\", kafkaRecord.getTopic());\n+            span.setAttribute(\"messaging.destination_kind\", \"topic\");\n+\n+            kafkaRecord.injectTracingMetadata(tracingMetadata.withSpan(span));\n+\n+            span.end();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzE3Ng=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNDg4NQ==", "bodyText": "should it fail on multiple values? Is it even possible?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476204885", "createdAt": "2020-08-25T06:24:54Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/tracing/HeaderExtractAdapter.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.Headers;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+\n+public class HeaderExtractAdapter implements HttpTextFormat.Getter<Headers> {\n+    public static final HeaderExtractAdapter GETTER = new HeaderExtractAdapter();\n+\n+    @Override\n+    public String get(Headers headers, String key) {\n+        final Header header = headers.lastHeader(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNTI2NA==", "bodyText": "I was thinking add was appending, but let's check.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476205264", "createdAt": "2020-08-25T06:25:48Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/tracing/HeaderInjectAdapter.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.kafka.common.header.Headers;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+\n+public class HeaderInjectAdapter implements HttpTextFormat.Setter<Headers> {\n+    public static final HeaderInjectAdapter SETTER = new HeaderInjectAdapter();\n+\n+    @Override\n+    public void set(Headers headers, String key, String value) {\n+        if (headers != null) {\n+            headers.remove(key).add(key, value.getBytes(StandardCharsets.UTF_8));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzQ2MA=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNTczMQ==", "bodyText": "That is a bit cumbersome and error-prone.\nIs there something we can do in the base class?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476205731", "createdAt": "2020-08-25T06:27:02Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/DefaultConfigTest.java", "diffHunk": "@@ -89,12 +89,14 @@ private MapBasedConfig getKafkaSinkConfigForMyAppProcessingData(String topicOut,\n         Map<String, Object> config = new HashMap<>();\n         config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n         config.put(prefix + \"topic\", topicOut);\n+        config.put(prefix + \"tracing-enabled\", false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNTkzNg==", "bodyText": "we should wait until the vert.x instance is closed if we want to be totally correct.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476205936", "createdAt": "2020-08-25T06:27:31Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/KafkaTestBase.java", "diffHunk": "@@ -66,7 +66,9 @@ public void setup() {\n \n     @After\n     public void tearDown() {\n-        vertx.close();\n+        if (vertx != null) {\n+            vertx.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MTk4NTM3", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#pullrequestreview-474198537", "createdAt": "2020-08-25T07:18:50Z", "commit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNzoxODo1MVrOHGKv4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNzoxODo1NlrOHGKv_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIyOTYwMQ==", "bodyText": "minor - can be final", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476229601", "createdAt": "2020-08-25T07:18:51Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "diffHunk": "@@ -0,0 +1,392 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import static io.opentelemetry.trace.Span.Kind.CONSUMER;\n+import static io.opentelemetry.trace.Span.Kind.PRODUCER;\n+import static io.opentelemetry.trace.TracingContextUtils.withSpan;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.jboss.weld.environment.se.Weld;\n+import org.jboss.weld.environment.se.WeldContainer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.exporters.inmemory.InMemorySpanExporter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.reactivex.Flowable;\n+import io.smallrye.config.SmallRyeConfigProviderResolver;\n+import io.smallrye.reactive.messaging.TracingMetadata;\n+import io.smallrye.reactive.messaging.kafka.KafkaConnector;\n+import io.smallrye.reactive.messaging.kafka.KafkaTestBase;\n+import io.smallrye.reactive.messaging.kafka.KafkaUsage;\n+import io.smallrye.reactive.messaging.kafka.MapBasedConfig;\n+\n+public class TracingPropagationTest extends KafkaTestBase {\n+\n+    private WeldContainer container;\n+    private InMemorySpanExporter testExporter;\n+    private SpanProcessor spanProcessor;\n+\n+    @Before\n+    public void setup() {\n+        testExporter = InMemorySpanExporter.create();\n+        spanProcessor = SimpleSpanProcessor.newBuilder(testExporter).build();\n+        OpenTelemetrySdk.getTracerProvider().addSpanProcessor(spanProcessor);\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        if (testExporter != null) {\n+            testExporter.shutdown();\n+        }\n+        if (spanProcessor != null) {\n+            spanProcessor.shutdown();\n+        }\n+\n+        if (container != null) {\n+            container.close();\n+        }\n+\n+        // Release the config objects\n+        SmallRyeConfigProviderResolver.instance().releaseConfig(ConfigProvider.getConfig());\n+    }\n+\n+    @Test\n+    public void testFromAppToKafka() {\n+        KafkaUsage usage = new KafkaUsage();\n+        List<Map.Entry<String, Integer>> messages = new CopyOnWriteArrayList<>();\n+        List<Context> contexts = new CopyOnWriteArrayList<>();\n+        usage.consumeIntegersWithTracing(\"output\", 10, 1, TimeUnit.MINUTES, null,\n+                (key, value) -> messages.add(entry(key, value)),\n+                contexts::add);\n+        deploy(getKafkaSinkConfigForMyAppGeneratingData(), MyAppGeneratingData.class);\n+\n+        await().until(() -> messages.size() >= 10);\n+        List<Integer> values = new ArrayList<>();\n+        assertThat(messages).allSatisfy(entry -> {\n+            assertThat(entry.getValue()).isNotNull();\n+            values.add(entry.getValue());\n+        });\n+        assertThat(values).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        assertThat(contexts).hasSize(10);\n+        assertThat(contexts).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<SpanId> spanIds = contexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getSpanId())\n+                .collect(Collectors.toList());\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        List<TraceId> traceIds = contexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(traceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getTraceId()).isIn(traceIds);\n+            assertThat(data.getKind()).isEqualByComparingTo(PRODUCER);\n+            assertThat(data.getParentSpanId().isValid()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppToKafka() {\n+        KafkaUsage usage = new KafkaUsage();\n+        List<Map.Entry<String, Integer>> messages = new CopyOnWriteArrayList<>();\n+        List<Context> receivedContexts = new CopyOnWriteArrayList<>();\n+        usage.consumeIntegersWithTracing(\"result-topic\", 10, 1, TimeUnit.MINUTES, null,\n+                (key, value) -> messages.add(entry(key, value)),\n+                receivedContexts::add);\n+        deploy(getKafkaSinkConfigForMyAppProcessingData(), MyAppProcessingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        List<SpanContext> producedSpanContexts = new CopyOnWriteArrayList<>();\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"some-topic\", null, null, \"a-key\", count.getAndIncrement(),\n+                        createTracingSpan(producedSpanContexts, \"some-topic\")));\n+\n+        await().atMost(Duration.ofMinutes(5)).until(() -> messages.size() >= 10);\n+        List<Integer> values = new ArrayList<>();\n+        assertThat(messages).allSatisfy(entry -> {\n+            assertThat(entry.getValue()).isNotNull();\n+            values.add(entry.getValue());\n+        });\n+        assertThat(values).containsExactly(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+\n+        List<TraceId> producedTraceIds = producedSpanContexts.stream()\n+                .map(SpanContext::getTraceId)\n+                .collect(Collectors.toList());\n+        assertThat(producedTraceIds).hasSize(10);\n+\n+        assertThat(receivedContexts).hasSize(10);\n+        assertThat(receivedContexts).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<SpanId> receivedSpanIds = receivedContexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getSpanId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedSpanIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        List<TraceId> receivedTraceIds = receivedContexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedTraceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+        assertThat(receivedTraceIds).containsExactlyInAnyOrderElementsOf(producedTraceIds);\n+\n+        List<SpanId> receivedParentSpanIds = new ArrayList<>();\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            if (data.getKind().equals(CONSUMER)) {\n+                // Need to skip the spans created during @Incoming processing\n+                continue;\n+            }\n+            assertThat(data.getSpanId()).isIn(receivedSpanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getTraceId()).isIn(producedTraceIds);\n+            assertThat(data.getKind()).isEqualByComparingTo(PRODUCER);\n+            assertThat(data.getParentSpanId().isValid()).isTrue();\n+            receivedParentSpanIds.add(data.getParentSpanId());\n+        }\n+\n+        assertThat(producedSpanContexts.stream()\n+                .map(SpanContext::getSpanId)).containsExactlyElementsOf(receivedParentSpanIds);\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppWithParentSpan() {\n+        KafkaUsage usage = new KafkaUsage();\n+        deploy(getKafkaSinkConfigForMyAppReceivingData(\"parent-stuff\"), MyAppReceivingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        MyAppReceivingData bean = container.getBeanManager().createInstance().select(MyAppReceivingData.class).get();\n+        List<SpanContext> producedSpanContexts = new CopyOnWriteArrayList<>();\n+\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"parent-stuff\", null, null, \"a-key\", count.getAndIncrement(),\n+                        createTracingSpan(producedSpanContexts, \"stuff-topic\")));\n+\n+        await().until(() -> bean.list().size() >= 10);\n+        assertThat(bean.list()).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        List<TraceId> producedTraceIds = producedSpanContexts.stream()\n+                .map(SpanContext::getTraceId)\n+                .collect(Collectors.toList());\n+        assertThat(producedTraceIds).hasSize(10);\n+\n+        assertThat(bean.tracing()).hasSizeGreaterThanOrEqualTo(10);\n+        assertThat(bean.tracing()).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<TraceId> receivedTraceIds = bean.tracing().stream()\n+                .map(tracingMetadata -> tracingMetadata.getCurrentSpanContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedTraceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+        assertThat(receivedTraceIds).containsExactlyInAnyOrderElementsOf(producedTraceIds);\n+\n+        List<SpanId> spanIds = new ArrayList<>();\n+\n+        for (TracingMetadata tracing : bean.tracing()) {\n+            spanIds.add(tracing.getCurrentSpanContext().getSpanId());\n+\n+            assertThat(tracing.getPreviousSpanContext()).isNotNull();\n+            assertThat(tracing.getPreviousSpanContext().getTraceId())\n+                    .isEqualByComparingTo(tracing.getCurrentSpanContext().getTraceId());\n+            assertThat(tracing.getPreviousSpanContext().getSpanId())\n+                    .isNotEqualByComparingTo(tracing.getCurrentSpanContext().getSpanId());\n+        }\n+\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSizeGreaterThanOrEqualTo(10);\n+\n+        List<SpanId> parentIds = bean.tracing().stream()\n+                .map(tracingMetadata -> tracingMetadata.getPreviousSpanContext().getSpanId())\n+                .collect(Collectors.toList());\n+\n+        assertThat(producedSpanContexts.stream()\n+                .map(SpanContext::getSpanId)).containsExactlyElementsOf(parentIds);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getKind()).isEqualByComparingTo(CONSUMER);\n+            assertThat(data.getParentSpanId()).isNotNull();\n+            assertThat(data.getParentSpanId()).isIn(parentIds);\n+        }\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppWithNoParent() {\n+        KafkaUsage usage = new KafkaUsage();\n+        deploy(getKafkaSinkConfigForMyAppReceivingData(\"no-parent-stuff\"), MyAppReceivingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        MyAppReceivingData bean = container.getBeanManager().createInstance().select(MyAppReceivingData.class).get();\n+\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"no-parent-stuff\", null, null, \"a-key\", count.getAndIncrement()));\n+\n+        await().until(() -> bean.list().size() >= 10);\n+        assertThat(bean.list()).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        assertThat(bean.tracing()).hasSizeGreaterThanOrEqualTo(10);\n+        assertThat(bean.tracing()).doesNotContainNull().doesNotHaveDuplicates();\n+        List<SpanId> spanIds = new ArrayList<>();\n+\n+        for (TracingMetadata tracing : bean.tracing()) {\n+            spanIds.add(tracing.getCurrentSpanContext().getSpanId());\n+            assertThat(tracing.getPreviousSpanContext()).isNull();\n+        }\n+\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSizeGreaterThanOrEqualTo(10);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getKind()).isEqualByComparingTo(CONSUMER);\n+            assertThat(data.getParentSpanId().isValid()).isFalse();\n+        }\n+    }\n+\n+    private Iterable<Header> createTracingSpan(List<SpanContext> spanContexts, String topic) {\n+        RecordHeaders proposedHeaders = new RecordHeaders();\n+        final Span span = KafkaConnector.TRACER.spanBuilder(topic).setSpanKind(PRODUCER).startSpan();\n+        final Context context = withSpan(span, Context.current());\n+        OpenTelemetry.getPropagators()\n+                .getHttpTextFormat()\n+                .inject(context, proposedHeaders, (headers, key, value) -> {\n+                    if (headers != null) {\n+                        headers.remove(key).add(key, value.getBytes(StandardCharsets.UTF_8));\n+                    }\n+                });\n+        spanContexts.add(span.getContext());\n+        return proposedHeaders;\n+    }\n+\n+    private <T> void deploy(MapBasedConfig config, Class<T> clazz) {\n+        if (config != null) {\n+            config.write();\n+        } else {\n+            MapBasedConfig.clear();\n+        }\n+\n+        Weld weld = baseWeld();\n+        weld.addBeanClass(clazz);\n+\n+        container = weld.initialize();\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppGeneratingData() {\n+        String prefix = \"mp.messaging.outgoing.kafka.\";\n+        Map<String, Object> config = new HashMap<>();\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.serializer\", IntegerSerializer.class.getName());\n+        config.put(prefix + \"topic\", \"output\");\n+        return new MapBasedConfig(config);\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppProcessingData() {\n+        String prefix = \"mp.messaging.outgoing.kafka.\";\n+        Map<String, Object> config = new HashMap<>();\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.serializer\", IntegerSerializer.class.getName());\n+        config.put(prefix + \"topic\", \"result-topic\");\n+\n+        prefix = \"mp.messaging.incoming.source.\";\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.deserializer\", IntegerDeserializer.class.getName());\n+        config.put(prefix + \"key.deserializer\", StringDeserializer.class.getName());\n+        config.put(prefix + \"topic\", \"some-topic\");\n+        config.put(prefix + \"auto.offset.reset\", \"earliest\");\n+\n+        return new MapBasedConfig(config);\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppReceivingData(String topic) {\n+        Map<String, Object> config = new HashMap<>();\n+\n+        String prefix = \"mp.messaging.incoming.stuff.\";\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.deserializer\", IntegerDeserializer.class.getName());\n+        config.put(prefix + \"key.deserializer\", StringDeserializer.class.getName());\n+        config.put(prefix + \"topic\", topic);\n+        config.put(prefix + \"auto.offset.reset\", \"earliest\");\n+\n+        return new MapBasedConfig(config);\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppGeneratingData {\n+\n+        @Outgoing(\"kafka\")\n+        public Flowable<Integer> source() {\n+            return Flowable.range(0, 10);\n+        }\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppProcessingData {\n+\n+        @Incoming(\"source\")\n+        @Outgoing(\"kafka\")\n+        public Message<Integer> processMessage(Message<Integer> input) {\n+            return input.withPayload(input.getPayload() + 1);\n+        }\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppReceivingData {\n+        private List<TracingMetadata> tracingMetadata = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 373}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIyOTYzMQ==", "bodyText": "minor - can be final", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476229631", "createdAt": "2020-08-25T07:18:56Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "diffHunk": "@@ -0,0 +1,392 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import static io.opentelemetry.trace.Span.Kind.CONSUMER;\n+import static io.opentelemetry.trace.Span.Kind.PRODUCER;\n+import static io.opentelemetry.trace.TracingContextUtils.withSpan;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.jboss.weld.environment.se.Weld;\n+import org.jboss.weld.environment.se.WeldContainer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.exporters.inmemory.InMemorySpanExporter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.reactivex.Flowable;\n+import io.smallrye.config.SmallRyeConfigProviderResolver;\n+import io.smallrye.reactive.messaging.TracingMetadata;\n+import io.smallrye.reactive.messaging.kafka.KafkaConnector;\n+import io.smallrye.reactive.messaging.kafka.KafkaTestBase;\n+import io.smallrye.reactive.messaging.kafka.KafkaUsage;\n+import io.smallrye.reactive.messaging.kafka.MapBasedConfig;\n+\n+public class TracingPropagationTest extends KafkaTestBase {\n+\n+    private WeldContainer container;\n+    private InMemorySpanExporter testExporter;\n+    private SpanProcessor spanProcessor;\n+\n+    @Before\n+    public void setup() {\n+        testExporter = InMemorySpanExporter.create();\n+        spanProcessor = SimpleSpanProcessor.newBuilder(testExporter).build();\n+        OpenTelemetrySdk.getTracerProvider().addSpanProcessor(spanProcessor);\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        if (testExporter != null) {\n+            testExporter.shutdown();\n+        }\n+        if (spanProcessor != null) {\n+            spanProcessor.shutdown();\n+        }\n+\n+        if (container != null) {\n+            container.close();\n+        }\n+\n+        // Release the config objects\n+        SmallRyeConfigProviderResolver.instance().releaseConfig(ConfigProvider.getConfig());\n+    }\n+\n+    @Test\n+    public void testFromAppToKafka() {\n+        KafkaUsage usage = new KafkaUsage();\n+        List<Map.Entry<String, Integer>> messages = new CopyOnWriteArrayList<>();\n+        List<Context> contexts = new CopyOnWriteArrayList<>();\n+        usage.consumeIntegersWithTracing(\"output\", 10, 1, TimeUnit.MINUTES, null,\n+                (key, value) -> messages.add(entry(key, value)),\n+                contexts::add);\n+        deploy(getKafkaSinkConfigForMyAppGeneratingData(), MyAppGeneratingData.class);\n+\n+        await().until(() -> messages.size() >= 10);\n+        List<Integer> values = new ArrayList<>();\n+        assertThat(messages).allSatisfy(entry -> {\n+            assertThat(entry.getValue()).isNotNull();\n+            values.add(entry.getValue());\n+        });\n+        assertThat(values).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        assertThat(contexts).hasSize(10);\n+        assertThat(contexts).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<SpanId> spanIds = contexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getSpanId())\n+                .collect(Collectors.toList());\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        List<TraceId> traceIds = contexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(traceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getTraceId()).isIn(traceIds);\n+            assertThat(data.getKind()).isEqualByComparingTo(PRODUCER);\n+            assertThat(data.getParentSpanId().isValid()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppToKafka() {\n+        KafkaUsage usage = new KafkaUsage();\n+        List<Map.Entry<String, Integer>> messages = new CopyOnWriteArrayList<>();\n+        List<Context> receivedContexts = new CopyOnWriteArrayList<>();\n+        usage.consumeIntegersWithTracing(\"result-topic\", 10, 1, TimeUnit.MINUTES, null,\n+                (key, value) -> messages.add(entry(key, value)),\n+                receivedContexts::add);\n+        deploy(getKafkaSinkConfigForMyAppProcessingData(), MyAppProcessingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        List<SpanContext> producedSpanContexts = new CopyOnWriteArrayList<>();\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"some-topic\", null, null, \"a-key\", count.getAndIncrement(),\n+                        createTracingSpan(producedSpanContexts, \"some-topic\")));\n+\n+        await().atMost(Duration.ofMinutes(5)).until(() -> messages.size() >= 10);\n+        List<Integer> values = new ArrayList<>();\n+        assertThat(messages).allSatisfy(entry -> {\n+            assertThat(entry.getValue()).isNotNull();\n+            values.add(entry.getValue());\n+        });\n+        assertThat(values).containsExactly(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+\n+        List<TraceId> producedTraceIds = producedSpanContexts.stream()\n+                .map(SpanContext::getTraceId)\n+                .collect(Collectors.toList());\n+        assertThat(producedTraceIds).hasSize(10);\n+\n+        assertThat(receivedContexts).hasSize(10);\n+        assertThat(receivedContexts).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<SpanId> receivedSpanIds = receivedContexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getSpanId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedSpanIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        List<TraceId> receivedTraceIds = receivedContexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedTraceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+        assertThat(receivedTraceIds).containsExactlyInAnyOrderElementsOf(producedTraceIds);\n+\n+        List<SpanId> receivedParentSpanIds = new ArrayList<>();\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            if (data.getKind().equals(CONSUMER)) {\n+                // Need to skip the spans created during @Incoming processing\n+                continue;\n+            }\n+            assertThat(data.getSpanId()).isIn(receivedSpanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getTraceId()).isIn(producedTraceIds);\n+            assertThat(data.getKind()).isEqualByComparingTo(PRODUCER);\n+            assertThat(data.getParentSpanId().isValid()).isTrue();\n+            receivedParentSpanIds.add(data.getParentSpanId());\n+        }\n+\n+        assertThat(producedSpanContexts.stream()\n+                .map(SpanContext::getSpanId)).containsExactlyElementsOf(receivedParentSpanIds);\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppWithParentSpan() {\n+        KafkaUsage usage = new KafkaUsage();\n+        deploy(getKafkaSinkConfigForMyAppReceivingData(\"parent-stuff\"), MyAppReceivingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        MyAppReceivingData bean = container.getBeanManager().createInstance().select(MyAppReceivingData.class).get();\n+        List<SpanContext> producedSpanContexts = new CopyOnWriteArrayList<>();\n+\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"parent-stuff\", null, null, \"a-key\", count.getAndIncrement(),\n+                        createTracingSpan(producedSpanContexts, \"stuff-topic\")));\n+\n+        await().until(() -> bean.list().size() >= 10);\n+        assertThat(bean.list()).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        List<TraceId> producedTraceIds = producedSpanContexts.stream()\n+                .map(SpanContext::getTraceId)\n+                .collect(Collectors.toList());\n+        assertThat(producedTraceIds).hasSize(10);\n+\n+        assertThat(bean.tracing()).hasSizeGreaterThanOrEqualTo(10);\n+        assertThat(bean.tracing()).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<TraceId> receivedTraceIds = bean.tracing().stream()\n+                .map(tracingMetadata -> tracingMetadata.getCurrentSpanContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedTraceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+        assertThat(receivedTraceIds).containsExactlyInAnyOrderElementsOf(producedTraceIds);\n+\n+        List<SpanId> spanIds = new ArrayList<>();\n+\n+        for (TracingMetadata tracing : bean.tracing()) {\n+            spanIds.add(tracing.getCurrentSpanContext().getSpanId());\n+\n+            assertThat(tracing.getPreviousSpanContext()).isNotNull();\n+            assertThat(tracing.getPreviousSpanContext().getTraceId())\n+                    .isEqualByComparingTo(tracing.getCurrentSpanContext().getTraceId());\n+            assertThat(tracing.getPreviousSpanContext().getSpanId())\n+                    .isNotEqualByComparingTo(tracing.getCurrentSpanContext().getSpanId());\n+        }\n+\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSizeGreaterThanOrEqualTo(10);\n+\n+        List<SpanId> parentIds = bean.tracing().stream()\n+                .map(tracingMetadata -> tracingMetadata.getPreviousSpanContext().getSpanId())\n+                .collect(Collectors.toList());\n+\n+        assertThat(producedSpanContexts.stream()\n+                .map(SpanContext::getSpanId)).containsExactlyElementsOf(parentIds);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getKind()).isEqualByComparingTo(CONSUMER);\n+            assertThat(data.getParentSpanId()).isNotNull();\n+            assertThat(data.getParentSpanId()).isIn(parentIds);\n+        }\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppWithNoParent() {\n+        KafkaUsage usage = new KafkaUsage();\n+        deploy(getKafkaSinkConfigForMyAppReceivingData(\"no-parent-stuff\"), MyAppReceivingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        MyAppReceivingData bean = container.getBeanManager().createInstance().select(MyAppReceivingData.class).get();\n+\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"no-parent-stuff\", null, null, \"a-key\", count.getAndIncrement()));\n+\n+        await().until(() -> bean.list().size() >= 10);\n+        assertThat(bean.list()).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        assertThat(bean.tracing()).hasSizeGreaterThanOrEqualTo(10);\n+        assertThat(bean.tracing()).doesNotContainNull().doesNotHaveDuplicates();\n+        List<SpanId> spanIds = new ArrayList<>();\n+\n+        for (TracingMetadata tracing : bean.tracing()) {\n+            spanIds.add(tracing.getCurrentSpanContext().getSpanId());\n+            assertThat(tracing.getPreviousSpanContext()).isNull();\n+        }\n+\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSizeGreaterThanOrEqualTo(10);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getKind()).isEqualByComparingTo(CONSUMER);\n+            assertThat(data.getParentSpanId().isValid()).isFalse();\n+        }\n+    }\n+\n+    private Iterable<Header> createTracingSpan(List<SpanContext> spanContexts, String topic) {\n+        RecordHeaders proposedHeaders = new RecordHeaders();\n+        final Span span = KafkaConnector.TRACER.spanBuilder(topic).setSpanKind(PRODUCER).startSpan();\n+        final Context context = withSpan(span, Context.current());\n+        OpenTelemetry.getPropagators()\n+                .getHttpTextFormat()\n+                .inject(context, proposedHeaders, (headers, key, value) -> {\n+                    if (headers != null) {\n+                        headers.remove(key).add(key, value.getBytes(StandardCharsets.UTF_8));\n+                    }\n+                });\n+        spanContexts.add(span.getContext());\n+        return proposedHeaders;\n+    }\n+\n+    private <T> void deploy(MapBasedConfig config, Class<T> clazz) {\n+        if (config != null) {\n+            config.write();\n+        } else {\n+            MapBasedConfig.clear();\n+        }\n+\n+        Weld weld = baseWeld();\n+        weld.addBeanClass(clazz);\n+\n+        container = weld.initialize();\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppGeneratingData() {\n+        String prefix = \"mp.messaging.outgoing.kafka.\";\n+        Map<String, Object> config = new HashMap<>();\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.serializer\", IntegerSerializer.class.getName());\n+        config.put(prefix + \"topic\", \"output\");\n+        return new MapBasedConfig(config);\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppProcessingData() {\n+        String prefix = \"mp.messaging.outgoing.kafka.\";\n+        Map<String, Object> config = new HashMap<>();\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.serializer\", IntegerSerializer.class.getName());\n+        config.put(prefix + \"topic\", \"result-topic\");\n+\n+        prefix = \"mp.messaging.incoming.source.\";\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.deserializer\", IntegerDeserializer.class.getName());\n+        config.put(prefix + \"key.deserializer\", StringDeserializer.class.getName());\n+        config.put(prefix + \"topic\", \"some-topic\");\n+        config.put(prefix + \"auto.offset.reset\", \"earliest\");\n+\n+        return new MapBasedConfig(config);\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppReceivingData(String topic) {\n+        Map<String, Object> config = new HashMap<>();\n+\n+        String prefix = \"mp.messaging.incoming.stuff.\";\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.deserializer\", IntegerDeserializer.class.getName());\n+        config.put(prefix + \"key.deserializer\", StringDeserializer.class.getName());\n+        config.put(prefix + \"topic\", topic);\n+        config.put(prefix + \"auto.offset.reset\", \"earliest\");\n+\n+        return new MapBasedConfig(config);\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppGeneratingData {\n+\n+        @Outgoing(\"kafka\")\n+        public Flowable<Integer> source() {\n+            return Flowable.range(0, 10);\n+        }\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppProcessingData {\n+\n+        @Incoming(\"source\")\n+        @Outgoing(\"kafka\")\n+        public Message<Integer> processMessage(Message<Integer> input) {\n+            return input.withPayload(input.getPayload() + 1);\n+        }\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppReceivingData {\n+        private List<TracingMetadata> tracingMetadata = new ArrayList<>();\n+        private List<Integer> results = new CopyOnWriteArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a"}, "originalPosition": 374}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87fe25b0548205127cef80d6f4f8d1a1df3cc92b", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/87fe25b0548205127cef80d6f4f8d1a1df3cc92b", "committedDate": "2020-08-25T14:02:18Z", "message": "Initial OpenTelemetry work"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c655294dc64890e90088f73265b69235e7aa606c", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/c655294dc64890e90088f73265b69235e7aa606c", "committedDate": "2020-08-25T14:02:21Z", "message": "Updates based on PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f438b75396a17289913d4ac41a423c5fbd491b4", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/9f438b75396a17289913d4ac41a423c5fbd491b4", "committedDate": "2020-08-25T14:02:21Z", "message": "Disable tracing in non tracing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0bc7cbf2d6dbb238ed9a90c58b194b3050e4ba4", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/d0bc7cbf2d6dbb238ed9a90c58b194b3050e4ba4", "committedDate": "2020-08-25T14:03:00Z", "message": "Disable tracing in non tracing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23848eed7d98766607a08b6636f5472e97625723", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/23848eed7d98766607a08b6636f5472e97625723", "committedDate": "2020-08-25T14:03:03Z", "message": "Update to OTeL 0.7.1 and use new SemanticAttributes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9c298550d2387d3efcfc8a25f6ae9eeebdba3a7", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/b9c298550d2387d3efcfc8a25f6ae9eeebdba3a7", "committedDate": "2020-08-25T18:09:46Z", "message": "Updates for rebasing on Cloud Events and based on PR feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/b8e755370fa58767e50ac58eeac6b3ab80d0087a", "committedDate": "2020-08-24T13:04:25Z", "message": "Update to OTeL 0.7.1 and use new SemanticAttributes"}, "afterCommit": {"oid": "b9c298550d2387d3efcfc8a25f6ae9eeebdba3a7", "author": {"user": {"login": "kenfinnigan", "name": "Ken Finnigan"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/b9c298550d2387d3efcfc8a25f6ae9eeebdba3a7", "committedDate": "2020-08-25T18:09:46Z", "message": "Updates for rebasing on Cloud Events and based on PR feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NDExOTA0", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#pullrequestreview-476411904", "createdAt": "2020-08-27T06:12:33Z", "commit": {"oid": "b9c298550d2387d3efcfc8a25f6ae9eeebdba3a7"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNjoxMjozM1rOHIA_FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNjoxMjozM1rOHIA_FQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE2NjgwNQ==", "bodyText": "@pavolloffay any hint?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r478166805", "createdAt": "2020-08-27T06:12:33Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())\n+                    .setSpanKind(Span.Kind.CONSUMER);\n+\n+            // Handle possible parent span\n+            final SpanContext parentSpan = tracingMetadata.getPreviousSpanContext();\n+            if (parentSpan != null && parentSpan.isValid()) {\n+                spanBuilder.setParent(parentSpan);\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", kafkaRecord.getPartition());\n+            span.setAttribute(\"offset\", kafkaRecord.getOffset());\n+            span.setAttribute(\"messaging.system\", \"kafka\");\n+            span.setAttribute(\"messaging.destination\", kafkaRecord.getTopic());\n+            span.setAttribute(\"messaging.destination_kind\", \"topic\");\n+\n+            kafkaRecord.injectTracingMetadata(tracingMetadata.withSpan(span));\n+\n+            span.end();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzE3Ng=="}, "originalCommit": {"oid": "55e3a0d309094ab4df8b7d0debf8a55a18dee152"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3NzEzMjU0", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#pullrequestreview-477713254", "createdAt": "2020-08-28T13:08:47Z", "commit": {"oid": "b9c298550d2387d3efcfc8a25f6ae9eeebdba3a7"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMzowODo0N1rOHJEZBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMzowODo0N1rOHJEZBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3MTE3NQ==", "bodyText": "The signature looks weird getTracingEnabled() it could be .isTracingEnabled()?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r479271175", "createdAt": "2020-08-28T13:08:47Z", "author": {"login": "pavolloffay"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -264,6 +275,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9c298550d2387d3efcfc8a25f6ae9eeebdba3a7"}, "originalPosition": 52}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2311, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}