{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUzMTM2MDc5", "number": 672, "title": "Set fetch size to before pause value when resuming kafka source", "bodyText": "@cescoffier\nThis is a doozy and I'm not this sure this fix is the correct way to go. When we have a re-balance listener configured and partitions is greater than 1 we will get the following if consuming messages at a high throughput (KafkaSource will then stop consuming):\n2020-07-20 03:48:12,061 ERROR [io.sma.rea.mes.provider] (vert.x-eventloop-thread-1) SRMSG00201: Error caught during the stream processing: io.smallrye.mutiny.subscription.BackPressureFailure: Buffer full, cannot emit item\n\tat io.smallrye.mutiny.operators.multi.MultiFlatMapOp$FlatMapMainSubscriber.failOverflow(MultiFlatMapOp.java:539)\n\tat io.smallrye.mutiny.operators.multi.MultiFlatMapOp$FlatMapMainSubscriber.tryEmit(MultiFlatMapOp.java:240)\n\tat io.smallrye.mutiny.operators.multi.MultiFlatMapOp$FlatMapInner.onItem(MultiFlatMapOp.java:595)\n\tat io.smallrye.mutiny.subscription.MultiSubscriber.onNext(MultiSubscriber.java:61)\n\tat io.smallrye.mutiny.context.ContextPropagationMultiInterceptor$1.lambda$onNext$1(ContextPropagationMultiInterceptor.java:36)\n\tat io.smallrye.context.SmallRyeThreadContext.lambda$withContext$0(SmallRyeThreadContext.java:217)\n\tat io.smallrye.mutiny.context.ContextPropagationMultiInterceptor$1.onNext(ContextPropagationMultiInterceptor.java:36)\n\tat io.smallrye.mutiny.helpers.HalfSerializer.onNext(HalfSerializer.java:31)\n\tat io.smallrye.mutiny.helpers.StrictMultiSubscriber.onItem(StrictMultiSubscriber.java:81)\n\tat io.smallrye.mutiny.operators.multi.MultiMapOp$MapProcessor.onItem(MultiMapOp.java:50)\n\tat io.smallrye.mutiny.subscription.MultiSubscriber.onNext(MultiSubscriber.java:61)\n\tat io.smallrye.mutiny.context.ContextPropagationMultiInterceptor$1.lambda$onNext$1(ContextPropagationMultiInterceptor.java:36)\n\tat io.smallrye.context.SmallRyeThreadContext.lambda$withContext$0(SmallRyeThreadContext.java:217)\n\tat io.smallrye.mutiny.context.ContextPropagationMultiInterceptor$1.onNext(ContextPropagationMultiInterceptor.java:36)\n\tat io.smallrye.mutiny.context.ContextPropagationMultiInterceptor$1.lambda$onNext$1(ContextPropagationMultiInterceptor.java:36)\n\tat io.smallrye.context.SmallRyeThreadContext.lambda$withContext$0(SmallRyeThreadContext.java:217)\n\tat io.smallrye.mutiny.context.ContextPropagationMultiInterceptor$1.onNext(ContextPropagationMultiInterceptor.java:36)\n\tat io.smallrye.mutiny.helpers.HalfSerializer.onNext(HalfSerializer.java:31)\n\tat io.smallrye.mutiny.helpers.StrictMultiSubscriber.onItem(StrictMultiSubscriber.java:81)\n\tat io.smallrye.mutiny.operators.multi.MultiSignalConsumerOp$SignalSubscriber.onItem(MultiSignalConsumerOp.java:161)\n\tat io.smallrye.mutiny.subscription.MultiSubscriber.onNext(MultiSubscriber.java:61)\n\tat io.smallrye.mutiny.context.ContextPropagationMultiInterceptor$1.lambda$onNext$1(ContextPropagationMultiInterceptor.java:36)\n\tat io.smallrye.context.SmallRyeThreadContext.lambda$withContext$0(SmallRyeThreadContext.java:217)\n\tat io.smallrye.mutiny.context.ContextPropagationMultiInterceptor$1.onNext(ContextPropagationMultiInterceptor.java:36)\n\tat io.smallrye.mutiny.context.ContextPropagationMultiInterceptor$1.lambda$onNext$1(ContextPropagationMultiInterceptor.java:36)\n\tat io.smallrye.context.SmallRyeThreadContext.lambda$withContext$0(SmallRyeThreadContext.java:217)\n\tat io.smallrye.mutiny.context.ContextPropagationMultiInterceptor$1.onNext(ContextPropagationMultiInterceptor.java:36)\n\tat io.smallrye.mutiny.helpers.HalfSerializer.onNext(HalfSerializer.java:31)\n\tat io.smallrye.mutiny.helpers.StrictMultiSubscriber.onItem(StrictMultiSubscriber.java:81)\n\tat io.smallrye.mutiny.operators.multi.MultiSignalConsumerOp$SignalSubscriber.onItem(MultiSignalConsumerOp.java:161)\n\tat io.smallrye.mutiny.subscription.MultiSubscriber.onNext(MultiSubscriber.java:61)\n\tat io.smallrye.mutiny.context.ContextPropagationMultiInterceptor$1.lambda$onNext$1(ContextPropagationMultiInterceptor.java:36)\n\tat io.smallrye.context.SmallRyeThreadContext.lambda$withContext$0(SmallRyeThreadContext.java:217)\n\tat io.smallrye.mutiny.context.ContextPropagationMultiInterceptor$1.onNext(ContextPropagationMultiInterceptor.java:36)\n\tat io.smallrye.mutiny.vertx.MultiReadStream.lambda$subscribe$2(MultiReadStream.java:76)\n\tat io.vertx.kafka.client.consumer.impl.KafkaConsumerImpl.lambda$handler$1(KafkaConsumerImpl.java:79)\n\tat io.vertx.kafka.client.consumer.impl.KafkaReadStreamImpl.run(KafkaReadStreamImpl.java:229)\n\tat io.vertx.kafka.client.consumer.impl.KafkaReadStreamImpl.lambda$schedule$8(KafkaReadStreamImpl.java:184)\n\tat io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:366)\n\tat io.vertx.core.impl.EventLoopContext.lambda$executeAsync$0(EventLoopContext.java:38)\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.base/java.lang.Thread.run(Thread.java:834)\n\n\nThis happens because when resuming the Vert.x consumer it set sets the fetch amount to Long.MAX_VALUE\nhttps://github.com/vert-x3/vertx-kafka-client/blob/3.9.1/src/main/java/io/vertx/kafka/client/consumer/impl/KafkaReadStreamImpl.java#L571\nThere's also a less severe side effect when partitions is 1. Because of the MAX_VALUE fetch amount it will consume more than 1 message concurrently when using a worker thread to perform blocking operations, ex:\n    @Incoming(\"topic-in\")\n    public CompletionStage<Void> consume(IncomingKafkaRecord<String, String> record) {\n        return CompletableFuture.runAsync(() -> {\n            // perform blocking code.\n        });\n    }\n\nWithout a re-balance listener it will process the messages one at a time (MultiFlapMapOp#drainLoop always ends up requesting 1 in this case). Configuring a consumer re-balance listener shouldn't affect this behavior.\nWhen partitions is 1 the the fetch amount should be 1 and when greater than 1 the amount should be 128. This resolves both issues.\nWhat I don't like about this fix is that I arrived at these values empirically. It seems like this bug resides in the Vert.x Kafka code. Maybe resume should be setting the fetch amount to the previous non zero fetch amount before pausing. Something like:\n  @Override\n  public KafkaReadStreamImpl<K, V> resume() {\n    return fetch(this.previousFetchAmountBeforePausing.get());\n  }", "createdAt": "2020-07-20T07:10:50Z", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/672", "merged": true, "mergeCommit": {"oid": "6bd9141d81cf09482d7232a9e00e4f1ecf119c50"}, "closed": true, "closedAt": "2020-09-20T17:39:12Z", "author": {"login": "pcasaes"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc2sPlJABqjM1NjQyNjE0ODU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdKS2wvgBqjM3ODQ3NzMxMjY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c5b22117a17047f01ce1e725345617a0e19eb96c", "author": {"user": {"login": "pcasaes", "name": "Paulo Casaes"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/c5b22117a17047f01ce1e725345617a0e19eb96c", "committedDate": "2020-07-20T06:50:18Z", "message": "Set fetch size to before pause value when resuming kafka source"}, "afterCommit": {"oid": "8752c5943fb561d653d9bb9f187895781d2f3c7d", "author": {"user": {"login": "pcasaes", "name": "Paulo Casaes"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/8752c5943fb561d653d9bb9f187895781d2f3c7d", "committedDate": "2020-07-20T07:10:41Z", "message": "Set fetch size to before pause value when resuming kafka source"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMzQ5ODE5", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/672#pullrequestreview-451349819", "createdAt": "2020-07-20T07:14:42Z", "commit": {"oid": "8752c5943fb561d653d9bb9f187895781d2f3c7d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNzoxNDo0MlrOGz8cTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNzoxNToyM1rOGz8eJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzEyMDg0Nw==", "bodyText": "Why 128?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/672#discussion_r457120847", "createdAt": "2020-07-20T07:14:42Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -129,6 +129,10 @@ public KafkaSource(Vertx vertx,\n                                                     \"10000\")))\n                             + 11_000L; // it's possible that it might expire 10 seconds before when we need it to\n \n+                    // When resuming the consumer we must set the fetch amount to what it was before pausing\n+                    // When partitions is greater than 1 this value will be 128 otherwise it will be 1.\n+                    final int resumeFetchAmount = config.getPartitions() > 1 ? 128 : 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8752c5943fb561d653d9bb9f187895781d2f3c7d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzEyMTMxOQ==", "bodyText": "What happens when the amount is consumed? Would it get more?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/672#discussion_r457121319", "createdAt": "2020-07-20T07:15:23Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -140,11 +144,11 @@ public KafkaSource(Vertx vertx,\n                                 .with(\n                                         a -> {\n                                             log.executedConsumerAssignedRebalanceListener(group);\n-                                            kafkaConsumer.resume();\n+                                            kafkaConsumer.fetch(resumeFetchAmount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8752c5943fb561d653d9bb9f187895781d2f3c7d"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MzAxNDM2", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/672#pullrequestreview-468301436", "createdAt": "2020-08-17T09:19:52Z", "commit": {"oid": "8752c5943fb561d653d9bb9f187895781d2f3c7d"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "194fc2c961cacfb5f0395f1ad1a6fb1d6e47c8bc", "author": {"user": {"login": "pcasaes", "name": "Paulo Casaes"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/194fc2c961cacfb5f0395f1ad1a6fb1d6e47c8bc", "committedDate": "2020-09-19T04:54:21Z", "message": "Set fetch size to before pause value when resuming kafka source"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8752c5943fb561d653d9bb9f187895781d2f3c7d", "author": {"user": {"login": "pcasaes", "name": "Paulo Casaes"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/8752c5943fb561d653d9bb9f187895781d2f3c7d", "committedDate": "2020-07-20T07:10:41Z", "message": "Set fetch size to before pause value when resuming kafka source"}, "afterCommit": {"oid": "194fc2c961cacfb5f0395f1ad1a6fb1d6e47c8bc", "author": {"user": {"login": "pcasaes", "name": "Paulo Casaes"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/194fc2c961cacfb5f0395f1ad1a6fb1d6e47c8bc", "committedDate": "2020-09-19T04:54:21Z", "message": "Set fetch size to before pause value when resuming kafka source"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2313, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}