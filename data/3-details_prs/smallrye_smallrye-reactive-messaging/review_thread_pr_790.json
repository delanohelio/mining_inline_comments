{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3MzkwNDUz", "number": 790, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMzowOTo1N1rOEqFzcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMzo0MDoxMlrOEqF8Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTcwNzM4OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMzowOTo1N1rOHcHgOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxNDo1MTo0MlrOHcIGCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0NTExMw==", "bodyText": "Why is turning the keySet into a HashSet necessary?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499245113", "createdAt": "2020-10-04T13:09:57Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions\n+        for (TopicPartition partition : new HashSet<>(offsetStores.keySet())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0NTI1Mw==", "bodyText": "Because the key set is a live view, and removing from it may trigger a ConcurrentModificationException.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499245253", "createdAt": "2020-10-04T13:11:37Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions\n+        for (TopicPartition partition : new HashSet<>(offsetStores.keySet())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0NTExMw=="}, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0ODYwOQ==", "bodyText": "But it's all running in the same Vert.X context, no?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499248609", "createdAt": "2020-10-04T13:45:31Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions\n+        for (TopicPartition partition : new HashSet<>(offsetStores.keySet())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0NTExMw=="}, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0ODgwOQ==", "bodyText": "It's my understanding that the Vert.X Kafka Client calls revoked and assigned within the context.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499248809", "createdAt": "2020-10-04T13:48:10Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions\n+        for (TopicPartition partition : new HashSet<>(offsetStores.keySet())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0NTExMw=="}, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1MzczOA==", "bodyText": "No, it can come from the remove just below. It's always safer to create a copy if you want to remove. Another solution would be to create a temporary Set, collect the keys to remove and remove outside of the loop. Both require an additional set, but this variant avoids another loop.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499253738", "createdAt": "2020-10-04T14:41:01Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions\n+        for (TopicPartition partition : new HashSet<>(offsetStores.keySet())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0NTExMw=="}, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1NDc5NQ==", "bodyText": "Gotcha!", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499254795", "createdAt": "2020-10-04T14:51:42Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions\n+        for (TopicPartition partition : new HashSet<>(offsetStores.keySet())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0NTExMw=="}, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTcxOTY3OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMzoyNzoyNlrOHcHmiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxNToxMzo1MFrOHcIO1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0NjczMQ==", "bodyText": "This is something I got wrong. From the documentation:\n\nThe list of partitions that are now assigned to the consumer (previously owned partitions will NOT be included, i.e. this list will only include newly added partitions)\n\nhttps://kafka.apache.org/24/javadoc/org/apache/kafka/clients/consumer/ConsumerRebalanceListener.html#onPartitionsAssigned-java.util.Collection-\nThis needs to be used in conjunction with revoked to get the full picture\n\npartitions - The list of partitions that were assigned to the consumer and now have been reassigned to other consumers (may not include all currently assigned partitions, i.e. there may still be some partitions left)\n\nhttps://kafka.apache.org/24/javadoc/org/apache/kafka/clients/consumer/ConsumerRebalanceListener.html#onPartitionsRevoked-java.util.Collection-\nIf the idea is to remove partitions from the store then that should be done in partitionsRevoked.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499246731", "createdAt": "2020-10-04T13:27:26Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1NDA5OQ==", "bodyText": "Hum... ok, I should not remove the partitions.\nHowever, before we were Clearing the full store was wrong.\nThe problem is that in some cases I received records BEFORE this callback is called. This is because of the scheduling in the event loop.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499254099", "createdAt": "2020-10-04T14:44:34Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0NjczMQ=="}, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1NDQxNg==", "bodyText": "Yeah, it was wrong.\n\nThis is something I got wrong", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499254416", "createdAt": "2020-10-04T14:48:08Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0NjczMQ=="}, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1NjcxNA==", "bodyText": "The problem is that in some cases I received records BEFORE this callback is called.\n\nPerhaps we should use the pause/fetch strategy we use for the user supplied consumer re-balance as well. In this case we'd have to return a Uni.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499256714", "createdAt": "2020-10-04T15:10:18Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0NjczMQ=="}, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1NzA0NA==", "bodyText": "That would not always work, I've seen this issue when the application starts, where we are not in a pause/resume cycle.\nLet's revisit this when we have the blocking callbacks. We are trying to work around an issue that should not be an issue...", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499257044", "createdAt": "2020-10-04T15:13:50Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0NjczMQ=="}, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTcxOTg2OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMzoyNzo0OFrOHcHmpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxNDo1MTo0OFrOHcIGGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0Njc1OQ==", "bodyText": "Concerning the comment left on the partitionsAssigned method. After committing we should remove partitions from the store.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499246759", "createdAt": "2020-10-04T13:27:48Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions\n+        for (TopicPartition partition : new HashSet<>(offsetStores.keySet())) {\n+            if (!partitions.contains(partition)) {\n+                offsetStores.remove(partition);\n+            }\n+        }\n+\n+        // We cannot commit the removed offsets as we are not assigned to this partition anymore.\n+\n+        if (!offsetStores.isEmpty()) {\n+            startFlushAndCheckHealthTimer();\n+        }\n+    }\n \n+    /**\n+     * Revoked partitions.\n+     * This method is called from a Vert.x event loop (the one used by the Kafka client)\n+     *\n+     * @param partitions the partitions that we will no longer receive\n+     */\n+    @Override\n+    public void partitionsRevoked(Set<TopicPartition> partitions) {\n         stopFlushAndCheckHealthTimer();\n \n-        if (!partitions.isEmpty()) {\n+        // Remove all handled partitions that are not in the given list of partitions\n+        Map<TopicPartition, OffsetAndMetadata> toCommit = new HashMap<>();\n+        for (TopicPartition partition : new HashSet<>(offsetStores.keySet())) {\n+            if (!partitions.contains(partition)) {\n+                OffsetStore store = offsetStores.remove(partition);\n+                long largestOffset = store.clearLesserSequentiallyProcessedOffsetsAndReturnLargestOffset();\n+                if (largestOffset > -1) {\n+                    toCommit.put(partition, new OffsetAndMetadata(largestOffset + 1L, null));\n+                }\n+            }\n+        }\n+\n+        if (!toCommit.isEmpty()) {\n+            // Commit the offsets\n+            consumer.getDelegate().commit(toCommit);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1NDIwOQ==", "bodyText": "They have been already removed in OffsetStore store = offsetStores.remove(partition);\nThe commit happens after the removal.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499254209", "createdAt": "2020-10-04T14:45:50Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions\n+        for (TopicPartition partition : new HashSet<>(offsetStores.keySet())) {\n+            if (!partitions.contains(partition)) {\n+                offsetStores.remove(partition);\n+            }\n+        }\n+\n+        // We cannot commit the removed offsets as we are not assigned to this partition anymore.\n+\n+        if (!offsetStores.isEmpty()) {\n+            startFlushAndCheckHealthTimer();\n+        }\n+    }\n \n+    /**\n+     * Revoked partitions.\n+     * This method is called from a Vert.x event loop (the one used by the Kafka client)\n+     *\n+     * @param partitions the partitions that we will no longer receive\n+     */\n+    @Override\n+    public void partitionsRevoked(Set<TopicPartition> partitions) {\n         stopFlushAndCheckHealthTimer();\n \n-        if (!partitions.isEmpty()) {\n+        // Remove all handled partitions that are not in the given list of partitions\n+        Map<TopicPartition, OffsetAndMetadata> toCommit = new HashMap<>();\n+        for (TopicPartition partition : new HashSet<>(offsetStores.keySet())) {\n+            if (!partitions.contains(partition)) {\n+                OffsetStore store = offsetStores.remove(partition);\n+                long largestOffset = store.clearLesserSequentiallyProcessedOffsetsAndReturnLargestOffset();\n+                if (largestOffset > -1) {\n+                    toCommit.put(partition, new OffsetAndMetadata(largestOffset + 1L, null));\n+                }\n+            }\n+        }\n+\n+        if (!toCommit.isEmpty()) {\n+            // Commit the offsets\n+            consumer.getDelegate().commit(toCommit);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0Njc1OQ=="}, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1NDgxMQ==", "bodyText": "I see. nice!", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499254811", "createdAt": "2020-10-04T14:51:48Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions\n+        for (TopicPartition partition : new HashSet<>(offsetStores.keySet())) {\n+            if (!partitions.contains(partition)) {\n+                offsetStores.remove(partition);\n+            }\n+        }\n+\n+        // We cannot commit the removed offsets as we are not assigned to this partition anymore.\n+\n+        if (!offsetStores.isEmpty()) {\n+            startFlushAndCheckHealthTimer();\n+        }\n+    }\n \n+    /**\n+     * Revoked partitions.\n+     * This method is called from a Vert.x event loop (the one used by the Kafka client)\n+     *\n+     * @param partitions the partitions that we will no longer receive\n+     */\n+    @Override\n+    public void partitionsRevoked(Set<TopicPartition> partitions) {\n         stopFlushAndCheckHealthTimer();\n \n-        if (!partitions.isEmpty()) {\n+        // Remove all handled partitions that are not in the given list of partitions\n+        Map<TopicPartition, OffsetAndMetadata> toCommit = new HashMap<>();\n+        for (TopicPartition partition : new HashSet<>(offsetStores.keySet())) {\n+            if (!partitions.contains(partition)) {\n+                OffsetStore store = offsetStores.remove(partition);\n+                long largestOffset = store.clearLesserSequentiallyProcessedOffsetsAndReturnLargestOffset();\n+                if (largestOffset > -1) {\n+                    toCommit.put(partition, new OffsetAndMetadata(largestOffset + 1L, null));\n+                }\n+            }\n+        }\n+\n+        if (!toCommit.isEmpty()) {\n+            // Commit the offsets\n+            consumer.getDelegate().commit(toCommit);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0Njc1OQ=="}, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTcyMTQ0OnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMzoyOToyN1rOHcHndQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxNjoxMDo1OVrOHcIj6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0Njk2NQ==", "bodyText": "If we are not adding partitions to the store in this method then we need to start the time if either that store or partitions aren't empty.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499246965", "createdAt": "2020-10-04T13:29:27Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions\n+        for (TopicPartition partition : new HashSet<>(offsetStores.keySet())) {\n+            if (!partitions.contains(partition)) {\n+                offsetStores.remove(partition);\n+            }\n+        }\n+\n+        // We cannot commit the removed offsets as we are not assigned to this partition anymore.\n+\n+        if (!offsetStores.isEmpty()) {\n+            startFlushAndCheckHealthTimer();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1NDI4MQ==", "bodyText": "Yes!", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499254281", "createdAt": "2020-10-04T14:46:41Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions\n+        for (TopicPartition partition : new HashSet<>(offsetStores.keySet())) {\n+            if (!partitions.contains(partition)) {\n+                offsetStores.remove(partition);\n+            }\n+        }\n+\n+        // We cannot commit the removed offsets as we are not assigned to this partition anymore.\n+\n+        if (!offsetStores.isEmpty()) {\n+            startFlushAndCheckHealthTimer();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0Njk2NQ=="}, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI2MjQ0Mg==", "bodyText": "Done!", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499262442", "createdAt": "2020-10-04T16:10:59Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -105,11 +104,50 @@ private OffsetStore getOffsetStore(TopicPartition topicPartition) {\n      */\n     @Override\n     public void partitionsAssigned(Set<TopicPartition> partitions) {\n-        offsetStores.clear();\n+        stopFlushAndCheckHealthTimer();\n+\n+        // Remove all handled partitions that are not in the given list of partitions\n+        for (TopicPartition partition : new HashSet<>(offsetStores.keySet())) {\n+            if (!partitions.contains(partition)) {\n+                offsetStores.remove(partition);\n+            }\n+        }\n+\n+        // We cannot commit the removed offsets as we are not assigned to this partition anymore.\n+\n+        if (!offsetStores.isEmpty()) {\n+            startFlushAndCheckHealthTimer();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0Njk2NQ=="}, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTcyNDAzOnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMzozMjo1OFrOHcHozQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMzozMjo1OFrOHcHozQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0NzMwOQ==", "bodyText": "Nice!", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499247309", "createdAt": "2020-10-04T13:32:58Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -282,13 +320,54 @@ boolean hasTooManyMessagesWithoutAck() {\n \n     public static class TooManyMessagesWithoutAckException extends Exception {\n         public TooManyMessagesWithoutAckException() {\n-            super(\"Too Many Messages without Ack\");\n+            super(\"Too Many Messages without acknowledgement\");\n         }\n     }\n \n     @Override\n     public void terminate() {\n-        // TODO Force commit sync.\n+        commitAllAndAwait();\n+        offsetStores.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTcyOTUxOnYy", "diffSide": "RIGHT", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/ContextHolder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMzo0MDoxMlrOHcHrwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxNDo1MDozN1rOHcIFrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0ODA2Ng==", "bodyText": "Will we be living with this as a final solution or are we going to work with Vert.X to get access to the context properly?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499248066", "createdAt": "2020-10-04T13:40:12Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/ContextHolder.java", "diffHunk": "@@ -15,24 +19,29 @@ public ContextHolder(Vertx vertx) {\n         this.vertx = vertx;\n     }\n \n-    public Context getContext() {\n-        Context ctx = this.context;\n-        if (ctx == null) {\n-            synchronized (this) {\n-                ctx = this.context;\n-                if (ctx == null) {\n-                    this.context = ctx = vertx.getOrCreateContext();\n-                }\n+    public void capture(KafkaReadStream<?, ?> stream) {\n+        if (!(stream instanceof KafkaReadStreamImpl)) {\n+            throw new IllegalArgumentException(\"Cannot capture the context - not a KafkaReadStreamImpl\");\n+        } else {\n+            try {\n+                Field field = KafkaReadStreamImpl.class.getDeclaredField(\"context\");\n+                field.setAccessible(true);\n+                context = new Context((io.vertx.core.Context) field.get(stream));\n+            } catch (Exception e) {\n+                throw new IllegalArgumentException(\"Cannot capture the context\", e);\n             }\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1NDcwMw==", "bodyText": "That's a good question.\nWe are going to go with this for now.\nThere are multiple things:\n\nWe need to switch to a blocking rebalance listener - this is done using a hack too (see my other branch - that need to be reworked completely BTW).\nWe only use the Vert.x client to get a Multi of Record. That part is not that complicated, so starting to see if we need to remove it completely or not.\nThis code is not changed in Vert.x 3.9 nor Vert.x 4.x (for now).\n\nI've done a list of improvements to applied in the upstream Vert.x client. Exposing the context needs to be added. Generally, we don't do this in Vert.x as we expect the client creation to be called form an event loop (and so you can capture the context from a creation site), but in our case, it's not the case, and the client creates its own context.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/790#discussion_r499254703", "createdAt": "2020-10-04T14:50:37Z", "author": {"login": "cescoffier"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/ContextHolder.java", "diffHunk": "@@ -15,24 +19,29 @@ public ContextHolder(Vertx vertx) {\n         this.vertx = vertx;\n     }\n \n-    public Context getContext() {\n-        Context ctx = this.context;\n-        if (ctx == null) {\n-            synchronized (this) {\n-                ctx = this.context;\n-                if (ctx == null) {\n-                    this.context = ctx = vertx.getOrCreateContext();\n-                }\n+    public void capture(KafkaReadStream<?, ?> stream) {\n+        if (!(stream instanceof KafkaReadStreamImpl)) {\n+            throw new IllegalArgumentException(\"Cannot capture the context - not a KafkaReadStreamImpl\");\n+        } else {\n+            try {\n+                Field field = KafkaReadStreamImpl.class.getDeclaredField(\"context\");\n+                field.setAccessible(true);\n+                context = new Context((io.vertx.core.Context) field.get(stream));\n+            } catch (Exception e) {\n+                throw new IllegalArgumentException(\"Cannot capture the context\", e);\n             }\n         }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0ODA2Ng=="}, "originalCommit": {"oid": "db6983a533f68c1d8974a2e7623d78474e4b4d37"}, "originalPosition": 33}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 58, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}