{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxOTkwNjkz", "number": 774, "title": "Improve the latest commit strategy", "bodyText": "Instead of committing the last polled offset, commit for each partition the higher offset.\nAlso, improve the tests and fix unknown properties in the admin client.\n@pcasaes can you have a look?", "createdAt": "2020-09-23T19:22:15Z", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774", "merged": true, "mergeCommit": {"oid": "0c433e4be2a63395cf07f2ec619068c2725b17c8"}, "closed": true, "closedAt": "2020-09-27T07:55:52Z", "author": {"login": "cescoffier"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdMCWB-AFqTQ5NTY0NjM4OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdMWnQbgBqjM4MDc5NzUyMTk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NjQ2Mzg4", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#pullrequestreview-495646388", "createdAt": "2020-09-24T14:40:31Z", "commit": {"oid": "37ce2975c49568828b6c3cbadb9ae2ccfc834bd5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNDo0MDozMlrOHXeQhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNDo0Nzo0NVrOHXemqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM3NTA0NQ==", "bodyText": "offsets isn't threadsafe. The user might call the Message#ack method inside  a worker thread. It's the reason why on the Throttled strategy we run the handle code inside the context's event thread.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494375045", "createdAt": "2020-09-24T14:40:32Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaLatestCommit.java", "diffHunk": "@@ -18,13 +23,33 @@\n public class KafkaLatestCommit implements KafkaCommitHandler {\n \n     private final KafkaConsumer<?, ?> consumer;\n+    private final Map<TopicPartition, Long> offsets = new HashMap<>();\n \n-    public KafkaLatestCommit(KafkaConsumer<?, ?> consumer) {\n-        this.consumer = consumer;\n+    public KafkaLatestCommit(io.vertx.mutiny.kafka.client.consumer.KafkaConsumer<?, ?> consumer) {\n+        this.consumer = (KafkaConsumer<?, ?>) consumer.getDelegate();\n     }\n \n     @Override\n     public <K, V> CompletionStage<Void> handle(IncomingKafkaRecord<K, V> record) {\n-        return consumer.commit().subscribeAsCompletionStage();\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+        Map<TopicPartition, OffsetAndMetadata> map = new HashMap<>();\n+        TopicPartition key = new TopicPartition(record.getTopic(), record.getPartition());\n+        Long last = offsets.get(key);\n+        // Verify that the latest committed offset before this one.\n+        if (last == null || last < record.getOffset() + 1) {\n+            offsets.put(key, record.getOffset() + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37ce2975c49568828b6c3cbadb9ae2ccfc834bd5"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM3OTYxNw==", "bodyText": "This has always bothered me about this strategy. Committing on every message causes High load on the cluster. Maybe we should add a warning to the documentation.\nAlso, what's the implication of completing exceptionally here?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494379617", "createdAt": "2020-09-24T14:46:25Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaLatestCommit.java", "diffHunk": "@@ -18,13 +23,33 @@\n public class KafkaLatestCommit implements KafkaCommitHandler {\n \n     private final KafkaConsumer<?, ?> consumer;\n+    private final Map<TopicPartition, Long> offsets = new HashMap<>();\n \n-    public KafkaLatestCommit(KafkaConsumer<?, ?> consumer) {\n-        this.consumer = consumer;\n+    public KafkaLatestCommit(io.vertx.mutiny.kafka.client.consumer.KafkaConsumer<?, ?> consumer) {\n+        this.consumer = (KafkaConsumer<?, ?>) consumer.getDelegate();\n     }\n \n     @Override\n     public <K, V> CompletionStage<Void> handle(IncomingKafkaRecord<K, V> record) {\n-        return consumer.commit().subscribeAsCompletionStage();\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+        Map<TopicPartition, OffsetAndMetadata> map = new HashMap<>();\n+        TopicPartition key = new TopicPartition(record.getTopic(), record.getPartition());\n+        Long last = offsets.get(key);\n+        // Verify that the latest committed offset before this one.\n+        if (last == null || last < record.getOffset() + 1) {\n+            offsets.put(key, record.getOffset() + 1);\n+            map.put(key, new OffsetAndMetadata(record.getOffset() + 1, null));\n+\n+            consumer.commit(map, ar -> {\n+                if (ar.failed()) {\n+                    future.completeExceptionally(ar.cause());\n+                } else {\n+                    future.complete(null);\n+                }\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37ce2975c49568828b6c3cbadb9ae2ccfc834bd5"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM4MDcxMg==", "bodyText": "Very nice!", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494380712", "createdAt": "2020-09-24T14:47:45Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/commit/CommitStrategiesTest.java", "diffHunk": "@@ -0,0 +1,310 @@\n+package io.smallrye.reactive.messaging.kafka.commit;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.lang.reflect.Field;\n+import java.util.*;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.UnsatisfiedResolutionException;\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.inject.Named;\n+\n+import io.smallrye.reactive.messaging.kafka.IncomingKafkaRecordMetadata;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.MockConsumer;\n+import org.apache.kafka.clients.consumer.OffsetAndMetadata;\n+import org.apache.kafka.clients.consumer.OffsetResetStrategy;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.kafka.KafkaConnectorIncomingConfiguration;\n+import io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener;\n+import io.smallrye.reactive.messaging.kafka.base.MapBasedConfig;\n+import io.smallrye.reactive.messaging.kafka.base.WeldTestBase;\n+import io.smallrye.reactive.messaging.kafka.impl.KafkaSource;\n+import io.vertx.kafka.client.consumer.KafkaReadStream;\n+import io.vertx.mutiny.core.Vertx;\n+import io.vertx.mutiny.kafka.client.consumer.KafkaConsumer;\n+\n+public class CommitStrategiesTest extends WeldTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37ce2975c49568828b6c3cbadb9ae2ccfc834bd5"}, "originalPosition": 38}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "37ce2975c49568828b6c3cbadb9ae2ccfc834bd5", "author": {"user": {"login": "cescoffier", "name": "Clement Escoffier"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/37ce2975c49568828b6c3cbadb9ae2ccfc834bd5", "committedDate": "2020-09-23T19:20:41Z", "message": "Fix the latest commit strategy - commit the offset from the received message and keep track to not commit previous offset."}, "afterCommit": {"oid": "37f6ba5c88f4976c590965584fdf01ed3cb4959b", "author": {"user": {"login": "cescoffier", "name": "Clement Escoffier"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/37f6ba5c88f4976c590965584fdf01ed3cb4959b", "committedDate": "2020-09-24T17:25:27Z", "message": "Fix the latest commit strategy - commit the offset from the received message and keep track to not commit previous offset."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1ODA4ODEy", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#pullrequestreview-495808812", "createdAt": "2020-09-24T17:46:09Z", "commit": {"oid": "37f6ba5c88f4976c590965584fdf01ed3cb4959b"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1OTA1MzUw", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#pullrequestreview-495905350", "createdAt": "2020-09-24T19:55:46Z", "commit": {"oid": "37f6ba5c88f4976c590965584fdf01ed3cb4959b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxOTo1NTo0N1rOHXqcjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMjo1OTowNFrOHXzSSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU3NDczMg==", "bodyText": "Why would it run on another context? Doesn't vert.x assure that the timer runs on the same context it was created on?", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494574732", "createdAt": "2020-09-24T19:55:47Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -158,27 +160,37 @@ private void startFlushAndCheckHealthTimer() {\n \n     }\n \n-    private void flushAndCheckHealth(long timerId) {\n-        Map<TopicPartition, Long> offsetsMapping = clearLesserSequentiallyProcessedOffsetsAndReturnLargestOffsetMapping();\n-\n-        if (!offsetsMapping.isEmpty()) {\n-            Map<TopicPartition, OffsetAndMetadata> offsets = offsetsMapping\n-                    .entrySet()\n-                    .stream()\n-                    .collect(Collectors.toMap(Map.Entry::getKey,\n-                            e -> new OffsetAndMetadata().setOffset(e.getValue() + 1L)));\n-            consumer.getDelegate().commit(offsets, a -> this.startFlushAndCheckHealthTimer());\n-        } else {\n-            this.startFlushAndCheckHealthTimer();\n+    private synchronized Context getContext() {\n+        if (context == null) {\n+            context = vertx.getOrCreateContext();\n         }\n+        return context;\n+    }\n+\n+    private void flushAndCheckHealth(long timerId) {\n+        // The timer may be on another context, so make sure we are on the right one to access the store.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37f6ba5c88f4976c590965584fdf01ed3cb4959b"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcxOTU2MA==", "bodyText": "I ran a test locally on a project and it works perfectly!\nI do have one final suggestion. context here is loaded only once, so using a lock every time we acquire seems heavy handed. What do you think about using a double checked lock? We would have to change context to be volatile on line 51\nprivate volatile Context context;\n\nAnd then rewrite this method\n    private Context getContext() {\n        Context ctx = this.context;\n        if (ctx == null) {\n            synchronized (this) {\n                ctx = this.context;\n                if (ctx == null) {\n                    this.context = ctx = vertx.getOrCreateContext();\n                }\n            }\n        }\n        return ctx;\n    }\n\nWe could do the same with the latest strategy - maybe even abstract it to reduce duplicate code.\nTheoretically we would see a 100x performance gain.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494719560", "createdAt": "2020-09-25T02:59:04Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -158,27 +160,37 @@ private void startFlushAndCheckHealthTimer() {\n \n     }\n \n-    private void flushAndCheckHealth(long timerId) {\n-        Map<TopicPartition, Long> offsetsMapping = clearLesserSequentiallyProcessedOffsetsAndReturnLargestOffsetMapping();\n-\n-        if (!offsetsMapping.isEmpty()) {\n-            Map<TopicPartition, OffsetAndMetadata> offsets = offsetsMapping\n-                    .entrySet()\n-                    .stream()\n-                    .collect(Collectors.toMap(Map.Entry::getKey,\n-                            e -> new OffsetAndMetadata().setOffset(e.getValue() + 1L)));\n-            consumer.getDelegate().commit(offsets, a -> this.startFlushAndCheckHealthTimer());\n-        } else {\n-            this.startFlushAndCheckHealthTimer();\n+    private synchronized Context getContext() {\n+        if (context == null) {\n+            context = vertx.getOrCreateContext();\n         }\n+        return context;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37f6ba5c88f4976c590965584fdf01ed3cb4959b"}, "originalPosition": 162}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "37f6ba5c88f4976c590965584fdf01ed3cb4959b", "author": {"user": {"login": "cescoffier", "name": "Clement Escoffier"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/37f6ba5c88f4976c590965584fdf01ed3cb4959b", "committedDate": "2020-09-24T17:25:27Z", "message": "Fix the latest commit strategy - commit the offset from the received message and keep track to not commit previous offset."}, "afterCommit": {"oid": "734be1be05620cda1fae39b070656e1169d414e9", "author": {"user": {"login": "cescoffier", "name": "Clement Escoffier"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/734be1be05620cda1fae39b070656e1169d414e9", "committedDate": "2020-09-25T07:22:56Z", "message": "Improve context management in commit strategies"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NDIyMjMw", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#pullrequestreview-496422230", "createdAt": "2020-09-25T13:32:53Z", "commit": {"oid": "734be1be05620cda1fae39b070656e1169d414e9"}, "state": "DISMISSED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMzozMjo1M1rOHYDy_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMzozMjo1M1rOHYDy_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk5MDA3OQ==", "bodyText": "Very nice!!!!", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494990079", "createdAt": "2020-09-25T13:32:53Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/ContextHolder.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package io.smallrye.reactive.messaging.kafka.commit;\n+\n+import io.vertx.mutiny.core.Context;\n+import io.vertx.mutiny.core.Vertx;\n+\n+/**\n+ * A class holding a vert.x context to make sure methods are always run from the same one.\n+ */\n+public class ContextHolder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734be1be05620cda1fae39b070656e1169d414e9"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NDMzMDg4", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#pullrequestreview-496433088", "createdAt": "2020-09-25T13:45:34Z", "commit": {"oid": "734be1be05620cda1fae39b070656e1169d414e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMzo0NTozNFrOHYES5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMzo0NTozNFrOHYES5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk5ODI0NA==", "bodyText": "This pattern comes from\nhttps://www.oracle.com/technical-resources/articles/javase/bloch-effective-08-qa.html\nUnder: Best Practices for Lazy Initialization\nIt's also referenced in Java Concurrency in Practice by Goetz et al in section 16.2.4\n\nSubsequent changes in the JMM... have enabled DLC to work if resource is made volatile.", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494998244", "createdAt": "2020-09-25T13:45:34Z", "author": {"login": "pcasaes"}, "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/ContextHolder.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package io.smallrye.reactive.messaging.kafka.commit;\n+\n+import io.vertx.mutiny.core.Context;\n+import io.vertx.mutiny.core.Vertx;\n+\n+/**\n+ * A class holding a vert.x context to make sure methods are always run from the same one.\n+ */\n+public class ContextHolder {\n+\n+    protected final Vertx vertx;\n+    protected volatile Context context;\n+\n+    public ContextHolder(Vertx vertx) {\n+        this.vertx = vertx;\n+    }\n+\n+    public Context getContext() {\n+        Context ctx = this.context;\n+        if (ctx == null) {\n+            synchronized (this) {\n+                ctx = this.context;\n+                if (ctx == null) {\n+                    this.context = ctx = vertx.getOrCreateContext();\n+                }\n+            }\n+        }\n+        return ctx;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734be1be05620cda1fae39b070656e1169d414e9"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58cf91ec37836642d53fdf8abb11d2a8047ceba7", "author": {"user": {"login": "cescoffier", "name": "Clement Escoffier"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/58cf91ec37836642d53fdf8abb11d2a8047ceba7", "committedDate": "2020-09-25T13:54:20Z", "message": "If not started, start the vert.x timer on message reception."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc8b6427c62b6fd075a580d8e8d4cbc786556494", "author": {"user": {"login": "cescoffier", "name": "Clement Escoffier"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/fc8b6427c62b6fd075a580d8e8d4cbc786556494", "committedDate": "2020-09-25T13:56:11Z", "message": "Filter out unknown properties"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7733c1303d6532ea0b8ce2970310547821ffacb4", "author": {"user": {"login": "cescoffier", "name": "Clement Escoffier"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/7733c1303d6532ea0b8ce2970310547821ffacb4", "committedDate": "2020-09-25T13:57:36Z", "message": "Fix the latest commit strategy - commit the offset from the received message and keep track to not commit previous offset."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "615e4648405e038462d53d144204f0f2d86bf794", "author": {"user": {"login": "cescoffier", "name": "Clement Escoffier"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/615e4648405e038462d53d144204f0f2d86bf794", "committedDate": "2020-09-25T13:57:38Z", "message": "Improve context management in commit strategies"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "734be1be05620cda1fae39b070656e1169d414e9", "author": {"user": {"login": "cescoffier", "name": "Clement Escoffier"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/734be1be05620cda1fae39b070656e1169d414e9", "committedDate": "2020-09-25T07:22:56Z", "message": "Improve context management in commit strategies"}, "afterCommit": {"oid": "615e4648405e038462d53d144204f0f2d86bf794", "author": {"user": {"login": "cescoffier", "name": "Clement Escoffier"}}, "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/615e4648405e038462d53d144204f0f2d86bf794", "committedDate": "2020-09-25T13:57:38Z", "message": "Improve context management in commit strategies"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2270, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}