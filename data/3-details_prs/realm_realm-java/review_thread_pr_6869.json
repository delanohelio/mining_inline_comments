{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwNzUyODc0", "number": 6869, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMzozNTowN1rOD-OFLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo1MjowOFrOD_T-wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTY5MDA1OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsMongoCollection.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMzozNTowN1rOGYL9lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwOTozMTo0NFrOGZ7EaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAxNDk5Ng==", "bodyText": "I made the assumption returning a BsonArray to Java was the least annoying option given my ignorance on how to smartly work with the JNI. This solution isn't my cup of tea, as it relies on knowing what's in every array position in Java. I'm all open to change this.", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r428014996", "createdAt": "2020-05-20T13:35:07Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsMongoCollection.cpp", "diffHunk": "@@ -69,6 +70,22 @@ static std::function<jobject(JNIEnv*, std::vector<ObjectId>)> collection_mapper_\n     return arr;\n };\n \n+static std::function<jobject(JNIEnv*, RemoteMongoCollection::RemoteUpdateResult)> collection_mapper_update = [](JNIEnv* env, RemoteMongoCollection::RemoteUpdateResult result) {\n+    Bson matched_count(result.matched_count);\n+    Bson modified_count(result.modified_count);\n+    Bson upserted_value;\n+    if (result.upserted_id) {\n+        upserted_value = new Bson(result.upserted_id.value());\n+    }\n+    // FIXME: maybe not the most efficient way. Suggestions?\n+    BsonArray result_values { matched_count, modified_count, upserted_value };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0861c8ff2d04d7fe9d64161750e8e94c58e42260"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc3NzIzOA==", "bodyText": "As it is part of a remote request, I would consider it reasonable to use a Bson, but you could consider using a document instead, as this would make it easier to maintain the \"protocol\".\nOtherwise you could define the response class in Java and construct the Java object from the arguments.", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429777238", "createdAt": "2020-05-25T07:34:51Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsMongoCollection.cpp", "diffHunk": "@@ -69,6 +70,22 @@ static std::function<jobject(JNIEnv*, std::vector<ObjectId>)> collection_mapper_\n     return arr;\n };\n \n+static std::function<jobject(JNIEnv*, RemoteMongoCollection::RemoteUpdateResult)> collection_mapper_update = [](JNIEnv* env, RemoteMongoCollection::RemoteUpdateResult result) {\n+    Bson matched_count(result.matched_count);\n+    Bson modified_count(result.modified_count);\n+    Bson upserted_value;\n+    if (result.upserted_id) {\n+        upserted_value = new Bson(result.upserted_id.value());\n+    }\n+    // FIXME: maybe not the most efficient way. Suggestions?\n+    BsonArray result_values { matched_count, modified_count, upserted_value };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAxNDk5Ng=="}, "originalCommit": {"oid": "0861c8ff2d04d7fe9d64161750e8e94c58e42260"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxNjQwNQ==", "bodyText": "In many cases we have some sort of \"implicit\" protocol when parsing multiple objects back and forth between JNI...neither is particularly pretty. With an array you need to know the indices, with a document you need to know the keys.\nUsing arrays is usually pretty simple though and we are doing that elsewhere as well.", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429816405", "createdAt": "2020-05-25T08:54:25Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsMongoCollection.cpp", "diffHunk": "@@ -69,6 +70,22 @@ static std::function<jobject(JNIEnv*, std::vector<ObjectId>)> collection_mapper_\n     return arr;\n };\n \n+static std::function<jobject(JNIEnv*, RemoteMongoCollection::RemoteUpdateResult)> collection_mapper_update = [](JNIEnv* env, RemoteMongoCollection::RemoteUpdateResult result) {\n+    Bson matched_count(result.matched_count);\n+    Bson modified_count(result.modified_count);\n+    Bson upserted_value;\n+    if (result.upserted_id) {\n+        upserted_value = new Bson(result.upserted_id.value());\n+    }\n+    // FIXME: maybe not the most efficient way. Suggestions?\n+    BsonArray result_values { matched_count, modified_count, upserted_value };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAxNDk5Ng=="}, "originalCommit": {"oid": "0861c8ff2d04d7fe9d64161750e8e94c58e42260"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgzNTM2OQ==", "bodyText": "In any case, the OS collection method I'm using returns an array of Bsons. I tried to create a plain Bson using our protocol to deliver the result to Java and it still gets delivered as a BsonArray, so I think this solution is acceptable. It's just I'm not all too happy about using indices.", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429835369", "createdAt": "2020-05-25T09:31:44Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsMongoCollection.cpp", "diffHunk": "@@ -69,6 +70,22 @@ static std::function<jobject(JNIEnv*, std::vector<ObjectId>)> collection_mapper_\n     return arr;\n };\n \n+static std::function<jobject(JNIEnv*, RemoteMongoCollection::RemoteUpdateResult)> collection_mapper_update = [](JNIEnv* env, RemoteMongoCollection::RemoteUpdateResult result) {\n+    Bson matched_count(result.matched_count);\n+    Bson modified_count(result.modified_count);\n+    Bson upserted_value;\n+    if (result.upserted_id) {\n+        upserted_value = new Bson(result.upserted_id.value());\n+    }\n+    // FIXME: maybe not the most efficient way. Suggestions?\n+    BsonArray result_values { matched_count, modified_count, upserted_value };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAxNDk5Ng=="}, "originalCommit": {"oid": "0861c8ff2d04d7fe9d64161750e8e94c58e42260"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTY5NDIyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMzozNTo1N1rOGYMABQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMzozNTo1N1rOGYMABQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAxNTYyMQ==", "bodyText": "Links to the BsonArray comment in the native part.", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r428015621", "createdAt": "2020-05-20T13:35:57Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "diffHunk": "@@ -226,56 +223,273 @@ protected RemoteInsertManyResult mapSuccess(Object result) {\n         return ResultHandler.handleResult(success, error);\n     }\n \n-    public RemoteDeleteResult deleteOne(final Bson filter) {\n-        AtomicReference<RemoteDeleteResult> success = new AtomicReference<>(null);\n+    public DeleteResult deleteOne(final Bson filter) {\n+        return deleteInternal(DeleteType.ONE, filter);\n+    }\n+\n+    public DeleteResult deleteMany(final Bson filter) {\n+        return deleteInternal(DeleteType.MANY, filter);\n+    }\n+\n+    public UpdateResult updateOne(final Bson filter, final Bson update) {\n+        return updateOne(filter, update, null);\n+    }\n+\n+    public UpdateResult updateOne(final Bson filter,\n+                                  final Bson update,\n+                                  @Nullable final UpdateOptions options) {\n+        return updateInternal(UpdateType.ONE, filter, update, options);\n+    }\n+\n+    public UpdateResult updateMany(final Bson filter, final Bson update) {\n+        return updateMany(filter, update, null);\n+    }\n+\n+    public UpdateResult updateMany(final Bson filter,\n+                                   final Bson update,\n+                                   @Nullable final UpdateOptions options) {\n+        return updateInternal(UpdateType.MANY, filter, update, options);\n+    }\n+\n+    public DocumentT findOneAndUpdate(final Bson filter, final Bson update) {\n+        return findOneAndUpdate(filter, update, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndUpdate(final Bson filter,\n+                                              final Bson update,\n+                                              final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.UPDATE, filter, update, null, resultClass);\n+    }\n+\n+    public DocumentT findOneAndUpdate(final Bson filter,\n+                                      final Bson update,\n+                                      final FindOneAndModifyOptions options) {\n+        return findOneAndUpdate(filter, update, options, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndUpdate(final Bson filter,\n+                                              final Bson update,\n+                                              final FindOneAndModifyOptions options,\n+                                              final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.UPDATE, filter, update, options, resultClass);\n+    }\n+\n+    public DocumentT findOneAndReplace(final Bson filter, final Bson replacement) {\n+        return findOneAndReplace(filter, replacement, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndReplace(final Bson filter,\n+                                               final Bson update,\n+                                               final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.REPLACE, filter, update, null, resultClass);\n+    }\n+\n+    public DocumentT findOneAndReplace(final Bson filter,\n+                                       final Bson update,\n+                                       final FindOneAndModifyOptions options) {\n+        return findOneAndReplace(filter, update, options, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndReplace(final Bson filter,\n+                                               final Bson update,\n+                                               final FindOneAndModifyOptions options,\n+                                               final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.REPLACE, filter, update, options, resultClass);\n+    }\n+\n+    public DocumentT findOneAndDelete(final Bson filter) {\n+        return findOneAndDelete(filter, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndDelete(final Bson filter,\n+                                              final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.DELETE, filter, null, null, resultClass);\n+    }\n+\n+    public DocumentT findOneAndDelete(final Bson filter,\n+                                      final FindOneAndModifyOptions options) {\n+        return findOneAndInternal(FindOneAndType.DELETE, filter, null, options, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndDelete(final Bson filter,\n+                                      final FindOneAndModifyOptions options,\n+                                      final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.DELETE, filter, null, options, resultClass);\n+    }\n+\n+    private UpdateResult updateInternal(UpdateType type, final Bson filter, final Bson update, @Nullable final UpdateOptions options) {\n+        AtomicReference<UpdateResult> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<UpdateResult> callback = new OsJNIResultCallback<UpdateResult>(success, error) {\n+            @Override\n+            protected UpdateResult mapSuccess(Object result) {\n+                // FIXME: see OsMongoCollection.cpp - collection_mapper_update. There surely is a better way to do this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0861c8ff2d04d7fe9d64161750e8e94c58e42260"}, "originalPosition": 355}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Njg2NTgwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwNzoyMjowMlrOGZ3KSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwNzoyMjowMlrOGZ3KSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc3MTMzNg==", "bodyText": "Maybe keep a short phrase on why this should be revisited, e.g. \"implementation not done\", \"C++ parser does not work for this\", etc. Then it is easier to reason about when revisiting and reviewing.", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429771336", "createdAt": "2020-05-25T07:22:02Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -71,19 +73,20 @@ class MongoCollectionTest {\n     fun insertOne() {\n         with(getCollectionInternal(COLLECTION_NAME)) {\n             assertEquals(0, count().blockingGetResult())\n-            val doc = Document(mapOf(\"KEY_1\" to \"WORLD_1\", \"KEY_2\" to \"WORLD_2\"))\n-            insertOne(doc).blockingGetResult()\n+//            val doc1 = Document(mapOf(\"hello_1\" to 1, \"hello_2\" to 2))\n+            val doc1 = Document(mapOf(\"hello_1\" to \"1\", \"hello_2\" to \"2\"))\n+            insertOne(doc1).blockingGetResult()\n             assertEquals(1, count().blockingGetResult())\n \n             // FIXME: revisit this later", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0861c8ff2d04d7fe9d64161750e8e94c58e42260"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NjkyMjQwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsMongoCollection.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwNzo0MTozNFrOGZ3tSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwNzo0MTozNFrOGZ3tSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc4MDI5Nw==", "bodyText": "I added a parse_checked in https://github.com/realm/realm-java/blob/v10/realm/realm-library/src/main/cpp/jni_util/bson_util.hpp#L34 that will throw an illegal_argument exception if the Bson is not of the expected type instead of hitting an assert on the direct cast. This will be propagated as an IllegalArgumentException in Java if you use the CATCH_STD in you JNI wrapper.", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429780297", "createdAt": "2020-05-25T07:41:34Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsMongoCollection.cpp", "diffHunk": "@@ -88,10 +105,10 @@ Java_io_realm_internal_objectstore_OsMongoCollection_nativeCount(JNIEnv* env,\n     try {\n         auto collection = reinterpret_cast<RemoteMongoCollection*>(j_collection_ptr);\n \n-        // FIXME: add guard agains wrongly encoded strings (e.g. due to using a bogus codec from Java)\n-        bson::BsonDocument bson_filter(JniBsonProtocol::jstring_to_bson(env, j_filter));\n+        // FIXME: add guard against wrongly encoded strings (e.g. due to using a bogus codec from Java)\n+        bson::BsonDocument filter(JniBsonProtocol::jstring_to_bson(env, j_filter));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0861c8ff2d04d7fe9d64161750e8e94c58e42260"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Njk3MDE0OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/jni/JniBsonProtocol.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwNzo1Njo0M1rOGZ4KrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwNzo1Njo0M1rOGZ4KrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc4NzgyMA==", "bodyText": "Hmm. Doesn't the default IterableCodecProvider and DocumentWrapper codec/provider allow you to do this directly by converting to a list of documents and converting each element without the serialized roundtrip.", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429787820", "createdAt": "2020-05-25T07:56:43Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/jni/JniBsonProtocol.java", "diffHunk": "@@ -72,4 +75,13 @@\n         return value;\n     }\n \n+    public static <T> Collection<T> decodeArray(BsonArray array, Class<T> clz, CodecRegistry registry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0861c8ff2d04d7fe9d64161750e8e94c58e42260"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Njk5ODYzOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsMongoCollection.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODowNTo1M1rOGZ4cFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo0MToyNFrOGZ5ggw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5MjI3OQ==", "bodyText": "A bit hard to say with the lack of overview here, but it seems like many of these native methods are doing almost the same. Maybe it would be worth just differentiating them by a selector or similar as in ex. https://github.com/realm/realm-java/blob/v10/realm/realm-library/src/main/cpp/io_realm_ApiKeyAuth.cpp#L79", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429792279", "createdAt": "2020-05-25T08:05:53Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsMongoCollection.cpp", "diffHunk": "@@ -100,14 +117,14 @@ JNIEXPORT void JNICALL\n Java_io_realm_internal_objectstore_OsMongoCollection_nativeFindOne(JNIEnv* env,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0861c8ff2d04d7fe9d64161750e8e94c58e42260"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwOTc5NQ==", "bodyText": "I thought of that too, there is a lot of code repetition. I will definitely address this.", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429809795", "createdAt": "2020-05-25T08:41:24Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsMongoCollection.cpp", "diffHunk": "@@ -100,14 +117,14 @@ JNIEXPORT void JNICALL\n Java_io_realm_internal_objectstore_OsMongoCollection_nativeFindOne(JNIEnv* env,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5MjI3OQ=="}, "originalCommit": {"oid": "0861c8ff2d04d7fe9d64161750e8e94c58e42260"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzAwNDU3OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODowNzo1MFrOGZ4foA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDo0MDo0NFrOGaDRdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5MzE4NA==", "bodyText": "See previous comment about maybe combining these into methods taking a selector. You already have the differentiation modelled in the FindOneAndType enums, etc.", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429793184", "createdAt": "2020-05-25T08:07:50Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "diffHunk": "@@ -226,56 +223,273 @@ protected RemoteInsertManyResult mapSuccess(Object result) {\n         return ResultHandler.handleResult(success, error);\n     }\n \n-    public RemoteDeleteResult deleteOne(final Bson filter) {\n-        AtomicReference<RemoteDeleteResult> success = new AtomicReference<>(null);\n+    public DeleteResult deleteOne(final Bson filter) {\n+        return deleteInternal(DeleteType.ONE, filter);\n+    }\n+\n+    public DeleteResult deleteMany(final Bson filter) {\n+        return deleteInternal(DeleteType.MANY, filter);\n+    }\n+\n+    public UpdateResult updateOne(final Bson filter, final Bson update) {\n+        return updateOne(filter, update, null);\n+    }\n+\n+    public UpdateResult updateOne(final Bson filter,\n+                                  final Bson update,\n+                                  @Nullable final UpdateOptions options) {\n+        return updateInternal(UpdateType.ONE, filter, update, options);\n+    }\n+\n+    public UpdateResult updateMany(final Bson filter, final Bson update) {\n+        return updateMany(filter, update, null);\n+    }\n+\n+    public UpdateResult updateMany(final Bson filter,\n+                                   final Bson update,\n+                                   @Nullable final UpdateOptions options) {\n+        return updateInternal(UpdateType.MANY, filter, update, options);\n+    }\n+\n+    public DocumentT findOneAndUpdate(final Bson filter, final Bson update) {\n+        return findOneAndUpdate(filter, update, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndUpdate(final Bson filter,\n+                                              final Bson update,\n+                                              final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.UPDATE, filter, update, null, resultClass);\n+    }\n+\n+    public DocumentT findOneAndUpdate(final Bson filter,\n+                                      final Bson update,\n+                                      final FindOneAndModifyOptions options) {\n+        return findOneAndUpdate(filter, update, options, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndUpdate(final Bson filter,\n+                                              final Bson update,\n+                                              final FindOneAndModifyOptions options,\n+                                              final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.UPDATE, filter, update, options, resultClass);\n+    }\n+\n+    public DocumentT findOneAndReplace(final Bson filter, final Bson replacement) {\n+        return findOneAndReplace(filter, replacement, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndReplace(final Bson filter,\n+                                               final Bson update,\n+                                               final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.REPLACE, filter, update, null, resultClass);\n+    }\n+\n+    public DocumentT findOneAndReplace(final Bson filter,\n+                                       final Bson update,\n+                                       final FindOneAndModifyOptions options) {\n+        return findOneAndReplace(filter, update, options, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndReplace(final Bson filter,\n+                                               final Bson update,\n+                                               final FindOneAndModifyOptions options,\n+                                               final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.REPLACE, filter, update, options, resultClass);\n+    }\n+\n+    public DocumentT findOneAndDelete(final Bson filter) {\n+        return findOneAndDelete(filter, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndDelete(final Bson filter,\n+                                              final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.DELETE, filter, null, null, resultClass);\n+    }\n+\n+    public DocumentT findOneAndDelete(final Bson filter,\n+                                      final FindOneAndModifyOptions options) {\n+        return findOneAndInternal(FindOneAndType.DELETE, filter, null, options, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndDelete(final Bson filter,\n+                                      final FindOneAndModifyOptions options,\n+                                      final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.DELETE, filter, null, options, resultClass);\n+    }\n+\n+    private UpdateResult updateInternal(UpdateType type, final Bson filter, final Bson update, @Nullable final UpdateOptions options) {\n+        AtomicReference<UpdateResult> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<UpdateResult> callback = new OsJNIResultCallback<UpdateResult>(success, error) {\n+            @Override\n+            protected UpdateResult mapSuccess(Object result) {\n+                // FIXME: see OsMongoCollection.cpp - collection_mapper_update. There surely is a better way to do this\n+                BsonArray array = JniBsonProtocol.decode((String) result, BsonArray.class, codecRegistry);\n+                long matchedCount = array.get(0).asInt32().getValue();\n+                long modifiedCount = array.get(1).asInt32().getValue();\n+\n+                // FIXME: this seems ugly, but Stitch allows retuning null for upsertedId\n+                BsonValue upsertedId = array.get(2);\n+                if (upsertedId instanceof BsonNull) {\n+                    upsertedId = null;\n+                }\n+                return new UpdateResult(matchedCount, modifiedCount, upsertedId);\n+            }\n+        };\n+\n+        String jsonFilter = JniBsonProtocol.encode(filter, codecRegistry);\n+        String jsonUpdate = JniBsonProtocol.encode(update, codecRegistry);\n+\n+        switch (type) {\n+            case ONE:\n+                if (options == null) {\n+                    nativeUpdateOne(nativePtr, jsonFilter, jsonUpdate, callback);\n+                } else {\n+                    nativeUpdateOneWithOptions(nativePtr, jsonFilter, jsonUpdate, options.isUpsert(), callback);\n+                }\n+                break;\n+            case MANY:\n+                if (options == null) {\n+                    nativeUpdateMany(nativePtr, jsonFilter, jsonUpdate, callback);\n+                } else {\n+                    nativeUpdateManyWithOptions(nativePtr, jsonFilter, jsonUpdate, options.isUpsert(), callback);\n+                }\n+                break;\n+        }\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    private <ResultT> ResultT findOneInternal(@Nullable final Bson filter,\n+                                              @Nullable final FindOptions options,\n+                                              final Class<ResultT> resultClass) {\n+        AtomicReference<ResultT> success = new AtomicReference<>(null);\n         AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n-        OsJNIResultCallback<RemoteDeleteResult> callback = new OsJNIResultCallback<RemoteDeleteResult>(success, error) {\n+        OsJNIResultCallback<ResultT> callback = new OsJNIResultCallback<ResultT>(success, error) {\n             @Override\n-            protected RemoteDeleteResult mapSuccess(Object result) {\n-                return new RemoteDeleteResult((Long) result);\n+            protected ResultT mapSuccess(Object result) {\n+                return findSuccessMapper(result, resultClass);\n             }\n         };\n \n-        String jsonDocument = JniBsonProtocol.encode(filter, codecRegistry);\n-        nativeDeleteOne(nativePtr, jsonDocument, callback);\n+        String encodedFilter = (filter == null) ?\n+                JniBsonProtocol.encode(new Document(), codecRegistry) :\n+                JniBsonProtocol.encode(filter, codecRegistry);\n+        if (options == null) {\n+            nativeFindOne(nativePtr, encodedFilter, callback);\n+        } else {\n+            String projectionString = JniBsonProtocol.encode(options.getProjection(), codecRegistry);\n+            String sortString = JniBsonProtocol.encode(options.getSort(), codecRegistry);\n+\n+            nativeFindOneWithOptions(nativePtr, encodedFilter, projectionString, sortString, options.getLimit(), callback);\n+        }\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    private  <ResultT> ResultT findOneAndInternal(final FindOneAndType type,\n+                                                  final Bson filter,\n+                                                  @Nullable final Bson update,\n+                                                  @Nullable final FindOneAndModifyOptions options,\n+                                                  final Class<ResultT> resultClass) {\n+        AtomicReference<ResultT> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<ResultT> callback = new OsJNIResultCallback<ResultT>(success, error) {\n+            @Override\n+            protected ResultT mapSuccess(Object result) {\n+                return findSuccessMapper(result, resultClass);\n+            }\n+        };\n+\n+        String encodedFilter = JniBsonProtocol.encode(filter, codecRegistry);\n+        String encodedUpdate = JniBsonProtocol.encode(update, codecRegistry);\n+        String encodedProjection = null;\n+        String encodedSort = null;\n+        if (options != null) {\n+            encodedProjection = JniBsonProtocol.encode(options.getProjection(), codecRegistry);\n+            encodedSort = JniBsonProtocol.encode(options.getSort(), codecRegistry);\n+        }\n+\n+        switch (type) {\n+            case UPDATE:\n+                if (options == null) {\n+                    nativeFindOneAndUpdate(nativePtr, encodedFilter, encodedUpdate, callback);\n+                } else {\n+                    nativeFindOneAndUpdateWithOptions(nativePtr, encodedFilter, encodedUpdate, encodedProjection, encodedSort, options.isUpsert(), options.isReturnNewDocument(), callback);\n+                }\n+                break;\n+            case REPLACE:\n+                if (options == null) {\n+                    nativeFindOneAndReplace(nativePtr, encodedFilter, encodedUpdate, callback);\n+                } else {\n+                    nativeFindOneAndReplaceWithOptions(nativePtr, encodedFilter, encodedUpdate, encodedProjection, encodedSort, options.isUpsert(), options.isReturnNewDocument(), callback);\n+                }\n+                break;\n+            case DELETE:\n+                if (options == null) {\n+                    nativeFindOneAndDelete(nativePtr, encodedFilter, callback);\n+                } else {\n+                    nativeFindOneAndDeleteWithOptions(nativePtr, encodedFilter, encodedProjection, encodedSort, options.isUpsert(), options.isReturnNewDocument(), callback);\n+                }\n+                break;\n+        }\n+\n         return ResultHandler.handleResult(success, error);\n     }\n \n-    public RemoteDeleteResult deleteMany(final Bson filter) {\n-        AtomicReference<RemoteDeleteResult> success = new AtomicReference<>(null);\n+    private DeleteResult deleteInternal(final DeleteType type, final Bson filter) {\n+        AtomicReference<DeleteResult> success = new AtomicReference<>(null);\n         AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n-        OsJNIResultCallback<RemoteDeleteResult> callback = new OsJNIResultCallback<RemoteDeleteResult>(success, error) {\n+        OsJNIResultCallback<DeleteResult> callback = new OsJNIResultCallback<DeleteResult>(success, error) {\n             @Override\n-            protected RemoteDeleteResult mapSuccess(Object result) {\n-                return new RemoteDeleteResult((Long) result);\n+            protected DeleteResult mapSuccess(Object result) {\n+                return new DeleteResult((Long) result);\n             }\n         };\n \n         String jsonDocument = JniBsonProtocol.encode(filter, codecRegistry);\n-        nativeDeleteMany(nativePtr, jsonDocument, callback);\n+        switch (type) {\n+            case ONE:\n+                nativeDeleteOne(nativePtr, jsonDocument, callback);\n+                break;\n+            case MANY:\n+                nativeDeleteMany(nativePtr, jsonDocument, callback);\n+                break;\n+        }\n         return ResultHandler.handleResult(success, error);\n     }\n \n-    private <T> T findOneSuccessMapper(@Nullable Object result, Class<T> resultClass) {\n+    private <T> T findSuccessMapper(@Nullable Object result, Class<T> resultClass) {\n         if (result == null) {\n             return null;\n         } else {\n             return JniBsonProtocol.decode((String) result, resultClass, codecRegistry);\n         }\n     }\n \n+    private enum UpdateType {\n+        ONE, MANY\n+    }\n+\n+    private enum DeleteType {\n+        ONE, MANY\n+    }\n+\n+    private enum FindOneAndType {\n+        UPDATE, REPLACE, DELETE\n+    }\n+\n     private static native long nativeGetFinalizerMethodPtr();\n     private static native void nativeCount(long remoteMongoCollectionPtr,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0861c8ff2d04d7fe9d64161750e8e94c58e42260"}, "originalPosition": 523}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk2OTc4Mw==", "bodyText": "I will address this in the next PR.", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429969783", "createdAt": "2020-05-25T14:40:44Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "diffHunk": "@@ -226,56 +223,273 @@ protected RemoteInsertManyResult mapSuccess(Object result) {\n         return ResultHandler.handleResult(success, error);\n     }\n \n-    public RemoteDeleteResult deleteOne(final Bson filter) {\n-        AtomicReference<RemoteDeleteResult> success = new AtomicReference<>(null);\n+    public DeleteResult deleteOne(final Bson filter) {\n+        return deleteInternal(DeleteType.ONE, filter);\n+    }\n+\n+    public DeleteResult deleteMany(final Bson filter) {\n+        return deleteInternal(DeleteType.MANY, filter);\n+    }\n+\n+    public UpdateResult updateOne(final Bson filter, final Bson update) {\n+        return updateOne(filter, update, null);\n+    }\n+\n+    public UpdateResult updateOne(final Bson filter,\n+                                  final Bson update,\n+                                  @Nullable final UpdateOptions options) {\n+        return updateInternal(UpdateType.ONE, filter, update, options);\n+    }\n+\n+    public UpdateResult updateMany(final Bson filter, final Bson update) {\n+        return updateMany(filter, update, null);\n+    }\n+\n+    public UpdateResult updateMany(final Bson filter,\n+                                   final Bson update,\n+                                   @Nullable final UpdateOptions options) {\n+        return updateInternal(UpdateType.MANY, filter, update, options);\n+    }\n+\n+    public DocumentT findOneAndUpdate(final Bson filter, final Bson update) {\n+        return findOneAndUpdate(filter, update, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndUpdate(final Bson filter,\n+                                              final Bson update,\n+                                              final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.UPDATE, filter, update, null, resultClass);\n+    }\n+\n+    public DocumentT findOneAndUpdate(final Bson filter,\n+                                      final Bson update,\n+                                      final FindOneAndModifyOptions options) {\n+        return findOneAndUpdate(filter, update, options, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndUpdate(final Bson filter,\n+                                              final Bson update,\n+                                              final FindOneAndModifyOptions options,\n+                                              final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.UPDATE, filter, update, options, resultClass);\n+    }\n+\n+    public DocumentT findOneAndReplace(final Bson filter, final Bson replacement) {\n+        return findOneAndReplace(filter, replacement, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndReplace(final Bson filter,\n+                                               final Bson update,\n+                                               final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.REPLACE, filter, update, null, resultClass);\n+    }\n+\n+    public DocumentT findOneAndReplace(final Bson filter,\n+                                       final Bson update,\n+                                       final FindOneAndModifyOptions options) {\n+        return findOneAndReplace(filter, update, options, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndReplace(final Bson filter,\n+                                               final Bson update,\n+                                               final FindOneAndModifyOptions options,\n+                                               final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.REPLACE, filter, update, options, resultClass);\n+    }\n+\n+    public DocumentT findOneAndDelete(final Bson filter) {\n+        return findOneAndDelete(filter, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndDelete(final Bson filter,\n+                                              final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.DELETE, filter, null, null, resultClass);\n+    }\n+\n+    public DocumentT findOneAndDelete(final Bson filter,\n+                                      final FindOneAndModifyOptions options) {\n+        return findOneAndInternal(FindOneAndType.DELETE, filter, null, options, documentClass);\n+    }\n+\n+    public <ResultT> ResultT findOneAndDelete(final Bson filter,\n+                                      final FindOneAndModifyOptions options,\n+                                      final Class<ResultT> resultClass) {\n+        return findOneAndInternal(FindOneAndType.DELETE, filter, null, options, resultClass);\n+    }\n+\n+    private UpdateResult updateInternal(UpdateType type, final Bson filter, final Bson update, @Nullable final UpdateOptions options) {\n+        AtomicReference<UpdateResult> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<UpdateResult> callback = new OsJNIResultCallback<UpdateResult>(success, error) {\n+            @Override\n+            protected UpdateResult mapSuccess(Object result) {\n+                // FIXME: see OsMongoCollection.cpp - collection_mapper_update. There surely is a better way to do this\n+                BsonArray array = JniBsonProtocol.decode((String) result, BsonArray.class, codecRegistry);\n+                long matchedCount = array.get(0).asInt32().getValue();\n+                long modifiedCount = array.get(1).asInt32().getValue();\n+\n+                // FIXME: this seems ugly, but Stitch allows retuning null for upsertedId\n+                BsonValue upsertedId = array.get(2);\n+                if (upsertedId instanceof BsonNull) {\n+                    upsertedId = null;\n+                }\n+                return new UpdateResult(matchedCount, modifiedCount, upsertedId);\n+            }\n+        };\n+\n+        String jsonFilter = JniBsonProtocol.encode(filter, codecRegistry);\n+        String jsonUpdate = JniBsonProtocol.encode(update, codecRegistry);\n+\n+        switch (type) {\n+            case ONE:\n+                if (options == null) {\n+                    nativeUpdateOne(nativePtr, jsonFilter, jsonUpdate, callback);\n+                } else {\n+                    nativeUpdateOneWithOptions(nativePtr, jsonFilter, jsonUpdate, options.isUpsert(), callback);\n+                }\n+                break;\n+            case MANY:\n+                if (options == null) {\n+                    nativeUpdateMany(nativePtr, jsonFilter, jsonUpdate, callback);\n+                } else {\n+                    nativeUpdateManyWithOptions(nativePtr, jsonFilter, jsonUpdate, options.isUpsert(), callback);\n+                }\n+                break;\n+        }\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    private <ResultT> ResultT findOneInternal(@Nullable final Bson filter,\n+                                              @Nullable final FindOptions options,\n+                                              final Class<ResultT> resultClass) {\n+        AtomicReference<ResultT> success = new AtomicReference<>(null);\n         AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n-        OsJNIResultCallback<RemoteDeleteResult> callback = new OsJNIResultCallback<RemoteDeleteResult>(success, error) {\n+        OsJNIResultCallback<ResultT> callback = new OsJNIResultCallback<ResultT>(success, error) {\n             @Override\n-            protected RemoteDeleteResult mapSuccess(Object result) {\n-                return new RemoteDeleteResult((Long) result);\n+            protected ResultT mapSuccess(Object result) {\n+                return findSuccessMapper(result, resultClass);\n             }\n         };\n \n-        String jsonDocument = JniBsonProtocol.encode(filter, codecRegistry);\n-        nativeDeleteOne(nativePtr, jsonDocument, callback);\n+        String encodedFilter = (filter == null) ?\n+                JniBsonProtocol.encode(new Document(), codecRegistry) :\n+                JniBsonProtocol.encode(filter, codecRegistry);\n+        if (options == null) {\n+            nativeFindOne(nativePtr, encodedFilter, callback);\n+        } else {\n+            String projectionString = JniBsonProtocol.encode(options.getProjection(), codecRegistry);\n+            String sortString = JniBsonProtocol.encode(options.getSort(), codecRegistry);\n+\n+            nativeFindOneWithOptions(nativePtr, encodedFilter, projectionString, sortString, options.getLimit(), callback);\n+        }\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    private  <ResultT> ResultT findOneAndInternal(final FindOneAndType type,\n+                                                  final Bson filter,\n+                                                  @Nullable final Bson update,\n+                                                  @Nullable final FindOneAndModifyOptions options,\n+                                                  final Class<ResultT> resultClass) {\n+        AtomicReference<ResultT> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<ResultT> callback = new OsJNIResultCallback<ResultT>(success, error) {\n+            @Override\n+            protected ResultT mapSuccess(Object result) {\n+                return findSuccessMapper(result, resultClass);\n+            }\n+        };\n+\n+        String encodedFilter = JniBsonProtocol.encode(filter, codecRegistry);\n+        String encodedUpdate = JniBsonProtocol.encode(update, codecRegistry);\n+        String encodedProjection = null;\n+        String encodedSort = null;\n+        if (options != null) {\n+            encodedProjection = JniBsonProtocol.encode(options.getProjection(), codecRegistry);\n+            encodedSort = JniBsonProtocol.encode(options.getSort(), codecRegistry);\n+        }\n+\n+        switch (type) {\n+            case UPDATE:\n+                if (options == null) {\n+                    nativeFindOneAndUpdate(nativePtr, encodedFilter, encodedUpdate, callback);\n+                } else {\n+                    nativeFindOneAndUpdateWithOptions(nativePtr, encodedFilter, encodedUpdate, encodedProjection, encodedSort, options.isUpsert(), options.isReturnNewDocument(), callback);\n+                }\n+                break;\n+            case REPLACE:\n+                if (options == null) {\n+                    nativeFindOneAndReplace(nativePtr, encodedFilter, encodedUpdate, callback);\n+                } else {\n+                    nativeFindOneAndReplaceWithOptions(nativePtr, encodedFilter, encodedUpdate, encodedProjection, encodedSort, options.isUpsert(), options.isReturnNewDocument(), callback);\n+                }\n+                break;\n+            case DELETE:\n+                if (options == null) {\n+                    nativeFindOneAndDelete(nativePtr, encodedFilter, callback);\n+                } else {\n+                    nativeFindOneAndDeleteWithOptions(nativePtr, encodedFilter, encodedProjection, encodedSort, options.isUpsert(), options.isReturnNewDocument(), callback);\n+                }\n+                break;\n+        }\n+\n         return ResultHandler.handleResult(success, error);\n     }\n \n-    public RemoteDeleteResult deleteMany(final Bson filter) {\n-        AtomicReference<RemoteDeleteResult> success = new AtomicReference<>(null);\n+    private DeleteResult deleteInternal(final DeleteType type, final Bson filter) {\n+        AtomicReference<DeleteResult> success = new AtomicReference<>(null);\n         AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n-        OsJNIResultCallback<RemoteDeleteResult> callback = new OsJNIResultCallback<RemoteDeleteResult>(success, error) {\n+        OsJNIResultCallback<DeleteResult> callback = new OsJNIResultCallback<DeleteResult>(success, error) {\n             @Override\n-            protected RemoteDeleteResult mapSuccess(Object result) {\n-                return new RemoteDeleteResult((Long) result);\n+            protected DeleteResult mapSuccess(Object result) {\n+                return new DeleteResult((Long) result);\n             }\n         };\n \n         String jsonDocument = JniBsonProtocol.encode(filter, codecRegistry);\n-        nativeDeleteMany(nativePtr, jsonDocument, callback);\n+        switch (type) {\n+            case ONE:\n+                nativeDeleteOne(nativePtr, jsonDocument, callback);\n+                break;\n+            case MANY:\n+                nativeDeleteMany(nativePtr, jsonDocument, callback);\n+                break;\n+        }\n         return ResultHandler.handleResult(success, error);\n     }\n \n-    private <T> T findOneSuccessMapper(@Nullable Object result, Class<T> resultClass) {\n+    private <T> T findSuccessMapper(@Nullable Object result, Class<T> resultClass) {\n         if (result == null) {\n             return null;\n         } else {\n             return JniBsonProtocol.decode((String) result, resultClass, codecRegistry);\n         }\n     }\n \n+    private enum UpdateType {\n+        ONE, MANY\n+    }\n+\n+    private enum DeleteType {\n+        ONE, MANY\n+    }\n+\n+    private enum FindOneAndType {\n+        UPDATE, REPLACE, DELETE\n+    }\n+\n     private static native long nativeGetFinalizerMethodPtr();\n     private static native void nativeCount(long remoteMongoCollectionPtr,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5MzE4NA=="}, "originalCommit": {"oid": "0861c8ff2d04d7fe9d64161750e8e94c58e42260"}, "originalPosition": 523}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzEyNTY2OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo0NzowNFrOGZ5rww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMToyMzozN1rOGZ98GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxMjY3NQ==", "bodyText": "Isn't this just a duplicate of the below, so can be removed?", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429812675", "createdAt": "2020-05-25T08:47:04Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -71,19 +73,20 @@ class MongoCollectionTest {\n     fun insertOne() {\n         with(getCollectionInternal(COLLECTION_NAME)) {\n             assertEquals(0, count().blockingGetResult())\n-            val doc = Document(mapOf(\"KEY_1\" to \"WORLD_1\", \"KEY_2\" to \"WORLD_2\"))\n-            insertOne(doc).blockingGetResult()\n+//            val doc1 = Document(mapOf(\"hello_1\" to 1, \"hello_2\" to 2))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56a0f3ec1b0f457466941ebf1fd7b59a89ada2a9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4MjM5Mw==", "bodyText": "Yes, there's a lot of clutter lying around.", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429882393", "createdAt": "2020-05-25T11:23:37Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -71,19 +73,20 @@ class MongoCollectionTest {\n     fun insertOne() {\n         with(getCollectionInternal(COLLECTION_NAME)) {\n             assertEquals(0, count().blockingGetResult())\n-            val doc = Document(mapOf(\"KEY_1\" to \"WORLD_1\", \"KEY_2\" to \"WORLD_2\"))\n-            insertOne(doc).blockingGetResult()\n+//            val doc1 = Document(mapOf(\"hello_1\" to 1, \"hello_2\" to 2))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxMjY3NQ=="}, "originalCommit": {"oid": "56a0f3ec1b0f457466941ebf1fd7b59a89ada2a9"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzEzMjU1OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo0OTowOFrOGZ5v6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMToyNjoxM1rOGZ-AQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxMzczNw==", "bodyText": "Why id !! needed here, but not just below? \ud83e\udd14\nShouldn't it just be val result1 = updateOne(Document(), doc1).blockingGetResult()!! in that case? Same for the other sections in this test", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429813737", "createdAt": "2020-05-25T08:49:08Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -260,6 +263,194 @@ class MongoCollectionTest {\n         }\n     }\n \n+    @Test\n+    fun updateOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world\")\n+            val result1 = updateOne(Document(), doc1).blockingGetResult()\n+            assertEquals(0, result1!!.matchedCount)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56a0f3ec1b0f457466941ebf1fd7b59a89ada2a9"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4MzQ1Ng==", "bodyText": "True that", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429883456", "createdAt": "2020-05-25T11:26:13Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -260,6 +263,194 @@ class MongoCollectionTest {\n         }\n     }\n \n+    @Test\n+    fun updateOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world\")\n+            val result1 = updateOne(Document(), doc1).blockingGetResult()\n+            assertEquals(0, result1!!.matchedCount)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxMzczNw=="}, "originalCommit": {"oid": "56a0f3ec1b0f457466941ebf1fd7b59a89ada2a9"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzEzNjY5OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo1MDoyN1rOGZ5yfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo1MDoyN1rOGZ5yfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxNDM5OQ==", "bodyText": "Add FIXME for why this is commented out here or delete it.", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429814399", "createdAt": "2020-05-25T08:50:27Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -260,6 +263,194 @@ class MongoCollectionTest {\n         }\n     }\n \n+    @Test\n+    fun updateOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world\")\n+            val result1 = updateOne(Document(), doc1).blockingGetResult()\n+            assertEquals(0, result1!!.matchedCount)\n+            assertEquals(0, result1.modifiedCount)\n+            assertNull(result1.upsertedId)\n+\n+            val options2 = UpdateOptions().upsert(true)\n+            val result2 = updateOne(Document(), doc1, options2).blockingGetResult()\n+            assertEquals(0, result2!!.matchedCount)\n+            assertEquals(0, result2.modifiedCount)\n+            assertFalse(result2.upsertedId!!.isNull)\n+\n+            val result3 = updateOne(Document(), Document(\"\\$set\", Document(\"woof\", \"meow\"))).blockingGetResult()\n+            assertEquals(1, result3!!.matchedCount)\n+            assertEquals(1, result3.modifiedCount)\n+            assertNull(result3.upsertedId)\n+\n+//            val expectedDoc = Document(\"hello\", \"world\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56a0f3ec1b0f457466941ebf1fd7b59a89ada2a9"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzEzODIwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo1MDo1MlrOGZ5zYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo1MDo1MlrOGZ5zYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxNDYyNA==", "bodyText": "Same as above with !!", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429814624", "createdAt": "2020-05-25T08:50:52Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -260,6 +263,194 @@ class MongoCollectionTest {\n         }\n     }\n \n+    @Test\n+    fun updateOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world\")\n+            val result1 = updateOne(Document(), doc1).blockingGetResult()\n+            assertEquals(0, result1!!.matchedCount)\n+            assertEquals(0, result1.modifiedCount)\n+            assertNull(result1.upsertedId)\n+\n+            val options2 = UpdateOptions().upsert(true)\n+            val result2 = updateOne(Document(), doc1, options2).blockingGetResult()\n+            assertEquals(0, result2!!.matchedCount)\n+            assertEquals(0, result2.modifiedCount)\n+            assertFalse(result2.upsertedId!!.isNull)\n+\n+            val result3 = updateOne(Document(), Document(\"\\$set\", Document(\"woof\", \"meow\"))).blockingGetResult()\n+            assertEquals(1, result3!!.matchedCount)\n+            assertEquals(1, result3.modifiedCount)\n+            assertNull(result3.upsertedId)\n+\n+//            val expectedDoc = Document(\"hello\", \"world\")\n+//            expectedDoc[\"woof\"] = \"meow\"\n+//            assertEquals(expectedDoc, withoutId(Tasks.await(coll.find(Document()).first())))\n+//\n+//            try {\n+//                Tasks.await(coll.updateOne(Document(\"\\$who\", 1), Document()))\n+//                fail()\n+//            } catch (ex: ExecutionException) {\n+//                assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun updateMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world\")\n+            val result1 = updateMany(Document(), doc1).blockingGetResult()\n+            assertEquals(0, result1!!.matchedCount)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56a0f3ec1b0f457466941ebf1fd7b59a89ada2a9"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzEzODkxOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo1MTowMlrOGZ5zyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo1MTowMlrOGZ5zyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxNDczMA==", "bodyText": "Same as above", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429814730", "createdAt": "2020-05-25T08:51:02Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -260,6 +263,194 @@ class MongoCollectionTest {\n         }\n     }\n \n+    @Test\n+    fun updateOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world\")\n+            val result1 = updateOne(Document(), doc1).blockingGetResult()\n+            assertEquals(0, result1!!.matchedCount)\n+            assertEquals(0, result1.modifiedCount)\n+            assertNull(result1.upsertedId)\n+\n+            val options2 = UpdateOptions().upsert(true)\n+            val result2 = updateOne(Document(), doc1, options2).blockingGetResult()\n+            assertEquals(0, result2!!.matchedCount)\n+            assertEquals(0, result2.modifiedCount)\n+            assertFalse(result2.upsertedId!!.isNull)\n+\n+            val result3 = updateOne(Document(), Document(\"\\$set\", Document(\"woof\", \"meow\"))).blockingGetResult()\n+            assertEquals(1, result3!!.matchedCount)\n+            assertEquals(1, result3.modifiedCount)\n+            assertNull(result3.upsertedId)\n+\n+//            val expectedDoc = Document(\"hello\", \"world\")\n+//            expectedDoc[\"woof\"] = \"meow\"\n+//            assertEquals(expectedDoc, withoutId(Tasks.await(coll.find(Document()).first())))\n+//\n+//            try {\n+//                Tasks.await(coll.updateOne(Document(\"\\$who\", 1), Document()))\n+//                fail()\n+//            } catch (ex: ExecutionException) {\n+//                assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun updateMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world\")\n+            val result1 = updateMany(Document(), doc1).blockingGetResult()\n+            assertEquals(0, result1!!.matchedCount)\n+            assertEquals(0, result1.modifiedCount)\n+            assertNull(result1.upsertedId)\n+\n+            val options2 = UpdateOptions().upsert(true)\n+            val result2 = updateMany(Document(), doc1, options2).blockingGetResult()\n+            assertEquals(0, result2!!.matchedCount)\n+            assertEquals(0, result2.modifiedCount)\n+            assertNotNull(result2.upsertedId)\n+\n+            val result3 = updateMany(Document(), Document(\"\\$set\", Document(\"woof\", \"meow\"))).blockingGetResult()\n+            assertEquals(1, result3!!.matchedCount)\n+            assertEquals(1, result3.modifiedCount)\n+            assertNull(result3.upsertedId)\n+\n+            insertOne(Document()).blockingGetResult()\n+            val result4 = updateMany(Document(), Document(\"\\$set\", Document(\"woof\", \"meow\"))).blockingGetResult()\n+            assertEquals(2, result4!!.matchedCount)\n+            assertEquals(2, result4.modifiedCount)\n+\n+//            val expectedDoc1 = Document(\"hello\", \"world\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56a0f3ec1b0f457466941ebf1fd7b59a89ada2a9"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzE0MjQwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo1MjowOFrOGZ518Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMTozNTowMVrOGZ-OyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxNTI4MQ==", "bodyText": "I prefer using !! when the variable is created instead of when using below. That way the error appears at the root of the problem.", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429815281", "createdAt": "2020-05-25T08:52:08Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -260,6 +263,194 @@ class MongoCollectionTest {\n         }\n     }\n \n+    @Test\n+    fun updateOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world\")\n+            val result1 = updateOne(Document(), doc1).blockingGetResult()\n+            assertEquals(0, result1!!.matchedCount)\n+            assertEquals(0, result1.modifiedCount)\n+            assertNull(result1.upsertedId)\n+\n+            val options2 = UpdateOptions().upsert(true)\n+            val result2 = updateOne(Document(), doc1, options2).blockingGetResult()\n+            assertEquals(0, result2!!.matchedCount)\n+            assertEquals(0, result2.modifiedCount)\n+            assertFalse(result2.upsertedId!!.isNull)\n+\n+            val result3 = updateOne(Document(), Document(\"\\$set\", Document(\"woof\", \"meow\"))).blockingGetResult()\n+            assertEquals(1, result3!!.matchedCount)\n+            assertEquals(1, result3.modifiedCount)\n+            assertNull(result3.upsertedId)\n+\n+//            val expectedDoc = Document(\"hello\", \"world\")\n+//            expectedDoc[\"woof\"] = \"meow\"\n+//            assertEquals(expectedDoc, withoutId(Tasks.await(coll.find(Document()).first())))\n+//\n+//            try {\n+//                Tasks.await(coll.updateOne(Document(\"\\$who\", 1), Document()))\n+//                fail()\n+//            } catch (ex: ExecutionException) {\n+//                assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun updateMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world\")\n+            val result1 = updateMany(Document(), doc1).blockingGetResult()\n+            assertEquals(0, result1!!.matchedCount)\n+            assertEquals(0, result1.modifiedCount)\n+            assertNull(result1.upsertedId)\n+\n+            val options2 = UpdateOptions().upsert(true)\n+            val result2 = updateMany(Document(), doc1, options2).blockingGetResult()\n+            assertEquals(0, result2!!.matchedCount)\n+            assertEquals(0, result2.modifiedCount)\n+            assertNotNull(result2.upsertedId)\n+\n+            val result3 = updateMany(Document(), Document(\"\\$set\", Document(\"woof\", \"meow\"))).blockingGetResult()\n+            assertEquals(1, result3!!.matchedCount)\n+            assertEquals(1, result3.modifiedCount)\n+            assertNull(result3.upsertedId)\n+\n+            insertOne(Document()).blockingGetResult()\n+            val result4 = updateMany(Document(), Document(\"\\$set\", Document(\"woof\", \"meow\"))).blockingGetResult()\n+            assertEquals(2, result4!!.matchedCount)\n+            assertEquals(2, result4.modifiedCount)\n+\n+//            val expectedDoc1 = Document(\"hello\", \"world\")\n+//            expectedDoc1[\"woof\"] = \"meow\"\n+//            val expectedDoc2 = Document(\"woof\", \"meow\")\n+//            assertEquals(listOf(expectedDoc1, expectedDoc2), withoutIds(Tasks.await<MutableList<Document>>(coll.find(Document()).into(mutableListOf()))))\n+//\n+//            try {\n+//                Tasks.await(coll.updateMany(Document(\"\\$who\", 1), Document()))\n+//                fail()\n+//            } catch (ex: ExecutionException) {\n+//                assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    @Ignore\n+    // FIXME: revisit when parser is fully operational\n+    fun findOneAndUpdate() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val sampleDoc = Document(\"hello\", \"world1\")\n+            sampleDoc[\"num\"] = 2\n+\n+            // Collection should start out empty\n+            // This also tests the null return format\n+            assertNull(findOneAndUpdate(Document(), Document()).blockingGetResult())\n+\n+            // Insert a sample Document\n+            insertOne(sampleDoc).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Sample call to findOneAndUpdate() where we get the previous document back\n+            val sampleUpdate = Document(\"\\$set\", Document(\"hello\", \"hellothere\"))\n+            sampleUpdate[\"\\$inc\"] = Document(\"num\", 1)\n+            assertEquals(sampleDoc.withoutId(), findOneAndUpdate(Document(\"hello\", \"world1\"), sampleUpdate).blockingGetResult())\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Make sure the update took place\n+            val expectedDoc = Document(\"hello\", \"hellothere\")\n+            expectedDoc[\"num\"] = 3\n+//            assertEquals(expectedDoc.withoutId(), withoutId(Tasks.await(coll.find().first())))\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Call findOneAndUpdate() again but get the new document\n+            sampleUpdate.remove(\"\\$set\")\n+            expectedDoc[\"num\"] = 4\n+            val result = findOneAndUpdate(Document(\"hello\", \"hellothere\"), sampleUpdate, FindOneAndModifyOptions().returnNewDocument(true)).blockingGetResult()\n+            assertEquals(expectedDoc.withoutId(), result!!.withoutId())\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Test null behaviour again with a filter that should not match any documents\n+            assertNull(findOneAndUpdate(Document(\"hello\", \"zzzzz\"), Document()).blockingGetResult())\n+            assertEquals(1, count().blockingGetResult())\n+\n+            val doc1 = Document(\"hello\", \"world1\")\n+            doc1[\"num\"] = 1\n+\n+            val doc2 = Document(\"hello\", \"world2\")\n+            doc2[\"num\"] = 2\n+\n+            val doc3 = Document(\"hello\", \"world3\")\n+            doc3[\"num\"] = 3\n+\n+            // Test the upsert option where it should not actually be invoked\n+            val result2 = findOneAndUpdate(Document(\"hello\", \"hellothere\"), Document(\"\\$set\", doc1), FindOneAndModifyOptions().returnNewDocument(true).upsert(true)).blockingGetResult()\n+            assertEquals(doc1, result2!!.withoutId())\n+            assertEquals(1, count().blockingGetResult())\n+//            assertEquals(doc1.withoutId(), withoutId(Tasks.await(coll.find().first())))\n+\n+            // Test the upsert option where the server should perform upsert and return new document\n+            val result3 = findOneAndUpdate(Document(\"hello\", \"hellothere\"), Document(\"\\$set\", doc2), FindOneAndModifyOptions().returnNewDocument(true).upsert(true)).blockingGetResult()\n+            assertEquals(doc2, result3!!.withoutId())\n+            assertEquals(2, count().blockingGetResult())\n+\n+            // Test the upsert option where the server should perform upsert and return old document\n+            // The old document should be empty\n+            val result4 = findOneAndUpdate(Document(\"hello\", \"hellothere\"), Document(\"\\$set\", doc3), FindOneAndModifyOptions().upsert(true)).blockingGetResult()\n+            assertNull(result4)\n+            assertEquals(3, count().blockingGetResult())\n+\n+            // Test sort and project\n+//            assertEquals(listOf(doc1, doc2, doc3),\n+//                    withoutIds(Tasks.await<MutableList<Document>>(coll.find().into(mutableListOf()))))\n+\n+            val sampleProject = Document(\"hello\", 1)\n+            sampleProject[\"_id\"] = 0\n+\n+            val result5 = findOneAndUpdate(Document(), sampleUpdate, FindOneAndModifyOptions().projection(sampleProject).sort(Document(\"num\", 1))).blockingGetResult()\n+            assertEquals(Document(\"hello\", \"world1\"), result5!!.withoutId())\n+            assertEquals(3, count().blockingGetResult())\n+\n+            val result6 = findOneAndUpdate(Document(), sampleUpdate, FindOneAndModifyOptions().projection(sampleProject).sort(Document(\"num\", -1))).blockingGetResult()\n+            assertEquals(Document(\"hello\", \"world3\"), result6!!.withoutId())\n+            assertEquals(3, count().blockingGetResult())\n+\n+            // Test proper failure\n+//            try {\n+//                Tasks.await(coll.findOneAndUpdate(Document(), Document(\"\\$who\", 1)))\n+//                fail()\n+//            } catch (ex: ExecutionException) {\n+//                assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+//\n+//            try {\n+//                Tasks.await(coll.findOneAndUpdate(Document(), Document(\"\\$who\", 1),\n+//                        FindOneAndModifyOptions().upsert(true)))\n+//                fail()\n+//            } catch (ex: ExecutionException) {\n+//                assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun find() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            // FIXME: fix find implementation - ignore this code for code review\n+            val iter = find().blockingGetResult()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56a0f3ec1b0f457466941ebf1fd7b59a89ada2a9"}, "originalPosition": 277}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4NjU0MQ==", "bodyText": "That is right, it's more that I'm used to not enforce the nullability check until later in the code due to sometimes receiving null values under certain circumstances (I'm not talking about this test but in general), in which case I would use either checkNotNull(whatever) or !! like I just did here. It feels a bit like I'm breaking the contract by enforcing something that is nullable to be not null, even if I know it won't be null.", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429886541", "createdAt": "2020-05-25T11:33:23Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -260,6 +263,194 @@ class MongoCollectionTest {\n         }\n     }\n \n+    @Test\n+    fun updateOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world\")\n+            val result1 = updateOne(Document(), doc1).blockingGetResult()\n+            assertEquals(0, result1!!.matchedCount)\n+            assertEquals(0, result1.modifiedCount)\n+            assertNull(result1.upsertedId)\n+\n+            val options2 = UpdateOptions().upsert(true)\n+            val result2 = updateOne(Document(), doc1, options2).blockingGetResult()\n+            assertEquals(0, result2!!.matchedCount)\n+            assertEquals(0, result2.modifiedCount)\n+            assertFalse(result2.upsertedId!!.isNull)\n+\n+            val result3 = updateOne(Document(), Document(\"\\$set\", Document(\"woof\", \"meow\"))).blockingGetResult()\n+            assertEquals(1, result3!!.matchedCount)\n+            assertEquals(1, result3.modifiedCount)\n+            assertNull(result3.upsertedId)\n+\n+//            val expectedDoc = Document(\"hello\", \"world\")\n+//            expectedDoc[\"woof\"] = \"meow\"\n+//            assertEquals(expectedDoc, withoutId(Tasks.await(coll.find(Document()).first())))\n+//\n+//            try {\n+//                Tasks.await(coll.updateOne(Document(\"\\$who\", 1), Document()))\n+//                fail()\n+//            } catch (ex: ExecutionException) {\n+//                assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun updateMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world\")\n+            val result1 = updateMany(Document(), doc1).blockingGetResult()\n+            assertEquals(0, result1!!.matchedCount)\n+            assertEquals(0, result1.modifiedCount)\n+            assertNull(result1.upsertedId)\n+\n+            val options2 = UpdateOptions().upsert(true)\n+            val result2 = updateMany(Document(), doc1, options2).blockingGetResult()\n+            assertEquals(0, result2!!.matchedCount)\n+            assertEquals(0, result2.modifiedCount)\n+            assertNotNull(result2.upsertedId)\n+\n+            val result3 = updateMany(Document(), Document(\"\\$set\", Document(\"woof\", \"meow\"))).blockingGetResult()\n+            assertEquals(1, result3!!.matchedCount)\n+            assertEquals(1, result3.modifiedCount)\n+            assertNull(result3.upsertedId)\n+\n+            insertOne(Document()).blockingGetResult()\n+            val result4 = updateMany(Document(), Document(\"\\$set\", Document(\"woof\", \"meow\"))).blockingGetResult()\n+            assertEquals(2, result4!!.matchedCount)\n+            assertEquals(2, result4.modifiedCount)\n+\n+//            val expectedDoc1 = Document(\"hello\", \"world\")\n+//            expectedDoc1[\"woof\"] = \"meow\"\n+//            val expectedDoc2 = Document(\"woof\", \"meow\")\n+//            assertEquals(listOf(expectedDoc1, expectedDoc2), withoutIds(Tasks.await<MutableList<Document>>(coll.find(Document()).into(mutableListOf()))))\n+//\n+//            try {\n+//                Tasks.await(coll.updateMany(Document(\"\\$who\", 1), Document()))\n+//                fail()\n+//            } catch (ex: ExecutionException) {\n+//                assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    @Ignore\n+    // FIXME: revisit when parser is fully operational\n+    fun findOneAndUpdate() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val sampleDoc = Document(\"hello\", \"world1\")\n+            sampleDoc[\"num\"] = 2\n+\n+            // Collection should start out empty\n+            // This also tests the null return format\n+            assertNull(findOneAndUpdate(Document(), Document()).blockingGetResult())\n+\n+            // Insert a sample Document\n+            insertOne(sampleDoc).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Sample call to findOneAndUpdate() where we get the previous document back\n+            val sampleUpdate = Document(\"\\$set\", Document(\"hello\", \"hellothere\"))\n+            sampleUpdate[\"\\$inc\"] = Document(\"num\", 1)\n+            assertEquals(sampleDoc.withoutId(), findOneAndUpdate(Document(\"hello\", \"world1\"), sampleUpdate).blockingGetResult())\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Make sure the update took place\n+            val expectedDoc = Document(\"hello\", \"hellothere\")\n+            expectedDoc[\"num\"] = 3\n+//            assertEquals(expectedDoc.withoutId(), withoutId(Tasks.await(coll.find().first())))\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Call findOneAndUpdate() again but get the new document\n+            sampleUpdate.remove(\"\\$set\")\n+            expectedDoc[\"num\"] = 4\n+            val result = findOneAndUpdate(Document(\"hello\", \"hellothere\"), sampleUpdate, FindOneAndModifyOptions().returnNewDocument(true)).blockingGetResult()\n+            assertEquals(expectedDoc.withoutId(), result!!.withoutId())\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Test null behaviour again with a filter that should not match any documents\n+            assertNull(findOneAndUpdate(Document(\"hello\", \"zzzzz\"), Document()).blockingGetResult())\n+            assertEquals(1, count().blockingGetResult())\n+\n+            val doc1 = Document(\"hello\", \"world1\")\n+            doc1[\"num\"] = 1\n+\n+            val doc2 = Document(\"hello\", \"world2\")\n+            doc2[\"num\"] = 2\n+\n+            val doc3 = Document(\"hello\", \"world3\")\n+            doc3[\"num\"] = 3\n+\n+            // Test the upsert option where it should not actually be invoked\n+            val result2 = findOneAndUpdate(Document(\"hello\", \"hellothere\"), Document(\"\\$set\", doc1), FindOneAndModifyOptions().returnNewDocument(true).upsert(true)).blockingGetResult()\n+            assertEquals(doc1, result2!!.withoutId())\n+            assertEquals(1, count().blockingGetResult())\n+//            assertEquals(doc1.withoutId(), withoutId(Tasks.await(coll.find().first())))\n+\n+            // Test the upsert option where the server should perform upsert and return new document\n+            val result3 = findOneAndUpdate(Document(\"hello\", \"hellothere\"), Document(\"\\$set\", doc2), FindOneAndModifyOptions().returnNewDocument(true).upsert(true)).blockingGetResult()\n+            assertEquals(doc2, result3!!.withoutId())\n+            assertEquals(2, count().blockingGetResult())\n+\n+            // Test the upsert option where the server should perform upsert and return old document\n+            // The old document should be empty\n+            val result4 = findOneAndUpdate(Document(\"hello\", \"hellothere\"), Document(\"\\$set\", doc3), FindOneAndModifyOptions().upsert(true)).blockingGetResult()\n+            assertNull(result4)\n+            assertEquals(3, count().blockingGetResult())\n+\n+            // Test sort and project\n+//            assertEquals(listOf(doc1, doc2, doc3),\n+//                    withoutIds(Tasks.await<MutableList<Document>>(coll.find().into(mutableListOf()))))\n+\n+            val sampleProject = Document(\"hello\", 1)\n+            sampleProject[\"_id\"] = 0\n+\n+            val result5 = findOneAndUpdate(Document(), sampleUpdate, FindOneAndModifyOptions().projection(sampleProject).sort(Document(\"num\", 1))).blockingGetResult()\n+            assertEquals(Document(\"hello\", \"world1\"), result5!!.withoutId())\n+            assertEquals(3, count().blockingGetResult())\n+\n+            val result6 = findOneAndUpdate(Document(), sampleUpdate, FindOneAndModifyOptions().projection(sampleProject).sort(Document(\"num\", -1))).blockingGetResult()\n+            assertEquals(Document(\"hello\", \"world3\"), result6!!.withoutId())\n+            assertEquals(3, count().blockingGetResult())\n+\n+            // Test proper failure\n+//            try {\n+//                Tasks.await(coll.findOneAndUpdate(Document(), Document(\"\\$who\", 1)))\n+//                fail()\n+//            } catch (ex: ExecutionException) {\n+//                assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+//\n+//            try {\n+//                Tasks.await(coll.findOneAndUpdate(Document(), Document(\"\\$who\", 1),\n+//                        FindOneAndModifyOptions().upsert(true)))\n+//                fail()\n+//            } catch (ex: ExecutionException) {\n+//                assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun find() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            // FIXME: fix find implementation - ignore this code for code review\n+            val iter = find().blockingGetResult()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxNTI4MQ=="}, "originalCommit": {"oid": "56a0f3ec1b0f457466941ebf1fd7b59a89ada2a9"}, "originalPosition": 277}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4NzE3Ng==", "bodyText": "But in this case makes sense, because I know with 100% certainty I will not receive a null result. I will move the !!.", "url": "https://github.com/realm/realm-java/pull/6869#discussion_r429887176", "createdAt": "2020-05-25T11:35:01Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -260,6 +263,194 @@ class MongoCollectionTest {\n         }\n     }\n \n+    @Test\n+    fun updateOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world\")\n+            val result1 = updateOne(Document(), doc1).blockingGetResult()\n+            assertEquals(0, result1!!.matchedCount)\n+            assertEquals(0, result1.modifiedCount)\n+            assertNull(result1.upsertedId)\n+\n+            val options2 = UpdateOptions().upsert(true)\n+            val result2 = updateOne(Document(), doc1, options2).blockingGetResult()\n+            assertEquals(0, result2!!.matchedCount)\n+            assertEquals(0, result2.modifiedCount)\n+            assertFalse(result2.upsertedId!!.isNull)\n+\n+            val result3 = updateOne(Document(), Document(\"\\$set\", Document(\"woof\", \"meow\"))).blockingGetResult()\n+            assertEquals(1, result3!!.matchedCount)\n+            assertEquals(1, result3.modifiedCount)\n+            assertNull(result3.upsertedId)\n+\n+//            val expectedDoc = Document(\"hello\", \"world\")\n+//            expectedDoc[\"woof\"] = \"meow\"\n+//            assertEquals(expectedDoc, withoutId(Tasks.await(coll.find(Document()).first())))\n+//\n+//            try {\n+//                Tasks.await(coll.updateOne(Document(\"\\$who\", 1), Document()))\n+//                fail()\n+//            } catch (ex: ExecutionException) {\n+//                assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun updateMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world\")\n+            val result1 = updateMany(Document(), doc1).blockingGetResult()\n+            assertEquals(0, result1!!.matchedCount)\n+            assertEquals(0, result1.modifiedCount)\n+            assertNull(result1.upsertedId)\n+\n+            val options2 = UpdateOptions().upsert(true)\n+            val result2 = updateMany(Document(), doc1, options2).blockingGetResult()\n+            assertEquals(0, result2!!.matchedCount)\n+            assertEquals(0, result2.modifiedCount)\n+            assertNotNull(result2.upsertedId)\n+\n+            val result3 = updateMany(Document(), Document(\"\\$set\", Document(\"woof\", \"meow\"))).blockingGetResult()\n+            assertEquals(1, result3!!.matchedCount)\n+            assertEquals(1, result3.modifiedCount)\n+            assertNull(result3.upsertedId)\n+\n+            insertOne(Document()).blockingGetResult()\n+            val result4 = updateMany(Document(), Document(\"\\$set\", Document(\"woof\", \"meow\"))).blockingGetResult()\n+            assertEquals(2, result4!!.matchedCount)\n+            assertEquals(2, result4.modifiedCount)\n+\n+//            val expectedDoc1 = Document(\"hello\", \"world\")\n+//            expectedDoc1[\"woof\"] = \"meow\"\n+//            val expectedDoc2 = Document(\"woof\", \"meow\")\n+//            assertEquals(listOf(expectedDoc1, expectedDoc2), withoutIds(Tasks.await<MutableList<Document>>(coll.find(Document()).into(mutableListOf()))))\n+//\n+//            try {\n+//                Tasks.await(coll.updateMany(Document(\"\\$who\", 1), Document()))\n+//                fail()\n+//            } catch (ex: ExecutionException) {\n+//                assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    @Ignore\n+    // FIXME: revisit when parser is fully operational\n+    fun findOneAndUpdate() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val sampleDoc = Document(\"hello\", \"world1\")\n+            sampleDoc[\"num\"] = 2\n+\n+            // Collection should start out empty\n+            // This also tests the null return format\n+            assertNull(findOneAndUpdate(Document(), Document()).blockingGetResult())\n+\n+            // Insert a sample Document\n+            insertOne(sampleDoc).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Sample call to findOneAndUpdate() where we get the previous document back\n+            val sampleUpdate = Document(\"\\$set\", Document(\"hello\", \"hellothere\"))\n+            sampleUpdate[\"\\$inc\"] = Document(\"num\", 1)\n+            assertEquals(sampleDoc.withoutId(), findOneAndUpdate(Document(\"hello\", \"world1\"), sampleUpdate).blockingGetResult())\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Make sure the update took place\n+            val expectedDoc = Document(\"hello\", \"hellothere\")\n+            expectedDoc[\"num\"] = 3\n+//            assertEquals(expectedDoc.withoutId(), withoutId(Tasks.await(coll.find().first())))\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Call findOneAndUpdate() again but get the new document\n+            sampleUpdate.remove(\"\\$set\")\n+            expectedDoc[\"num\"] = 4\n+            val result = findOneAndUpdate(Document(\"hello\", \"hellothere\"), sampleUpdate, FindOneAndModifyOptions().returnNewDocument(true)).blockingGetResult()\n+            assertEquals(expectedDoc.withoutId(), result!!.withoutId())\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Test null behaviour again with a filter that should not match any documents\n+            assertNull(findOneAndUpdate(Document(\"hello\", \"zzzzz\"), Document()).blockingGetResult())\n+            assertEquals(1, count().blockingGetResult())\n+\n+            val doc1 = Document(\"hello\", \"world1\")\n+            doc1[\"num\"] = 1\n+\n+            val doc2 = Document(\"hello\", \"world2\")\n+            doc2[\"num\"] = 2\n+\n+            val doc3 = Document(\"hello\", \"world3\")\n+            doc3[\"num\"] = 3\n+\n+            // Test the upsert option where it should not actually be invoked\n+            val result2 = findOneAndUpdate(Document(\"hello\", \"hellothere\"), Document(\"\\$set\", doc1), FindOneAndModifyOptions().returnNewDocument(true).upsert(true)).blockingGetResult()\n+            assertEquals(doc1, result2!!.withoutId())\n+            assertEquals(1, count().blockingGetResult())\n+//            assertEquals(doc1.withoutId(), withoutId(Tasks.await(coll.find().first())))\n+\n+            // Test the upsert option where the server should perform upsert and return new document\n+            val result3 = findOneAndUpdate(Document(\"hello\", \"hellothere\"), Document(\"\\$set\", doc2), FindOneAndModifyOptions().returnNewDocument(true).upsert(true)).blockingGetResult()\n+            assertEquals(doc2, result3!!.withoutId())\n+            assertEquals(2, count().blockingGetResult())\n+\n+            // Test the upsert option where the server should perform upsert and return old document\n+            // The old document should be empty\n+            val result4 = findOneAndUpdate(Document(\"hello\", \"hellothere\"), Document(\"\\$set\", doc3), FindOneAndModifyOptions().upsert(true)).blockingGetResult()\n+            assertNull(result4)\n+            assertEquals(3, count().blockingGetResult())\n+\n+            // Test sort and project\n+//            assertEquals(listOf(doc1, doc2, doc3),\n+//                    withoutIds(Tasks.await<MutableList<Document>>(coll.find().into(mutableListOf()))))\n+\n+            val sampleProject = Document(\"hello\", 1)\n+            sampleProject[\"_id\"] = 0\n+\n+            val result5 = findOneAndUpdate(Document(), sampleUpdate, FindOneAndModifyOptions().projection(sampleProject).sort(Document(\"num\", 1))).blockingGetResult()\n+            assertEquals(Document(\"hello\", \"world1\"), result5!!.withoutId())\n+            assertEquals(3, count().blockingGetResult())\n+\n+            val result6 = findOneAndUpdate(Document(), sampleUpdate, FindOneAndModifyOptions().projection(sampleProject).sort(Document(\"num\", -1))).blockingGetResult()\n+            assertEquals(Document(\"hello\", \"world3\"), result6!!.withoutId())\n+            assertEquals(3, count().blockingGetResult())\n+\n+            // Test proper failure\n+//            try {\n+//                Tasks.await(coll.findOneAndUpdate(Document(), Document(\"\\$who\", 1)))\n+//                fail()\n+//            } catch (ex: ExecutionException) {\n+//                assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+//\n+//            try {\n+//                Tasks.await(coll.findOneAndUpdate(Document(), Document(\"\\$who\", 1),\n+//                        FindOneAndModifyOptions().upsert(true)))\n+//                fail()\n+//            } catch (ex: ExecutionException) {\n+//                assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun find() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            // FIXME: fix find implementation - ignore this code for code review\n+            val iter = find().blockingGetResult()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxNTI4MQ=="}, "originalCommit": {"oid": "56a0f3ec1b0f457466941ebf1fd7b59a89ada2a9"}, "originalPosition": 277}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 715, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}