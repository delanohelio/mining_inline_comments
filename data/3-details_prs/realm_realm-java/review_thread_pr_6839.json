{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzOTQ4MjI2", "number": 6839, "reviewThreads": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo1OTo0MVrOD8VRjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMDoyMTo0OVrOD80REA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTg5NzExOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo1OTo0MVrOGVNGdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo1OTo0MVrOGVNGdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4NzkyNg==", "bodyText": "This is useful for working on tests, but should normally not be part of the test. It will affect all other tests as well unless you reset it in tearDown", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424887926", "createdAt": "2020-05-14T05:59:41Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.remote.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class RemoteMongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: RemoteMongoClient\n+    private lateinit var database: RemoteMongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.DEBUG)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTkwNDQ4OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjowMjo1NFrOGVNKsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo1Mjo1MVrOGVYtOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4OTAxMA==", "bodyText": "Nitpick, I would normally place the companion object at the top as I see it as static functions used by most of the class, so first finding the definition for them at the bottom makes reading the code from top -> bottom a bit hard.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424889010", "createdAt": "2020-05-14T06:02:54Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.remote.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class RemoteMongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: RemoteMongoClient\n+    private lateinit var database: RemoteMongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(2, count(rawDoc, RemoteCountOptions().limit(2)).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+//            val doc1withId = Document(rawDoc.withId())\n+            val doc2 = Document(rawDoc)\n+\n+            // FIXME: check feasibility of this assertion, otherwise, just make a plain insert\n+//            insertOne(doc1withId).blockingGetResult().let {\n+//                assertTrue(ObjectId.isValid(it!!.insertedId.toString()))\n+//                assertEquals(doc1withId[\"_id\"], it.insertedId)\n+//            }\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(1, count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())\n+\n+            // FIXME: investigate error handling for malformed payloads\n+//            assertFailsWith(ExecutionException::class) {\n+//                this.count(Document(\"\\$who\", 1)).blockingGetResult()\n+//                fail(\"Should not reach this!\")\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteOne(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(1, deleteOne(rawDoc).blockingGetResult()!!.deletedCount)\n+            assertEquals(1, deleteOne(Document()).blockingGetResult()!!.deletedCount)\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteMany(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(2, deleteMany(rawDoc).blockingGetResult()!!.deletedCount)                 // two docs will be deleted\n+            assertEquals(2, count().blockingGetResult())                                           // two docs still present\n+            assertEquals(2, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(4, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun findOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world1\")\n+            val doc2 = Document(\"hello\", \"world2\")\n+            val doc3 = Document(\"hello\", \"world3\")\n+\n+            // Test findOne() on empty collection with no filter and no options\n+            assertNull(findOne().blockingGetResult())\n+\n+            // Insert a document into the collection\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Test findOne() with no filter and no options\n+            assertEquals(doc1, findOne().blockingGetResult()!!.withoutId())\n+\n+            // Test findOne() with filter that does not match any documents and no options\n+            assertNull(findOne(Document(\"hello\", \"worldDNE\")).blockingGetResult())\n+\n+            // Insert 2 more documents into the collection\n+            insertMany(listOf(doc2, doc3)).blockingGetResult()\n+            assertEquals(3, count().blockingGetResult())\n+\n+            // FIXME: add these when all findOne methods are ready and the parser works\n+            // test findOne() with projection and sort options\n+//            val projection = Document(\"hello\", \"1\")\n+//            projection[\"_id\"] = 0\n+//            val options = RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", \"1\"))\n+//            assertEquals(findOne(Document(), options).blockingGetResult(), doc1.withoutId())\n+\n+            // FIXME: adapt to our framework\n+//            val result3 = Tasks.await(coll.findOne(Document(), RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", -1))))\n+//            Assert.assertEquals(result3, withoutId(doc3))\n+//\n+//            // test findOne() properly fails\n+//            try {\n+//                Tasks.await(coll.findOne(Document(\"\\$who\", 1)))\n+//                Assert.fail()\n+//            } catch (ex: ExecutionException) {\n+//                Assert.assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    // FIXME: more to come\n+\n+    private fun getCollectionInternal(collectionName: String, javaClass: Class<Document>? = null): RemoteMongoCollection<Document> {\n+        return when (javaClass) {\n+            null -> database.getCollection(collectionName)\n+            else -> database.getCollection(collectionName, javaClass)\n+        }\n+    }\n+\n+    private fun Document.withId(objectId: ObjectId? = null): Document {\n+        return apply { this[\"_id\"] = objectId ?: ObjectId() }\n+    }\n+\n+    private fun Document.withoutId(): Document {\n+        return apply { remove(\"_id\") }\n+    }\n+\n+    private companion object {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA1ODY4Mw==", "bodyText": "True, and that's how I would normally do it for Java classes, but I am following Kotlin's style guide on companion objects: https://kotlinlang.org/docs/reference/coding-conventions.html#source-code-organization", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425058683", "createdAt": "2020-05-14T11:15:05Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.remote.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class RemoteMongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: RemoteMongoClient\n+    private lateinit var database: RemoteMongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(2, count(rawDoc, RemoteCountOptions().limit(2)).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+//            val doc1withId = Document(rawDoc.withId())\n+            val doc2 = Document(rawDoc)\n+\n+            // FIXME: check feasibility of this assertion, otherwise, just make a plain insert\n+//            insertOne(doc1withId).blockingGetResult().let {\n+//                assertTrue(ObjectId.isValid(it!!.insertedId.toString()))\n+//                assertEquals(doc1withId[\"_id\"], it.insertedId)\n+//            }\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(1, count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())\n+\n+            // FIXME: investigate error handling for malformed payloads\n+//            assertFailsWith(ExecutionException::class) {\n+//                this.count(Document(\"\\$who\", 1)).blockingGetResult()\n+//                fail(\"Should not reach this!\")\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteOne(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(1, deleteOne(rawDoc).blockingGetResult()!!.deletedCount)\n+            assertEquals(1, deleteOne(Document()).blockingGetResult()!!.deletedCount)\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteMany(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(2, deleteMany(rawDoc).blockingGetResult()!!.deletedCount)                 // two docs will be deleted\n+            assertEquals(2, count().blockingGetResult())                                           // two docs still present\n+            assertEquals(2, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(4, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun findOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world1\")\n+            val doc2 = Document(\"hello\", \"world2\")\n+            val doc3 = Document(\"hello\", \"world3\")\n+\n+            // Test findOne() on empty collection with no filter and no options\n+            assertNull(findOne().blockingGetResult())\n+\n+            // Insert a document into the collection\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Test findOne() with no filter and no options\n+            assertEquals(doc1, findOne().blockingGetResult()!!.withoutId())\n+\n+            // Test findOne() with filter that does not match any documents and no options\n+            assertNull(findOne(Document(\"hello\", \"worldDNE\")).blockingGetResult())\n+\n+            // Insert 2 more documents into the collection\n+            insertMany(listOf(doc2, doc3)).blockingGetResult()\n+            assertEquals(3, count().blockingGetResult())\n+\n+            // FIXME: add these when all findOne methods are ready and the parser works\n+            // test findOne() with projection and sort options\n+//            val projection = Document(\"hello\", \"1\")\n+//            projection[\"_id\"] = 0\n+//            val options = RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", \"1\"))\n+//            assertEquals(findOne(Document(), options).blockingGetResult(), doc1.withoutId())\n+\n+            // FIXME: adapt to our framework\n+//            val result3 = Tasks.await(coll.findOne(Document(), RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", -1))))\n+//            Assert.assertEquals(result3, withoutId(doc3))\n+//\n+//            // test findOne() properly fails\n+//            try {\n+//                Tasks.await(coll.findOne(Document(\"\\$who\", 1)))\n+//                Assert.fail()\n+//            } catch (ex: ExecutionException) {\n+//                Assert.assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    // FIXME: more to come\n+\n+    private fun getCollectionInternal(collectionName: String, javaClass: Class<Document>? = null): RemoteMongoCollection<Document> {\n+        return when (javaClass) {\n+            null -> database.getCollection(collectionName)\n+            else -> database.getCollection(collectionName, javaClass)\n+        }\n+    }\n+\n+    private fun Document.withId(objectId: ObjectId? = null): Document {\n+        return apply { this[\"_id\"] = objectId ?: ObjectId() }\n+    }\n+\n+    private fun Document.withoutId(): Document {\n+        return apply { remove(\"_id\") }\n+    }\n+\n+    private companion object {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4OTAxMA=="}, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2MDc5MA==", "bodyText": "Fair enough. I wonder if we should have these in companion objects in that case or if it would make sense to convert them to const vals at the top of the file?", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425060790", "createdAt": "2020-05-14T11:18:51Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.remote.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class RemoteMongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: RemoteMongoClient\n+    private lateinit var database: RemoteMongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(2, count(rawDoc, RemoteCountOptions().limit(2)).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+//            val doc1withId = Document(rawDoc.withId())\n+            val doc2 = Document(rawDoc)\n+\n+            // FIXME: check feasibility of this assertion, otherwise, just make a plain insert\n+//            insertOne(doc1withId).blockingGetResult().let {\n+//                assertTrue(ObjectId.isValid(it!!.insertedId.toString()))\n+//                assertEquals(doc1withId[\"_id\"], it.insertedId)\n+//            }\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(1, count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())\n+\n+            // FIXME: investigate error handling for malformed payloads\n+//            assertFailsWith(ExecutionException::class) {\n+//                this.count(Document(\"\\$who\", 1)).blockingGetResult()\n+//                fail(\"Should not reach this!\")\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteOne(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(1, deleteOne(rawDoc).blockingGetResult()!!.deletedCount)\n+            assertEquals(1, deleteOne(Document()).blockingGetResult()!!.deletedCount)\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteMany(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(2, deleteMany(rawDoc).blockingGetResult()!!.deletedCount)                 // two docs will be deleted\n+            assertEquals(2, count().blockingGetResult())                                           // two docs still present\n+            assertEquals(2, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(4, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun findOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world1\")\n+            val doc2 = Document(\"hello\", \"world2\")\n+            val doc3 = Document(\"hello\", \"world3\")\n+\n+            // Test findOne() on empty collection with no filter and no options\n+            assertNull(findOne().blockingGetResult())\n+\n+            // Insert a document into the collection\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Test findOne() with no filter and no options\n+            assertEquals(doc1, findOne().blockingGetResult()!!.withoutId())\n+\n+            // Test findOne() with filter that does not match any documents and no options\n+            assertNull(findOne(Document(\"hello\", \"worldDNE\")).blockingGetResult())\n+\n+            // Insert 2 more documents into the collection\n+            insertMany(listOf(doc2, doc3)).blockingGetResult()\n+            assertEquals(3, count().blockingGetResult())\n+\n+            // FIXME: add these when all findOne methods are ready and the parser works\n+            // test findOne() with projection and sort options\n+//            val projection = Document(\"hello\", \"1\")\n+//            projection[\"_id\"] = 0\n+//            val options = RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", \"1\"))\n+//            assertEquals(findOne(Document(), options).blockingGetResult(), doc1.withoutId())\n+\n+            // FIXME: adapt to our framework\n+//            val result3 = Tasks.await(coll.findOne(Document(), RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", -1))))\n+//            Assert.assertEquals(result3, withoutId(doc3))\n+//\n+//            // test findOne() properly fails\n+//            try {\n+//                Tasks.await(coll.findOne(Document(\"\\$who\", 1)))\n+//                Assert.fail()\n+//            } catch (ex: ExecutionException) {\n+//                Assert.assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    // FIXME: more to come\n+\n+    private fun getCollectionInternal(collectionName: String, javaClass: Class<Document>? = null): RemoteMongoCollection<Document> {\n+        return when (javaClass) {\n+            null -> database.getCollection(collectionName)\n+            else -> database.getCollection(collectionName, javaClass)\n+        }\n+    }\n+\n+    private fun Document.withId(objectId: ObjectId? = null): Document {\n+        return apply { this[\"_id\"] = objectId ?: ObjectId() }\n+    }\n+\n+    private fun Document.withoutId(): Document {\n+        return apply { remove(\"_id\") }\n+    }\n+\n+    private companion object {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4OTAxMA=="}, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3ODA3NA==", "bodyText": "The rule is companion objects should be used if the constants declared in them are class-scoped, and top-level constants should be used if they have a wider scope. I could see some of these might be used in the future elsewhere outside this test, but for now, they belong in this test. This could easily piggyback on using base classes for certain tests and such.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425078074", "createdAt": "2020-05-14T11:52:51Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.remote.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class RemoteMongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: RemoteMongoClient\n+    private lateinit var database: RemoteMongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(2, count(rawDoc, RemoteCountOptions().limit(2)).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+//            val doc1withId = Document(rawDoc.withId())\n+            val doc2 = Document(rawDoc)\n+\n+            // FIXME: check feasibility of this assertion, otherwise, just make a plain insert\n+//            insertOne(doc1withId).blockingGetResult().let {\n+//                assertTrue(ObjectId.isValid(it!!.insertedId.toString()))\n+//                assertEquals(doc1withId[\"_id\"], it.insertedId)\n+//            }\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(1, count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())\n+\n+            // FIXME: investigate error handling for malformed payloads\n+//            assertFailsWith(ExecutionException::class) {\n+//                this.count(Document(\"\\$who\", 1)).blockingGetResult()\n+//                fail(\"Should not reach this!\")\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteOne(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(1, deleteOne(rawDoc).blockingGetResult()!!.deletedCount)\n+            assertEquals(1, deleteOne(Document()).blockingGetResult()!!.deletedCount)\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteMany(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(2, deleteMany(rawDoc).blockingGetResult()!!.deletedCount)                 // two docs will be deleted\n+            assertEquals(2, count().blockingGetResult())                                           // two docs still present\n+            assertEquals(2, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(4, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun findOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world1\")\n+            val doc2 = Document(\"hello\", \"world2\")\n+            val doc3 = Document(\"hello\", \"world3\")\n+\n+            // Test findOne() on empty collection with no filter and no options\n+            assertNull(findOne().blockingGetResult())\n+\n+            // Insert a document into the collection\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Test findOne() with no filter and no options\n+            assertEquals(doc1, findOne().blockingGetResult()!!.withoutId())\n+\n+            // Test findOne() with filter that does not match any documents and no options\n+            assertNull(findOne(Document(\"hello\", \"worldDNE\")).blockingGetResult())\n+\n+            // Insert 2 more documents into the collection\n+            insertMany(listOf(doc2, doc3)).blockingGetResult()\n+            assertEquals(3, count().blockingGetResult())\n+\n+            // FIXME: add these when all findOne methods are ready and the parser works\n+            // test findOne() with projection and sort options\n+//            val projection = Document(\"hello\", \"1\")\n+//            projection[\"_id\"] = 0\n+//            val options = RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", \"1\"))\n+//            assertEquals(findOne(Document(), options).blockingGetResult(), doc1.withoutId())\n+\n+            // FIXME: adapt to our framework\n+//            val result3 = Tasks.await(coll.findOne(Document(), RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", -1))))\n+//            Assert.assertEquals(result3, withoutId(doc3))\n+//\n+//            // test findOne() properly fails\n+//            try {\n+//                Tasks.await(coll.findOne(Document(\"\\$who\", 1)))\n+//                Assert.fail()\n+//            } catch (ex: ExecutionException) {\n+//                Assert.assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    // FIXME: more to come\n+\n+    private fun getCollectionInternal(collectionName: String, javaClass: Class<Document>? = null): RemoteMongoCollection<Document> {\n+        return when (javaClass) {\n+            null -> database.getCollection(collectionName)\n+            else -> database.getCollection(collectionName, javaClass)\n+        }\n+    }\n+\n+    private fun Document.withId(objectId: ObjectId? = null): Document {\n+        return apply { this[\"_id\"] = objectId ?: ObjectId() }\n+    }\n+\n+    private fun Document.withoutId(): Document {\n+        return apply { remove(\"_id\") }\n+    }\n+\n+    private companion object {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4OTAxMA=="}, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTkxNzMyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjowOTozMlrOGVNS0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTozNzowNlrOGVYNbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5MTA5MA==", "bodyText": "This seems to be a test for RemoteCountOptions instead of insertMany, so I would probably move this to its own test.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424891090", "createdAt": "2020-05-14T06:09:32Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.remote.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class RemoteMongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: RemoteMongoClient\n+    private lateinit var database: RemoteMongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(2, count(rawDoc, RemoteCountOptions().limit(2)).blockingGetResult())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2OTkzMg==", "bodyText": "I think the best options is to do it as a part of testing count - see comment below.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425069932", "createdAt": "2020-05-14T11:37:06Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.remote.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class RemoteMongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: RemoteMongoClient\n+    private lateinit var database: RemoteMongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(2, count(rawDoc, RemoteCountOptions().limit(2)).blockingGetResult())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5MTA5MA=="}, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTkxODgyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjoxMDoxMVrOGVNTvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMToxOTowMVrOGVXqBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5MTMyNw==", "bodyText": "I'm missing tests for error scenarios, not 100% sure which ones exist, but we should not only test the happy path. This is true for most of the tests in this class.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424891327", "createdAt": "2020-05-14T06:10:11Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.remote.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class RemoteMongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: RemoteMongoClient\n+    private lateinit var database: RemoteMongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2MDg2OQ==", "bodyText": "Yeah, this is the first iteration. It has been a bit hard to produce exception scenarios given that the parser isn't 100% ready yet. Also, my approach to this is to port the existing tests on collections from the Stitch SDK. I guess it will be clearer once the parser is fully fixed.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425060869", "createdAt": "2020-05-14T11:19:01Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.remote.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class RemoteMongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: RemoteMongoClient\n+    private lateinit var database: RemoteMongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5MTMyNw=="}, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTkyMTQ1OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjoxMToyMVrOGVNVZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMToyODowM1rOGVX7zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5MTc0OA==", "bodyText": "Same as before. Not sure this test belongs here.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424891748", "createdAt": "2020-05-14T06:11:21Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.remote.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class RemoteMongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: RemoteMongoClient\n+    private lateinit var database: RemoteMongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(2, count(rawDoc, RemoteCountOptions().limit(2)).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+//            val doc1withId = Document(rawDoc.withId())\n+            val doc2 = Document(rawDoc)\n+\n+            // FIXME: check feasibility of this assertion, otherwise, just make a plain insert\n+//            insertOne(doc1withId).blockingGetResult().let {\n+//                assertTrue(ObjectId.isValid(it!!.insertedId.toString()))\n+//                assertEquals(doc1withId[\"_id\"], it.insertedId)\n+//            }\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(1, count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2NDc0Ng==", "bodyText": "Here it's more a question on perspective. They are an optional parameter in a count operation, so given that I'm testing count, I thought I should also test that count works fine given some options.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425064746", "createdAt": "2020-05-14T11:26:48Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.remote.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class RemoteMongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: RemoteMongoClient\n+    private lateinit var database: RemoteMongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(2, count(rawDoc, RemoteCountOptions().limit(2)).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+//            val doc1withId = Document(rawDoc.withId())\n+            val doc2 = Document(rawDoc)\n+\n+            // FIXME: check feasibility of this assertion, otherwise, just make a plain insert\n+//            insertOne(doc1withId).blockingGetResult().let {\n+//                assertTrue(ObjectId.isValid(it!!.insertedId.toString()))\n+//                assertEquals(doc1withId[\"_id\"], it.insertedId)\n+//            }\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(1, count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5MTc0OA=="}, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2NTQyMQ==", "bodyText": "Ah yeah, sorry. You are right. Here it makes sense", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425065421", "createdAt": "2020-05-14T11:28:03Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.remote.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class RemoteMongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: RemoteMongoClient\n+    private lateinit var database: RemoteMongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(2, count(rawDoc, RemoteCountOptions().limit(2)).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+//            val doc1withId = Document(rawDoc.withId())\n+            val doc2 = Document(rawDoc)\n+\n+            // FIXME: check feasibility of this assertion, otherwise, just make a plain insert\n+//            insertOne(doc1withId).blockingGetResult().let {\n+//                assertTrue(ObjectId.isValid(it!!.insertedId.toString()))\n+//                assertEquals(doc1withId[\"_id\"], it.insertedId)\n+//            }\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(1, count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5MTc0OA=="}, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTkyMzI4OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjoxMjoyMVrOGVNWrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjoxMjoyMVrOGVNWrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5MjA3OQ==", "bodyText": "I would split this into two tests deleteOne_singleDocument and deleteOne_listOfDocuments", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424892079", "createdAt": "2020-05-14T06:12:21Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.remote.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class RemoteMongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: RemoteMongoClient\n+    private lateinit var database: RemoteMongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(2, count(rawDoc, RemoteCountOptions().limit(2)).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+//            val doc1withId = Document(rawDoc.withId())\n+            val doc2 = Document(rawDoc)\n+\n+            // FIXME: check feasibility of this assertion, otherwise, just make a plain insert\n+//            insertOne(doc1withId).blockingGetResult().let {\n+//                assertTrue(ObjectId.isValid(it!!.insertedId.toString()))\n+//                assertEquals(doc1withId[\"_id\"], it.insertedId)\n+//            }\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(1, count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())\n+\n+            // FIXME: investigate error handling for malformed payloads\n+//            assertFailsWith(ExecutionException::class) {\n+//                this.count(Document(\"\\$who\", 1)).blockingGetResult()\n+//                fail(\"Should not reach this!\")\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteOne(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val doc1b = Document(rawDoc)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTkyNTA2OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjoxMzowN1rOGVNXxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjoxMzowN1rOGVNXxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5MjM1OQ==", "bodyText": "I need to get more used to reading Kotlin. Had to think a bit about what with did, but using it is fine I think \ud83d\udc4d", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424892359", "createdAt": "2020-05-14T06:13:07Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.remote.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class RemoteMongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: RemoteMongoClient\n+    private lateinit var database: RemoteMongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTkyNzU1OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjoxNDoxNVrOGVNZTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjoxNDoxNVrOGVNZTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5Mjc1MQ==", "bodyText": "Same as above. Would split into multiple tests.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424892751", "createdAt": "2020-05-14T06:14:15Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.remote.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class RemoteMongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: RemoteMongoClient\n+    private lateinit var database: RemoteMongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(2, count(rawDoc, RemoteCountOptions().limit(2)).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+//            val doc1withId = Document(rawDoc.withId())\n+            val doc2 = Document(rawDoc)\n+\n+            // FIXME: check feasibility of this assertion, otherwise, just make a plain insert\n+//            insertOne(doc1withId).blockingGetResult().let {\n+//                assertTrue(ObjectId.isValid(it!!.insertedId.toString()))\n+//                assertEquals(doc1withId[\"_id\"], it.insertedId)\n+//            }\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(1, count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())\n+\n+            // FIXME: investigate error handling for malformed payloads\n+//            assertFailsWith(ExecutionException::class) {\n+//                this.count(Document(\"\\$who\", 1)).blockingGetResult()\n+//                fail(\"Should not reach this!\")\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteOne(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(1, deleteOne(rawDoc).blockingGetResult()!!.deletedCount)\n+            assertEquals(1, deleteOne(Document()).blockingGetResult()!!.deletedCount)\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteMany(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(2, deleteMany(rawDoc).blockingGetResult()!!.deletedCount)                 // two docs will be deleted\n+            assertEquals(2, count().blockingGetResult())                                           // two docs still present\n+            assertEquals(2, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTkzMjEyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjoxNTo1OFrOGVNb6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjoxNTo1OFrOGVNb6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5MzQxOA==", "bodyText": "Generally, a unit test should only test one aspect. This test seems to test at least 5...Sometimes we do combine multiple behaviors into the same test if there is a lot of overhead in setting up a test, but I'm not sure this is one of them.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424893418", "createdAt": "2020-05-14T06:15:58Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/RemoteMongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.remote.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class RemoteMongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: RemoteMongoClient\n+    private lateinit var database: RemoteMongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(2, count(rawDoc, RemoteCountOptions().limit(2)).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+//            val doc1withId = Document(rawDoc.withId())\n+            val doc2 = Document(rawDoc)\n+\n+            // FIXME: check feasibility of this assertion, otherwise, just make a plain insert\n+//            insertOne(doc1withId).blockingGetResult().let {\n+//                assertTrue(ObjectId.isValid(it!!.insertedId.toString()))\n+//                assertEquals(doc1withId[\"_id\"], it.insertedId)\n+//            }\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(1, count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())\n+\n+            // FIXME: investigate error handling for malformed payloads\n+//            assertFailsWith(ExecutionException::class) {\n+//                this.count(Document(\"\\$who\", 1)).blockingGetResult()\n+//                fail(\"Should not reach this!\")\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteOne(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(1, deleteOne(rawDoc).blockingGetResult()!!.deletedCount)\n+            assertEquals(1, deleteOne(Document()).blockingGetResult()!!.deletedCount)\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)//.withId()\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteMany(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(2, deleteMany(rawDoc).blockingGetResult()!!.deletedCount)                 // two docs will be deleted\n+            assertEquals(2, count().blockingGetResult())                                           // two docs still present\n+            assertEquals(2, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(4, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun findOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world1\")\n+            val doc2 = Document(\"hello\", \"world2\")\n+            val doc3 = Document(\"hello\", \"world3\")\n+\n+            // Test findOne() on empty collection with no filter and no options", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTkzNzQ5OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/util/TaskUtils.kt", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjoxODoyM1rOGVNfJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo1NjoyMFrOGVY0FQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5NDI0Ng==", "bodyText": "We should probably find a common pattern for how to implement extension methods for classes. Personally I'm in favor of using <ClassName>Ext so TaskExt.kt. We have done that elsewhere. But I don't have strong preferences, so if you or @rorbech feels strongly about a specific approach we should probably align on it.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424894246", "createdAt": "2020-05-14T06:18:23Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/util/TaskUtils.kt", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.util\n+\n+import com.google.android.gms.tasks.Task\n+import java.util.concurrent.CountDownLatch\n+\n+/**\n+ * Returns the result of a [Task] in a synchronous way or will throw an exception if a failure is\n+ * detected. This operation blocks the thread on which it is called.\n+ *\n+ * @return the [T] result emitted by the task\n+ */\n+fun <T> Task<T>.blockingGetResult(): T? {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3ODQ4MA==", "bodyText": "I think it's a fair point. I will change the file name.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425078480", "createdAt": "2020-05-14T11:53:44Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/util/TaskUtils.kt", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.util\n+\n+import com.google.android.gms.tasks.Task\n+import java.util.concurrent.CountDownLatch\n+\n+/**\n+ * Returns the result of a [Task] in a synchronous way or will throw an exception if a failure is\n+ * detected. This operation blocks the thread on which it is called.\n+ *\n+ * @return the [T] result emitted by the task\n+ */\n+fun <T> Task<T>.blockingGetResult(): T? {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5NDI0Ng=="}, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3OTgyOQ==", "bodyText": "Also, just noticed this implementation might be moot. There is a Task.await method in the GMS library, which does basically this, although it wraps any possible exceptions inside ExecutionException. Whatever it is, I still think having a handy extension function is better than writing Task.await(myTask) every time.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425079829", "createdAt": "2020-05-14T11:56:20Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/util/TaskUtils.kt", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.util\n+\n+import com.google.android.gms.tasks.Task\n+import java.util.concurrent.CountDownLatch\n+\n+/**\n+ * Returns the result of a [Task] in a synchronous way or will throw an exception if a failure is\n+ * detected. This operation blocks the thread on which it is called.\n+ *\n+ * @return the [T] result emitted by the task\n+ */\n+fun <T> Task<T>.blockingGetResult(): T? {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5NDI0Ng=="}, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTk0MTgzOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/util/TaskUtilsKtTest.kt", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjoyMDoxOFrOGVNh2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo1ODo0M1rOGVY4pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5NDkzOQ==", "bodyText": "Great that you are testing the extension method specifically. Normally we don't have unit tests of internal helper methods as we assume they are being tested by the tests actually using them. But if you think it is valuable enough to have this, we can just keep it.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424894939", "createdAt": "2020-05-14T06:20:18Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/util/TaskUtilsKtTest.kt", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.util\n+\n+import io.realm.internal.common.TaskDispatcher\n+import org.junit.Test\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertNull\n+import kotlin.test.fail\n+\n+class TaskUtilsKtTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA4MDk5OQ==", "bodyText": "I thought it would be nice to do it as it's using the task dispatching framework from Stitch internally.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425080999", "createdAt": "2020-05-14T11:58:43Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/util/TaskUtilsKtTest.kt", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.util\n+\n+import io.realm.internal.common.TaskDispatcher\n+import org.junit.Test\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertNull\n+import kotlin.test.fail\n+\n+class TaskUtilsKtTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5NDkzOQ=="}, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTk0ODI3OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjoyMjo1MlrOGVNlxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjowMzo1M1rOGVjY5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5NTk0MA==", "bodyText": "Does this also works if object_id is none (i.e. no value)?", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424895940", "createdAt": "2020-05-14T06:22:52Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "diffHunk": "@@ -33,13 +33,36 @@\n \n using namespace realm;\n using namespace realm::app;\n+using namespace realm::bson;\n using namespace realm::jni_util;\n using namespace realm::_impl;\n \n-static std::function<jobject(JNIEnv*, uint64_t)> collection_mapper = [](JNIEnv* env, uint64_t result) {\n+// This mapper works for both count and delete operations\n+static std::function<jobject(JNIEnv*, uint64_t)> collection_mapper_count = [](JNIEnv* env, uint64_t result) {\n     return JavaClassGlobalDef::new_long(env, result);\n };\n \n+static std::function<jobject(JNIEnv*, util::Optional<bson::BsonDocument>)> collection_mapper_find_one = [](JNIEnv* env, util::Optional<bson::BsonDocument> document) {\n+    return document ? JniBsonProtocol::bson_to_jstring(env, *document) : NULL;\n+};\n+\n+static std::function<jobject(JNIEnv*, util::Optional<ObjectId>)> collection_mapper_insert_one = [](JNIEnv* env, util::Optional<ObjectId> object_id) {\n+    return JavaClassGlobalDef::new_object_id(env, object_id.value());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE1MTA1OA==", "bodyText": "Though technically possible, I doubt we can ever reach it. I'm guessing the only way object_id has no value is because there has been an error inserting the Bson, in which case the error callback will be triggered, e.g. inserting the same document with the same ID twice. I will make it throw an exception from here just in case:\n    if (object_id) {\n        return JavaClassGlobalDef::new_object_id(env, object_id.value());\n    }\n    throw util::invalid_argument(\"Error in 'insert_one', parameter 'object_id' has no value.\");", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425151058", "createdAt": "2020-05-14T13:48:49Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "diffHunk": "@@ -33,13 +33,36 @@\n \n using namespace realm;\n using namespace realm::app;\n+using namespace realm::bson;\n using namespace realm::jni_util;\n using namespace realm::_impl;\n \n-static std::function<jobject(JNIEnv*, uint64_t)> collection_mapper = [](JNIEnv* env, uint64_t result) {\n+// This mapper works for both count and delete operations\n+static std::function<jobject(JNIEnv*, uint64_t)> collection_mapper_count = [](JNIEnv* env, uint64_t result) {\n     return JavaClassGlobalDef::new_long(env, result);\n };\n \n+static std::function<jobject(JNIEnv*, util::Optional<bson::BsonDocument>)> collection_mapper_find_one = [](JNIEnv* env, util::Optional<bson::BsonDocument> document) {\n+    return document ? JniBsonProtocol::bson_to_jstring(env, *document) : NULL;\n+};\n+\n+static std::function<jobject(JNIEnv*, util::Optional<ObjectId>)> collection_mapper_insert_one = [](JNIEnv* env, util::Optional<ObjectId> object_id) {\n+    return JavaClassGlobalDef::new_object_id(env, object_id.value());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5NTk0MA=="}, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI1MzA5NQ==", "bodyText": "Fixed using suggestion from the comment below.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425253095", "createdAt": "2020-05-14T16:03:53Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "diffHunk": "@@ -33,13 +33,36 @@\n \n using namespace realm;\n using namespace realm::app;\n+using namespace realm::bson;\n using namespace realm::jni_util;\n using namespace realm::_impl;\n \n-static std::function<jobject(JNIEnv*, uint64_t)> collection_mapper = [](JNIEnv* env, uint64_t result) {\n+// This mapper works for both count and delete operations\n+static std::function<jobject(JNIEnv*, uint64_t)> collection_mapper_count = [](JNIEnv* env, uint64_t result) {\n     return JavaClassGlobalDef::new_long(env, result);\n };\n \n+static std::function<jobject(JNIEnv*, util::Optional<bson::BsonDocument>)> collection_mapper_find_one = [](JNIEnv* env, util::Optional<bson::BsonDocument> document) {\n+    return document ? JniBsonProtocol::bson_to_jstring(env, *document) : NULL;\n+};\n+\n+static std::function<jobject(JNIEnv*, util::Optional<ObjectId>)> collection_mapper_insert_one = [](JNIEnv* env, util::Optional<ObjectId> object_id) {\n+    return JavaClassGlobalDef::new_object_id(env, object_id.value());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5NTk0MA=="}, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTk1NDE0OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjoyNToyOFrOGVNpdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjoyNToyOFrOGVNpdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5Njg4NA==", "bodyText": "Nitpick...normally we would use auto collection here since the type is inside the reinterpret_cast ... just like Kotlin val name = Type(). Both here and in a lot of other places", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424896884", "createdAt": "2020-05-14T06:25:28Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "diffHunk": "@@ -58,9 +81,110 @@ Java_io_realm_internal_objectstore_OsRemoteMongoCollection_nativeCount(JNIEnv* e\n                                                                        jobject j_callback) {\n     try {\n         RemoteMongoCollection* collection = reinterpret_cast<RemoteMongoCollection*>(j_collection_ptr);\n-        bson::BsonDocument filter(JniBsonProtocol::jstring_to_bson(env, j_filter));\n+        bson::BsonDocument bson_filter(JniBsonProtocol::jstring_to_bson(env, j_filter));\n         uint64_t limit = std::uint64_t(j_limit);\n-        collection->count(filter, limit, JavaNetworkTransport::create_result_callback(env, j_callback, collection_mapper));\n+        collection->count(bson_filter, limit, JavaNetworkTransport::create_result_callback(env, j_callback, collection_mapper_count));\n+    }\n+    CATCH_STD()\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_io_realm_internal_objectstore_OsRemoteMongoCollection_nativeFindOne(JNIEnv* env,\n+                                                                         jclass,\n+                                                                         jlong j_collection_ptr,\n+                                                                         jstring j_document,\n+                                                                         jobject j_callback) {\n+    try {\n+        RemoteMongoCollection* collection = reinterpret_cast<RemoteMongoCollection*>(j_collection_ptr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b443d7a877a5f6d5e09605235d50be9e34dd9d1"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjIxNDU0OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNzo1MTo1OVrOGVQKqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNDowMDoxMlrOGVdr_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkzODE1NA==", "bodyText": "Remember to handle if the object_id is not set", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424938154", "createdAt": "2020-05-14T07:51:59Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "diffHunk": "@@ -33,13 +33,36 @@\n \n using namespace realm;\n using namespace realm::app;\n+using namespace realm::bson;\n using namespace realm::jni_util;\n using namespace realm::_impl;\n \n-static std::function<jobject(JNIEnv*, uint64_t)> collection_mapper = [](JNIEnv* env, uint64_t result) {\n+// This mapper works for both count and delete operations\n+static std::function<jobject(JNIEnv*, uint64_t)> collection_mapper_count = [](JNIEnv* env, uint64_t result) {\n     return JavaClassGlobalDef::new_long(env, result);\n };\n \n+static std::function<jobject(JNIEnv*, util::Optional<bson::BsonDocument>)> collection_mapper_find_one = [](JNIEnv* env, util::Optional<bson::BsonDocument> document) {\n+    return document ? JniBsonProtocol::bson_to_jstring(env, *document) : NULL;\n+};\n+\n+static std::function<jobject(JNIEnv*, util::Optional<ObjectId>)> collection_mapper_insert_one = [](JNIEnv* env, util::Optional<ObjectId> object_id) {\n+    return JavaClassGlobalDef::new_object_id(env, object_id.value());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE1MTQxMQ==", "bodyText": "See comment above - would this error handling be correct?", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425151411", "createdAt": "2020-05-14T13:49:19Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "diffHunk": "@@ -33,13 +33,36 @@\n \n using namespace realm;\n using namespace realm::app;\n+using namespace realm::bson;\n using namespace realm::jni_util;\n using namespace realm::_impl;\n \n-static std::function<jobject(JNIEnv*, uint64_t)> collection_mapper = [](JNIEnv* env, uint64_t result) {\n+// This mapper works for both count and delete operations\n+static std::function<jobject(JNIEnv*, uint64_t)> collection_mapper_count = [](JNIEnv* env, uint64_t result) {\n     return JavaClassGlobalDef::new_long(env, result);\n };\n \n+static std::function<jobject(JNIEnv*, util::Optional<bson::BsonDocument>)> collection_mapper_find_one = [](JNIEnv* env, util::Optional<bson::BsonDocument> document) {\n+    return document ? JniBsonProtocol::bson_to_jstring(env, *document) : NULL;\n+};\n+\n+static std::function<jobject(JNIEnv*, util::Optional<ObjectId>)> collection_mapper_insert_one = [](JNIEnv* env, util::Optional<ObjectId> object_id) {\n+    return JavaClassGlobalDef::new_object_id(env, object_id.value());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkzODE1NA=="}, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE1OTY3Ng==", "bodyText": "Yes, conceptually, though IllegalArgumentException is probably not the right one. I did it like this https://github.com/realm/realm-java/pull/6810/files#diff-7e3f4a991bb3d13d71a4a8e0103745ecR32 in the Function PR.\nThe mapping of C++ exceptions to Java exceptions when using the CATCH_STD() can be found in https://github.com/realm/realm-java/blob/master/realm/realm-library/src/main/cpp/util.cpp#L49", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425159676", "createdAt": "2020-05-14T14:00:12Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "diffHunk": "@@ -33,13 +33,36 @@\n \n using namespace realm;\n using namespace realm::app;\n+using namespace realm::bson;\n using namespace realm::jni_util;\n using namespace realm::_impl;\n \n-static std::function<jobject(JNIEnv*, uint64_t)> collection_mapper = [](JNIEnv* env, uint64_t result) {\n+// This mapper works for both count and delete operations\n+static std::function<jobject(JNIEnv*, uint64_t)> collection_mapper_count = [](JNIEnv* env, uint64_t result) {\n     return JavaClassGlobalDef::new_long(env, result);\n };\n \n+static std::function<jobject(JNIEnv*, util::Optional<bson::BsonDocument>)> collection_mapper_find_one = [](JNIEnv* env, util::Optional<bson::BsonDocument> document) {\n+    return document ? JniBsonProtocol::bson_to_jstring(env, *document) : NULL;\n+};\n+\n+static std::function<jobject(JNIEnv*, util::Optional<ObjectId>)> collection_mapper_insert_one = [](JNIEnv* env, util::Optional<ObjectId> object_id) {\n+    return JavaClassGlobalDef::new_object_id(env, object_id.value());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkzODE1NA=="}, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjIxNzAzOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNzo1Mjo0NFrOGVQMTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMzo1NDoxMFrOGVdZ7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkzODU3Mw==", "bodyText": "Remember to handle if the object_id is not set", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424938573", "createdAt": "2020-05-14T07:52:44Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "diffHunk": "@@ -33,13 +33,36 @@\n \n using namespace realm;\n using namespace realm::app;\n+using namespace realm::bson;\n using namespace realm::jni_util;\n using namespace realm::_impl;\n \n-static std::function<jobject(JNIEnv*, uint64_t)> collection_mapper = [](JNIEnv* env, uint64_t result) {\n+// This mapper works for both count and delete operations\n+static std::function<jobject(JNIEnv*, uint64_t)> collection_mapper_count = [](JNIEnv* env, uint64_t result) {\n     return JavaClassGlobalDef::new_long(env, result);\n };\n \n+static std::function<jobject(JNIEnv*, util::Optional<bson::BsonDocument>)> collection_mapper_find_one = [](JNIEnv* env, util::Optional<bson::BsonDocument> document) {\n+    return document ? JniBsonProtocol::bson_to_jstring(env, *document) : NULL;\n+};\n+\n+static std::function<jobject(JNIEnv*, util::Optional<ObjectId>)> collection_mapper_insert_one = [](JNIEnv* env, util::Optional<ObjectId> object_id) {\n+    return JavaClassGlobalDef::new_object_id(env, object_id.value());\n+};\n+\n+static std::function<jobject(JNIEnv*, std::vector<ObjectId>)> collection_mapper_insert_many = [](JNIEnv* env, std::vector<ObjectId> object_ids) {\n+    jobjectArray arr = (jobjectArray)env->NewObjectArray(static_cast<jsize>(object_ids.size()), JavaClassGlobalDef::java_lang_object(), NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE1NTA1Mg==", "bodyText": "This isn't an Optional. What I could do instead is to check whether the array is empty or not. In case it's empty then we can throw an exception, although it should never reach that point in here, as the only scenario I can think of would generate an empty array is a failure in inserting the documents, which would trigger an error callback.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425155052", "createdAt": "2020-05-14T13:54:10Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "diffHunk": "@@ -33,13 +33,36 @@\n \n using namespace realm;\n using namespace realm::app;\n+using namespace realm::bson;\n using namespace realm::jni_util;\n using namespace realm::_impl;\n \n-static std::function<jobject(JNIEnv*, uint64_t)> collection_mapper = [](JNIEnv* env, uint64_t result) {\n+// This mapper works for both count and delete operations\n+static std::function<jobject(JNIEnv*, uint64_t)> collection_mapper_count = [](JNIEnv* env, uint64_t result) {\n     return JavaClassGlobalDef::new_long(env, result);\n };\n \n+static std::function<jobject(JNIEnv*, util::Optional<bson::BsonDocument>)> collection_mapper_find_one = [](JNIEnv* env, util::Optional<bson::BsonDocument> document) {\n+    return document ? JniBsonProtocol::bson_to_jstring(env, *document) : NULL;\n+};\n+\n+static std::function<jobject(JNIEnv*, util::Optional<ObjectId>)> collection_mapper_insert_one = [](JNIEnv* env, util::Optional<ObjectId> object_id) {\n+    return JavaClassGlobalDef::new_object_id(env, object_id.value());\n+};\n+\n+static std::function<jobject(JNIEnv*, std::vector<ObjectId>)> collection_mapper_insert_many = [](JNIEnv* env, std::vector<ObjectId> object_ids) {\n+    jobjectArray arr = (jobjectArray)env->NewObjectArray(static_cast<jsize>(object_ids.size()), JavaClassGlobalDef::java_lang_object(), NULL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkzODU3Mw=="}, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjIzNzAwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNzo1ODoxMVrOGVQY6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNzo1ODoxMVrOGVQY6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk0MTgwMw==", "bodyText": "Looks like this can be fixed now?", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424941803", "createdAt": "2020-05-14T07:58:11Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "diffHunk": "@@ -58,9 +81,110 @@ Java_io_realm_internal_objectstore_OsRemoteMongoCollection_nativeCount(JNIEnv* e\n                                                                        jobject j_callback) {\n     try {\n         RemoteMongoCollection* collection = reinterpret_cast<RemoteMongoCollection*>(j_collection_ptr);\n-        bson::BsonDocument filter(JniBsonProtocol::jstring_to_bson(env, j_filter));\n+        bson::BsonDocument bson_filter(JniBsonProtocol::jstring_to_bson(env, j_filter));\n         uint64_t limit = std::uint64_t(j_limit);\n-        collection->count(filter, limit, JavaNetworkTransport::create_result_callback(env, j_callback, collection_mapper));\n+        collection->count(bson_filter, limit, JavaNetworkTransport::create_result_callback(env, j_callback, collection_mapper_count));\n+    }\n+    CATCH_STD()\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_io_realm_internal_objectstore_OsRemoteMongoCollection_nativeFindOne(JNIEnv* env,\n+                                                                         jclass,\n+                                                                         jlong j_collection_ptr,\n+                                                                         jstring j_document,\n+                                                                         jobject j_callback) {\n+    try {\n+        RemoteMongoCollection* collection = reinterpret_cast<RemoteMongoCollection*>(j_collection_ptr);\n+        bson::BsonDocument bson_filter(JniBsonProtocol::jstring_to_bson(env, j_document));\n+        collection->find_one(bson_filter, JavaNetworkTransport::create_result_callback(env, j_callback, collection_mapper_find_one));\n+    }\n+    CATCH_STD()\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_io_realm_internal_objectstore_OsRemoteMongoCollection_nativeFindOneWithOptions(JNIEnv* env,\n+                                                                         jclass,\n+                                                                         jlong j_collection_ptr,\n+                                                                         jstring j_filter,\n+                                                                         jstring j_projection,\n+                                                                         jstring j_sort,\n+                                                                         jlong j_limit,\n+                                                                         jobject j_callback) {\n+    try {\n+        RemoteMongoCollection* collection = reinterpret_cast<RemoteMongoCollection*>(j_collection_ptr);\n+        uint64_t limit = std::uint64_t(j_limit);\n+\n+        // FIXME: remove redundant variables", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjI1MzkyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/ResultHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODowMjo1M1rOGVQjrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODowMjo1M1rOGVQjrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk0NDU1Ng==", "bodyText": "I would suggest moving this to io.realm.internal.network. It would make it more clear what the class is used for. The name ResultHandler is very generic when living directly in io.realm.internal", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424944556", "createdAt": "2020-05-14T08:02:53Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/ResultHandler.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjI3MTcxOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsRemoteMongoCollection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODowODoyM1rOGVQvhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODowODoyM1rOGVQvhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk0NzU5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String filterString = filter == null ?\n          \n          \n            \n                    String filterString = (filter == null) ?", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424947591", "createdAt": "2020-05-14T08:08:23Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsRemoteMongoCollection.java", "diffHunk": "@@ -38,12 +65,231 @@ public long getNativeFinalizerPtr() {\n         return nativeFinalizerPtr;\n     }\n \n-    public void count(String filter) {\n-        throw new UnsupportedOperationException(\"Not Implemented\");\n+    public Long count() {\n+        return count(null);\n+    }\n+\n+    public Long count(@Nullable final Bson filter) {\n+        return count(filter, null);\n+    }\n+\n+    public Long count(@Nullable final Bson filter, @Nullable final RemoteCountOptions options) {\n+        AtomicReference<Long> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<Long> callback = new OsJNIResultCallback<Long>(success, error) {\n+            @Override\n+            protected Long mapSuccess(Object result) {\n+                return (Long) result;\n+            }\n+        };\n+\n+        // no filter means count all\n+        String filterString = filter == null ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjI3MjcwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsRemoteMongoCollection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODowODo0MlrOGVQwMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODowODo0MlrOGVQwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk0Nzc2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int limit = options == null ? 0 : options.getLimit();\n          \n          \n            \n                    int limit = (options == null) ? 0 : options.getLimit();", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424947762", "createdAt": "2020-05-14T08:08:42Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsRemoteMongoCollection.java", "diffHunk": "@@ -38,12 +65,231 @@ public long getNativeFinalizerPtr() {\n         return nativeFinalizerPtr;\n     }\n \n-    public void count(String filter) {\n-        throw new UnsupportedOperationException(\"Not Implemented\");\n+    public Long count() {\n+        return count(null);\n+    }\n+\n+    public Long count(@Nullable final Bson filter) {\n+        return count(filter, null);\n+    }\n+\n+    public Long count(@Nullable final Bson filter, @Nullable final RemoteCountOptions options) {\n+        AtomicReference<Long> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<Long> callback = new OsJNIResultCallback<Long>(success, error) {\n+            @Override\n+            protected Long mapSuccess(Object result) {\n+                return (Long) result;\n+            }\n+        };\n+\n+        // no filter means count all\n+        String filterString = filter == null ?\n+                JniBsonProtocol.encode(new Document(), codecRegistry) :\n+                JniBsonProtocol.encode(filter, codecRegistry);\n+        int limit = options == null ? 0 : options.getLimit();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjI3NTc0OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsRemoteMongoCollection.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODowOTozNlrOGVQyIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMjowOTozM1rOGVZOYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk0ODI1OA==", "bodyText": "This looks wrong? DocumentT can be any type, so what ensures this cast is correct?", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424948258", "createdAt": "2020-05-14T08:09:36Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsRemoteMongoCollection.java", "diffHunk": "@@ -38,12 +65,231 @@ public long getNativeFinalizerPtr() {\n         return nativeFinalizerPtr;\n     }\n \n-    public void count(String filter) {\n-        throw new UnsupportedOperationException(\"Not Implemented\");\n+    public Long count() {\n+        return count(null);\n+    }\n+\n+    public Long count(@Nullable final Bson filter) {\n+        return count(filter, null);\n+    }\n+\n+    public Long count(@Nullable final Bson filter, @Nullable final RemoteCountOptions options) {\n+        AtomicReference<Long> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<Long> callback = new OsJNIResultCallback<Long>(success, error) {\n+            @Override\n+            protected Long mapSuccess(Object result) {\n+                return (Long) result;\n+            }\n+        };\n+\n+        // no filter means count all\n+        String filterString = filter == null ?\n+                JniBsonProtocol.encode(new Document(), codecRegistry) :\n+                JniBsonProtocol.encode(filter, codecRegistry);\n+        int limit = options == null ? 0 : options.getLimit();\n+\n+        nativeCount(nativePtr, filterString, limit, callback);\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public DocumentT findOne() {\n+        return findOne(new Document());\n+    }\n+\n+    public <ResultT> ResultT findOne(final Class<ResultT> resultClass) {\n+        AtomicReference<ResultT> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<ResultT> callback = new OsJNIResultCallback<ResultT>(success, error) {\n+            @Override\n+            protected ResultT mapSuccess(Object result) {\n+                return (ResultT) findOneSuccessMapper(result, resultClass);\n+            }\n+        };\n+\n+        nativeFindOne(nativePtr, JniBsonProtocol.encode(new Document(), codecRegistry), callback);\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public DocumentT findOne(final Bson filter) {\n+        AtomicReference<DocumentT> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<DocumentT> callback = new OsJNIResultCallback<DocumentT>(success, error) {\n+            @Override\n+            protected DocumentT mapSuccess(Object result) {\n+                return (DocumentT) findOneSuccessMapper(result, Document.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA4NjU2Mw==", "bodyText": "That's right. The return type in findOneSuccessMapper was wrongly specified. I've fixed it there so the typecasting isn't necessary anymore.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425086563", "createdAt": "2020-05-14T12:09:33Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsRemoteMongoCollection.java", "diffHunk": "@@ -38,12 +65,231 @@ public long getNativeFinalizerPtr() {\n         return nativeFinalizerPtr;\n     }\n \n-    public void count(String filter) {\n-        throw new UnsupportedOperationException(\"Not Implemented\");\n+    public Long count() {\n+        return count(null);\n+    }\n+\n+    public Long count(@Nullable final Bson filter) {\n+        return count(filter, null);\n+    }\n+\n+    public Long count(@Nullable final Bson filter, @Nullable final RemoteCountOptions options) {\n+        AtomicReference<Long> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<Long> callback = new OsJNIResultCallback<Long>(success, error) {\n+            @Override\n+            protected Long mapSuccess(Object result) {\n+                return (Long) result;\n+            }\n+        };\n+\n+        // no filter means count all\n+        String filterString = filter == null ?\n+                JniBsonProtocol.encode(new Document(), codecRegistry) :\n+                JniBsonProtocol.encode(filter, codecRegistry);\n+        int limit = options == null ? 0 : options.getLimit();\n+\n+        nativeCount(nativePtr, filterString, limit, callback);\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public DocumentT findOne() {\n+        return findOne(new Document());\n+    }\n+\n+    public <ResultT> ResultT findOne(final Class<ResultT> resultClass) {\n+        AtomicReference<ResultT> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<ResultT> callback = new OsJNIResultCallback<ResultT>(success, error) {\n+            @Override\n+            protected ResultT mapSuccess(Object result) {\n+                return (ResultT) findOneSuccessMapper(result, resultClass);\n+            }\n+        };\n+\n+        nativeFindOne(nativePtr, JniBsonProtocol.encode(new Document(), codecRegistry), callback);\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public DocumentT findOne(final Bson filter) {\n+        AtomicReference<DocumentT> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<DocumentT> callback = new OsJNIResultCallback<DocumentT>(success, error) {\n+            @Override\n+            protected DocumentT mapSuccess(Object result) {\n+                return (DocumentT) findOneSuccessMapper(result, Document.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk0ODI1OA=="}, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjI4NTYxOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/RemoteMongoClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODoxMjoyMVrOGVQ4WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjo1OToyN1rOGVlv-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk0OTg0OQ==", "bodyText": "If this constructor is going to be part of the public API we probably need to consider to make the CodecRegistry optional?\nBut didn't we talk about making the class abstract so we can hide the constructors?", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424949849", "createdAt": "2020-05-14T08:12:21Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/RemoteMongoClient.java", "diffHunk": "@@ -26,8 +28,10 @@\n public class RemoteMongoClient {\n \n     private OsRemoteMongoClient osRemoteMongoClient;\n+    private CodecRegistry codecRegistry;\n \n-    public RemoteMongoClient(RealmUser realmUser, String serviceName) {\n+    public RemoteMongoClient(final RealmUser realmUser, final String serviceName, final CodecRegistry codecRegistry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4OTgxOQ==", "bodyText": "Let's keep the constructors public for now and revisit this in the future as agreed.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425289819", "createdAt": "2020-05-14T16:56:29Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/RemoteMongoClient.java", "diffHunk": "@@ -26,8 +28,10 @@\n public class RemoteMongoClient {\n \n     private OsRemoteMongoClient osRemoteMongoClient;\n+    private CodecRegistry codecRegistry;\n \n-    public RemoteMongoClient(RealmUser realmUser, String serviceName) {\n+    public RemoteMongoClient(final RealmUser realmUser, final String serviceName, final CodecRegistry codecRegistry) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk0OTg0OQ=="}, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI5MTc2OA==", "bodyText": "Regarding the codec registry, I think I would like to wait until the functions PR is merged. I think we might have to use a codec registry factory instead of (if I remember it right) having it as a static member inside one of the configuration classes in case we want to give the option of defaulting to a certain registry in here.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425291768", "createdAt": "2020-05-14T16:59:27Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/RemoteMongoClient.java", "diffHunk": "@@ -26,8 +28,10 @@\n public class RemoteMongoClient {\n \n     private OsRemoteMongoClient osRemoteMongoClient;\n+    private CodecRegistry codecRegistry;\n \n-    public RemoteMongoClient(RealmUser realmUser, String serviceName) {\n+    public RemoteMongoClient(final RealmUser realmUser, final String serviceName, final CodecRegistry codecRegistry) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk0OTg0OQ=="}, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjMyMjM2OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODoyMjozNFrOGVRQKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMzoyNTo0MVrOGVcHQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NTk0NA==", "bodyText": "We should probably add checks on the actual type even though we have quite good control on the input side in Java, as people could use a codec registry that encodes object unexpectedly.\nif (args.type() != bson::Bson::Type::Array) {\n       throw util::invalid_argument(\"Function arguments must be a BSON array\");\n}\n\nwhich will throw an IllegalArgumentException to Java.\nThen it should be safe to cast it with static_cast<bson::BsonArray>(args) to get the right type without hitting the assertions.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424955944", "createdAt": "2020-05-14T08:22:34Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "diffHunk": "@@ -58,9 +81,110 @@ Java_io_realm_internal_objectstore_OsRemoteMongoCollection_nativeCount(JNIEnv* e\n                                                                        jobject j_callback) {\n     try {\n         RemoteMongoCollection* collection = reinterpret_cast<RemoteMongoCollection*>(j_collection_ptr);\n-        bson::BsonDocument filter(JniBsonProtocol::jstring_to_bson(env, j_filter));\n+        bson::BsonDocument bson_filter(JniBsonProtocol::jstring_to_bson(env, j_filter));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk2NzIzMg==", "bodyText": "We should probably do a <T> JniBsonProtocol::checked_jstring_to_bson(...). To ease it, but my template programming is a bit rusty, so I cannot write from the top of my head. I can do it as part of the functions PR, then you can await the implementation and guard the arguments later.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424967232", "createdAt": "2020-05-14T08:40:10Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "diffHunk": "@@ -58,9 +81,110 @@ Java_io_realm_internal_objectstore_OsRemoteMongoCollection_nativeCount(JNIEnv* e\n                                                                        jobject j_callback) {\n     try {\n         RemoteMongoCollection* collection = reinterpret_cast<RemoteMongoCollection*>(j_collection_ptr);\n-        bson::BsonDocument filter(JniBsonProtocol::jstring_to_bson(env, j_filter));\n+        bson::BsonDocument bson_filter(JniBsonProtocol::jstring_to_bson(env, j_filter));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NTk0NA=="}, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTEzMzg4OQ==", "bodyText": "I will add a FIXME to remind me of that.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425133889", "createdAt": "2020-05-14T13:25:41Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "diffHunk": "@@ -58,9 +81,110 @@ Java_io_realm_internal_objectstore_OsRemoteMongoCollection_nativeCount(JNIEnv* e\n                                                                        jobject j_callback) {\n     try {\n         RemoteMongoCollection* collection = reinterpret_cast<RemoteMongoCollection*>(j_collection_ptr);\n-        bson::BsonDocument filter(JniBsonProtocol::jstring_to_bson(env, j_filter));\n+        bson::BsonDocument bson_filter(JniBsonProtocol::jstring_to_bson(env, j_filter));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NTk0NA=="}, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjMyNDI2OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODoyMzowNFrOGVRReA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODoyMzowNFrOGVRReA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NjI4MA==", "bodyText": "Same check as above.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424956280", "createdAt": "2020-05-14T08:23:04Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsRemoteMongoCollection.cpp", "diffHunk": "@@ -58,9 +81,110 @@ Java_io_realm_internal_objectstore_OsRemoteMongoCollection_nativeCount(JNIEnv* e\n                                                                        jobject j_callback) {\n     try {\n         RemoteMongoCollection* collection = reinterpret_cast<RemoteMongoCollection*>(j_collection_ptr);\n-        bson::BsonDocument filter(JniBsonProtocol::jstring_to_bson(env, j_filter));\n+        bson::BsonDocument bson_filter(JniBsonProtocol::jstring_to_bson(env, j_filter));\n         uint64_t limit = std::uint64_t(j_limit);\n-        collection->count(filter, limit, JavaNetworkTransport::create_result_callback(env, j_callback, collection_mapper));\n+        collection->count(bson_filter, limit, JavaNetworkTransport::create_result_callback(env, j_callback, collection_mapper_count));\n+    }\n+    CATCH_STD()\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_io_realm_internal_objectstore_OsRemoteMongoCollection_nativeFindOne(JNIEnv* env,\n+                                                                         jclass,\n+                                                                         jlong j_collection_ptr,\n+                                                                         jstring j_document,\n+                                                                         jobject j_callback) {\n+    try {\n+        RemoteMongoCollection* collection = reinterpret_cast<RemoteMongoCollection*>(j_collection_ptr);\n+        bson::BsonDocument bson_filter(JniBsonProtocol::jstring_to_bson(env, j_document));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjQxMzA2OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsRemoteMongoCollection.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODo0NTo0M1rOGVSKDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMjoxMjoyNlrOGVZUwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk3MDc2NQ==", "bodyText": "As discussed be aware of the special BsonNull type. Do not know whether it is used in the OS layer or we can rely on standard null pointers.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r424970765", "createdAt": "2020-05-14T08:45:43Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsRemoteMongoCollection.java", "diffHunk": "@@ -38,12 +65,231 @@ public long getNativeFinalizerPtr() {\n         return nativeFinalizerPtr;\n     }\n \n-    public void count(String filter) {\n-        throw new UnsupportedOperationException(\"Not Implemented\");\n+    public Long count() {\n+        return count(null);\n+    }\n+\n+    public Long count(@Nullable final Bson filter) {\n+        return count(filter, null);\n+    }\n+\n+    public Long count(@Nullable final Bson filter, @Nullable final RemoteCountOptions options) {\n+        AtomicReference<Long> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<Long> callback = new OsJNIResultCallback<Long>(success, error) {\n+            @Override\n+            protected Long mapSuccess(Object result) {\n+                return (Long) result;\n+            }\n+        };\n+\n+        // no filter means count all\n+        String filterString = filter == null ?\n+                JniBsonProtocol.encode(new Document(), codecRegistry) :\n+                JniBsonProtocol.encode(filter, codecRegistry);\n+        int limit = options == null ? 0 : options.getLimit();\n+\n+        nativeCount(nativePtr, filterString, limit, callback);\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public DocumentT findOne() {\n+        return findOne(new Document());\n+    }\n+\n+    public <ResultT> ResultT findOne(final Class<ResultT> resultClass) {\n+        AtomicReference<ResultT> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<ResultT> callback = new OsJNIResultCallback<ResultT>(success, error) {\n+            @Override\n+            protected ResultT mapSuccess(Object result) {\n+                return (ResultT) findOneSuccessMapper(result, resultClass);\n+            }\n+        };\n+\n+        nativeFindOne(nativePtr, JniBsonProtocol.encode(new Document(), codecRegistry), callback);\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public DocumentT findOne(final Bson filter) {\n+        AtomicReference<DocumentT> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<DocumentT> callback = new OsJNIResultCallback<DocumentT>(success, error) {\n+            @Override\n+            protected DocumentT mapSuccess(Object result) {\n+                return (DocumentT) findOneSuccessMapper(result, Document.class);\n+            }\n+        };\n+\n+        String encodedFilter = JniBsonProtocol.encode(filter, codecRegistry);\n+        nativeFindOne(nativePtr, encodedFilter, callback);\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public <ResultT> ResultT findOne(final @Nullable Bson filter, final Class<ResultT> resultClass) {\n+        AtomicReference<ResultT> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<ResultT> callback = new OsJNIResultCallback<ResultT>(success, error) {\n+            @Override\n+            protected ResultT mapSuccess(Object result) {\n+                return (ResultT) findOneSuccessMapper(result, resultClass);\n+            }\n+        };\n+\n+        String encodedFilter = filter == null ?\n+                JniBsonProtocol.encode(new Document(), codecRegistry) :\n+                JniBsonProtocol.encode(filter, codecRegistry);\n+        nativeFindOne(nativePtr, encodedFilter, callback);\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public DocumentT findOne(@Nullable final Bson filter, final RemoteFindOptions options) {\n+        AtomicReference<DocumentT> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<DocumentT> callback = new OsJNIResultCallback<DocumentT>(success, error) {\n+            @Override\n+            protected DocumentT mapSuccess(Object result) {\n+                return (DocumentT) findOneSuccessMapper(result, documentClass);\n+            }\n+        };\n+\n+        String encodedFilter = filter == null ?\n+                JniBsonProtocol.encode(new Document(), codecRegistry) :\n+                JniBsonProtocol.encode(filter, codecRegistry);\n+        String projectionString = JniBsonProtocol.encode(options.getProjection(), codecRegistry);\n+        String sortString = JniBsonProtocol.encode(options.getSort(), codecRegistry);\n+        nativeFindOneWithOptions(nativePtr, encodedFilter, projectionString, sortString, options.getLimit(), callback);\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public <ResultT> ResultT findOne(\n+            final Bson filter,\n+            final RemoteFindOptions options,\n+            final Class<ResultT> resultClass) {\n+        AtomicReference<ResultT> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<ResultT> callback = new OsJNIResultCallback<ResultT>(success, error) {\n+            @Override\n+            protected ResultT mapSuccess(Object result) {\n+                return (ResultT) findOneSuccessMapper(result, resultClass);\n+            }\n+        };\n+\n+        String encodedFilter = filter == null ?\n+                JniBsonProtocol.encode(new Document(), codecRegistry) :\n+                JniBsonProtocol.encode(filter, codecRegistry);\n+        String projectionString = JniBsonProtocol.encode(options.getProjection(), codecRegistry);\n+        String sortString = JniBsonProtocol.encode(options.getSort(), codecRegistry);\n+        nativeFindOneWithOptions(nativePtr, encodedFilter, projectionString, sortString, options.getLimit(), callback);\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public RemoteInsertOneResult insertOne(final DocumentT document) {\n+        AtomicReference<RemoteInsertOneResult> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<RemoteInsertOneResult> callback = new OsJNIResultCallback<RemoteInsertOneResult>(success, error) {\n+            @Override\n+            protected RemoteInsertOneResult mapSuccess(Object result) {\n+                BsonValue bsonObjectId = new BsonObjectId((ObjectId) result);\n+                return new RemoteInsertOneResult(bsonObjectId);\n+            }\n+        };\n+\n+        String encodedDocument = JniBsonProtocol.encode(document, codecRegistry);\n+        nativeInsertOne(nativePtr, encodedDocument, callback);\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public RemoteInsertManyResult insertMany(final List<? extends DocumentT> documents) {\n+        AtomicReference<RemoteInsertManyResult> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<RemoteInsertManyResult> callback = new OsJNIResultCallback<RemoteInsertManyResult>(success, error) {\n+            @Override\n+            protected RemoteInsertManyResult mapSuccess(Object result) {\n+                Object[] objects = (Object[]) result;\n+                Map<Long, BsonValue> insertedIdsMap = new HashMap<>();\n+                for (int i = 0; i < objects.length; i++) {\n+                    ObjectId objectId = (ObjectId) objects[i];\n+                    BsonValue bsonObjectId = new BsonObjectId(objectId);\n+                    insertedIdsMap.put((long) i, bsonObjectId);\n+                }\n+                return new RemoteInsertManyResult(insertedIdsMap);\n+            }\n+        };\n+\n+        String encodedDocumentArray = JniBsonProtocol.encode(documents, codecRegistry);\n+        nativeInsertMany(nativePtr, encodedDocumentArray, callback);\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public RemoteDeleteResult deleteOne(final Bson filter) {\n+        AtomicReference<RemoteDeleteResult> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<RemoteDeleteResult> callback = new OsJNIResultCallback<RemoteDeleteResult>(success, error) {\n+            @Override\n+            protected RemoteDeleteResult mapSuccess(Object result) {\n+                return new RemoteDeleteResult((Long) result);\n+            }\n+        };\n+\n+        String jsonDocument = JniBsonProtocol.encode(filter, codecRegistry);\n+        nativeDeleteOne(nativePtr, jsonDocument, callback);\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public RemoteDeleteResult deleteMany(final Bson filter) {\n+        AtomicReference<RemoteDeleteResult> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<RemoteDeleteResult> callback = new OsJNIResultCallback<RemoteDeleteResult>(success, error) {\n+            @Override\n+            protected RemoteDeleteResult mapSuccess(Object result) {\n+                return new RemoteDeleteResult((Long) result);\n+            }\n+        };\n+\n+        String jsonDocument = JniBsonProtocol.encode(filter, codecRegistry);\n+        nativeDeleteMany(nativePtr, jsonDocument, callback);\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    private Object findOneSuccessMapper(@Nullable Object result, Class<?> resultClass) {\n+        if (result == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA4ODE5NA==", "bodyText": "I've done a quick search and it doesn't seem to exist in the object server. Null is returned in some operations from the Stitch SDK, so my guess is to stick to null to ensure continuity.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425088194", "createdAt": "2020-05-14T12:12:26Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsRemoteMongoCollection.java", "diffHunk": "@@ -38,12 +65,231 @@ public long getNativeFinalizerPtr() {\n         return nativeFinalizerPtr;\n     }\n \n-    public void count(String filter) {\n-        throw new UnsupportedOperationException(\"Not Implemented\");\n+    public Long count() {\n+        return count(null);\n+    }\n+\n+    public Long count(@Nullable final Bson filter) {\n+        return count(filter, null);\n+    }\n+\n+    public Long count(@Nullable final Bson filter, @Nullable final RemoteCountOptions options) {\n+        AtomicReference<Long> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<Long> callback = new OsJNIResultCallback<Long>(success, error) {\n+            @Override\n+            protected Long mapSuccess(Object result) {\n+                return (Long) result;\n+            }\n+        };\n+\n+        // no filter means count all\n+        String filterString = filter == null ?\n+                JniBsonProtocol.encode(new Document(), codecRegistry) :\n+                JniBsonProtocol.encode(filter, codecRegistry);\n+        int limit = options == null ? 0 : options.getLimit();\n+\n+        nativeCount(nativePtr, filterString, limit, callback);\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public DocumentT findOne() {\n+        return findOne(new Document());\n+    }\n+\n+    public <ResultT> ResultT findOne(final Class<ResultT> resultClass) {\n+        AtomicReference<ResultT> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<ResultT> callback = new OsJNIResultCallback<ResultT>(success, error) {\n+            @Override\n+            protected ResultT mapSuccess(Object result) {\n+                return (ResultT) findOneSuccessMapper(result, resultClass);\n+            }\n+        };\n+\n+        nativeFindOne(nativePtr, JniBsonProtocol.encode(new Document(), codecRegistry), callback);\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public DocumentT findOne(final Bson filter) {\n+        AtomicReference<DocumentT> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<DocumentT> callback = new OsJNIResultCallback<DocumentT>(success, error) {\n+            @Override\n+            protected DocumentT mapSuccess(Object result) {\n+                return (DocumentT) findOneSuccessMapper(result, Document.class);\n+            }\n+        };\n+\n+        String encodedFilter = JniBsonProtocol.encode(filter, codecRegistry);\n+        nativeFindOne(nativePtr, encodedFilter, callback);\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public <ResultT> ResultT findOne(final @Nullable Bson filter, final Class<ResultT> resultClass) {\n+        AtomicReference<ResultT> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<ResultT> callback = new OsJNIResultCallback<ResultT>(success, error) {\n+            @Override\n+            protected ResultT mapSuccess(Object result) {\n+                return (ResultT) findOneSuccessMapper(result, resultClass);\n+            }\n+        };\n+\n+        String encodedFilter = filter == null ?\n+                JniBsonProtocol.encode(new Document(), codecRegistry) :\n+                JniBsonProtocol.encode(filter, codecRegistry);\n+        nativeFindOne(nativePtr, encodedFilter, callback);\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public DocumentT findOne(@Nullable final Bson filter, final RemoteFindOptions options) {\n+        AtomicReference<DocumentT> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<DocumentT> callback = new OsJNIResultCallback<DocumentT>(success, error) {\n+            @Override\n+            protected DocumentT mapSuccess(Object result) {\n+                return (DocumentT) findOneSuccessMapper(result, documentClass);\n+            }\n+        };\n+\n+        String encodedFilter = filter == null ?\n+                JniBsonProtocol.encode(new Document(), codecRegistry) :\n+                JniBsonProtocol.encode(filter, codecRegistry);\n+        String projectionString = JniBsonProtocol.encode(options.getProjection(), codecRegistry);\n+        String sortString = JniBsonProtocol.encode(options.getSort(), codecRegistry);\n+        nativeFindOneWithOptions(nativePtr, encodedFilter, projectionString, sortString, options.getLimit(), callback);\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public <ResultT> ResultT findOne(\n+            final Bson filter,\n+            final RemoteFindOptions options,\n+            final Class<ResultT> resultClass) {\n+        AtomicReference<ResultT> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<ResultT> callback = new OsJNIResultCallback<ResultT>(success, error) {\n+            @Override\n+            protected ResultT mapSuccess(Object result) {\n+                return (ResultT) findOneSuccessMapper(result, resultClass);\n+            }\n+        };\n+\n+        String encodedFilter = filter == null ?\n+                JniBsonProtocol.encode(new Document(), codecRegistry) :\n+                JniBsonProtocol.encode(filter, codecRegistry);\n+        String projectionString = JniBsonProtocol.encode(options.getProjection(), codecRegistry);\n+        String sortString = JniBsonProtocol.encode(options.getSort(), codecRegistry);\n+        nativeFindOneWithOptions(nativePtr, encodedFilter, projectionString, sortString, options.getLimit(), callback);\n+\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public RemoteInsertOneResult insertOne(final DocumentT document) {\n+        AtomicReference<RemoteInsertOneResult> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<RemoteInsertOneResult> callback = new OsJNIResultCallback<RemoteInsertOneResult>(success, error) {\n+            @Override\n+            protected RemoteInsertOneResult mapSuccess(Object result) {\n+                BsonValue bsonObjectId = new BsonObjectId((ObjectId) result);\n+                return new RemoteInsertOneResult(bsonObjectId);\n+            }\n+        };\n+\n+        String encodedDocument = JniBsonProtocol.encode(document, codecRegistry);\n+        nativeInsertOne(nativePtr, encodedDocument, callback);\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public RemoteInsertManyResult insertMany(final List<? extends DocumentT> documents) {\n+        AtomicReference<RemoteInsertManyResult> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<RemoteInsertManyResult> callback = new OsJNIResultCallback<RemoteInsertManyResult>(success, error) {\n+            @Override\n+            protected RemoteInsertManyResult mapSuccess(Object result) {\n+                Object[] objects = (Object[]) result;\n+                Map<Long, BsonValue> insertedIdsMap = new HashMap<>();\n+                for (int i = 0; i < objects.length; i++) {\n+                    ObjectId objectId = (ObjectId) objects[i];\n+                    BsonValue bsonObjectId = new BsonObjectId(objectId);\n+                    insertedIdsMap.put((long) i, bsonObjectId);\n+                }\n+                return new RemoteInsertManyResult(insertedIdsMap);\n+            }\n+        };\n+\n+        String encodedDocumentArray = JniBsonProtocol.encode(documents, codecRegistry);\n+        nativeInsertMany(nativePtr, encodedDocumentArray, callback);\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public RemoteDeleteResult deleteOne(final Bson filter) {\n+        AtomicReference<RemoteDeleteResult> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<RemoteDeleteResult> callback = new OsJNIResultCallback<RemoteDeleteResult>(success, error) {\n+            @Override\n+            protected RemoteDeleteResult mapSuccess(Object result) {\n+                return new RemoteDeleteResult((Long) result);\n+            }\n+        };\n+\n+        String jsonDocument = JniBsonProtocol.encode(filter, codecRegistry);\n+        nativeDeleteOne(nativePtr, jsonDocument, callback);\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    public RemoteDeleteResult deleteMany(final Bson filter) {\n+        AtomicReference<RemoteDeleteResult> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<RemoteDeleteResult> callback = new OsJNIResultCallback<RemoteDeleteResult>(success, error) {\n+            @Override\n+            protected RemoteDeleteResult mapSuccess(Object result) {\n+                return new RemoteDeleteResult((Long) result);\n+            }\n+        };\n+\n+        String jsonDocument = JniBsonProtocol.encode(filter, codecRegistry);\n+        nativeDeleteMany(nativePtr, jsonDocument, callback);\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    private Object findOneSuccessMapper(@Nullable Object result, Class<?> resultClass) {\n+        if (result == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk3MDc2NQ=="}, "originalCommit": {"oid": "46eaaa91a8b4c8f07972e489c0904f199cc1401e"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDk0NzY1OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMDoxMzowNlrOGV-4EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMDoxMzowNlrOGV-4EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwMzQ0MA==", "bodyText": "Add a FIXME if these are still here for a reason or delete them", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425703440", "createdAt": "2020-05-15T10:13:06Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.mongodb.mongo.MongoClient\n+import io.realm.mongodb.mongo.MongoCollection\n+import io.realm.mongodb.mongo.MongoDatabase\n+import io.realm.mongodb.mongo.options.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class MongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: MongoClient\n+    private lateinit var database: MongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+            val doc = Document(mapOf(\"KEY_1\" to \"WORLD_1\", \"KEY_2\" to \"WORLD_2\"))\n+            insertOne(doc).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+//            val doc = Document(\"hello\", \"world\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2266cd0e20e00a932b1190432e5cfc18919a9f20"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDk1MTI0OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMDoxNDoxOFrOGV-6Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMDoxNDoxOFrOGV-6Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwNDAzOA==", "bodyText": "Add FIXME or delete them", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425704038", "createdAt": "2020-05-15T10:14:18Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.mongodb.mongo.MongoClient\n+import io.realm.mongodb.mongo.MongoCollection\n+import io.realm.mongodb.mongo.MongoDatabase\n+import io.realm.mongodb.mongo.options.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class MongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: MongoClient\n+    private lateinit var database: MongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+            val doc = Document(mapOf(\"KEY_1\" to \"WORLD_1\", \"KEY_2\" to \"WORLD_2\"))\n+            insertOne(doc).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+//            val doc = Document(\"hello\", \"world\")\n+//            doc[\"_id\"] = ObjectId()\n+//\n+//            assertEquals(doc.getObjectId(\"_id\"), insertOne(doc).blockingGetResult()!!.insertedId.asObjectId().value)\n+//            assertFailsWith(ObjectServerError::class) { insertOne(doc).blockingGetResult() }\n+//\n+//            val doc2 = Document(\"hello\", \"world\")\n+//            assertNotEquals(doc.getObjectId(\"_id\"), insertOne(doc2).blockingGetResult()!!.insertedId.asObjectId().value)\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(\"hello\", \"world\")\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"hello\", \"Friend\")).blockingGetResult())\n+            assertEquals(1,count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())\n+\n+//            try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2266cd0e20e00a932b1190432e5cfc18919a9f20"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDk1OTY5OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMDoxNzowMlrOGV-_uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMDoxNzowMlrOGV-_uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwNTQwMA==", "bodyText": "Add FIXME or delete", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425705400", "createdAt": "2020-05-15T10:17:02Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.mongodb.mongo.MongoClient\n+import io.realm.mongodb.mongo.MongoCollection\n+import io.realm.mongodb.mongo.MongoDatabase\n+import io.realm.mongodb.mongo.options.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class MongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: MongoClient\n+    private lateinit var database: MongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+            val doc = Document(mapOf(\"KEY_1\" to \"WORLD_1\", \"KEY_2\" to \"WORLD_2\"))\n+            insertOne(doc).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+//            val doc = Document(\"hello\", \"world\")\n+//            doc[\"_id\"] = ObjectId()\n+//\n+//            assertEquals(doc.getObjectId(\"_id\"), insertOne(doc).blockingGetResult()!!.insertedId.asObjectId().value)\n+//            assertFailsWith(ObjectServerError::class) { insertOne(doc).blockingGetResult() }\n+//\n+//            val doc2 = Document(\"hello\", \"world\")\n+//            assertNotEquals(doc.getObjectId(\"_id\"), insertOne(doc2).blockingGetResult()!!.insertedId.asObjectId().value)\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(\"hello\", \"world\")\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"hello\", \"Friend\")).blockingGetResult())\n+            assertEquals(1,count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())\n+\n+//            try {\n+//                count(Document(\"\\$who\", 1)).blockingGetResult()\n+//                Assert.fail()\n+//            } catch (ex: ExecutionException) {\n+//                // FIXME: add assertion\n+//                val a = 0\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne_singleDocument() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteOne(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne_listOfDocuments() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(1, deleteOne(rawDoc).blockingGetResult()!!.deletedCount)\n+            assertEquals(1, deleteOne(Document()).blockingGetResult()!!.deletedCount)\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany_singleDocument() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteMany(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany_listOfDocuments() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(2, deleteMany(rawDoc).blockingGetResult()!!.deletedCount)                 // two docs will be deleted\n+            assertEquals(2, count().blockingGetResult())                                           // two docs still present\n+            assertEquals(2, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(4, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun findOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world1\")\n+            val doc2 = Document(\"hello\", \"world2\")\n+            val doc3 = Document(\"hello\", \"world3\")\n+\n+            // Test findOne() on empty collection with no filter and no options\n+            assertNull(findOne().blockingGetResult())\n+\n+            // Insert a document into the collection\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Test findOne() with no filter and no options\n+            assertEquals(doc1, findOne().blockingGetResult()!!.withoutId())\n+\n+            // Test findOne() with filter that does not match any documents and no options\n+            assertNull(findOne(Document(\"hello\", \"worldDNE\")).blockingGetResult())\n+\n+//            // Insert 2 more documents into the collection", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2266cd0e20e00a932b1190432e5cfc18919a9f20"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDk2NTAyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMDoxODo0NVrOGV_DKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMTowMzoxNVrOGWAWQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwNjI4Mw==", "bodyText": "Not entirely sure what is best practise here, but should these just be defined at the top of the file instead of in the companion object. I have a feeling that we are just putting them in Companion objects because that would make them static like in Java, but it might not be Kotlin best practise?", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425706283", "createdAt": "2020-05-15T10:18:45Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.mongodb.mongo.MongoClient\n+import io.realm.mongodb.mongo.MongoCollection\n+import io.realm.mongodb.mongo.MongoDatabase\n+import io.realm.mongodb.mongo.options.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class MongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: MongoClient\n+    private lateinit var database: MongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+            val doc = Document(mapOf(\"KEY_1\" to \"WORLD_1\", \"KEY_2\" to \"WORLD_2\"))\n+            insertOne(doc).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+//            val doc = Document(\"hello\", \"world\")\n+//            doc[\"_id\"] = ObjectId()\n+//\n+//            assertEquals(doc.getObjectId(\"_id\"), insertOne(doc).blockingGetResult()!!.insertedId.asObjectId().value)\n+//            assertFailsWith(ObjectServerError::class) { insertOne(doc).blockingGetResult() }\n+//\n+//            val doc2 = Document(\"hello\", \"world\")\n+//            assertNotEquals(doc.getObjectId(\"_id\"), insertOne(doc2).blockingGetResult()!!.insertedId.asObjectId().value)\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(\"hello\", \"world\")\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"hello\", \"Friend\")).blockingGetResult())\n+            assertEquals(1,count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())\n+\n+//            try {\n+//                count(Document(\"\\$who\", 1)).blockingGetResult()\n+//                Assert.fail()\n+//            } catch (ex: ExecutionException) {\n+//                // FIXME: add assertion\n+//                val a = 0\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne_singleDocument() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteOne(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne_listOfDocuments() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(1, deleteOne(rawDoc).blockingGetResult()!!.deletedCount)\n+            assertEquals(1, deleteOne(Document()).blockingGetResult()!!.deletedCount)\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany_singleDocument() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteMany(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany_listOfDocuments() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(2, deleteMany(rawDoc).blockingGetResult()!!.deletedCount)                 // two docs will be deleted\n+            assertEquals(2, count().blockingGetResult())                                           // two docs still present\n+            assertEquals(2, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(4, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun findOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world1\")\n+            val doc2 = Document(\"hello\", \"world2\")\n+            val doc3 = Document(\"hello\", \"world3\")\n+\n+            // Test findOne() on empty collection with no filter and no options\n+            assertNull(findOne().blockingGetResult())\n+\n+            // Insert a document into the collection\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Test findOne() with no filter and no options\n+            assertEquals(doc1, findOne().blockingGetResult()!!.withoutId())\n+\n+            // Test findOne() with filter that does not match any documents and no options\n+            assertNull(findOne(Document(\"hello\", \"worldDNE\")).blockingGetResult())\n+\n+//            // Insert 2 more documents into the collection\n+////            insertMany(listOf(doc2, doc3)).blockingGetResult()    // use insertOne for now\n+//            insertOne(doc2).blockingGetResult()\n+//            insertOne(doc3).blockingGetResult()\n+//            assertEquals(3, count().blockingGetResult())\n+//\n+//            // test findOne() with projection and sort options\n+//            val projection = Document(\"hello\", 1)\n+//            projection[\"_id\"] = 0\n+//            val options1 = RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", 1))\n+//            assertEquals(doc1, findOne(Document(), options1).blockingGetResult()!!.withoutId())\n+//\n+//            val options2 = RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", -1))\n+//            assertEquals(doc3.withoutId(), findOne(Document(), options2).blockingGetResult()!!.withoutId())\n+//\n+//            // test findOne() properly fails\n+//            try {\n+//                Tasks.await(coll.findOne(Document(\"\\$who\", 1)))\n+//                Assert.fail()\n+//            } catch (ex: ExecutionException) {\n+//                Assert.assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    // FIXME: more to come\n+\n+    private fun getCollectionInternal(collectionName: String, javaClass: Class<Document>? = null): MongoCollection<Document> {\n+        return when (javaClass) {\n+            null -> database.getCollection(collectionName)\n+            else -> database.getCollection(collectionName, javaClass)\n+        }\n+    }\n+\n+    private fun Document.withId(objectId: ObjectId? = null): Document {\n+        return apply { this[\"_id\"] = objectId ?: ObjectId() }\n+    }\n+\n+    private fun Document.withoutId(): Document {\n+        return apply { remove(\"_id\") }\n+    }\n+\n+    private companion object {\n+        const val SERVICE_NAME = \"BackingDB\"    // it comes from the test server's BackingDB/config.json", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2266cd0e20e00a932b1190432e5cfc18919a9f20"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcxMTU1MA==", "bodyText": "Some say that if the scope of the constants is constrained to this class, it should be a companion object, whereas if its scope is wider, then it should be a top-of-the-file definition.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425711550", "createdAt": "2020-05-15T10:28:51Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.mongodb.mongo.MongoClient\n+import io.realm.mongodb.mongo.MongoCollection\n+import io.realm.mongodb.mongo.MongoDatabase\n+import io.realm.mongodb.mongo.options.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class MongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: MongoClient\n+    private lateinit var database: MongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+            val doc = Document(mapOf(\"KEY_1\" to \"WORLD_1\", \"KEY_2\" to \"WORLD_2\"))\n+            insertOne(doc).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+//            val doc = Document(\"hello\", \"world\")\n+//            doc[\"_id\"] = ObjectId()\n+//\n+//            assertEquals(doc.getObjectId(\"_id\"), insertOne(doc).blockingGetResult()!!.insertedId.asObjectId().value)\n+//            assertFailsWith(ObjectServerError::class) { insertOne(doc).blockingGetResult() }\n+//\n+//            val doc2 = Document(\"hello\", \"world\")\n+//            assertNotEquals(doc.getObjectId(\"_id\"), insertOne(doc2).blockingGetResult()!!.insertedId.asObjectId().value)\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(\"hello\", \"world\")\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"hello\", \"Friend\")).blockingGetResult())\n+            assertEquals(1,count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())\n+\n+//            try {\n+//                count(Document(\"\\$who\", 1)).blockingGetResult()\n+//                Assert.fail()\n+//            } catch (ex: ExecutionException) {\n+//                // FIXME: add assertion\n+//                val a = 0\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne_singleDocument() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteOne(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne_listOfDocuments() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(1, deleteOne(rawDoc).blockingGetResult()!!.deletedCount)\n+            assertEquals(1, deleteOne(Document()).blockingGetResult()!!.deletedCount)\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany_singleDocument() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteMany(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany_listOfDocuments() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(2, deleteMany(rawDoc).blockingGetResult()!!.deletedCount)                 // two docs will be deleted\n+            assertEquals(2, count().blockingGetResult())                                           // two docs still present\n+            assertEquals(2, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(4, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun findOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world1\")\n+            val doc2 = Document(\"hello\", \"world2\")\n+            val doc3 = Document(\"hello\", \"world3\")\n+\n+            // Test findOne() on empty collection with no filter and no options\n+            assertNull(findOne().blockingGetResult())\n+\n+            // Insert a document into the collection\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Test findOne() with no filter and no options\n+            assertEquals(doc1, findOne().blockingGetResult()!!.withoutId())\n+\n+            // Test findOne() with filter that does not match any documents and no options\n+            assertNull(findOne(Document(\"hello\", \"worldDNE\")).blockingGetResult())\n+\n+//            // Insert 2 more documents into the collection\n+////            insertMany(listOf(doc2, doc3)).blockingGetResult()    // use insertOne for now\n+//            insertOne(doc2).blockingGetResult()\n+//            insertOne(doc3).blockingGetResult()\n+//            assertEquals(3, count().blockingGetResult())\n+//\n+//            // test findOne() with projection and sort options\n+//            val projection = Document(\"hello\", 1)\n+//            projection[\"_id\"] = 0\n+//            val options1 = RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", 1))\n+//            assertEquals(doc1, findOne(Document(), options1).blockingGetResult()!!.withoutId())\n+//\n+//            val options2 = RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", -1))\n+//            assertEquals(doc3.withoutId(), findOne(Document(), options2).blockingGetResult()!!.withoutId())\n+//\n+//            // test findOne() properly fails\n+//            try {\n+//                Tasks.await(coll.findOne(Document(\"\\$who\", 1)))\n+//                Assert.fail()\n+//            } catch (ex: ExecutionException) {\n+//                Assert.assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    // FIXME: more to come\n+\n+    private fun getCollectionInternal(collectionName: String, javaClass: Class<Document>? = null): MongoCollection<Document> {\n+        return when (javaClass) {\n+            null -> database.getCollection(collectionName)\n+            else -> database.getCollection(collectionName, javaClass)\n+        }\n+    }\n+\n+    private fun Document.withId(objectId: ObjectId? = null): Document {\n+        return apply { this[\"_id\"] = objectId ?: ObjectId() }\n+    }\n+\n+    private fun Document.withoutId(): Document {\n+        return apply { remove(\"_id\") }\n+    }\n+\n+    private companion object {\n+        const val SERVICE_NAME = \"BackingDB\"    // it comes from the test server's BackingDB/config.json", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwNjI4Mw=="}, "originalCommit": {"oid": "2266cd0e20e00a932b1190432e5cfc18919a9f20"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcxMzEwOQ==", "bodyText": "You can still make it private in the top of the file, which limits the scope more or less to the class.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425713109", "createdAt": "2020-05-15T10:32:10Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.mongodb.mongo.MongoClient\n+import io.realm.mongodb.mongo.MongoCollection\n+import io.realm.mongodb.mongo.MongoDatabase\n+import io.realm.mongodb.mongo.options.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class MongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: MongoClient\n+    private lateinit var database: MongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+            val doc = Document(mapOf(\"KEY_1\" to \"WORLD_1\", \"KEY_2\" to \"WORLD_2\"))\n+            insertOne(doc).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+//            val doc = Document(\"hello\", \"world\")\n+//            doc[\"_id\"] = ObjectId()\n+//\n+//            assertEquals(doc.getObjectId(\"_id\"), insertOne(doc).blockingGetResult()!!.insertedId.asObjectId().value)\n+//            assertFailsWith(ObjectServerError::class) { insertOne(doc).blockingGetResult() }\n+//\n+//            val doc2 = Document(\"hello\", \"world\")\n+//            assertNotEquals(doc.getObjectId(\"_id\"), insertOne(doc2).blockingGetResult()!!.insertedId.asObjectId().value)\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(\"hello\", \"world\")\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"hello\", \"Friend\")).blockingGetResult())\n+            assertEquals(1,count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())\n+\n+//            try {\n+//                count(Document(\"\\$who\", 1)).blockingGetResult()\n+//                Assert.fail()\n+//            } catch (ex: ExecutionException) {\n+//                // FIXME: add assertion\n+//                val a = 0\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne_singleDocument() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteOne(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne_listOfDocuments() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(1, deleteOne(rawDoc).blockingGetResult()!!.deletedCount)\n+            assertEquals(1, deleteOne(Document()).blockingGetResult()!!.deletedCount)\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany_singleDocument() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteMany(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany_listOfDocuments() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(2, deleteMany(rawDoc).blockingGetResult()!!.deletedCount)                 // two docs will be deleted\n+            assertEquals(2, count().blockingGetResult())                                           // two docs still present\n+            assertEquals(2, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(4, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun findOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world1\")\n+            val doc2 = Document(\"hello\", \"world2\")\n+            val doc3 = Document(\"hello\", \"world3\")\n+\n+            // Test findOne() on empty collection with no filter and no options\n+            assertNull(findOne().blockingGetResult())\n+\n+            // Insert a document into the collection\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Test findOne() with no filter and no options\n+            assertEquals(doc1, findOne().blockingGetResult()!!.withoutId())\n+\n+            // Test findOne() with filter that does not match any documents and no options\n+            assertNull(findOne(Document(\"hello\", \"worldDNE\")).blockingGetResult())\n+\n+//            // Insert 2 more documents into the collection\n+////            insertMany(listOf(doc2, doc3)).blockingGetResult()    // use insertOne for now\n+//            insertOne(doc2).blockingGetResult()\n+//            insertOne(doc3).blockingGetResult()\n+//            assertEquals(3, count().blockingGetResult())\n+//\n+//            // test findOne() with projection and sort options\n+//            val projection = Document(\"hello\", 1)\n+//            projection[\"_id\"] = 0\n+//            val options1 = RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", 1))\n+//            assertEquals(doc1, findOne(Document(), options1).blockingGetResult()!!.withoutId())\n+//\n+//            val options2 = RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", -1))\n+//            assertEquals(doc3.withoutId(), findOne(Document(), options2).blockingGetResult()!!.withoutId())\n+//\n+//            // test findOne() properly fails\n+//            try {\n+//                Tasks.await(coll.findOne(Document(\"\\$who\", 1)))\n+//                Assert.fail()\n+//            } catch (ex: ExecutionException) {\n+//                Assert.assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    // FIXME: more to come\n+\n+    private fun getCollectionInternal(collectionName: String, javaClass: Class<Document>? = null): MongoCollection<Document> {\n+        return when (javaClass) {\n+            null -> database.getCollection(collectionName)\n+            else -> database.getCollection(collectionName, javaClass)\n+        }\n+    }\n+\n+    private fun Document.withId(objectId: ObjectId? = null): Document {\n+        return apply { this[\"_id\"] = objectId ?: ObjectId() }\n+    }\n+\n+    private fun Document.withoutId(): Document {\n+        return apply { remove(\"_id\") }\n+    }\n+\n+    private companion object {\n+        const val SERVICE_NAME = \"BackingDB\"    // it comes from the test server's BackingDB/config.json", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwNjI4Mw=="}, "originalCommit": {"oid": "2266cd0e20e00a932b1190432e5cfc18919a9f20"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyNjU2NA==", "bodyText": "That's right too. I don't know either which is considered the standard though.", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425726564", "createdAt": "2020-05-15T11:01:06Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.mongodb.mongo.MongoClient\n+import io.realm.mongodb.mongo.MongoCollection\n+import io.realm.mongodb.mongo.MongoDatabase\n+import io.realm.mongodb.mongo.options.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class MongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: MongoClient\n+    private lateinit var database: MongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+            val doc = Document(mapOf(\"KEY_1\" to \"WORLD_1\", \"KEY_2\" to \"WORLD_2\"))\n+            insertOne(doc).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+//            val doc = Document(\"hello\", \"world\")\n+//            doc[\"_id\"] = ObjectId()\n+//\n+//            assertEquals(doc.getObjectId(\"_id\"), insertOne(doc).blockingGetResult()!!.insertedId.asObjectId().value)\n+//            assertFailsWith(ObjectServerError::class) { insertOne(doc).blockingGetResult() }\n+//\n+//            val doc2 = Document(\"hello\", \"world\")\n+//            assertNotEquals(doc.getObjectId(\"_id\"), insertOne(doc2).blockingGetResult()!!.insertedId.asObjectId().value)\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(\"hello\", \"world\")\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"hello\", \"Friend\")).blockingGetResult())\n+            assertEquals(1,count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())\n+\n+//            try {\n+//                count(Document(\"\\$who\", 1)).blockingGetResult()\n+//                Assert.fail()\n+//            } catch (ex: ExecutionException) {\n+//                // FIXME: add assertion\n+//                val a = 0\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne_singleDocument() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteOne(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne_listOfDocuments() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(1, deleteOne(rawDoc).blockingGetResult()!!.deletedCount)\n+            assertEquals(1, deleteOne(Document()).blockingGetResult()!!.deletedCount)\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany_singleDocument() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteMany(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany_listOfDocuments() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(2, deleteMany(rawDoc).blockingGetResult()!!.deletedCount)                 // two docs will be deleted\n+            assertEquals(2, count().blockingGetResult())                                           // two docs still present\n+            assertEquals(2, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(4, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun findOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world1\")\n+            val doc2 = Document(\"hello\", \"world2\")\n+            val doc3 = Document(\"hello\", \"world3\")\n+\n+            // Test findOne() on empty collection with no filter and no options\n+            assertNull(findOne().blockingGetResult())\n+\n+            // Insert a document into the collection\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Test findOne() with no filter and no options\n+            assertEquals(doc1, findOne().blockingGetResult()!!.withoutId())\n+\n+            // Test findOne() with filter that does not match any documents and no options\n+            assertNull(findOne(Document(\"hello\", \"worldDNE\")).blockingGetResult())\n+\n+//            // Insert 2 more documents into the collection\n+////            insertMany(listOf(doc2, doc3)).blockingGetResult()    // use insertOne for now\n+//            insertOne(doc2).blockingGetResult()\n+//            insertOne(doc3).blockingGetResult()\n+//            assertEquals(3, count().blockingGetResult())\n+//\n+//            // test findOne() with projection and sort options\n+//            val projection = Document(\"hello\", 1)\n+//            projection[\"_id\"] = 0\n+//            val options1 = RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", 1))\n+//            assertEquals(doc1, findOne(Document(), options1).blockingGetResult()!!.withoutId())\n+//\n+//            val options2 = RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", -1))\n+//            assertEquals(doc3.withoutId(), findOne(Document(), options2).blockingGetResult()!!.withoutId())\n+//\n+//            // test findOne() properly fails\n+//            try {\n+//                Tasks.await(coll.findOne(Document(\"\\$who\", 1)))\n+//                Assert.fail()\n+//            } catch (ex: ExecutionException) {\n+//                Assert.assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    // FIXME: more to come\n+\n+    private fun getCollectionInternal(collectionName: String, javaClass: Class<Document>? = null): MongoCollection<Document> {\n+        return when (javaClass) {\n+            null -> database.getCollection(collectionName)\n+            else -> database.getCollection(collectionName, javaClass)\n+        }\n+    }\n+\n+    private fun Document.withId(objectId: ObjectId? = null): Document {\n+        return apply { this[\"_id\"] = objectId ?: ObjectId() }\n+    }\n+\n+    private fun Document.withoutId(): Document {\n+        return apply { remove(\"_id\") }\n+    }\n+\n+    private companion object {\n+        const val SERVICE_NAME = \"BackingDB\"    // it comes from the test server's BackingDB/config.json", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwNjI4Mw=="}, "originalCommit": {"oid": "2266cd0e20e00a932b1190432e5cfc18919a9f20"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyNzU1Mw==", "bodyText": "I will put them as top-level definitions. It always is nice to try something new :-)", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425727553", "createdAt": "2020-05-15T11:03:15Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n+import io.realm.mongodb.mongo.MongoClient\n+import io.realm.mongodb.mongo.MongoCollection\n+import io.realm.mongodb.mongo.MongoDatabase\n+import io.realm.mongodb.mongo.options.RemoteCountOptions\n+import io.realm.util.blockingGetResult\n+import org.bson.Document\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+@RunWith(AndroidJUnit4::class)\n+class MongoCollectionTest {\n+\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+    private lateinit var client: MongoClient\n+    private lateinit var database: MongoDatabase\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getRemoteMongoClient(SERVICE_NAME)\n+        database = client.getDatabase(DATABASE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        // FIXME: probably not the best way to \"reset\" the state\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun insertOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+            val doc = Document(mapOf(\"KEY_1\" to \"WORLD_1\", \"KEY_2\" to \"WORLD_2\"))\n+            insertOne(doc).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+//            val doc = Document(\"hello\", \"world\")\n+//            doc[\"_id\"] = ObjectId()\n+//\n+//            assertEquals(doc.getObjectId(\"_id\"), insertOne(doc).blockingGetResult()!!.insertedId.asObjectId().value)\n+//            assertFailsWith(ObjectServerError::class) { insertOne(doc).blockingGetResult() }\n+//\n+//            val doc2 = Document(\"hello\", \"world\")\n+//            assertNotEquals(doc.getObjectId(\"_id\"), insertOne(doc2).blockingGetResult()!!.insertedId.asObjectId().value)\n+        }\n+    }\n+\n+    @Test\n+    fun insertMany() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            val doc3 = Document(rawDoc)\n+            val doc4 = Document(\"foo\", \"bar\")\n+            val manyDocuments = listOf(doc1, doc2, doc3, doc4)\n+\n+            insertMany(manyDocuments)\n+                    .blockingGetResult()\n+                    .let { assertEquals(manyDocuments.size, it!!.insertedIds.size) }\n+\n+            assertEquals(manyDocuments.size.toLong(), count().blockingGetResult())\n+            assertEquals(3, count(rawDoc).blockingGetResult())\n+            assertEquals(1, count(Document(\"foo\", \"bar\")).blockingGetResult())\n+            assertEquals(0, count(Document(\"bar\", \"foo\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(\"hello\", \"world\")\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"hello\", \"Friend\")).blockingGetResult())\n+            assertEquals(1,count(rawDoc, RemoteCountOptions().limit(1)).blockingGetResult())\n+\n+//            try {\n+//                count(Document(\"\\$who\", 1)).blockingGetResult()\n+//                Assert.fail()\n+//            } catch (ex: ExecutionException) {\n+//                // FIXME: add assertion\n+//                val a = 0\n+//            }\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne_singleDocument() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteOne(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun deleteOne_listOfDocuments() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(1, deleteOne(rawDoc).blockingGetResult()!!.deletedCount)\n+            assertEquals(1, deleteOne(Document()).blockingGetResult()!!.deletedCount)\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany_singleDocument() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            assertEquals(1, deleteMany(doc1).blockingGetResult()!!.deletedCount)\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun deleteMany_listOfDocuments() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(KEY_1, VALUE_1)\n+            val doc1 = Document(rawDoc)\n+            val doc1b = Document(rawDoc)\n+            val doc2 = Document(\"foo\", \"bar\")\n+            val doc3 = Document(\"42\", \"666\")\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(2, deleteMany(rawDoc).blockingGetResult()!!.deletedCount)                 // two docs will be deleted\n+            assertEquals(2, count().blockingGetResult())                                           // two docs still present\n+            assertEquals(2, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+\n+            insertMany(listOf(doc1, doc1b, doc2, doc3)).blockingGetResult()\n+            assertEquals(4, deleteMany(Document()).blockingGetResult()!!.deletedCount)             // delete all\n+            assertEquals(0, count().blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun findOne() {\n+        with(getCollectionInternal(COLLECTION_NAME)) {\n+            val doc1 = Document(\"hello\", \"world1\")\n+            val doc2 = Document(\"hello\", \"world2\")\n+            val doc3 = Document(\"hello\", \"world3\")\n+\n+            // Test findOne() on empty collection with no filter and no options\n+            assertNull(findOne().blockingGetResult())\n+\n+            // Insert a document into the collection\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Test findOne() with no filter and no options\n+            assertEquals(doc1, findOne().blockingGetResult()!!.withoutId())\n+\n+            // Test findOne() with filter that does not match any documents and no options\n+            assertNull(findOne(Document(\"hello\", \"worldDNE\")).blockingGetResult())\n+\n+//            // Insert 2 more documents into the collection\n+////            insertMany(listOf(doc2, doc3)).blockingGetResult()    // use insertOne for now\n+//            insertOne(doc2).blockingGetResult()\n+//            insertOne(doc3).blockingGetResult()\n+//            assertEquals(3, count().blockingGetResult())\n+//\n+//            // test findOne() with projection and sort options\n+//            val projection = Document(\"hello\", 1)\n+//            projection[\"_id\"] = 0\n+//            val options1 = RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", 1))\n+//            assertEquals(doc1, findOne(Document(), options1).blockingGetResult()!!.withoutId())\n+//\n+//            val options2 = RemoteFindOptions()\n+//                    .limit(2)\n+//                    .projection(projection)\n+//                    .sort(Document(\"hello\", -1))\n+//            assertEquals(doc3.withoutId(), findOne(Document(), options2).blockingGetResult()!!.withoutId())\n+//\n+//            // test findOne() properly fails\n+//            try {\n+//                Tasks.await(coll.findOne(Document(\"\\$who\", 1)))\n+//                Assert.fail()\n+//            } catch (ex: ExecutionException) {\n+//                Assert.assertTrue(ex.cause is StitchServiceException)\n+//                val svcEx = ex.cause as StitchServiceException\n+//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n+//            }\n+        }\n+    }\n+\n+    // FIXME: more to come\n+\n+    private fun getCollectionInternal(collectionName: String, javaClass: Class<Document>? = null): MongoCollection<Document> {\n+        return when (javaClass) {\n+            null -> database.getCollection(collectionName)\n+            else -> database.getCollection(collectionName, javaClass)\n+        }\n+    }\n+\n+    private fun Document.withId(objectId: ObjectId? = null): Document {\n+        return apply { this[\"_id\"] = objectId ?: ObjectId() }\n+    }\n+\n+    private fun Document.withoutId(): Document {\n+        return apply { remove(\"_id\") }\n+    }\n+\n+    private companion object {\n+        const val SERVICE_NAME = \"BackingDB\"    // it comes from the test server's BackingDB/config.json", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwNjI4Mw=="}, "originalCommit": {"oid": "2266cd0e20e00a932b1190432e5cfc18919a9f20"}, "originalPosition": 272}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDk3NDg4OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmUser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMDoyMTo0OVrOGV_Jnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMDoyMTo0OVrOGV_Jnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwNzkzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public MongoClient getRemoteMongoClient(String serviceName) {\n          \n          \n            \n                public MongoClient getMongoClient(String serviceName) {", "url": "https://github.com/realm/realm-java/pull/6839#discussion_r425707935", "createdAt": "2020-05-15T10:21:49Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmUser.java", "diffHunk": "@@ -441,12 +440,11 @@ public RealmPushNotifications getPushNotifications() {\n     /**\n      * FIXME Add support for the MongoDB wrapper. Name of Class and method still TBD.\n      */\n-    public RemoteMongoClient getRemoteMongoClient() {\n-        if (remoteMongoClient == null) {\n-            // FIXME: serviceName?\n-            remoteMongoClient = new RemoteMongoClient(this, \"serviceName\");\n+    public MongoClient getRemoteMongoClient(String serviceName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2266cd0e20e00a932b1190432e5cfc18919a9f20"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 694, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}