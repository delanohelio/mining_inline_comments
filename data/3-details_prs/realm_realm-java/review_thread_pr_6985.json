{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNTczOTU4", "number": 6985, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMDoyMzoyNlrOELCu_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNzo0NzoyOFrOELKGVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMDE0NTg5OnYy", "diffSide": "RIGHT", "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.kt", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMDoyMzoyNlrOGsb8iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNTozNjoxMlrOGszr9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0ODM5Mg==", "bodyText": "@cmelchior Any particular reason for this to be the interface type?\nAdding the embedded objects require a RealmModel parent. Currently the fillers just use a hardcoded obj reference, but could of course just add both the interface and implementation typed variables as arguments  to the fillers where needed.", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449248392", "createdAt": "2020-07-02T20:23:26Z", "author": {"login": "rorbech"}, "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.kt", "diffHunk": "@@ -2066,107 +2066,126 @@ class RealmProxyClassGenerator(private val processingEnvironment: ProcessingEnvi\n     @Throws(IOException::class)\n     private fun emitCreateOrUpdateUsingJsonObject(writer: JavaWriter) {\n         writer.apply {\n+            val embedded = metadata.embedded\n             emitAnnotation(\"SuppressWarnings\", \"\\\"cast\\\"\")\n-            beginMethod(qualifiedJavaClassName,\"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n-            val modelOrListCount = countModelOrListFields(metadata.fields)\n-            if (modelOrListCount == 0) {\n-                emitStatement(\"final List<String> excludeFields = Collections.<String> emptyList()\")\n+            if (!embedded) {\n+                beginMethod(qualifiedJavaClassName, \"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n             } else {\n-                emitStatement(\"final List<String> excludeFields = new ArrayList<String>(%1\\$d)\", modelOrListCount)\n+                beginMethod(qualifiedJavaClassName, \"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"RealmModel\", \"parent\", \"String\", \"parentProperty\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n             }\n-\n-            if (!metadata.hasPrimaryKey()) {\n-                buildExcludeFieldsList(writer, metadata.fields)\n-                emitStatement(\"%s obj = realm.createObjectInternal(%s.class, true, excludeFields)\", qualifiedJavaClassName, qualifiedJavaClassName)\n-            } else {\n-                var pkType = \"Long\"\n-                var jsonAccessorMethodSuffix = \"Long\"\n-                var findFirstCast = \"\"\n-                if (Utils.isString(metadata.primaryKey)) {\n-                    pkType = \"String\"\n-                    jsonAccessorMethodSuffix=  \"String\"\n-                } else if (Utils.isObjectId(metadata.primaryKey)) {\n-                    pkType = \"ObjectId\"\n-                    findFirstCast = \"(org.bson.types.ObjectId)\"\n-                    jsonAccessorMethodSuffix = \"\"\n+                val modelOrListCount = countModelOrListFields(metadata.fields)\n+                if (modelOrListCount == 0) {\n+                    emitStatement(\"final List<String> excludeFields = Collections.<String> emptyList()\")\n+                } else {\n+                    emitStatement(\"final List<String> excludeFields = new ArrayList<String>(%1\\$d)\", modelOrListCount)\n                 }\n-                emitStatement(\"%s obj = null\", qualifiedJavaClassName)\n-                beginControlFlow(\"if (update)\")\n-                    emitStatement(\"Table table = realm.getTable(%s.class)\", qualifiedJavaClassName)\n-                    emitStatement(\"%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)\", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)\n-                    emitStatement(\"long pkColumnKey = %s\", fieldColKeyVariableReference(metadata.primaryKey))\n-                    emitStatement(\"long objKey = Table.NO_MATCH\")\n-                    if (metadata.isNullable(metadata.primaryKey!!)) {\n-                        beginControlFlow(\"if (json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n-                            emitStatement(\"objKey = table.findFirstNull(pkColumnKey)\")\n-                        nextControlFlow(\"else\")\n-                            emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n-                        endControlFlow()\n+\n+                if (!metadata.hasPrimaryKey()) {\n+                    buildExcludeFieldsList(writer, metadata.fields)\n+                    if (!embedded) {\n+                        emitStatement(\"%s obj = realm.createObjectInternal(%s.class, true, excludeFields)\", qualifiedJavaClassName, qualifiedJavaClassName)\n                     } else {\n-                        beginControlFlow(\"if (!json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n-                            emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n-                        endControlFlow()\n+                        emitStatement(\"%s obj = realm.createEmbeddedObject(%s.class, parent, parentProperty)\", qualifiedJavaClassName, qualifiedJavaClassName)\n+                    }\n+                } else {\n+                    var pkType = \"Long\"\n+                    var jsonAccessorMethodSuffix = \"Long\"\n+                    var findFirstCast = \"\"\n+                    if (Utils.isString(metadata.primaryKey)) {\n+                        pkType = \"String\"\n+                        jsonAccessorMethodSuffix=  \"String\"\n+                    } else if (Utils.isObjectId(metadata.primaryKey)) {\n+                        pkType = \"ObjectId\"\n+                        findFirstCast = \"(org.bson.types.ObjectId)\"\n+                        jsonAccessorMethodSuffix = \"\"\n                     }\n-                    beginControlFlow(\"if (objKey != Table.NO_MATCH)\")\n-                        emitStatement(\"final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()\")\n-                        beginControlFlow(\"try\")\n-                            emitStatement(\"objectContext.set(realm, table.getUncheckedRow(objKey), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())\", qualifiedJavaClassName)\n-                            emitStatement(\"obj = new %s()\", generatedClassName)\n-                        nextControlFlow(\"finally\")\n-                            emitStatement(\"objectContext.clear()\")\n+                    emitStatement(\"%s obj = null\", qualifiedJavaClassName)\n+                    beginControlFlow(\"if (update)\")\n+                        emitStatement(\"Table table = realm.getTable(%s.class)\", qualifiedJavaClassName)\n+                        emitStatement(\"%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)\", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)\n+                        emitStatement(\"long pkColumnKey = %s\", fieldColKeyVariableReference(metadata.primaryKey))\n+                        emitStatement(\"long objKey = Table.NO_MATCH\")\n+                        if (metadata.isNullable(metadata.primaryKey!!)) {\n+                            beginControlFlow(\"if (json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n+                                emitStatement(\"objKey = table.findFirstNull(pkColumnKey)\")\n+                            nextControlFlow(\"else\")\n+                                emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n+                            endControlFlow()\n+                        } else {\n+                            beginControlFlow(\"if (!json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n+                                emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n+                            endControlFlow()\n+                        }\n+                        beginControlFlow(\"if (objKey != Table.NO_MATCH)\")\n+                            emitStatement(\"final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()\")\n+                            beginControlFlow(\"try\")\n+                                emitStatement(\"objectContext.set(realm, table.getUncheckedRow(objKey), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())\", qualifiedJavaClassName)\n+                                emitStatement(\"obj = new %s()\", generatedClassName)\n+                            nextControlFlow(\"finally\")\n+                                emitStatement(\"objectContext.clear()\")\n+                            endControlFlow()\n                         endControlFlow()\n                     endControlFlow()\n-                endControlFlow()\n \n-                beginControlFlow(\"if (obj == null)\")\n-                    buildExcludeFieldsList(writer, metadata.fields)\n-                    val primaryKeyFieldType = QualifiedClassName(metadata.primaryKey!!.asType().toString())\n-                    val primaryKeyFieldName = metadata.primaryKey!!.simpleName.toString()\n-                    RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedJavaClassName, generatedClassName, primaryKeyFieldType, primaryKeyFieldName, writer)\n-                endControlFlow()\n-            }\n-            emitEmptyLine()\n-            emitStatement(\"final %1\\$s objProxy = (%1\\$s) obj\", interfaceName)\n-            for (field in metadata.fields) {\n-                val fieldName = field.simpleName.toString()\n-                val qualifiedFieldType = QualifiedClassName(field.asType().toString())\n-                if (metadata.isPrimaryKey(field)) {\n-                    continue  // Primary key has already been set when adding new row or finding the existing row.\n+                    beginControlFlow(\"if (obj == null)\")\n+                        buildExcludeFieldsList(writer, metadata.fields)\n+                        val primaryKeyFieldType = QualifiedClassName(metadata.primaryKey!!.asType().toString())\n+                        val primaryKeyFieldName = metadata.primaryKey!!.simpleName.toString()\n+                        RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedJavaClassName, generatedClassName, primaryKeyFieldType, primaryKeyFieldName, writer)\n+                    endControlFlow()\n                 }\n-                when {\n-                    Utils.isRealmModel(field) -> RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            Utils.getProxyClassSimpleName(field),\n-                            writer)\n-                    Utils.isRealmModelList(field) -> RealmJsonTypeHelper.emitFillRealmListWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalGetter(fieldName),\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            (field.asType() as DeclaredType).typeArguments[0].toString(),\n-                            Utils.getProxyClassSimpleName(field),\n-                            writer)\n-                    Utils.isRealmValueList(field) -> emitStatement(\"ProxyUtils.setRealmListWithJsonObject(objProxy.%1\\$s(), json, \\\"%2\\$s\\\")\", metadata.getInternalGetter(fieldName), fieldName)\n-                    Utils.isMutableRealmInteger(field) -> RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalGetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            writer)\n-                    else -> RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            writer)\n+                emitEmptyLine()\n+                emitStatement(\"final %1\\$s objProxy = (%1\\$s) obj\", interfaceName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52299681ed25ba0423f8dd1cea9436adad6ac25c"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwODA2MA==", "bodyText": "I'm a bit unsure, but I believe it is in order to reference the future generated getters and setters in the model class", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449408060", "createdAt": "2020-07-03T06:54:13Z", "author": {"login": "cmelchior"}, "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.kt", "diffHunk": "@@ -2066,107 +2066,126 @@ class RealmProxyClassGenerator(private val processingEnvironment: ProcessingEnvi\n     @Throws(IOException::class)\n     private fun emitCreateOrUpdateUsingJsonObject(writer: JavaWriter) {\n         writer.apply {\n+            val embedded = metadata.embedded\n             emitAnnotation(\"SuppressWarnings\", \"\\\"cast\\\"\")\n-            beginMethod(qualifiedJavaClassName,\"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n-            val modelOrListCount = countModelOrListFields(metadata.fields)\n-            if (modelOrListCount == 0) {\n-                emitStatement(\"final List<String> excludeFields = Collections.<String> emptyList()\")\n+            if (!embedded) {\n+                beginMethod(qualifiedJavaClassName, \"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n             } else {\n-                emitStatement(\"final List<String> excludeFields = new ArrayList<String>(%1\\$d)\", modelOrListCount)\n+                beginMethod(qualifiedJavaClassName, \"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"RealmModel\", \"parent\", \"String\", \"parentProperty\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n             }\n-\n-            if (!metadata.hasPrimaryKey()) {\n-                buildExcludeFieldsList(writer, metadata.fields)\n-                emitStatement(\"%s obj = realm.createObjectInternal(%s.class, true, excludeFields)\", qualifiedJavaClassName, qualifiedJavaClassName)\n-            } else {\n-                var pkType = \"Long\"\n-                var jsonAccessorMethodSuffix = \"Long\"\n-                var findFirstCast = \"\"\n-                if (Utils.isString(metadata.primaryKey)) {\n-                    pkType = \"String\"\n-                    jsonAccessorMethodSuffix=  \"String\"\n-                } else if (Utils.isObjectId(metadata.primaryKey)) {\n-                    pkType = \"ObjectId\"\n-                    findFirstCast = \"(org.bson.types.ObjectId)\"\n-                    jsonAccessorMethodSuffix = \"\"\n+                val modelOrListCount = countModelOrListFields(metadata.fields)\n+                if (modelOrListCount == 0) {\n+                    emitStatement(\"final List<String> excludeFields = Collections.<String> emptyList()\")\n+                } else {\n+                    emitStatement(\"final List<String> excludeFields = new ArrayList<String>(%1\\$d)\", modelOrListCount)\n                 }\n-                emitStatement(\"%s obj = null\", qualifiedJavaClassName)\n-                beginControlFlow(\"if (update)\")\n-                    emitStatement(\"Table table = realm.getTable(%s.class)\", qualifiedJavaClassName)\n-                    emitStatement(\"%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)\", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)\n-                    emitStatement(\"long pkColumnKey = %s\", fieldColKeyVariableReference(metadata.primaryKey))\n-                    emitStatement(\"long objKey = Table.NO_MATCH\")\n-                    if (metadata.isNullable(metadata.primaryKey!!)) {\n-                        beginControlFlow(\"if (json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n-                            emitStatement(\"objKey = table.findFirstNull(pkColumnKey)\")\n-                        nextControlFlow(\"else\")\n-                            emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n-                        endControlFlow()\n+\n+                if (!metadata.hasPrimaryKey()) {\n+                    buildExcludeFieldsList(writer, metadata.fields)\n+                    if (!embedded) {\n+                        emitStatement(\"%s obj = realm.createObjectInternal(%s.class, true, excludeFields)\", qualifiedJavaClassName, qualifiedJavaClassName)\n                     } else {\n-                        beginControlFlow(\"if (!json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n-                            emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n-                        endControlFlow()\n+                        emitStatement(\"%s obj = realm.createEmbeddedObject(%s.class, parent, parentProperty)\", qualifiedJavaClassName, qualifiedJavaClassName)\n+                    }\n+                } else {\n+                    var pkType = \"Long\"\n+                    var jsonAccessorMethodSuffix = \"Long\"\n+                    var findFirstCast = \"\"\n+                    if (Utils.isString(metadata.primaryKey)) {\n+                        pkType = \"String\"\n+                        jsonAccessorMethodSuffix=  \"String\"\n+                    } else if (Utils.isObjectId(metadata.primaryKey)) {\n+                        pkType = \"ObjectId\"\n+                        findFirstCast = \"(org.bson.types.ObjectId)\"\n+                        jsonAccessorMethodSuffix = \"\"\n                     }\n-                    beginControlFlow(\"if (objKey != Table.NO_MATCH)\")\n-                        emitStatement(\"final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()\")\n-                        beginControlFlow(\"try\")\n-                            emitStatement(\"objectContext.set(realm, table.getUncheckedRow(objKey), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())\", qualifiedJavaClassName)\n-                            emitStatement(\"obj = new %s()\", generatedClassName)\n-                        nextControlFlow(\"finally\")\n-                            emitStatement(\"objectContext.clear()\")\n+                    emitStatement(\"%s obj = null\", qualifiedJavaClassName)\n+                    beginControlFlow(\"if (update)\")\n+                        emitStatement(\"Table table = realm.getTable(%s.class)\", qualifiedJavaClassName)\n+                        emitStatement(\"%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)\", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)\n+                        emitStatement(\"long pkColumnKey = %s\", fieldColKeyVariableReference(metadata.primaryKey))\n+                        emitStatement(\"long objKey = Table.NO_MATCH\")\n+                        if (metadata.isNullable(metadata.primaryKey!!)) {\n+                            beginControlFlow(\"if (json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n+                                emitStatement(\"objKey = table.findFirstNull(pkColumnKey)\")\n+                            nextControlFlow(\"else\")\n+                                emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n+                            endControlFlow()\n+                        } else {\n+                            beginControlFlow(\"if (!json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n+                                emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n+                            endControlFlow()\n+                        }\n+                        beginControlFlow(\"if (objKey != Table.NO_MATCH)\")\n+                            emitStatement(\"final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()\")\n+                            beginControlFlow(\"try\")\n+                                emitStatement(\"objectContext.set(realm, table.getUncheckedRow(objKey), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())\", qualifiedJavaClassName)\n+                                emitStatement(\"obj = new %s()\", generatedClassName)\n+                            nextControlFlow(\"finally\")\n+                                emitStatement(\"objectContext.clear()\")\n+                            endControlFlow()\n                         endControlFlow()\n                     endControlFlow()\n-                endControlFlow()\n \n-                beginControlFlow(\"if (obj == null)\")\n-                    buildExcludeFieldsList(writer, metadata.fields)\n-                    val primaryKeyFieldType = QualifiedClassName(metadata.primaryKey!!.asType().toString())\n-                    val primaryKeyFieldName = metadata.primaryKey!!.simpleName.toString()\n-                    RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedJavaClassName, generatedClassName, primaryKeyFieldType, primaryKeyFieldName, writer)\n-                endControlFlow()\n-            }\n-            emitEmptyLine()\n-            emitStatement(\"final %1\\$s objProxy = (%1\\$s) obj\", interfaceName)\n-            for (field in metadata.fields) {\n-                val fieldName = field.simpleName.toString()\n-                val qualifiedFieldType = QualifiedClassName(field.asType().toString())\n-                if (metadata.isPrimaryKey(field)) {\n-                    continue  // Primary key has already been set when adding new row or finding the existing row.\n+                    beginControlFlow(\"if (obj == null)\")\n+                        buildExcludeFieldsList(writer, metadata.fields)\n+                        val primaryKeyFieldType = QualifiedClassName(metadata.primaryKey!!.asType().toString())\n+                        val primaryKeyFieldName = metadata.primaryKey!!.simpleName.toString()\n+                        RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedJavaClassName, generatedClassName, primaryKeyFieldType, primaryKeyFieldName, writer)\n+                    endControlFlow()\n                 }\n-                when {\n-                    Utils.isRealmModel(field) -> RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            Utils.getProxyClassSimpleName(field),\n-                            writer)\n-                    Utils.isRealmModelList(field) -> RealmJsonTypeHelper.emitFillRealmListWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalGetter(fieldName),\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            (field.asType() as DeclaredType).typeArguments[0].toString(),\n-                            Utils.getProxyClassSimpleName(field),\n-                            writer)\n-                    Utils.isRealmValueList(field) -> emitStatement(\"ProxyUtils.setRealmListWithJsonObject(objProxy.%1\\$s(), json, \\\"%2\\$s\\\")\", metadata.getInternalGetter(fieldName), fieldName)\n-                    Utils.isMutableRealmInteger(field) -> RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalGetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            writer)\n-                    else -> RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            writer)\n+                emitEmptyLine()\n+                emitStatement(\"final %1\\$s objProxy = (%1\\$s) obj\", interfaceName)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0ODM5Mg=="}, "originalCommit": {"oid": "52299681ed25ba0423f8dd1cea9436adad6ac25c"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUwMjIzMw==", "bodyText": "Yes, I guess we now need both the proxy and the actual object (RealmModel)", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449502233", "createdAt": "2020-07-03T10:11:19Z", "author": {"login": "rorbech"}, "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.kt", "diffHunk": "@@ -2066,107 +2066,126 @@ class RealmProxyClassGenerator(private val processingEnvironment: ProcessingEnvi\n     @Throws(IOException::class)\n     private fun emitCreateOrUpdateUsingJsonObject(writer: JavaWriter) {\n         writer.apply {\n+            val embedded = metadata.embedded\n             emitAnnotation(\"SuppressWarnings\", \"\\\"cast\\\"\")\n-            beginMethod(qualifiedJavaClassName,\"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n-            val modelOrListCount = countModelOrListFields(metadata.fields)\n-            if (modelOrListCount == 0) {\n-                emitStatement(\"final List<String> excludeFields = Collections.<String> emptyList()\")\n+            if (!embedded) {\n+                beginMethod(qualifiedJavaClassName, \"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n             } else {\n-                emitStatement(\"final List<String> excludeFields = new ArrayList<String>(%1\\$d)\", modelOrListCount)\n+                beginMethod(qualifiedJavaClassName, \"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"RealmModel\", \"parent\", \"String\", \"parentProperty\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n             }\n-\n-            if (!metadata.hasPrimaryKey()) {\n-                buildExcludeFieldsList(writer, metadata.fields)\n-                emitStatement(\"%s obj = realm.createObjectInternal(%s.class, true, excludeFields)\", qualifiedJavaClassName, qualifiedJavaClassName)\n-            } else {\n-                var pkType = \"Long\"\n-                var jsonAccessorMethodSuffix = \"Long\"\n-                var findFirstCast = \"\"\n-                if (Utils.isString(metadata.primaryKey)) {\n-                    pkType = \"String\"\n-                    jsonAccessorMethodSuffix=  \"String\"\n-                } else if (Utils.isObjectId(metadata.primaryKey)) {\n-                    pkType = \"ObjectId\"\n-                    findFirstCast = \"(org.bson.types.ObjectId)\"\n-                    jsonAccessorMethodSuffix = \"\"\n+                val modelOrListCount = countModelOrListFields(metadata.fields)\n+                if (modelOrListCount == 0) {\n+                    emitStatement(\"final List<String> excludeFields = Collections.<String> emptyList()\")\n+                } else {\n+                    emitStatement(\"final List<String> excludeFields = new ArrayList<String>(%1\\$d)\", modelOrListCount)\n                 }\n-                emitStatement(\"%s obj = null\", qualifiedJavaClassName)\n-                beginControlFlow(\"if (update)\")\n-                    emitStatement(\"Table table = realm.getTable(%s.class)\", qualifiedJavaClassName)\n-                    emitStatement(\"%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)\", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)\n-                    emitStatement(\"long pkColumnKey = %s\", fieldColKeyVariableReference(metadata.primaryKey))\n-                    emitStatement(\"long objKey = Table.NO_MATCH\")\n-                    if (metadata.isNullable(metadata.primaryKey!!)) {\n-                        beginControlFlow(\"if (json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n-                            emitStatement(\"objKey = table.findFirstNull(pkColumnKey)\")\n-                        nextControlFlow(\"else\")\n-                            emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n-                        endControlFlow()\n+\n+                if (!metadata.hasPrimaryKey()) {\n+                    buildExcludeFieldsList(writer, metadata.fields)\n+                    if (!embedded) {\n+                        emitStatement(\"%s obj = realm.createObjectInternal(%s.class, true, excludeFields)\", qualifiedJavaClassName, qualifiedJavaClassName)\n                     } else {\n-                        beginControlFlow(\"if (!json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n-                            emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n-                        endControlFlow()\n+                        emitStatement(\"%s obj = realm.createEmbeddedObject(%s.class, parent, parentProperty)\", qualifiedJavaClassName, qualifiedJavaClassName)\n+                    }\n+                } else {\n+                    var pkType = \"Long\"\n+                    var jsonAccessorMethodSuffix = \"Long\"\n+                    var findFirstCast = \"\"\n+                    if (Utils.isString(metadata.primaryKey)) {\n+                        pkType = \"String\"\n+                        jsonAccessorMethodSuffix=  \"String\"\n+                    } else if (Utils.isObjectId(metadata.primaryKey)) {\n+                        pkType = \"ObjectId\"\n+                        findFirstCast = \"(org.bson.types.ObjectId)\"\n+                        jsonAccessorMethodSuffix = \"\"\n                     }\n-                    beginControlFlow(\"if (objKey != Table.NO_MATCH)\")\n-                        emitStatement(\"final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()\")\n-                        beginControlFlow(\"try\")\n-                            emitStatement(\"objectContext.set(realm, table.getUncheckedRow(objKey), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())\", qualifiedJavaClassName)\n-                            emitStatement(\"obj = new %s()\", generatedClassName)\n-                        nextControlFlow(\"finally\")\n-                            emitStatement(\"objectContext.clear()\")\n+                    emitStatement(\"%s obj = null\", qualifiedJavaClassName)\n+                    beginControlFlow(\"if (update)\")\n+                        emitStatement(\"Table table = realm.getTable(%s.class)\", qualifiedJavaClassName)\n+                        emitStatement(\"%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)\", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)\n+                        emitStatement(\"long pkColumnKey = %s\", fieldColKeyVariableReference(metadata.primaryKey))\n+                        emitStatement(\"long objKey = Table.NO_MATCH\")\n+                        if (metadata.isNullable(metadata.primaryKey!!)) {\n+                            beginControlFlow(\"if (json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n+                                emitStatement(\"objKey = table.findFirstNull(pkColumnKey)\")\n+                            nextControlFlow(\"else\")\n+                                emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n+                            endControlFlow()\n+                        } else {\n+                            beginControlFlow(\"if (!json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n+                                emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n+                            endControlFlow()\n+                        }\n+                        beginControlFlow(\"if (objKey != Table.NO_MATCH)\")\n+                            emitStatement(\"final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()\")\n+                            beginControlFlow(\"try\")\n+                                emitStatement(\"objectContext.set(realm, table.getUncheckedRow(objKey), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())\", qualifiedJavaClassName)\n+                                emitStatement(\"obj = new %s()\", generatedClassName)\n+                            nextControlFlow(\"finally\")\n+                                emitStatement(\"objectContext.clear()\")\n+                            endControlFlow()\n                         endControlFlow()\n                     endControlFlow()\n-                endControlFlow()\n \n-                beginControlFlow(\"if (obj == null)\")\n-                    buildExcludeFieldsList(writer, metadata.fields)\n-                    val primaryKeyFieldType = QualifiedClassName(metadata.primaryKey!!.asType().toString())\n-                    val primaryKeyFieldName = metadata.primaryKey!!.simpleName.toString()\n-                    RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedJavaClassName, generatedClassName, primaryKeyFieldType, primaryKeyFieldName, writer)\n-                endControlFlow()\n-            }\n-            emitEmptyLine()\n-            emitStatement(\"final %1\\$s objProxy = (%1\\$s) obj\", interfaceName)\n-            for (field in metadata.fields) {\n-                val fieldName = field.simpleName.toString()\n-                val qualifiedFieldType = QualifiedClassName(field.asType().toString())\n-                if (metadata.isPrimaryKey(field)) {\n-                    continue  // Primary key has already been set when adding new row or finding the existing row.\n+                    beginControlFlow(\"if (obj == null)\")\n+                        buildExcludeFieldsList(writer, metadata.fields)\n+                        val primaryKeyFieldType = QualifiedClassName(metadata.primaryKey!!.asType().toString())\n+                        val primaryKeyFieldName = metadata.primaryKey!!.simpleName.toString()\n+                        RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedJavaClassName, generatedClassName, primaryKeyFieldType, primaryKeyFieldName, writer)\n+                    endControlFlow()\n                 }\n-                when {\n-                    Utils.isRealmModel(field) -> RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            Utils.getProxyClassSimpleName(field),\n-                            writer)\n-                    Utils.isRealmModelList(field) -> RealmJsonTypeHelper.emitFillRealmListWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalGetter(fieldName),\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            (field.asType() as DeclaredType).typeArguments[0].toString(),\n-                            Utils.getProxyClassSimpleName(field),\n-                            writer)\n-                    Utils.isRealmValueList(field) -> emitStatement(\"ProxyUtils.setRealmListWithJsonObject(objProxy.%1\\$s(), json, \\\"%2\\$s\\\")\", metadata.getInternalGetter(fieldName), fieldName)\n-                    Utils.isMutableRealmInteger(field) -> RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalGetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            writer)\n-                    else -> RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            writer)\n+                emitEmptyLine()\n+                emitStatement(\"final %1\\$s objProxy = (%1\\$s) obj\", interfaceName)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0ODM5Mg=="}, "originalCommit": {"oid": "52299681ed25ba0423f8dd1cea9436adad6ac25c"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUwMjg0MA==", "bodyText": "The proxy is always a subclass of the realm model, so you can do unsafe casts if needed. We do that in a few places.", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449502840", "createdAt": "2020-07-03T10:12:42Z", "author": {"login": "cmelchior"}, "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.kt", "diffHunk": "@@ -2066,107 +2066,126 @@ class RealmProxyClassGenerator(private val processingEnvironment: ProcessingEnvi\n     @Throws(IOException::class)\n     private fun emitCreateOrUpdateUsingJsonObject(writer: JavaWriter) {\n         writer.apply {\n+            val embedded = metadata.embedded\n             emitAnnotation(\"SuppressWarnings\", \"\\\"cast\\\"\")\n-            beginMethod(qualifiedJavaClassName,\"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n-            val modelOrListCount = countModelOrListFields(metadata.fields)\n-            if (modelOrListCount == 0) {\n-                emitStatement(\"final List<String> excludeFields = Collections.<String> emptyList()\")\n+            if (!embedded) {\n+                beginMethod(qualifiedJavaClassName, \"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n             } else {\n-                emitStatement(\"final List<String> excludeFields = new ArrayList<String>(%1\\$d)\", modelOrListCount)\n+                beginMethod(qualifiedJavaClassName, \"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"RealmModel\", \"parent\", \"String\", \"parentProperty\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n             }\n-\n-            if (!metadata.hasPrimaryKey()) {\n-                buildExcludeFieldsList(writer, metadata.fields)\n-                emitStatement(\"%s obj = realm.createObjectInternal(%s.class, true, excludeFields)\", qualifiedJavaClassName, qualifiedJavaClassName)\n-            } else {\n-                var pkType = \"Long\"\n-                var jsonAccessorMethodSuffix = \"Long\"\n-                var findFirstCast = \"\"\n-                if (Utils.isString(metadata.primaryKey)) {\n-                    pkType = \"String\"\n-                    jsonAccessorMethodSuffix=  \"String\"\n-                } else if (Utils.isObjectId(metadata.primaryKey)) {\n-                    pkType = \"ObjectId\"\n-                    findFirstCast = \"(org.bson.types.ObjectId)\"\n-                    jsonAccessorMethodSuffix = \"\"\n+                val modelOrListCount = countModelOrListFields(metadata.fields)\n+                if (modelOrListCount == 0) {\n+                    emitStatement(\"final List<String> excludeFields = Collections.<String> emptyList()\")\n+                } else {\n+                    emitStatement(\"final List<String> excludeFields = new ArrayList<String>(%1\\$d)\", modelOrListCount)\n                 }\n-                emitStatement(\"%s obj = null\", qualifiedJavaClassName)\n-                beginControlFlow(\"if (update)\")\n-                    emitStatement(\"Table table = realm.getTable(%s.class)\", qualifiedJavaClassName)\n-                    emitStatement(\"%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)\", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)\n-                    emitStatement(\"long pkColumnKey = %s\", fieldColKeyVariableReference(metadata.primaryKey))\n-                    emitStatement(\"long objKey = Table.NO_MATCH\")\n-                    if (metadata.isNullable(metadata.primaryKey!!)) {\n-                        beginControlFlow(\"if (json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n-                            emitStatement(\"objKey = table.findFirstNull(pkColumnKey)\")\n-                        nextControlFlow(\"else\")\n-                            emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n-                        endControlFlow()\n+\n+                if (!metadata.hasPrimaryKey()) {\n+                    buildExcludeFieldsList(writer, metadata.fields)\n+                    if (!embedded) {\n+                        emitStatement(\"%s obj = realm.createObjectInternal(%s.class, true, excludeFields)\", qualifiedJavaClassName, qualifiedJavaClassName)\n                     } else {\n-                        beginControlFlow(\"if (!json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n-                            emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n-                        endControlFlow()\n+                        emitStatement(\"%s obj = realm.createEmbeddedObject(%s.class, parent, parentProperty)\", qualifiedJavaClassName, qualifiedJavaClassName)\n+                    }\n+                } else {\n+                    var pkType = \"Long\"\n+                    var jsonAccessorMethodSuffix = \"Long\"\n+                    var findFirstCast = \"\"\n+                    if (Utils.isString(metadata.primaryKey)) {\n+                        pkType = \"String\"\n+                        jsonAccessorMethodSuffix=  \"String\"\n+                    } else if (Utils.isObjectId(metadata.primaryKey)) {\n+                        pkType = \"ObjectId\"\n+                        findFirstCast = \"(org.bson.types.ObjectId)\"\n+                        jsonAccessorMethodSuffix = \"\"\n                     }\n-                    beginControlFlow(\"if (objKey != Table.NO_MATCH)\")\n-                        emitStatement(\"final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()\")\n-                        beginControlFlow(\"try\")\n-                            emitStatement(\"objectContext.set(realm, table.getUncheckedRow(objKey), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())\", qualifiedJavaClassName)\n-                            emitStatement(\"obj = new %s()\", generatedClassName)\n-                        nextControlFlow(\"finally\")\n-                            emitStatement(\"objectContext.clear()\")\n+                    emitStatement(\"%s obj = null\", qualifiedJavaClassName)\n+                    beginControlFlow(\"if (update)\")\n+                        emitStatement(\"Table table = realm.getTable(%s.class)\", qualifiedJavaClassName)\n+                        emitStatement(\"%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)\", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)\n+                        emitStatement(\"long pkColumnKey = %s\", fieldColKeyVariableReference(metadata.primaryKey))\n+                        emitStatement(\"long objKey = Table.NO_MATCH\")\n+                        if (metadata.isNullable(metadata.primaryKey!!)) {\n+                            beginControlFlow(\"if (json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n+                                emitStatement(\"objKey = table.findFirstNull(pkColumnKey)\")\n+                            nextControlFlow(\"else\")\n+                                emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n+                            endControlFlow()\n+                        } else {\n+                            beginControlFlow(\"if (!json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n+                                emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n+                            endControlFlow()\n+                        }\n+                        beginControlFlow(\"if (objKey != Table.NO_MATCH)\")\n+                            emitStatement(\"final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()\")\n+                            beginControlFlow(\"try\")\n+                                emitStatement(\"objectContext.set(realm, table.getUncheckedRow(objKey), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())\", qualifiedJavaClassName)\n+                                emitStatement(\"obj = new %s()\", generatedClassName)\n+                            nextControlFlow(\"finally\")\n+                                emitStatement(\"objectContext.clear()\")\n+                            endControlFlow()\n                         endControlFlow()\n                     endControlFlow()\n-                endControlFlow()\n \n-                beginControlFlow(\"if (obj == null)\")\n-                    buildExcludeFieldsList(writer, metadata.fields)\n-                    val primaryKeyFieldType = QualifiedClassName(metadata.primaryKey!!.asType().toString())\n-                    val primaryKeyFieldName = metadata.primaryKey!!.simpleName.toString()\n-                    RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedJavaClassName, generatedClassName, primaryKeyFieldType, primaryKeyFieldName, writer)\n-                endControlFlow()\n-            }\n-            emitEmptyLine()\n-            emitStatement(\"final %1\\$s objProxy = (%1\\$s) obj\", interfaceName)\n-            for (field in metadata.fields) {\n-                val fieldName = field.simpleName.toString()\n-                val qualifiedFieldType = QualifiedClassName(field.asType().toString())\n-                if (metadata.isPrimaryKey(field)) {\n-                    continue  // Primary key has already been set when adding new row or finding the existing row.\n+                    beginControlFlow(\"if (obj == null)\")\n+                        buildExcludeFieldsList(writer, metadata.fields)\n+                        val primaryKeyFieldType = QualifiedClassName(metadata.primaryKey!!.asType().toString())\n+                        val primaryKeyFieldName = metadata.primaryKey!!.simpleName.toString()\n+                        RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedJavaClassName, generatedClassName, primaryKeyFieldType, primaryKeyFieldName, writer)\n+                    endControlFlow()\n                 }\n-                when {\n-                    Utils.isRealmModel(field) -> RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            Utils.getProxyClassSimpleName(field),\n-                            writer)\n-                    Utils.isRealmModelList(field) -> RealmJsonTypeHelper.emitFillRealmListWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalGetter(fieldName),\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            (field.asType() as DeclaredType).typeArguments[0].toString(),\n-                            Utils.getProxyClassSimpleName(field),\n-                            writer)\n-                    Utils.isRealmValueList(field) -> emitStatement(\"ProxyUtils.setRealmListWithJsonObject(objProxy.%1\\$s(), json, \\\"%2\\$s\\\")\", metadata.getInternalGetter(fieldName), fieldName)\n-                    Utils.isMutableRealmInteger(field) -> RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalGetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            writer)\n-                    else -> RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            writer)\n+                emitEmptyLine()\n+                emitStatement(\"final %1\\$s objProxy = (%1\\$s) obj\", interfaceName)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0ODM5Mg=="}, "originalCommit": {"oid": "52299681ed25ba0423f8dd1cea9436adad6ac25c"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYzNzM2Ng==", "bodyText": "Did the unsafe cast instead, as I think it will cause less confusion than juggling differently typed references to the same object.", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449637366", "createdAt": "2020-07-03T15:36:12Z", "author": {"login": "rorbech"}, "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.kt", "diffHunk": "@@ -2066,107 +2066,126 @@ class RealmProxyClassGenerator(private val processingEnvironment: ProcessingEnvi\n     @Throws(IOException::class)\n     private fun emitCreateOrUpdateUsingJsonObject(writer: JavaWriter) {\n         writer.apply {\n+            val embedded = metadata.embedded\n             emitAnnotation(\"SuppressWarnings\", \"\\\"cast\\\"\")\n-            beginMethod(qualifiedJavaClassName,\"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n-            val modelOrListCount = countModelOrListFields(metadata.fields)\n-            if (modelOrListCount == 0) {\n-                emitStatement(\"final List<String> excludeFields = Collections.<String> emptyList()\")\n+            if (!embedded) {\n+                beginMethod(qualifiedJavaClassName, \"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n             } else {\n-                emitStatement(\"final List<String> excludeFields = new ArrayList<String>(%1\\$d)\", modelOrListCount)\n+                beginMethod(qualifiedJavaClassName, \"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"RealmModel\", \"parent\", \"String\", \"parentProperty\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n             }\n-\n-            if (!metadata.hasPrimaryKey()) {\n-                buildExcludeFieldsList(writer, metadata.fields)\n-                emitStatement(\"%s obj = realm.createObjectInternal(%s.class, true, excludeFields)\", qualifiedJavaClassName, qualifiedJavaClassName)\n-            } else {\n-                var pkType = \"Long\"\n-                var jsonAccessorMethodSuffix = \"Long\"\n-                var findFirstCast = \"\"\n-                if (Utils.isString(metadata.primaryKey)) {\n-                    pkType = \"String\"\n-                    jsonAccessorMethodSuffix=  \"String\"\n-                } else if (Utils.isObjectId(metadata.primaryKey)) {\n-                    pkType = \"ObjectId\"\n-                    findFirstCast = \"(org.bson.types.ObjectId)\"\n-                    jsonAccessorMethodSuffix = \"\"\n+                val modelOrListCount = countModelOrListFields(metadata.fields)\n+                if (modelOrListCount == 0) {\n+                    emitStatement(\"final List<String> excludeFields = Collections.<String> emptyList()\")\n+                } else {\n+                    emitStatement(\"final List<String> excludeFields = new ArrayList<String>(%1\\$d)\", modelOrListCount)\n                 }\n-                emitStatement(\"%s obj = null\", qualifiedJavaClassName)\n-                beginControlFlow(\"if (update)\")\n-                    emitStatement(\"Table table = realm.getTable(%s.class)\", qualifiedJavaClassName)\n-                    emitStatement(\"%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)\", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)\n-                    emitStatement(\"long pkColumnKey = %s\", fieldColKeyVariableReference(metadata.primaryKey))\n-                    emitStatement(\"long objKey = Table.NO_MATCH\")\n-                    if (metadata.isNullable(metadata.primaryKey!!)) {\n-                        beginControlFlow(\"if (json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n-                            emitStatement(\"objKey = table.findFirstNull(pkColumnKey)\")\n-                        nextControlFlow(\"else\")\n-                            emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n-                        endControlFlow()\n+\n+                if (!metadata.hasPrimaryKey()) {\n+                    buildExcludeFieldsList(writer, metadata.fields)\n+                    if (!embedded) {\n+                        emitStatement(\"%s obj = realm.createObjectInternal(%s.class, true, excludeFields)\", qualifiedJavaClassName, qualifiedJavaClassName)\n                     } else {\n-                        beginControlFlow(\"if (!json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n-                            emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n-                        endControlFlow()\n+                        emitStatement(\"%s obj = realm.createEmbeddedObject(%s.class, parent, parentProperty)\", qualifiedJavaClassName, qualifiedJavaClassName)\n+                    }\n+                } else {\n+                    var pkType = \"Long\"\n+                    var jsonAccessorMethodSuffix = \"Long\"\n+                    var findFirstCast = \"\"\n+                    if (Utils.isString(metadata.primaryKey)) {\n+                        pkType = \"String\"\n+                        jsonAccessorMethodSuffix=  \"String\"\n+                    } else if (Utils.isObjectId(metadata.primaryKey)) {\n+                        pkType = \"ObjectId\"\n+                        findFirstCast = \"(org.bson.types.ObjectId)\"\n+                        jsonAccessorMethodSuffix = \"\"\n                     }\n-                    beginControlFlow(\"if (objKey != Table.NO_MATCH)\")\n-                        emitStatement(\"final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()\")\n-                        beginControlFlow(\"try\")\n-                            emitStatement(\"objectContext.set(realm, table.getUncheckedRow(objKey), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())\", qualifiedJavaClassName)\n-                            emitStatement(\"obj = new %s()\", generatedClassName)\n-                        nextControlFlow(\"finally\")\n-                            emitStatement(\"objectContext.clear()\")\n+                    emitStatement(\"%s obj = null\", qualifiedJavaClassName)\n+                    beginControlFlow(\"if (update)\")\n+                        emitStatement(\"Table table = realm.getTable(%s.class)\", qualifiedJavaClassName)\n+                        emitStatement(\"%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)\", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)\n+                        emitStatement(\"long pkColumnKey = %s\", fieldColKeyVariableReference(metadata.primaryKey))\n+                        emitStatement(\"long objKey = Table.NO_MATCH\")\n+                        if (metadata.isNullable(metadata.primaryKey!!)) {\n+                            beginControlFlow(\"if (json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n+                                emitStatement(\"objKey = table.findFirstNull(pkColumnKey)\")\n+                            nextControlFlow(\"else\")\n+                                emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n+                            endControlFlow()\n+                        } else {\n+                            beginControlFlow(\"if (!json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n+                                emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n+                            endControlFlow()\n+                        }\n+                        beginControlFlow(\"if (objKey != Table.NO_MATCH)\")\n+                            emitStatement(\"final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()\")\n+                            beginControlFlow(\"try\")\n+                                emitStatement(\"objectContext.set(realm, table.getUncheckedRow(objKey), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())\", qualifiedJavaClassName)\n+                                emitStatement(\"obj = new %s()\", generatedClassName)\n+                            nextControlFlow(\"finally\")\n+                                emitStatement(\"objectContext.clear()\")\n+                            endControlFlow()\n                         endControlFlow()\n                     endControlFlow()\n-                endControlFlow()\n \n-                beginControlFlow(\"if (obj == null)\")\n-                    buildExcludeFieldsList(writer, metadata.fields)\n-                    val primaryKeyFieldType = QualifiedClassName(metadata.primaryKey!!.asType().toString())\n-                    val primaryKeyFieldName = metadata.primaryKey!!.simpleName.toString()\n-                    RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedJavaClassName, generatedClassName, primaryKeyFieldType, primaryKeyFieldName, writer)\n-                endControlFlow()\n-            }\n-            emitEmptyLine()\n-            emitStatement(\"final %1\\$s objProxy = (%1\\$s) obj\", interfaceName)\n-            for (field in metadata.fields) {\n-                val fieldName = field.simpleName.toString()\n-                val qualifiedFieldType = QualifiedClassName(field.asType().toString())\n-                if (metadata.isPrimaryKey(field)) {\n-                    continue  // Primary key has already been set when adding new row or finding the existing row.\n+                    beginControlFlow(\"if (obj == null)\")\n+                        buildExcludeFieldsList(writer, metadata.fields)\n+                        val primaryKeyFieldType = QualifiedClassName(metadata.primaryKey!!.asType().toString())\n+                        val primaryKeyFieldName = metadata.primaryKey!!.simpleName.toString()\n+                        RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedJavaClassName, generatedClassName, primaryKeyFieldType, primaryKeyFieldName, writer)\n+                    endControlFlow()\n                 }\n-                when {\n-                    Utils.isRealmModel(field) -> RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            Utils.getProxyClassSimpleName(field),\n-                            writer)\n-                    Utils.isRealmModelList(field) -> RealmJsonTypeHelper.emitFillRealmListWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalGetter(fieldName),\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            (field.asType() as DeclaredType).typeArguments[0].toString(),\n-                            Utils.getProxyClassSimpleName(field),\n-                            writer)\n-                    Utils.isRealmValueList(field) -> emitStatement(\"ProxyUtils.setRealmListWithJsonObject(objProxy.%1\\$s(), json, \\\"%2\\$s\\\")\", metadata.getInternalGetter(fieldName), fieldName)\n-                    Utils.isMutableRealmInteger(field) -> RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalGetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            writer)\n-                    else -> RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            writer)\n+                emitEmptyLine()\n+                emitStatement(\"final %1\\$s objProxy = (%1\\$s) obj\", interfaceName)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0ODM5Mg=="}, "originalCommit": {"oid": "52299681ed25ba0423f8dd1cea9436adad6ac25c"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTE4OTQzOnYy", "diffSide": "LEFT", "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjo0Nzo1N1rOGsljAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMTowMTowMFrOGssvpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwNTY5OQ==", "bodyText": "I don't think we should completely remove this placeholder as it also covers the other json variants, but the name and description could have been more clear about that.", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449405699", "createdAt": "2020-07-03T06:47:57Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "diffHunk": "@@ -437,9 +436,53 @@ class EmbeddedObjectsTest {\n     }\n \n     @Test\n-    @Ignore(\"Add in another PR\")\n-    fun createObjectFromJson() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52299681ed25ba0423f8dd1cea9436adad6ac25c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUyMzYyMg==", "bodyText": "Added another separate ignored test for the stream-based API", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449523622", "createdAt": "2020-07-03T11:01:00Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "diffHunk": "@@ -437,9 +436,53 @@ class EmbeddedObjectsTest {\n     }\n \n     @Test\n-    @Ignore(\"Add in another PR\")\n-    fun createObjectFromJson() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwNTY5OQ=="}, "originalCommit": {"oid": "52299681ed25ba0423f8dd1cea9436adad6ac25c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTE5MTgxOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjo0OTowNFrOGslkgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjo0OTowNFrOGslkgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwNjA4Mg==", "bodyText": "You are using !! in other places?", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449406082", "createdAt": "2020-07-03T06:49:04Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "diffHunk": "@@ -437,9 +436,53 @@ class EmbeddedObjectsTest {\n     }\n \n     @Test\n-    @Ignore(\"Add in another PR\")\n-    fun createObjectFromJson() {\n-        TODO(\"Placeholder for all tests regarding importing from JSON\")\n+    fun createEmbeddedObjectFromJson() {\n+        realm.executeTransaction { realm ->\n+            realm.createObjectFromJson(EmbeddedCircularParent::class.java, \"\"\"\n+                        { \n+                            \"id\": \"uuid\", \n+                            \"singleChild\": { \n+                                \"id\" : \"childId\", \n+                                \"singleChild\" : { \n+                                    \"id\": \"embeddedChildId\" \n+                                }\n+                            }\n+                        }\n+                \"\"\")\n+        }\n+        val circularParent = realm.where(EmbeddedCircularParent::class.java).findFirst()!!\n+        assertEquals(\"childId\", circularParent.singleChild?.id)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52299681ed25ba0423f8dd1cea9436adad6ac25c"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTM1MjU0OnYy", "diffSide": "RIGHT", "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNzo0NzoyOFrOGsnEzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNzo0NzoyOFrOGsnEzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQzMDczNA==", "bodyText": "Would Importing embedded classes from JSON without a parent is now allowed be more clear? orphaned feels like it had a parent once, which it didn't in this case.", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449430734", "createdAt": "2020-07-03T07:47:28Z", "author": {"login": "cmelchior"}, "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.kt", "diffHunk": "@@ -423,7 +423,11 @@ class RealmProxyMediatorGenerator(private val processingEnvironment: ProcessingE\n                     Arrays.asList(\"JSONException\")\n             )\n                 emitMediatorShortCircuitSwitch(writer, emitStatement = { i: Int ->\n-                    emitStatement(\"return clazz.cast(%s.createOrUpdateUsingJsonObject(realm, json, update))\", qualifiedProxyClasses[i])\n+                    if (!embeddedClass[i]) {\n+                        emitStatement(\"return clazz.cast(%s.createOrUpdateUsingJsonObject(realm, json, update))\", qualifiedProxyClasses[i])\n+                    } else {\n+                        emitStatement(\"throw new IllegalArgumentException(\\\"Cannot import orphaned embedded class from json\\\")\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52299681ed25ba0423f8dd1cea9436adad6ac25c"}, "originalPosition": 8}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 439, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}