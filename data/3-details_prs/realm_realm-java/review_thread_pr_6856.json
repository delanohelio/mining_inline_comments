{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4NDc1NTQ3", "number": 6856, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNToyOTo0OFrOD86wug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyODowMVrOD_Th0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjAzODk4OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNToyOTo0OFrOGWJrCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjo0Njo1NlrOGXSD3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MDMyOA==", "bodyText": "there is an extension function available for this app.registerAndLoginUser(...)", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r425880328", "createdAt": "2020-05-15T15:29:48Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2NjMzNA==", "bodyText": "Done", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r427066334", "createdAt": "2020-05-19T06:46:56Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MDMyOA=="}, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjA0NDM0OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozMToyM1rOGWJukA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjo0Nzo0NVrOGXSFIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MTIzMg==", "bodyText": "It should not be possible to create SyncSessions from the public API.... you need to either fetch it using :\nrealm.syncSession // Kotlin extension\napp.sync.getSession(syncConfig) // Java API\n\nBoth require opening a Realm.\nBut maybe we did this here and in other tests because it is a lot easier.", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r425881232", "createdAt": "2020-05-15T15:31:23Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2NjY1OA==", "bodyText": "I updated all session to use this approach.", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r427066658", "createdAt": "2020-05-19T06:47:45Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MTIzMg=="}, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjA0NjkyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozMjoxMFrOGWJwOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjo1OTo1OFrOGXSaWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MTY1Ng==", "bodyText": "getOrCreateSession is discouraged from the public API.... I think it is mostly public right now because we haven't found a way to hide it.", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r425881656", "createdAt": "2020-05-15T15:32:10Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+        Assert.assertEquals(user, session.user)\n+        Assert.assertEquals(configuration, session.configuration)\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MjA4OA==", "bodyText": "I updated to use the realm.syncSession instead, but included a smoke test to ensure that getOrCreateSession actually returns a session.", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r427072088", "createdAt": "2020-05-19T06:59:58Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+        Assert.assertEquals(user, session.user)\n+        Assert.assertEquals(configuration, session.configuration)\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MTY1Ng=="}, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjA0NzkxOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozMjoyNlrOGWJw2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjo0Nzo1N1rOGXSFgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MTgxNw==", "bodyText": "Convert all of these to use static imports", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r425881817", "createdAt": "2020-05-15T15:32:26Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2Njc1Mg==", "bodyText": "Done", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r427066752", "createdAt": "2020-05-19T06:47:57Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MTgxNw=="}, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjA0OTU2OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozMjo1NFrOGWJx7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjo0ODo0MFrOGXSGuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MjA5Mw==", "bodyText": "realm.use ?", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r425882093", "createdAt": "2020-05-15T15:32:54Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+        Assert.assertEquals(user, session.user)\n+        Assert.assertEquals(configuration, session.configuration)\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        val realm = Realm.getInstance(configuration)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2NzA2NQ==", "bodyText": "Migrated all of these to use", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r427067065", "createdAt": "2020-05-19T06:48:40Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+        Assert.assertEquals(user, session.user)\n+        Assert.assertEquals(configuration, session.configuration)\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        val realm = Realm.getInstance(configuration)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MjA5Mw=="}, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjA1MTkzOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozMzozNFrOGWJzeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjo0OToyN1rOGXSIAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MjQ4OA==", "bodyText": "I suspect all of these ClientReset tests needs to be ignored for now, but a pleasant surprise if not.", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r425882488", "createdAt": "2020-05-15T15:33:34Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+        Assert.assertEquals(user, session.user)\n+        Assert.assertEquals(configuration, session.configuration)\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        val realm = Realm.getInstance(configuration)\n+        val session = app.sync.getOrCreateSession(configuration)\n+        val listeners = arrayOf(\n+                null,\n+                ProgressListener { progress: Progress? -> },\n+                ProgressListener { progress: Progress? -> }\n+        )\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+        // Check that remove works unconditionally for all input\n+        for (listener in listeners) {\n+            session.removeProgressListener(TestHelper.allowNull(listener))\n+        }\n+        realm.close()\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2NzM5Mg==", "bodyText": "Seems to work.", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r427067392", "createdAt": "2020-05-19T06:49:27Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+        Assert.assertEquals(user, session.user)\n+        Assert.assertEquals(configuration, session.configuration)\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        val realm = Realm.getInstance(configuration)\n+        val session = app.sync.getOrCreateSession(configuration)\n+        val listeners = arrayOf(\n+                null,\n+                ProgressListener { progress: Progress? -> },\n+                ProgressListener { progress: Progress? -> }\n+        )\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+        // Check that remove works unconditionally for all input\n+        for (listener in listeners) {\n+            session.removeProgressListener(TestHelper.allowNull(listener))\n+        }\n+        realm.close()\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MjQ4OA=="}, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjA1NjUwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozNDo1M1rOGWJ2cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjo1MTo0MVrOGXSLtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MzI1MQ==", "bodyText": "IMO tests should use !! instead of ? as we are otherwise hiding errors", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r425883251", "createdAt": "2020-05-15T15:34:53Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+        Assert.assertEquals(user, session.user)\n+        Assert.assertEquals(configuration, session.configuration)\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        val realm = Realm.getInstance(configuration)\n+        val session = app.sync.getOrCreateSession(configuration)\n+        val listeners = arrayOf(\n+                null,\n+                ProgressListener { progress: Progress? -> },\n+                ProgressListener { progress: Progress? -> }\n+        )\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+        // Check that remove works unconditionally for all input\n+        for (listener in listeners) {\n+            session.removeProgressListener(TestHelper.allowNull(listener))\n+        }\n+        realm.close()\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    Assert.assertEquals(filePathFromError, filePathFromConfig)\n+                    Assert.assertFalse(handler.backupFile.exists())\n+                    Assert.assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        val syncService = user.app.sync\n+        syncService.simulateClientReset(syncService.getSession(config))\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        Assert.fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    Assert.assertNotNull(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    Assert.assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    val backupRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealm.isEmpty)\n+                    Assert.assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                    backupRealm.where(StringOnly::class.java).findAll().first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.chars)\n+                    } ?: fail()\n+                    backupRealm.close()\n+\n+                    // opening a Dynamic Realm should also work\n+                    val dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration)\n+                    dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                    val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                    Assert.assertEquals(1, all.size.toLong())\n+                    all.first()?.let { first ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2ODM0MA==", "bodyText": "\ud83d\udc4d  I was bit too eager in avoid it. I already fixed it locally as the assert could then also be a one liner.", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r427068340", "createdAt": "2020-05-19T06:51:41Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+        Assert.assertEquals(user, session.user)\n+        Assert.assertEquals(configuration, session.configuration)\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        val realm = Realm.getInstance(configuration)\n+        val session = app.sync.getOrCreateSession(configuration)\n+        val listeners = arrayOf(\n+                null,\n+                ProgressListener { progress: Progress? -> },\n+                ProgressListener { progress: Progress? -> }\n+        )\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+        // Check that remove works unconditionally for all input\n+        for (listener in listeners) {\n+            session.removeProgressListener(TestHelper.allowNull(listener))\n+        }\n+        realm.close()\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    Assert.assertEquals(filePathFromError, filePathFromConfig)\n+                    Assert.assertFalse(handler.backupFile.exists())\n+                    Assert.assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        val syncService = user.app.sync\n+        syncService.simulateClientReset(syncService.getSession(config))\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        Assert.fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    Assert.assertNotNull(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    Assert.assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    val backupRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealm.isEmpty)\n+                    Assert.assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                    backupRealm.where(StringOnly::class.java).findAll().first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.chars)\n+                    } ?: fail()\n+                    backupRealm.close()\n+\n+                    // opening a Dynamic Realm should also work\n+                    val dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration)\n+                    dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                    val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                    Assert.assertEquals(1, all.size.toLong())\n+                    all.first()?.let { first ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MzI1MQ=="}, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjA1NzI0OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozNTowNlrOGWJ29Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozNTowNlrOGWJ29Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MzM4MQ==", "bodyText": "Same", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r425883381", "createdAt": "2020-05-15T15:35:06Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+        Assert.assertEquals(user, session.user)\n+        Assert.assertEquals(configuration, session.configuration)\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        val realm = Realm.getInstance(configuration)\n+        val session = app.sync.getOrCreateSession(configuration)\n+        val listeners = arrayOf(\n+                null,\n+                ProgressListener { progress: Progress? -> },\n+                ProgressListener { progress: Progress? -> }\n+        )\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+        // Check that remove works unconditionally for all input\n+        for (listener in listeners) {\n+            session.removeProgressListener(TestHelper.allowNull(listener))\n+        }\n+        realm.close()\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    Assert.assertEquals(filePathFromError, filePathFromConfig)\n+                    Assert.assertFalse(handler.backupFile.exists())\n+                    Assert.assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        val syncService = user.app.sync\n+        syncService.simulateClientReset(syncService.getSession(config))\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        Assert.fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    Assert.assertNotNull(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    Assert.assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    val backupRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealm.isEmpty)\n+                    Assert.assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                    backupRealm.where(StringOnly::class.java).findAll().first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.chars)\n+                    } ?: fail()\n+                    backupRealm.close()\n+\n+                    // opening a Dynamic Realm should also work\n+                    val dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration)\n+                    dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                    val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                    Assert.assertEquals(1, all.size.toLong())\n+                    all.first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.getString(StringOnly.FIELD_CHARS))\n+                    } ?: fail()\n+                    dynamicRealm.close()\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    try {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        Assert.fail(\"Expected to throw a Migration required\")\n+                    } catch (expected: RealmMigrationNeededException) {\n+                    }\n+\n+                    // opening a DynamicRealm will work though\n+                    val dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration)\n+                    dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                    val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                    Assert.assertEquals(1, all.size.toLong())\n+                    all.first()?.let { first ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 272}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjA2MTMzOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozNjowN1rOGWJ5jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjo1MjowMlrOGXSMTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NDA0NA==", "bodyText": "No need for these annotations", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r425884044", "createdAt": "2020-05-15T15:36:07Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+        Assert.assertEquals(user, session.user)\n+        Assert.assertEquals(configuration, session.configuration)\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        val realm = Realm.getInstance(configuration)\n+        val session = app.sync.getOrCreateSession(configuration)\n+        val listeners = arrayOf(\n+                null,\n+                ProgressListener { progress: Progress? -> },\n+                ProgressListener { progress: Progress? -> }\n+        )\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+        // Check that remove works unconditionally for all input\n+        for (listener in listeners) {\n+            session.removeProgressListener(TestHelper.allowNull(listener))\n+        }\n+        realm.close()\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    Assert.assertEquals(filePathFromError, filePathFromConfig)\n+                    Assert.assertFalse(handler.backupFile.exists())\n+                    Assert.assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        val syncService = user.app.sync\n+        syncService.simulateClientReset(syncService.getSession(config))\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        Assert.fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    Assert.assertNotNull(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    Assert.assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    val backupRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealm.isEmpty)\n+                    Assert.assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                    backupRealm.where(StringOnly::class.java).findAll().first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.chars)\n+                    } ?: fail()\n+                    backupRealm.close()\n+\n+                    // opening a Dynamic Realm should also work\n+                    val dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration)\n+                    dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                    val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                    Assert.assertEquals(1, all.size.toLong())\n+                    all.first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.getString(StringOnly.FIELD_CHARS))\n+                    } ?: fail()\n+                    dynamicRealm.close()\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    try {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        Assert.fail(\"Expected to throw a Migration required\")\n+                    } catch (expected: RealmMigrationNeededException) {\n+                    }\n+\n+                    // opening a DynamicRealm will work though\n+                    val dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration)\n+                    dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                    val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                    Assert.assertEquals(1, all.size.toLong())\n+                    all.first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.getString(StringOnly.FIELD_CHARS))\n+                    } ?: fail()\n+                    // make sure we can't write to it (read-only Realm)\n+                    try {\n+                        dynamicRealm.beginTransaction()\n+                        Assert.fail(\"Can't perform transactions on read-only Realms\")\n+                    } catch (expected: IllegalStateException) {\n+                    }\n+                    dynamicRealm.close()\n+                    try {\n+                        SyncConfiguration.forRecovery(backupFile, null, StringOnly::class.java)\n+                        Assert.fail(\"Expected to throw java.lang.Class is not a RealmModule\")\n+                    } catch (expected: IllegalArgumentException) {\n+                    }\n+\n+                    // specifying the module will allow to open the typed Realm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, StringOnlyModule())\n+                    val backupRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealm.isEmpty)\n+                    Assert.assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                    val allSorted = backupRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    } ?: fail()\n+                    backupRealm.close()\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.\n+    @Test\n+    fun errorHandler_useClientResetEncrypted() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val randomKey = TestHelper.getRandomKey()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .encryptionKey(randomKey)\n+                .modules(StringOnlyModule())\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+                    var backupRealmConfiguration = handler.backupRealmConfiguration\n+\n+                    // can open encrypted backup Realm\n+                    var backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                    var allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    } ?: fail()\n+                    backupEncryptedRealm.close()\n+                    val backupFile = handler.backupFile.absolutePath\n+                    // build a conf to open a DynamicRealm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, StringOnlyModule())\n+                    backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                    allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    }\n+                    backupEncryptedRealm.close()\n+\n+                    // using wrong key throw\n+                    try {\n+                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), StringOnlyModule()))\n+                        Assert.fail(\"Expected to throw when using wrong encryption key\")\n+                    } catch (expected: RealmFileException) {\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    @Throws(InterruptedException::class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 373}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkzMjY0NA==", "bodyText": "These as in:\n'both the @Throws and @UiThreadTest'\nor as in\n'all the @Throws in the class'\n(...or both).", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r425932644", "createdAt": "2020-05-15T17:01:36Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+        Assert.assertEquals(user, session.user)\n+        Assert.assertEquals(configuration, session.configuration)\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        val realm = Realm.getInstance(configuration)\n+        val session = app.sync.getOrCreateSession(configuration)\n+        val listeners = arrayOf(\n+                null,\n+                ProgressListener { progress: Progress? -> },\n+                ProgressListener { progress: Progress? -> }\n+        )\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+        // Check that remove works unconditionally for all input\n+        for (listener in listeners) {\n+            session.removeProgressListener(TestHelper.allowNull(listener))\n+        }\n+        realm.close()\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    Assert.assertEquals(filePathFromError, filePathFromConfig)\n+                    Assert.assertFalse(handler.backupFile.exists())\n+                    Assert.assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        val syncService = user.app.sync\n+        syncService.simulateClientReset(syncService.getSession(config))\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        Assert.fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    Assert.assertNotNull(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    Assert.assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    val backupRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealm.isEmpty)\n+                    Assert.assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                    backupRealm.where(StringOnly::class.java).findAll().first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.chars)\n+                    } ?: fail()\n+                    backupRealm.close()\n+\n+                    // opening a Dynamic Realm should also work\n+                    val dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration)\n+                    dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                    val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                    Assert.assertEquals(1, all.size.toLong())\n+                    all.first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.getString(StringOnly.FIELD_CHARS))\n+                    } ?: fail()\n+                    dynamicRealm.close()\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    try {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        Assert.fail(\"Expected to throw a Migration required\")\n+                    } catch (expected: RealmMigrationNeededException) {\n+                    }\n+\n+                    // opening a DynamicRealm will work though\n+                    val dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration)\n+                    dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                    val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                    Assert.assertEquals(1, all.size.toLong())\n+                    all.first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.getString(StringOnly.FIELD_CHARS))\n+                    } ?: fail()\n+                    // make sure we can't write to it (read-only Realm)\n+                    try {\n+                        dynamicRealm.beginTransaction()\n+                        Assert.fail(\"Can't perform transactions on read-only Realms\")\n+                    } catch (expected: IllegalStateException) {\n+                    }\n+                    dynamicRealm.close()\n+                    try {\n+                        SyncConfiguration.forRecovery(backupFile, null, StringOnly::class.java)\n+                        Assert.fail(\"Expected to throw java.lang.Class is not a RealmModule\")\n+                    } catch (expected: IllegalArgumentException) {\n+                    }\n+\n+                    // specifying the module will allow to open the typed Realm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, StringOnlyModule())\n+                    val backupRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealm.isEmpty)\n+                    Assert.assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                    val allSorted = backupRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    } ?: fail()\n+                    backupRealm.close()\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.\n+    @Test\n+    fun errorHandler_useClientResetEncrypted() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val randomKey = TestHelper.getRandomKey()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .encryptionKey(randomKey)\n+                .modules(StringOnlyModule())\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+                    var backupRealmConfiguration = handler.backupRealmConfiguration\n+\n+                    // can open encrypted backup Realm\n+                    var backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                    var allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    } ?: fail()\n+                    backupEncryptedRealm.close()\n+                    val backupFile = handler.backupFile.absolutePath\n+                    // build a conf to open a DynamicRealm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, StringOnlyModule())\n+                    backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                    allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    }\n+                    backupEncryptedRealm.close()\n+\n+                    // using wrong key throw\n+                    try {\n+                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), StringOnlyModule()))\n+                        Assert.fail(\"Expected to throw when using wrong encryption key\")\n+                    } catch (expected: RealmFileException) {\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    @Throws(InterruptedException::class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NDA0NA=="}, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 373}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2ODQ5Mw==", "bodyText": "Removed all the @Throws annotations", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r427068493", "createdAt": "2020-05-19T06:52:02Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+        Assert.assertEquals(user, session.user)\n+        Assert.assertEquals(configuration, session.configuration)\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        val realm = Realm.getInstance(configuration)\n+        val session = app.sync.getOrCreateSession(configuration)\n+        val listeners = arrayOf(\n+                null,\n+                ProgressListener { progress: Progress? -> },\n+                ProgressListener { progress: Progress? -> }\n+        )\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+        // Check that remove works unconditionally for all input\n+        for (listener in listeners) {\n+            session.removeProgressListener(TestHelper.allowNull(listener))\n+        }\n+        realm.close()\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    Assert.assertEquals(filePathFromError, filePathFromConfig)\n+                    Assert.assertFalse(handler.backupFile.exists())\n+                    Assert.assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        val syncService = user.app.sync\n+        syncService.simulateClientReset(syncService.getSession(config))\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        Assert.fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    Assert.assertNotNull(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    Assert.assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    val backupRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealm.isEmpty)\n+                    Assert.assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                    backupRealm.where(StringOnly::class.java).findAll().first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.chars)\n+                    } ?: fail()\n+                    backupRealm.close()\n+\n+                    // opening a Dynamic Realm should also work\n+                    val dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration)\n+                    dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                    val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                    Assert.assertEquals(1, all.size.toLong())\n+                    all.first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.getString(StringOnly.FIELD_CHARS))\n+                    } ?: fail()\n+                    dynamicRealm.close()\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    try {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        Assert.fail(\"Expected to throw a Migration required\")\n+                    } catch (expected: RealmMigrationNeededException) {\n+                    }\n+\n+                    // opening a DynamicRealm will work though\n+                    val dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration)\n+                    dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                    val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                    Assert.assertEquals(1, all.size.toLong())\n+                    all.first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.getString(StringOnly.FIELD_CHARS))\n+                    } ?: fail()\n+                    // make sure we can't write to it (read-only Realm)\n+                    try {\n+                        dynamicRealm.beginTransaction()\n+                        Assert.fail(\"Can't perform transactions on read-only Realms\")\n+                    } catch (expected: IllegalStateException) {\n+                    }\n+                    dynamicRealm.close()\n+                    try {\n+                        SyncConfiguration.forRecovery(backupFile, null, StringOnly::class.java)\n+                        Assert.fail(\"Expected to throw java.lang.Class is not a RealmModule\")\n+                    } catch (expected: IllegalArgumentException) {\n+                    }\n+\n+                    // specifying the module will allow to open the typed Realm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, StringOnlyModule())\n+                    val backupRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealm.isEmpty)\n+                    Assert.assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                    val allSorted = backupRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    } ?: fail()\n+                    backupRealm.close()\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.\n+    @Test\n+    fun errorHandler_useClientResetEncrypted() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val randomKey = TestHelper.getRandomKey()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .encryptionKey(randomKey)\n+                .modules(StringOnlyModule())\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+                    var backupRealmConfiguration = handler.backupRealmConfiguration\n+\n+                    // can open encrypted backup Realm\n+                    var backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                    var allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    } ?: fail()\n+                    backupEncryptedRealm.close()\n+                    val backupFile = handler.backupFile.absolutePath\n+                    // build a conf to open a DynamicRealm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, StringOnlyModule())\n+                    backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                    allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    }\n+                    backupEncryptedRealm.close()\n+\n+                    // using wrong key throw\n+                    try {\n+                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), StringOnlyModule()))\n+                        Assert.fail(\"Expected to throw when using wrong encryption key\")\n+                    } catch (expected: RealmFileException) {\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    @Throws(InterruptedException::class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NDA0NA=="}, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 373}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjA2MjI3OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozNjoyM1rOGWJ6LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozNjoyM1rOGWJ6LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NDIwNA==", "bodyText": "replace with realm.use", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r425884204", "createdAt": "2020-05-15T15:36:23Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+        Assert.assertEquals(user, session.user)\n+        Assert.assertEquals(configuration, session.configuration)\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        val realm = Realm.getInstance(configuration)\n+        val session = app.sync.getOrCreateSession(configuration)\n+        val listeners = arrayOf(\n+                null,\n+                ProgressListener { progress: Progress? -> },\n+                ProgressListener { progress: Progress? -> }\n+        )\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+        // Check that remove works unconditionally for all input\n+        for (listener in listeners) {\n+            session.removeProgressListener(TestHelper.allowNull(listener))\n+        }\n+        realm.close()\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    Assert.assertEquals(filePathFromError, filePathFromConfig)\n+                    Assert.assertFalse(handler.backupFile.exists())\n+                    Assert.assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        val syncService = user.app.sync\n+        syncService.simulateClientReset(syncService.getSession(config))\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        Assert.fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    Assert.assertNotNull(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    Assert.assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    val backupRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealm.isEmpty)\n+                    Assert.assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                    backupRealm.where(StringOnly::class.java).findAll().first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.chars)\n+                    } ?: fail()\n+                    backupRealm.close()\n+\n+                    // opening a Dynamic Realm should also work\n+                    val dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration)\n+                    dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                    val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                    Assert.assertEquals(1, all.size.toLong())\n+                    all.first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.getString(StringOnly.FIELD_CHARS))\n+                    } ?: fail()\n+                    dynamicRealm.close()\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    try {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        Assert.fail(\"Expected to throw a Migration required\")\n+                    } catch (expected: RealmMigrationNeededException) {\n+                    }\n+\n+                    // opening a DynamicRealm will work though\n+                    val dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration)\n+                    dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                    val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                    Assert.assertEquals(1, all.size.toLong())\n+                    all.first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.getString(StringOnly.FIELD_CHARS))\n+                    } ?: fail()\n+                    // make sure we can't write to it (read-only Realm)\n+                    try {\n+                        dynamicRealm.beginTransaction()\n+                        Assert.fail(\"Can't perform transactions on read-only Realms\")\n+                    } catch (expected: IllegalStateException) {\n+                    }\n+                    dynamicRealm.close()\n+                    try {\n+                        SyncConfiguration.forRecovery(backupFile, null, StringOnly::class.java)\n+                        Assert.fail(\"Expected to throw java.lang.Class is not a RealmModule\")\n+                    } catch (expected: IllegalArgumentException) {\n+                    }\n+\n+                    // specifying the module will allow to open the typed Realm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, StringOnlyModule())\n+                    val backupRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealm.isEmpty)\n+                    Assert.assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                    val allSorted = backupRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    } ?: fail()\n+                    backupRealm.close()\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.\n+    @Test\n+    fun errorHandler_useClientResetEncrypted() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val randomKey = TestHelper.getRandomKey()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .encryptionKey(randomKey)\n+                .modules(StringOnlyModule())\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+                    var backupRealmConfiguration = handler.backupRealmConfiguration\n+\n+                    // can open encrypted backup Realm\n+                    var backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                    var allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    } ?: fail()\n+                    backupEncryptedRealm.close()\n+                    val backupFile = handler.backupFile.absolutePath\n+                    // build a conf to open a DynamicRealm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, StringOnlyModule())\n+                    backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                    allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    }\n+                    backupEncryptedRealm.close()\n+\n+                    // using wrong key throw\n+                    try {\n+                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), StringOnlyModule()))\n+                        Assert.fail(\"Expected to throw when using wrong encryption key\")\n+                    } catch (expected: RealmFileException) {\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    @Throws(InterruptedException::class)\n+    fun uploadAllLocalChanges_throwsOnUiThread() {\n+        val realm = Realm.getInstance(configuration)\n+        try {\n+            app.sync.getOrCreateSession(configuration).uploadAllLocalChanges()\n+            Assert.fail(\"Should throw an IllegalStateException on Ui Thread\")\n+        } catch (ignored: IllegalStateException) {\n+        } finally {\n+            realm.close()\n+        }\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    @Throws(InterruptedException::class)\n+    fun uploadAllLocalChanges_withTimeout_throwsOnUiThread() {\n+        val realm = Realm.getInstance(configuration)\n+        try {\n+            app.sync.getOrCreateSession(configuration).uploadAllLocalChanges(30, TimeUnit.SECONDS)\n+            Assert.fail(\"Should throw an IllegalStateException on Ui Thread\")\n+        } catch (ignored: IllegalStateException) {\n+        } finally {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 394}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjA2MjgwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozNjozNVrOGWJ6iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjo1MjoxM1rOGXSMmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NDI5Nw==", "bodyText": "replace with assertFailsWith", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r425884297", "createdAt": "2020-05-15T15:36:35Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+        Assert.assertEquals(user, session.user)\n+        Assert.assertEquals(configuration, session.configuration)\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        val realm = Realm.getInstance(configuration)\n+        val session = app.sync.getOrCreateSession(configuration)\n+        val listeners = arrayOf(\n+                null,\n+                ProgressListener { progress: Progress? -> },\n+                ProgressListener { progress: Progress? -> }\n+        )\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+        // Check that remove works unconditionally for all input\n+        for (listener in listeners) {\n+            session.removeProgressListener(TestHelper.allowNull(listener))\n+        }\n+        realm.close()\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    Assert.assertEquals(filePathFromError, filePathFromConfig)\n+                    Assert.assertFalse(handler.backupFile.exists())\n+                    Assert.assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        val syncService = user.app.sync\n+        syncService.simulateClientReset(syncService.getSession(config))\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        Assert.fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    Assert.assertNotNull(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    Assert.assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    val backupRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealm.isEmpty)\n+                    Assert.assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                    backupRealm.where(StringOnly::class.java).findAll().first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.chars)\n+                    } ?: fail()\n+                    backupRealm.close()\n+\n+                    // opening a Dynamic Realm should also work\n+                    val dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration)\n+                    dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                    val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                    Assert.assertEquals(1, all.size.toLong())\n+                    all.first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.getString(StringOnly.FIELD_CHARS))\n+                    } ?: fail()\n+                    dynamicRealm.close()\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    try {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        Assert.fail(\"Expected to throw a Migration required\")\n+                    } catch (expected: RealmMigrationNeededException) {\n+                    }\n+\n+                    // opening a DynamicRealm will work though\n+                    val dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration)\n+                    dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                    val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                    Assert.assertEquals(1, all.size.toLong())\n+                    all.first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.getString(StringOnly.FIELD_CHARS))\n+                    } ?: fail()\n+                    // make sure we can't write to it (read-only Realm)\n+                    try {\n+                        dynamicRealm.beginTransaction()\n+                        Assert.fail(\"Can't perform transactions on read-only Realms\")\n+                    } catch (expected: IllegalStateException) {\n+                    }\n+                    dynamicRealm.close()\n+                    try {\n+                        SyncConfiguration.forRecovery(backupFile, null, StringOnly::class.java)\n+                        Assert.fail(\"Expected to throw java.lang.Class is not a RealmModule\")\n+                    } catch (expected: IllegalArgumentException) {\n+                    }\n+\n+                    // specifying the module will allow to open the typed Realm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, StringOnlyModule())\n+                    val backupRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealm.isEmpty)\n+                    Assert.assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                    val allSorted = backupRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    } ?: fail()\n+                    backupRealm.close()\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.\n+    @Test\n+    fun errorHandler_useClientResetEncrypted() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val randomKey = TestHelper.getRandomKey()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .encryptionKey(randomKey)\n+                .modules(StringOnlyModule())\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+                    var backupRealmConfiguration = handler.backupRealmConfiguration\n+\n+                    // can open encrypted backup Realm\n+                    var backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                    var allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    } ?: fail()\n+                    backupEncryptedRealm.close()\n+                    val backupFile = handler.backupFile.absolutePath\n+                    // build a conf to open a DynamicRealm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, StringOnlyModule())\n+                    backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                    allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    }\n+                    backupEncryptedRealm.close()\n+\n+                    // using wrong key throw\n+                    try {\n+                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), StringOnlyModule()))\n+                        Assert.fail(\"Expected to throw when using wrong encryption key\")\n+                    } catch (expected: RealmFileException) {\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    @Throws(InterruptedException::class)\n+    fun uploadAllLocalChanges_throwsOnUiThread() {\n+        val realm = Realm.getInstance(configuration)\n+        try {\n+            app.sync.getOrCreateSession(configuration).uploadAllLocalChanges()\n+            Assert.fail(\"Should throw an IllegalStateException on Ui Thread\")\n+        } catch (ignored: IllegalStateException) {\n+        } finally {\n+            realm.close()\n+        }\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    @Throws(InterruptedException::class)\n+    fun uploadAllLocalChanges_withTimeout_throwsOnUiThread() {\n+        val realm = Realm.getInstance(configuration)\n+        try {\n+            app.sync.getOrCreateSession(configuration).uploadAllLocalChanges(30, TimeUnit.SECONDS)\n+            Assert.fail(\"Should throw an IllegalStateException on Ui Thread\")\n+        } catch (ignored: IllegalStateException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 393}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2ODU2OA==", "bodyText": "Done", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r427068568", "createdAt": "2020-05-19T06:52:13Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+import kotlin.test.fail\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = createNewUser(app)\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        val session = SyncSession(configuration)\n+        Assert.assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+        Assert.assertEquals(user, session.user)\n+        Assert.assertEquals(configuration, session.configuration)\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        val session = app.sync.getOrCreateSession(configuration)\n+        try {\n+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            Assert.fail()\n+        } catch (ignored: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        val realm = Realm.getInstance(configuration)\n+        val session = app.sync.getOrCreateSession(configuration)\n+        val listeners = arrayOf(\n+                null,\n+                ProgressListener { progress: Progress? -> },\n+                ProgressListener { progress: Progress? -> }\n+        )\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+        // Check that remove works unconditionally for all input\n+        for (listener in listeners) {\n+            session.removeProgressListener(TestHelper.allowNull(listener))\n+        }\n+        realm.close()\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    Assert.assertEquals(filePathFromError, filePathFromConfig)\n+                    Assert.assertFalse(handler.backupFile.exists())\n+                    Assert.assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        val syncService = user.app.sync\n+        syncService.simulateClientReset(syncService.getSession(config))\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        Assert.fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    Assert.assertNotNull(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    Assert.assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    val backupRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealm.isEmpty)\n+                    Assert.assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                    backupRealm.where(StringOnly::class.java).findAll().first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.chars)\n+                    } ?: fail()\n+                    backupRealm.close()\n+\n+                    // opening a Dynamic Realm should also work\n+                    val dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration)\n+                    dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                    val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                    Assert.assertEquals(1, all.size.toLong())\n+                    all.first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.getString(StringOnly.FIELD_CHARS))\n+                    } ?: fail()\n+                    dynamicRealm.close()\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    Assert.assertFalse(handler.originalFile.exists())\n+                    Assert.assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    try {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        Assert.fail(\"Expected to throw a Migration required\")\n+                    } catch (expected: RealmMigrationNeededException) {\n+                    }\n+\n+                    // opening a DynamicRealm will work though\n+                    val dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration)\n+                    dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                    val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                    Assert.assertEquals(1, all.size.toLong())\n+                    all.first()?.let { first ->\n+                        Assert.assertEquals(\"Foo\", first.getString(StringOnly.FIELD_CHARS))\n+                    } ?: fail()\n+                    // make sure we can't write to it (read-only Realm)\n+                    try {\n+                        dynamicRealm.beginTransaction()\n+                        Assert.fail(\"Can't perform transactions on read-only Realms\")\n+                    } catch (expected: IllegalStateException) {\n+                    }\n+                    dynamicRealm.close()\n+                    try {\n+                        SyncConfiguration.forRecovery(backupFile, null, StringOnly::class.java)\n+                        Assert.fail(\"Expected to throw java.lang.Class is not a RealmModule\")\n+                    } catch (expected: IllegalArgumentException) {\n+                    }\n+\n+                    // specifying the module will allow to open the typed Realm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, StringOnlyModule())\n+                    val backupRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertFalse(backupRealm.isEmpty)\n+                    Assert.assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                    val allSorted = backupRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    } ?: fail()\n+                    backupRealm.close()\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.\n+    @Test\n+    fun errorHandler_useClientResetEncrypted() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val randomKey = TestHelper.getRandomKey()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .encryptionKey(randomKey)\n+                .modules(StringOnlyModule())\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        Assert.fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+                    var backupRealmConfiguration = handler.backupRealmConfiguration\n+\n+                    // can open encrypted backup Realm\n+                    var backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                    var allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    } ?: fail()\n+                    backupEncryptedRealm.close()\n+                    val backupFile = handler.backupFile.absolutePath\n+                    // build a conf to open a DynamicRealm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, StringOnlyModule())\n+                    backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration)\n+                    Assert.assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                    allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                    allSorted[0]?.let { allSorted0 ->\n+                        Assert.assertEquals(\"Foo\", allSorted0.chars)\n+                    }\n+                    backupEncryptedRealm.close()\n+\n+                    // using wrong key throw\n+                    try {\n+                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), StringOnlyModule()))\n+                        Assert.fail(\"Expected to throw when using wrong encryption key\")\n+                    } catch (expected: RealmFileException) {\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.beginTransaction()\n+        realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        realm.commitTransaction()\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(app.sync.getSession(configuration))\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    @Throws(InterruptedException::class)\n+    fun uploadAllLocalChanges_throwsOnUiThread() {\n+        val realm = Realm.getInstance(configuration)\n+        try {\n+            app.sync.getOrCreateSession(configuration).uploadAllLocalChanges()\n+            Assert.fail(\"Should throw an IllegalStateException on Ui Thread\")\n+        } catch (ignored: IllegalStateException) {\n+        } finally {\n+            realm.close()\n+        }\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    @Throws(InterruptedException::class)\n+    fun uploadAllLocalChanges_withTimeout_throwsOnUiThread() {\n+        val realm = Realm.getInstance(configuration)\n+        try {\n+            app.sync.getOrCreateSession(configuration).uploadAllLocalChanges(30, TimeUnit.SECONDS)\n+            Assert.fail(\"Should throw an IllegalStateException on Ui Thread\")\n+        } catch (ignored: IllegalStateException) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NDI5Nw=="}, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 393}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjA2NDQ4OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/util/KotlinTestUtils.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozNzowNFrOGWJ7tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjo1ODoyN1rOGXSXoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NDU5OA==", "bodyText": "As discussed in Slack, we should probably see how far realm.use { .. } will get us", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r425884598", "createdAt": "2020-05-15T15:37:04Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/util/KotlinTestUtils.kt", "diffHunk": "@@ -29,3 +31,21 @@ inline fun <reified T> ErrorCollector.assertFailsWith(block : () -> Unit){\n         }\n     }\n }\n+\n+/**\n+ * A **resource container** to keep references for objects that should later be closed.\n+ */\n+class ResourceContainer : Closeable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MTM5Mw==", "bodyText": "use is useful where closing follows scope. But this was introduced to assist the tests where it does not follow scope. The specific problematic test are those where we need to close the Realm in a callback passed to the config. In some of the test we also asserts stuff after closing, so we cannot use the collecting mechanism on the test looper to just close them after completion.\nWe should consider always adding the Realm as an argument to the callback, so that it would be way easier to access and reuse the callbacks across multiple configs.\nAnother", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r427071393", "createdAt": "2020-05-19T06:58:27Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/util/KotlinTestUtils.kt", "diffHunk": "@@ -29,3 +31,21 @@ inline fun <reified T> ErrorCollector.assertFailsWith(block : () -> Unit){\n         }\n     }\n }\n+\n+/**\n+ * A **resource container** to keep references for objects that should later be closed.\n+ */\n+class ResourceContainer : Closeable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NDU5OA=="}, "originalCommit": {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NDQ1ODAzOnYy", "diffSide": "LEFT", "path": "realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODowMjo0N1rOGX_zJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwOTozMjowNlrOGZ7FGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgxNTcxNg==", "bodyText": "@cmelchior What should this test do? What is an invalid user, logged out maybe?\nFurther, in the current form it is nondeterministic, due to not awaiting connection state, etc.\nCould you sketch suggested test if it still makes sense", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r427815716", "createdAt": "2020-05-20T08:02:47Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java", "diffHunk": "@@ -1,583 +0,0 @@\n-/*\n- * Copyright 2016 Realm Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.realm;\n-\n-import androidx.test.annotation.UiThreadTest;\n-import androidx.test.ext.junit.runners.AndroidJUnit4;\n-\n-import org.hamcrest.CoreMatchers;\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Ignore;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import io.realm.entities.StringOnly;\n-import io.realm.exceptions.RealmFileException;\n-import io.realm.exceptions.RealmMigrationNeededException;\n-import io.realm.log.RealmLog;\n-import io.realm.entities.StringOnlyModule;\n-import io.realm.rule.RunInLooperThread;\n-import io.realm.rule.RunTestInLooperThread;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertThat;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-@RunWith(AndroidJUnit4.class)\n-public class SessionTests {\n-\n-    private SyncConfiguration configuration;\n-    private TestRealmApp app;\n-    private RealmUser user;\n-\n-    @Rule\n-    public final TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();\n-\n-    @Rule\n-    public final RunInLooperThread looperThread = new RunInLooperThread();\n-\n-    @Before\n-    public void setUp() {\n-        app = new TestRealmApp();\n-        user = SyncTestUtils.createTestUser(app);\n-        configuration = SyncConfiguration.defaultConfig(user, \"default\");\n-    }\n-\n-    @After\n-    public void tearDown() {\n-        if (app != null) {\n-            RealmAppExtKt.close(app);\n-        }\n-    }\n-\n-    @Test\n-    public void get_syncValues() {\n-        SyncSession session = new SyncSession(configuration);\n-        assertEquals(\"ws://127.0.0.1:9090/\", session.getServerUrl().toString());\n-        assertEquals(user, session.getUser());\n-        assertEquals(configuration, session.getConfiguration());\n-    }\n-\n-    @Test\n-    public void addDownloadProgressListener_nullThrows() {\n-        SyncSession session = app.getSync().getOrCreateSession(configuration);\n-        try {\n-            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, null);\n-            fail();\n-        } catch (IllegalArgumentException ignored) {\n-        }\n-    }\n-\n-    @Test\n-    public void addUploadProgressListener_nullThrows() {\n-        SyncSession session = app.getSync().getOrCreateSession(configuration);\n-        try {\n-            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, null);\n-            fail();\n-        } catch (IllegalArgumentException ignored) {\n-        }\n-    }\n-\n-    @Test\n-    public void removeProgressListener() {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getOrCreateSession(configuration);\n-        ProgressListener[] listeners = new ProgressListener[] {\n-                null,\n-                progress -> {\n-                    // Listener 1, not present\n-                },\n-                progress -> {\n-                    // Listener 2, present\n-                }\n-        };\n-        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, listeners[2]);\n-\n-        // Check that remove works unconditionally for all input\n-        for (ProgressListener listener : listeners) {\n-            session.removeProgressListener(listener);\n-        }\n-        realm.close();\n-    }\n-\n-    // Check that a Client Reset is correctly reported.\n-    @Test\n-    @RunTestInLooperThread\n-    @Ignore(\"FIXME: Figure out how to fix this\")\n-    public void errorHandler_clientResetReported() {\n-        RealmUser user = SyncTestUtils.createTestUser(app);\n-        String url = \"realm://objectserver.realm.io/default\";\n-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user)\n-                .clientResyncMode(ClientResyncMode.MANUAL)\n-                .errorHandler((session, error) -> {\n-                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\n-                        fail(\"Wrong error \" + error.toString());\n-                        return;\n-                    }\n-\n-                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;\n-                    String filePathFromError = handler.getOriginalFile().getAbsolutePath();\n-                    String filePathFromConfig = session.getConfiguration().getPath();\n-                    assertEquals(filePathFromError, filePathFromConfig);\n-                    assertFalse(handler.getBackupFile().exists());\n-                    assertTrue(handler.getOriginalFile().exists());\n-\n-                    looperThread.testComplete();\n-                })\n-                .build();\n-\n-        Realm realm = Realm.getInstance(config);\n-        looperThread.addTestRealm(realm);\n-\n-        // Trigger error\n-        RealmSync syncService = user.getApp().getSync();\n-        syncService.simulateClientReset(syncService.getSession((config)));\n-    }\n-\n-    // Check that we can manually execute the Client Reset.\n-    @Test\n-    @RunTestInLooperThread\n-    @Ignore(\"FIXME: Figure out how to fix this\")\n-    public void errorHandler_manualExecuteClientReset() {\n-        RealmUser user = SyncTestUtils.createTestUser(app);\n-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user)\n-                .clientResyncMode(ClientResyncMode.MANUAL)\n-                .errorHandler((session, error) -> {\n-                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\n-                        fail(\"Wrong error \" + error.toString());\n-                        return;\n-                    }\n-\n-                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;\n-                    try {\n-                        handler.executeClientReset();\n-                        fail(\"All Realms should be closed before executing Client Reset can be allowed\");\n-                    } catch(IllegalStateException ignored) {\n-                    }\n-\n-                    // Execute Client Reset\n-                    looperThread.closeTestRealms();\n-                    handler.executeClientReset();\n-\n-                    // Validate that files have been moved\n-                    assertFalse(handler.getOriginalFile().exists());\n-                    assertTrue(handler.getBackupFile().exists());\n-                    looperThread.testComplete();\n-                })\n-                .build();\n-\n-        Realm realm = Realm.getInstance(config);\n-        looperThread.addTestRealm(realm);\n-\n-        // Trigger error\n-        user.getApp().getSync().simulateClientReset(app.getSync().getSession(configuration));\n-    }\n-\n-    // Check that we can use the backup SyncConfiguration to open the Realm.\n-    @Test\n-    @RunTestInLooperThread\n-    @Ignore(\"FIXME: Figure out how to fix this\")\n-    public void errorHandler_useBackupSyncConfigurationForClientReset() {\n-        RealmUser user = SyncTestUtils.createTestUser(app);\n-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user)\n-                .clientResyncMode(ClientResyncMode.MANUAL)\n-                .schema(StringOnly.class)\n-                .errorHandler((session, error) -> {\n-                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\n-                        fail(\"Wrong error \" + error.toString());\n-                        return;\n-                    }\n-\n-                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;\n-                    // Execute Client Reset\n-                    looperThread.closeTestRealms();\n-                    handler.executeClientReset();\n-\n-                    // Validate that files have been moved\n-                    assertFalse(handler.getOriginalFile().exists());\n-                    assertTrue(handler.getBackupFile().exists());\n-\n-                    RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();\n-                    assertNotNull(backupRealmConfiguration);\n-                    assertFalse(backupRealmConfiguration.isSyncConfiguration());\n-                    assertTrue(backupRealmConfiguration.isRecoveryConfiguration());\n-\n-                    Realm backupRealm = Realm.getInstance(backupRealmConfiguration);\n-                    assertFalse(backupRealm.isEmpty());\n-                    assertEquals(1, backupRealm.where(StringOnly.class).count());\n-                    assertEquals(\"Foo\", backupRealm.where(StringOnly.class).findAll().first().getChars());\n-                    backupRealm.close();\n-\n-                    // opening a Dynamic Realm should also work\n-                    DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);\n-                    dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME);\n-                    RealmResults<DynamicRealmObject> all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();\n-                    assertEquals(1, all.size());\n-                    assertEquals(\"Foo\", all.first().getString(StringOnly.FIELD_CHARS));\n-                    dynamicRealm.close();\n-                    looperThread.testComplete();\n-                })\n-                .modules(new StringOnlyModule())\n-                .build();\n-\n-        Realm realm = Realm.getInstance(config);\n-        realm.beginTransaction();\n-        realm.createObject(StringOnly.class).setChars(\"Foo\");\n-        realm.commitTransaction();\n-\n-        looperThread.addTestRealm(realm);\n-\n-        // Trigger error\n-        user.getApp().getSync().simulateClientReset(app.getSync().getSession(configuration));\n-    }\n-\n-    // Check that we can open the backup file without using the provided SyncConfiguration,\n-    // this might be the case if the user decide to act upon the client reset later (providing s/he\n-    // persisted the location of the file)\n-    @Test\n-    @RunTestInLooperThread\n-    @Ignore(\"FIXME: Figure out how to fix this\")\n-    public void errorHandler_useBackupSyncConfigurationAfterClientReset() {\n-        RealmUser user = SyncTestUtils.createTestUser(app);\n-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user)\n-                .clientResyncMode(ClientResyncMode.MANUAL)\n-                .errorHandler((session, error) -> {\n-                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\n-                        fail(\"Wrong error \" + error.toString());\n-                        return;\n-                    }\n-\n-                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;\n-                    // Execute Client Reset\n-                    looperThread.closeTestRealms();\n-                    handler.executeClientReset();\n-\n-                    // Validate that files have been moved\n-                    assertFalse(handler.getOriginalFile().exists());\n-                    assertTrue(handler.getBackupFile().exists());\n-\n-                    String backupFile = handler.getBackupFile().getAbsolutePath();\n-\n-                    // this SyncConf doesn't specify any module, it will throw a migration required\n-                    // exception since the backup Realm contain only StringOnly table\n-                    RealmConfiguration backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile);\n-\n-                    try {\n-                        Realm.getInstance(backupRealmConfiguration);\n-                        fail(\"Expected to throw a Migration required\");\n-                    } catch (RealmMigrationNeededException expected) {\n-                    }\n-\n-                    // opening a DynamicRealm will work though\n-                    DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);\n-\n-                    dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME);\n-                    RealmResults<DynamicRealmObject> all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();\n-                    assertEquals(1, all.size());\n-                    assertEquals(\"Foo\", all.first().getString(StringOnly.FIELD_CHARS));\n-\n-                    // make sure we can't write to it (read-only Realm)\n-                    try {\n-                        dynamicRealm.beginTransaction();\n-                        fail(\"Can't perform transactions on read-only Realms\");\n-                    } catch (IllegalStateException expected) {\n-                    }\n-                    dynamicRealm.close();\n-\n-                    try {\n-                        SyncConfiguration.forRecovery(backupFile, null, StringOnly.class);\n-                        fail(\"Expected to throw java.lang.Class is not a RealmModule\");\n-                    } catch (IllegalArgumentException expected) {\n-                    }\n-\n-                    // specifying the module will allow to open the typed Realm\n-                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, new StringOnlyModule());\n-                    Realm backupRealm = Realm.getInstance(backupRealmConfiguration);\n-                    assertFalse(backupRealm.isEmpty());\n-                    assertEquals(1, backupRealm.where(StringOnly.class).count());\n-                    RealmResults<StringOnly> allSorted = backupRealm.where(StringOnly.class).findAll();\n-                    assertEquals(\"Foo\", allSorted.get(0).getChars());\n-                    backupRealm.close();\n-\n-                    looperThread.testComplete();\n-                })\n-                .modules(new StringOnlyModule())\n-                .build();\n-\n-        Realm realm = Realm.getInstance(config);\n-        realm.beginTransaction();\n-        realm.createObject(StringOnly.class).setChars(\"Foo\");\n-        realm.commitTransaction();\n-\n-        looperThread.addTestRealm(realm);\n-\n-        // Trigger error\n-        user.getApp().getSync().simulateClientReset(app.getSync().getSession(configuration));\n-    }\n-\n-    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.\n-    @Test\n-    @RunTestInLooperThread\n-    @Ignore(\"FIXME: Figure out how to fix this\")\n-    public void errorHandler_useClientResetEncrypted() {\n-        RealmUser user = SyncTestUtils.createTestUser(app);\n-        final byte[] randomKey = TestHelper.getRandomKey();\n-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user)\n-                .clientResyncMode(ClientResyncMode.MANUAL)\n-                .encryptionKey(randomKey)\n-                .modules(new StringOnlyModule())\n-                .errorHandler((session, error) -> {\n-                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\n-                        fail(\"Wrong error \" + error.toString());\n-                        return;\n-                    }\n-\n-                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;\n-                    // Execute Client Reset\n-                    looperThread.closeTestRealms();\n-                    handler.executeClientReset();\n-\n-                    RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();\n-\n-                    // can open encrypted backup Realm\n-                    Realm backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration);\n-                    assertEquals(1, backupEncryptedRealm.where(StringOnly.class).count());\n-                    RealmResults<StringOnly> allSorted = backupEncryptedRealm.where(StringOnly.class).findAll();\n-                    assertEquals(\"Foo\", allSorted.get(0).getChars());\n-                    backupEncryptedRealm.close();\n-\n-                    String backupFile = handler.getBackupFile().getAbsolutePath();\n-                    // build a conf to open a DynamicRealm\n-                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, new StringOnlyModule());\n-                    backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration);\n-                    assertEquals(1, backupEncryptedRealm.where(StringOnly.class).count());\n-                    allSorted = backupEncryptedRealm.where(StringOnly.class).findAll();\n-                    assertEquals(\"Foo\", allSorted.get(0).getChars());\n-                    backupEncryptedRealm.close();\n-\n-                    // using wrong key throw\n-                    try {\n-                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), new StringOnlyModule()));\n-                        fail(\"Expected to throw when using wrong encryption key\");\n-                    } catch (RealmFileException expected) {\n-                    }\n-\n-                    looperThread.testComplete();\n-                })\n-                .build();\n-\n-        Realm realm = Realm.getInstance(config);\n-        realm.beginTransaction();\n-        realm.createObject(StringOnly.class).setChars(\"Foo\");\n-        realm.commitTransaction();\n-\n-        looperThread.addTestRealm(realm);\n-\n-        // Trigger error\n-        user.getApp().getSync().simulateClientReset(app.getSync().getSession(configuration));\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void uploadAllLocalChanges_throwsOnUiThread() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        try {\n-            app.getSync().getOrCreateSession(configuration).uploadAllLocalChanges();\n-            fail(\"Should throw an IllegalStateException on Ui Thread\");\n-        } catch (IllegalStateException ignored) {\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void uploadAllLocalChanges_withTimeout_throwsOnUiThread() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        try {\n-            app.getSync().getOrCreateSession(configuration).uploadAllLocalChanges(30, TimeUnit.SECONDS);\n-            fail(\"Should throw an IllegalStateException on Ui Thread\");\n-        } catch (IllegalStateException ignored) {\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    public void uploadAllLocalChanges_withTimeout_invalidParametersThrows() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getOrCreateSession(configuration);\n-        try {\n-            try {\n-                session.uploadAllLocalChanges(-1, TimeUnit.SECONDS);\n-                fail();\n-            } catch (IllegalArgumentException ignored) {\n-            }\n-\n-            try {\n-                //noinspection ConstantConditions\n-                session.uploadAllLocalChanges(1, null);\n-                fail();\n-            } catch (IllegalArgumentException ignored) {\n-            }\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    public void uploadAllLocalChanges_returnFalseWhenTimedOut() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getSession(configuration);\n-        try {\n-            assertFalse(session.uploadAllLocalChanges(100, TimeUnit.MILLISECONDS));\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void downloadAllServerChanges_throwsOnUiThread() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        try {\n-            app.getSync().getSession(configuration).downloadAllServerChanges();\n-            fail(\"Should throw an IllegalStateException on Ui Thread\");\n-        } catch (IllegalStateException ignored) {\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void downloadAllServerChanges_withTimeout_throwsOnUiThread() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        try {\n-            app.getSync().getSession(configuration).downloadAllServerChanges(30, TimeUnit.SECONDS);\n-            fail(\"Should throw an IllegalStateException on Ui Thread\");\n-        } catch (IllegalStateException ignored) {\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-\n-    @Test\n-    public void downloadAllServerChanges_withTimeout_invalidParametersThrows() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getSession(configuration);\n-        try {\n-            try {\n-                session.downloadAllServerChanges(-1, TimeUnit.SECONDS);\n-                fail();\n-            } catch (IllegalArgumentException ignored) {\n-            }\n-\n-            try {\n-                //noinspection ConstantConditions\n-                session.downloadAllServerChanges(1, null);\n-                fail();\n-            } catch (IllegalArgumentException ignored) {\n-            }\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    public void downloadAllServerChanges_returnFalseWhenTimedOut() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getSession(configuration);\n-        try {\n-            assertFalse(session.downloadAllServerChanges(100, TimeUnit.MILLISECONDS));\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void unrecognizedErrorCode_errorHandler() {\n-        AtomicBoolean errorHandlerCalled = new AtomicBoolean(false);\n-        configuration = configFactory.createSyncConfigurationBuilder(user)\n-                .errorHandler((session, error) -> {\n-                    errorHandlerCalled.set(true);\n-                    assertEquals(ErrorCode.UNKNOWN, error.getErrorCode());\n-                    assertEquals(ErrorCode.Category.FATAL, error.getCategory());\n-\n-                })\n-                .build();\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getSession(configuration);\n-\n-        TestHelper.TestLogger testLogger = new TestHelper.TestLogger();\n-        RealmLog.add(testLogger);\n-\n-        session.notifySessionError(\"unknown\", 3, \"Unknown Error\");\n-        RealmLog.remove(testLogger);\n-\n-        assertTrue(errorHandlerCalled.get());\n-        assertEquals(\"Unknown error code: 'unknown:3'\", testLogger.message);\n-\n-        realm.close();\n-    }\n-\n-    @Test\n-    public void getSessionThrowsOnNonExistingSession() {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getSession(configuration);\n-        assertEquals(configuration, session.getConfiguration());\n-\n-        // Closing the Realm should remove the session\n-        realm.close();\n-        try {\n-            app.getSync().getSession(configuration);\n-            fail(\"getSession should throw an ISE\");\n-        } catch (IllegalStateException expected) {\n-            assertThat(expected.getMessage(), CoreMatchers.containsString(\n-                    \"No SyncSession found using the path : \"));\n-        }\n-    }\n-\n-    @Test\n-    public void isConnected_falseForInvalidUser() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e0bc286d66982b4f128fc0cd7502af41d12076a"}, "originalPosition": 566}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgzNTU0NA==", "bodyText": "Removed the test as we per discussions cannot create an invalid user here.", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r429835544", "createdAt": "2020-05-25T09:32:06Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java", "diffHunk": "@@ -1,583 +0,0 @@\n-/*\n- * Copyright 2016 Realm Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.realm;\n-\n-import androidx.test.annotation.UiThreadTest;\n-import androidx.test.ext.junit.runners.AndroidJUnit4;\n-\n-import org.hamcrest.CoreMatchers;\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Ignore;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import io.realm.entities.StringOnly;\n-import io.realm.exceptions.RealmFileException;\n-import io.realm.exceptions.RealmMigrationNeededException;\n-import io.realm.log.RealmLog;\n-import io.realm.entities.StringOnlyModule;\n-import io.realm.rule.RunInLooperThread;\n-import io.realm.rule.RunTestInLooperThread;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertThat;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-@RunWith(AndroidJUnit4.class)\n-public class SessionTests {\n-\n-    private SyncConfiguration configuration;\n-    private TestRealmApp app;\n-    private RealmUser user;\n-\n-    @Rule\n-    public final TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();\n-\n-    @Rule\n-    public final RunInLooperThread looperThread = new RunInLooperThread();\n-\n-    @Before\n-    public void setUp() {\n-        app = new TestRealmApp();\n-        user = SyncTestUtils.createTestUser(app);\n-        configuration = SyncConfiguration.defaultConfig(user, \"default\");\n-    }\n-\n-    @After\n-    public void tearDown() {\n-        if (app != null) {\n-            RealmAppExtKt.close(app);\n-        }\n-    }\n-\n-    @Test\n-    public void get_syncValues() {\n-        SyncSession session = new SyncSession(configuration);\n-        assertEquals(\"ws://127.0.0.1:9090/\", session.getServerUrl().toString());\n-        assertEquals(user, session.getUser());\n-        assertEquals(configuration, session.getConfiguration());\n-    }\n-\n-    @Test\n-    public void addDownloadProgressListener_nullThrows() {\n-        SyncSession session = app.getSync().getOrCreateSession(configuration);\n-        try {\n-            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, null);\n-            fail();\n-        } catch (IllegalArgumentException ignored) {\n-        }\n-    }\n-\n-    @Test\n-    public void addUploadProgressListener_nullThrows() {\n-        SyncSession session = app.getSync().getOrCreateSession(configuration);\n-        try {\n-            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, null);\n-            fail();\n-        } catch (IllegalArgumentException ignored) {\n-        }\n-    }\n-\n-    @Test\n-    public void removeProgressListener() {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getOrCreateSession(configuration);\n-        ProgressListener[] listeners = new ProgressListener[] {\n-                null,\n-                progress -> {\n-                    // Listener 1, not present\n-                },\n-                progress -> {\n-                    // Listener 2, present\n-                }\n-        };\n-        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, listeners[2]);\n-\n-        // Check that remove works unconditionally for all input\n-        for (ProgressListener listener : listeners) {\n-            session.removeProgressListener(listener);\n-        }\n-        realm.close();\n-    }\n-\n-    // Check that a Client Reset is correctly reported.\n-    @Test\n-    @RunTestInLooperThread\n-    @Ignore(\"FIXME: Figure out how to fix this\")\n-    public void errorHandler_clientResetReported() {\n-        RealmUser user = SyncTestUtils.createTestUser(app);\n-        String url = \"realm://objectserver.realm.io/default\";\n-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user)\n-                .clientResyncMode(ClientResyncMode.MANUAL)\n-                .errorHandler((session, error) -> {\n-                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\n-                        fail(\"Wrong error \" + error.toString());\n-                        return;\n-                    }\n-\n-                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;\n-                    String filePathFromError = handler.getOriginalFile().getAbsolutePath();\n-                    String filePathFromConfig = session.getConfiguration().getPath();\n-                    assertEquals(filePathFromError, filePathFromConfig);\n-                    assertFalse(handler.getBackupFile().exists());\n-                    assertTrue(handler.getOriginalFile().exists());\n-\n-                    looperThread.testComplete();\n-                })\n-                .build();\n-\n-        Realm realm = Realm.getInstance(config);\n-        looperThread.addTestRealm(realm);\n-\n-        // Trigger error\n-        RealmSync syncService = user.getApp().getSync();\n-        syncService.simulateClientReset(syncService.getSession((config)));\n-    }\n-\n-    // Check that we can manually execute the Client Reset.\n-    @Test\n-    @RunTestInLooperThread\n-    @Ignore(\"FIXME: Figure out how to fix this\")\n-    public void errorHandler_manualExecuteClientReset() {\n-        RealmUser user = SyncTestUtils.createTestUser(app);\n-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user)\n-                .clientResyncMode(ClientResyncMode.MANUAL)\n-                .errorHandler((session, error) -> {\n-                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\n-                        fail(\"Wrong error \" + error.toString());\n-                        return;\n-                    }\n-\n-                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;\n-                    try {\n-                        handler.executeClientReset();\n-                        fail(\"All Realms should be closed before executing Client Reset can be allowed\");\n-                    } catch(IllegalStateException ignored) {\n-                    }\n-\n-                    // Execute Client Reset\n-                    looperThread.closeTestRealms();\n-                    handler.executeClientReset();\n-\n-                    // Validate that files have been moved\n-                    assertFalse(handler.getOriginalFile().exists());\n-                    assertTrue(handler.getBackupFile().exists());\n-                    looperThread.testComplete();\n-                })\n-                .build();\n-\n-        Realm realm = Realm.getInstance(config);\n-        looperThread.addTestRealm(realm);\n-\n-        // Trigger error\n-        user.getApp().getSync().simulateClientReset(app.getSync().getSession(configuration));\n-    }\n-\n-    // Check that we can use the backup SyncConfiguration to open the Realm.\n-    @Test\n-    @RunTestInLooperThread\n-    @Ignore(\"FIXME: Figure out how to fix this\")\n-    public void errorHandler_useBackupSyncConfigurationForClientReset() {\n-        RealmUser user = SyncTestUtils.createTestUser(app);\n-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user)\n-                .clientResyncMode(ClientResyncMode.MANUAL)\n-                .schema(StringOnly.class)\n-                .errorHandler((session, error) -> {\n-                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\n-                        fail(\"Wrong error \" + error.toString());\n-                        return;\n-                    }\n-\n-                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;\n-                    // Execute Client Reset\n-                    looperThread.closeTestRealms();\n-                    handler.executeClientReset();\n-\n-                    // Validate that files have been moved\n-                    assertFalse(handler.getOriginalFile().exists());\n-                    assertTrue(handler.getBackupFile().exists());\n-\n-                    RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();\n-                    assertNotNull(backupRealmConfiguration);\n-                    assertFalse(backupRealmConfiguration.isSyncConfiguration());\n-                    assertTrue(backupRealmConfiguration.isRecoveryConfiguration());\n-\n-                    Realm backupRealm = Realm.getInstance(backupRealmConfiguration);\n-                    assertFalse(backupRealm.isEmpty());\n-                    assertEquals(1, backupRealm.where(StringOnly.class).count());\n-                    assertEquals(\"Foo\", backupRealm.where(StringOnly.class).findAll().first().getChars());\n-                    backupRealm.close();\n-\n-                    // opening a Dynamic Realm should also work\n-                    DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);\n-                    dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME);\n-                    RealmResults<DynamicRealmObject> all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();\n-                    assertEquals(1, all.size());\n-                    assertEquals(\"Foo\", all.first().getString(StringOnly.FIELD_CHARS));\n-                    dynamicRealm.close();\n-                    looperThread.testComplete();\n-                })\n-                .modules(new StringOnlyModule())\n-                .build();\n-\n-        Realm realm = Realm.getInstance(config);\n-        realm.beginTransaction();\n-        realm.createObject(StringOnly.class).setChars(\"Foo\");\n-        realm.commitTransaction();\n-\n-        looperThread.addTestRealm(realm);\n-\n-        // Trigger error\n-        user.getApp().getSync().simulateClientReset(app.getSync().getSession(configuration));\n-    }\n-\n-    // Check that we can open the backup file without using the provided SyncConfiguration,\n-    // this might be the case if the user decide to act upon the client reset later (providing s/he\n-    // persisted the location of the file)\n-    @Test\n-    @RunTestInLooperThread\n-    @Ignore(\"FIXME: Figure out how to fix this\")\n-    public void errorHandler_useBackupSyncConfigurationAfterClientReset() {\n-        RealmUser user = SyncTestUtils.createTestUser(app);\n-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user)\n-                .clientResyncMode(ClientResyncMode.MANUAL)\n-                .errorHandler((session, error) -> {\n-                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\n-                        fail(\"Wrong error \" + error.toString());\n-                        return;\n-                    }\n-\n-                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;\n-                    // Execute Client Reset\n-                    looperThread.closeTestRealms();\n-                    handler.executeClientReset();\n-\n-                    // Validate that files have been moved\n-                    assertFalse(handler.getOriginalFile().exists());\n-                    assertTrue(handler.getBackupFile().exists());\n-\n-                    String backupFile = handler.getBackupFile().getAbsolutePath();\n-\n-                    // this SyncConf doesn't specify any module, it will throw a migration required\n-                    // exception since the backup Realm contain only StringOnly table\n-                    RealmConfiguration backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile);\n-\n-                    try {\n-                        Realm.getInstance(backupRealmConfiguration);\n-                        fail(\"Expected to throw a Migration required\");\n-                    } catch (RealmMigrationNeededException expected) {\n-                    }\n-\n-                    // opening a DynamicRealm will work though\n-                    DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);\n-\n-                    dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME);\n-                    RealmResults<DynamicRealmObject> all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();\n-                    assertEquals(1, all.size());\n-                    assertEquals(\"Foo\", all.first().getString(StringOnly.FIELD_CHARS));\n-\n-                    // make sure we can't write to it (read-only Realm)\n-                    try {\n-                        dynamicRealm.beginTransaction();\n-                        fail(\"Can't perform transactions on read-only Realms\");\n-                    } catch (IllegalStateException expected) {\n-                    }\n-                    dynamicRealm.close();\n-\n-                    try {\n-                        SyncConfiguration.forRecovery(backupFile, null, StringOnly.class);\n-                        fail(\"Expected to throw java.lang.Class is not a RealmModule\");\n-                    } catch (IllegalArgumentException expected) {\n-                    }\n-\n-                    // specifying the module will allow to open the typed Realm\n-                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, new StringOnlyModule());\n-                    Realm backupRealm = Realm.getInstance(backupRealmConfiguration);\n-                    assertFalse(backupRealm.isEmpty());\n-                    assertEquals(1, backupRealm.where(StringOnly.class).count());\n-                    RealmResults<StringOnly> allSorted = backupRealm.where(StringOnly.class).findAll();\n-                    assertEquals(\"Foo\", allSorted.get(0).getChars());\n-                    backupRealm.close();\n-\n-                    looperThread.testComplete();\n-                })\n-                .modules(new StringOnlyModule())\n-                .build();\n-\n-        Realm realm = Realm.getInstance(config);\n-        realm.beginTransaction();\n-        realm.createObject(StringOnly.class).setChars(\"Foo\");\n-        realm.commitTransaction();\n-\n-        looperThread.addTestRealm(realm);\n-\n-        // Trigger error\n-        user.getApp().getSync().simulateClientReset(app.getSync().getSession(configuration));\n-    }\n-\n-    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.\n-    @Test\n-    @RunTestInLooperThread\n-    @Ignore(\"FIXME: Figure out how to fix this\")\n-    public void errorHandler_useClientResetEncrypted() {\n-        RealmUser user = SyncTestUtils.createTestUser(app);\n-        final byte[] randomKey = TestHelper.getRandomKey();\n-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user)\n-                .clientResyncMode(ClientResyncMode.MANUAL)\n-                .encryptionKey(randomKey)\n-                .modules(new StringOnlyModule())\n-                .errorHandler((session, error) -> {\n-                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\n-                        fail(\"Wrong error \" + error.toString());\n-                        return;\n-                    }\n-\n-                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;\n-                    // Execute Client Reset\n-                    looperThread.closeTestRealms();\n-                    handler.executeClientReset();\n-\n-                    RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();\n-\n-                    // can open encrypted backup Realm\n-                    Realm backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration);\n-                    assertEquals(1, backupEncryptedRealm.where(StringOnly.class).count());\n-                    RealmResults<StringOnly> allSorted = backupEncryptedRealm.where(StringOnly.class).findAll();\n-                    assertEquals(\"Foo\", allSorted.get(0).getChars());\n-                    backupEncryptedRealm.close();\n-\n-                    String backupFile = handler.getBackupFile().getAbsolutePath();\n-                    // build a conf to open a DynamicRealm\n-                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, new StringOnlyModule());\n-                    backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration);\n-                    assertEquals(1, backupEncryptedRealm.where(StringOnly.class).count());\n-                    allSorted = backupEncryptedRealm.where(StringOnly.class).findAll();\n-                    assertEquals(\"Foo\", allSorted.get(0).getChars());\n-                    backupEncryptedRealm.close();\n-\n-                    // using wrong key throw\n-                    try {\n-                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), new StringOnlyModule()));\n-                        fail(\"Expected to throw when using wrong encryption key\");\n-                    } catch (RealmFileException expected) {\n-                    }\n-\n-                    looperThread.testComplete();\n-                })\n-                .build();\n-\n-        Realm realm = Realm.getInstance(config);\n-        realm.beginTransaction();\n-        realm.createObject(StringOnly.class).setChars(\"Foo\");\n-        realm.commitTransaction();\n-\n-        looperThread.addTestRealm(realm);\n-\n-        // Trigger error\n-        user.getApp().getSync().simulateClientReset(app.getSync().getSession(configuration));\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void uploadAllLocalChanges_throwsOnUiThread() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        try {\n-            app.getSync().getOrCreateSession(configuration).uploadAllLocalChanges();\n-            fail(\"Should throw an IllegalStateException on Ui Thread\");\n-        } catch (IllegalStateException ignored) {\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void uploadAllLocalChanges_withTimeout_throwsOnUiThread() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        try {\n-            app.getSync().getOrCreateSession(configuration).uploadAllLocalChanges(30, TimeUnit.SECONDS);\n-            fail(\"Should throw an IllegalStateException on Ui Thread\");\n-        } catch (IllegalStateException ignored) {\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    public void uploadAllLocalChanges_withTimeout_invalidParametersThrows() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getOrCreateSession(configuration);\n-        try {\n-            try {\n-                session.uploadAllLocalChanges(-1, TimeUnit.SECONDS);\n-                fail();\n-            } catch (IllegalArgumentException ignored) {\n-            }\n-\n-            try {\n-                //noinspection ConstantConditions\n-                session.uploadAllLocalChanges(1, null);\n-                fail();\n-            } catch (IllegalArgumentException ignored) {\n-            }\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    public void uploadAllLocalChanges_returnFalseWhenTimedOut() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getSession(configuration);\n-        try {\n-            assertFalse(session.uploadAllLocalChanges(100, TimeUnit.MILLISECONDS));\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void downloadAllServerChanges_throwsOnUiThread() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        try {\n-            app.getSync().getSession(configuration).downloadAllServerChanges();\n-            fail(\"Should throw an IllegalStateException on Ui Thread\");\n-        } catch (IllegalStateException ignored) {\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void downloadAllServerChanges_withTimeout_throwsOnUiThread() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        try {\n-            app.getSync().getSession(configuration).downloadAllServerChanges(30, TimeUnit.SECONDS);\n-            fail(\"Should throw an IllegalStateException on Ui Thread\");\n-        } catch (IllegalStateException ignored) {\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-\n-    @Test\n-    public void downloadAllServerChanges_withTimeout_invalidParametersThrows() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getSession(configuration);\n-        try {\n-            try {\n-                session.downloadAllServerChanges(-1, TimeUnit.SECONDS);\n-                fail();\n-            } catch (IllegalArgumentException ignored) {\n-            }\n-\n-            try {\n-                //noinspection ConstantConditions\n-                session.downloadAllServerChanges(1, null);\n-                fail();\n-            } catch (IllegalArgumentException ignored) {\n-            }\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    public void downloadAllServerChanges_returnFalseWhenTimedOut() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getSession(configuration);\n-        try {\n-            assertFalse(session.downloadAllServerChanges(100, TimeUnit.MILLISECONDS));\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void unrecognizedErrorCode_errorHandler() {\n-        AtomicBoolean errorHandlerCalled = new AtomicBoolean(false);\n-        configuration = configFactory.createSyncConfigurationBuilder(user)\n-                .errorHandler((session, error) -> {\n-                    errorHandlerCalled.set(true);\n-                    assertEquals(ErrorCode.UNKNOWN, error.getErrorCode());\n-                    assertEquals(ErrorCode.Category.FATAL, error.getCategory());\n-\n-                })\n-                .build();\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getSession(configuration);\n-\n-        TestHelper.TestLogger testLogger = new TestHelper.TestLogger();\n-        RealmLog.add(testLogger);\n-\n-        session.notifySessionError(\"unknown\", 3, \"Unknown Error\");\n-        RealmLog.remove(testLogger);\n-\n-        assertTrue(errorHandlerCalled.get());\n-        assertEquals(\"Unknown error code: 'unknown:3'\", testLogger.message);\n-\n-        realm.close();\n-    }\n-\n-    @Test\n-    public void getSessionThrowsOnNonExistingSession() {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getSession(configuration);\n-        assertEquals(configuration, session.getConfiguration());\n-\n-        // Closing the Realm should remove the session\n-        realm.close();\n-        try {\n-            app.getSync().getSession(configuration);\n-            fail(\"getSession should throw an ISE\");\n-        } catch (IllegalStateException expected) {\n-            assertThat(expected.getMessage(), CoreMatchers.containsString(\n-                    \"No SyncSession found using the path : \"));\n-        }\n-    }\n-\n-    @Test\n-    public void isConnected_falseForInvalidUser() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgxNTcxNg=="}, "originalCommit": {"oid": "7e0bc286d66982b4f128fc0cd7502af41d12076a"}, "originalPosition": 566}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzA2MzQ0OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNjozNFrOGZ5EKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNjozNFrOGZ5EKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMjUzOA==", "bodyText": "Can be removed?", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r429802538", "createdAt": "2020-05-25T08:26:34Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,501 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.kotlin.syncSession\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import io.realm.util.assertFailsWithMessage\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.lang.IllegalArgumentException\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.*\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+            assertEquals(user, session.user)\n+            assertEquals(configuration, session.configuration)\n+        }\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+        val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            val listeners = arrayOf(\n+                    null,\n+                    ProgressListener { progress: Progress? -> },\n+                    ProgressListener { progress: Progress? -> }\n+            )\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+            // Check that remove works unconditionally for all input\n+            for (listener in listeners) {\n+                session.removeProgressListener(TestHelper.allowNull(listener))\n+            }\n+        }\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    assertEquals(filePathFromError, filePathFromConfig)\n+                    assertFalse(handler.backupFile.exists())\n+                    assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    assertNotNull(backupRealmConfiguration)\n+                    assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        assertEquals(\"Foo\", backupRealm.where(StringOnly::class.java).findAll().first()!!.chars)\n+                    }\n+\n+                    // opening a Dynamic Realm should also work\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    assertFailsWith<RealmMigrationNeededException> {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        fail(\"Expected to throw a Migration required\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc1ad656284738277877e98bf4e6cfd61987d20d"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzA2MzgyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNjo0MVrOGZ5EZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNjo0MVrOGZ5EZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMjU5Ng==", "bodyText": "Same", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r429802596", "createdAt": "2020-05-25T08:26:41Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,501 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.kotlin.syncSession\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import io.realm.util.assertFailsWithMessage\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.lang.IllegalArgumentException\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.*\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+            assertEquals(user, session.user)\n+            assertEquals(configuration, session.configuration)\n+        }\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+        val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            val listeners = arrayOf(\n+                    null,\n+                    ProgressListener { progress: Progress? -> },\n+                    ProgressListener { progress: Progress? -> }\n+            )\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+            // Check that remove works unconditionally for all input\n+            for (listener in listeners) {\n+                session.removeProgressListener(TestHelper.allowNull(listener))\n+            }\n+        }\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    assertEquals(filePathFromError, filePathFromConfig)\n+                    assertFalse(handler.backupFile.exists())\n+                    assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    assertNotNull(backupRealmConfiguration)\n+                    assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        assertEquals(\"Foo\", backupRealm.where(StringOnly::class.java).findAll().first()!!.chars)\n+                    }\n+\n+                    // opening a Dynamic Realm should also work\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    assertFailsWith<RealmMigrationNeededException> {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        fail(\"Expected to throw a Migration required\")\n+                    }\n+\n+                    // opening a DynamicRealm will work though\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                        // make sure we can't write to it (read-only Realm)\n+                        assertFailsWith<java.lang.IllegalStateException> {\n+                            dynamicRealm.beginTransaction()\n+                            fail(\"Can't perform transactions on read-only Realms\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc1ad656284738277877e98bf4e6cfd61987d20d"}, "originalPosition": 272}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzA2NDE0OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNjo0NlrOGZ5Elg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNjo0NlrOGZ5Elg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMjY0Ng==", "bodyText": "Same", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r429802646", "createdAt": "2020-05-25T08:26:46Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,501 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.kotlin.syncSession\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import io.realm.util.assertFailsWithMessage\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.lang.IllegalArgumentException\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.*\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+            assertEquals(user, session.user)\n+            assertEquals(configuration, session.configuration)\n+        }\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+        val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            val listeners = arrayOf(\n+                    null,\n+                    ProgressListener { progress: Progress? -> },\n+                    ProgressListener { progress: Progress? -> }\n+            )\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+            // Check that remove works unconditionally for all input\n+            for (listener in listeners) {\n+                session.removeProgressListener(TestHelper.allowNull(listener))\n+            }\n+        }\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    assertEquals(filePathFromError, filePathFromConfig)\n+                    assertFalse(handler.backupFile.exists())\n+                    assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    assertNotNull(backupRealmConfiguration)\n+                    assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        assertEquals(\"Foo\", backupRealm.where(StringOnly::class.java).findAll().first()!!.chars)\n+                    }\n+\n+                    // opening a Dynamic Realm should also work\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    assertFailsWith<RealmMigrationNeededException> {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        fail(\"Expected to throw a Migration required\")\n+                    }\n+\n+                    // opening a DynamicRealm will work though\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                        // make sure we can't write to it (read-only Realm)\n+                        assertFailsWith<java.lang.IllegalStateException> {\n+                            dynamicRealm.beginTransaction()\n+                            fail(\"Can't perform transactions on read-only Realms\")\n+                        }\n+                    }\n+\n+                    assertFailsWith<IllegalArgumentException> {\n+                        SyncConfiguration.forRecovery(backupFile, null, StringOnly::class.java)\n+                        fail(\"Expected to throw java.lang.Class is not a RealmModule\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc1ad656284738277877e98bf4e6cfd61987d20d"}, "originalPosition": 278}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzA2NDg0OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNjo1OVrOGZ5E_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNjo1OVrOGZ5E_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMjc1MQ==", "bodyText": "Same", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r429802751", "createdAt": "2020-05-25T08:26:59Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,501 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.kotlin.syncSession\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import io.realm.util.assertFailsWithMessage\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.lang.IllegalArgumentException\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.*\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+            assertEquals(user, session.user)\n+            assertEquals(configuration, session.configuration)\n+        }\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+        val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            val listeners = arrayOf(\n+                    null,\n+                    ProgressListener { progress: Progress? -> },\n+                    ProgressListener { progress: Progress? -> }\n+            )\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+            // Check that remove works unconditionally for all input\n+            for (listener in listeners) {\n+                session.removeProgressListener(TestHelper.allowNull(listener))\n+            }\n+        }\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    assertEquals(filePathFromError, filePathFromConfig)\n+                    assertFalse(handler.backupFile.exists())\n+                    assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    assertNotNull(backupRealmConfiguration)\n+                    assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        assertEquals(\"Foo\", backupRealm.where(StringOnly::class.java).findAll().first()!!.chars)\n+                    }\n+\n+                    // opening a Dynamic Realm should also work\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    assertFailsWith<RealmMigrationNeededException> {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        fail(\"Expected to throw a Migration required\")\n+                    }\n+\n+                    // opening a DynamicRealm will work though\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                        // make sure we can't write to it (read-only Realm)\n+                        assertFailsWith<java.lang.IllegalStateException> {\n+                            dynamicRealm.beginTransaction()\n+                            fail(\"Can't perform transactions on read-only Realms\")\n+                        }\n+                    }\n+\n+                    assertFailsWith<IllegalArgumentException> {\n+                        SyncConfiguration.forRecovery(backupFile, null, StringOnly::class.java)\n+                        fail(\"Expected to throw java.lang.Class is not a RealmModule\")\n+                    }\n+\n+                    // specifying the module will allow to open the typed Realm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, StringOnlyModule())\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.\n+    @Test\n+    fun errorHandler_useClientResetEncrypted() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val randomKey = TestHelper.getRandomKey()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .encryptionKey(randomKey)\n+                .modules(StringOnlyModule())\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+                    var backupRealmConfiguration = handler.backupRealmConfiguration\n+\n+                    // can open encrypted backup Realm\n+                    Realm.getInstance(backupRealmConfiguration).use { backupEncryptedRealm ->\n+                        assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // build a conf to open a DynamicRealm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, StringOnlyModule())\n+                    Realm.getInstance(backupRealmConfiguration).use { backupEncryptedRealm ->\n+                        assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+\n+                    // using wrong key throw\n+                    assertFailsWith<RealmFileException> {\n+                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), StringOnlyModule()))\n+                        fail(\"Expected to throw when using wrong encryption key\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc1ad656284738277877e98bf4e6cfd61987d20d"}, "originalPosition": 344}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzA2NTExOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNzowNVrOGZ5FKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNzowNVrOGZ5FKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMjc5NQ==", "bodyText": "Same", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r429802795", "createdAt": "2020-05-25T08:27:05Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,501 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.kotlin.syncSession\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import io.realm.util.assertFailsWithMessage\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.lang.IllegalArgumentException\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.*\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+            assertEquals(user, session.user)\n+            assertEquals(configuration, session.configuration)\n+        }\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+        val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            val listeners = arrayOf(\n+                    null,\n+                    ProgressListener { progress: Progress? -> },\n+                    ProgressListener { progress: Progress? -> }\n+            )\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+            // Check that remove works unconditionally for all input\n+            for (listener in listeners) {\n+                session.removeProgressListener(TestHelper.allowNull(listener))\n+            }\n+        }\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    assertEquals(filePathFromError, filePathFromConfig)\n+                    assertFalse(handler.backupFile.exists())\n+                    assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    assertNotNull(backupRealmConfiguration)\n+                    assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        assertEquals(\"Foo\", backupRealm.where(StringOnly::class.java).findAll().first()!!.chars)\n+                    }\n+\n+                    // opening a Dynamic Realm should also work\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    assertFailsWith<RealmMigrationNeededException> {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        fail(\"Expected to throw a Migration required\")\n+                    }\n+\n+                    // opening a DynamicRealm will work though\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                        // make sure we can't write to it (read-only Realm)\n+                        assertFailsWith<java.lang.IllegalStateException> {\n+                            dynamicRealm.beginTransaction()\n+                            fail(\"Can't perform transactions on read-only Realms\")\n+                        }\n+                    }\n+\n+                    assertFailsWith<IllegalArgumentException> {\n+                        SyncConfiguration.forRecovery(backupFile, null, StringOnly::class.java)\n+                        fail(\"Expected to throw java.lang.Class is not a RealmModule\")\n+                    }\n+\n+                    // specifying the module will allow to open the typed Realm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, StringOnlyModule())\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.\n+    @Test\n+    fun errorHandler_useClientResetEncrypted() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val randomKey = TestHelper.getRandomKey()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .encryptionKey(randomKey)\n+                .modules(StringOnlyModule())\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+                    var backupRealmConfiguration = handler.backupRealmConfiguration\n+\n+                    // can open encrypted backup Realm\n+                    Realm.getInstance(backupRealmConfiguration).use { backupEncryptedRealm ->\n+                        assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // build a conf to open a DynamicRealm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, StringOnlyModule())\n+                    Realm.getInstance(backupRealmConfiguration).use { backupEncryptedRealm ->\n+                        assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+\n+                    // using wrong key throw\n+                    assertFailsWith<RealmFileException> {\n+                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), StringOnlyModule()))\n+                        fail(\"Expected to throw when using wrong encryption key\")\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun uploadAllLocalChanges_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use { realm ->\n+            assertFailsWith<java.lang.IllegalStateException> {\n+                realm.syncSession.uploadAllLocalChanges()\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc1ad656284738277877e98bf4e6cfd61987d20d"}, "originalPosition": 366}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzA2NTM4OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNzoxMFrOGZ5FUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNzoxMFrOGZ5FUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMjgzNQ==", "bodyText": "Same", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r429802835", "createdAt": "2020-05-25T08:27:10Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,501 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.kotlin.syncSession\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import io.realm.util.assertFailsWithMessage\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.lang.IllegalArgumentException\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.*\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+            assertEquals(user, session.user)\n+            assertEquals(configuration, session.configuration)\n+        }\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+        val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            val listeners = arrayOf(\n+                    null,\n+                    ProgressListener { progress: Progress? -> },\n+                    ProgressListener { progress: Progress? -> }\n+            )\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+            // Check that remove works unconditionally for all input\n+            for (listener in listeners) {\n+                session.removeProgressListener(TestHelper.allowNull(listener))\n+            }\n+        }\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    assertEquals(filePathFromError, filePathFromConfig)\n+                    assertFalse(handler.backupFile.exists())\n+                    assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    assertNotNull(backupRealmConfiguration)\n+                    assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        assertEquals(\"Foo\", backupRealm.where(StringOnly::class.java).findAll().first()!!.chars)\n+                    }\n+\n+                    // opening a Dynamic Realm should also work\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    assertFailsWith<RealmMigrationNeededException> {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        fail(\"Expected to throw a Migration required\")\n+                    }\n+\n+                    // opening a DynamicRealm will work though\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                        // make sure we can't write to it (read-only Realm)\n+                        assertFailsWith<java.lang.IllegalStateException> {\n+                            dynamicRealm.beginTransaction()\n+                            fail(\"Can't perform transactions on read-only Realms\")\n+                        }\n+                    }\n+\n+                    assertFailsWith<IllegalArgumentException> {\n+                        SyncConfiguration.forRecovery(backupFile, null, StringOnly::class.java)\n+                        fail(\"Expected to throw java.lang.Class is not a RealmModule\")\n+                    }\n+\n+                    // specifying the module will allow to open the typed Realm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, StringOnlyModule())\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.\n+    @Test\n+    fun errorHandler_useClientResetEncrypted() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val randomKey = TestHelper.getRandomKey()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .encryptionKey(randomKey)\n+                .modules(StringOnlyModule())\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+                    var backupRealmConfiguration = handler.backupRealmConfiguration\n+\n+                    // can open encrypted backup Realm\n+                    Realm.getInstance(backupRealmConfiguration).use { backupEncryptedRealm ->\n+                        assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // build a conf to open a DynamicRealm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, StringOnlyModule())\n+                    Realm.getInstance(backupRealmConfiguration).use { backupEncryptedRealm ->\n+                        assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+\n+                    // using wrong key throw\n+                    assertFailsWith<RealmFileException> {\n+                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), StringOnlyModule()))\n+                        fail(\"Expected to throw when using wrong encryption key\")\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun uploadAllLocalChanges_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use { realm ->\n+            assertFailsWith<java.lang.IllegalStateException> {\n+                realm.syncSession.uploadAllLocalChanges()\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun uploadAllLocalChanges_withTimeout_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use { realm ->\n+            assertFailsWith<IllegalStateException> {\n+                realm.syncSession.uploadAllLocalChanges(30, TimeUnit.SECONDS)\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc1ad656284738277877e98bf4e6cfd61987d20d"}, "originalPosition": 377}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzA2NjEwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNzoyMlrOGZ5Fvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNzoyMlrOGZ5Fvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMjk0Mw==", "bodyText": "Same", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r429802943", "createdAt": "2020-05-25T08:27:22Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,501 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.kotlin.syncSession\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import io.realm.util.assertFailsWithMessage\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.lang.IllegalArgumentException\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.*\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+            assertEquals(user, session.user)\n+            assertEquals(configuration, session.configuration)\n+        }\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+        val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            val listeners = arrayOf(\n+                    null,\n+                    ProgressListener { progress: Progress? -> },\n+                    ProgressListener { progress: Progress? -> }\n+            )\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+            // Check that remove works unconditionally for all input\n+            for (listener in listeners) {\n+                session.removeProgressListener(TestHelper.allowNull(listener))\n+            }\n+        }\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    assertEquals(filePathFromError, filePathFromConfig)\n+                    assertFalse(handler.backupFile.exists())\n+                    assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    assertNotNull(backupRealmConfiguration)\n+                    assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        assertEquals(\"Foo\", backupRealm.where(StringOnly::class.java).findAll().first()!!.chars)\n+                    }\n+\n+                    // opening a Dynamic Realm should also work\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    assertFailsWith<RealmMigrationNeededException> {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        fail(\"Expected to throw a Migration required\")\n+                    }\n+\n+                    // opening a DynamicRealm will work though\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                        // make sure we can't write to it (read-only Realm)\n+                        assertFailsWith<java.lang.IllegalStateException> {\n+                            dynamicRealm.beginTransaction()\n+                            fail(\"Can't perform transactions on read-only Realms\")\n+                        }\n+                    }\n+\n+                    assertFailsWith<IllegalArgumentException> {\n+                        SyncConfiguration.forRecovery(backupFile, null, StringOnly::class.java)\n+                        fail(\"Expected to throw java.lang.Class is not a RealmModule\")\n+                    }\n+\n+                    // specifying the module will allow to open the typed Realm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, StringOnlyModule())\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.\n+    @Test\n+    fun errorHandler_useClientResetEncrypted() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val randomKey = TestHelper.getRandomKey()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .encryptionKey(randomKey)\n+                .modules(StringOnlyModule())\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+                    var backupRealmConfiguration = handler.backupRealmConfiguration\n+\n+                    // can open encrypted backup Realm\n+                    Realm.getInstance(backupRealmConfiguration).use { backupEncryptedRealm ->\n+                        assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // build a conf to open a DynamicRealm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, StringOnlyModule())\n+                    Realm.getInstance(backupRealmConfiguration).use { backupEncryptedRealm ->\n+                        assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+\n+                    // using wrong key throw\n+                    assertFailsWith<RealmFileException> {\n+                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), StringOnlyModule()))\n+                        fail(\"Expected to throw when using wrong encryption key\")\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun uploadAllLocalChanges_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use { realm ->\n+            assertFailsWith<java.lang.IllegalStateException> {\n+                realm.syncSession.uploadAllLocalChanges()\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun uploadAllLocalChanges_withTimeout_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use { realm ->\n+            assertFailsWith<IllegalStateException> {\n+                realm.syncSession.uploadAllLocalChanges(30, TimeUnit.SECONDS)\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun uploadAllLocalChanges_withTimeout_invalidParametersThrows() {\n+        Realm.getInstance(configuration). use { realm ->\n+            val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.uploadAllLocalChanges(-1, TimeUnit.SECONDS)\n+            }\n+            assertFailsWith<IllegalArgumentException> {\n+                session.uploadAllLocalChanges(1, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun uploadAllLocalChanges_returnFalseWhenTimedOut() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertFalse(session.uploadAllLocalChanges(100, TimeUnit.MILLISECONDS))\n+        }\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun downloadAllServerChanges_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use {realm ->\n+            assertFailsWith<IllegalStateException> {\n+                realm.syncSession.downloadAllServerChanges()\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc1ad656284738277877e98bf4e6cfd61987d20d"}, "originalPosition": 409}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzA2NjQyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNzoyOFrOGZ5F8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNzoyOFrOGZ5F8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMjk5NQ==", "bodyText": "Same", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r429802995", "createdAt": "2020-05-25T08:27:28Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,501 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.kotlin.syncSession\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import io.realm.util.assertFailsWithMessage\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.lang.IllegalArgumentException\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.*\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+            assertEquals(user, session.user)\n+            assertEquals(configuration, session.configuration)\n+        }\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+        val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            val listeners = arrayOf(\n+                    null,\n+                    ProgressListener { progress: Progress? -> },\n+                    ProgressListener { progress: Progress? -> }\n+            )\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+            // Check that remove works unconditionally for all input\n+            for (listener in listeners) {\n+                session.removeProgressListener(TestHelper.allowNull(listener))\n+            }\n+        }\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    assertEquals(filePathFromError, filePathFromConfig)\n+                    assertFalse(handler.backupFile.exists())\n+                    assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    assertNotNull(backupRealmConfiguration)\n+                    assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        assertEquals(\"Foo\", backupRealm.where(StringOnly::class.java).findAll().first()!!.chars)\n+                    }\n+\n+                    // opening a Dynamic Realm should also work\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    assertFailsWith<RealmMigrationNeededException> {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        fail(\"Expected to throw a Migration required\")\n+                    }\n+\n+                    // opening a DynamicRealm will work though\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                        // make sure we can't write to it (read-only Realm)\n+                        assertFailsWith<java.lang.IllegalStateException> {\n+                            dynamicRealm.beginTransaction()\n+                            fail(\"Can't perform transactions on read-only Realms\")\n+                        }\n+                    }\n+\n+                    assertFailsWith<IllegalArgumentException> {\n+                        SyncConfiguration.forRecovery(backupFile, null, StringOnly::class.java)\n+                        fail(\"Expected to throw java.lang.Class is not a RealmModule\")\n+                    }\n+\n+                    // specifying the module will allow to open the typed Realm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, StringOnlyModule())\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.\n+    @Test\n+    fun errorHandler_useClientResetEncrypted() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val randomKey = TestHelper.getRandomKey()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .encryptionKey(randomKey)\n+                .modules(StringOnlyModule())\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+                    var backupRealmConfiguration = handler.backupRealmConfiguration\n+\n+                    // can open encrypted backup Realm\n+                    Realm.getInstance(backupRealmConfiguration).use { backupEncryptedRealm ->\n+                        assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // build a conf to open a DynamicRealm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, StringOnlyModule())\n+                    Realm.getInstance(backupRealmConfiguration).use { backupEncryptedRealm ->\n+                        assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+\n+                    // using wrong key throw\n+                    assertFailsWith<RealmFileException> {\n+                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), StringOnlyModule()))\n+                        fail(\"Expected to throw when using wrong encryption key\")\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun uploadAllLocalChanges_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use { realm ->\n+            assertFailsWith<java.lang.IllegalStateException> {\n+                realm.syncSession.uploadAllLocalChanges()\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun uploadAllLocalChanges_withTimeout_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use { realm ->\n+            assertFailsWith<IllegalStateException> {\n+                realm.syncSession.uploadAllLocalChanges(30, TimeUnit.SECONDS)\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun uploadAllLocalChanges_withTimeout_invalidParametersThrows() {\n+        Realm.getInstance(configuration). use { realm ->\n+            val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.uploadAllLocalChanges(-1, TimeUnit.SECONDS)\n+            }\n+            assertFailsWith<IllegalArgumentException> {\n+                session.uploadAllLocalChanges(1, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun uploadAllLocalChanges_returnFalseWhenTimedOut() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertFalse(session.uploadAllLocalChanges(100, TimeUnit.MILLISECONDS))\n+        }\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun downloadAllServerChanges_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use {realm ->\n+            assertFailsWith<IllegalStateException> {\n+                realm.syncSession.downloadAllServerChanges()\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun downloadAllServerChanges_withTimeout_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use { realm ->\n+            assertFailsWith<IllegalStateException> {\n+                realm.syncSession.downloadAllServerChanges(30, TimeUnit.SECONDS)\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc1ad656284738277877e98bf4e6cfd61987d20d"}, "originalPosition": 420}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzA2NjcyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNzozM1rOGZ5GHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNzozM1rOGZ5GHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMzAzOQ==", "bodyText": "Same", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r429803039", "createdAt": "2020-05-25T08:27:33Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,501 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.kotlin.syncSession\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import io.realm.util.assertFailsWithMessage\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.lang.IllegalArgumentException\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.*\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+            assertEquals(user, session.user)\n+            assertEquals(configuration, session.configuration)\n+        }\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+        val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            val listeners = arrayOf(\n+                    null,\n+                    ProgressListener { progress: Progress? -> },\n+                    ProgressListener { progress: Progress? -> }\n+            )\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+            // Check that remove works unconditionally for all input\n+            for (listener in listeners) {\n+                session.removeProgressListener(TestHelper.allowNull(listener))\n+            }\n+        }\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    assertEquals(filePathFromError, filePathFromConfig)\n+                    assertFalse(handler.backupFile.exists())\n+                    assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    assertNotNull(backupRealmConfiguration)\n+                    assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        assertEquals(\"Foo\", backupRealm.where(StringOnly::class.java).findAll().first()!!.chars)\n+                    }\n+\n+                    // opening a Dynamic Realm should also work\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    assertFailsWith<RealmMigrationNeededException> {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        fail(\"Expected to throw a Migration required\")\n+                    }\n+\n+                    // opening a DynamicRealm will work though\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                        // make sure we can't write to it (read-only Realm)\n+                        assertFailsWith<java.lang.IllegalStateException> {\n+                            dynamicRealm.beginTransaction()\n+                            fail(\"Can't perform transactions on read-only Realms\")\n+                        }\n+                    }\n+\n+                    assertFailsWith<IllegalArgumentException> {\n+                        SyncConfiguration.forRecovery(backupFile, null, StringOnly::class.java)\n+                        fail(\"Expected to throw java.lang.Class is not a RealmModule\")\n+                    }\n+\n+                    // specifying the module will allow to open the typed Realm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, StringOnlyModule())\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.\n+    @Test\n+    fun errorHandler_useClientResetEncrypted() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val randomKey = TestHelper.getRandomKey()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .encryptionKey(randomKey)\n+                .modules(StringOnlyModule())\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+                    var backupRealmConfiguration = handler.backupRealmConfiguration\n+\n+                    // can open encrypted backup Realm\n+                    Realm.getInstance(backupRealmConfiguration).use { backupEncryptedRealm ->\n+                        assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // build a conf to open a DynamicRealm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, StringOnlyModule())\n+                    Realm.getInstance(backupRealmConfiguration).use { backupEncryptedRealm ->\n+                        assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+\n+                    // using wrong key throw\n+                    assertFailsWith<RealmFileException> {\n+                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), StringOnlyModule()))\n+                        fail(\"Expected to throw when using wrong encryption key\")\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun uploadAllLocalChanges_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use { realm ->\n+            assertFailsWith<java.lang.IllegalStateException> {\n+                realm.syncSession.uploadAllLocalChanges()\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun uploadAllLocalChanges_withTimeout_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use { realm ->\n+            assertFailsWith<IllegalStateException> {\n+                realm.syncSession.uploadAllLocalChanges(30, TimeUnit.SECONDS)\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun uploadAllLocalChanges_withTimeout_invalidParametersThrows() {\n+        Realm.getInstance(configuration). use { realm ->\n+            val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.uploadAllLocalChanges(-1, TimeUnit.SECONDS)\n+            }\n+            assertFailsWith<IllegalArgumentException> {\n+                session.uploadAllLocalChanges(1, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun uploadAllLocalChanges_returnFalseWhenTimedOut() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertFalse(session.uploadAllLocalChanges(100, TimeUnit.MILLISECONDS))\n+        }\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun downloadAllServerChanges_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use {realm ->\n+            assertFailsWith<IllegalStateException> {\n+                realm.syncSession.downloadAllServerChanges()\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun downloadAllServerChanges_withTimeout_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use { realm ->\n+            assertFailsWith<IllegalStateException> {\n+                realm.syncSession.downloadAllServerChanges(30, TimeUnit.SECONDS)\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun downloadAllServerChanges_withTimeout_invalidParametersThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.downloadAllServerChanges(-1, TimeUnit.SECONDS)\n+                fail()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc1ad656284738277877e98bf4e6cfd61987d20d"}, "originalPosition": 431}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzA2ODM0OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyODowMVrOGZ5HGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyODowMVrOGZ5HGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMzI4OQ==", "bodyText": "Remove?", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r429803289", "createdAt": "2020-05-25T08:28:01Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SessionTests.kt", "diffHunk": "@@ -0,0 +1,501 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.TestHelper.TestLogger\n+import io.realm.entities.StringOnly\n+import io.realm.entities.StringOnlyModule\n+import io.realm.exceptions.RealmFileException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.kotlin.syncSession\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.ResourceContainer\n+import io.realm.util.assertFailsWithMessage\n+import org.hamcrest.CoreMatchers\n+import org.hamcrest.MatcherAssert.assertThat\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import java.lang.IllegalArgumentException\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.*\n+\n+@RunWith(AndroidJUnit4::class)\n+class SessionTests {\n+    private lateinit var configuration: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+    private lateinit var user: RealmUser\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestRealmApp()\n+        // TODO We could potentially work without a fully functioning user to speed up tests, but\n+        //  seems like the old  way of \"faking\" it, does now work for now, so using a real user.\n+        // user = SyncTestUtils.createTestUser(app)\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        configuration = SyncConfiguration.defaultConfig(user, \"default\")\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun get_syncValues() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertEquals(\"ws://127.0.0.1:9090/\", session.serverUrl.toString())\n+            assertEquals(user, session.user)\n+            assertEquals(configuration, session.configuration)\n+        }\n+    }\n+\n+    @Test\n+    fun addDownloadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+        val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun addUploadProgressListener_nullThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun removeProgressListener() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            val listeners = arrayOf(\n+                    null,\n+                    ProgressListener { progress: Progress? -> },\n+                    ProgressListener { progress: Progress? -> }\n+            )\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, TestHelper.allowNull(listeners[2]))\n+\n+            // Check that remove works unconditionally for all input\n+            for (listener in listeners) {\n+                session.removeProgressListener(TestHelper.allowNull(listener))\n+            }\n+        }\n+    }\n+\n+    // Check that a Client Reset is correctly reported.\n+    @Test\n+    fun errorHandler_clientResetReported() = looperThread.runBlocking {\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    val filePathFromError = handler.originalFile.absolutePath\n+                    val filePathFromConfig = session.configuration.path\n+                    assertEquals(filePathFromError, filePathFromConfig)\n+                    assertFalse(handler.backupFile.exists())\n+                    assertTrue(handler.originalFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        looperThread.closeAfterTest(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can manually execute the Client Reset.\n+    @Test\n+    fun errorHandler_manualExecuteClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    try {\n+                        handler.executeClientReset()\n+                        fail(\"All Realms should be closed before executing Client Reset can be allowed\")\n+                    } catch (ignored: IllegalStateException) {\n+                    }\n+\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can use the backup SyncConfiguration to open the Realm.\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationForClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .schema(StringOnly::class.java)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupRealmConfiguration = handler.backupRealmConfiguration\n+                    assertNotNull(backupRealmConfiguration)\n+                    assertFalse(backupRealmConfiguration.isSyncConfiguration)\n+                    assertTrue(backupRealmConfiguration.isRecoveryConfiguration)\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        assertEquals(\"Foo\", backupRealm.where(StringOnly::class.java).findAll().first()!!.chars)\n+                    }\n+\n+                    // opening a Dynamic Realm should also work\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // Check that we can open the backup file without using the provided SyncConfiguration,\n+    // this might be the case if the user decide to act upon the client reset later (providing s/he\n+    // persisted the location of the file)\n+    @Test\n+    fun errorHandler_useBackupSyncConfigurationAfterClientReset() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+\n+                    // Validate that files have been moved\n+                    assertFalse(handler.originalFile.exists())\n+                    assertTrue(handler.backupFile.exists())\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // this SyncConf doesn't specify any module, it will throw a migration required\n+                    // exception since the backup Realm contain only StringOnly table\n+                    var backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile)\n+                    assertFailsWith<RealmMigrationNeededException> {\n+                        Realm.getInstance(backupRealmConfiguration)\n+                        fail(\"Expected to throw a Migration required\")\n+                    }\n+\n+                    // opening a DynamicRealm will work though\n+                    DynamicRealm.getInstance(backupRealmConfiguration).use { dynamicRealm ->\n+                        dynamicRealm.schema.checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME)\n+                        val all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll()\n+                        assertEquals(1, all.size.toLong())\n+                        assertEquals(\"Foo\", all.first()!!.getString(StringOnly.FIELD_CHARS))\n+                        // make sure we can't write to it (read-only Realm)\n+                        assertFailsWith<java.lang.IllegalStateException> {\n+                            dynamicRealm.beginTransaction()\n+                            fail(\"Can't perform transactions on read-only Realms\")\n+                        }\n+                    }\n+\n+                    assertFailsWith<IllegalArgumentException> {\n+                        SyncConfiguration.forRecovery(backupFile, null, StringOnly::class.java)\n+                        fail(\"Expected to throw java.lang.Class is not a RealmModule\")\n+                    }\n+\n+                    // specifying the module will allow to open the typed Realm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, StringOnlyModule())\n+                    Realm.getInstance(backupRealmConfiguration).use { backupRealm ->\n+                        assertFalse(backupRealm.isEmpty)\n+                        assertEquals(1, backupRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .modules(StringOnlyModule())\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.\n+    @Test\n+    fun errorHandler_useClientResetEncrypted() = looperThread.runBlocking {\n+        val resources = ResourceContainer()\n+\n+        val randomKey = TestHelper.getRandomKey()\n+        val config = configFactory.createSyncConfigurationBuilder(user)\n+                .clientResyncMode(ClientResyncMode.MANUAL)\n+                .encryptionKey(randomKey)\n+                .modules(StringOnlyModule())\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    if (error.errorCode != ErrorCode.CLIENT_RESET) {\n+                        fail(\"Wrong error $error\")\n+                        return@errorHandler\n+                    }\n+                    val handler = error as ClientResetRequiredError\n+                    // Execute Client Reset\n+                    resources.close()\n+                    handler.executeClientReset()\n+                    var backupRealmConfiguration = handler.backupRealmConfiguration\n+\n+                    // can open encrypted backup Realm\n+                    Realm.getInstance(backupRealmConfiguration).use { backupEncryptedRealm ->\n+                        assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+                    val backupFile = handler.backupFile.absolutePath\n+\n+                    // build a conf to open a DynamicRealm\n+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, StringOnlyModule())\n+                    Realm.getInstance(backupRealmConfiguration).use { backupEncryptedRealm ->\n+                        assertEquals(1, backupEncryptedRealm.where(StringOnly::class.java).count())\n+                        val allSorted = backupEncryptedRealm.where(StringOnly::class.java).findAll()\n+                        assertEquals(\"Foo\", allSorted[0]!!.chars)\n+                    }\n+\n+                    // using wrong key throw\n+                    assertFailsWith<RealmFileException> {\n+                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), StringOnlyModule()))\n+                        fail(\"Expected to throw when using wrong encryption key\")\n+                    }\n+                    looperThread.testComplete()\n+                }\n+                .build()\n+\n+        val realm = Realm.getInstance(config)\n+        realm.executeTransaction {\n+            realm.createObject(StringOnly::class.java).chars = \"Foo\"\n+        }\n+        resources.add(realm)\n+\n+        // Trigger error\n+        user.app.sync.simulateClientReset(realm.syncSession)\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun uploadAllLocalChanges_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use { realm ->\n+            assertFailsWith<java.lang.IllegalStateException> {\n+                realm.syncSession.uploadAllLocalChanges()\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun uploadAllLocalChanges_withTimeout_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use { realm ->\n+            assertFailsWith<IllegalStateException> {\n+                realm.syncSession.uploadAllLocalChanges(30, TimeUnit.SECONDS)\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun uploadAllLocalChanges_withTimeout_invalidParametersThrows() {\n+        Realm.getInstance(configuration). use { realm ->\n+            val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.uploadAllLocalChanges(-1, TimeUnit.SECONDS)\n+            }\n+            assertFailsWith<IllegalArgumentException> {\n+                session.uploadAllLocalChanges(1, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun uploadAllLocalChanges_returnFalseWhenTimedOut() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertFalse(session.uploadAllLocalChanges(100, TimeUnit.MILLISECONDS))\n+        }\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun downloadAllServerChanges_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use {realm ->\n+            assertFailsWith<IllegalStateException> {\n+                realm.syncSession.downloadAllServerChanges()\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun downloadAllServerChanges_withTimeout_throwsOnUiThread() {\n+        Realm.getInstance(configuration).use { realm ->\n+            assertFailsWith<IllegalStateException> {\n+                realm.syncSession.downloadAllServerChanges(30, TimeUnit.SECONDS)\n+                fail(\"Should throw an IllegalStateException on Ui Thread\")\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun downloadAllServerChanges_withTimeout_invalidParametersThrows() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertFailsWith<IllegalArgumentException> {\n+                session.downloadAllServerChanges(-1, TimeUnit.SECONDS)\n+                fail()\n+            }\n+            assertFailsWith<IllegalArgumentException> {\n+                session.downloadAllServerChanges(1, TestHelper.getNull())\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun downloadAllServerChanges_returnFalseWhenTimedOut() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            // We never assume to be able to download changes with one 1ms\n+            assertFalse(session.downloadAllServerChanges(1, TimeUnit.MILLISECONDS))\n+        }\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun unrecognizedErrorCode_errorHandler() {\n+        val errorHandlerCalled = AtomicBoolean(false)\n+        configuration = configFactory.createSyncConfigurationBuilder(user)\n+                .errorHandler { session: SyncSession?, error: ObjectServerError ->\n+                    errorHandlerCalled.set(true)\n+                    assertEquals(ErrorCode.UNKNOWN, error.errorCode)\n+                    assertEquals(ErrorCode.Category.FATAL, error.category)\n+                }\n+                .build()\n+\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            val testLogger = TestLogger()\n+            RealmLog.add(testLogger)\n+            session.notifySessionError(\"unknown\", 3, \"Unknown Error\")\n+            RealmLog.remove(testLogger)\n+            assertTrue(errorHandlerCalled.get())\n+            assertEquals(\"Unknown error code: 'unknown:3'\", testLogger.message)\n+        }\n+    }\n+\n+    // Closing the Realm should remove the session\n+    @Test\n+    fun getSessionThrowsOnNonExistingSession() {\n+        Realm.getInstance(configuration).use { realm ->\n+            val session = realm.syncSession\n+            assertEquals(configuration, session.configuration)\n+        // Exiting the scope closes the Realm and should remove the session\n+        }\n+        assertFailsWithMessage<IllegalStateException>(\n+                CoreMatchers.containsString( \"No SyncSession found using the path : \")\n+        ) {\n+            app.sync.getSession(configuration)\n+            fail(\"getSession should throw an ISE\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc1ad656284738277877e98bf4e6cfd61987d20d"}, "originalPosition": 483}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 704, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}