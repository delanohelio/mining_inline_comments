{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzMzI4MjA5", "number": 6881, "reviewThreads": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzowMDoyOVrOD_9aJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo1MDowNVrOECHnoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzkyOTk4OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzowMDoyOVrOGa75PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwODo1NzoxOFrOGa_42g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5NzQ2OQ==", "bodyText": "There is an assertFailsWith<> in Kotlin to test that it fails with a specific exception. There are also some other variants in KotlinTestUtils.kt for testing ObjectServerError's error code and a matcher to test actual message of exceptions.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r430897469", "createdAt": "2020-05-27T07:00:29Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -228,37 +224,26 @@ class MongoCollectionTest {\n             // Test findOne() with filter that does not match any documents and no options\n             assertNull(findOne(Document(\"hello\", \"worldDNE\")).blockingGetResult())\n \n-            // FIXME: revisit when parser is fully operational\n             // Insert 2 more documents into the collection\n-//            insertMany(listOf(doc2, doc3)).blockingGetResult()    // use insertOne for now\n-            insertOne(doc2).blockingGetResult()\n-            insertOne(doc3).blockingGetResult()\n+            insertMany(listOf(doc2, doc3)).blockingGetResult()\n             assertEquals(3, count().blockingGetResult())\n \n-//            // test findOne() with projection and sort options\n-//            val projection = Document(\"hello\", 1)\n-//            projection[\"_id\"] = 0\n-//            val options1 = FindOptions()\n-//                    .limit(2)\n-//                    .projection(projection)\n-//                    .sort(Document(\"hello\", 1))\n-//            assertEquals(doc1, findOne(Document(), options1).blockingGetResult()!!.withoutId())\n-//\n-//            val options2 = FindOptions()\n-//                    .limit(2)\n-//                    .projection(projection)\n-//                    .sort(Document(\"hello\", -1))\n-//            assertEquals(doc3.withoutId(), findOne(Document(), options2).blockingGetResult()!!.withoutId())\n-//\n-//            // test findOne() properly fails\n-//            try {\n-//                Tasks.await(coll.findOne(Document(\"\\$who\", 1)))\n-//                Assert.fail()\n-//            } catch (ex: ExecutionException) {\n-//                Assert.assertTrue(ex.cause is StitchServiceException)\n-//                val svcEx = ex.cause as StitchServiceException\n-//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n-//            }\n+            // test findOne() with projection and sort options\n+            val projection = Document(\"hello\", 1)\n+            projection[\"_id\"] = 0\n+            val options1 = FindOptions()\n+                    .limit(2)\n+                    .projection(projection)\n+                    .sort(Document(\"hello\", 1))\n+            assertEquals(doc1, findOne(Document(), options1).blockingGetResult()!!.withoutId())\n+\n+            val options2 = FindOptions()\n+                    .limit(2)\n+                    .projection(projection)\n+                    .sort(Document(\"hello\", -1))\n+            assertEquals(doc3.withoutId(), findOne(Document(), options2).blockingGetResult()!!.withoutId())\n+\n+            assertFails { findOne(Document(\"\\$who\", 1)).blockingGetResult() }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "479cc8dfe47b6822f050f20c8b5ec748fb76f756"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk2MjkwNg==", "bodyText": "Yes, that exception handling is part of my next commit.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r430962906", "createdAt": "2020-05-27T08:57:18Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -228,37 +224,26 @@ class MongoCollectionTest {\n             // Test findOne() with filter that does not match any documents and no options\n             assertNull(findOne(Document(\"hello\", \"worldDNE\")).blockingGetResult())\n \n-            // FIXME: revisit when parser is fully operational\n             // Insert 2 more documents into the collection\n-//            insertMany(listOf(doc2, doc3)).blockingGetResult()    // use insertOne for now\n-            insertOne(doc2).blockingGetResult()\n-            insertOne(doc3).blockingGetResult()\n+            insertMany(listOf(doc2, doc3)).blockingGetResult()\n             assertEquals(3, count().blockingGetResult())\n \n-//            // test findOne() with projection and sort options\n-//            val projection = Document(\"hello\", 1)\n-//            projection[\"_id\"] = 0\n-//            val options1 = FindOptions()\n-//                    .limit(2)\n-//                    .projection(projection)\n-//                    .sort(Document(\"hello\", 1))\n-//            assertEquals(doc1, findOne(Document(), options1).blockingGetResult()!!.withoutId())\n-//\n-//            val options2 = FindOptions()\n-//                    .limit(2)\n-//                    .projection(projection)\n-//                    .sort(Document(\"hello\", -1))\n-//            assertEquals(doc3.withoutId(), findOne(Document(), options2).blockingGetResult()!!.withoutId())\n-//\n-//            // test findOne() properly fails\n-//            try {\n-//                Tasks.await(coll.findOne(Document(\"\\$who\", 1)))\n-//                Assert.fail()\n-//            } catch (ex: ExecutionException) {\n-//                Assert.assertTrue(ex.cause is StitchServiceException)\n-//                val svcEx = ex.cause as StitchServiceException\n-//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n-//            }\n+            // test findOne() with projection and sort options\n+            val projection = Document(\"hello\", 1)\n+            projection[\"_id\"] = 0\n+            val options1 = FindOptions()\n+                    .limit(2)\n+                    .projection(projection)\n+                    .sort(Document(\"hello\", 1))\n+            assertEquals(doc1, findOne(Document(), options1).blockingGetResult()!!.withoutId())\n+\n+            val options2 = FindOptions()\n+                    .limit(2)\n+                    .projection(projection)\n+                    .sort(Document(\"hello\", -1))\n+            assertEquals(doc3.withoutId(), findOne(Document(), options2).blockingGetResult()!!.withoutId())\n+\n+            assertFails { findOne(Document(\"\\$who\", 1)).blockingGetResult() }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5NzQ2OQ=="}, "originalCommit": {"oid": "479cc8dfe47b6822f050f20c8b5ec748fb76f756"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4Mzk2MzQyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsAggregateIterable.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzoxMjo1MlrOGa8OvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzoxMjo1MlrOGa8OvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwMjk3Mw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r430902973", "createdAt": "2020-05-27T07:12:52Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsAggregateIterable.cpp", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include \"io_realm_internal_objectstore_OsAggregateIterable.h\"\n+\n+#include \"java_class_global_def.hpp\"\n+#include \"java_network_transport.hpp\"\n+#include \"util.hpp\"\n+#include \"jni_util/java_method.hpp\"\n+#include \"jni_util/jni_utils.hpp\"\n+#include \"jni_util/bson_util.hpp\"\n+#include \"object-store/src/util/bson/bson.hpp\"\n+\n+#include <realm/util/optional.hpp>\n+#include <sync/app.hpp>\n+#include <sync/sync_user.hpp>\n+#include <sync/remote_mongo_database.hpp>\n+#include <sync/remote_mongo_collection.hpp>\n+#include <jni_util/bson_util.hpp>\n+#include <jni.h>\n+\n+using namespace realm;\n+using namespace realm::app;\n+using namespace realm::bson;\n+using namespace realm::jni_util;\n+using namespace realm::_impl;\n+\n+static std::function<jobject(JNIEnv*, util::Optional<bson::BsonArray>)> collection_mapper_aggregate = [](JNIEnv* env, util::Optional<bson::BsonArray> array) {\n+    return array ? JniBsonProtocol::bson_to_jstring(env, *array) : NULL;\n+};\n+\n+JNIEXPORT void JNICALL\n+Java_io_realm_internal_objectstore_OsAggregateIterable_nativeAggregate(JNIEnv* env,\n+                                                                       jclass,\n+                                                                       jlong j_collection_ptr,\n+                                                                       jstring j_pipeline,\n+                                                                       jobject j_callback) {\n+    try {\n+        auto collection = reinterpret_cast<RemoteMongoCollection *>(j_collection_ptr);\n+\n+        BsonArray bson_array(JniBsonProtocol::parse_checked(env, j_pipeline, Bson::Type::Array, \"BSON pipeline must be a BsonArray\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "479cc8dfe47b6822f050f20c8b5ec748fb76f756"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDA0NDkyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/MongoIterable.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzozODoxM1rOGa9CDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTozMTo0MVrOGeXtMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxNjEwOA==", "bodyText": "Should the new iterator refetch the collection? From the Javadoc of the class it sounds a bit like the class is encapsulating a specific query result.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r430916108", "createdAt": "2020-05-27T07:38:13Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/MongoIterable.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb.mongo.iterable;\n+\n+import com.google.android.gms.tasks.Task;\n+\n+import java.util.Collection;\n+\n+import io.realm.internal.common.TaskDispatcher;\n+\n+/**\n+ * The MongoIterable is the results from an operation, such as a query.\n+ *\n+ * @param <ResultT> The type that this iterable will decode documents to.\n+ */\n+public abstract class MongoIterable<ResultT> {\n+\n+    private final TaskDispatcher dispatcher;\n+\n+    MongoIterable(final TaskDispatcher dispatcher) {\n+        this.dispatcher = dispatcher;\n+    }\n+\n+    /**\n+     * Gets the collection from the Object Store.\n+     * @return collection with the results from the Object Store.\n+     */\n+    abstract Collection<ResultT> getCollection();\n+\n+    /**\n+     * Gets the first entry in the result collection\n+     * @return first entry in the collection.\n+     */\n+    abstract ResultT getFirst();\n+\n+    /**\n+     * Returns a cursor of the operation represented by this iterable.\n+     *\n+     * @return a cursor of the operation represented by this iterable.\n+     */\n+    public Task<MongoCursor<ResultT>> iterator() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "479cc8dfe47b6822f050f20c8b5ec748fb76f756"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDQzOA==", "bodyText": "The Javadoc might not be the best. I should probably rewrite it. This class is not a Java Iterable, although it tries to mimic its behaviour. The results need to be delivered as Tasks though. This also affects the MongoCursor class, whose implementation I've changed for the next commit. It didn't need the second level of asynchronicity.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r430980438", "createdAt": "2020-05-27T09:24:59Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/MongoIterable.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb.mongo.iterable;\n+\n+import com.google.android.gms.tasks.Task;\n+\n+import java.util.Collection;\n+\n+import io.realm.internal.common.TaskDispatcher;\n+\n+/**\n+ * The MongoIterable is the results from an operation, such as a query.\n+ *\n+ * @param <ResultT> The type that this iterable will decode documents to.\n+ */\n+public abstract class MongoIterable<ResultT> {\n+\n+    private final TaskDispatcher dispatcher;\n+\n+    MongoIterable(final TaskDispatcher dispatcher) {\n+        this.dispatcher = dispatcher;\n+    }\n+\n+    /**\n+     * Gets the collection from the Object Store.\n+     * @return collection with the results from the Object Store.\n+     */\n+    abstract Collection<ResultT> getCollection();\n+\n+    /**\n+     * Gets the first entry in the result collection\n+     * @return first entry in the collection.\n+     */\n+    abstract ResultT getFirst();\n+\n+    /**\n+     * Returns a cursor of the operation represented by this iterable.\n+     *\n+     * @return a cursor of the operation represented by this iterable.\n+     */\n+    public Task<MongoCursor<ResultT>> iterator() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxNjEwOA=="}, "originalCommit": {"oid": "479cc8dfe47b6822f050f20c8b5ec748fb76f756"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ5ODg2NA==", "bodyText": "Is it intended that calling this multiple times should trigger multiple remote operations? Maybe I am still a bit confused with the various collection/iterable terms.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r434498864", "createdAt": "2020-06-03T11:31:41Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/MongoIterable.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb.mongo.iterable;\n+\n+import com.google.android.gms.tasks.Task;\n+\n+import java.util.Collection;\n+\n+import io.realm.internal.common.TaskDispatcher;\n+\n+/**\n+ * The MongoIterable is the results from an operation, such as a query.\n+ *\n+ * @param <ResultT> The type that this iterable will decode documents to.\n+ */\n+public abstract class MongoIterable<ResultT> {\n+\n+    private final TaskDispatcher dispatcher;\n+\n+    MongoIterable(final TaskDispatcher dispatcher) {\n+        this.dispatcher = dispatcher;\n+    }\n+\n+    /**\n+     * Gets the collection from the Object Store.\n+     * @return collection with the results from the Object Store.\n+     */\n+    abstract Collection<ResultT> getCollection();\n+\n+    /**\n+     * Gets the first entry in the result collection\n+     * @return first entry in the collection.\n+     */\n+    abstract ResultT getFirst();\n+\n+    /**\n+     * Returns a cursor of the operation represented by this iterable.\n+     *\n+     * @return a cursor of the operation represented by this iterable.\n+     */\n+    public Task<MongoCursor<ResultT>> iterator() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxNjEwOA=="}, "originalCommit": {"oid": "479cc8dfe47b6822f050f20c8b5ec748fb76f756"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDA1MzU0OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/MongoCursor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzo0MDo0OVrOGa9HUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzo0MDo0OVrOGa9HUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxNzQ1OQ==", "bodyText": "Inconsistent Javadoc formattting here and there.\nFirst line should end with a period and subsequent paragraphs should be separated by <p>.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r430917459", "createdAt": "2020-05-27T07:40:49Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/MongoCursor.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb.mongo.iterable;\n+\n+import com.google.android.gms.tasks.Task;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import io.realm.internal.common.TaskDispatcher;\n+\n+/**\n+ * The Mongo Cursor interface.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "479cc8dfe47b6822f050f20c8b5ec748fb76f756"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDExNzExOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzo1OTowOFrOGa9waw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMjowNTo1NFrOGbGKFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkyNzk3OQ==", "bodyText": "Remember to verify that encode works with null", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r430927979", "createdAt": "2020-05-27T07:59:08Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "diffHunk": "@@ -406,61 +467,51 @@ protected ResultT mapSuccess(Object result) {\n \n         String encodedFilter = JniBsonProtocol.encode(filter, codecRegistry);\n         String encodedUpdate = JniBsonProtocol.encode(update, codecRegistry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "479cc8dfe47b6822f050f20c8b5ec748fb76f756"}, "originalPosition": 551}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2NTYyMQ==", "bodyText": "Doesn't apply any longer.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r431065621", "createdAt": "2020-05-27T12:05:54Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "diffHunk": "@@ -406,61 +467,51 @@ protected ResultT mapSuccess(Object result) {\n \n         String encodedFilter = JniBsonProtocol.encode(filter, codecRegistry);\n         String encodedUpdate = JniBsonProtocol.encode(update, codecRegistry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkyNzk3OQ=="}, "originalCommit": {"oid": "479cc8dfe47b6822f050f20c8b5ec748fb76f756"}, "originalPosition": 551}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDEyNTM5OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwODowMToyOFrOGa91uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwODowMToyOFrOGa91uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkyOTMzNg==", "bodyText": "Shouldn't this be IllegalArgumentException? Here and other places", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r430929336", "createdAt": "2020-05-27T08:01:28Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "diffHunk": "@@ -406,61 +467,51 @@ protected ResultT mapSuccess(Object result) {\n \n         String encodedFilter = JniBsonProtocol.encode(filter, codecRegistry);\n         String encodedUpdate = JniBsonProtocol.encode(update, codecRegistry);\n-        String encodedProjection = null;\n-        String encodedSort = null;\n+        String encodedProjection = encodedEmptyDocument;\n+        String encodedSort = encodedEmptyDocument;\n         if (options != null) {\n-            encodedProjection = JniBsonProtocol.encode(options.getProjection(), codecRegistry);\n-            encodedSort = JniBsonProtocol.encode(options.getSort(), codecRegistry);\n+            if (options.getProjection() != null) {\n+                encodedProjection = JniBsonProtocol.encode(options.getProjection(), codecRegistry);\n+            }\n+            if (options.getSort() != null) {\n+                encodedSort = JniBsonProtocol.encode(options.getSort(), codecRegistry);\n+            }\n         }\n \n         switch (type) {\n-            case UPDATE:\n+            case FIND_ONE_AND_UPDATE:\n+                nativeFindOneAndUpdate(type, nativePtr, encodedFilter, encodedUpdate, encodedProjection, encodedSort, false, false, callback);\n+                break;\n+            case FIND_ONE_AND_UPDATE_WITH_OPTIONS:\n                 if (options == null) {\n-                    nativeFindOneAndUpdate(nativePtr, encodedFilter, encodedUpdate, callback);\n-                } else {\n-                    nativeFindOneAndUpdateWithOptions(nativePtr, encodedFilter, encodedUpdate, encodedProjection, encodedSort, options.isUpsert(), options.isReturnNewDocument(), callback);\n+                    throw new IllegalStateException(\"FindOneAndModifyOptions must not be null\");\n                 }\n+                nativeFindOneAndUpdate(type, nativePtr, encodedFilter, encodedUpdate, encodedProjection, encodedSort, options.isUpsert(), options.isReturnNewDocument(), callback);\n+                break;\n+            case FIND_ONE_AND_REPLACE:\n+                nativeFindOneAndReplace(type, nativePtr, encodedFilter, encodedUpdate, encodedProjection, encodedSort, false, false,callback);\n                 break;\n-            case REPLACE:\n+            case FIND_ONE_AND_REPLACE_WITH_OPTIONS:\n                 if (options == null) {\n-                    nativeFindOneAndReplace(nativePtr, encodedFilter, encodedUpdate, callback);\n-                } else {\n-                    nativeFindOneAndReplaceWithOptions(nativePtr, encodedFilter, encodedUpdate, encodedProjection, encodedSort, options.isUpsert(), options.isReturnNewDocument(), callback);\n+                    throw new IllegalStateException(\"FindOneAndModifyOptions must not be null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "479cc8dfe47b6822f050f20c8b5ec748fb76f756"}, "originalPosition": 590}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDEzOTcwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwODowNTo1MlrOGa9_Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwOTo0NTozMFrOGbBsZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkzMTczNQ==", "bodyText": "Did you intentionally remove the public possibility to call count with options without filter?", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r430931735", "createdAt": "2020-05-27T08:05:52Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "diffHunk": "@@ -73,14 +90,18 @@ public long getNativeFinalizerPtr() {\n     }\n \n     public Long count() {\n-        return count(null);\n+        return countInternal(new Document(), null);\n+    }\n+\n+    public Long count(final Bson filter) {\n+        return countInternal(filter, null);\n     }\n \n-    public Long count(@Nullable final Bson filter) {\n-        return count(filter, null);\n+    public Long count(final Bson filter, final CountOptions options) {\n+        return countInternal(filter, options);\n     }\n \n-    public Long count(@Nullable final Bson filter, @Nullable final CountOptions options) {\n+    private Long countInternal(final Bson filter, @Nullable final CountOptions options) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "479cc8dfe47b6822f050f20c8b5ec748fb76f756"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MjQ4NA==", "bodyText": "It was a mistake, it never was part of the original API.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r430992484", "createdAt": "2020-05-27T09:45:30Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "diffHunk": "@@ -73,14 +90,18 @@ public long getNativeFinalizerPtr() {\n     }\n \n     public Long count() {\n-        return count(null);\n+        return countInternal(new Document(), null);\n+    }\n+\n+    public Long count(final Bson filter) {\n+        return countInternal(filter, null);\n     }\n \n-    public Long count(@Nullable final Bson filter) {\n-        return count(filter, null);\n+    public Long count(final Bson filter, final CountOptions options) {\n+        return countInternal(filter, options);\n     }\n \n-    public Long count(@Nullable final Bson filter, @Nullable final CountOptions options) {\n+    private Long countInternal(final Bson filter, @Nullable final CountOptions options) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkzMTczNQ=="}, "originalCommit": {"oid": "479cc8dfe47b6822f050f20c8b5ec748fb76f756"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDE2Mzk1OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsMongoCollection.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwODoxMjo1M1rOGa-Ovw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwOTozOToyMVrOGbBfCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkzNTc0Mw==", "bodyText": "Maybe throw an error if it is an unexpected type, as you do in some of the other similar methods.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r430935743", "createdAt": "2020-05-27T08:12:53Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsMongoCollection.cpp", "diffHunk": "@@ -116,41 +116,36 @@ Java_io_realm_internal_objectstore_OsMongoCollection_nativeCount(JNIEnv* env,\n JNIEXPORT void JNICALL\n Java_io_realm_internal_objectstore_OsMongoCollection_nativeFindOne(JNIEnv* env,\n                                                                    jclass,\n+                                                                   jint j_find_one_type,\n                                                                    jlong j_collection_ptr,\n                                                                    jstring j_filter,\n+                                                                   jstring j_projection,\n+                                                                   jstring j_sort,\n+                                                                   jlong j_limit,\n                                                                    jobject j_callback) {\n     try {\n         auto collection = reinterpret_cast<RemoteMongoCollection*>(j_collection_ptr);\n \n         bson::BsonDocument filter(JniBsonProtocol::parse_checked(env, j_filter, Bson::Type::Document, \"BSON filter must be a Document\"));\n-        collection->find_one(filter, JavaNetworkTransport::create_result_callback(env, j_callback, collection_mapper_find_one));\n-    }\n-    CATCH_STD()\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_io_realm_internal_objectstore_OsMongoCollection_nativeFindOneWithOptions(JNIEnv* env,\n-                                                                              jclass,\n-                                                                              jlong j_collection_ptr,\n-                                                                              jstring j_filter,\n-                                                                              jstring j_projection,\n-                                                                              jstring j_sort,\n-                                                                              jlong j_limit,\n-                                                                              jobject j_callback) {\n-    try {\n-        auto collection = reinterpret_cast<RemoteMongoCollection*>(j_collection_ptr);\n-        uint64_t limit = std::uint64_t(j_limit);\n \n-        bson::BsonDocument filter(JniBsonProtocol::parse_checked(env, j_filter, Bson::Type::Document, \"BSON filter must be a Document\"));\n-        bson::BsonDocument projection(JniBsonProtocol::parse_checked(env, j_projection, Bson::Type::Document, \"BSON projection must be a Document\"));\n-        bson::BsonDocument sort(JniBsonProtocol::parse_checked(env, j_sort, Bson::Type::Document, \"BSON sort must be a Document\"));\n-        RemoteMongoCollection::RemoteFindOptions options = {\n-                limit,\n-                projection,\n-                sort\n-        };\n-\n-        collection->find_one(filter, options, JavaNetworkTransport::create_result_callback(env, j_callback, collection_mapper_find_one));\n+        switch (j_find_one_type) {\n+            case io_realm_internal_objectstore_OsMongoCollection_FIND_ONE:\n+                collection->find_one(filter, JavaNetworkTransport::create_result_callback(env, j_callback, collection_mapper_find_one));\n+                break;\n+            case io_realm_internal_objectstore_OsMongoCollection_FIND_ONE_WITH_OPTIONS:\n+                uint64_t limit = std::uint64_t(j_limit);\n+\n+                bson::BsonDocument projection(JniBsonProtocol::parse_checked(env, j_projection, Bson::Type::Document, \"BSON projection must be a Document\"));\n+                bson::BsonDocument sort(JniBsonProtocol::parse_checked(env, j_sort, Bson::Type::Document, \"BSON sort must be a Document\"));\n+                RemoteMongoCollection::RemoteFindOptions options = {\n+                        limit,\n+                        projection,\n+                        sort\n+                };\n+\n+                collection->find_one(filter, options, JavaNetworkTransport::create_result_callback(env, j_callback, collection_mapper_find_one));\n+                break;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c0a9b00fb4571bc460247d8aee25307192fd799"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4OTA2Ng==", "bodyText": "Yes, totally forgot about it.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r430989066", "createdAt": "2020-05-27T09:39:21Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsMongoCollection.cpp", "diffHunk": "@@ -116,41 +116,36 @@ Java_io_realm_internal_objectstore_OsMongoCollection_nativeCount(JNIEnv* env,\n JNIEXPORT void JNICALL\n Java_io_realm_internal_objectstore_OsMongoCollection_nativeFindOne(JNIEnv* env,\n                                                                    jclass,\n+                                                                   jint j_find_one_type,\n                                                                    jlong j_collection_ptr,\n                                                                    jstring j_filter,\n+                                                                   jstring j_projection,\n+                                                                   jstring j_sort,\n+                                                                   jlong j_limit,\n                                                                    jobject j_callback) {\n     try {\n         auto collection = reinterpret_cast<RemoteMongoCollection*>(j_collection_ptr);\n \n         bson::BsonDocument filter(JniBsonProtocol::parse_checked(env, j_filter, Bson::Type::Document, \"BSON filter must be a Document\"));\n-        collection->find_one(filter, JavaNetworkTransport::create_result_callback(env, j_callback, collection_mapper_find_one));\n-    }\n-    CATCH_STD()\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_io_realm_internal_objectstore_OsMongoCollection_nativeFindOneWithOptions(JNIEnv* env,\n-                                                                              jclass,\n-                                                                              jlong j_collection_ptr,\n-                                                                              jstring j_filter,\n-                                                                              jstring j_projection,\n-                                                                              jstring j_sort,\n-                                                                              jlong j_limit,\n-                                                                              jobject j_callback) {\n-    try {\n-        auto collection = reinterpret_cast<RemoteMongoCollection*>(j_collection_ptr);\n-        uint64_t limit = std::uint64_t(j_limit);\n \n-        bson::BsonDocument filter(JniBsonProtocol::parse_checked(env, j_filter, Bson::Type::Document, \"BSON filter must be a Document\"));\n-        bson::BsonDocument projection(JniBsonProtocol::parse_checked(env, j_projection, Bson::Type::Document, \"BSON projection must be a Document\"));\n-        bson::BsonDocument sort(JniBsonProtocol::parse_checked(env, j_sort, Bson::Type::Document, \"BSON sort must be a Document\"));\n-        RemoteMongoCollection::RemoteFindOptions options = {\n-                limit,\n-                projection,\n-                sort\n-        };\n-\n-        collection->find_one(filter, options, JavaNetworkTransport::create_result_callback(env, j_callback, collection_mapper_find_one));\n+        switch (j_find_one_type) {\n+            case io_realm_internal_objectstore_OsMongoCollection_FIND_ONE:\n+                collection->find_one(filter, JavaNetworkTransport::create_result_callback(env, j_callback, collection_mapper_find_one));\n+                break;\n+            case io_realm_internal_objectstore_OsMongoCollection_FIND_ONE_WITH_OPTIONS:\n+                uint64_t limit = std::uint64_t(j_limit);\n+\n+                bson::BsonDocument projection(JniBsonProtocol::parse_checked(env, j_projection, Bson::Type::Document, \"BSON projection must be a Document\"));\n+                bson::BsonDocument sort(JniBsonProtocol::parse_checked(env, j_sort, Bson::Type::Document, \"BSON sort must be a Document\"));\n+                RemoteMongoCollection::RemoteFindOptions options = {\n+                        limit,\n+                        projection,\n+                        sort\n+                };\n+\n+                collection->find_one(filter, options, JavaNetworkTransport::create_result_callback(env, j_callback, collection_mapper_find_one));\n+                break;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkzNTc0Mw=="}, "originalCommit": {"oid": "2c0a9b00fb4571bc460247d8aee25307192fd799"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDE4NjcxOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoIterable.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwODoxOToxNlrOGa-dMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjo1MzoxOFrOGcQ0og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkzOTQ0MA==", "bodyText": "Seems to remember some comment about only using Os-prefix if it actually wrapped an underlying OS object.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r430939440", "createdAt": "2020-05-27T08:19:16Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoIterable.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.objectstore;\n+\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.ObjectServerError;\n+import io.realm.internal.jni.JniBsonProtocol;\n+import io.realm.internal.jni.OsJNIResultCallback;\n+import io.realm.internal.network.ResultHandler;\n+\n+public abstract class OsMongoIterable<ResultT> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c0a9b00fb4571bc460247d8aee25307192fd799"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MTYzNg==", "bodyText": "I talked about it with @cmelchior and it's OK to use it for helper classes which don't instantiate objects - unless I misunderstood it @cmelchior?", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r430981636", "createdAt": "2020-05-27T09:27:00Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoIterable.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.objectstore;\n+\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.ObjectServerError;\n+import io.realm.internal.jni.JniBsonProtocol;\n+import io.realm.internal.jni.OsJNIResultCallback;\n+import io.realm.internal.network.ResultHandler;\n+\n+public abstract class OsMongoIterable<ResultT> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkzOTQ0MA=="}, "originalCommit": {"oid": "2c0a9b00fb4571bc460247d8aee25307192fd799"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4MjI1Nw==", "bodyText": "I think there was a bit of a misunderstanding then. Normally we only use Os<X> for classes wrapping some ObjectStore class. I believe we chatted about finalizers? \ud83e\udd14\nSo, in this case, it should probably be merged with the public MongoIterable", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432282257", "createdAt": "2020-05-29T06:34:33Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoIterable.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.objectstore;\n+\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.ObjectServerError;\n+import io.realm.internal.jni.JniBsonProtocol;\n+import io.realm.internal.jni.OsJNIResultCallback;\n+import io.realm.internal.network.ResultHandler;\n+\n+public abstract class OsMongoIterable<ResultT> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkzOTQ0MA=="}, "originalCommit": {"oid": "2c0a9b00fb4571bc460247d8aee25307192fd799"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4ODkzMA==", "bodyText": "Sure, I'll get it done.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432288930", "createdAt": "2020-05-29T06:53:18Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoIterable.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.objectstore;\n+\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.ObjectServerError;\n+import io.realm.internal.jni.JniBsonProtocol;\n+import io.realm.internal.jni.OsJNIResultCallback;\n+import io.realm.internal.network.ResultHandler;\n+\n+public abstract class OsMongoIterable<ResultT> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkzOTQ0MA=="}, "originalCommit": {"oid": "2c0a9b00fb4571bc460247d8aee25307192fd799"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDIwODg1OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwODoyNToxMFrOGa-rLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwOTozMDowM1rOGbBJTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk0MzAyMg==", "bodyText": "Does this double asynchronicity make sense? Doesn't it only involve one remote call?", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r430943022", "createdAt": "2020-05-27T08:25:10Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -389,66 +363,151 @@ class MongoCollectionTest {\n             doc3[\"num\"] = 3\n \n             // Test the upsert option where it should not actually be invoked\n-            val result2 = findOneAndUpdate(Document(\"hello\", \"hellothere\"), Document(\"\\$set\", doc1), FindOneAndModifyOptions().returnNewDocument(true).upsert(true)).blockingGetResult()\n+            val options2 = FindOneAndModifyOptions()\n+                    .returnNewDocument(true)\n+                    .upsert(true)\n+            val result2 = findOneAndUpdate(\n+                    Document(\"hello\", \"hellothere\"),\n+                    Document(\"\\$set\", doc1),\n+                    options2\n+            ).blockingGetResult()\n             assertEquals(doc1, result2!!.withoutId())\n             assertEquals(1, count().blockingGetResult())\n-//            assertEquals(doc1.withoutId(), withoutId(Tasks.await(coll.find().first())))\n+            assertEquals(doc1.withoutId(),\n+                    find().first().blockingGetResult()!!.withoutId())\n \n             // Test the upsert option where the server should perform upsert and return new document\n-            val result3 = findOneAndUpdate(Document(\"hello\", \"hellothere\"), Document(\"\\$set\", doc2), FindOneAndModifyOptions().returnNewDocument(true).upsert(true)).blockingGetResult()\n+            val options3 = FindOneAndModifyOptions()\n+                    .returnNewDocument(true)\n+                    .upsert(true)\n+            val result3 = findOneAndUpdate(\n+                    Document(\"hello\", \"hellothere\"),\n+                    Document(\"\\$set\", doc2),\n+                    options3\n+            ).blockingGetResult()\n             assertEquals(doc2, result3!!.withoutId())\n             assertEquals(2, count().blockingGetResult())\n \n             // Test the upsert option where the server should perform upsert and return old document\n             // The old document should be empty\n-            val result4 = findOneAndUpdate(Document(\"hello\", \"hellothere\"), Document(\"\\$set\", doc3), FindOneAndModifyOptions().upsert(true)).blockingGetResult()\n+            val options4 = FindOneAndModifyOptions()\n+                    .upsert(true)\n+            val result4= findOneAndUpdate(\n+                    Document(\"hello\", \"hellothere\"),\n+                    Document(\"\\$set\", doc3),\n+                    options4\n+            ).blockingGetResult()\n             assertNull(result4)\n             assertEquals(3, count().blockingGetResult())\n \n-            // Test sort and project\n-//            assertEquals(listOf(doc1, doc2, doc3),\n-//                    withoutIds(Tasks.await<MutableList<Document>>(coll.find().into(mutableListOf()))))\n-\n-            val sampleProject = Document(\"hello\", 1)\n-            sampleProject[\"_id\"] = 0\n-\n-            val result5 = findOneAndUpdate(Document(), sampleUpdate, FindOneAndModifyOptions().projection(sampleProject).sort(Document(\"num\", 1))).blockingGetResult()\n-            assertEquals(Document(\"hello\", \"world1\"), result5!!.withoutId())\n-            assertEquals(3, count().blockingGetResult())\n-\n-            val result6 = findOneAndUpdate(Document(), sampleUpdate, FindOneAndModifyOptions().projection(sampleProject).sort(Document(\"num\", -1))).blockingGetResult()\n-            assertEquals(Document(\"hello\", \"world3\"), result6!!.withoutId())\n-            assertEquals(3, count().blockingGetResult())\n+            // FIXME: projections and sort aren't currently working due to a bug in Stitch: https://jira.mongodb.org/browse/REALMC-5787\n+//            // Test sort and project\n+//            val sampleProject = Document(\"hello\", 1)\n+//            sampleProject[\"_id\"] = 0\n+//\n+//            val options5 = FindOneAndModifyOptions()\n+//                    .projection(sampleProject)\n+//                    .sort(Document(\"num\", 1))\n+//            val result5 = findOneAndUpdate(\n+//                    Document(),\n+//                    sampleUpdate,\n+//                    options5\n+//            ).blockingGetResult()\n+//            assertEquals(Document(\"hello\", \"world1\"), result5!!.withoutId())\n+//            assertEquals(3, count().blockingGetResult())\n+//\n+//            val options6 = FindOneAndModifyOptions()\n+//                    .projection(sampleProject)\n+//                    .sort(Document(\"num\", -1))\n+//            val result6 = findOneAndUpdate(\n+//                    Document(),\n+//                    sampleUpdate,\n+//                    options6\n+//            ).blockingGetResult()\n+//            assertEquals(Document(\"hello\", \"world3\"), result6!!.withoutId())\n+//            assertEquals(3, count().blockingGetResult())\n \n             // Test proper failure\n-//            try {\n-//                Tasks.await(coll.findOneAndUpdate(Document(), Document(\"\\$who\", 1)))\n-//                fail()\n-//            } catch (ex: ExecutionException) {\n-//                assertTrue(ex.cause is StitchServiceException)\n-//                val svcEx = ex.cause as StitchServiceException\n-//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n-//            }\n-//\n-//            try {\n-//                Tasks.await(coll.findOneAndUpdate(Document(), Document(\"\\$who\", 1),\n-//                        FindOneAndModifyOptions().upsert(true)))\n-//                fail()\n-//            } catch (ex: ExecutionException) {\n-//                assertTrue(ex.cause is StitchServiceException)\n-//                val svcEx = ex.cause as StitchServiceException\n-//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n-//            }\n+            assertFails { findOneAndUpdate(Document(), Document(\"\\$who\", 1)).blockingGetResult() }\n+            assertFails { findOneAndUpdate(Document(), Document(\"\\$who\", 1), FindOneAndModifyOptions().upsert(true)).blockingGetResult() }\n         }\n     }\n \n     @Test\n     fun find() {\n         with(getCollectionInternal(COLLECTION_NAME)) {\n-            // FIXME: fix find implementation - ignore this code for code review\n-            val iter = find().blockingGetResult()!!\n-            assertFalse(iter.iterator().hasNext())\n-            assertFailsWith<NoSuchElementException> { iter.first() }\n+            var iter = find()\n+            assertFalse(iter.iterator().blockingGetResult()!!.hasNext().blockingGetResult()!!)\n+            assertNull(iter.first().blockingGetResult())\n+\n+            val doc1 = Document(\"hello\", \"world\")\n+            val doc2 = Document(\"hello\", \"friend\")\n+            doc2[\"proj\"] = \"field\"\n+            insertMany(listOf(doc1, doc2)).blockingGetResult()\n+\n+            assertTrue(iter.iterator().blockingGetResult()!!\n+                    .hasNext().blockingGetResult()!!)\n+            assertEquals(doc1.withoutId(), iter.first().blockingGetResult()!!.withoutId())\n+            assertEquals(doc2.withoutId(),\n+                    iter.limit(1)\n+                            .sort(Document(\"_id\", -1))\n+                            .iterator().blockingGetResult()!!\n+                            .next().blockingGetResult()!!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c0a9b00fb4571bc460247d8aee25307192fd799"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MzUwMA==", "bodyText": "That's right. I have changed it for the next commit - see https://github.com/realm/realm-java/pull/6881/files#r430916108", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r430983500", "createdAt": "2020-05-27T09:30:03Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -389,66 +363,151 @@ class MongoCollectionTest {\n             doc3[\"num\"] = 3\n \n             // Test the upsert option where it should not actually be invoked\n-            val result2 = findOneAndUpdate(Document(\"hello\", \"hellothere\"), Document(\"\\$set\", doc1), FindOneAndModifyOptions().returnNewDocument(true).upsert(true)).blockingGetResult()\n+            val options2 = FindOneAndModifyOptions()\n+                    .returnNewDocument(true)\n+                    .upsert(true)\n+            val result2 = findOneAndUpdate(\n+                    Document(\"hello\", \"hellothere\"),\n+                    Document(\"\\$set\", doc1),\n+                    options2\n+            ).blockingGetResult()\n             assertEquals(doc1, result2!!.withoutId())\n             assertEquals(1, count().blockingGetResult())\n-//            assertEquals(doc1.withoutId(), withoutId(Tasks.await(coll.find().first())))\n+            assertEquals(doc1.withoutId(),\n+                    find().first().blockingGetResult()!!.withoutId())\n \n             // Test the upsert option where the server should perform upsert and return new document\n-            val result3 = findOneAndUpdate(Document(\"hello\", \"hellothere\"), Document(\"\\$set\", doc2), FindOneAndModifyOptions().returnNewDocument(true).upsert(true)).blockingGetResult()\n+            val options3 = FindOneAndModifyOptions()\n+                    .returnNewDocument(true)\n+                    .upsert(true)\n+            val result3 = findOneAndUpdate(\n+                    Document(\"hello\", \"hellothere\"),\n+                    Document(\"\\$set\", doc2),\n+                    options3\n+            ).blockingGetResult()\n             assertEquals(doc2, result3!!.withoutId())\n             assertEquals(2, count().blockingGetResult())\n \n             // Test the upsert option where the server should perform upsert and return old document\n             // The old document should be empty\n-            val result4 = findOneAndUpdate(Document(\"hello\", \"hellothere\"), Document(\"\\$set\", doc3), FindOneAndModifyOptions().upsert(true)).blockingGetResult()\n+            val options4 = FindOneAndModifyOptions()\n+                    .upsert(true)\n+            val result4= findOneAndUpdate(\n+                    Document(\"hello\", \"hellothere\"),\n+                    Document(\"\\$set\", doc3),\n+                    options4\n+            ).blockingGetResult()\n             assertNull(result4)\n             assertEquals(3, count().blockingGetResult())\n \n-            // Test sort and project\n-//            assertEquals(listOf(doc1, doc2, doc3),\n-//                    withoutIds(Tasks.await<MutableList<Document>>(coll.find().into(mutableListOf()))))\n-\n-            val sampleProject = Document(\"hello\", 1)\n-            sampleProject[\"_id\"] = 0\n-\n-            val result5 = findOneAndUpdate(Document(), sampleUpdate, FindOneAndModifyOptions().projection(sampleProject).sort(Document(\"num\", 1))).blockingGetResult()\n-            assertEquals(Document(\"hello\", \"world1\"), result5!!.withoutId())\n-            assertEquals(3, count().blockingGetResult())\n-\n-            val result6 = findOneAndUpdate(Document(), sampleUpdate, FindOneAndModifyOptions().projection(sampleProject).sort(Document(\"num\", -1))).blockingGetResult()\n-            assertEquals(Document(\"hello\", \"world3\"), result6!!.withoutId())\n-            assertEquals(3, count().blockingGetResult())\n+            // FIXME: projections and sort aren't currently working due to a bug in Stitch: https://jira.mongodb.org/browse/REALMC-5787\n+//            // Test sort and project\n+//            val sampleProject = Document(\"hello\", 1)\n+//            sampleProject[\"_id\"] = 0\n+//\n+//            val options5 = FindOneAndModifyOptions()\n+//                    .projection(sampleProject)\n+//                    .sort(Document(\"num\", 1))\n+//            val result5 = findOneAndUpdate(\n+//                    Document(),\n+//                    sampleUpdate,\n+//                    options5\n+//            ).blockingGetResult()\n+//            assertEquals(Document(\"hello\", \"world1\"), result5!!.withoutId())\n+//            assertEquals(3, count().blockingGetResult())\n+//\n+//            val options6 = FindOneAndModifyOptions()\n+//                    .projection(sampleProject)\n+//                    .sort(Document(\"num\", -1))\n+//            val result6 = findOneAndUpdate(\n+//                    Document(),\n+//                    sampleUpdate,\n+//                    options6\n+//            ).blockingGetResult()\n+//            assertEquals(Document(\"hello\", \"world3\"), result6!!.withoutId())\n+//            assertEquals(3, count().blockingGetResult())\n \n             // Test proper failure\n-//            try {\n-//                Tasks.await(coll.findOneAndUpdate(Document(), Document(\"\\$who\", 1)))\n-//                fail()\n-//            } catch (ex: ExecutionException) {\n-//                assertTrue(ex.cause is StitchServiceException)\n-//                val svcEx = ex.cause as StitchServiceException\n-//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n-//            }\n-//\n-//            try {\n-//                Tasks.await(coll.findOneAndUpdate(Document(), Document(\"\\$who\", 1),\n-//                        FindOneAndModifyOptions().upsert(true)))\n-//                fail()\n-//            } catch (ex: ExecutionException) {\n-//                assertTrue(ex.cause is StitchServiceException)\n-//                val svcEx = ex.cause as StitchServiceException\n-//                assertEquals(StitchServiceErrorCode.MONGODB_ERROR, svcEx.errorCode)\n-//            }\n+            assertFails { findOneAndUpdate(Document(), Document(\"\\$who\", 1)).blockingGetResult() }\n+            assertFails { findOneAndUpdate(Document(), Document(\"\\$who\", 1), FindOneAndModifyOptions().upsert(true)).blockingGetResult() }\n         }\n     }\n \n     @Test\n     fun find() {\n         with(getCollectionInternal(COLLECTION_NAME)) {\n-            // FIXME: fix find implementation - ignore this code for code review\n-            val iter = find().blockingGetResult()!!\n-            assertFalse(iter.iterator().hasNext())\n-            assertFailsWith<NoSuchElementException> { iter.first() }\n+            var iter = find()\n+            assertFalse(iter.iterator().blockingGetResult()!!.hasNext().blockingGetResult()!!)\n+            assertNull(iter.first().blockingGetResult())\n+\n+            val doc1 = Document(\"hello\", \"world\")\n+            val doc2 = Document(\"hello\", \"friend\")\n+            doc2[\"proj\"] = \"field\"\n+            insertMany(listOf(doc1, doc2)).blockingGetResult()\n+\n+            assertTrue(iter.iterator().blockingGetResult()!!\n+                    .hasNext().blockingGetResult()!!)\n+            assertEquals(doc1.withoutId(), iter.first().blockingGetResult()!!.withoutId())\n+            assertEquals(doc2.withoutId(),\n+                    iter.limit(1)\n+                            .sort(Document(\"_id\", -1))\n+                            .iterator().blockingGetResult()!!\n+                            .next().blockingGetResult()!!", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk0MzAyMg=="}, "originalCommit": {"oid": "2c0a9b00fb4571bc460247d8aee25307192fd799"}, "originalPosition": 372}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDU4NjE5OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDowODowMVrOGbCfdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDowODowMVrOGbCfdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAwNTU1OQ==", "bodyText": "I will remove this, it stays for now until all the OS bugs are fixed.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r431005559", "createdAt": "2020-05-27T10:08:01Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -51,6 +54,9 @@ class MongoCollectionTest {\n     @Before\n     fun setUp() {\n         Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+\n+        RealmLog.setLevel(LogLevel.DEBUG)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a15eb8d43df6751f8c77a89710b8f57588352a94"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDU4ODE3OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDowODozNFrOGbCgkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDowODozNFrOGbCgkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAwNTg0Mg==", "bodyText": "I will also break down some of the tests into smaller, more meaningful cases in the upcoming commits.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r431005842", "createdAt": "2020-05-27T10:08:34Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoCollectionTest.kt", "diffHunk": "@@ -51,6 +54,9 @@ class MongoCollectionTest {\n     @Before\n     fun setUp() {\n         Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a15eb8d43df6751f8c77a89710b8f57588352a94"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDYxNjIyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDoxNzoyMFrOGbCy5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDoxNzoyMFrOGbCy5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMDUzMw==", "bodyText": "I will remove these separators. I added them for temporary convenience to quickly see the different operation blocks.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r431010533", "createdAt": "2020-05-27T10:17:20Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "diffHunk": "@@ -90,99 +111,142 @@ protected Long mapSuccess(Object result) {\n             }\n         };\n \n-        // no filter means count all\n-        String filterString = (filter == null) ?\n-                JniBsonProtocol.encode(new Document(), codecRegistry) :\n-                JniBsonProtocol.encode(filter, codecRegistry);\n+        String filterString = JniBsonProtocol.encode(filter, codecRegistry);\n         int limit = (options == null) ? 0 : options.getLimit();\n \n         nativeCount(nativePtr, filterString, limit, callback);\n \n         return ResultHandler.handleResult(success, error);\n     }\n \n-    public Collection<DocumentT> find() {\n-        return find(new Document());\n-    }\n+    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a15eb8d43df6751f8c77a89710b8f57588352a94"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQyOTY3OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjoyNjo0M1rOGcQQXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjoyNjo0M1rOGcQQXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3OTY0Ng==", "bodyText": "We have Util.checkNull(val, args) for this kind of common checks", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432279646", "createdAt": "2020-05-29T06:26:43Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "diffHunk": "@@ -221,42 +306,114 @@ protected InsertManyResult mapSuccess(Object result) {\n         return ResultHandler.handleResult(success, error);\n     }\n \n+    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n     public DeleteResult deleteOne(final Bson filter) {\n-        return deleteInternal(DeleteType.ONE, filter);\n+        return deleteInternal(DELETE_ONE, filter);\n     }\n \n     public DeleteResult deleteMany(final Bson filter) {\n-        return deleteInternal(DeleteType.MANY, filter);\n+        return deleteInternal(DELETE_MANY, filter);\n     }\n \n+    private DeleteResult deleteInternal(final int type, final Bson filter) {\n+        AtomicReference<DeleteResult> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<DeleteResult> callback = new OsJNIResultCallback<DeleteResult>(success, error) {\n+            @Override\n+            protected DeleteResult mapSuccess(Object result) {\n+                return new DeleteResult((Long) result);\n+            }\n+        };\n+\n+        String jsonDocument = JniBsonProtocol.encode(filter, codecRegistry);\n+        switch (type) {\n+            case DELETE_ONE:\n+                nativeDelete(DELETE_ONE, nativePtr, jsonDocument, callback);\n+                break;\n+            case DELETE_MANY:\n+                nativeDelete(DELETE_MANY, nativePtr, jsonDocument, callback);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid delete type: \" + type);\n+        }\n+        return ResultHandler.handleResult(success, error);\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n     public UpdateResult updateOne(final Bson filter, final Bson update) {\n-        return updateOne(filter, update, null);\n+        return updateInternal(UPDATE_ONE, filter, update, null);\n     }\n \n     public UpdateResult updateOne(final Bson filter,\n                                   final Bson update,\n-                                  @Nullable final UpdateOptions options) {\n-        return updateInternal(UpdateType.ONE, filter, update, options);\n+                                  final UpdateOptions options) {\n+        return updateInternal(UPDATE_ONE_WITH_OPTIONS, filter, update, options);\n     }\n \n     public UpdateResult updateMany(final Bson filter, final Bson update) {\n-        return updateMany(filter, update, null);\n+        return updateInternal(UPDATE_MANY, filter, update, null);\n     }\n \n     public UpdateResult updateMany(final Bson filter,\n                                    final Bson update,\n-                                   @Nullable final UpdateOptions options) {\n-        return updateInternal(UpdateType.MANY, filter, update, options);\n+                                   final UpdateOptions options) {\n+        return updateInternal(UPDATE_MANY_WITH_OPTIONS, filter, update, options);\n     }\n \n+    private UpdateResult updateInternal(final int type,\n+                                        final Bson filter,\n+                                        final Bson update,\n+                                        @Nullable final UpdateOptions options) {\n+        AtomicReference<UpdateResult> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        OsJNIResultCallback<UpdateResult> callback = new OsJNIResultCallback<UpdateResult>(success, error) {\n+            @Override\n+            protected UpdateResult mapSuccess(Object result) {\n+                BsonArray array = JniBsonProtocol.decode((String) result, BsonArray.class, codecRegistry);\n+                long matchedCount = array.get(0).asInt32().getValue();\n+                long modifiedCount = array.get(1).asInt32().getValue();\n+                BsonValue upsertedId = array.get(2);\n+\n+                if (upsertedId instanceof BsonNull) {\n+                    upsertedId = null;\n+                }\n+                return new UpdateResult(matchedCount, modifiedCount, upsertedId);\n+            }\n+        };\n+\n+        String jsonFilter = JniBsonProtocol.encode(filter, codecRegistry);\n+        String jsonUpdate = JniBsonProtocol.encode(update, codecRegistry);\n+\n+        switch (type) {\n+            case UPDATE_ONE:\n+            case UPDATE_MANY:\n+                nativeUpdate(type, nativePtr, jsonFilter, jsonUpdate, false, callback);\n+                break;\n+            case UPDATE_ONE_WITH_OPTIONS:\n+            case UPDATE_MANY_WITH_OPTIONS:\n+                if (options == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 389}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQ0NzY5OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjozNToyNlrOGcQbsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjozNToyNlrOGcQbsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4MjU0NQ==", "bodyText": "Wrapping looks wrong here", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432282545", "createdAt": "2020-05-29T06:35:26Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -62,7 +66,30 @@\n      * @return the namespace\n      */\n     public MongoNamespace getNamespace() {\n-        throw new RuntimeException(\"Not Implemented\");\n+        return nameSpace;\n+    }\n+\n+    /**\n+     * Get the class of documents stored in this collection.\n+     * <p>\n+     * If you used the simple {@link MongoDatabase#getCollection(String)} to get\n+     * this collection,\n+     * this is {@link org.bson.Document}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQ0ODM4OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjozNTo0NFrOGcQcIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjozNTo0NFrOGcQcIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4MjY1OQ==", "bodyText": "This description doesn't say much. Should probably be expanded a bit.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432282659", "createdAt": "2020-05-29T06:35:44Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -62,7 +66,30 @@\n      * @return the namespace\n      */\n     public MongoNamespace getNamespace() {\n-        throw new RuntimeException(\"Not Implemented\");\n+        return nameSpace;\n+    }\n+\n+    /**\n+     * Get the class of documents stored in this collection.\n+     * <p>\n+     * If you used the simple {@link MongoDatabase#getCollection(String)} to get\n+     * this collection,\n+     * this is {@link org.bson.Document}.\n+     * </p>\n+     *\n+     * @return the class", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQ1MTQ5OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjozNzoyMVrOGcQeQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjozNzoyMVrOGcQeQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4MzIwMA==", "bodyText": "This kind of JavaDoc doesn't really say anything the types dont already. I would probably rephrase to @return the {@link CodecRegistry}  for this collection.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432283200", "createdAt": "2020-05-29T06:37:21Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -62,7 +66,30 @@\n      * @return the namespace\n      */\n     public MongoNamespace getNamespace() {\n-        throw new RuntimeException(\"Not Implemented\");\n+        return nameSpace;\n+    }\n+\n+    /**\n+     * Get the class of documents stored in this collection.\n+     * <p>\n+     * If you used the simple {@link MongoDatabase#getCollection(String)} to get\n+     * this collection,\n+     * this is {@link org.bson.Document}.\n+     * </p>\n+     *\n+     * @return the class\n+     */\n+    public Class<DocumentT> getDocumentClass() {\n+        return osMongoCollection.getDocumentClass();\n+    }\n+\n+    /**\n+     * Get the codec registry for the RemoteMongoCollection.\n+     *\n+     * @return the {@link CodecRegistry}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQ1MjkyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjozNzo1M1rOGcQfAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwOTo0MDo1MFrOGcV7lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4MzM5Mw==", "bodyText": "Not sure what this means?", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432283393", "createdAt": "2020-05-29T06:37:53Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -212,18 +234,18 @@ public MongoNamespace getNamespace() {\n      *\n      * @return the find iterable interface\n      */\n-    // FIXME: fix find implementation - ignore this code for code review\n-    public Task<Iterable<DocumentT>> find() {\n-        return dispatcher.dispatchTask(() ->\n-                osMongoCollection.find()\n-        );\n+    public FindIterable<DocumentT> find() {\n+        return new FindIterable<>(dispatcher, osMongoCollection.find());\n     }\n \n-    // FIXME: fix find implementation - ignore this code for code review\n-    public Task<Iterable<DocumentT>> find(final FindOptions options) {\n-        return dispatcher.dispatchTask(() ->\n-                osMongoCollection.find(options)\n-        );\n+    /**\n+     * Finds all documents in the collection that match the given filter.\n+     *\n+     * @param options a {@link FindOptions} struct\n+     * @return the find iterable interface", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM3MjYzMQ==", "bodyText": "It is the wrong description, it should specify that it uses options to build the query.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432372631", "createdAt": "2020-05-29T09:40:50Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -212,18 +234,18 @@ public MongoNamespace getNamespace() {\n      *\n      * @return the find iterable interface\n      */\n-    // FIXME: fix find implementation - ignore this code for code review\n-    public Task<Iterable<DocumentT>> find() {\n-        return dispatcher.dispatchTask(() ->\n-                osMongoCollection.find()\n-        );\n+    public FindIterable<DocumentT> find() {\n+        return new FindIterable<>(dispatcher, osMongoCollection.find());\n     }\n \n-    // FIXME: fix find implementation - ignore this code for code review\n-    public Task<Iterable<DocumentT>> find(final FindOptions options) {\n-        return dispatcher.dispatchTask(() ->\n-                osMongoCollection.find(options)\n-        );\n+    /**\n+     * Finds all documents in the collection that match the given filter.\n+     *\n+     * @param options a {@link FindOptions} struct\n+     * @return the find iterable interface", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4MzM5Mw=="}, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQ1MzIzOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjozODowNVrOGcQfOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjozODowNVrOGcQfOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4MzQ0OA==", "bodyText": "Same for this and most other JavaDoc....this description doesn't say much.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432283448", "createdAt": "2020-05-29T06:38:05Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -233,18 +255,21 @@ public MongoNamespace getNamespace() {\n      * @param <ResultT>   the target document type of the iterable.\n      * @return the find iterable interface\n      */\n-    // FIXME: fix find implementation - ignore this code for code review\n-    public <ResultT> Task<Iterable<ResultT>> find(final Class<ResultT> resultClass) {\n-        return dispatcher.dispatchTask(() ->\n-                osMongoCollection.find(resultClass)\n-        );\n+    public <ResultT> FindIterable<ResultT> find(final Class<ResultT> resultClass) {\n+        return new FindIterable<>(dispatcher, osMongoCollection.find(resultClass));\n     }\n \n-    // FIXME: fix find implementation - ignore this code for code review\n-    public <ResultT> Task<Iterable<ResultT>> find(final Class<ResultT> resultClass, final FindOptions options) {\n-        return dispatcher.dispatchTask(() ->\n-                osMongoCollection.find(resultClass, options)\n-        );\n+    /**\n+     * Finds all documents in the collection that match the given filter.\n+     *\n+     * @param resultClass the class to decode each document into\n+     * @param options a {@link FindOptions} struct\n+     * @param <ResultT>   the target document type of the iterable.\n+     * @return the find iterable interface", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQ2MjIzOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/AggregateIterable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjo0MjoyMVrOGcQkyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMDowMTo0M1rOGcWmsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4NDg3Mg==", "bodyText": "Missing Javadoc", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432284872", "createdAt": "2020-05-29T06:42:21Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/AggregateIterable.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb.mongo.iterable;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import io.realm.internal.common.TaskDispatcher;\n+import io.realm.internal.objectstore.OsAggregateIterable;\n+import io.realm.mongodb.mongo.MongoCollection;\n+\n+/**\n+ * Specific iterable for {@link MongoCollection#aggregate(List)} operations.\n+ *\n+ * @param <ResultT> The type to which this iterable will decode documents.\n+ */\n+public class AggregateIterable<ResultT> extends MongoIterable<ResultT> {\n+\n+    private OsAggregateIterable<ResultT> osAggregateIterable;\n+\n+    public AggregateIterable(final TaskDispatcher dispatcher,\n+                             final OsAggregateIterable<ResultT> osAggregateIterable) {\n+        super(dispatcher);\n+        this.osAggregateIterable = osAggregateIterable;\n+    }\n+\n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4MzY2Ng==", "bodyText": "Becomes a private method after removing the unnecessary OS classes.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432383666", "createdAt": "2020-05-29T10:01:43Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/AggregateIterable.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb.mongo.iterable;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import io.realm.internal.common.TaskDispatcher;\n+import io.realm.internal.objectstore.OsAggregateIterable;\n+import io.realm.mongodb.mongo.MongoCollection;\n+\n+/**\n+ * Specific iterable for {@link MongoCollection#aggregate(List)} operations.\n+ *\n+ * @param <ResultT> The type to which this iterable will decode documents.\n+ */\n+public class AggregateIterable<ResultT> extends MongoIterable<ResultT> {\n+\n+    private OsAggregateIterable<ResultT> osAggregateIterable;\n+\n+    public AggregateIterable(final TaskDispatcher dispatcher,\n+                             final OsAggregateIterable<ResultT> osAggregateIterable) {\n+        super(dispatcher);\n+        this.osAggregateIterable = osAggregateIterable;\n+    }\n+\n+    @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4NDg3Mg=="}, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQ2MjUyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/AggregateIterable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjo0MjoyNlrOGcQk8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMDowMTo1MFrOGcWm-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4NDkxMw==", "bodyText": "Same", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432284913", "createdAt": "2020-05-29T06:42:26Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/AggregateIterable.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb.mongo.iterable;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import io.realm.internal.common.TaskDispatcher;\n+import io.realm.internal.objectstore.OsAggregateIterable;\n+import io.realm.mongodb.mongo.MongoCollection;\n+\n+/**\n+ * Specific iterable for {@link MongoCollection#aggregate(List)} operations.\n+ *\n+ * @param <ResultT> The type to which this iterable will decode documents.\n+ */\n+public class AggregateIterable<ResultT> extends MongoIterable<ResultT> {\n+\n+    private OsAggregateIterable<ResultT> osAggregateIterable;\n+\n+    public AggregateIterable(final TaskDispatcher dispatcher,\n+                             final OsAggregateIterable<ResultT> osAggregateIterable) {\n+        super(dispatcher);\n+        this.osAggregateIterable = osAggregateIterable;\n+    }\n+\n+    @Override\n+    Collection<ResultT> getCollection() {\n+        return osAggregateIterable.getCollection();\n+    }\n+\n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4MzczNg==", "bodyText": "Same as above.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432383736", "createdAt": "2020-05-29T10:01:50Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/AggregateIterable.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb.mongo.iterable;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import io.realm.internal.common.TaskDispatcher;\n+import io.realm.internal.objectstore.OsAggregateIterable;\n+import io.realm.mongodb.mongo.MongoCollection;\n+\n+/**\n+ * Specific iterable for {@link MongoCollection#aggregate(List)} operations.\n+ *\n+ * @param <ResultT> The type to which this iterable will decode documents.\n+ */\n+public class AggregateIterable<ResultT> extends MongoIterable<ResultT> {\n+\n+    private OsAggregateIterable<ResultT> osAggregateIterable;\n+\n+    public AggregateIterable(final TaskDispatcher dispatcher,\n+                             final OsAggregateIterable<ResultT> osAggregateIterable) {\n+        super(dispatcher);\n+        this.osAggregateIterable = osAggregateIterable;\n+    }\n+\n+    @Override\n+    Collection<ResultT> getCollection() {\n+        return osAggregateIterable.getCollection();\n+    }\n+\n+    @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4NDkxMw=="}, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQ2MzIwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/FindIterable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjo0Mjo0MVrOGcQlVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMDowMjowNVrOGcWncA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4NTAxNA==", "bodyText": "Javadoc", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432285014", "createdAt": "2020-05-29T06:42:41Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/FindIterable.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb.mongo.iterable;\n+\n+import org.bson.conversions.Bson;\n+\n+import java.util.Collection;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.common.TaskDispatcher;\n+import io.realm.internal.objectstore.OsFindIterable;\n+import io.realm.mongodb.mongo.MongoCollection;\n+\n+/**\n+ * Specific iterable for {@link MongoCollection#find()} operations.\n+ *\n+ * @param <ResultT> The type to which this iterable will decode documents.\n+ */\n+public class FindIterable<ResultT> extends MongoIterable<ResultT> {\n+\n+    private final OsFindIterable<ResultT> osFindIterable;\n+\n+    public FindIterable(final TaskDispatcher dispatcher,\n+                        final OsFindIterable<ResultT> osFindIterable) {\n+        super(dispatcher);\n+        this.osFindIterable = osFindIterable;\n+    }\n+\n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4Mzg1Ng==", "bodyText": "Same as above.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432383856", "createdAt": "2020-05-29T10:02:05Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/FindIterable.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb.mongo.iterable;\n+\n+import org.bson.conversions.Bson;\n+\n+import java.util.Collection;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.common.TaskDispatcher;\n+import io.realm.internal.objectstore.OsFindIterable;\n+import io.realm.mongodb.mongo.MongoCollection;\n+\n+/**\n+ * Specific iterable for {@link MongoCollection#find()} operations.\n+ *\n+ * @param <ResultT> The type to which this iterable will decode documents.\n+ */\n+public class FindIterable<ResultT> extends MongoIterable<ResultT> {\n+\n+    private final OsFindIterable<ResultT> osFindIterable;\n+\n+    public FindIterable(final TaskDispatcher dispatcher,\n+                        final OsFindIterable<ResultT> osFindIterable) {\n+        super(dispatcher);\n+        this.osFindIterable = osFindIterable;\n+    }\n+\n+    @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4NTAxNA=="}, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQ2MzM4OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/FindIterable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjo0Mjo0NlrOGcQldA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjo0Mjo0NlrOGcQldA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4NTA0NA==", "bodyText": "Javadoc", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432285044", "createdAt": "2020-05-29T06:42:46Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/FindIterable.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb.mongo.iterable;\n+\n+import org.bson.conversions.Bson;\n+\n+import java.util.Collection;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.common.TaskDispatcher;\n+import io.realm.internal.objectstore.OsFindIterable;\n+import io.realm.mongodb.mongo.MongoCollection;\n+\n+/**\n+ * Specific iterable for {@link MongoCollection#find()} operations.\n+ *\n+ * @param <ResultT> The type to which this iterable will decode documents.\n+ */\n+public class FindIterable<ResultT> extends MongoIterable<ResultT> {\n+\n+    private final OsFindIterable<ResultT> osFindIterable;\n+\n+    public FindIterable(final TaskDispatcher dispatcher,\n+                        final OsFindIterable<ResultT> osFindIterable) {\n+        super(dispatcher);\n+        this.osFindIterable = osFindIterable;\n+    }\n+\n+    @Override\n+    Collection<ResultT> getCollection() {\n+        return osFindIterable.getCollection();\n+    }\n+\n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQ2NDkxOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/MongoCursor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjo0MzoyNFrOGcQmZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjo0MzoyNFrOGcQmZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4NTI4NA==", "bodyText": "This doesn't say anything the name of the class doesn't. Maybe expand on what the class actually is for?", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432285284", "createdAt": "2020-05-29T06:43:24Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/MongoCursor.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb.mongo.iterable;\n+\n+import com.google.android.gms.tasks.Task;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * The Mongo Cursor class.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQ2NTk5OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/MongoCursor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjo0NDowMVrOGcQnIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzoyMDozNVrOGcRf3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4NTQ3Mg==", "bodyText": "This doesn't look right, it returns a ResultT?", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432285472", "createdAt": "2020-05-29T06:44:01Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/MongoCursor.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb.mongo.iterable;\n+\n+import com.google.android.gms.tasks.Task;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * The Mongo Cursor class.\n+ * <p>\n+ * An application should ensure that a cursor is closed in all circumstances, e.g. using a\n+ * try-with-resources statement.\n+ *\n+ * @param <ResultT> The type of documents the cursor contains\n+ */\n+public class MongoCursor<ResultT> implements Iterator<ResultT> {\n+\n+    private final Iterator<ResultT> iterator;\n+\n+    MongoCursor(Iterator<ResultT> iterator) {\n+        this.iterator = iterator;\n+    }\n+\n+    /**\n+     * Returns whether or not there is a next document to retrieve with {@code next()}.\n+     *\n+     * @return A {@link Task} containing whether or not there is a next document to\n+     * retrieve with {@code next()}.\n+     */\n+    @Override\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    /**\n+     * Returns the next document.\n+     *\n+     * @return A {@link Task} containing the next document if available or a failed task with", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5OTk5OA==", "bodyText": "Possible paste error when took the description from Stitch.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432299998", "createdAt": "2020-05-29T07:20:35Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/MongoCursor.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb.mongo.iterable;\n+\n+import com.google.android.gms.tasks.Task;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * The Mongo Cursor class.\n+ * <p>\n+ * An application should ensure that a cursor is closed in all circumstances, e.g. using a\n+ * try-with-resources statement.\n+ *\n+ * @param <ResultT> The type of documents the cursor contains\n+ */\n+public class MongoCursor<ResultT> implements Iterator<ResultT> {\n+\n+    private final Iterator<ResultT> iterator;\n+\n+    MongoCursor(Iterator<ResultT> iterator) {\n+        this.iterator = iterator;\n+    }\n+\n+    /**\n+     * Returns whether or not there is a next document to retrieve with {@code next()}.\n+     *\n+     * @return A {@link Task} containing whether or not there is a next document to\n+     * retrieve with {@code next()}.\n+     */\n+    @Override\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    /**\n+     * Returns the next document.\n+     *\n+     * @return A {@link Task} containing the next document if available or a failed task with", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4NTQ3Mg=="}, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQ2NzYwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/MongoIterable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjo0NDo0N1rOGcQoKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjo0NDo0N1rOGcQoKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4NTczNg==", "bodyText": "Good description \ud83d\udc4d", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r432285736", "createdAt": "2020-05-29T06:44:47Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/iterable/MongoIterable.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb.mongo.iterable;\n+\n+import com.google.android.gms.tasks.Task;\n+\n+import java.util.Collection;\n+\n+import io.realm.internal.common.TaskDispatcher;\n+\n+/**\n+ * The MongoIterable is the results from an operation, such as a query.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb3bbf33f6f9892af8da0107f1eb5496eec247b"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjU0OTI5OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo0MjowM1rOGeYBYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo0MjowM1rOGeYBYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwNDAzNQ==", "bodyText": "I recall adding getters for App and User on Functions for convenience. But can't recall the use case...maybe something like functions.getApp().getConfiguration().getDefaultCodecRegistry().\nMaybe we should consider adding these for consistency. @cmelchior can you remember the use case?", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r434504035", "createdAt": "2020-06-03T11:42:03Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoClient.java", "diffHunk": "@@ -18,21 +18,25 @@\n \n import org.bson.codecs.configuration.CodecRegistry;\n \n-import io.realm.mongodb.User;\n import io.realm.internal.Util;\n+import io.realm.internal.common.TaskDispatcher;\n import io.realm.internal.objectstore.OsMongoClient;\n \n /**\n  * The remote MongoClient used for working with data in MongoDB remotely via Realm.\n  */\n abstract public class MongoClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cedf0a03dbcdc1fa715c83a4249864ac21e5c998"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjU3MjUzOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo0OTozMFrOGeYP-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo0OTozMFrOGeYP-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwNzc2OQ==", "bodyText": "There is already a assertFailsWithErrorCode(expectedCode: ErrorCode, method: () -> Unit) in KotlinTestUtils.kt maybe build on top of that. Could be changes in to a chain'able construct, so you could assert further details like you do.", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r434507769", "createdAt": "2020-06-03T11:49:30Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt", "diffHunk": "@@ -0,0 +1,1076 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.Realm\n+import io.realm.TestApp\n+import io.realm.TestHelper\n+import io.realm.mongodb.mongo.MongoClient\n+import io.realm.mongodb.mongo.MongoCollection\n+import io.realm.mongodb.mongo.MongoNamespace\n+import io.realm.mongodb.mongo.options.CountOptions\n+import io.realm.mongodb.mongo.options.FindOneAndModifyOptions\n+import io.realm.mongodb.mongo.options.FindOptions\n+import io.realm.mongodb.mongo.options.UpdateOptions\n+import io.realm.util.blockingGetResult\n+import io.realm.util.mongodb.CustomType\n+import org.bson.Document\n+import org.bson.codecs.configuration.CodecRegistries\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Ignore\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.*\n+\n+private const val SERVICE_NAME = \"BackingDB\"    // it comes from the test server's BackingDB/config.json\n+private const val DATABASE_NAME = \"test_data\"   // same as above\n+private const val COLLECTION_NAME = \"test_data\"\n+\n+@RunWith(AndroidJUnit4::class)\n+class MongoClientTest {\n+\n+    private lateinit var app: TestApp\n+    private lateinit var user: User\n+    private lateinit var client: MongoClient\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getMongoClient(SERVICE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        with(getCollectionInternal()) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal()) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(\"hello\", \"world\")\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"hello\", \"Friend\")).blockingGetResult())\n+            assertEquals(1, count(rawDoc, CountOptions().limit(1)).blockingGetResult())\n+\n+            assertFailsWith(ObjectServerError::class) {\n+                count(Document(\"\\$who\", 1)).blockingGetResult()\n+            }.also { e ->\n+                assertEquals(ErrorCode.MONGODB_ERROR, e.errorCode)\n+                assertNotNull(e.errorMessage)\n+                assertTrue(e.errorMessage!!.contains(\"operator\", true))\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun count_fails() {\n+        with(getCollectionInternal()) {\n+            assertFailsWith(ObjectServerError::class) {\n+                count(Document(\"\\$who\", 1)).blockingGetResult()\n+            }.also { e ->\n+                assertEquals(ErrorCode.MONGODB_ERROR, e.errorCode)\n+                assertNotNull(e.errorMessage)\n+                assertTrue(e.errorMessage!!.contains(\"operator\", true))\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun findOne_nullResult() {\n+        with(getCollectionInternal()) {\n+            // Test findOne() on empty collection with no filter and no options\n+            assertNull(findOne().blockingGetResult())\n+\n+            // Test findOne() with filter that does not match any documents and no options\n+            assertNull(findOne(Document(\"hello\", \"worldDNE\")).blockingGetResult())\n+\n+            val doc1 = Document(\"hello\", \"world1\")\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Test findOne() with filter that does not match any documents and no options\n+            assertNull(findOne(Document(\"hello\", \"worldDNE\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun findOne_singleDocument() {\n+        with(getCollectionInternal()) {\n+            val doc1 = Document(\"hello\", \"world1\")\n+\n+            // Insert one document\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // No filter and no options\n+            assertEquals(doc1, findOne().blockingGetResult()!!.withoutId())\n+\n+            // Projection (remove \"_id\") options\n+            val projection = Document(\"hello\", 1).apply { this[\"_id\"] = 0 }\n+            var options = FindOptions()\n+                    .limit(2)\n+                    .projection(projection)\n+            assertEquals(doc1, findOne(Document(), options).blockingGetResult()!!)\n+\n+            // Projection (remove \"_id\") and sort (by desc \"hello\") options\n+            options = FindOptions()\n+                    .limit(2)\n+                    .projection(projection)\n+                    .sort(Document(\"hello\", -1))\n+            assertEquals(doc1, findOne(Document(), options).blockingGetResult()!!)\n+        }\n+    }\n+\n+    @Test\n+    fun findOne_multipleDocuments() {\n+        with(getCollectionInternal()) {\n+            val doc1 = Document(\"hello\", \"world1\")\n+            val doc2 = Document(\"hello\", \"world2\")\n+            val doc3 = Document(\"hello\", \"world3\")\n+\n+            // Insert 3 documents\n+            insertMany(listOf(doc1, doc2, doc3)).blockingGetResult()\n+            assertEquals(3, count().blockingGetResult())\n+\n+            // Projection (remove \"_id\") and sort (by asc \"hello\") options\n+            val projection = Document(\"hello\", 1).apply { this[\"_id\"] = 0 }\n+            var options = FindOptions()\n+                    .limit(2)\n+                    .projection(projection)\n+                    .sort(Document(\"hello\", 1))\n+            assertEquals(doc1, findOne(Document(), options).blockingGetResult()!!)\n+\n+            // Projection (remove \"_id\") and sort (by desc \"hello\") options\n+            options = FindOptions()\n+                    .limit(2)\n+                    .projection(projection)\n+                    .sort(Document(\"hello\", -1))\n+            assertEquals(doc3, findOne(Document(), options).blockingGetResult()!!)\n+        }\n+    }\n+\n+    @Test\n+    fun findOne_fails() {\n+        with(getCollectionInternal()) {\n+            assertFailsWith(ObjectServerError::class) {\n+                findOne(Document(\"\\$who\", 1)).blockingGetResult()\n+            }.also { e ->\n+                assertEquals(ErrorCode.MONGODB_ERROR, e.errorCode)\n+                assertNotNull(e.errorMessage)\n+                assertTrue(e.errorMessage!!.contains(\"operator\", true))\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun find() {\n+        with(getCollectionInternal()) {\n+            // Find on an empty collection returns false on hasNext and null on first\n+            var iter = find()\n+            assertFalse(iter.iterator().blockingGetResult()!!.hasNext())\n+            assertNull(iter.first().blockingGetResult())\n+\n+            val doc1 = Document(\"hello\", \"world\")\n+            val doc2 = Document(\"hello\", \"friend\")\n+            doc2[\"proj\"] = \"field\"\n+            insertMany(listOf(doc1, doc2)).blockingGetResult()\n+\n+            // Iterate after inserting two documents\n+            assertTrue(iter.iterator().blockingGetResult()!!.hasNext())\n+            assertEquals(doc1, iter.first().blockingGetResult()!!.withoutId())\n+\n+            // Get next with sort by desc \"_id\" and limit to 1 document\n+            assertEquals(doc2,\n+                    iter.limit(1)\n+                            .sort(Document(\"_id\", -1))\n+                            .iterator().blockingGetResult()!!\n+                            .next().withoutId())\n+\n+            // Find first document\n+            iter = find(doc1)\n+            assertTrue(iter.iterator().blockingGetResult()!!.hasNext())\n+            assertEquals(doc1,\n+                    iter.iterator().blockingGetResult()!!\n+                            .next().withoutId())\n+\n+            // Find with filter for first document\n+            iter = find().filter(doc1)\n+            assertTrue(iter.iterator().blockingGetResult()!!.hasNext())\n+            assertEquals(doc1,\n+                    iter.iterator().blockingGetResult()!!\n+                            .next().withoutId())\n+\n+            // Find with projection shows \"proj\" in result\n+            val expected = Document(\"proj\", \"field\")\n+            assertEquals(expected,\n+                    find(doc2)\n+                            .projection(Document(\"proj\", 1))\n+                            .iterator().blockingGetResult()!!\n+                            .next().withoutId())\n+\n+            // Getting a new iterator returns first element on tryNext\n+            val asyncIter = iter.iterator().blockingGetResult()!!\n+            assertEquals(doc1, asyncIter.tryNext().withoutId())\n+        }\n+    }\n+\n+    @Test\n+    fun find_fails() {\n+        with(getCollectionInternal()) {\n+            assertFailsWith(ObjectServerError::class) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cedf0a03dbcdc1fa715c83a4249864ac21e5c998"}, "originalPosition": 254}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjU3NDQwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo1MDowNVrOGeYRIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo1MDowNVrOGeYRIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwODA2NQ==", "bodyText": "Same", "url": "https://github.com/realm/realm-java/pull/6881#discussion_r434508065", "createdAt": "2020-06-03T11:50:05Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt", "diffHunk": "@@ -0,0 +1,1076 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.mongodb\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.Realm\n+import io.realm.TestApp\n+import io.realm.TestHelper\n+import io.realm.mongodb.mongo.MongoClient\n+import io.realm.mongodb.mongo.MongoCollection\n+import io.realm.mongodb.mongo.MongoNamespace\n+import io.realm.mongodb.mongo.options.CountOptions\n+import io.realm.mongodb.mongo.options.FindOneAndModifyOptions\n+import io.realm.mongodb.mongo.options.FindOptions\n+import io.realm.mongodb.mongo.options.UpdateOptions\n+import io.realm.util.blockingGetResult\n+import io.realm.util.mongodb.CustomType\n+import org.bson.Document\n+import org.bson.codecs.configuration.CodecRegistries\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Ignore\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import kotlin.test.*\n+\n+private const val SERVICE_NAME = \"BackingDB\"    // it comes from the test server's BackingDB/config.json\n+private const val DATABASE_NAME = \"test_data\"   // same as above\n+private const val COLLECTION_NAME = \"test_data\"\n+\n+@RunWith(AndroidJUnit4::class)\n+class MongoClientTest {\n+\n+    private lateinit var app: TestApp\n+    private lateinit var user: User\n+    private lateinit var client: MongoClient\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        client = user.getMongoClient(SERVICE_NAME)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        with(getCollectionInternal()) {\n+            deleteMany(Document()).blockingGetResult()\n+        }\n+\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun count() {\n+        with(getCollectionInternal()) {\n+            assertEquals(0, count().blockingGetResult())\n+\n+            val rawDoc = Document(\"hello\", \"world\")\n+            val doc1 = Document(rawDoc)\n+            val doc2 = Document(rawDoc)\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+            insertOne(doc2).blockingGetResult()\n+            assertEquals(2, count().blockingGetResult())\n+\n+            assertEquals(2, count(rawDoc).blockingGetResult())\n+            assertEquals(0, count(Document(\"hello\", \"Friend\")).blockingGetResult())\n+            assertEquals(1, count(rawDoc, CountOptions().limit(1)).blockingGetResult())\n+\n+            assertFailsWith(ObjectServerError::class) {\n+                count(Document(\"\\$who\", 1)).blockingGetResult()\n+            }.also { e ->\n+                assertEquals(ErrorCode.MONGODB_ERROR, e.errorCode)\n+                assertNotNull(e.errorMessage)\n+                assertTrue(e.errorMessage!!.contains(\"operator\", true))\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun count_fails() {\n+        with(getCollectionInternal()) {\n+            assertFailsWith(ObjectServerError::class) {\n+                count(Document(\"\\$who\", 1)).blockingGetResult()\n+            }.also { e ->\n+                assertEquals(ErrorCode.MONGODB_ERROR, e.errorCode)\n+                assertNotNull(e.errorMessage)\n+                assertTrue(e.errorMessage!!.contains(\"operator\", true))\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun findOne_nullResult() {\n+        with(getCollectionInternal()) {\n+            // Test findOne() on empty collection with no filter and no options\n+            assertNull(findOne().blockingGetResult())\n+\n+            // Test findOne() with filter that does not match any documents and no options\n+            assertNull(findOne(Document(\"hello\", \"worldDNE\")).blockingGetResult())\n+\n+            val doc1 = Document(\"hello\", \"world1\")\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // Test findOne() with filter that does not match any documents and no options\n+            assertNull(findOne(Document(\"hello\", \"worldDNE\")).blockingGetResult())\n+        }\n+    }\n+\n+    @Test\n+    fun findOne_singleDocument() {\n+        with(getCollectionInternal()) {\n+            val doc1 = Document(\"hello\", \"world1\")\n+\n+            // Insert one document\n+            insertOne(doc1).blockingGetResult()\n+            assertEquals(1, count().blockingGetResult())\n+\n+            // No filter and no options\n+            assertEquals(doc1, findOne().blockingGetResult()!!.withoutId())\n+\n+            // Projection (remove \"_id\") options\n+            val projection = Document(\"hello\", 1).apply { this[\"_id\"] = 0 }\n+            var options = FindOptions()\n+                    .limit(2)\n+                    .projection(projection)\n+            assertEquals(doc1, findOne(Document(), options).blockingGetResult()!!)\n+\n+            // Projection (remove \"_id\") and sort (by desc \"hello\") options\n+            options = FindOptions()\n+                    .limit(2)\n+                    .projection(projection)\n+                    .sort(Document(\"hello\", -1))\n+            assertEquals(doc1, findOne(Document(), options).blockingGetResult()!!)\n+        }\n+    }\n+\n+    @Test\n+    fun findOne_multipleDocuments() {\n+        with(getCollectionInternal()) {\n+            val doc1 = Document(\"hello\", \"world1\")\n+            val doc2 = Document(\"hello\", \"world2\")\n+            val doc3 = Document(\"hello\", \"world3\")\n+\n+            // Insert 3 documents\n+            insertMany(listOf(doc1, doc2, doc3)).blockingGetResult()\n+            assertEquals(3, count().blockingGetResult())\n+\n+            // Projection (remove \"_id\") and sort (by asc \"hello\") options\n+            val projection = Document(\"hello\", 1).apply { this[\"_id\"] = 0 }\n+            var options = FindOptions()\n+                    .limit(2)\n+                    .projection(projection)\n+                    .sort(Document(\"hello\", 1))\n+            assertEquals(doc1, findOne(Document(), options).blockingGetResult()!!)\n+\n+            // Projection (remove \"_id\") and sort (by desc \"hello\") options\n+            options = FindOptions()\n+                    .limit(2)\n+                    .projection(projection)\n+                    .sort(Document(\"hello\", -1))\n+            assertEquals(doc3, findOne(Document(), options).blockingGetResult()!!)\n+        }\n+    }\n+\n+    @Test\n+    fun findOne_fails() {\n+        with(getCollectionInternal()) {\n+            assertFailsWith(ObjectServerError::class) {\n+                findOne(Document(\"\\$who\", 1)).blockingGetResult()\n+            }.also { e ->\n+                assertEquals(ErrorCode.MONGODB_ERROR, e.errorCode)\n+                assertNotNull(e.errorMessage)\n+                assertTrue(e.errorMessage!!.contains(\"operator\", true))\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun find() {\n+        with(getCollectionInternal()) {\n+            // Find on an empty collection returns false on hasNext and null on first\n+            var iter = find()\n+            assertFalse(iter.iterator().blockingGetResult()!!.hasNext())\n+            assertNull(iter.first().blockingGetResult())\n+\n+            val doc1 = Document(\"hello\", \"world\")\n+            val doc2 = Document(\"hello\", \"friend\")\n+            doc2[\"proj\"] = \"field\"\n+            insertMany(listOf(doc1, doc2)).blockingGetResult()\n+\n+            // Iterate after inserting two documents\n+            assertTrue(iter.iterator().blockingGetResult()!!.hasNext())\n+            assertEquals(doc1, iter.first().blockingGetResult()!!.withoutId())\n+\n+            // Get next with sort by desc \"_id\" and limit to 1 document\n+            assertEquals(doc2,\n+                    iter.limit(1)\n+                            .sort(Document(\"_id\", -1))\n+                            .iterator().blockingGetResult()!!\n+                            .next().withoutId())\n+\n+            // Find first document\n+            iter = find(doc1)\n+            assertTrue(iter.iterator().blockingGetResult()!!.hasNext())\n+            assertEquals(doc1,\n+                    iter.iterator().blockingGetResult()!!\n+                            .next().withoutId())\n+\n+            // Find with filter for first document\n+            iter = find().filter(doc1)\n+            assertTrue(iter.iterator().blockingGetResult()!!.hasNext())\n+            assertEquals(doc1,\n+                    iter.iterator().blockingGetResult()!!\n+                            .next().withoutId())\n+\n+            // Find with projection shows \"proj\" in result\n+            val expected = Document(\"proj\", \"field\")\n+            assertEquals(expected,\n+                    find(doc2)\n+                            .projection(Document(\"proj\", 1))\n+                            .iterator().blockingGetResult()!!\n+                            .next().withoutId())\n+\n+            // Getting a new iterator returns first element on tryNext\n+            val asyncIter = iter.iterator().blockingGetResult()!!\n+            assertEquals(doc1, asyncIter.tryNext().withoutId())\n+        }\n+    }\n+\n+    @Test\n+    fun find_fails() {\n+        with(getCollectionInternal()) {\n+            assertFailsWith(ObjectServerError::class) {\n+                find(Document(\"\\$who\", 1)).first().blockingGetResult()\n+            }.also { e ->\n+                assertEquals(ErrorCode.MONGODB_ERROR, e.errorCode)\n+                assertNotNull(e.errorMessage)\n+                assertTrue(e.errorMessage!!.contains(\"operator\", true))\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun aggregate() {\n+        with(getCollectionInternal()) {\n+            // Aggregate on an empty collection returns false on hasNext and null on first\n+            var iter = aggregate(listOf())\n+            assertFalse(iter.iterator().blockingGetResult()!!.hasNext())\n+            assertNull(iter.first().blockingGetResult())\n+\n+            // Iterate after inserting two documents\n+            val doc1 = Document(\"hello\", \"world\")\n+            val doc2 = Document(\"hello\", \"friend\")\n+            insertMany(listOf(doc1, doc2)).blockingGetResult()\n+            assertTrue(iter.iterator().blockingGetResult()!!.hasNext())\n+            assertEquals(doc1.withoutId(), iter.first().blockingGetResult()!!.withoutId())\n+\n+            // Aggregate with pipeline, sort by desc \"_id\" and limit to 1 document\n+            iter = aggregate(listOf(Document(\"\\$sort\", Document(\"_id\", -1)), Document(\"\\$limit\", 1)))\n+            assertEquals(doc2.withoutId(),\n+                    iter.iterator().blockingGetResult()!!\n+                            .next().withoutId())\n+\n+            // Aggregate with pipeline, match first document\n+            iter = aggregate(listOf(Document(\"\\$match\", doc1)))\n+            assertTrue(iter.iterator().blockingGetResult()!!.hasNext())\n+            assertEquals(doc1.withoutId(), iter.iterator().blockingGetResult()!!.next().withoutId())\n+        }\n+    }\n+\n+    @Test\n+    fun aggregate_fails() {\n+        with(getCollectionInternal()) {\n+            assertFailsWith(ObjectServerError::class) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cedf0a03dbcdc1fa715c83a4249864ac21e5c998"}, "originalPosition": 295}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 724, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}