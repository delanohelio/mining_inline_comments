{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNTAzMTc4", "number": 6939, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDoyNzoyM1rOEdP2Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMTo1MTo0N1rOEf9G1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTAzODQ3OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/AppConfigurationTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDoyNzoyM1rOHIS8rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDoyNzoyM1rOHIS8rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2MTEwMQ==", "bodyText": "Just delete this test", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r478461101", "createdAt": "2020-08-27T14:27:23Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/AppConfigurationTests.kt", "diffHunk": "@@ -297,4 +309,61 @@ class AppConfigurationTests {\n                     assertEquals(defaultHttpLogObfuscator, it.httpLogObfuscator)\n                 }\n     }\n+    // Check that custom headers and auth header renames are correctly used for HTTP requests\n+    // performed from Java.\n+    @Test\n+    fun javaRequestCustomHeaders() {\n+        var app: App? = null\n+        try {\n+            looperThread.runBlocking {\n+                app = TestApp(builder = { builder ->\n+                    builder.addCustomRequestHeader(CUSTOM_HEADER_NAME, CUSTOM_HEADER_VALUE)\n+                    builder.authorizationHeaderName(AUTH_HEADER_NAME)\n+                })\n+                runJavaRequestCustomHeadersTest(app!!)\n+            }\n+        } finally {\n+            app?.close()\n+        }\n+    }\n+\n+    // FIXME Seems to be outdated...cannot find an option for setting headers for a specific host", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTA0NzQ3OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDoyOToxNVrOHITCcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwOTowMDo0MVrOHKs5ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2MjU3OA==", "bodyText": "Hmm, I think I saw something about this being fixed. Try talking to @RedBeard0531", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r478462578", "createdAt": "2020-08-27T14:29:15Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import android.util.Log\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.SyncDog\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.log.RealmLogger\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.assertFailsWithErrorCode\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkyMTExNQ==", "bodyText": "The old issue #5416 is still open. I have tried incorporating the shutdown_and_wait from realm/realm-object-store#1055 but had various issue around it. In some of the other tests referring to #5416 I was not able to get hold of the session and other places like here it did not work out. Reapplied a workaround from another test by retried to close if it fails.", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r480921115", "createdAt": "2020-09-01T07:32:24Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import android.util.Log\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.SyncDog\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.log.RealmLogger\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.assertFailsWithErrorCode\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2MjU3OA=="}, "originalCommit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk4MzQzNA==", "bodyText": "Maybe related to some internal notification triggering to early due to realm/realm-object-store#1054", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r480983434", "createdAt": "2020-09-01T09:00:41Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import android.util.Log\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.SyncDog\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.log.RealmLogger\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.assertFailsWithErrorCode\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2MjU3OA=="}, "originalCommit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTA1MTE0OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDoyOTo1OFrOHITEnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDoyOTo1OFrOHITEnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2MzEzNQ==", "bodyText": "Yes", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r478463135", "createdAt": "2020-08-27T14:29:58Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import android.util.Log\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.SyncDog\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.log.RealmLogger\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.assertFailsWithErrorCode\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been\n+            //  closed for now https://github.com/realm/realm-java/issues/5416\n+            if (e.message!!.contains(\"It's not allowed to delete the file\")) {\n+                // retry after 1 second\n+                SystemClock.sleep(1000)\n+                assertTrue(Realm.deleteRealm(config))\n+            }\n+        }\n+\n+        // FIXME Is this sufficient to test \"loginLogoutResumeSynching\"-case", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTA1NzcwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDozMToyMVrOHITIxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDozMToyMVrOHITIxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2NDE5OQ==", "bodyText": "Great, we should probably still keep the test as a kind of smoke test.", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r478464199", "createdAt": "2020-08-27T14:31:21Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import android.util.Log\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.SyncDog\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.log.RealmLogger\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.assertFailsWithErrorCode\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been\n+            //  closed for now https://github.com/realm/realm-java/issues/5416\n+            if (e.message!!.contains(\"It's not allowed to delete the file\")) {\n+                // retry after 1 second\n+                SystemClock.sleep(1000)\n+                assertTrue(Realm.deleteRealm(config))\n+            }\n+        }\n+\n+        // FIXME Is this sufficient to test \"loginLogoutResumeSynching\"-case\n+        user = app.login(Credentials.emailPassword(user.email, SECRET_PASSWORD))\n+        val config2: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        Realm.getInstance(config2).use { realm ->\n+            realm.syncSession.downloadAllServerChanges()\n+            realm.refresh()\n+            assertEquals(1, realm.where(SyncStringOnly::class.java).count())\n+        }\n+        looperThread.testComplete()\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun waitForInitialRemoteData_mainThreadThrows() {\n+        val user: User = SyncTestUtils.createTestUser(app)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        assertFailsWith<java.lang.IllegalStateException> {\n+            Realm.getInstance(config).close()\n+        }\n+    }\n+\n+    @Test\n+    fun waitForInitialRemoteData() {\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+        }\n+        user.logOut()\n+\n+        // 2. Local state should now be completely reset. Open the same sync Realm but different local name again with\n+        // a new configuration which should download the uploaded changes (pray it managed to do so within the time frame).\n+        // Use different user to trigger different path\n+        val user2 = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user2, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .waitForInitialRemoteData()\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo 1$i\"\n+                }\n+            }\n+            assertEquals(20, realm.where(SyncStringOnly::class.java).count())\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    @Ignore(\"Sync somehow keeps a Realm alive, causing the Realm.deleteRealm to throw \" +\n+            \" https://github.com/realm/realm-java/issues/5416\")\n+    fun waitForInitialData_resilientInCaseOfRetries() {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        for (i in 0..9) {\n+            val t = Thread(Runnable {\n+                var realm: Realm? = null\n+                assertFailsWith<DownloadingRealmInterruptedException> {\n+                    Thread.currentThread().interrupt()\n+                    Realm.getInstance(config).close()\n+                }\n+                // FIXME Seems like the file is actually created before interrupted. Is this check\n+                //  correct?\n+                 assertFalse(File(config.getPath()).exists())\n+                // FIXME This can throw IllegalStateException as the realm is maybe not closed\n+                //  properly due to https://github.com/realm/realm-java/issues/5416\n+                Realm.deleteRealm(config)\n+            })\n+            t.start()\n+            t.join()\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    // FIXME This does not throw anymore as described in issue. But do the test still make sense", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "originalPosition": 207}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTA2NDEzOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDozMjo0MlrOHITMrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNDoyMzowNlrOHJ68xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2NTE5OA==", "bodyText": "We cannot test this in dev mode, since the server will just create the schema.\nMaybe if we have a model class with a specific property that has a different type on the the client than on the server.\nWe can add this class as part of the server setup?", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r478465198", "createdAt": "2020-08-27T14:32:42Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import android.util.Log\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.SyncDog\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.log.RealmLogger\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.assertFailsWithErrorCode\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been\n+            //  closed for now https://github.com/realm/realm-java/issues/5416\n+            if (e.message!!.contains(\"It's not allowed to delete the file\")) {\n+                // retry after 1 second\n+                SystemClock.sleep(1000)\n+                assertTrue(Realm.deleteRealm(config))\n+            }\n+        }\n+\n+        // FIXME Is this sufficient to test \"loginLogoutResumeSynching\"-case\n+        user = app.login(Credentials.emailPassword(user.email, SECRET_PASSWORD))\n+        val config2: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        Realm.getInstance(config2).use { realm ->\n+            realm.syncSession.downloadAllServerChanges()\n+            realm.refresh()\n+            assertEquals(1, realm.where(SyncStringOnly::class.java).count())\n+        }\n+        looperThread.testComplete()\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun waitForInitialRemoteData_mainThreadThrows() {\n+        val user: User = SyncTestUtils.createTestUser(app)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        assertFailsWith<java.lang.IllegalStateException> {\n+            Realm.getInstance(config).close()\n+        }\n+    }\n+\n+    @Test\n+    fun waitForInitialRemoteData() {\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+        }\n+        user.logOut()\n+\n+        // 2. Local state should now be completely reset. Open the same sync Realm but different local name again with\n+        // a new configuration which should download the uploaded changes (pray it managed to do so within the time frame).\n+        // Use different user to trigger different path\n+        val user2 = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user2, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .waitForInitialRemoteData()\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo 1$i\"\n+                }\n+            }\n+            assertEquals(20, realm.where(SyncStringOnly::class.java).count())\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    @Ignore(\"Sync somehow keeps a Realm alive, causing the Realm.deleteRealm to throw \" +\n+            \" https://github.com/realm/realm-java/issues/5416\")\n+    fun waitForInitialData_resilientInCaseOfRetries() {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        for (i in 0..9) {\n+            val t = Thread(Runnable {\n+                var realm: Realm? = null\n+                assertFailsWith<DownloadingRealmInterruptedException> {\n+                    Thread.currentThread().interrupt()\n+                    Realm.getInstance(config).close()\n+                }\n+                // FIXME Seems like the file is actually created before interrupted. Is this check\n+                //  correct?\n+                 assertFalse(File(config.getPath()).exists())\n+                // FIXME This can throw IllegalStateException as the realm is maybe not closed\n+                //  properly due to https://github.com/realm/realm-java/issues/5416\n+                Realm.deleteRealm(config)\n+            })\n+            t.start()\n+            t.join()\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    // FIXME This does not throw anymore as described in issue. But do the test still make sense\n+    //  with new sync?\n+    //@Ignore(\"See https://github.com/realm/realm-java/issues/5373\")\n+    fun waitForInitialData_resilientInCaseOfRetriesAsync() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .waitForInitialRemoteData()\n+                .build()\n+        val randomizer = Random()\n+        for (i in 0..9) {\n+            val task = Realm.getInstanceAsync(config, object : Realm.Callback() {\n+                override fun onSuccess(realm: Realm) { fail() }\n+                override fun onError(exception: Throwable) { fail(exception.toString()) }\n+            })\n+            SystemClock.sleep(randomizer.nextInt(5).toLong())\n+            task.cancel()\n+        }\n+        // Leave some time for the async callbacks to actually get through\n+        looperThread.postRunnableDelayed(\n+                Runnable { looperThread.testComplete() },\n+                1000\n+        )\n+    }\n+\n+    @Test\n+    fun waitForInitialRemoteData_readOnlyTrue() {\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+        }\n+        user.logOut()\n+\n+        // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should\n+        // download the uploaded changes (pray it managed to do so within the time frame).\n+        // Use different user to trigger different path\n+        val user2 = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        val configNew: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user2, user.id)\n+                .waitForInitialRemoteData()\n+                .readOnly()\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        assertFalse(configNew.testRealmExists())\n+        Realm.getInstance(configNew).use { realm ->\n+            assertEquals(10, realm.where(SyncStringOnly::class.java).count())\n+        }\n+        user.logOut()\n+    }\n+\n+    @Test\n+    // FIXME\n+    @Ignore(\"Not really sure how to do this test with new sync\")\n+    fun waitForInitialRemoteData_readOnlyTrue_throwsIfWrongServerSchema() {\n+        val configNew: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .readOnly()\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        assertFalse(configNew.testRealmExists())\n+        assertFailsWith<RealmMigrationNeededException> {\n+            // This will fail, because the server Realm is completely empty and the Client is not allowed to write the\n+            // schema.\n+            // FIXME Does not throw. How to test schema migration with new sync when server is in dev mode", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE2NTA2MQ==", "bodyText": "Seems to work if the class is just not known on the server, so introduce a class for this purpose.", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r480165061", "createdAt": "2020-08-31T14:23:06Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import android.util.Log\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.SyncDog\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.log.RealmLogger\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.assertFailsWithErrorCode\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been\n+            //  closed for now https://github.com/realm/realm-java/issues/5416\n+            if (e.message!!.contains(\"It's not allowed to delete the file\")) {\n+                // retry after 1 second\n+                SystemClock.sleep(1000)\n+                assertTrue(Realm.deleteRealm(config))\n+            }\n+        }\n+\n+        // FIXME Is this sufficient to test \"loginLogoutResumeSynching\"-case\n+        user = app.login(Credentials.emailPassword(user.email, SECRET_PASSWORD))\n+        val config2: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        Realm.getInstance(config2).use { realm ->\n+            realm.syncSession.downloadAllServerChanges()\n+            realm.refresh()\n+            assertEquals(1, realm.where(SyncStringOnly::class.java).count())\n+        }\n+        looperThread.testComplete()\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun waitForInitialRemoteData_mainThreadThrows() {\n+        val user: User = SyncTestUtils.createTestUser(app)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        assertFailsWith<java.lang.IllegalStateException> {\n+            Realm.getInstance(config).close()\n+        }\n+    }\n+\n+    @Test\n+    fun waitForInitialRemoteData() {\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+        }\n+        user.logOut()\n+\n+        // 2. Local state should now be completely reset. Open the same sync Realm but different local name again with\n+        // a new configuration which should download the uploaded changes (pray it managed to do so within the time frame).\n+        // Use different user to trigger different path\n+        val user2 = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user2, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .waitForInitialRemoteData()\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo 1$i\"\n+                }\n+            }\n+            assertEquals(20, realm.where(SyncStringOnly::class.java).count())\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    @Ignore(\"Sync somehow keeps a Realm alive, causing the Realm.deleteRealm to throw \" +\n+            \" https://github.com/realm/realm-java/issues/5416\")\n+    fun waitForInitialData_resilientInCaseOfRetries() {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        for (i in 0..9) {\n+            val t = Thread(Runnable {\n+                var realm: Realm? = null\n+                assertFailsWith<DownloadingRealmInterruptedException> {\n+                    Thread.currentThread().interrupt()\n+                    Realm.getInstance(config).close()\n+                }\n+                // FIXME Seems like the file is actually created before interrupted. Is this check\n+                //  correct?\n+                 assertFalse(File(config.getPath()).exists())\n+                // FIXME This can throw IllegalStateException as the realm is maybe not closed\n+                //  properly due to https://github.com/realm/realm-java/issues/5416\n+                Realm.deleteRealm(config)\n+            })\n+            t.start()\n+            t.join()\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    // FIXME This does not throw anymore as described in issue. But do the test still make sense\n+    //  with new sync?\n+    //@Ignore(\"See https://github.com/realm/realm-java/issues/5373\")\n+    fun waitForInitialData_resilientInCaseOfRetriesAsync() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .waitForInitialRemoteData()\n+                .build()\n+        val randomizer = Random()\n+        for (i in 0..9) {\n+            val task = Realm.getInstanceAsync(config, object : Realm.Callback() {\n+                override fun onSuccess(realm: Realm) { fail() }\n+                override fun onError(exception: Throwable) { fail(exception.toString()) }\n+            })\n+            SystemClock.sleep(randomizer.nextInt(5).toLong())\n+            task.cancel()\n+        }\n+        // Leave some time for the async callbacks to actually get through\n+        looperThread.postRunnableDelayed(\n+                Runnable { looperThread.testComplete() },\n+                1000\n+        )\n+    }\n+\n+    @Test\n+    fun waitForInitialRemoteData_readOnlyTrue() {\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+        }\n+        user.logOut()\n+\n+        // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should\n+        // download the uploaded changes (pray it managed to do so within the time frame).\n+        // Use different user to trigger different path\n+        val user2 = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        val configNew: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user2, user.id)\n+                .waitForInitialRemoteData()\n+                .readOnly()\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        assertFalse(configNew.testRealmExists())\n+        Realm.getInstance(configNew).use { realm ->\n+            assertEquals(10, realm.where(SyncStringOnly::class.java).count())\n+        }\n+        user.logOut()\n+    }\n+\n+    @Test\n+    // FIXME\n+    @Ignore(\"Not really sure how to do this test with new sync\")\n+    fun waitForInitialRemoteData_readOnlyTrue_throwsIfWrongServerSchema() {\n+        val configNew: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .readOnly()\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        assertFalse(configNew.testRealmExists())\n+        assertFailsWith<RealmMigrationNeededException> {\n+            // This will fail, because the server Realm is completely empty and the Client is not allowed to write the\n+            // schema.\n+            // FIXME Does not throw. How to test schema migration with new sync when server is in dev mode", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2NTE5OA=="}, "originalCommit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "originalPosition": 276}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTM0NjAxOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/ProgressListenerTests.kt", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMToyODo1MVrOHMiSdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxODowODozNVrOHOF1Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkwNjc0Mg==", "bodyText": "Shouldn't we wait for the transaction to complete to call this?", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r482906742", "createdAt": "2020-09-03T11:28:51Z", "author": {"login": "clementetb"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/ProgressListenerTests.kt", "diffHunk": "@@ -290,6 +300,83 @@ class ProgressListenerTests {\n         }\n     }\n \n+    @Test\n+    @Ignore(\"FIXME: Flacky: Tracked by https://github.com/realm/realm-java/issues/6976\")\n+    fun progressListenersWorkWhenUsingWaitForInitialRemoteData() = looperThread.runBlocking {\n+        val username = UUID.randomUUID().toString()\n+        val password = \"password\"\n+        var user: User = app.registerUserAndLogin(username, password)\n+\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6a05d4557fd3ff71fea08e6acca384fbf9382e8"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUyNjk2OQ==", "bodyText": "The transaction are synchronous. ??", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r484526969", "createdAt": "2020-09-07T17:14:57Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/ProgressListenerTests.kt", "diffHunk": "@@ -290,6 +300,83 @@ class ProgressListenerTests {\n         }\n     }\n \n+    @Test\n+    @Ignore(\"FIXME: Flacky: Tracked by https://github.com/realm/realm-java/issues/6976\")\n+    fun progressListenersWorkWhenUsingWaitForInitialRemoteData() = looperThread.runBlocking {\n+        val username = UUID.randomUUID().toString()\n+        val password = \"password\"\n+        var user: User = app.registerUserAndLogin(username, password)\n+\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkwNjc0Mg=="}, "originalCommit": {"oid": "d6a05d4557fd3ff71fea08e6acca384fbf9382e8"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUzNzY1OQ==", "bodyText": "Yes, they are \ud83e\udd26\ud83c\udffb\u200d\u2642\ufe0f", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r484537659", "createdAt": "2020-09-07T18:08:35Z", "author": {"login": "clementetb"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/ProgressListenerTests.kt", "diffHunk": "@@ -290,6 +300,83 @@ class ProgressListenerTests {\n         }\n     }\n \n+    @Test\n+    @Ignore(\"FIXME: Flacky: Tracked by https://github.com/realm/realm-java/issues/6976\")\n+    fun progressListenersWorkWhenUsingWaitForInitialRemoteData() = looperThread.runBlocking {\n+        val username = UUID.randomUUID().toString()\n+        val password = \"password\"\n+        var user: User = app.registerUserAndLogin(username, password)\n+\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkwNjc0Mg=="}, "originalCommit": {"oid": "d6a05d4557fd3ff71fea08e6acca384fbf9382e8"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTQyNDg0OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMTo1MTo0N1rOHMjBdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMTo1MTo0N1rOHMjBdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkxODc3Mw==", "bodyText": "Exceptions and assertions on a custom thread will crash the test app. It will stop the test process and will not yield any results.\nCheck using BlockingLooperThread.runDetached", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r482918773", "createdAt": "2020-09-03T11:51:47Z", "author": {"login": "clementetb"}, "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,331 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.StringOnly\n+import io.realm.entities.SyncSchemeMigration\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.objectserver.utils.Constants\n+import io.realm.rule.BlockingLooperThread\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Assert.*\n+import org.junit.Before\n+import org.junit.Ignore\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // TODO: We don't have a way to ensure that the Realm instance on client thread has been\n+            //  closed for now https://github.com/realm/realm-java/issues/5416\n+            if (e.message!!.contains(\"It's not allowed to delete the file\")) {\n+                // retry after 1 second\n+                SystemClock.sleep(1000)\n+                assertTrue(Realm.deleteRealm(config))\n+            }\n+        }\n+\n+        user = app.login(Credentials.emailPassword(user.email, SECRET_PASSWORD))\n+        val config2: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        Realm.getInstance(config2).use { realm ->\n+            realm.syncSession.downloadAllServerChanges()\n+            realm.refresh()\n+            assertEquals(1, realm.where(SyncStringOnly::class.java).count())\n+        }\n+        looperThread.testComplete()\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun waitForInitialRemoteData_mainThreadThrows() {\n+        val user: User = SyncTestUtils.createTestUser(app)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        assertFailsWith<java.lang.IllegalStateException> {\n+            Realm.getInstance(config).close()\n+        }\n+    }\n+\n+    @Test\n+    fun waitForInitialRemoteData() {\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+        }\n+        user.logOut()\n+\n+        // 2. Local state should now be completely reset. Open the same sync Realm but different local name again with\n+        // a new configuration which should download the uploaded changes (pray it managed to do so within the time frame).\n+        // Use different user to trigger different path\n+        val user2 = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user2, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .waitForInitialRemoteData()\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo 1$i\"\n+                }\n+            }\n+            assertEquals(20, realm.where(SyncStringOnly::class.java).count())\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    @Ignore(\"Sync somehow keeps a Realm alive, causing the Realm.deleteRealm to throw \" +\n+            \" https://github.com/realm/realm-java/issues/5416\")\n+    fun waitForInitialData_resilientInCaseOfRetries() {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        for (i in 0..9) {\n+            val t = Thread(Runnable {\n+                var realm: Realm? = null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6a05d4557fd3ff71fea08e6acca384fbf9382e8"}, "originalPosition": 184}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 756, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}