{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyODkxOTIw", "number": 6783, "title": "Add support for EmailPasswordAuthProvider", "bodyText": "Add support for the EmailPasswordAuthProvider and associated functions.\n\nregisterUser\nconfirmUser\nresendConfirmationEmail\nsendResetPasswordEmail\ncallResetPasswordFunction\nresetPassword\n\nIntegration tests for confirmUser and resetPassword are not possible currently. Added them as TODO items in #6756\nCallbacks\nGetting great callback support between Java and Kotlin is turning out to be fairly problematic.\nCurrently, we have this interface in Java\n    public interface Callback<T> {\n        void onSuccess(T t);\n        void onError(ObjectServerError error);\n    }\n\nThis actually works pretty well in Java even with Nullability annotations. The problem is that we have a really common use case of T being Void and that causes problems in Kotlin because you cannot create instances of Void, which means that null is usually used which breaks the type system in Kotlin.\nval callback = object: RealmApp.Callback<Void> {\n  override fun onSuccess(t: Void) { / * Crash with null pointer exception */ }\n  override fun onError(error: Throwable) {  }\n}\n\nFixing this through annotations has turned out to be impossible due to where these annotations can be placed. I'll be happy to elaborate on the details if needed.\nThis leaves us with 4 options as far as I can tell\n\n\nMake onSuccess always nullable: public void onSuccess(@Nullable T t). This turns into T? on the Kotlin side, which gets really annoying for consumers when the type isn't Void.\n\n\nCreate two interfaces Callback and VoidCallback with the later having no arguments for onSuccess. This just feels extremely annoying API wise.\n\n\nSplit Callback into 3 SAM interfaces. OnSuccess, OnVoidSuccess and OnError. We actually do something similar for transactions right now. This approach looks fairly nice in Kotlin and with lamdas in Java. Without Lambdas it is a lot of boilerplate. I also have concerns with regards to how understandable the API is. It is pretty important that people handle the onError case since it involves a network, so both should always be present. Thus splitting into two interfaces feel a bit wrong. Also still having OnSuccess and OnVoidSuccess is annoying.\n\n\nThe currently implemented solution. I'm using reflection to hack around not being able to create an instance of Void. But with an instance of Void Kotlin support is no longer broken. It does mean that onSuccess(Void v) in Java will actually return an instance of Void instead of null, but no-body should be checking that anyway.\n\n\nTODO\n\n Integration tests\n Describe the tradeoffs of the Callback using reflection for Void\n Async implementation", "createdAt": "2020-03-24T10:03:21Z", "url": "https://github.com/realm/realm-java/pull/6783", "merged": true, "mergeCommit": {"oid": "8878265d992449fb127db8fddfb1960e57835766"}, "closed": true, "closedAt": "2020-03-29T20:52:36Z", "author": {"login": "cmelchior"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcQv66_AH2gAyMzkyODkxOTIwOmE1MTA2NTkxMjYxZDI3ODk3YWIyOTc3YzNhYjBkYjVjZDhiZDA3ZjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcSfd-ZgFqTM4MzQ0ODU5OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a5106591261d27897ab2977c3ab0db5cd8bd07f2", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/a5106591261d27897ab2977c3ab0db5cd8bd07f2", "committedDate": "2020-03-24T09:58:46Z", "message": "Initial implementation of EmailPasswordAuthProvider"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84055a428669d6d1dc6de39a4255e592c4f01484", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/84055a428669d6d1dc6de39a4255e592c4f01484", "committedDate": "2020-03-24T22:06:41Z", "message": "Add more EmailPasswordAuthProviderTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53cd14446f890ab2a13d368ffe01026682a87f4f", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/53cd14446f890ab2a13d368ffe01026682a87f4f", "committedDate": "2020-03-25T09:22:43Z", "message": "Cleanup. Finish remaining tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18ecd6b5d4eed7b8cb242973a99733c316b3d7d2", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/18ecd6b5d4eed7b8cb242973a99733c316b3d7d2", "committedDate": "2020-03-25T09:39:08Z", "message": "More cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35047fc5e88be5e190cf681afc68ca53fd92a528", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/35047fc5e88be5e190cf681afc68ca53fd92a528", "committedDate": "2020-03-25T22:18:39Z", "message": "Add missing javadoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTI0MTgz", "url": "https://github.com/realm/realm-java/pull/6783#pullrequestreview-382924183", "createdAt": "2020-03-27T14:46:20Z", "commit": {"oid": "35047fc5e88be5e190cf681afc68ca53fd92a528"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNDo0NjoyMFrOF80aMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxOTowMzoyOFrOF8-XAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMxNzU1NA==", "bodyText": "can we add FIXME to use the admin API in the future to do this validation?", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399317554", "createdAt": "2020-03-27T14:46:20Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/EmailPasswordAuthProviderTests.kt", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.admin.ServerAdmin\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import org.junit.After\n+import org.junit.Assert.assertEquals\n+import org.junit.Assert.fail\n+import org.junit.Before\n+import org.junit.Ignore\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.lang.IllegalStateException\n+\n+@RunWith(AndroidJUnit4::class)\n+class EmailPasswordAuthProviderTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+    private lateinit var app: TestRealmApp\n+    private lateinit var admin: ServerAdmin\n+\n+    // Callback use to verify that an Illegal Argument was thrown from async methods\n+    private val checkNullArgCallback\n+            = object : RealmApp.Callback<Void> {\n+        override fun onSuccess(t: Void) {\n+            fail()\n+        }\n+\n+        override fun onError(error: ObjectServerError) {\n+            assertEquals(ErrorCode.UNKNOWN, error.errorCode)\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    // Methods exposed by the EmailPasswordAuthProvider\n+    enum class Method {\n+        REGISTER_USER,\n+        CONFIRM_USER,\n+        RESEND_CONFIRMATION_EMAIL,\n+        SEND_RESET_PASSWORD_EMAIL,\n+        CALL_RESET_PASSWORD_FUNCTION,\n+        RESET_PASSWORD\n+    }\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        admin = ServerAdmin()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        app.close()\n+        admin.deleteAllUsers()\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    inline fun testNullArg(method: () -> Unit) {\n+        try {\n+            method()\n+            fail()\n+        } catch (ignore: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun registerUser() {\n+        val email = TestHelper.getRandomEmail()\n+        val password = \"password1234\"\n+        app.emailPasswordAuthProvider.registerUser(email, password)\n+        val user = app.login(RealmCredentials.emailPassword(email, password))\n+        assertEquals(RealmUser.State.ACTIVE, user.state)\n+    }\n+\n+    @Test\n+    fun registerUserAsync() {\n+        val email = TestHelper.getRandomEmail()\n+        val password = \"password1234\"\n+        looperThread.runBlocking {\n+            app.emailPasswordAuthProvider.registerUserAsync(email, password, object: RealmApp.Callback<Void> {\n+                override fun onSuccess(t: Void) {\n+                    val user2 = app.login(RealmCredentials.emailPassword(email, password))\n+                    assertEquals(RealmUser.State.ACTIVE, user2.state)\n+                    looperThread.testComplete()\n+                }\n+\n+                override fun onError(error: ObjectServerError) {\n+                    fail(error.toString())\n+                }\n+            })\n+        }\n+    }\n+\n+    @Test\n+    fun registerUser_invalidServerArgsThrows() {\n+        val provider = app.emailPasswordAuthProvider\n+        try {\n+            provider.registerUser(\"invalid-email\", \"1234\")\n+            fail()\n+        } catch (ex: ObjectServerError) {\n+            assertEquals(ErrorCode.BAD_REQUEST, ex.errorCode)\n+        }\n+    }\n+\n+    @Test\n+    fun registerUserAsync_invalidServerArgsThrows() {\n+        val provider = app.emailPasswordAuthProvider\n+        looperThread.runBlocking {\n+            provider.registerUserAsync(\"invalid-email\", \"1234\", object: RealmApp.Callback<Void> {\n+                override fun onSuccess(t: Void) {\n+                    fail()\n+                }\n+\n+                override fun onError(error: ObjectServerError) {\n+                    assertEquals(ErrorCode.BAD_REQUEST, error.errorCode)\n+                    looperThread.testComplete()\n+                }\n+            })\n+        }\n+\n+    }\n+\n+    @Test\n+    fun registerUser_invalidArgumentsThrows() {\n+        val provider: EmailPasswordAuthProvider = app.emailPasswordAuthProvider\n+        testNullArg { provider.registerUser(TestHelper.getNullString(), \"123456\") }\n+        testNullArg { provider.registerUser(\"foo@bar.baz\", TestHelper.getNullString()) }\n+        looperThread.runBlocking {\n+            provider.registerUserAsync(TestHelper.getNullString(), \"123456\", checkNullArgCallback)\n+        }\n+        looperThread.runBlocking {\n+            provider.registerUserAsync(\"foo@bar.baz\", TestHelper.getNullString(), checkNullArgCallback)\n+        }\n+    }\n+\n+    @Ignore(\"Find a way to automate this\")\n+    @Test\n+    fun confirmUser() {\n+        TODO(\"Figure out how to manually test this\")\n+    }\n+\n+    @Ignore(\"Find a way to automate this\")\n+    @Test\n+    fun confirmUserAsync() {\n+        TODO(\"Figure out how to manually test this\")\n+    }\n+\n+    @Test\n+    fun confirmUser_invalidServerArgsThrows() {\n+        val provider = app.emailPasswordAuthProvider\n+        try {\n+            provider.confirmUser(\"invalid-token\", \"invalid-token-id\")\n+            fail()\n+        } catch (ex: ObjectServerError) {\n+            assertEquals(ErrorCode.BAD_REQUEST, ex.errorCode)\n+        }\n+    }\n+\n+    @Test\n+    fun confirmUserAsync_invalidServerArgsThrows() {\n+        val provider = app.emailPasswordAuthProvider\n+        looperThread.runBlocking {\n+            provider.confirmUserAsync(\"invalid-email\", \"1234\", object: RealmApp.Callback<Void> {\n+                override fun onSuccess(t: Void) {\n+                    fail()\n+                }\n+\n+                override fun onError(error: ObjectServerError) {\n+                    assertEquals(ErrorCode.BAD_REQUEST, error.errorCode)\n+                    looperThread.testComplete()\n+                }\n+            })\n+        }\n+    }\n+\n+    @Test\n+    fun confirmUser_invalidArgumentsThrows() {\n+        val provider: EmailPasswordAuthProvider = app.emailPasswordAuthProvider\n+        testNullArg { provider.confirmUser(TestHelper.getNullString(), \"token-id\") }\n+        testNullArg { provider.confirmUser(\"token\", TestHelper.getNullString()) }\n+        looperThread.runBlocking {\n+            provider.confirmUserAsync(TestHelper.getNullString(), \"token-id\", checkNullArgCallback)\n+        }\n+        looperThread.runBlocking {\n+            provider.confirmUserAsync(\"token\", TestHelper.getNullString(), checkNullArgCallback)\n+        }\n+    }\n+\n+    @Test\n+    fun resendConfirmationEmail() {\n+        // We only test that the server successfully accepts the request. We have no way of knowing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35047fc5e88be5e190cf681afc68ca53fd92a528"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMyMzY2OQ==", "bodyText": "do you need to call deletePendingUser for each registerUser ?", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399323669", "createdAt": "2020-03-27T14:54:33Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/EmailPasswordAuthProviderTests.kt", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.admin.ServerAdmin\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import org.junit.After\n+import org.junit.Assert.assertEquals\n+import org.junit.Assert.fail\n+import org.junit.Before\n+import org.junit.Ignore\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.lang.IllegalStateException\n+\n+@RunWith(AndroidJUnit4::class)\n+class EmailPasswordAuthProviderTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+    private lateinit var app: TestRealmApp\n+    private lateinit var admin: ServerAdmin\n+\n+    // Callback use to verify that an Illegal Argument was thrown from async methods\n+    private val checkNullArgCallback\n+            = object : RealmApp.Callback<Void> {\n+        override fun onSuccess(t: Void) {\n+            fail()\n+        }\n+\n+        override fun onError(error: ObjectServerError) {\n+            assertEquals(ErrorCode.UNKNOWN, error.errorCode)\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    // Methods exposed by the EmailPasswordAuthProvider\n+    enum class Method {\n+        REGISTER_USER,\n+        CONFIRM_USER,\n+        RESEND_CONFIRMATION_EMAIL,\n+        SEND_RESET_PASSWORD_EMAIL,\n+        CALL_RESET_PASSWORD_FUNCTION,\n+        RESET_PASSWORD\n+    }\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        admin = ServerAdmin()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        app.close()\n+        admin.deleteAllUsers()\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    inline fun testNullArg(method: () -> Unit) {\n+        try {\n+            method()\n+            fail()\n+        } catch (ignore: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun registerUser() {\n+        val email = TestHelper.getRandomEmail()\n+        val password = \"password1234\"\n+        app.emailPasswordAuthProvider.registerUser(email, password)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35047fc5e88be5e190cf681afc68ca53fd92a528"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQzMjIzMQ==", "bodyText": "This can be refactored to be used with all types of expected exception.\ninline fun <reified T : Exception> expectException(method: () -> Unit) {\n        try {\n            method()\n            fail()\n        } catch (ignore: Throwable) {\n            if (ignore !is T) {\n                throw ignore\n            }\n        }\n    }\n\n//\nexpectException<IllegalArgumentException> { provider.registerUser(TestHelper.getNullString(), \"123456\") }", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399432231", "createdAt": "2020-03-27T17:36:33Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/EmailPasswordAuthProviderTests.kt", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.admin.ServerAdmin\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import org.junit.After\n+import org.junit.Assert.assertEquals\n+import org.junit.Assert.fail\n+import org.junit.Before\n+import org.junit.Ignore\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.lang.IllegalStateException\n+\n+@RunWith(AndroidJUnit4::class)\n+class EmailPasswordAuthProviderTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+    private lateinit var app: TestRealmApp\n+    private lateinit var admin: ServerAdmin\n+\n+    // Callback use to verify that an Illegal Argument was thrown from async methods\n+    private val checkNullArgCallback\n+            = object : RealmApp.Callback<Void> {\n+        override fun onSuccess(t: Void) {\n+            fail()\n+        }\n+\n+        override fun onError(error: ObjectServerError) {\n+            assertEquals(ErrorCode.UNKNOWN, error.errorCode)\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    // Methods exposed by the EmailPasswordAuthProvider\n+    enum class Method {\n+        REGISTER_USER,\n+        CONFIRM_USER,\n+        RESEND_CONFIRMATION_EMAIL,\n+        SEND_RESET_PASSWORD_EMAIL,\n+        CALL_RESET_PASSWORD_FUNCTION,\n+        RESET_PASSWORD\n+    }\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        admin = ServerAdmin()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        app.close()\n+        admin.deleteAllUsers()\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    inline fun testNullArg(method: () -> Unit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35047fc5e88be5e190cf681afc68ca53fd92a528"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ1NjU5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * This only works if users in the Realm Application are configured to be automatically be confirmed.\n          \n          \n            \n             * This only works if users in the Realm Application are configured to be automatically confirmed.", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399456594", "createdAt": "2020-03-27T18:18:24Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmAppExt.kt", "diffHunk": "@@ -13,3 +11,12 @@ fun RealmApp.close() {\n     SyncManager.reset()\n     BaseRealm.applicationContext = null // Required for Realm.init() to work\n }\n+\n+/**\n+ * Helper function for quickly logging in test users.\n+ * This only works if users in the Realm Application are configured to be automatically be confirmed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35047fc5e88be5e190cf681afc68ca53fd92a528"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3MjQ1OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * for logging into an Realm Application.\n          \n          \n            \n                 * for login into a Realm Application.", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399472459", "createdAt": "2020-03-27T18:47:47Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/EmailPasswordAuthProvider.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.json.JSONArray;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * Class encapsulating functionality provided when {@link RealmUser}'s are logged in through the\n+ * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+ */\n+public class EmailPasswordAuthProvider {\n+\n+    private static final int TYPE_REGISTER_USER = 1;\n+    private static final int TYPE_CONFIRM_USER = 2;\n+    private static final int TYPE_RESEND_CONFIRMATION_EMAIL = 3;\n+    private static final int TYPE_SEND_RESET_PASSWORD_EMAIL = 4;\n+    private static final int TYPE_CALL_RESET_PASSWORD_FUNCTION = 5;\n+    private static final int TYPE_RESET_PASSWORD = 6;\n+\n+    private final RealmApp app;\n+\n+    /**\n+     * Creates an authentication provider exposing functionality to using an email and password\n+     * for logging into an Realm Application.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35047fc5e88be5e190cf681afc68ca53fd92a528"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3MzExOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param password the password to associated with the email. The password must be between\n          \n          \n            \n                 * @param password the password to associate with the email. The password must be between", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399473119", "createdAt": "2020-03-27T18:48:57Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/EmailPasswordAuthProvider.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.json.JSONArray;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * Class encapsulating functionality provided when {@link RealmUser}'s are logged in through the\n+ * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+ */\n+public class EmailPasswordAuthProvider {\n+\n+    private static final int TYPE_REGISTER_USER = 1;\n+    private static final int TYPE_CONFIRM_USER = 2;\n+    private static final int TYPE_RESEND_CONFIRMATION_EMAIL = 3;\n+    private static final int TYPE_SEND_RESET_PASSWORD_EMAIL = 4;\n+    private static final int TYPE_CALL_RESET_PASSWORD_FUNCTION = 5;\n+    private static final int TYPE_RESET_PASSWORD = 6;\n+\n+    private final RealmApp app;\n+\n+    /**\n+     * Creates an authentication provider exposing functionality to using an email and password\n+     * for logging into an Realm Application.\n+     */\n+    public EmailPasswordAuthProvider(RealmApp app) {\n+        this.app = app;\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35047fc5e88be5e190cf681afc68ca53fd92a528"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3NjEzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * happen on the same thread as this this method is called on.\n          \n          \n            \n                 * happen on the same thread as this method is called on.", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399476131", "createdAt": "2020-03-27T18:54:44Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/EmailPasswordAuthProvider.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.json.JSONArray;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * Class encapsulating functionality provided when {@link RealmUser}'s are logged in through the\n+ * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+ */\n+public class EmailPasswordAuthProvider {\n+\n+    private static final int TYPE_REGISTER_USER = 1;\n+    private static final int TYPE_CONFIRM_USER = 2;\n+    private static final int TYPE_RESEND_CONFIRMATION_EMAIL = 3;\n+    private static final int TYPE_SEND_RESET_PASSWORD_EMAIL = 4;\n+    private static final int TYPE_CALL_RESET_PASSWORD_FUNCTION = 5;\n+    private static final int TYPE_RESET_PASSWORD = 6;\n+\n+    private final RealmApp app;\n+\n+    /**\n+     * Creates an authentication provider exposing functionality to using an email and password\n+     * for logging into an Realm Application.\n+     */\n+    public EmailPasswordAuthProvider(RealmApp app) {\n+        this.app = app;\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     *\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public void registerUser(String email, String password) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        Util.checkEmpty(password, \"password\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_REGISTER_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email, password);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     * @param callback callback when registration has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35047fc5e88be5e190cf681afc68ca53fd92a528"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3NzU0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * happen on the same thread as this this method is called on.\n          \n          \n            \n                 * happen on the same thread as this method is called on.", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399477546", "createdAt": "2020-03-27T18:57:31Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/EmailPasswordAuthProvider.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.json.JSONArray;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * Class encapsulating functionality provided when {@link RealmUser}'s are logged in through the\n+ * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+ */\n+public class EmailPasswordAuthProvider {\n+\n+    private static final int TYPE_REGISTER_USER = 1;\n+    private static final int TYPE_CONFIRM_USER = 2;\n+    private static final int TYPE_RESEND_CONFIRMATION_EMAIL = 3;\n+    private static final int TYPE_SEND_RESET_PASSWORD_EMAIL = 4;\n+    private static final int TYPE_CALL_RESET_PASSWORD_FUNCTION = 5;\n+    private static final int TYPE_RESET_PASSWORD = 6;\n+\n+    private final RealmApp app;\n+\n+    /**\n+     * Creates an authentication provider exposing functionality to using an email and password\n+     * for logging into an Realm Application.\n+     */\n+    public EmailPasswordAuthProvider(RealmApp app) {\n+        this.app = app;\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     *\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public void registerUser(String email, String password) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        Util.checkEmpty(password, \"password\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_REGISTER_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email, password);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     * @param callback callback when registration has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     *\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public RealmAsyncTask registerUserAsync(String email, String password, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous registration of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                registerUser(email, password);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void confirmUser(String token, String tokenId) throws ObjectServerError {\n+        Util.checkEmpty(token, \"token\");\n+        Util.checkEmpty(tokenId, \"tokenId\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_CONFIRM_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                token, tokenId);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @param callback callback when confirmation has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35047fc5e88be5e190cf681afc68ca53fd92a528"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3ODQ1OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * always happen on the same thread as this this method is called on.\n          \n          \n            \n                 * always happen on the same thread as this method is called on.", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399478459", "createdAt": "2020-03-27T18:59:15Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/EmailPasswordAuthProvider.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.json.JSONArray;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * Class encapsulating functionality provided when {@link RealmUser}'s are logged in through the\n+ * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+ */\n+public class EmailPasswordAuthProvider {\n+\n+    private static final int TYPE_REGISTER_USER = 1;\n+    private static final int TYPE_CONFIRM_USER = 2;\n+    private static final int TYPE_RESEND_CONFIRMATION_EMAIL = 3;\n+    private static final int TYPE_SEND_RESET_PASSWORD_EMAIL = 4;\n+    private static final int TYPE_CALL_RESET_PASSWORD_FUNCTION = 5;\n+    private static final int TYPE_RESET_PASSWORD = 6;\n+\n+    private final RealmApp app;\n+\n+    /**\n+     * Creates an authentication provider exposing functionality to using an email and password\n+     * for logging into an Realm Application.\n+     */\n+    public EmailPasswordAuthProvider(RealmApp app) {\n+        this.app = app;\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     *\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public void registerUser(String email, String password) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        Util.checkEmpty(password, \"password\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_REGISTER_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email, password);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     * @param callback callback when registration has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     *\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public RealmAsyncTask registerUserAsync(String email, String password, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous registration of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                registerUser(email, password);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void confirmUser(String token, String tokenId) throws ObjectServerError {\n+        Util.checkEmpty(token, \"token\");\n+        Util.checkEmpty(tokenId, \"tokenId\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_CONFIRM_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                token, tokenId);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @param callback callback when confirmation has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask confirmUserAsync(String token, String tokenId, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous confirmation of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                confirmUser(token, tokenId);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Resend the confirmation for a user to the given email.\n+     *\n+     * @param email the email of the user.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void resendConfirmationEmail(String email) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_RESEND_CONFIRMATION_EMAIL,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Resend the confirmation for a user to the given email.\n+     *\n+     * @param email the email of the user.\n+     * @param callback callback when resending the email has completed or failed. The callback will\n+     * always happen on the same thread as this this method is called on.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35047fc5e88be5e190cf681afc68ca53fd92a528"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3ODg4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * always happen on the same thread as this this method is called on.\n          \n          \n            \n                 * always happen on the same thread as this method is called on.", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399478887", "createdAt": "2020-03-27T18:59:59Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/EmailPasswordAuthProvider.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.json.JSONArray;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * Class encapsulating functionality provided when {@link RealmUser}'s are logged in through the\n+ * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+ */\n+public class EmailPasswordAuthProvider {\n+\n+    private static final int TYPE_REGISTER_USER = 1;\n+    private static final int TYPE_CONFIRM_USER = 2;\n+    private static final int TYPE_RESEND_CONFIRMATION_EMAIL = 3;\n+    private static final int TYPE_SEND_RESET_PASSWORD_EMAIL = 4;\n+    private static final int TYPE_CALL_RESET_PASSWORD_FUNCTION = 5;\n+    private static final int TYPE_RESET_PASSWORD = 6;\n+\n+    private final RealmApp app;\n+\n+    /**\n+     * Creates an authentication provider exposing functionality to using an email and password\n+     * for logging into an Realm Application.\n+     */\n+    public EmailPasswordAuthProvider(RealmApp app) {\n+        this.app = app;\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     *\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public void registerUser(String email, String password) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        Util.checkEmpty(password, \"password\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_REGISTER_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email, password);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     * @param callback callback when registration has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     *\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public RealmAsyncTask registerUserAsync(String email, String password, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous registration of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                registerUser(email, password);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void confirmUser(String token, String tokenId) throws ObjectServerError {\n+        Util.checkEmpty(token, \"token\");\n+        Util.checkEmpty(tokenId, \"tokenId\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_CONFIRM_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                token, tokenId);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @param callback callback when confirmation has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask confirmUserAsync(String token, String tokenId, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous confirmation of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                confirmUser(token, tokenId);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Resend the confirmation for a user to the given email.\n+     *\n+     * @param email the email of the user.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void resendConfirmationEmail(String email) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_RESEND_CONFIRMATION_EMAIL,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Resend the confirmation for a user to the given email.\n+     *\n+     * @param email the email of the user.\n+     * @param callback callback when resending the email has completed or failed. The callback will\n+     * always happen on the same thread as this this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask resendConfirmationEmailAsync(String email, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous resending the confirmation email is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                resendConfirmationEmail(email);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Sends a user a password reset email for the given email.\n+     *\n+     * @param email the email of the user.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void sendResetPasswordEmail(String email) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_SEND_RESET_PASSWORD_EMAIL,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Sends a user a password reset email for the given email.\n+     *\n+     * @param email the email of the user.\n+     * @param callback callback when sending the email has completed or failed. The callback will\n+     * always happen on the same thread as this this method is called on.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35047fc5e88be5e190cf681afc68ca53fd92a528"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3OTUzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param args any additional arguments provided to to the reset function. All arguments must\n          \n          \n            \n                 * @param args any additional arguments provided to the reset function. All arguments must", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399479531", "createdAt": "2020-03-27T19:01:18Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/EmailPasswordAuthProvider.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.json.JSONArray;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * Class encapsulating functionality provided when {@link RealmUser}'s are logged in through the\n+ * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+ */\n+public class EmailPasswordAuthProvider {\n+\n+    private static final int TYPE_REGISTER_USER = 1;\n+    private static final int TYPE_CONFIRM_USER = 2;\n+    private static final int TYPE_RESEND_CONFIRMATION_EMAIL = 3;\n+    private static final int TYPE_SEND_RESET_PASSWORD_EMAIL = 4;\n+    private static final int TYPE_CALL_RESET_PASSWORD_FUNCTION = 5;\n+    private static final int TYPE_RESET_PASSWORD = 6;\n+\n+    private final RealmApp app;\n+\n+    /**\n+     * Creates an authentication provider exposing functionality to using an email and password\n+     * for logging into an Realm Application.\n+     */\n+    public EmailPasswordAuthProvider(RealmApp app) {\n+        this.app = app;\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     *\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public void registerUser(String email, String password) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        Util.checkEmpty(password, \"password\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_REGISTER_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email, password);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     * @param callback callback when registration has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     *\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public RealmAsyncTask registerUserAsync(String email, String password, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous registration of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                registerUser(email, password);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void confirmUser(String token, String tokenId) throws ObjectServerError {\n+        Util.checkEmpty(token, \"token\");\n+        Util.checkEmpty(tokenId, \"tokenId\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_CONFIRM_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                token, tokenId);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @param callback callback when confirmation has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask confirmUserAsync(String token, String tokenId, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous confirmation of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                confirmUser(token, tokenId);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Resend the confirmation for a user to the given email.\n+     *\n+     * @param email the email of the user.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void resendConfirmationEmail(String email) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_RESEND_CONFIRMATION_EMAIL,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Resend the confirmation for a user to the given email.\n+     *\n+     * @param email the email of the user.\n+     * @param callback callback when resending the email has completed or failed. The callback will\n+     * always happen on the same thread as this this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask resendConfirmationEmailAsync(String email, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous resending the confirmation email is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                resendConfirmationEmail(email);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Sends a user a password reset email for the given email.\n+     *\n+     * @param email the email of the user.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void sendResetPasswordEmail(String email) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_SEND_RESET_PASSWORD_EMAIL,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Sends a user a password reset email for the given email.\n+     *\n+     * @param email the email of the user.\n+     * @param callback callback when sending the email has completed or failed. The callback will\n+     * always happen on the same thread as this this method is called on.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public RealmAsyncTask sendResetPasswordEmailAsync(String email, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous sending the reset password email is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                sendResetPasswordEmail(email);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Call the reset password function configured to the\n+     * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+     *\n+     * @param email the email of the user.\n+     * @param newPassword the new password of the user.\n+     * @param args any additional arguments provided to to the reset function. All arguments must\n+     * be able to be converted to JSON compatible values using {@code toString()}.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void callResetPasswordFunction(String email, String newPassword, Object... args) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        Util.checkEmpty(newPassword, \"newPassword\");\n+        JSONArray array = new JSONArray();\n+        for (Object arg : args) {\n+            array.put((arg != null) ? arg.toString() : null);\n+        }\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_CALL_RESET_PASSWORD_FUNCTION,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email, newPassword, array.toString());\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Call the reset password function configured to the\n+     * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+     *\n+     * @param email the email of the user.\n+     * @param newPassword the new password of the user.\n+     * @param args any additional arguments provided to to the reset function. All arguments must", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35047fc5e88be5e190cf681afc68ca53fd92a528"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3OTY3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param args any additional arguments provided to to the reset function. All arguments must\n          \n          \n            \n                 * @param args any additional arguments provided to the reset function. All arguments must", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399479676", "createdAt": "2020-03-27T19:01:37Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/EmailPasswordAuthProvider.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.json.JSONArray;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * Class encapsulating functionality provided when {@link RealmUser}'s are logged in through the\n+ * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+ */\n+public class EmailPasswordAuthProvider {\n+\n+    private static final int TYPE_REGISTER_USER = 1;\n+    private static final int TYPE_CONFIRM_USER = 2;\n+    private static final int TYPE_RESEND_CONFIRMATION_EMAIL = 3;\n+    private static final int TYPE_SEND_RESET_PASSWORD_EMAIL = 4;\n+    private static final int TYPE_CALL_RESET_PASSWORD_FUNCTION = 5;\n+    private static final int TYPE_RESET_PASSWORD = 6;\n+\n+    private final RealmApp app;\n+\n+    /**\n+     * Creates an authentication provider exposing functionality to using an email and password\n+     * for logging into an Realm Application.\n+     */\n+    public EmailPasswordAuthProvider(RealmApp app) {\n+        this.app = app;\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     *\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public void registerUser(String email, String password) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        Util.checkEmpty(password, \"password\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_REGISTER_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email, password);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     * @param callback callback when registration has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     *\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public RealmAsyncTask registerUserAsync(String email, String password, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous registration of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                registerUser(email, password);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void confirmUser(String token, String tokenId) throws ObjectServerError {\n+        Util.checkEmpty(token, \"token\");\n+        Util.checkEmpty(tokenId, \"tokenId\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_CONFIRM_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                token, tokenId);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @param callback callback when confirmation has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask confirmUserAsync(String token, String tokenId, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous confirmation of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                confirmUser(token, tokenId);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Resend the confirmation for a user to the given email.\n+     *\n+     * @param email the email of the user.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void resendConfirmationEmail(String email) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_RESEND_CONFIRMATION_EMAIL,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Resend the confirmation for a user to the given email.\n+     *\n+     * @param email the email of the user.\n+     * @param callback callback when resending the email has completed or failed. The callback will\n+     * always happen on the same thread as this this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask resendConfirmationEmailAsync(String email, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous resending the confirmation email is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                resendConfirmationEmail(email);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Sends a user a password reset email for the given email.\n+     *\n+     * @param email the email of the user.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void sendResetPasswordEmail(String email) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_SEND_RESET_PASSWORD_EMAIL,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Sends a user a password reset email for the given email.\n+     *\n+     * @param email the email of the user.\n+     * @param callback callback when sending the email has completed or failed. The callback will\n+     * always happen on the same thread as this this method is called on.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public RealmAsyncTask sendResetPasswordEmailAsync(String email, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous sending the reset password email is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                sendResetPasswordEmail(email);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Call the reset password function configured to the\n+     * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+     *\n+     * @param email the email of the user.\n+     * @param newPassword the new password of the user.\n+     * @param args any additional arguments provided to to the reset function. All arguments must", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35047fc5e88be5e190cf681afc68ca53fd92a528"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ4MDU3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * logging in using the {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} identity provider.\n          \n          \n            \n                 * login using the {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} identity provider.", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399480579", "createdAt": "2020-03-27T19:03:28Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -225,15 +228,25 @@ public RealmAsyncTask logOutAsync(Callback<RealmUser> callback) {\n          return logOutAsync(user, callback);\n      }\n \n+    /**\n+     * Returns a wrapper for interacting with functionality related to users either being created or\n+     * logging in using the {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} identity provider.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35047fc5e88be5e190cf681afc68ca53fd92a528"}, "originalPosition": 50}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "269787c3e7287d37f571208d5e3735e80ebe6e3d", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/269787c3e7287d37f571208d5e3735e80ebe6e3d", "committedDate": "2020-03-27T22:17:30Z", "message": "Apply suggestions from code review\n\nCo-Authored-By: Nabil Hachicha <nh@realm.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4d9a1ebe40e40108a5f87090dc020b28979c40c", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/d4d9a1ebe40e40108a5f87090dc020b28979c40c", "committedDate": "2020-03-27T23:14:16Z", "message": "Generic exception check. Also automatically delete all pending users."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11c7cc975a01d86ab7f9145b5adb093c41b3b588", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/11c7cc975a01d86ab7f9145b5adb093c41b3b588", "committedDate": "2020-03-29T10:22:32Z", "message": "Introduce Result class instead of letting Callback having multiple methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d706ff934c05808c95512915b71c8ed7715d99f7", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/d706ff934c05808c95512915b71c8ed7715d99f7", "committedDate": "2020-03-29T11:21:14Z", "message": "Remove Void instance hack"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNDIzMjcz", "url": "https://github.com/realm/realm-java/pull/6783#pullrequestreview-383423273", "createdAt": "2020-03-29T15:26:52Z", "commit": {"oid": "d706ff934c05808c95512915b71c8ed7715d99f7"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNToyNjo1MlrOF9SpHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTozMDowMlrOF9Sqyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMjg5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Returns the response in case the request as a success.\n          \n          \n            \n                     * Returns the response in case the request was a success.", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399812894", "createdAt": "2020-03-29T15:26:52Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -448,30 +448,106 @@ private void postSuccess(final T result) {\n                 handler.post(new Runnable() {\n                     @Override\n                     public void run() {\n-                        callback.onSuccess(result);\n+                        callback.onResult(Result.withResult(result));\n                     }\n                 });\n             }\n         }\n     }\n \n-    // Work-around for Kotlin not playing nice with the Void type and nullability annotations.\n-    // See https://github.com/realm/realm-java/pull/6783/ for more context.\n-    static final Void VOID_INSTANCE;\n-    static {\n-        Constructor<Void> constructor;\n-        Void v = null;\n-        try {\n-            constructor = Void.class.getDeclaredConstructor();\n-            constructor.setAccessible(true);\n-            v = constructor.newInstance();\n-        } catch (Exception e) {\n-            // Do nothing\n-            // Something is fundamentally broken if this fails and any Kotlin API using callbacks\n-            // with Void will throw a runtime exception (as Kotlin expects the value to be non-null).\n-            // For now, let this happen as any API using Java will still continue to work.\n+    /**\n+     * Result class representing the result of an async request from this app towards MongoDB Realm.\n+     *\n+     * @param <T> Type returned if the request was a success.\n+     * @see Callback\n+     */\n+    public static class Result<T> {\n+        private T result;\n+        private ObjectServerError error;\n+\n+        private Result(@Nullable T result, @Nullable ObjectServerError exception) {\n+            this.result = result;\n+            this.error = exception;\n+        }\n+\n+        /**\n+         * Creates a successful request result with no return value.\n+         */\n+        public static <T> Result<T> success() {\n+            return new Result(null, null);\n+        }\n+\n+        /**\n+         * Creates a successful request result with a return value.\n+         *\n+         * @param result the result value.\n+         */\n+        public static <T> Result<T> withResult(T result) {\n+            return new Result<>(result, null);\n+        }\n+\n+        /**\n+         * Creates a failed request result. The request failed for some reason, either because there\n+         * was a network error or the Realm Object Server returned an error.\n+         *\n+         * @param exception error that occurred.\n+         */\n+        public static <T> Result<T> withError(ObjectServerError exception) {\n+            return new Result<>(null, exception);\n+        }\n+\n+        /**\n+         * Returns whether or not request was successful\n+         *\n+         * @return {@code true} if the request was a success, {@code false} if not.\n+         */\n+        public boolean isSuccess() {\n+            return error == null;\n+        }\n+\n+        /**\n+         * Returns the response in case the request as a success.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d706ff934c05808c95512915b71c8ed7715d99f7"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzMyMg==", "bodyText": "You're not using Result.success is the result always non-null? it doesn't seem to be the case since you're returning null in a couple of callbacks ...", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399813322", "createdAt": "2020-03-29T15:30:02Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -448,30 +448,106 @@ private void postSuccess(final T result) {\n                 handler.post(new Runnable() {\n                     @Override\n                     public void run() {\n-                        callback.onSuccess(result);\n+                        callback.onResult(Result.withResult(result));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d706ff934c05808c95512915b71c8ed7715d99f7"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecebe1cb9d8d2e7dbff22043008ec0c7c43fcd38", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/ecebe1cb9d8d2e7dbff22043008ec0c7c43fcd38", "committedDate": "2020-03-29T17:57:56Z", "message": "Increase readability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54586044c0114cf5cbde690013893bea26a29500", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/54586044c0114cf5cbde690013893bea26a29500", "committedDate": "2020-03-29T17:58:44Z", "message": "Update realm/realm-library/src/objectServer/java/io/realm/RealmApp.java\n\nCo-Authored-By: Nabil Hachicha <nh@realm.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNDQ4NTk5", "url": "https://github.com/realm/realm-java/pull/6783#pullrequestreview-383448599", "createdAt": "2020-03-29T19:56:31Z", "commit": {"oid": "54586044c0114cf5cbde690013893bea26a29500"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2461, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}