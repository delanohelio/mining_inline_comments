{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3Mzk0NDc2", "number": 7007, "title": "Add tests for syncing embedded objects", "bodyText": "", "createdAt": "2020-07-27T20:48:35Z", "url": "https://github.com/realm/realm-java/pull/7007", "merged": true, "mergeCommit": {"oid": "f10262128b6ebe656959b1416de3d5d5c56ee11a"}, "closed": true, "closedAt": "2020-08-07T15:00:22Z", "author": {"login": "edualonso"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3wmx1gH2gAyNDU3Mzk0NDc2OjAwMjZiMTg0NDU4MDA0N2ExNGMxNzZjYWYzNzhmOTg3MDU5OTA0YmE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc8lU3agH2gAyNDU3Mzk0NDc2OmE5NWJhMmQyZDNkOGZiMDA5YjE2YzhiM2U4YmNjMDZjZGRjNjE0ZmI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0026b1844580047a14c176caf378f987059904ba", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/0026b1844580047a14c176caf378f987059904ba", "committedDate": "2020-07-23T14:49:43Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88dbf726f4b83c3737d3774c5c170c035515972d", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/88dbf726f4b83c3737d3774c5c170c035515972d", "committedDate": "2020-07-26T22:17:29Z", "message": "Seems we can't set children to managed parents when using sync. In addition, sync doesn't allow calls to *OrUpdate to update a constant parent with a different child"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20b35d87bbd1b448d272041b7999d83e5a0774c7", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/20b35d87bbd1b448d272041b7999d83e5a0774c7", "committedDate": "2020-07-29T09:16:10Z", "message": "Fixed broken test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6318bafc94b7143bfae04d593df612f1e407aba3", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/6318bafc94b7143bfae04d593df612f1e407aba3", "committedDate": "2020-08-03T09:59:08Z", "message": "Merge branch 'v10' into el/embedded-objects-sync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7af323f5dddb0f28b7e4f37ce3a6e60b7eccd6e5", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/7af323f5dddb0f28b7e4f37ce3a6e60b7eccd6e5", "committedDate": "2020-08-04T09:02:03Z", "message": "Added ignore to failing test due to server error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "babf0ef5793aaed0a493e5a227835dcf83640307", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/babf0ef5793aaed0a493e5a227835dcf83640307", "committedDate": "2020-08-07T09:28:22Z", "message": "Merge branch 'v10' into el/embedded-objects-sync\n\n# Conflicts:\n#\trealm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79cef318e87830aae00666dc0dee0065b74ee42a", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/79cef318e87830aae00666dc0dee0065b74ee42a", "committedDate": "2020-08-07T11:18:12Z", "message": "Added test for embedded tree structures but ignored due to existing bug server-side"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMjU1NzM1", "url": "https://github.com/realm/realm-java/pull/7007#pullrequestreview-463255735", "createdAt": "2020-08-07T12:01:40Z", "commit": {"oid": "79cef318e87830aae00666dc0dee0065b74ee42a"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMjowMTo0MFrOG9XLbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMjoxMTo1NVrOG9Xfsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk5NjA3Nw==", "bodyText": "Is this always true? Wouldn't the sync potentially already have fetched stuff.", "url": "https://github.com/realm/realm-java/pull/7007#discussion_r466996077", "createdAt": "2020-08-07T12:01:40Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "diffHunk": "@@ -232,6 +239,222 @@ class SyncedRealmTests {\n         }\n     }\n \n+    @Test\n+    fun embeddedObject_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                realm.createObject<EmbeddedSimpleParent>(primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79cef318e87830aae00666dc0dee0065b74ee42a"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk5ODQ0Nw==", "bodyText": "Maybe also verify that the children are actually embedded in the parent.", "url": "https://github.com/realm/realm-java/pull/7007#discussion_r466998447", "createdAt": "2020-08-07T12:06:18Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "diffHunk": "@@ -232,6 +239,222 @@ class SyncedRealmTests {\n         }\n     }\n \n+    @Test\n+    fun embeddedObject_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                realm.createObject<EmbeddedSimpleParent>(primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    // FIXME: remove ignore when sync issue fixed\n+    @Test\n+    @Ignore(\"ignored until https://jira.mongodb.org/browse/REALMC-6541 is fixed\")\n+    fun embeddedObject_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                val parent = EmbeddedSimpleParent(primaryKeyValue)\n+\n+//                parent.child = EmbeddedSimpleChild()\n+                val managedParent = it.copyToRealmOrUpdate(parent)\n+                // FIXME: instantiating the child in managedParent yields this from sync:\n+                //  \"MongoDB error: Updating the path 'child.childID' would create a conflict at 'child'\"\n+                managedParent.child = EmbeddedSimpleChild() // Will copy the object to Realm\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(EmbeddedSimpleListParent::class.java, primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(2, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleListParent>()\n+            assertEquals(1, parentResults.count())\n+            val parentFromResults = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parentFromResults._id)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79cef318e87830aae00666dc0dee0065b74ee42a"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk5OTk2MA==", "bodyText": "I would prefer explicit naming to avoid confusion.", "url": "https://github.com/realm/realm-java/pull/7007#discussion_r466999960", "createdAt": "2020-08-07T12:09:22Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "diffHunk": "@@ -232,6 +239,222 @@ class SyncedRealmTests {\n         }\n     }\n \n+    @Test\n+    fun embeddedObject_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                realm.createObject<EmbeddedSimpleParent>(primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    // FIXME: remove ignore when sync issue fixed\n+    @Test\n+    @Ignore(\"ignored until https://jira.mongodb.org/browse/REALMC-6541 is fixed\")\n+    fun embeddedObject_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                val parent = EmbeddedSimpleParent(primaryKeyValue)\n+\n+//                parent.child = EmbeddedSimpleChild()\n+                val managedParent = it.copyToRealmOrUpdate(parent)\n+                // FIXME: instantiating the child in managedParent yields this from sync:\n+                //  \"MongoDB error: Updating the path 'child.childID' would create a conflict at 'child'\"\n+                managedParent.child = EmbeddedSimpleChild() // Will copy the object to Realm\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(EmbeddedSimpleListParent::class.java, primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(2, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleListParent>()\n+            assertEquals(1, parentResults.count())\n+            val parentFromResults = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parentFromResults._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                EmbeddedSimpleListParent(primaryKeyValue).apply {\n+                    children = RealmList(EmbeddedSimpleChild(\"child1\"), EmbeddedSimpleChild(\"child2\"))\n+                    it.insert(this)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79cef318e87830aae00666dc0dee0065b74ee42a"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAwMTI2Ng==", "bodyText": "Do we have a reference to the issue?", "url": "https://github.com/realm/realm-java/pull/7007#discussion_r467001266", "createdAt": "2020-08-07T12:11:55Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "diffHunk": "@@ -232,6 +239,222 @@ class SyncedRealmTests {\n         }\n     }\n \n+    @Test\n+    fun embeddedObject_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                realm.createObject<EmbeddedSimpleParent>(primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    // FIXME: remove ignore when sync issue fixed\n+    @Test\n+    @Ignore(\"ignored until https://jira.mongodb.org/browse/REALMC-6541 is fixed\")\n+    fun embeddedObject_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                val parent = EmbeddedSimpleParent(primaryKeyValue)\n+\n+//                parent.child = EmbeddedSimpleChild()\n+                val managedParent = it.copyToRealmOrUpdate(parent)\n+                // FIXME: instantiating the child in managedParent yields this from sync:\n+                //  \"MongoDB error: Updating the path 'child.childID' would create a conflict at 'child'\"\n+                managedParent.child = EmbeddedSimpleChild() // Will copy the object to Realm\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(EmbeddedSimpleListParent::class.java, primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(2, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleListParent>()\n+            assertEquals(1, parentResults.count())\n+            val parentFromResults = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parentFromResults._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                EmbeddedSimpleListParent(primaryKeyValue).apply {\n+                    children = RealmList(EmbeddedSimpleChild(\"child1\"), EmbeddedSimpleChild(\"child2\"))\n+                    it.insert(this)\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(1, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(2, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleListParent>()\n+            assertEquals(1, parentResults.count())\n+            val parentFromResults = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parentFromResults._id)\n+            assertEquals(\"child1\", childResults.findAll()[0]!!.childId)\n+            assertEquals(\"child2\", childResults.findAll()[1]!!.childId)\n+        }\n+    }\n+\n+    @Test\n+    @Ignore(\"Enable when a bug server-side is fixed\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79cef318e87830aae00666dc0dee0065b74ee42a"}, "originalPosition": 207}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a95ba2d2d3d8fb009b16c8b3e8bcc06cddc614fb", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/a95ba2d2d3d8fb009b16c8b3e8bcc06cddc614fb", "committedDate": "2020-08-07T14:30:49Z", "message": "Removed tree-structure classes from remote config schema until https://jira.mongodb.org/projects/HELP/queues/issue/HELP-17759 is fixed"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2287, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}