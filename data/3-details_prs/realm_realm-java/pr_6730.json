{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4ODAwNzI1", "number": 6730, "title": "Add support for Embedded Objects", "bodyText": "Closes #6713\nThis PR adds support for \"Embedded Objects\". For non-synced Realms, the only benefit is that it can be be used to implement cascading deletes in some scenarios. For synced Realms it also describes how the data is serialized once it reaches a MongoDB server.\nSemantics\nEmbedded objects have slightly different semantics than normal objects:\n\nWhen the parent of an embedded object is deleted, so is the embedded object.\nSetting the link to the embedded object to null will also delete the embedded object.\nOnly one parent can ever link to an embedded object. Embedded objects can be parents to other embedded objects themselves.\n@PrimaryKey is not supported on embedded objects.\nFree-floating embedded objects with no parents are not possible, not even as a temporary state. This also prevents cycles between embedded objects. Only tree-structures are possible.\nThe above restrictions also mean it effectively isn't possible to move objects once assigned a parent.\n\nAPI\n// Mark class as embedded\n@RealmClass(embedded = true)\npublic class Person extends RealmObject {\n\n  // @LinkingObjects pointing to a single parent is supported for embedded objects\n  // They can optionally be marked @Required, although this is assumed if only one \n  // parent type exists\n  @Required\n  @LinkingObjects(\"child\")\n  public final Parent parent;\n\n  // It is still possible to have multiple different parent types, but only one can be set.\n  // This also means that if multiple possible parent types are possible. Neither of the\n  // @LinkingObjects can be marked as @Required.\n  @LinkingObjects(\"child1\")\n  public final Parent parent;\n  @LinkingObjects(\"child2\")\n  public final Parent parent;\n\n  // The old way of setting @LinkingObjects is still possible. But the result will only ever\n  // contain 1 element. \n  @LinkingObjects(\"child\")\n  public final RealmResults<Parent> parents = null;\n}\n\n// RealmObjectSchema exposes the information\nboolean RealmObjectSchema.isEmbedded();\n\n// Changing the embeddedness is only possible if all variants are true\n// when changing the flag.\nRealmObjectSchema.setEmbedded(boolean);\n\n// Queries on lists are allowed\nRealmResults<Person> results = parent.children.where()...findAll();\n\n// Creating embedded objects need to provide their parent as well.\n// All `copyToRealm` and `insert` methods do this already\nrealm.insert(new Parent(new Person()));\nrealm.insertOrUpdate(new Parent(new Person()));\nrealm.copyToRealm(new Parent(new Person()));\nrealm.copyToRealmOrUpdate(new Parent(new Person()));\n\n// Creating objects directly must also provide the linking parent.\n// So a new method has been added. If the parent is a list, the \n// semantics implemented is that the object is added to the \n// end of the list. This seemed the most sensible bit is also very subjective.\nrealm.createEmbeddedObject(Person.class, managedParent, \"parentFieldName\"); \n\n// Adding unmanaged objects to either lists or properties will automatically copy them correctly and make them embedded\nmanagedObject.field = EmbeddedPerson() // Will automatically copy the object as embedded \nmanagedObject.list.add(EmbeddedPerson()) // Will automatically copy the object as embedded \n\n// Dynamic Realms poses a bit of a challenge, since we don't have a concept of \n// unmanaged DynamicRealmObjects. This currently means that some things do not work.\n\n// Same as for typed Realms\ndynamicRealm.createEmbeddedObjcet(\"parentClass\", parentDynamicObject, \"parentField\");\n\n// The convience methods available to typed Realms are not available for DynamicRealm until we have support for an unmanaged RealmObject. All the the below would does not work for now.\nRealmList<DynamicRealmObject> list = obj.getList(\"myList\");\nlist.add(obj)\nlist.add(index, obj) \nlist.set(index, obj)\nobj.setObject(embeddedObject);\n\n// JSON support has currently not been added, but all the normal methods should be made to work\n\n// RealmResults.setObject(...) support has not been added yet. Also unclear exactly how this should work.\n\nTODO\n\n Upgrade to Sync-alpha.15 to fix last to unit test failures.\n Add annotation processor support + test\n Add tests for support schema graph types: Simple, Tree, Circular\n Extend RealmObjectSchema + tests\n How should migrations for embedded classes be handled? Not relevant for synchronized Realms I guess, but could be relevant for non-synced Realms.\n Tests for copyToRealm\n Tests for insert\n\nTODO for other PR's\n\n Runtime tests for the possible @LinkingObject configs. Especially in Kotlin.\n Tests for insertandinsertOrUpdate` with lists. All these variants use different compiled code.\n Add support for an unmanaged DynamicRealmObject\n Implementation and tests for createFromJson-variants.\n Figure out exactly how to support RealmResults.setObject(...) + Tests\n Add test involving synchronization of embedded objects\n Fix createEmbeddedObject not checking if the parent object has the correct type\n Fix support for using embedded Model classes defined in another library module.\n copyToRealm and insert are implemented using different strategies. The one used by insert seems much simpler, so would probably be helpful to refactor how copyToRealm is implemented.", "createdAt": "2020-01-29T22:34:04Z", "url": "https://github.com/realm/realm-java/pull/6730", "merged": true, "mergeCommit": {"oid": "dec806675fedfa3d2961812d6baa44be5d205e12"}, "closed": true, "closedAt": "2020-06-03T11:13:30Z", "author": {"login": "cmelchior"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb_NLzcgH2gAyMzY4ODAwNzI1OmU1MzFiYTY3YzFkZTZhOTM3MmZlZjYwMzYxOWVjNTBlYzJiNjM5MmM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnkuDmgH2gAyMzY4ODAwNzI1OjIxN2YxZDMwYzdhMjljYmQzMzQ0MzEyNTc5NTdhODQ3YjY5NWUyZmQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e531ba67c1de6a9372fef603619ec50ec2b6392c", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/e531ba67c1de6a9372fef603619ec50ec2b6392c", "committedDate": "2020-01-29T21:53:49Z", "message": "Added preliminary annotation processor support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa85cd20de821b2d1873aee1d9fcc6b4c0f1aad4", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/fa85cd20de821b2d1873aee1d9fcc6b4c0f1aad4", "committedDate": "2020-01-30T08:40:51Z", "message": "Add support for embedded classes on the Java side of schema generation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ec468323939e8b3eb91952c038d0f319fc31200", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/6ec468323939e8b3eb91952c038d0f319fc31200", "committedDate": "2020-01-30T12:22:15Z", "message": "Add missing check for illegal use of single parent reference"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5f2ce65f55a74fbf7da4c9fad9bc4ec1c8301da", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/a5f2ce65f55a74fbf7da4c9fad9bc4ec1c8301da", "committedDate": "2020-01-30T13:25:12Z", "message": "Add preliminary public API's for queries and RealmObjectSchema"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b543110d5ef0d8dd469675fade2dd4cfb0ae3877", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/b543110d5ef0d8dd469675fade2dd4cfb0ae3877", "committedDate": "2020-01-30T22:51:32Z", "message": "Add isEmbedded to mediators"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "827ee786a6793d804617ecc0e6f19d2001d9a6b5", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/827ee786a6793d804617ecc0e6f19d2001d9a6b5", "committedDate": "2020-02-25T09:05:32Z", "message": "Merge branch 'v10' into cm/embedded-objects\n\n# Conflicts:\n#\tCHANGELOG.md"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd0745da3d799a76fc5ea5b3ac98af20882afae7", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/fd0745da3d799a76fc5ea5b3ac98af20882afae7", "committedDate": "2020-02-28T14:09:52Z", "message": "Merge branch 'v10' into cm/embedded-objects"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NDU1Njg2", "url": "https://github.com/realm/realm-java/pull/6730#pullrequestreview-366455686", "createdAt": "2020-02-28T14:56:17Z", "commit": {"oid": "fd0745da3d799a76fc5ea5b3ac98af20882afae7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNDo1NjoxOFrOFv3sKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNDo1NjoxOFrOFv3sKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTczOTgxNg==", "bodyText": "the the", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r385739816", "createdAt": "2020-02-28T14:56:18Z", "author": {"login": "Zhuinden"}, "path": "CHANGELOG.md", "diffHunk": "@@ -5,7 +5,7 @@\n * Removed Query Based Sync API's and Subscriptions. These API's are not initially supported by MongoDB Realm. They will be re-introduced in a future release. `SyncConfiguration.partionKey()` has been added as a replacement. Read more [here](XXX).  \n \n ### Enhancements\n-* None.\n+* Added support for \"Embedded Objects\". They are enabled using `@RealmClass(embedded = true)`. An embedded object must have exactly one parent object linking to it and it will be deleted when the the parent is. Embedded objects can also be the parent of other embedded classes. Read more [here](https://realm.io/docs/java/latest/#embedded-objects). (Issue [#6713](https://github.com/realm/realm-java/issues/6713))  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd0745da3d799a76fc5ea5b3ac98af20882afae7"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NDU2MTA5", "url": "https://github.com/realm/realm-java/pull/6730#pullrequestreview-366456109", "createdAt": "2020-02-28T14:56:50Z", "commit": {"oid": "fd0745da3d799a76fc5ea5b3ac98af20882afae7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNDo1Njo1MVrOFv3tUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNDo1Njo1MVrOFv3tUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MDExMg==", "bodyText": "That's already there 3 lines above I think?", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r385740112", "createdAt": "2020-02-28T14:56:51Z", "author": {"login": "Zhuinden"}, "path": "CHANGELOG.md", "diffHunk": "@@ -43,7 +43,7 @@ NOTE: This version bumps the Realm file format to version 10. It is not possible\n * `RealmResults.asJSON()` is no longer `@Beta`.\n * Storing large binary blobs in Realm files no longer forces the file to be at least 8x the size of the largest blob.\n * Reduce the size of transaction logs stored inside the Realm file, reducing file size growth from large transactions.\n-* Added support for \"Embedded Objects\". They are enabled using `@RealmClass(embedded = true)`. An embedded object must have exactly one parent object linking to it and it will be deleted when the the parent is. Embedded objects can also be the parent of other embedded classes. Read more [here](https://realm.io/docs/java/latest/#embedded-objects). (Issue [#6713](https://github.com/realm/realm-java/issues/6713))  \n+* `RealmResults.asJSON()` is no longer `@Beta`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd0745da3d799a76fc5ea5b3ac98af20882afae7"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "283aff9768a7fdc3eccc5da8f2ce82aaf5eacc66", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/283aff9768a7fdc3eccc5da8f2ce82aaf5eacc66", "committedDate": "2020-03-08T21:08:00Z", "message": "Merge branch 'v10' into cm/embedded-objects\n\n# Conflicts:\n#\trealm/build.gradle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94f6b8023898f52cc4f168bc7b98190ba3a2f819", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/94f6b8023898f52cc4f168bc7b98190ba3a2f819", "committedDate": "2020-03-08T21:10:23Z", "message": "Adding test stubs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c096f01ce7e57ecef25178d755d560e69268600", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/2c096f01ce7e57ecef25178d755d560e69268600", "committedDate": "2020-05-06T12:42:19Z", "message": "Merge branch 'v10' into cm/embedded-objects\n\n# Conflicts:\n#\tCHANGELOG.md\n#\trealm/realm-annotations-processor/src/test/resources/io/realm/some_test_AllTypesRealmProxy.java\n#\trealm/realm-annotations-processor/src/test/resources/io/realm/some_test_NullTypesRealmProxy.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "232fbb0e6852f0330be0b66636a368bf1c7f3c99", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/232fbb0e6852f0330be0b66636a368bf1c7f3c99", "committedDate": "2020-05-06T14:28:11Z", "message": "Make test compile and convert to Kotlin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "747a210247161bf8e799ada0c7ac09d63134335c", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/747a210247161bf8e799ada0c7ac09d63134335c", "committedDate": "2020-05-06T14:43:38Z", "message": "Move test classes to Kotlin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "320b8a4436cedf9b9befdce740d1fa0bd5dca451", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/320b8a4436cedf9b9befdce740d1fa0bd5dca451", "committedDate": "2020-05-08T05:56:14Z", "message": "Add Javadoc. Add first copyToRealm test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2365d770d7f827f51418edf351a0d6319f55943a", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/2365d770d7f827f51418edf351a0d6319f55943a", "committedDate": "2020-05-18T16:07:29Z", "message": "Added support for CopyToRealm and ObjectSchema"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a6c0daa800c8ea927db8a55dfb34b5fc9251b0e", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/8a6c0daa800c8ea927db8a55dfb34b5fc9251b0e", "committedDate": "2020-05-26T07:00:50Z", "message": "Ad support for embedded objects in typed RealmLists."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88d0a75a645fab5aa4961615064e217f2419fa4a", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/88d0a75a645fab5aa4961615064e217f2419fa4a", "committedDate": "2020-05-26T09:02:47Z", "message": "Update annotation processor tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfca1a62a626ade9a72769936fa9496ca4668a72", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/bfca1a62a626ade9a72769936fa9496ca4668a72", "committedDate": "2020-05-26T09:44:45Z", "message": "Merge branch 'v10' into cm/embedded-objects\n\n# Conflicts:\n#\tCHANGELOG.md\n#\trealm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a548cb8f7027e10d72b45331e1f415b867c85da1", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/a548cb8f7027e10d72b45331e1f415b867c85da1", "committedDate": "2020-05-26T10:39:23Z", "message": "Fix Findbugs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71f46522d5b2cd5a9e22944bf1ba6880fa50f300", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/71f46522d5b2cd5a9e22944bf1ba6880fa50f300", "committedDate": "2020-05-26T12:23:21Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de129fc4106d870ca5a7e184d7b62e025d91b48d", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/de129fc4106d870ca5a7e184d7b62e025d91b48d", "committedDate": "2020-05-27T14:09:11Z", "message": "Fix faulty cache during copyToRealm. Better autogenerated code."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efd62ae0b94d70c4b750cbf883ceaa3221eda373", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/efd62ae0b94d70c4b750cbf883ceaa3221eda373", "committedDate": "2020-05-27T17:12:34Z", "message": "Fix Java 7 support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52d2e569482cba011c9aace3a439724a4849a83a", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/52d2e569482cba011c9aace3a439724a4849a83a", "committedDate": "2020-05-28T11:15:31Z", "message": "Add support for insert/insertOrUpdate"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88bb423d6b56d0970383f8c19ea560f43b8ab58d", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/88bb423d6b56d0970383f8c19ea560f43b8ab58d", "committedDate": "2020-05-28T12:30:58Z", "message": "Add missing methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "committedDate": "2020-05-28T13:24:40Z", "message": "Fix ObjectServerTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNzAzMjUz", "url": "https://github.com/realm/realm-java/pull/6730#pullrequestreview-420703253", "createdAt": "2020-05-29T07:10:01Z", "commit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "state": "APPROVED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzoxMDowMVrOGcROWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQyMDo0ODozM1rOGc7LQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NTUxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * This method should only be used to created objects of types marked as embedded.\n          \n          \n            \n             * This method should only be used to create objects of types marked as embedded.", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432295514", "createdAt": "2020-05-29T07:10:01Z", "author": {"login": "rorbech"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmExtensions.kt", "diffHunk": "@@ -74,6 +74,23 @@ inline fun <reified T : RealmModel> Realm.createObject(primaryKeyValue: Any?): T\n     return this.createObject(T::class.java, primaryKeyValue)\n }\n \n+/**\n+ * Instantiates and adds a new embedded object to the Realm.\n+ * <p>\n+ * This method should only be used to created objects of types marked as embedded.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NjMwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @param parentObject The parent object which should a reference to the embedded object. If the parent property is a list\n          \n          \n            \n             * @param parentObject The parent object which should hold a reference to the embedded object. If the parent property is a list", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432296304", "createdAt": "2020-05-29T07:12:00Z", "author": {"login": "rorbech"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmExtensions.kt", "diffHunk": "@@ -74,6 +74,23 @@ inline fun <reified T : RealmModel> Realm.createObject(primaryKeyValue: Any?): T\n     return this.createObject(T::class.java, primaryKeyValue)\n }\n \n+/**\n+ * Instantiates and adds a new embedded object to the Realm.\n+ * <p>\n+ * This method should only be used to created objects of types marked as embedded.\n+ *\n+ * @param T the Class of the object to create. It must be marked with {@code \\@RealmClass(embedded = true)}.\n+ * @param parentObject The parent object which should a reference to the embedded object. If the parent property is a list", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMDIyMA==", "bodyText": "Maybe explicit for testing purpose, but otherwise you could just use default value to skip the two explicit constructors\nopen class EmbeddedSimpleChild(var id: String = UUID.randomUUID().toString())\nHere and in other test classes", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432300220", "createdAt": "2020-05-29T07:21:04Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTest/kotlin/io/realm/entities/embedded/EmbeddedSimpleChild.kt", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.entities.embedded\n+\n+import io.realm.RealmObject\n+import io.realm.annotations.LinkingObjects\n+import io.realm.annotations.RealmClass\n+import java.util.*\n+\n+/**\n+ * The embedded object part of a simple object graph. This object can have two parents\n+ * [EmbeddedSimpleParent] and [EmbeddedSimpleListParent].\n+ */\n+@RealmClass(embedded = true)\n+open class EmbeddedSimpleChild : RealmObject {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk1NTEwOA==", "bodyText": "The documentation of Backlink should probably be updated to reflect that it does not have to be a RealmResult for embedded objects if the parent is always of the same type.", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432955108", "createdAt": "2020-05-31T14:56:10Z", "author": {"login": "rorbech"}, "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.kt", "diffHunk": "@@ -74,7 +74,7 @@ class Backlink(clazz: ClassMetaData, private val backlinkField: VariableElement)\n     /**\n      * The fully-qualified name of the class to which the backlinks, from `targetField`, point.\n      */\n-    val sourceClass: QualifiedClassName? = Utils.getRealmResultsType(backlinkField)\n+    val sourceClass: QualifiedClassName? = if (Utils.isRealmResults(backlinkField)) Utils.getRealmResultsType(backlinkField) else Utils.getModelClassQualifiedName(backlinkField)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk1NTI1MQ==", "bodyText": "Sounds like this is flipped compared to the implementation.", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432955251", "createdAt": "2020-05-31T14:57:39Z", "author": {"login": "rorbech"}, "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.kt", "diffHunk": "@@ -83,6 +83,11 @@ class Backlink(clazz: ClassMetaData, private val backlinkField: VariableElement)\n      */\n     val sourceField: String? = backlinkField.getAnnotation(LinkingObjects::class.java)?.value\n \n+    /**\n+     * {@code true} if the parent link should be modeled as a single link instead of as a RealmResults.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk1OTE1OQ==", "bodyText": "Seems like this pattern of commenting on exception, switching and emitting exceptions is used quite some times. Maybe abstract it into a reusable method.", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432959159", "createdAt": "2020-05-31T15:44:14Z", "author": {"login": "rorbech"}, "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.kt", "diffHunk": "@@ -292,33 +315,52 @@ class RealmProxyMediatorGenerator(private val processingEnvironment: ProcessingE\n                     EnumSet.of(Modifier.PUBLIC),\n                     \"Realm\", \"realm\", \"Collection<? extends RealmModel>\", \"objects\")\n \n+            if (embeddedClass.contains(false)) {\n                 emitStatement(\"Iterator<? extends RealmModel> iterator = objects.iterator()\")\n                 emitStatement(\"RealmModel object = null\")\n                 emitStatement(\"Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>(objects.size())\")\n \n                 beginControlFlow(\"if (iterator.hasNext())\")\n-                    emitSingleLineComment(\" access the first element to figure out the clazz for the routing below\")\n-                    emitStatement(\"object = iterator.next()\")\n-                    emitSingleLineComment(\"This cast is correct because obj is either\")\n-                    emitSingleLineComment(\"generated by RealmProxy or the original type extending directly from RealmObject\")\n-                    emitStatement(\"@SuppressWarnings(\\\"unchecked\\\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())\")\n-                    emitEmptyLine()\n+                emitSingleLineComment(\" access the first element to figure out the clazz for the routing below\")\n+                emitStatement(\"object = iterator.next()\")\n+                emitSingleLineComment(\"This cast is correct because obj is either\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2MTIwNw==", "bodyText": "Newline at end of file", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432961207", "createdAt": "2020-05-31T16:10:12Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "diffHunk": "@@ -278,4 +278,4 @@ class SyncedRealmMigrationTests {\n             BaseRealm.applicationContext = null\n         }\n     }\n-}\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2MTUzMA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432961530", "createdAt": "2020-05-31T16:13:40Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/java/io/realm/Realm.java", "diffHunk": "@@ -153,9 +155,9 @@ private Realm(RealmCache cache, OsSharedRealm.VersionID version) {\n         schema = new ImmutableRealmSchema(this,\n                 new ColumnIndices(configuration.getSchemaMediator(), sharedRealm.getSchemaInfo()));\n         // FIXME: This is to work around the different behaviour between the read only Realms in the Object Store and\n-        // in current java implementation. Opening a read only Realm with some missing schemas is allowed by Object\n-        // Store and realm-cocoa. In that case, any query based on the missing schema should just return an empty\n-        // results. Fix this together with https://github.com/realm/realm-java/issues/2953\n+        //  in current java implementation. Opening a read only Realm with some missing schemas is allowed by Object", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2MjMwNQ==", "bodyText": "I assume that this also just works out of the box with obfuscation, due to looking up the field names in some meta data, right?", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432962305", "createdAt": "2020-05-31T16:22:59Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/java/io/realm/Realm.java", "diffHunk": "@@ -1006,9 +1012,63 @@ private Scanner getFullStringScanner(InputStream in) {\n      */\n     public <E extends RealmModel> E createObject(Class<E> clazz, @Nullable Object primaryKeyValue) {\n         checkIfValid();\n+        RealmProxyMediator mediator = configuration.getSchemaMediator();\n+        if (mediator.isEmbedded(clazz)) {\n+            throw new IllegalArgumentException(\"This class is marked embedded. Use `createEmbeddedObject(class, parent, property)` instead:  \" + mediator.getSimpleClassName(clazz));\n+        }\n         return createObjectInternal(clazz, primaryKeyValue, true, Collections.<String>emptyList());\n     }\n \n+    /**\n+     * Instantiates and adds a new embedded object to the Realm.\n+     * <p>\n+     * This method should only be used to created objects of types marked as embedded.\n+     *\n+     * @param clazz the Class of the object to create. It must be marked with {@code \\@RealmClass(embedded = true)}.\n+     * @param parent The parent object which should a reference to the embedded object. If the parent property is a list\n+     * the embedded object will be added to the end of that list.\n+     * @param parentProperty the property in the parent class which holds the reference.\n+     * @return the newly created embedded object.\n+     * @throws IllegalArgumentException if {@code clazz} is not an embedded class or if the property\n+     * in the parent class cannot hold objects of the appropriate type.\n+     * @see RealmClass#embedded()\n+     */\n+    public <E extends RealmModel> E createEmbeddedObject(Class<E> clazz, RealmModel parentObject, String parentProperty) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3MjU3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * \n          \n          \n            \n                 * <p>", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432972578", "createdAt": "2020-05-31T18:37:04Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/java/io/realm/internal/objectstore/OsObjectBuilder.java", "diffHunk": "@@ -403,12 +404,28 @@ private void addEmptyList(long columnKey) {\n \n     /**\n      * Updates any existing object if it exists, otherwise creates a new one.\n+     * ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3MjU5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *\n          \n          \n            \n                 * <P>", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432972597", "createdAt": "2020-05-31T18:37:20Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/java/io/realm/internal/objectstore/OsObjectBuilder.java", "diffHunk": "@@ -403,12 +404,28 @@ private void addEmptyList(long columnKey) {\n \n     /**\n      * Updates any existing object if it exists, otherwise creates a new one.\n+     * \n+     * Updating an existing object requires that the primary key is defined as one of the fields.\n      *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3NDc2NQ==", "bodyText": "New line at end of file", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432974765", "createdAt": "2020-05-31T19:05:07Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp", "diffHunk": "@@ -389,3 +389,24 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeCreateNewObjectWit\n     CATCH_STD()\n     return 0;\n }\n+\n+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeCreateEmbeddedObject(\n+    JNIEnv* env, jclass, jlong j_parent_table_ptr, jlong j_parent_object_key, jlong j_parent_column_key)\n+{\n+    try {\n+        TableRef table = TBL_REF(j_parent_table_ptr);\n+        ObjKey obj_key(static_cast<int64_t>(j_parent_object_key));\n+        Obj parent_obj = table->get_object(obj_key);\n+        ColKey col_key(static_cast<int64_t>(j_parent_column_key));\n+        Obj child_obj;\n+        if (table->get_column_type(col_key) == type_Link) {\n+            child_obj = parent_obj.create_and_set_linked_object(col_key);\n+        } else {\n+            LnkLstPtr list = parent_obj.get_linklist_ptr(col_key);\n+            child_obj = list->create_and_insert_linked_object(list->size());\n+        }\n+        return to_jlong_or_not_found(child_obj.get_key());\n+    }\n+    CATCH_STD()\n+    return 0;\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3ODc2Ng==", "bodyText": "Wouldn't there be a way to not have to generate all these _ unsupported_ methods. Maybe somehow checking it in the mediator before dispatching to this class?", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432978766", "createdAt": "2020-05-31T19:56:34Z", "author": {"login": "rorbech"}, "path": "realm/realm-annotations-processor/src/test/resources/io/realm/some_test_SimpleRealmProxy.java", "diffHunk": "@@ -384,6 +384,10 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob\n         return unmanagedObject;\n     }\n \n+    public static void updateEmbeddedObject(Realm realm, some.test.Simple unmanagedObject, some.test.Simple managedObject, Map<RealmModel, RealmObjectProxy> cache, Set<ImportFlag> flags) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MDQxOA==", "bodyText": "Maybe it would also make sense to have output for a mediator with embedded objects too? Not hard to verify that the processor generates right code for isEmbedded - but for completion. And if you could eliminate the always throwing updateEmbeddedObject for non-embedded classes it would start being nice to have to for reasoning about the output instead of the processor.", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432980418", "createdAt": "2020-05-31T20:18:27Z", "author": {"login": "rorbech"}, "path": "realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java", "diffHunk": "@@ -206,4 +206,25 @@ public void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects\n         throw getMissingProxyClassException(clazz);\n     }\n \n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MDg5MQ==", "bodyText": "Sometimes test fail in weird ways if they fail to assert, so maybe stick to realm.executeTransaction{} just for certainty.", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432980891", "createdAt": "2020-05-31T20:24:42Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.*\n+import io.realm.entities.embedded.*\n+import io.realm.kotlin.addChangeListener\n+import io.realm.kotlin.createEmbeddedObject\n+import io.realm.kotlin.createObject\n+import io.realm.kotlin.where\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Class testing the Embedded Objects feature.\n+ */\n+// FIXME: Move all of these tests out from here. We try to tests by Class, not Feature.\n+@RunWith(AndroidJUnit4::class)\n+class EmbeddedObjectsTest {\n+\n+    @get:Rule\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var realmConfig: RealmConfiguration\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        realmConfig = configFactory.createConfiguration()\n+        realm = Realm.getInstance(realmConfig)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::realm.isInitialized) {\n+            realm.close()\n+        }\n+    }\n+\n+    @Test\n+    fun createObject_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MTE5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    managedParent.child = EmbeddedSimpleChild(\"child\") // Wil copy the object to Realm\n          \n          \n            \n                    managedParent.child = EmbeddedSimpleChild(\"child\") // Will copy the object to Realm", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432981194", "createdAt": "2020-05-31T20:27:49Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.*\n+import io.realm.entities.embedded.*\n+import io.realm.kotlin.addChangeListener\n+import io.realm.kotlin.createEmbeddedObject\n+import io.realm.kotlin.createObject\n+import io.realm.kotlin.where\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Class testing the Embedded Objects feature.\n+ */\n+// FIXME: Move all of these tests out from here. We try to tests by Class, not Feature.\n+@RunWith(AndroidJUnit4::class)\n+class EmbeddedObjectsTest {\n+\n+    @get:Rule\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var realmConfig: RealmConfiguration\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        realmConfig = configFactory.createConfiguration()\n+        realm = Realm.getInstance(realmConfig)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::realm.isInitialized) {\n+            realm.close()\n+        }\n+    }\n+\n+    @Test\n+    fun createObject_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createObject<EmbeddedSimpleChild>() }\n+    }\n+\n+    @Test\n+    fun createObjectWithPrimaryKey_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createObject<EmbeddedSimpleChild>(\"foo\") }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_nullArgsThrows() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, TestHelper.getNull(), \"foo\") }\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, TestHelper.getNull()) }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_nonExistingParentPropertyNameThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"foo\") }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_wrongParentPropertyTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+\n+        // TODO: Smoke-test for wrong type. Figure out how to test all unsupported types.\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"id\") }\n+    }\n+\n+    @Test\n+    @Ignore(\"FIXME\")\n+    fun createEmbeddedObject_wrongParentPropertyObjectTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+\n+        assertFailsWith<IllegalArgumentException> {\n+            // Embedded object is not of the type the parent object links to.\n+            realm.createEmbeddedObject<EmbeddedTreeLeaf>(parent, \"child\")\n+        }\n+    }\n+\n+    @Test\n+    @Ignore(\"FIXME\")\n+    fun createEmbeddedObject_wrongParentPropertyListTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleListParent>(\"parent\")\n+\n+        assertFailsWith<IllegalArgumentException> {\n+            // Embedded object is not of the type the parent object links to.\n+            realm.createEmbeddedObject<EmbeddedTreeLeaf>(parent, \"children\")\n+        }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_simpleSingleChild() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        val child = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\");\n+        assertEquals(child.parent, parent)\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_simpleChildList() {\n+        // Using createEmbeddedObject() with a parent list, will append the object to the end\n+        // of the list\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleListParent>(UUID.randomUUID().toString())\n+        val child1 = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"children\")\n+        val child2 = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"children\")\n+        assertEquals(2, parent.children.size.toLong())\n+        assertEquals(child1, parent.children.first()!!)\n+        assertEquals(child2, parent.children.last()!!)\n+    }\n+\n+    @Test\n+    @Ignore\n+    fun dynamicRealm_createEmbeddedObject() {\n+        TODO(\"Placeholder for all tests for DynamicRealm.createEmbeddedObject()\")\n+    }\n+\n+\n+    @Test\n+    fun settingParentFieldDeletesChild() {\n+        realm.beginTransaction()\n+        val parent = EmbeddedSimpleParent(\"parent\")\n+        parent.child = EmbeddedSimpleChild(\"child\")\n+\n+        val managedParent: EmbeddedSimpleParent = realm.copyToRealm(parent)\n+        val managedChild: EmbeddedSimpleChild = managedParent.child!!\n+        managedParent.child = null // Will delete the embedded object\n+        assertFalse(managedChild.isValid)\n+        assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+    }\n+\n+    @Test\n+    fun objectAccessor_willAutomaticallyCopyUnmanaged() {\n+        // Checks that adding an unmanaged embedded object to a property will automatically copy it.\n+        realm.beginTransaction()\n+        val parent = EmbeddedSimpleParent(\"parent\")\n+        val managedParent: EmbeddedSimpleParent = realm.copyToRealm(parent)\n+\n+        assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+        managedParent.child = EmbeddedSimpleChild(\"child\") // Wil copy the object to Realm", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MTI4Mg==", "bodyText": "Magic value. Maybe just add in class.", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432981282", "createdAt": "2020-05-31T20:29:00Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.*\n+import io.realm.entities.embedded.*\n+import io.realm.kotlin.addChangeListener\n+import io.realm.kotlin.createEmbeddedObject\n+import io.realm.kotlin.createObject\n+import io.realm.kotlin.where\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Class testing the Embedded Objects feature.\n+ */\n+// FIXME: Move all of these tests out from here. We try to tests by Class, not Feature.\n+@RunWith(AndroidJUnit4::class)\n+class EmbeddedObjectsTest {\n+\n+    @get:Rule\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var realmConfig: RealmConfiguration\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        realmConfig = configFactory.createConfiguration()\n+        realm = Realm.getInstance(realmConfig)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::realm.isInitialized) {\n+            realm.close()\n+        }\n+    }\n+\n+    @Test\n+    fun createObject_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createObject<EmbeddedSimpleChild>() }\n+    }\n+\n+    @Test\n+    fun createObjectWithPrimaryKey_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createObject<EmbeddedSimpleChild>(\"foo\") }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_nullArgsThrows() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, TestHelper.getNull(), \"foo\") }\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, TestHelper.getNull()) }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_nonExistingParentPropertyNameThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"foo\") }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_wrongParentPropertyTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+\n+        // TODO: Smoke-test for wrong type. Figure out how to test all unsupported types.\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"id\") }\n+    }\n+\n+    @Test\n+    @Ignore(\"FIXME\")\n+    fun createEmbeddedObject_wrongParentPropertyObjectTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+\n+        assertFailsWith<IllegalArgumentException> {\n+            // Embedded object is not of the type the parent object links to.\n+            realm.createEmbeddedObject<EmbeddedTreeLeaf>(parent, \"child\")\n+        }\n+    }\n+\n+    @Test\n+    @Ignore(\"FIXME\")\n+    fun createEmbeddedObject_wrongParentPropertyListTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleListParent>(\"parent\")\n+\n+        assertFailsWith<IllegalArgumentException> {\n+            // Embedded object is not of the type the parent object links to.\n+            realm.createEmbeddedObject<EmbeddedTreeLeaf>(parent, \"children\")\n+        }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_simpleSingleChild() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        val child = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\");\n+        assertEquals(child.parent, parent)\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_simpleChildList() {\n+        // Using createEmbeddedObject() with a parent list, will append the object to the end\n+        // of the list\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleListParent>(UUID.randomUUID().toString())\n+        val child1 = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"children\")\n+        val child2 = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"children\")\n+        assertEquals(2, parent.children.size.toLong())\n+        assertEquals(child1, parent.children.first()!!)\n+        assertEquals(child2, parent.children.last()!!)\n+    }\n+\n+    @Test\n+    @Ignore\n+    fun dynamicRealm_createEmbeddedObject() {\n+        TODO(\"Placeholder for all tests for DynamicRealm.createEmbeddedObject()\")\n+    }\n+\n+\n+    @Test\n+    fun settingParentFieldDeletesChild() {\n+        realm.beginTransaction()\n+        val parent = EmbeddedSimpleParent(\"parent\")\n+        parent.child = EmbeddedSimpleChild(\"child\")\n+\n+        val managedParent: EmbeddedSimpleParent = realm.copyToRealm(parent)\n+        val managedChild: EmbeddedSimpleChild = managedParent.child!!\n+        managedParent.child = null // Will delete the embedded object\n+        assertFalse(managedChild.isValid)\n+        assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+    }\n+\n+    @Test\n+    fun objectAccessor_willAutomaticallyCopyUnmanaged() {\n+        // Checks that adding an unmanaged embedded object to a property will automatically copy it.\n+        realm.beginTransaction()\n+        val parent = EmbeddedSimpleParent(\"parent\")\n+        val managedParent: EmbeddedSimpleParent = realm.copyToRealm(parent)\n+\n+        assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+        managedParent.child = EmbeddedSimpleChild(\"child\") // Wil copy the object to Realm\n+        assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        assertTrue(managedParent.child!!.isValid)\n+    }\n+\n+    @Test\n+    fun objectAccessor_willAutomaticallyCopyManaged() {\n+        // Checks that setting a link to a managed embedded object will automatically copy it unlike\n+        // normal objects that allow multiple parents. Note: This behavior is a bit controversial\n+        // and was subject to a lot of discussion during API design. The problem is that making\n+        // the behavior explicit will result in an extremely annoying API. We need to carefully\n+        // monitor if people understand how this behaves.\n+        realm.beginTransaction()\n+        val managedParent1: EmbeddedSimpleParent = realm.copyToRealm(EmbeddedSimpleParent(\"parent1\"))\n+        val managedParent2: EmbeddedSimpleParent = realm.copyToRealm(EmbeddedSimpleParent(\"parent2\"))\n+\n+        assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+        managedParent1.child = EmbeddedSimpleChild(\"child\")\n+        assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        managedParent2.child = managedParent1.child // Will copy the embedded object\n+        assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        assertNotEquals(managedParent1.child, managedParent2.child)\n+    }\n+\n+    @Test\n+    fun objectAccessor_willCopyUnderConstruction() {\n+        realm.beginTransaction()\n+        val unmanagedObj = EmbeddedWithConstructorArgs()\n+        val managedObj = realm.copyToRealm(unmanagedObj)\n+        assertEquals(\"innerChild\", managedObj.child!!.id)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MTU0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                fun copyToRealmOrUpdate_throws() {\n          \n          \n            \n                fun copyToRealmOrUpdate_noParentThrows() {", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432981549", "createdAt": "2020-05-31T20:31:27Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.*\n+import io.realm.entities.embedded.*\n+import io.realm.kotlin.addChangeListener\n+import io.realm.kotlin.createEmbeddedObject\n+import io.realm.kotlin.createObject\n+import io.realm.kotlin.where\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Class testing the Embedded Objects feature.\n+ */\n+// FIXME: Move all of these tests out from here. We try to tests by Class, not Feature.\n+@RunWith(AndroidJUnit4::class)\n+class EmbeddedObjectsTest {\n+\n+    @get:Rule\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var realmConfig: RealmConfiguration\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        realmConfig = configFactory.createConfiguration()\n+        realm = Realm.getInstance(realmConfig)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::realm.isInitialized) {\n+            realm.close()\n+        }\n+    }\n+\n+    @Test\n+    fun createObject_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createObject<EmbeddedSimpleChild>() }\n+    }\n+\n+    @Test\n+    fun createObjectWithPrimaryKey_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createObject<EmbeddedSimpleChild>(\"foo\") }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_nullArgsThrows() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, TestHelper.getNull(), \"foo\") }\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, TestHelper.getNull()) }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_nonExistingParentPropertyNameThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"foo\") }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_wrongParentPropertyTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+\n+        // TODO: Smoke-test for wrong type. Figure out how to test all unsupported types.\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"id\") }\n+    }\n+\n+    @Test\n+    @Ignore(\"FIXME\")\n+    fun createEmbeddedObject_wrongParentPropertyObjectTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+\n+        assertFailsWith<IllegalArgumentException> {\n+            // Embedded object is not of the type the parent object links to.\n+            realm.createEmbeddedObject<EmbeddedTreeLeaf>(parent, \"child\")\n+        }\n+    }\n+\n+    @Test\n+    @Ignore(\"FIXME\")\n+    fun createEmbeddedObject_wrongParentPropertyListTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleListParent>(\"parent\")\n+\n+        assertFailsWith<IllegalArgumentException> {\n+            // Embedded object is not of the type the parent object links to.\n+            realm.createEmbeddedObject<EmbeddedTreeLeaf>(parent, \"children\")\n+        }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_simpleSingleChild() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        val child = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\");\n+        assertEquals(child.parent, parent)\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_simpleChildList() {\n+        // Using createEmbeddedObject() with a parent list, will append the object to the end\n+        // of the list\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleListParent>(UUID.randomUUID().toString())\n+        val child1 = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"children\")\n+        val child2 = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"children\")\n+        assertEquals(2, parent.children.size.toLong())\n+        assertEquals(child1, parent.children.first()!!)\n+        assertEquals(child2, parent.children.last()!!)\n+    }\n+\n+    @Test\n+    @Ignore\n+    fun dynamicRealm_createEmbeddedObject() {\n+        TODO(\"Placeholder for all tests for DynamicRealm.createEmbeddedObject()\")\n+    }\n+\n+\n+    @Test\n+    fun settingParentFieldDeletesChild() {\n+        realm.beginTransaction()\n+        val parent = EmbeddedSimpleParent(\"parent\")\n+        parent.child = EmbeddedSimpleChild(\"child\")\n+\n+        val managedParent: EmbeddedSimpleParent = realm.copyToRealm(parent)\n+        val managedChild: EmbeddedSimpleChild = managedParent.child!!\n+        managedParent.child = null // Will delete the embedded object\n+        assertFalse(managedChild.isValid)\n+        assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+    }\n+\n+    @Test\n+    fun objectAccessor_willAutomaticallyCopyUnmanaged() {\n+        // Checks that adding an unmanaged embedded object to a property will automatically copy it.\n+        realm.beginTransaction()\n+        val parent = EmbeddedSimpleParent(\"parent\")\n+        val managedParent: EmbeddedSimpleParent = realm.copyToRealm(parent)\n+\n+        assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+        managedParent.child = EmbeddedSimpleChild(\"child\") // Wil copy the object to Realm\n+        assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        assertTrue(managedParent.child!!.isValid)\n+    }\n+\n+    @Test\n+    fun objectAccessor_willAutomaticallyCopyManaged() {\n+        // Checks that setting a link to a managed embedded object will automatically copy it unlike\n+        // normal objects that allow multiple parents. Note: This behavior is a bit controversial\n+        // and was subject to a lot of discussion during API design. The problem is that making\n+        // the behavior explicit will result in an extremely annoying API. We need to carefully\n+        // monitor if people understand how this behaves.\n+        realm.beginTransaction()\n+        val managedParent1: EmbeddedSimpleParent = realm.copyToRealm(EmbeddedSimpleParent(\"parent1\"))\n+        val managedParent2: EmbeddedSimpleParent = realm.copyToRealm(EmbeddedSimpleParent(\"parent2\"))\n+\n+        assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+        managedParent1.child = EmbeddedSimpleChild(\"child\")\n+        assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        managedParent2.child = managedParent1.child // Will copy the embedded object\n+        assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        assertNotEquals(managedParent1.child, managedParent2.child)\n+    }\n+\n+    @Test\n+    fun objectAccessor_willCopyUnderConstruction() {\n+        realm.beginTransaction()\n+        val unmanagedObj = EmbeddedWithConstructorArgs()\n+        val managedObj = realm.copyToRealm(unmanagedObj)\n+        assertEquals(\"innerChild\", managedObj.child!!.id)\n+    }\n+\n+    @Test\n+    fun realmList_add_willAutomaticallyCopy() {\n+        realm.beginTransaction()\n+        val parent = realm.copyToRealm(EmbeddedSimpleListParent(\"parent\"))\n+        assertTrue(parent.children.add(EmbeddedSimpleChild(\"child\")))\n+        val child = parent.children.first()!!\n+        assertTrue(child.isValid)\n+        assertEquals(\"child\", child.id)\n+\n+        // FIXME: How to handle DynamicRealmObject :(\n+    }\n+\n+    @Test\n+    fun realmList_addIndex_willAutomaticallyCopy() {\n+        realm.beginTransaction()\n+        val parent = realm.copyToRealm(EmbeddedSimpleListParent(\"parent\"))\n+        parent.children.add(EmbeddedSimpleChild(\"secondChild\"))\n+        parent.children.add(0, EmbeddedSimpleChild(\"firstChild\"))\n+        val child = parent.children.first()!!\n+        assertTrue(child.isValid)\n+        assertEquals(\"firstChild\", child.id)\n+\n+        // FIXME: How to handle DynamicRealmObject :(\n+    }\n+\n+    @Test\n+    fun realmList_set_willAutomaticallyCopy() {\n+        // Checks that adding an unmanaged embedded object to a list will automatically make\n+        // it managed\n+        realm.beginTransaction()\n+        val parent = realm.copyToRealm(EmbeddedSimpleListParent(\"parent\"))\n+        assertTrue(parent.children.add(EmbeddedSimpleChild(\"child\")))\n+        assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        parent.children[0] = EmbeddedSimpleChild(\"OtherChild\")\n+        assertEquals(\"OtherChild\", parent.children.first()!!.id)\n+        assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+\n+        // FIXME: How to handle DynamicRealmObject :(\n+    }\n+\n+    @Test\n+    fun copyToRealm_noParentThrows() {\n+        realm.executeTransaction {\n+            assertFailsWith<IllegalArgumentException> {\n+                realm.copyToRealm(EmbeddedSimpleChild(\"child\"))\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun copyToRealmOrUpdate_throws() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MTc0OQ==", "bodyText": "Add reason to ignore as it is easier to inspect in reports", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432981749", "createdAt": "2020-05-31T20:34:07Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.*\n+import io.realm.entities.embedded.*\n+import io.realm.kotlin.addChangeListener\n+import io.realm.kotlin.createEmbeddedObject\n+import io.realm.kotlin.createObject\n+import io.realm.kotlin.where\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Class testing the Embedded Objects feature.\n+ */\n+// FIXME: Move all of these tests out from here. We try to tests by Class, not Feature.\n+@RunWith(AndroidJUnit4::class)\n+class EmbeddedObjectsTest {\n+\n+    @get:Rule\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var realmConfig: RealmConfiguration\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        realmConfig = configFactory.createConfiguration()\n+        realm = Realm.getInstance(realmConfig)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::realm.isInitialized) {\n+            realm.close()\n+        }\n+    }\n+\n+    @Test\n+    fun createObject_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createObject<EmbeddedSimpleChild>() }\n+    }\n+\n+    @Test\n+    fun createObjectWithPrimaryKey_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createObject<EmbeddedSimpleChild>(\"foo\") }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_nullArgsThrows() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, TestHelper.getNull(), \"foo\") }\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, TestHelper.getNull()) }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_nonExistingParentPropertyNameThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"foo\") }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_wrongParentPropertyTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+\n+        // TODO: Smoke-test for wrong type. Figure out how to test all unsupported types.\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"id\") }\n+    }\n+\n+    @Test\n+    @Ignore(\"FIXME\")\n+    fun createEmbeddedObject_wrongParentPropertyObjectTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+\n+        assertFailsWith<IllegalArgumentException> {\n+            // Embedded object is not of the type the parent object links to.\n+            realm.createEmbeddedObject<EmbeddedTreeLeaf>(parent, \"child\")\n+        }\n+    }\n+\n+    @Test\n+    @Ignore(\"FIXME\")\n+    fun createEmbeddedObject_wrongParentPropertyListTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleListParent>(\"parent\")\n+\n+        assertFailsWith<IllegalArgumentException> {\n+            // Embedded object is not of the type the parent object links to.\n+            realm.createEmbeddedObject<EmbeddedTreeLeaf>(parent, \"children\")\n+        }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_simpleSingleChild() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        val child = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\");\n+        assertEquals(child.parent, parent)\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_simpleChildList() {\n+        // Using createEmbeddedObject() with a parent list, will append the object to the end\n+        // of the list\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleListParent>(UUID.randomUUID().toString())\n+        val child1 = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"children\")\n+        val child2 = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"children\")\n+        assertEquals(2, parent.children.size.toLong())\n+        assertEquals(child1, parent.children.first()!!)\n+        assertEquals(child2, parent.children.last()!!)\n+    }\n+\n+    @Test\n+    @Ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4Mjg0OA==", "bodyText": "Maybe also add the generated proxy for the EmbeddedClass for reference.", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432982848", "createdAt": "2020-05-31T20:48:33Z", "author": {"login": "rorbech"}, "path": "realm/realm-annotations-processor/src/test/resources/io/realm/some_test_EmbeddedClassSimpleParentRealmProxy.java", "diffHunk": "@@ -0,0 +1,871 @@\n+package io.realm;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMjEwOTA3", "url": "https://github.com/realm/realm-java/pull/6730#pullrequestreview-422210907", "createdAt": "2020-06-01T21:58:18Z", "commit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMTo1ODoxOFrOGdbgqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzoyOTowMFrOGddQuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMjYxNw==", "bodyText": "Doesn't really make a lot of sense to use a backing property if backlinkField is immutable.", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433512617", "createdAt": "2020-06-01T21:58:18Z", "author": {"login": "edualonso"}, "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.kt", "diffHunk": "@@ -83,6 +83,11 @@ class Backlink(clazz: ClassMetaData, private val backlinkField: VariableElement)\n      */\n     val sourceField: String? = backlinkField.getAnnotation(LinkingObjects::class.java)?.value\n \n+    /**\n+     * {@code true} if the parent link should be modeled as a single link instead of as a RealmResults.\n+     */\n+    val exposeAsRealmResults: Boolean = Utils.isRealmResults(backlinkField)\n+\n     val targetFieldType: String\n         get() = backlinkField.asType().toString()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMTc1OQ==", "bodyText": "There seems to be a lot immutable data coming out of classType. I'm wondering if we could somehow avoid using vars for things like this and rely on initialisation for assigning values instead. It feels like we are adding state to this class unnecessarily. Another example from this class is the contains* booleans.", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433521759", "createdAt": "2020-06-01T22:24:20Z", "author": {"login": "edualonso"}, "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.kt", "diffHunk": "@@ -128,12 +128,13 @@ class ClassMetaData(env: ProcessingEnvironment, typeMirrors: TypeMirrors, privat\n             return type != \"io.realm.DynamicRealmObject\" && !type.endsWith(\".RealmObject\") && !type.endsWith(\"RealmProxy\")\n         }\n \n+    var embedded: Boolean = false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyNjcyMg==", "bodyText": "Nitpick: whenever it makes sense, and as long as the function doesn't rely on optional values for overloading (and even in that case, I favour not using defaults, but that is my personal taste), I would put the lambda as the last parameter. Then you could extract it from within the parameter list for a more elegant look IMO:\n                emitMediatorSwitch(writer, false) {\n                   // blahblahblah...\n                }", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433526722", "createdAt": "2020-06-01T22:39:31Z", "author": {"login": "edualonso"}, "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.kt", "diffHunk": "@@ -292,33 +315,52 @@ class RealmProxyMediatorGenerator(private val processingEnvironment: ProcessingE\n                     EnumSet.of(Modifier.PUBLIC),\n                     \"Realm\", \"realm\", \"Collection<? extends RealmModel>\", \"objects\")\n \n+            if (embeddedClass.contains(false)) {\n                 emitStatement(\"Iterator<? extends RealmModel> iterator = objects.iterator()\")\n                 emitStatement(\"RealmModel object = null\")\n                 emitStatement(\"Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>(objects.size())\")\n \n                 beginControlFlow(\"if (iterator.hasNext())\")\n-                    emitSingleLineComment(\" access the first element to figure out the clazz for the routing below\")\n-                    emitStatement(\"object = iterator.next()\")\n-                    emitSingleLineComment(\"This cast is correct because obj is either\")\n-                    emitSingleLineComment(\"generated by RealmProxy or the original type extending directly from RealmObject\")\n-                    emitStatement(\"@SuppressWarnings(\\\"unchecked\\\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())\")\n-                    emitEmptyLine()\n+                emitSingleLineComment(\" access the first element to figure out the clazz for the routing below\")\n+                emitStatement(\"object = iterator.next()\")\n+                emitSingleLineComment(\"This cast is correct because obj is either\")\n+                emitSingleLineComment(\"generated by RealmProxy or the original type extending directly from RealmObject\")\n+                emitStatement(\"@SuppressWarnings(\\\"unchecked\\\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())\")\n+                emitEmptyLine()\n \n-                    emitMediatorSwitch({ i: Int ->\n+                emitMediatorSwitch({ i: Int ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyNzExNA==", "bodyText": "Same as above. I can see it's used in a number of places here too.", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433527114", "createdAt": "2020-06-01T22:40:46Z", "author": {"login": "edualonso"}, "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.kt", "diffHunk": "@@ -329,29 +371,41 @@ class RealmProxyMediatorGenerator(private val processingEnvironment: ProcessingE\n                     EnumSet.of(Modifier.PUBLIC),\n                     \"Realm\", \"realm\", \"Collection<? extends RealmModel>\", \"objects\")\n \n-                emitStatement(\"Iterator<? extends RealmModel> iterator = objects.iterator()\")\n-                emitStatement(\"RealmModel object = null\")\n-                emitStatement(\"Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>(objects.size())\")\n+                if (embeddedClass.contains(false)) {\n+                    emitStatement(\"Iterator<? extends RealmModel> iterator = objects.iterator()\")\n+                    emitStatement(\"RealmModel object = null\")\n+                    emitStatement(\"Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>(objects.size())\")\n \n-                beginControlFlow(\"if (iterator.hasNext())\")\n-                        .emitSingleLineComment(\" access the first element to figure out the clazz for the routing below\")\n-                        .emitStatement(\"object = iterator.next()\")\n-                        .emitSingleLineComment(\"This cast is correct because obj is either\")\n-                        .emitSingleLineComment(\"generated by RealmProxy or the original type extending directly from RealmObject\")\n-                        .emitStatement(\"@SuppressWarnings(\\\"unchecked\\\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())\")\n-                        .emitEmptyLine()\n+                    beginControlFlow(\"if (iterator.hasNext())\")\n+                            .emitSingleLineComment(\" access the first element to figure out the clazz for the routing below\")\n+                            .emitStatement(\"object = iterator.next()\")\n+                            .emitSingleLineComment(\"This cast is correct because obj is either\")\n+                            .emitSingleLineComment(\"generated by RealmProxy or the original type extending directly from RealmObject\")\n+                            .emitStatement(\"@SuppressWarnings(\\\"unchecked\\\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())\")\n+                            .emitEmptyLine()\n \n                     emitMediatorSwitch({ i: Int ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUzNzE0OA==", "bodyText": "This feels wrong. Remove secondary constructors, make this property a val and move to the primary constructor with its default value.\nSame for some of the other files below.", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433537148", "createdAt": "2020-06-01T23:13:56Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTest/kotlin/io/realm/entities/embedded/EmbeddedCircularChild.kt", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.entities.embedded\n+\n+import io.realm.RealmObject\n+import io.realm.annotations.RealmClass\n+import java.util.*\n+\n+/**\n+ * Embedded object that point to itself. Note, this is only allowed in the schema. The actual\n+ * objects are not allowed to have circular references.\n+ */\n+@RealmClass(embedded = true)\n+open class EmbeddedCircularChild : RealmObject {\n+    constructor() {}\n+    constructor(id: String) : super() {\n+        this.id = id\n+    }\n+\n+    var id = UUID.randomUUID().toString()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUzOTE1Ng==", "bodyText": "I know it's a test, but avoid var unless you're updating the value of children with a different list instance - remember you can still add elements to the list even if its property is immutable.", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433539156", "createdAt": "2020-06-01T23:21:33Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTest/kotlin/io/realm/entities/embedded/EmbeddedSimpleListParent.kt", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.entities.embedded\n+\n+import io.realm.RealmList\n+import io.realm.RealmObject\n+import io.realm.annotations.PrimaryKey\n+\n+// Top-level object describing a simple embedded objects structure consisting of only a\n+// list of embedded objects.\n+open class EmbeddedSimpleListParent : RealmObject {\n+    constructor() {}\n+    constructor(id: String) : super() {\n+        this.id = id\n+    }\n+\n+    @PrimaryKey\n+    var id: String? = null\n+    var children: RealmList<EmbeddedSimpleChild> = RealmList()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0MDgwNQ==", "bodyText": "Does it make sense to have an individual leafNode while having a leafNodeList? Also, no var for the lists.", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433540805", "createdAt": "2020-06-01T23:27:23Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTest/kotlin/io/realm/entities/embedded/EmbeddedTreeNode.kt", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.entities.embedded\n+\n+import io.realm.RealmList\n+import io.realm.RealmObject\n+import io.realm.annotations.RealmClass\n+import java.util.*\n+\n+// Middle-level node in a object-graph that is three-shaped, i.e. no circular references.\n+// The tree depth can be described as:\n+// - 1 TreeParent\n+// - 1 or more TreeNode's. I.e. a TreeNode can be the child of another TreeNode.\n+// - 1 or more TreeLeaf objects. TreeLeaf objects are always at the bottom of tree.\n+@RealmClass(embedded = true)\n+open class EmbeddedTreeNode : RealmObject {\n+    constructor() {}\n+    constructor(id: String) : super() {\n+        this.id = id\n+    }\n+    var id = UUID.randomUUID().toString()\n+    var middleNode: EmbeddedTreeNode? = null\n+    var leafNode: EmbeddedTreeLeaf? = null\n+    var middleNodeList: RealmList<EmbeddedTreeNode> = RealmList()\n+    var leafNodeList: RealmList<EmbeddedTreeLeaf> = RealmList()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0MTMwNQ==", "bodyText": "You can possibly do what Claus and I suggested above here too.", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433541305", "createdAt": "2020-06-01T23:29:00Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTest/kotlin/io/realm/entities/embedded/EmbeddedWithConstructorArgs.kt", "diffHunk": "@@ -0,0 +1,11 @@\n+package io.realm.entities.embedded\n+\n+import io.realm.RealmObject\n+\n+open class EmbeddedWithConstructorArgs : RealmObject() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d2662d1a520f342e05f07fdcc89ab6cdffe03e0", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/8d2662d1a520f342e05f07fdcc89ab6cdffe03e0", "committedDate": "2020-06-02T10:36:41Z", "message": "Merge branch 'v10' into cm/embedded-objects"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c600a7642b2517aefd5d532c510e1d900dba807", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/8c600a7642b2517aefd5d532c510e1d900dba807", "committedDate": "2020-06-02T12:08:22Z", "message": "Apply suggestions from code review\n\nCo-authored-by: Claus R\u00f8rbech <claus.rorbech@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4d06b38e3a809edb1f31892d5c00a7e514fbab2", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/a4d06b38e3a809edb1f31892d5c00a7e514fbab2", "committedDate": "2020-06-02T18:37:45Z", "message": "PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "264867f3aec5ee9fea75dd41e90440d1dda1e180", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/264867f3aec5ee9fea75dd41e90440d1dda1e180", "committedDate": "2020-06-02T18:37:57Z", "message": "Merge branch 'cm/embedded-objects' of https://github.com/realm/realm-java into cm/embedded-objects"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de5ac9f325ee99a153c5392cbc12079c16a455d5", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/de5ac9f325ee99a153c5392cbc12079c16a455d5", "committedDate": "2020-06-02T19:31:42Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0efd5fb1b2a8ceda24e54fe78140d0dd0548e14c", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/0efd5fb1b2a8ceda24e54fe78140d0dd0548e14c", "committedDate": "2020-06-02T19:57:10Z", "message": "Add missing impl"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDM1OTQ2", "url": "https://github.com/realm/realm-java/pull/6730#pullrequestreview-423035946", "createdAt": "2020-06-02T20:32:49Z", "commit": {"oid": "0efd5fb1b2a8ceda24e54fe78140d0dd0548e14c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "217f1d30c7a29cbd334431257957a847b695e2fd", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/217f1d30c7a29cbd334431257957a847b695e2fd", "committedDate": "2020-06-03T07:56:01Z", "message": "Fix list tests"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2422, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}