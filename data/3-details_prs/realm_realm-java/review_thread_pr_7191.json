{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4NDc4NzQx", "number": 7191, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNjowMDo0NFrOE4Alpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTozNzoyMFrOE57hPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MTY1MzUxOnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/DynamicRealmExtensions.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNjowMDo0NFrOHxrrhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNjowMDo0NFrOHxrrhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1NzkyNA==", "bodyText": "Missing license header", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r521857924", "createdAt": "2020-11-12T06:00:44Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/DynamicRealmExtensions.kt", "diffHunk": "@@ -0,0 +1,17 @@\n+package io.realm.kotlin", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzA0NTg4OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoxMToyMlrOHyfytA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwODowNjowN1rOHyjNNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxMTczMg==", "bodyText": "Can this ever be null here?", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522711732", "createdAt": "2020-11-13T07:11:22Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "diffHunk": "@@ -56,94 +54,25 @@ import kotlinx.coroutines.flow.flowOf\n  * @return Kotlin [Flow] on which calls to `onEach` or `collect` can be made.\n  */\n @Beta\n-fun <T : RealmModel> T.toFlow(): Flow<T> {\n-    val obj = this\n-    return if (obj is RealmObjectProxy) {\n-        val proxy = obj as RealmObjectProxy\n-        val realm = proxy.`realmGet$proxyState`().`realm$realm`\n-\n-        when (realm) {\n-            is Realm -> flowFromRealm<T>(realm, obj)\n-            is DynamicRealm -> {\n-                val dynamicObject = obj as DynamicRealmObject\n-                flowFromDynamicRealm(realm, dynamicObject) as Flow<T>\n-            }\n-            else -> throw UnsupportedOperationException(\"${realm.javaClass} does not support RxJava. See https://realm.io/docs/java/latest/#rxjava for more details.\")\n-        }\n-    } else {\n-        return flowOf(this)\n-    }\n-}\n-\n-private fun <T : RealmModel> flowFromRealm(realm: Realm, obj: T): Flow<T> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (realm.isFrozen) {\n-        return flowOf(obj)\n-    }\n-\n-    val config = realm.configuration\n-\n-    return callbackFlow<T> {\n-        // Do nothing if the object is invalid\n-        if (!obj.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<T> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        obj.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(obj))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                obj.removeChangeListener(listener)\n-                flowRealm.close()\n-            }\n-        }\n-    }\n-}\n-\n-private fun flowFromDynamicRealm(\n-        dynamicRealm: DynamicRealm,\n-        dynamicObject: DynamicRealmObject\n-): Flow<DynamicRealmObject> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (dynamicRealm.isFrozen) {\n-        return flowOf(dynamicObject)\n-    }\n-\n-    val config = dynamicRealm.configuration\n-\n-    return callbackFlow<DynamicRealmObject> {\n-        // Do nothing if the object is invalid\n-        if (!dynamicObject.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<DynamicRealmObject> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        dynamicObject.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(dynamicObject))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                dynamicObject.removeChangeListener(listener)\n-                flowRealm.close()\n+fun <T : RealmModel> T?.toFlow(): Flow<T?> {\n+    // Return flow with object or null flow if this function is called on null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc2NzY3MA==", "bodyText": "Yes, when calling findFirst().toflow(). We got feedback from a user and decided to add this here #7165", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522767670", "createdAt": "2020-11-13T08:06:07Z", "author": {"login": "edualonso"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "diffHunk": "@@ -56,94 +54,25 @@ import kotlinx.coroutines.flow.flowOf\n  * @return Kotlin [Flow] on which calls to `onEach` or `collect` can be made.\n  */\n @Beta\n-fun <T : RealmModel> T.toFlow(): Flow<T> {\n-    val obj = this\n-    return if (obj is RealmObjectProxy) {\n-        val proxy = obj as RealmObjectProxy\n-        val realm = proxy.`realmGet$proxyState`().`realm$realm`\n-\n-        when (realm) {\n-            is Realm -> flowFromRealm<T>(realm, obj)\n-            is DynamicRealm -> {\n-                val dynamicObject = obj as DynamicRealmObject\n-                flowFromDynamicRealm(realm, dynamicObject) as Flow<T>\n-            }\n-            else -> throw UnsupportedOperationException(\"${realm.javaClass} does not support RxJava. See https://realm.io/docs/java/latest/#rxjava for more details.\")\n-        }\n-    } else {\n-        return flowOf(this)\n-    }\n-}\n-\n-private fun <T : RealmModel> flowFromRealm(realm: Realm, obj: T): Flow<T> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (realm.isFrozen) {\n-        return flowOf(obj)\n-    }\n-\n-    val config = realm.configuration\n-\n-    return callbackFlow<T> {\n-        // Do nothing if the object is invalid\n-        if (!obj.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<T> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        obj.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(obj))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                obj.removeChangeListener(listener)\n-                flowRealm.close()\n-            }\n-        }\n-    }\n-}\n-\n-private fun flowFromDynamicRealm(\n-        dynamicRealm: DynamicRealm,\n-        dynamicObject: DynamicRealmObject\n-): Flow<DynamicRealmObject> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (dynamicRealm.isFrozen) {\n-        return flowOf(dynamicObject)\n-    }\n-\n-    val config = dynamicRealm.configuration\n-\n-    return callbackFlow<DynamicRealmObject> {\n-        // Do nothing if the object is invalid\n-        if (!dynamicObject.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<DynamicRealmObject> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        dynamicObject.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(dynamicObject))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                dynamicObject.removeChangeListener(listener)\n-                flowRealm.close()\n+fun <T : RealmModel> T?.toFlow(): Flow<T?> {\n+    // Return flow with object or null flow if this function is called on null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxMTczMg=="}, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzA1NTY3OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoxMzoxOVrOHyf5kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoxMzoxOVrOHyf5kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxMzQ5MA==", "bodyText": "Maybe add a comment about unmanaged objects only being emitted once?", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522713490", "createdAt": "2020-11-13T07:13:19Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "diffHunk": "@@ -56,94 +54,25 @@ import kotlinx.coroutines.flow.flowOf\n  * @return Kotlin [Flow] on which calls to `onEach` or `collect` can be made.\n  */\n @Beta\n-fun <T : RealmModel> T.toFlow(): Flow<T> {\n-    val obj = this\n-    return if (obj is RealmObjectProxy) {\n-        val proxy = obj as RealmObjectProxy\n-        val realm = proxy.`realmGet$proxyState`().`realm$realm`\n-\n-        when (realm) {\n-            is Realm -> flowFromRealm<T>(realm, obj)\n-            is DynamicRealm -> {\n-                val dynamicObject = obj as DynamicRealmObject\n-                flowFromDynamicRealm(realm, dynamicObject) as Flow<T>\n-            }\n-            else -> throw UnsupportedOperationException(\"${realm.javaClass} does not support RxJava. See https://realm.io/docs/java/latest/#rxjava for more details.\")\n-        }\n-    } else {\n-        return flowOf(this)\n-    }\n-}\n-\n-private fun <T : RealmModel> flowFromRealm(realm: Realm, obj: T): Flow<T> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (realm.isFrozen) {\n-        return flowOf(obj)\n-    }\n-\n-    val config = realm.configuration\n-\n-    return callbackFlow<T> {\n-        // Do nothing if the object is invalid\n-        if (!obj.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<T> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        obj.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(obj))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                obj.removeChangeListener(listener)\n-                flowRealm.close()\n-            }\n-        }\n-    }\n-}\n-\n-private fun flowFromDynamicRealm(\n-        dynamicRealm: DynamicRealm,\n-        dynamicObject: DynamicRealmObject\n-): Flow<DynamicRealmObject> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (dynamicRealm.isFrozen) {\n-        return flowOf(dynamicObject)\n-    }\n-\n-    val config = dynamicRealm.configuration\n-\n-    return callbackFlow<DynamicRealmObject> {\n-        // Do nothing if the object is invalid\n-        if (!dynamicObject.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<DynamicRealmObject> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        dynamicObject.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(dynamicObject))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                dynamicObject.removeChangeListener(listener)\n-                flowRealm.close()\n+fun <T : RealmModel> T?.toFlow(): Flow<T?> {\n+    // Return flow with object or null flow if this function is called on null\n+    return this?.let { obj ->\n+        if (obj is RealmObjectProxy) {\n+            val proxy = obj as RealmObjectProxy\n+\n+            @Suppress(\"INACCESSIBLE_TYPE\")\n+            when (val realm = proxy.`realmGet$proxyState`().`realm$realm`) {\n+                is Realm -> realm.configuration.flowFactory?.from<T>(realm, obj)\n+                        ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")\n+                is DynamicRealm ->\n+                    (obj as DynamicRealmObject).let { dynamicRealmObject ->\n+                        (realm.configuration.flowFactory?.from(realm, dynamicRealmObject)\n+                                ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")) as Flow<T?>\n+                    }\n+                else -> throw UnsupportedOperationException(\"${realm.javaClass} is not supported as a candidate for 'toFlow'. Only subclasses of RealmModel/RealmObject can be used.\")\n             }\n+        } else {\n+            return flowOf(this)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzA2NjE1OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmResultsExtensions.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoxNToyMVrOHygAZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoxNToyMVrOHygAZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxNTIzOQ==", "bodyText": "After thinking a bit about this,  I think we should introduce this method as well. IMO the one just returning the RealmResults are far easier to consume, this one is slightly annoying as you have to unpack things everytime, but it still has a lot of uses.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522715239", "createdAt": "2020-11-13T07:15:21Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmResultsExtensions.kt", "diffHunk": "@@ -63,38 +57,17 @@ import kotlinx.coroutines.flow.flowOf\n  */\n @Beta\n fun <T : RealmModel> RealmResults<T>.toFlow(): Flow<RealmResults<T>> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (realm.isFrozen) {\n-        return flowOf(this)\n-    }\n-\n-    val config = realm.configuration\n-\n-    return callbackFlow {\n-        val results = this@toFlow\n-\n-        // Do nothing if the results are invalid\n-        if (!results.isValid) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<RealmResults<T>> { listenerResults ->\n-            offer(listenerResults.freeze())\n-        }\n-\n-        results.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze())\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                results.removeChangeListener(listener)\n-                flowRealm.close()\n-            }\n-        }\n+    @Suppress(\"INACCESSIBLE_TYPE\")\n+    return when (val realmInstance = baseRealm) {\n+        is Realm -> realmInstance.configuration.flowFactory?.from(baseRealm as Realm, this)\n+                ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")\n+        is DynamicRealm -> realmInstance.configuration.flowFactory?.from(baseRealm as DynamicRealm, this)\n+                ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")\n+        else -> throw IllegalStateException(\"Wrong type of Realm.\")\n     }\n }\n+\n+// TODO figure out if we want to do this as a separate method or merge both in one that delivers changesets and results", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzA3NTI3OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoxNjo1M1rOHygGOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoxNjo1M1rOHygGOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxNjczMA==", "bodyText": "I would probably just delete this comment.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522716730", "createdAt": "2020-11-13T07:16:53Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/build.gradle", "diffHunk": "@@ -208,8 +208,14 @@ repositories {\n \n dependencies {\n \n+    // Hidden from deliverable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzEwNDYxOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoyMjoxNlrOHygaFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoyMjoxNlrOHygaFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMTgxMw==", "bodyText": "Missing test for what happens if you try to assign null to the factory. I assume we want to throw an IllegalArgumentException?", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522721813", "createdAt": "2020-11-13T07:22:16Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java", "diffHunk": "@@ -796,6 +801,68 @@ public void rxFactory() {\n         assertFalse(configuration2.getRxFactory() == dummyFactory);\n     }\n \n+    @Test\n+    public void coroutinesFactory_defaultNotNull() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzEwNzIxOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncConfigurationTests.kt", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoyMjo0N1rOHygbxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDozMDo1MlrOHypBgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMjI0NQ==", "bodyText": "Same, missing test for what happens if you assign null", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522722245", "createdAt": "2020-11-13T07:22:47Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncConfigurationTests.kt", "diffHunk": "@@ -424,4 +431,57 @@ class SyncConfigurationTests {\n                 .build()\n         assertTrue(configuration.isAllowWritesOnUiThread)\n     }\n+\n+    @Test\n+    fun coroutinesFactory_defaultNonNull() {\n+        val configuration = SyncConfiguration.Builder(createTestUser(app), DEFAULT_PARTITION)\n+                .build()\n+        assertNotNull(configuration.flowFactory)\n+    }\n+\n+    @Test\n+    fun coroutinesFactory() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2MTQ3OA==", "bodyText": "This is a Kotlin class, so non-nullability is enforced after adding @Nonnull to the Java method.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522861478", "createdAt": "2020-11-13T10:27:56Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncConfigurationTests.kt", "diffHunk": "@@ -424,4 +431,57 @@ class SyncConfigurationTests {\n                 .build()\n         assertTrue(configuration.isAllowWritesOnUiThread)\n     }\n+\n+    @Test\n+    fun coroutinesFactory_defaultNonNull() {\n+        val configuration = SyncConfiguration.Builder(createTestUser(app), DEFAULT_PARTITION)\n+                .build()\n+        assertNotNull(configuration.flowFactory)\n+    }\n+\n+    @Test\n+    fun coroutinesFactory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMjI0NQ=="}, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2Mjk3Ng==", "bodyText": "No, it doesn't prevent that when calling it from Java. At best you get a warning which can be missed or ignored.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522862976", "createdAt": "2020-11-13T10:30:52Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncConfigurationTests.kt", "diffHunk": "@@ -424,4 +431,57 @@ class SyncConfigurationTests {\n                 .build()\n         assertTrue(configuration.isAllowWritesOnUiThread)\n     }\n+\n+    @Test\n+    fun coroutinesFactory_defaultNonNull() {\n+        val configuration = SyncConfiguration.Builder(createTestUser(app), DEFAULT_PARTITION)\n+                .build()\n+        assertNotNull(configuration.flowFactory)\n+    }\n+\n+    @Test\n+    fun coroutinesFactory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMjI0NQ=="}, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzExMTU0OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoyMzozMlrOHygedg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoyMzozMlrOHygedg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMjkzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Warning: we discourage using this property directly from your code.\n          \n          \n            \n                 * Warning: This field is only exposed for internal usage, and should not be used.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522722934", "createdAt": "2020-11-13T07:23:32Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java", "diffHunk": "@@ -25,7 +25,13 @@\n     private static final String NOT_SUPPORTED_MESSAGE = \"This method is not supported by 'RealmResults' or\" +\n             \" 'OrderedRealmCollectionSnapshot'.\";\n \n-    final BaseRealm realm;\n+    /**\n+     * The {@link BaseRealm} instance in which this collection resides.\n+     * <p>\n+     * Warning: we discourage using this property directly from your code.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzExNzQxOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/java/io/realm/RealmConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoyNDozOVrOHygigg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoyNDozOVrOHygigg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMzk3MA==", "bodyText": "Missing Javadoc", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522723970", "createdAt": "2020-11-13T07:24:39Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/RealmConfiguration.java", "diffHunk": "@@ -267,6 +272,18 @@ public RxObservableFactory getRxFactory() {\n         return rxObservableFactory;\n     }\n \n+    /**\n+     * FIXME", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzExOTYzOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/java/io/realm/RealmConfiguration.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoyNTowNlrOHygkEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDoyMTowNlrOHyotSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyNDM3MA==", "bodyText": "We should guard against this in the builder so it can never be null here.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522724370", "createdAt": "2020-11-13T07:25:06Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/RealmConfiguration.java", "diffHunk": "@@ -267,6 +272,18 @@ public RxObservableFactory getRxFactory() {\n         return rxObservableFactory;\n     }\n \n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    @Nullable\n+    public FlowFactory getFlowFactory() {\n+        if (flowFactory == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0ODkyOA==", "bodyText": "Is this not the same case as with the Rx factory? It will be null if it isn't present in the classpath. By the way, I have just added a utility method for checking whether Flows are present or not.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522848928", "createdAt": "2020-11-13T10:04:28Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/java/io/realm/RealmConfiguration.java", "diffHunk": "@@ -267,6 +272,18 @@ public RxObservableFactory getRxFactory() {\n         return rxObservableFactory;\n     }\n \n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    @Nullable\n+    public FlowFactory getFlowFactory() {\n+        if (flowFactory == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyNDM3MA=="}, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1NzgwMA==", "bodyText": "Oh, I see what you mean. Sure, I will mark the parameter as @Nonnull (for Kotlin's sake) and throw an exception in case we still receive null in Java - and will add the same guard for the Rx factory because it seems we are missing it too.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522857800", "createdAt": "2020-11-13T10:21:06Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/java/io/realm/RealmConfiguration.java", "diffHunk": "@@ -267,6 +272,18 @@ public RxObservableFactory getRxFactory() {\n         return rxObservableFactory;\n     }\n \n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    @Nullable\n+    public FlowFactory getFlowFactory() {\n+        if (flowFactory == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyNDM3MA=="}, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzEzMTkzOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/java/io/realm/RealmList.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoyNzoxM1rOHygsYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoyNzoxM1rOHygsYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyNjQ5Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Warning: we discourage using this property directly from your code.\n          \n          \n            \n                 * Warning: This field is only exposed for internal usage, and should not be used.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522726496", "createdAt": "2020-11-13T07:27:13Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/RealmList.java", "diffHunk": "@@ -73,7 +73,14 @@\n \n     // Always null if RealmList is unmanaged, always non-null if managed.\n     private final ManagedListOperator<E> osListOperator;\n-    protected final BaseRealm realm;\n+\n+    /**\n+     * The {@link BaseRealm} instance in which this list resides.\n+     * <p>\n+     * Warning: we discourage using this property directly from your code.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzE0OTg1OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/java/io/realm/coroutines/FlowFactory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzozMDo0MVrOHyg4lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTozOTo0MVrOHzwfdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyOTYyMw==", "bodyText": "I think we might want to add the changeSetsFrom methods already now to this interface. Even if we don't expose them in this PR, it will prevent a later breaking change?\nBut then again, the interface is marked Beta.\nThoughts?", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522729623", "createdAt": "2020-11-13T07:30:41Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/FlowFactory.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines;\n+\n+import javax.annotation.Nonnull;\n+\n+import io.realm.DynamicRealm;\n+import io.realm.DynamicRealmObject;\n+import io.realm.Realm;\n+import io.realm.RealmList;\n+import io.realm.RealmModel;\n+import io.realm.RealmObject;\n+import io.realm.RealmResults;\n+import io.realm.annotations.Beta;\n+import kotlinx.coroutines.flow.Flow;\n+\n+/**\n+ * Factory interface for creating Kotlin {@link Flow}s for Realm classes.\n+ */\n+@Beta\n+public interface FlowFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1NTExMw==", "bodyText": "I will have a look at the current implementation for Rx. I will get back to you once I have a better idea about whether it's doable right away or not.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522855113", "createdAt": "2020-11-13T10:16:07Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/FlowFactory.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines;\n+\n+import javax.annotation.Nonnull;\n+\n+import io.realm.DynamicRealm;\n+import io.realm.DynamicRealmObject;\n+import io.realm.Realm;\n+import io.realm.RealmList;\n+import io.realm.RealmModel;\n+import io.realm.RealmObject;\n+import io.realm.RealmResults;\n+import io.realm.annotations.Beta;\n+import kotlinx.coroutines.flow.Flow;\n+\n+/**\n+ * Factory interface for creating Kotlin {@link Flow}s for Realm classes.\n+ */\n+@Beta\n+public interface FlowFactory {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyOTYyMw=="}, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzMzkxMA==", "bodyText": "I've added the implementation for all changeset methods and tests for them. I have left all the factory methods markes as \"beta\".", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r524033910", "createdAt": "2020-11-16T09:39:41Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/FlowFactory.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines;\n+\n+import javax.annotation.Nonnull;\n+\n+import io.realm.DynamicRealm;\n+import io.realm.DynamicRealmObject;\n+import io.realm.Realm;\n+import io.realm.RealmList;\n+import io.realm.RealmModel;\n+import io.realm.RealmObject;\n+import io.realm.RealmResults;\n+import io.realm.annotations.Beta;\n+import kotlinx.coroutines.flow.Flow;\n+\n+/**\n+ * Factory interface for creating Kotlin {@link Flow}s for Realm classes.\n+ */\n+@Beta\n+public interface FlowFactory {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyOTYyMw=="}, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzE2MjQ1OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzozMzowM1rOHyhBRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzozMzowM1rOHyhBRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczMTg0NQ==", "bodyText": "Flow\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Flow factory used by Realm by default.\n          \n          \n            \n             * Factory class used to create coroutine Flows. This class is used by default unless overridden in {@link RealmConfiguration.Builder#flowFactory(FlowFactory)}.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522731845", "createdAt": "2020-11-13T07:33:03Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,357 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Flow factory used by Realm by default.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzE2NjE5OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzozMzo0N1rOHyhD2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNDoxNTo0NVrOHyv7yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczMjUwNg==", "bodyText": "What actually happens in our Javadoc? Is this class even listed there? If not, that is a problem, that might prevent us from implementing this in Kotlin. \ud83e\udd14", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522732506", "createdAt": "2020-11-13T07:33:47Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,357 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Flow factory used by Realm by default.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1MzM2OA==", "bodyText": "I had to add an exception to exclude Kotlin files from being javadoc'ed in the build.gradle script since the mere existence of this class was causing the javadoc task to fail. I think it is totally ignored at the moment. But it is a valid concern. I don't think javadoc can ever document Kotlin classes, it can only be done with dokka, but then I'm not sure how to glue the two outputs together...", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522853368", "createdAt": "2020-11-13T10:12:58Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,357 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Flow factory used by Realm by default.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczMjUwNg=="}, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg4NDQxNA==", "bodyText": "It seems it might be possible to generate the javadoc using dokka instead: https://blog.jetbrains.com/kotlin/2020/08/dokka-preview-based-on-kotlin-1-4-0-rc/", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522884414", "createdAt": "2020-11-13T11:11:57Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,357 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Flow factory used by Realm by default.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczMjUwNg=="}, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg5MjYzMQ==", "bodyText": "I am unsure about being able to write this class in Java. The file containing the ProducerScope.awaitClose extension function doesn't have the @file:JvmName that would make it visible from Java, and so far it seems impossible to call it using a ProducerScope instance from java \ud83d\ude1e", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522892631", "createdAt": "2020-11-13T11:28:51Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,357 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Flow factory used by Realm by default.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczMjUwNg=="}, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk3NjIwMA==", "bodyText": "Will add an internal Kotlin class that will be called from a Java class that implements the flow interface. This way we will not have issues with javadoc.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522976200", "createdAt": "2020-11-13T14:15:45Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,357 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Flow factory used by Realm by default.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczMjUwNg=="}, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzE3ODEwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/sync/SyncConfiguration.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzozNjowMlrOHyhLfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDoyMToyMlrOHyotzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczNDQ2Mg==", "bodyText": "We should guard against null here.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522734462", "createdAt": "2020-11-13T07:36:02Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/sync/SyncConfiguration.java", "diffHunk": "@@ -793,6 +799,17 @@ public Builder rxFactory(RxObservableFactory factory) {\n             return this;\n         }\n \n+        /**\n+         * Sets the {@link FlowFactory} used to create coroutines Flows from Realm objects.\n+         * The default factory is {@link RealmFlowFactory}.\n+         *\n+         * @param factory factory to use.\n+         */\n+        public Builder flowFactory(FlowFactory factory) {\n+            flowFactory = factory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1MzUwNw==", "bodyText": "See #7191 (comment)", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522853507", "createdAt": "2020-11-13T10:13:17Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/sync/SyncConfiguration.java", "diffHunk": "@@ -793,6 +799,17 @@ public Builder rxFactory(RxObservableFactory factory) {\n             return this;\n         }\n \n+        /**\n+         * Sets the {@link FlowFactory} used to create coroutines Flows from Realm objects.\n+         * The default factory is {@link RealmFlowFactory}.\n+         *\n+         * @param factory factory to use.\n+         */\n+        public Builder flowFactory(FlowFactory factory) {\n+            flowFactory = factory;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczNDQ2Mg=="}, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1NzkzMw==", "bodyText": "Got it - #7191 (comment)", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522857933", "createdAt": "2020-11-13T10:21:22Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/sync/SyncConfiguration.java", "diffHunk": "@@ -793,6 +799,17 @@ public Builder rxFactory(RxObservableFactory factory) {\n             return this;\n         }\n \n+        /**\n+         * Sets the {@link FlowFactory} used to create coroutines Flows from Realm objects.\n+         * The default factory is {@link RealmFlowFactory}.\n+         *\n+         * @param factory factory to use.\n+         */\n+        public Builder flowFactory(FlowFactory factory) {\n+            flowFactory = factory;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczNDQ2Mg=="}, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzE4MDc5OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzozNjozMFrOHyhNJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDoxNDoxNFrOHyoehA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczNDg4Ng==", "bodyText": "We seem to be missing tests for this?", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522734886", "createdAt": "2020-11-13T07:36:30Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "diffHunk": "@@ -56,94 +54,25 @@ import kotlinx.coroutines.flow.flowOf\n  * @return Kotlin [Flow] on which calls to `onEach` or `collect` can be made.\n  */\n @Beta\n-fun <T : RealmModel> T.toFlow(): Flow<T> {\n-    val obj = this\n-    return if (obj is RealmObjectProxy) {\n-        val proxy = obj as RealmObjectProxy\n-        val realm = proxy.`realmGet$proxyState`().`realm$realm`\n-\n-        when (realm) {\n-            is Realm -> flowFromRealm<T>(realm, obj)\n-            is DynamicRealm -> {\n-                val dynamicObject = obj as DynamicRealmObject\n-                flowFromDynamicRealm(realm, dynamicObject) as Flow<T>\n-            }\n-            else -> throw UnsupportedOperationException(\"${realm.javaClass} does not support RxJava. See https://realm.io/docs/java/latest/#rxjava for more details.\")\n-        }\n-    } else {\n-        return flowOf(this)\n-    }\n-}\n-\n-private fun <T : RealmModel> flowFromRealm(realm: Realm, obj: T): Flow<T> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (realm.isFrozen) {\n-        return flowOf(obj)\n-    }\n-\n-    val config = realm.configuration\n-\n-    return callbackFlow<T> {\n-        // Do nothing if the object is invalid\n-        if (!obj.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<T> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        obj.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(obj))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                obj.removeChangeListener(listener)\n-                flowRealm.close()\n-            }\n-        }\n-    }\n-}\n-\n-private fun flowFromDynamicRealm(\n-        dynamicRealm: DynamicRealm,\n-        dynamicObject: DynamicRealmObject\n-): Flow<DynamicRealmObject> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (dynamicRealm.isFrozen) {\n-        return flowOf(dynamicObject)\n-    }\n-\n-    val config = dynamicRealm.configuration\n-\n-    return callbackFlow<DynamicRealmObject> {\n-        // Do nothing if the object is invalid\n-        if (!dynamicObject.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<DynamicRealmObject> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        dynamicObject.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(dynamicObject))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                dynamicObject.removeChangeListener(listener)\n-                flowRealm.close()\n+fun <T : RealmModel> T?.toFlow(): Flow<T?> {\n+    // Return flow with object or null flow if this function is called on null\n+    return this?.let { obj ->\n+        if (obj is RealmObjectProxy) {\n+            val proxy = obj as RealmObjectProxy\n+\n+            @Suppress(\"INACCESSIBLE_TYPE\")\n+            when (val realm = proxy.`realmGet$proxyState`().`realm$realm`) {\n+                is Realm -> realm.configuration.flowFactory?.from<T>(realm, obj)\n+                        ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")\n+                is DynamicRealm ->\n+                    (obj as DynamicRealmObject).let { dynamicRealmObject ->\n+                        (realm.configuration.flowFactory?.from(realm, dynamicRealmObject)\n+                                ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")) as Flow<T?>\n+                    }\n+                else -> throw UnsupportedOperationException(\"${realm.javaClass} is not supported as a candidate for 'toFlow'. Only subclasses of RealmModel/RealmObject can be used.\")\n             }\n+        } else {\n+            return flowOf(this)\n         }\n-    }\n+    } ?: flowOf(null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1NDAyMA==", "bodyText": "No, it is here CoroutinesTests.realmObject_toFlow_nullObjectEmitsNullFlow.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522854020", "createdAt": "2020-11-13T10:14:14Z", "author": {"login": "edualonso"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "diffHunk": "@@ -56,94 +54,25 @@ import kotlinx.coroutines.flow.flowOf\n  * @return Kotlin [Flow] on which calls to `onEach` or `collect` can be made.\n  */\n @Beta\n-fun <T : RealmModel> T.toFlow(): Flow<T> {\n-    val obj = this\n-    return if (obj is RealmObjectProxy) {\n-        val proxy = obj as RealmObjectProxy\n-        val realm = proxy.`realmGet$proxyState`().`realm$realm`\n-\n-        when (realm) {\n-            is Realm -> flowFromRealm<T>(realm, obj)\n-            is DynamicRealm -> {\n-                val dynamicObject = obj as DynamicRealmObject\n-                flowFromDynamicRealm(realm, dynamicObject) as Flow<T>\n-            }\n-            else -> throw UnsupportedOperationException(\"${realm.javaClass} does not support RxJava. See https://realm.io/docs/java/latest/#rxjava for more details.\")\n-        }\n-    } else {\n-        return flowOf(this)\n-    }\n-}\n-\n-private fun <T : RealmModel> flowFromRealm(realm: Realm, obj: T): Flow<T> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (realm.isFrozen) {\n-        return flowOf(obj)\n-    }\n-\n-    val config = realm.configuration\n-\n-    return callbackFlow<T> {\n-        // Do nothing if the object is invalid\n-        if (!obj.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<T> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        obj.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(obj))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                obj.removeChangeListener(listener)\n-                flowRealm.close()\n-            }\n-        }\n-    }\n-}\n-\n-private fun flowFromDynamicRealm(\n-        dynamicRealm: DynamicRealm,\n-        dynamicObject: DynamicRealmObject\n-): Flow<DynamicRealmObject> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (dynamicRealm.isFrozen) {\n-        return flowOf(dynamicObject)\n-    }\n-\n-    val config = dynamicRealm.configuration\n-\n-    return callbackFlow<DynamicRealmObject> {\n-        // Do nothing if the object is invalid\n-        if (!dynamicObject.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<DynamicRealmObject> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        dynamicObject.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(dynamicObject))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                dynamicObject.removeChangeListener(listener)\n-                flowRealm.close()\n+fun <T : RealmModel> T?.toFlow(): Flow<T?> {\n+    // Return flow with object or null flow if this function is called on null\n+    return this?.let { obj ->\n+        if (obj is RealmObjectProxy) {\n+            val proxy = obj as RealmObjectProxy\n+\n+            @Suppress(\"INACCESSIBLE_TYPE\")\n+            when (val realm = proxy.`realmGet$proxyState`().`realm$realm`) {\n+                is Realm -> realm.configuration.flowFactory?.from<T>(realm, obj)\n+                        ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")\n+                is DynamicRealm ->\n+                    (obj as DynamicRealmObject).let { dynamicRealmObject ->\n+                        (realm.configuration.flowFactory?.from(realm, dynamicRealmObject)\n+                                ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")) as Flow<T?>\n+                    }\n+                else -> throw UnsupportedOperationException(\"${realm.javaClass} is not supported as a candidate for 'toFlow'. Only subclasses of RealmModel/RealmObject can be used.\")\n             }\n+        } else {\n+            return flowOf(this)\n         }\n-    }\n+    } ?: flowOf(null)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczNDg4Ng=="}, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3ODIzNTg5OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMTo1Mzo0NFrOHyrg2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMjo1NDowOVrOHytOfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwMzc3MQ==", "bodyText": "Remember to awaitClose {}. And maybe also add a test for that path.\nAccording to #7180.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522903771", "createdAt": "2020-11-13T11:53:44Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Factory class used to create coroutine [Flow]s.\n+ *\n+ * This class is used by default unless overridden in [RealmConfiguration.Builder.flowFactory].\n+ */\n+@Beta\n+class RealmFlowFactory(\n+        private val returnFrozenObjects: Boolean = true\n+) : FlowFactory {\n+\n+    @Beta\n+    override fun from(realm: Realm): Flow<Realm> {\n+        if (realm.isFrozen) {\n+            return flowOf(realm)\n+        }\n+\n+        return callbackFlow {\n+            val flowRealm = Realm.getInstance(realm.configuration)\n+            val listener = RealmChangeListener<Realm> { listenerRealm ->\n+                if (returnFrozenObjects) {\n+                    offer(realm.freeze())\n+                } else {\n+                    offer(listenerRealm)\n+                }\n+            }\n+\n+            flowRealm.addChangeListener(listener)\n+\n+            if (returnFrozenObjects) {\n+                offer(flowRealm.freeze())\n+            } else {\n+                offer(flowRealm)\n+            }\n+\n+            awaitClose {\n+                flowRealm.removeChangeListener(listener)\n+                flowRealm.close()\n+            }\n+        }\n+    }\n+\n+    @Beta\n+    override fun from(dynamicRealm: DynamicRealm): Flow<DynamicRealm> {\n+        if (dynamicRealm.isFrozen) {\n+            return flowOf(dynamicRealm)\n+        }\n+\n+        return callbackFlow {\n+            val flowRealm = DynamicRealm.getInstance(dynamicRealm.configuration)\n+            val listener = RealmChangeListener<DynamicRealm> { listenerRealm ->\n+                if (returnFrozenObjects) {\n+                    offer(dynamicRealm.freeze())\n+                } else {\n+                    offer(listenerRealm)\n+                }\n+            }\n+\n+            flowRealm.addChangeListener(listener)\n+\n+            if (returnFrozenObjects) {\n+                offer(flowRealm.freeze())\n+            } else {\n+                offer(flowRealm)\n+            }\n+\n+            awaitClose {\n+                flowRealm.removeChangeListener(listener)\n+                flowRealm.close()\n+            }\n+        }\n+    }\n+\n+    @Beta\n+    override fun <T> from(realm: Realm, results: RealmResults<T>): Flow<RealmResults<T>> {\n+        // Return \"as is\" if frozen, there will be no listening for changes\n+        if (realm.isFrozen) {\n+            return flowOf(results)\n+        }\n+\n+        val config = realm.configuration\n+\n+        return callbackFlow {\n+            // Do nothing if the results are invalid\n+            if (!results.isValid) {\n+                return@callbackFlow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9fd64231c1aeb639f8b83311003eb2ce856868"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkzMTgzOQ==", "bodyText": "Completely forgot about these \ud83e\udd26", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522931839", "createdAt": "2020-11-13T12:54:09Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Factory class used to create coroutine [Flow]s.\n+ *\n+ * This class is used by default unless overridden in [RealmConfiguration.Builder.flowFactory].\n+ */\n+@Beta\n+class RealmFlowFactory(\n+        private val returnFrozenObjects: Boolean = true\n+) : FlowFactory {\n+\n+    @Beta\n+    override fun from(realm: Realm): Flow<Realm> {\n+        if (realm.isFrozen) {\n+            return flowOf(realm)\n+        }\n+\n+        return callbackFlow {\n+            val flowRealm = Realm.getInstance(realm.configuration)\n+            val listener = RealmChangeListener<Realm> { listenerRealm ->\n+                if (returnFrozenObjects) {\n+                    offer(realm.freeze())\n+                } else {\n+                    offer(listenerRealm)\n+                }\n+            }\n+\n+            flowRealm.addChangeListener(listener)\n+\n+            if (returnFrozenObjects) {\n+                offer(flowRealm.freeze())\n+            } else {\n+                offer(flowRealm)\n+            }\n+\n+            awaitClose {\n+                flowRealm.removeChangeListener(listener)\n+                flowRealm.close()\n+            }\n+        }\n+    }\n+\n+    @Beta\n+    override fun from(dynamicRealm: DynamicRealm): Flow<DynamicRealm> {\n+        if (dynamicRealm.isFrozen) {\n+            return flowOf(dynamicRealm)\n+        }\n+\n+        return callbackFlow {\n+            val flowRealm = DynamicRealm.getInstance(dynamicRealm.configuration)\n+            val listener = RealmChangeListener<DynamicRealm> { listenerRealm ->\n+                if (returnFrozenObjects) {\n+                    offer(dynamicRealm.freeze())\n+                } else {\n+                    offer(listenerRealm)\n+                }\n+            }\n+\n+            flowRealm.addChangeListener(listener)\n+\n+            if (returnFrozenObjects) {\n+                offer(flowRealm.freeze())\n+            } else {\n+                offer(flowRealm)\n+            }\n+\n+            awaitClose {\n+                flowRealm.removeChangeListener(listener)\n+                flowRealm.close()\n+            }\n+        }\n+    }\n+\n+    @Beta\n+    override fun <T> from(realm: Realm, results: RealmResults<T>): Flow<RealmResults<T>> {\n+        // Return \"as is\" if frozen, there will be no listening for changes\n+        if (realm.isFrozen) {\n+            return flowOf(results)\n+        }\n+\n+        val config = realm.configuration\n+\n+        return callbackFlow {\n+            // Do nothing if the results are invalid\n+            if (!results.isValid) {\n+                return@callbackFlow", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwMzc3MQ=="}, "originalCommit": {"oid": "fe9fd64231c1aeb639f8b83311003eb2ce856868"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3ODIzNjcxOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMTo1NDowM1rOHyrhXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMTo1NDowM1rOHyrhXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwMzkwMg==", "bodyText": "Same.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522903902", "createdAt": "2020-11-13T11:54:03Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Factory class used to create coroutine [Flow]s.\n+ *\n+ * This class is used by default unless overridden in [RealmConfiguration.Builder.flowFactory].\n+ */\n+@Beta\n+class RealmFlowFactory(\n+        private val returnFrozenObjects: Boolean = true\n+) : FlowFactory {\n+\n+    @Beta\n+    override fun from(realm: Realm): Flow<Realm> {\n+        if (realm.isFrozen) {\n+            return flowOf(realm)\n+        }\n+\n+        return callbackFlow {\n+            val flowRealm = Realm.getInstance(realm.configuration)\n+            val listener = RealmChangeListener<Realm> { listenerRealm ->\n+                if (returnFrozenObjects) {\n+                    offer(realm.freeze())\n+                } else {\n+                    offer(listenerRealm)\n+                }\n+            }\n+\n+            flowRealm.addChangeListener(listener)\n+\n+            if (returnFrozenObjects) {\n+                offer(flowRealm.freeze())\n+            } else {\n+                offer(flowRealm)\n+            }\n+\n+            awaitClose {\n+                flowRealm.removeChangeListener(listener)\n+                flowRealm.close()\n+            }\n+        }\n+    }\n+\n+    @Beta\n+    override fun from(dynamicRealm: DynamicRealm): Flow<DynamicRealm> {\n+        if (dynamicRealm.isFrozen) {\n+            return flowOf(dynamicRealm)\n+        }\n+\n+        return callbackFlow {\n+            val flowRealm = DynamicRealm.getInstance(dynamicRealm.configuration)\n+            val listener = RealmChangeListener<DynamicRealm> { listenerRealm ->\n+                if (returnFrozenObjects) {\n+                    offer(dynamicRealm.freeze())\n+                } else {\n+                    offer(listenerRealm)\n+                }\n+            }\n+\n+            flowRealm.addChangeListener(listener)\n+\n+            if (returnFrozenObjects) {\n+                offer(flowRealm.freeze())\n+            } else {\n+                offer(flowRealm)\n+            }\n+\n+            awaitClose {\n+                flowRealm.removeChangeListener(listener)\n+                flowRealm.close()\n+            }\n+        }\n+    }\n+\n+    @Beta\n+    override fun <T> from(realm: Realm, results: RealmResults<T>): Flow<RealmResults<T>> {\n+        // Return \"as is\" if frozen, there will be no listening for changes\n+        if (realm.isFrozen) {\n+            return flowOf(results)\n+        }\n+\n+        val config = realm.configuration\n+\n+        return callbackFlow {\n+            // Do nothing if the results are invalid\n+            if (!results.isValid) {\n+                return@callbackFlow\n+            }\n+\n+            // Get instance to ensure the Realm is open for as long as we are listening\n+            val flowRealm = Realm.getInstance(config)\n+            val listener = RealmChangeListener<RealmResults<T>> { listenerResults ->\n+                if (returnFrozenObjects) {\n+                    offer(listenerResults.freeze())\n+                } else {\n+                    offer(listenerResults)\n+                }\n+            }\n+\n+            results.addChangeListener(listener)\n+\n+            // Emit current value\n+            if (returnFrozenObjects) {\n+                offer(results.freeze())\n+            } else {\n+                offer(results)\n+            }\n+\n+            awaitClose {\n+                // Remove listener and cleanup\n+                if (!flowRealm.isClosed) {\n+                    results.removeChangeListener(listener)\n+                    flowRealm.close()\n+                }\n+            }\n+        }\n+    }\n+\n+    override fun <T> from(dynamicRealm: DynamicRealm, results: RealmResults<T>): Flow<RealmResults<T>> {\n+        // Return \"as is\" if frozen, there will be no listening for changes\n+        if (dynamicRealm.isFrozen) {\n+            return flowOf(results)\n+        }\n+\n+        val config = dynamicRealm.configuration\n+\n+        return callbackFlow {\n+            // Do nothing if the results are invalid\n+            if (!results.isValid) {\n+                return@callbackFlow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9fd64231c1aeb639f8b83311003eb2ce856868"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTc2NjA2OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmExtensions.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTozMDo0N1rOH0r7JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTozMDo0N1rOH0r7JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwNzY1Mg==", "bodyText": "Why is there a nullability check here when not for DynamicRealm?", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r525007652", "createdAt": "2020-11-17T09:30:47Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmExtensions.kt", "diffHunk": "@@ -96,6 +98,18 @@ inline fun <reified T : RealmModel> Realm.createEmbeddedObject(parentObject: Rea\n     return this.createEmbeddedObject(T::class.java, parentObject, parentProperty)\n }\n \n+/**\n+ * Creates a [Flow] for a [Realm]. It should emit the initial state of the Realm when subscribed to and\n+ * on each subsequent update of the Realm.\n+ *\n+ * @return Kotlin [Flow] that emit all updates to the Realm.\n+ */\n+@Beta\n+fun Realm.toflow(): Flow<Realm> {\n+    return configuration.flowFactory?.from(this)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d59993e4dac2cb4e3a5bdd94c9f3b0c3bd8d8eb"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTc4MDk2OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTozNDoyM1rOH0sEeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTozNDoyM1rOH0sEeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAxMDA0Mg==", "bodyText": "Normally we would do this to prevent accidental bugs to trigger the wrong failure:\nprivate RealmConfiguration.Builder builder =  configFactory.createConfigurationBuilder()\ntry {\n  builder.rxFactory(null)\n} catch (IllegalArgumentException e {\n  //...\n}", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r525010042", "createdAt": "2020-11-17T09:34:23Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java", "diffHunk": "@@ -796,6 +801,120 @@ public void rxFactory() {\n         assertFalse(configuration2.getRxFactory() == dummyFactory);\n     }\n \n+    @Test\n+    public void rxFactory_nullThrows() {\n+        try {\n+            configFactory.createConfigurationBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d59993e4dac2cb4e3a5bdd94c9f3b0c3bd8d8eb"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTc5NDUzOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTozNzoyMFrOH0sMkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTo0NTo1MFrOH0si2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAxMjExNQ==", "bodyText": "The argument about frozen should also be exposed as a public constructor for this class, as people cannot otherwise customize it.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r525012115", "createdAt": "2020-11-17T09:37:20Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines;\n+\n+import javax.annotation.Nonnull;\n+\n+import io.realm.DynamicRealm;\n+import io.realm.DynamicRealmObject;\n+import io.realm.Realm;\n+import io.realm.RealmList;\n+import io.realm.RealmModel;\n+import io.realm.RealmResults;\n+import io.realm.annotations.Beta;\n+import io.realm.internal.coroutines.InternalFlowFactory;\n+import io.realm.rx.CollectionChange;\n+import io.realm.rx.ObjectChange;\n+import kotlinx.coroutines.flow.Flow;\n+\n+/**\n+ * Factory class used to create coroutine {@link Flow}s.\n+ *\n+ * This class is used by default unless overridden in {@link io.realm.RealmConfiguration.Builder#flowFactory(FlowFactory}.\n+ */\n+@Beta\n+public class RealmFlowFactory implements FlowFactory {\n+\n+    private final InternalFlowFactory factory = new InternalFlowFactory(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d59993e4dac2cb4e3a5bdd94c9f3b0c3bd8d8eb"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAxNzgxNg==", "bodyText": "That's true, I missed this one.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r525017816", "createdAt": "2020-11-17T09:45:50Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines;\n+\n+import javax.annotation.Nonnull;\n+\n+import io.realm.DynamicRealm;\n+import io.realm.DynamicRealmObject;\n+import io.realm.Realm;\n+import io.realm.RealmList;\n+import io.realm.RealmModel;\n+import io.realm.RealmResults;\n+import io.realm.annotations.Beta;\n+import io.realm.internal.coroutines.InternalFlowFactory;\n+import io.realm.rx.CollectionChange;\n+import io.realm.rx.ObjectChange;\n+import kotlinx.coroutines.flow.Flow;\n+\n+/**\n+ * Factory class used to create coroutine {@link Flow}s.\n+ *\n+ * This class is used by default unless overridden in {@link io.realm.RealmConfiguration.Builder#flowFactory(FlowFactory}.\n+ */\n+@Beta\n+public class RealmFlowFactory implements FlowFactory {\n+\n+    private final InternalFlowFactory factory = new InternalFlowFactory(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAxMjExNQ=="}, "originalCommit": {"oid": "7d59993e4dac2cb4e3a5bdd94c9f3b0c3bd8d8eb"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 363, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}