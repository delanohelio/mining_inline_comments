{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg4MzA5ODU1", "number": 6776, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQyMTowMDoyNlrODoE2hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNVQxMzoxNzozOFrODoHXFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMzQ5MTI1OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQyMTowMDoyN1rOF2bjbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQyMTowNDozM1rOF2bkZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYxODg2Mw==", "bodyText": "Should be local", "url": "https://github.com/realm/realm-java/pull/6776#discussion_r392618863", "createdAt": "2020-03-14T21:00:27Z", "author": {"login": "Zhuinden"}, "path": "realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java", "diffHunk": "@@ -99,6 +99,8 @@ private void disposeSuccessfulTest(BaseRealm testRealm) {\n                 @Override\n                 public void run() {\n                     // Wait for Subscription to dispose of external resources\n+                    RealmLog.error(\"Global: \" + Realm.getGlobalInstanceCount(testRealm.getConfiguration()));\n+                    RealmLog.error(\"Local: \" + Realm.getGlobalInstanceCount(testRealm.getConfiguration()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce64f7b6210f89410f4af181240145b446c1ff36"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYxOTExMQ==", "bodyText": "Yeah, I already fixed it. Trying to locate a bug that only manifest on CI. 20 minute roundtrip times when debugging is fun...or something \ud83d\ude06", "url": "https://github.com/realm/realm-java/pull/6776#discussion_r392619111", "createdAt": "2020-03-14T21:04:33Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java", "diffHunk": "@@ -99,6 +99,8 @@ private void disposeSuccessfulTest(BaseRealm testRealm) {\n                 @Override\n                 public void run() {\n                     // Wait for Subscription to dispose of external resources\n+                    RealmLog.error(\"Global: \" + Realm.getGlobalInstanceCount(testRealm.getConfiguration()));\n+                    RealmLog.error(\"Local: \" + Realm.getGlobalInstanceCount(testRealm.getConfiguration()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYxODg2Mw=="}, "originalCommit": {"oid": "ce64f7b6210f89410f4af181240145b446c1ff36"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMzkwMjI4OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNVQxMzoxNzozOFrOF2e2yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMDoyNTowNFrOF3-qTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY3Mjk2OQ==", "bodyText": "Is it not possible to use Realm.refresh() here?", "url": "https://github.com/realm/realm-java/pull/6776#discussion_r392672969", "createdAt": "2020-03-15T13:17:38Z", "author": {"login": "Zhuinden"}, "path": "realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java", "diffHunk": "@@ -247,8 +247,17 @@ public void findFirstAsync_emittedOnSubscribe() {\n         final AllTypes asyncObj = realm.where(AllTypes.class).findFirstAsync();\n         subscription = asyncObj.<AllTypes>asFlowable().subscribe(rxObject -> {\n             assertTrue(rxObject.isFrozen());\n+            // Because the subscription is run asynchronously. There is a chance\n+            // the query resolved before the subscription triggers.\n+            // This means it is not deterministic what state is first emitted here.\n+            // It can either be a fully loaded object or one that is still loading.\n             assertFalse(rxObject.isValid());\n-            assertFalse(rxObject.isLoaded());\n+            if (rxObject.isLoaded()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7432181d8f2dbf81617d05cd5fdb9d51a9a42ddd"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY3MzE3MA==", "bodyText": "Yes, that would actually also have worked. Might make for a cleaner test \ud83d\udc4d", "url": "https://github.com/realm/realm-java/pull/6776#discussion_r392673170", "createdAt": "2020-03-15T13:20:10Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java", "diffHunk": "@@ -247,8 +247,17 @@ public void findFirstAsync_emittedOnSubscribe() {\n         final AllTypes asyncObj = realm.where(AllTypes.class).findFirstAsync();\n         subscription = asyncObj.<AllTypes>asFlowable().subscribe(rxObject -> {\n             assertTrue(rxObject.isFrozen());\n+            // Because the subscription is run asynchronously. There is a chance\n+            // the query resolved before the subscription triggers.\n+            // This means it is not deterministic what state is first emitted here.\n+            // It can either be a fully loaded object or one that is still loading.\n             assertFalse(rxObject.isValid());\n-            assertFalse(rxObject.isLoaded());\n+            if (rxObject.isLoaded()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY3Mjk2OQ=="}, "originalCommit": {"oid": "7432181d8f2dbf81617d05cd5fdb9d51a9a42ddd"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY3OTMzMg==", "bodyText": "Ups, to fast there. refresh() doesn't work on frozen objects which we emit as the default now.", "url": "https://github.com/realm/realm-java/pull/6776#discussion_r392679332", "createdAt": "2020-03-15T14:31:52Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java", "diffHunk": "@@ -247,8 +247,17 @@ public void findFirstAsync_emittedOnSubscribe() {\n         final AllTypes asyncObj = realm.where(AllTypes.class).findFirstAsync();\n         subscription = asyncObj.<AllTypes>asFlowable().subscribe(rxObject -> {\n             assertTrue(rxObject.isFrozen());\n+            // Because the subscription is run asynchronously. There is a chance\n+            // the query resolved before the subscription triggers.\n+            // This means it is not deterministic what state is first emitted here.\n+            // It can either be a fully loaded object or one that is still loading.\n             assertFalse(rxObject.isValid());\n-            assertFalse(rxObject.isLoaded());\n+            if (rxObject.isLoaded()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY3Mjk2OQ=="}, "originalCommit": {"oid": "7432181d8f2dbf81617d05cd5fdb9d51a9a42ddd"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAzMjM0Ng==", "bodyText": "Maybe realmObject.load()? \ud83e\udd14", "url": "https://github.com/realm/realm-java/pull/6776#discussion_r394032346", "createdAt": "2020-03-17T23:41:08Z", "author": {"login": "Zhuinden"}, "path": "realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java", "diffHunk": "@@ -247,8 +247,17 @@ public void findFirstAsync_emittedOnSubscribe() {\n         final AllTypes asyncObj = realm.where(AllTypes.class).findFirstAsync();\n         subscription = asyncObj.<AllTypes>asFlowable().subscribe(rxObject -> {\n             assertTrue(rxObject.isFrozen());\n+            // Because the subscription is run asynchronously. There is a chance\n+            // the query resolved before the subscription triggers.\n+            // This means it is not deterministic what state is first emitted here.\n+            // It can either be a fully loaded object or one that is still loading.\n             assertFalse(rxObject.isValid());\n-            assertFalse(rxObject.isLoaded());\n+            if (rxObject.isLoaded()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY3Mjk2OQ=="}, "originalCommit": {"oid": "7432181d8f2dbf81617d05cd5fdb9d51a9a42ddd"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI0MjYzNw==", "bodyText": "No, that doesn't work either. It isn't possible to change the state of frozen objects.\nThe only thing we can do is not emitting unloaded objects, which has to be filtered in the RealmObservableFactory.\nThe issue is that both findFirstAsync and subscribe are now asynchronous. Previously, subscribe was synchronous so you always knew that the first emission was an unloaded object.", "url": "https://github.com/realm/realm-java/pull/6776#discussion_r394242637", "createdAt": "2020-03-18T10:25:04Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java", "diffHunk": "@@ -247,8 +247,17 @@ public void findFirstAsync_emittedOnSubscribe() {\n         final AllTypes asyncObj = realm.where(AllTypes.class).findFirstAsync();\n         subscription = asyncObj.<AllTypes>asFlowable().subscribe(rxObject -> {\n             assertTrue(rxObject.isFrozen());\n+            // Because the subscription is run asynchronously. There is a chance\n+            // the query resolved before the subscription triggers.\n+            // This means it is not deterministic what state is first emitted here.\n+            // It can either be a fully loaded object or one that is still loading.\n             assertFalse(rxObject.isValid());\n-            assertFalse(rxObject.isLoaded());\n+            if (rxObject.isLoaded()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY3Mjk2OQ=="}, "originalCommit": {"oid": "7432181d8f2dbf81617d05cd5fdb9d51a9a42ddd"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 611, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}