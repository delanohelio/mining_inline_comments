{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNTAzMTc4", "number": 6939, "title": "Migrate and reenable sync realm integration test ", "bodyText": "Fixed issues:\n\n OS does not support custom headers. Implemented Java-rework until OS support is in place.\n\nA number of tests requires sessions to be closed, but we loose grip of them as tests intentionally triggers exceptions on getInstance. Already tracked in #5416. Tried incorporating shutdown_and_wait from realm/realm-object-store#1055 but did not solve the issue. Maybe dependant on realm/realm-object-store#1054 too.", "createdAt": "2020-06-10T14:39:58Z", "url": "https://github.com/realm/realm-java/pull/6939", "merged": true, "mergeCommit": {"oid": "26685d186faa1c00334d3e0e5dc8dc1bc2f3fcde"}, "closed": true, "closedAt": "2020-09-15T10:58:18Z", "author": {"login": "rorbech"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcphgFEgH2gAyNDMyNTAzMTc4Ojg3MzA4ZTVhNzZlMDkxZDY3ZmMyYWZkMmJlNTBhMDUwNzZiYjMxMGI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJFTy3AH2gAyNDMyNTAzMTc4OmRjMGU3MjAzMjczOTAyMGEyYWRjNmYxYzFmMjFiNGM5YWYyNjg1YTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "87308e5a76e091d67fc2afd2be50a05076bb310b", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/87308e5a76e091d67fc2afd2be50a05076bb310b", "committedDate": "2020-06-09T09:18:53Z", "message": "Move SyncedRealmIntegrationTests to Kotlin source set"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "592ca9e3bf6c4592c3b1e43c4ed2630c0ebe1b14", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/592ca9e3bf6c4592c3b1e43c4ed2630c0ebe1b14", "committedDate": "2020-06-09T09:20:28Z", "message": "Automatic conversion of SyncedRealmIntegrationTests to Kotlin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c4cbebf004ba9f6d8fbd2f8ff409e434aa73871", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/6c4cbebf004ba9f6d8fbd2f8ff409e434aa73871", "committedDate": "2020-06-10T14:30:11Z", "message": "Update to new Sync implementation and Kotlin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8de581890b1a233e6703b4539f4711f629e76c2", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/e8de581890b1a233e6703b4539f4711f629e76c2", "committedDate": "2020-06-24T07:10:57Z", "message": "Merge branch 'v10' into cr/sync-integration-test-realm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "185bb0adfc106ee36feb8be7a75c04d145922fe2", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/185bb0adfc106ee36feb8be7a75c04d145922fe2", "committedDate": "2020-06-30T07:18:11Z", "message": "Merge branch 'v10' into cr/sync-integration-test-realm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b7ca9a048ebbab34aca9cd14b265ba28b60c136", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/0b7ca9a048ebbab34aca9cd14b265ba28b60c136", "committedDate": "2020-06-30T07:21:41Z", "message": "Clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d98e193a4ef840b09b38a80e36c9aa8bb5a1a2e3", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/d98e193a4ef840b09b38a80e36c9aa8bb5a1a2e3", "committedDate": "2020-08-04T11:33:29Z", "message": "Merge branch 'v10' into cr/sync-integration-test-realm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/edba5df6d179e03470ae3561d695ba2771e93abf", "committedDate": "2020-08-07T13:18:25Z", "message": "Enable readOnly in read only test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2Nzc2NTU1", "url": "https://github.com/realm/realm-java/pull/6939#pullrequestreview-476776555", "createdAt": "2020-08-27T14:27:22Z", "commit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDoyNzoyM1rOHIS8rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDoyNzoyM1rOHIS8rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2MTEwMQ==", "bodyText": "Just delete this test", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r478461101", "createdAt": "2020-08-27T14:27:23Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/AppConfigurationTests.kt", "diffHunk": "@@ -297,4 +309,61 @@ class AppConfigurationTests {\n                     assertEquals(defaultHttpLogObfuscator, it.httpLogObfuscator)\n                 }\n     }\n+    // Check that custom headers and auth header renames are correctly used for HTTP requests\n+    // performed from Java.\n+    @Test\n+    fun javaRequestCustomHeaders() {\n+        var app: App? = null\n+        try {\n+            looperThread.runBlocking {\n+                app = TestApp(builder = { builder ->\n+                    builder.addCustomRequestHeader(CUSTOM_HEADER_NAME, CUSTOM_HEADER_VALUE)\n+                    builder.authorizationHeaderName(AUTH_HEADER_NAME)\n+                })\n+                runJavaRequestCustomHeadersTest(app!!)\n+            }\n+        } finally {\n+            app?.close()\n+        }\n+    }\n+\n+    // FIXME Seems to be outdated...cannot find an option for setting headers for a specific host", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2Nzc4NjA1", "url": "https://github.com/realm/realm-java/pull/6939#pullrequestreview-476778605", "createdAt": "2020-08-27T14:29:15Z", "commit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDoyOToxNVrOHITCcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDoyOToxNVrOHITCcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2MjU3OA==", "bodyText": "Hmm, I think I saw something about this being fixed. Try talking to @RedBeard0531", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r478462578", "createdAt": "2020-08-27T14:29:15Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import android.util.Log\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.SyncDog\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.log.RealmLogger\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.assertFailsWithErrorCode\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2Nzc5Mjg4", "url": "https://github.com/realm/realm-java/pull/6939#pullrequestreview-476779288", "createdAt": "2020-08-27T14:29:57Z", "commit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDoyOTo1OFrOHITEnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDoyOTo1OFrOHITEnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2MzEzNQ==", "bodyText": "Yes", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r478463135", "createdAt": "2020-08-27T14:29:58Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import android.util.Log\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.SyncDog\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.log.RealmLogger\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.assertFailsWithErrorCode\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been\n+            //  closed for now https://github.com/realm/realm-java/issues/5416\n+            if (e.message!!.contains(\"It's not allowed to delete the file\")) {\n+                // retry after 1 second\n+                SystemClock.sleep(1000)\n+                assertTrue(Realm.deleteRealm(config))\n+            }\n+        }\n+\n+        // FIXME Is this sufficient to test \"loginLogoutResumeSynching\"-case", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "originalPosition": 114}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NzgwNTkz", "url": "https://github.com/realm/realm-java/pull/6939#pullrequestreview-476780593", "createdAt": "2020-08-27T14:31:21Z", "commit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDozMToyMVrOHITIxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDozMToyMVrOHITIxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2NDE5OQ==", "bodyText": "Great, we should probably still keep the test as a kind of smoke test.", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r478464199", "createdAt": "2020-08-27T14:31:21Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import android.util.Log\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.SyncDog\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.log.RealmLogger\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.assertFailsWithErrorCode\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been\n+            //  closed for now https://github.com/realm/realm-java/issues/5416\n+            if (e.message!!.contains(\"It's not allowed to delete the file\")) {\n+                // retry after 1 second\n+                SystemClock.sleep(1000)\n+                assertTrue(Realm.deleteRealm(config))\n+            }\n+        }\n+\n+        // FIXME Is this sufficient to test \"loginLogoutResumeSynching\"-case\n+        user = app.login(Credentials.emailPassword(user.email, SECRET_PASSWORD))\n+        val config2: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        Realm.getInstance(config2).use { realm ->\n+            realm.syncSession.downloadAllServerChanges()\n+            realm.refresh()\n+            assertEquals(1, realm.where(SyncStringOnly::class.java).count())\n+        }\n+        looperThread.testComplete()\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun waitForInitialRemoteData_mainThreadThrows() {\n+        val user: User = SyncTestUtils.createTestUser(app)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        assertFailsWith<java.lang.IllegalStateException> {\n+            Realm.getInstance(config).close()\n+        }\n+    }\n+\n+    @Test\n+    fun waitForInitialRemoteData() {\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+        }\n+        user.logOut()\n+\n+        // 2. Local state should now be completely reset. Open the same sync Realm but different local name again with\n+        // a new configuration which should download the uploaded changes (pray it managed to do so within the time frame).\n+        // Use different user to trigger different path\n+        val user2 = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user2, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .waitForInitialRemoteData()\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo 1$i\"\n+                }\n+            }\n+            assertEquals(20, realm.where(SyncStringOnly::class.java).count())\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    @Ignore(\"Sync somehow keeps a Realm alive, causing the Realm.deleteRealm to throw \" +\n+            \" https://github.com/realm/realm-java/issues/5416\")\n+    fun waitForInitialData_resilientInCaseOfRetries() {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        for (i in 0..9) {\n+            val t = Thread(Runnable {\n+                var realm: Realm? = null\n+                assertFailsWith<DownloadingRealmInterruptedException> {\n+                    Thread.currentThread().interrupt()\n+                    Realm.getInstance(config).close()\n+                }\n+                // FIXME Seems like the file is actually created before interrupted. Is this check\n+                //  correct?\n+                 assertFalse(File(config.getPath()).exists())\n+                // FIXME This can throw IllegalStateException as the realm is maybe not closed\n+                //  properly due to https://github.com/realm/realm-java/issues/5416\n+                Realm.deleteRealm(config)\n+            })\n+            t.start()\n+            t.join()\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    // FIXME This does not throw anymore as described in issue. But do the test still make sense", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "originalPosition": 207}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NzgxOTQw", "url": "https://github.com/realm/realm-java/pull/6939#pullrequestreview-476781940", "createdAt": "2020-08-27T14:32:42Z", "commit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDozMjo0MlrOHITMrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDozMjo0MlrOHITMrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2NTE5OA==", "bodyText": "We cannot test this in dev mode, since the server will just create the schema.\nMaybe if we have a model class with a specific property that has a different type on the the client than on the server.\nWe can add this class as part of the server setup?", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r478465198", "createdAt": "2020-08-27T14:32:42Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import android.util.Log\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.SyncDog\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.log.RealmLogger\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.assertFailsWithErrorCode\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been\n+            //  closed for now https://github.com/realm/realm-java/issues/5416\n+            if (e.message!!.contains(\"It's not allowed to delete the file\")) {\n+                // retry after 1 second\n+                SystemClock.sleep(1000)\n+                assertTrue(Realm.deleteRealm(config))\n+            }\n+        }\n+\n+        // FIXME Is this sufficient to test \"loginLogoutResumeSynching\"-case\n+        user = app.login(Credentials.emailPassword(user.email, SECRET_PASSWORD))\n+        val config2: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        Realm.getInstance(config2).use { realm ->\n+            realm.syncSession.downloadAllServerChanges()\n+            realm.refresh()\n+            assertEquals(1, realm.where(SyncStringOnly::class.java).count())\n+        }\n+        looperThread.testComplete()\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun waitForInitialRemoteData_mainThreadThrows() {\n+        val user: User = SyncTestUtils.createTestUser(app)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        assertFailsWith<java.lang.IllegalStateException> {\n+            Realm.getInstance(config).close()\n+        }\n+    }\n+\n+    @Test\n+    fun waitForInitialRemoteData() {\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+        }\n+        user.logOut()\n+\n+        // 2. Local state should now be completely reset. Open the same sync Realm but different local name again with\n+        // a new configuration which should download the uploaded changes (pray it managed to do so within the time frame).\n+        // Use different user to trigger different path\n+        val user2 = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user2, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .waitForInitialRemoteData()\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo 1$i\"\n+                }\n+            }\n+            assertEquals(20, realm.where(SyncStringOnly::class.java).count())\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    @Ignore(\"Sync somehow keeps a Realm alive, causing the Realm.deleteRealm to throw \" +\n+            \" https://github.com/realm/realm-java/issues/5416\")\n+    fun waitForInitialData_resilientInCaseOfRetries() {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        for (i in 0..9) {\n+            val t = Thread(Runnable {\n+                var realm: Realm? = null\n+                assertFailsWith<DownloadingRealmInterruptedException> {\n+                    Thread.currentThread().interrupt()\n+                    Realm.getInstance(config).close()\n+                }\n+                // FIXME Seems like the file is actually created before interrupted. Is this check\n+                //  correct?\n+                 assertFalse(File(config.getPath()).exists())\n+                // FIXME This can throw IllegalStateException as the realm is maybe not closed\n+                //  properly due to https://github.com/realm/realm-java/issues/5416\n+                Realm.deleteRealm(config)\n+            })\n+            t.start()\n+            t.join()\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    // FIXME This does not throw anymore as described in issue. But do the test still make sense\n+    //  with new sync?\n+    //@Ignore(\"See https://github.com/realm/realm-java/issues/5373\")\n+    fun waitForInitialData_resilientInCaseOfRetriesAsync() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .waitForInitialRemoteData()\n+                .build()\n+        val randomizer = Random()\n+        for (i in 0..9) {\n+            val task = Realm.getInstanceAsync(config, object : Realm.Callback() {\n+                override fun onSuccess(realm: Realm) { fail() }\n+                override fun onError(exception: Throwable) { fail(exception.toString()) }\n+            })\n+            SystemClock.sleep(randomizer.nextInt(5).toLong())\n+            task.cancel()\n+        }\n+        // Leave some time for the async callbacks to actually get through\n+        looperThread.postRunnableDelayed(\n+                Runnable { looperThread.testComplete() },\n+                1000\n+        )\n+    }\n+\n+    @Test\n+    fun waitForInitialRemoteData_readOnlyTrue() {\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+        }\n+        user.logOut()\n+\n+        // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should\n+        // download the uploaded changes (pray it managed to do so within the time frame).\n+        // Use different user to trigger different path\n+        val user2 = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        val configNew: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user2, user.id)\n+                .waitForInitialRemoteData()\n+                .readOnly()\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        assertFalse(configNew.testRealmExists())\n+        Realm.getInstance(configNew).use { realm ->\n+            assertEquals(10, realm.where(SyncStringOnly::class.java).count())\n+        }\n+        user.logOut()\n+    }\n+\n+    @Test\n+    // FIXME\n+    @Ignore(\"Not really sure how to do this test with new sync\")\n+    fun waitForInitialRemoteData_readOnlyTrue_throwsIfWrongServerSchema() {\n+        val configNew: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .readOnly()\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        assertFalse(configNew.testRealmExists())\n+        assertFailsWith<RealmMigrationNeededException> {\n+            // This will fail, because the server Realm is completely empty and the Client is not allowed to write the\n+            // schema.\n+            // FIXME Does not throw. How to test schema migration with new sync when server is in dev mode", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf"}, "originalPosition": 276}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be2056b5810d52d16ddeca1d50e46c3ba07b493b", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/be2056b5810d52d16ddeca1d50e46c3ba07b493b", "committedDate": "2020-08-31T09:01:01Z", "message": "Merge branch 'v10' into cr/sync-integration-test-realm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88c0427df19e0686901a2f996530afc2f6ea820a", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/88c0427df19e0686901a2f996530afc2f6ea820a", "committedDate": "2020-08-31T14:08:21Z", "message": "Add missing imports after merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a33af43300576882ed2345227b9eafa31eb665db", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/a33af43300576882ed2345227b9eafa31eb665db", "committedDate": "2020-08-31T14:13:06Z", "message": "Fix ignored SyncedRealmIntegrationTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "807b8fe084ae2715c471c20e27151a76285b5e53", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/807b8fe084ae2715c471c20e27151a76285b5e53", "committedDate": "2020-08-31T21:40:35Z", "message": "Fix ignored SyncSessionTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68c99ba1e44b67136a2e0ddf80409054c79d2a34", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/68c99ba1e44b67136a2e0ddf80409054c79d2a34", "committedDate": "2020-08-31T22:16:39Z", "message": "Expose OS sync session's shutdown_and_wait for test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6a05d4557fd3ff71fea08e6acca384fbf9382e8", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/d6a05d4557fd3ff71fea08e6acca384fbf9382e8", "committedDate": "2020-09-01T06:55:55Z", "message": "Ignored flaky waitForInitialData_resilientInCaseOfRetries test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNzYyNTgx", "url": "https://github.com/realm/realm-java/pull/6939#pullrequestreview-481762581", "createdAt": "2020-09-03T11:53:54Z", "commit": {"oid": "d6a05d4557fd3ff71fea08e6acca384fbf9382e8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNzQ1OTg1", "url": "https://github.com/realm/realm-java/pull/6939#pullrequestreview-481745985", "createdAt": "2020-09-03T11:28:51Z", "commit": {"oid": "d6a05d4557fd3ff71fea08e6acca384fbf9382e8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMToyODo1MVrOHMiSdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMTo1MTo0N1rOHMjBdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkwNjc0Mg==", "bodyText": "Shouldn't we wait for the transaction to complete to call this?", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r482906742", "createdAt": "2020-09-03T11:28:51Z", "author": {"login": "clementetb"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/ProgressListenerTests.kt", "diffHunk": "@@ -290,6 +300,83 @@ class ProgressListenerTests {\n         }\n     }\n \n+    @Test\n+    @Ignore(\"FIXME: Flacky: Tracked by https://github.com/realm/realm-java/issues/6976\")\n+    fun progressListenersWorkWhenUsingWaitForInitialRemoteData() = looperThread.runBlocking {\n+        val username = UUID.randomUUID().toString()\n+        val password = \"password\"\n+        var user: User = app.registerUserAndLogin(username, password)\n+\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6a05d4557fd3ff71fea08e6acca384fbf9382e8"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkxODc3Mw==", "bodyText": "Exceptions and assertions on a custom thread will crash the test app. It will stop the test process and will not yield any results.\nCheck using BlockingLooperThread.runDetached", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r482918773", "createdAt": "2020-09-03T11:51:47Z", "author": {"login": "clementetb"}, "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,331 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.StringOnly\n+import io.realm.entities.SyncSchemeMigration\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.objectserver.utils.Constants\n+import io.realm.rule.BlockingLooperThread\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Assert.*\n+import org.junit.Before\n+import org.junit.Ignore\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // TODO: We don't have a way to ensure that the Realm instance on client thread has been\n+            //  closed for now https://github.com/realm/realm-java/issues/5416\n+            if (e.message!!.contains(\"It's not allowed to delete the file\")) {\n+                // retry after 1 second\n+                SystemClock.sleep(1000)\n+                assertTrue(Realm.deleteRealm(config))\n+            }\n+        }\n+\n+        user = app.login(Credentials.emailPassword(user.email, SECRET_PASSWORD))\n+        val config2: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        Realm.getInstance(config2).use { realm ->\n+            realm.syncSession.downloadAllServerChanges()\n+            realm.refresh()\n+            assertEquals(1, realm.where(SyncStringOnly::class.java).count())\n+        }\n+        looperThread.testComplete()\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun waitForInitialRemoteData_mainThreadThrows() {\n+        val user: User = SyncTestUtils.createTestUser(app)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        assertFailsWith<java.lang.IllegalStateException> {\n+            Realm.getInstance(config).close()\n+        }\n+    }\n+\n+    @Test\n+    fun waitForInitialRemoteData() {\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+        }\n+        user.logOut()\n+\n+        // 2. Local state should now be completely reset. Open the same sync Realm but different local name again with\n+        // a new configuration which should download the uploaded changes (pray it managed to do so within the time frame).\n+        // Use different user to trigger different path\n+        val user2 = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user2, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .waitForInitialRemoteData()\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo 1$i\"\n+                }\n+            }\n+            assertEquals(20, realm.where(SyncStringOnly::class.java).count())\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    @Ignore(\"Sync somehow keeps a Realm alive, causing the Realm.deleteRealm to throw \" +\n+            \" https://github.com/realm/realm-java/issues/5416\")\n+    fun waitForInitialData_resilientInCaseOfRetries() {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        for (i in 0..9) {\n+            val t = Thread(Runnable {\n+                var realm: Realm? = null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6a05d4557fd3ff71fea08e6acca384fbf9382e8"}, "originalPosition": 184}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b677dccd86503c682f938f93178bbfc04526b033", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/b677dccd86503c682f938f93178bbfc04526b033", "committedDate": "2020-09-08T06:50:08Z", "message": "Avoid native threads in SyncedRealmIntegrationTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "697482ad5ad7aaad6fbb0cf45a359fde05b8df41", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/697482ad5ad7aaad6fbb0cf45a359fde05b8df41", "committedDate": "2020-09-08T06:53:28Z", "message": "Include previously ignored test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "898168f8bfcc8713cf1eb7d687b023ddebae110c", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/898168f8bfcc8713cf1eb7d687b023ddebae110c", "committedDate": "2020-09-08T06:57:53Z", "message": "Remove irrelevant FIXME"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ea96d961fcc0a60b8a2290cce52d8cee20bd941", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/2ea96d961fcc0a60b8a2290cce52d8cee20bd941", "committedDate": "2020-09-08T08:26:55Z", "message": "Reignoring flaky SyncedRealmIntegrationTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NTkyMDgy", "url": "https://github.com/realm/realm-java/pull/6939#pullrequestreview-487592082", "createdAt": "2020-09-14T09:48:44Z", "commit": {"oid": "2ea96d961fcc0a60b8a2290cce52d8cee20bd941"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4NDMxMzYw", "url": "https://github.com/realm/realm-java/pull/6939#pullrequestreview-488431360", "createdAt": "2020-09-15T08:09:57Z", "commit": {"oid": "2ea96d961fcc0a60b8a2290cce52d8cee20bd941"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bebf5221a05051304d45e1b2a67e76decf23153", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/9bebf5221a05051304d45e1b2a67e76decf23153", "committedDate": "2020-09-15T08:18:28Z", "message": "Merge branch 'v10' into cr/sync-integration-test-realm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc0e72032739020a2adc6f1c1f21b4c9af2685a1", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/dc0e72032739020a2adc6f1c1f21b4c9af2685a1", "committedDate": "2020-09-15T10:33:42Z", "message": "Fix after merge"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2599, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}