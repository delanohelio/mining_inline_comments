{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4Njg0NDY1", "number": 6861, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzoxMzo1NVrOD9REYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzoxOTowMlrOD9RJ8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTY5Mzc3OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzoxMzo1NVrOGWqJow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowNDozMlrOGXSicQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxMjQ1MQ==", "bodyText": "I think this Rule can largely be replaced with assertFailsWith ?", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r426412451", "createdAt": "2020-05-18T07:13:55Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.IndexedFields\n+import io.realm.entities.PrimaryKeyAsString\n+import io.realm.entities.StringOnly\n+import io.realm.internal.OsObjectSchemaInfo\n+import io.realm.internal.OsRealmConfig\n+import io.realm.internal.OsSchemaInfo\n+import io.realm.internal.OsSharedRealm\n+import org.hamcrest.CoreMatchers\n+import org.junit.*\n+import org.junit.rules.ExpectedException\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Testing methods around migrations for Realms using a [SyncConfiguration].\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmMigrationTests {\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val thrown = ExpectedException.none()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec59608977043ec9a0fb92532f5426edfcc65ab7"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUzMDc1OQ==", "bodyText": "Yes, I have it stashed somewhere as my unit tests of the implementation failed as it was not possible to assertFailsWith on an AssertError. I will give it another try if you also see the potential.", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r426530759", "createdAt": "2020-05-18T10:36:50Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.IndexedFields\n+import io.realm.entities.PrimaryKeyAsString\n+import io.realm.entities.StringOnly\n+import io.realm.internal.OsObjectSchemaInfo\n+import io.realm.internal.OsRealmConfig\n+import io.realm.internal.OsSchemaInfo\n+import io.realm.internal.OsSharedRealm\n+import org.hamcrest.CoreMatchers\n+import org.junit.*\n+import org.junit.rules.ExpectedException\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Testing methods around migrations for Realms using a [SyncConfiguration].\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmMigrationTests {\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val thrown = ExpectedException.none()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxMjQ1MQ=="}, "originalCommit": {"oid": "ec59608977043ec9a0fb92532f5426edfcc65ab7"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3NDE2MQ==", "bodyText": "Added a assertFailsWithMessage<T>(Matcher<in String?>, () -> Unit) in KotlinTestUtils", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r427074161", "createdAt": "2020-05-19T07:04:32Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.IndexedFields\n+import io.realm.entities.PrimaryKeyAsString\n+import io.realm.entities.StringOnly\n+import io.realm.internal.OsObjectSchemaInfo\n+import io.realm.internal.OsRealmConfig\n+import io.realm.internal.OsSchemaInfo\n+import io.realm.internal.OsSharedRealm\n+import org.hamcrest.CoreMatchers\n+import org.junit.*\n+import org.junit.rules.ExpectedException\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Testing methods around migrations for Realms using a [SyncConfiguration].\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmMigrationTests {\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val thrown = ExpectedException.none()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxMjQ1MQ=="}, "originalCommit": {"oid": "ec59608977043ec9a0fb92532f5426edfcc65ab7"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTcwMjY5OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzoxNzowNFrOGWqPJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowNDo0OFrOGXSi6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxMzg2MQ==", "bodyText": "Does this needs to be a MutableList? Any reason not to just use val list = listOf(expectedObjectSchema) ?", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r426413861", "createdAt": "2020-05-18T07:17:04Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.IndexedFields\n+import io.realm.entities.PrimaryKeyAsString\n+import io.realm.entities.StringOnly\n+import io.realm.internal.OsObjectSchemaInfo\n+import io.realm.internal.OsRealmConfig\n+import io.realm.internal.OsSchemaInfo\n+import io.realm.internal.OsSharedRealm\n+import org.hamcrest.CoreMatchers\n+import org.junit.*\n+import org.junit.rules.ExpectedException\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Testing methods around migrations for Realms using a [SyncConfiguration].\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmMigrationTests {\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val thrown = ExpectedException.none()\n+\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun migrateRealm_syncConfigurationThrows() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app)).build()\n+        assertFailsWith<IllegalArgumentException> {\n+            Realm.migrateRealm(config)\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema are missing fields. These will be added\n+    // automatically.\n+    @Test\n+    fun addField_worksWithMigrationError() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with missing fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className) // Create empty class\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            assertTrue(realm.schema[className]!!.hasField(StringOnly.FIELD_CHARS)) // Field has been added\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema has more fields than in the model class.\n+    // The underlying field should not be deleted, just hidden.\n+    @Test\n+    fun missingFields_hiddenSilently() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with too many fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className)\n+                        .addField(StringOnly.FIELD_CHARS, String::class.java)\n+                        .addField(\"newField\", String::class.java)\n+                // A schema version has to be set otherwise Object Store will try to initialize the schema again and reach an\n+                // error branch. That is not a real case.\n+                dynamicRealm.version = 0\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            val stringOnlySchema = realm.schema[className]!!\n+            assertTrue(stringOnlySchema.hasField(StringOnly.FIELD_CHARS))\n+            assertTrue(stringOnlySchema.hasField(\"newField\"))\n+            assertEquals(2, stringOnlySchema.fieldNames.size.toLong())\n+        }\n+    }\n+\n+    // Check that a Realm cannot be opened if it contain breaking schema changes, like changing a primary key\n+    @Test\n+    fun breakingSchemaChange_throws() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(PrimaryKeyAsString::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with a different primary key)\n+        val expectedObjectSchema = OsObjectSchemaInfo.Builder(PrimaryKeyAsString.CLASS_NAME, 2, 0)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_PRIMARY_KEY, RealmFieldType.STRING, false, true, false)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_ID, RealmFieldType.INTEGER, true, true, true)\n+                .build()\n+        val list: MutableList<OsObjectSchemaInfo> = ArrayList()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec59608977043ec9a0fb92532f5426edfcc65ab7"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3NDI4Mw==", "bodyText": "No. Updated", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r427074283", "createdAt": "2020-05-19T07:04:48Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.IndexedFields\n+import io.realm.entities.PrimaryKeyAsString\n+import io.realm.entities.StringOnly\n+import io.realm.internal.OsObjectSchemaInfo\n+import io.realm.internal.OsRealmConfig\n+import io.realm.internal.OsSchemaInfo\n+import io.realm.internal.OsSharedRealm\n+import org.hamcrest.CoreMatchers\n+import org.junit.*\n+import org.junit.rules.ExpectedException\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Testing methods around migrations for Realms using a [SyncConfiguration].\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmMigrationTests {\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val thrown = ExpectedException.none()\n+\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun migrateRealm_syncConfigurationThrows() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app)).build()\n+        assertFailsWith<IllegalArgumentException> {\n+            Realm.migrateRealm(config)\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema are missing fields. These will be added\n+    // automatically.\n+    @Test\n+    fun addField_worksWithMigrationError() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with missing fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className) // Create empty class\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            assertTrue(realm.schema[className]!!.hasField(StringOnly.FIELD_CHARS)) // Field has been added\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema has more fields than in the model class.\n+    // The underlying field should not be deleted, just hidden.\n+    @Test\n+    fun missingFields_hiddenSilently() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with too many fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className)\n+                        .addField(StringOnly.FIELD_CHARS, String::class.java)\n+                        .addField(\"newField\", String::class.java)\n+                // A schema version has to be set otherwise Object Store will try to initialize the schema again and reach an\n+                // error branch. That is not a real case.\n+                dynamicRealm.version = 0\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            val stringOnlySchema = realm.schema[className]!!\n+            assertTrue(stringOnlySchema.hasField(StringOnly.FIELD_CHARS))\n+            assertTrue(stringOnlySchema.hasField(\"newField\"))\n+            assertEquals(2, stringOnlySchema.fieldNames.size.toLong())\n+        }\n+    }\n+\n+    // Check that a Realm cannot be opened if it contain breaking schema changes, like changing a primary key\n+    @Test\n+    fun breakingSchemaChange_throws() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(PrimaryKeyAsString::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with a different primary key)\n+        val expectedObjectSchema = OsObjectSchemaInfo.Builder(PrimaryKeyAsString.CLASS_NAME, 2, 0)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_PRIMARY_KEY, RealmFieldType.STRING, false, true, false)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_ID, RealmFieldType.INTEGER, true, true, true)\n+                .build()\n+        val list: MutableList<OsObjectSchemaInfo> = ArrayList()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxMzg2MQ=="}, "originalCommit": {"oid": "ec59608977043ec9a0fb92532f5426edfcc65ab7"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTcwODAyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzoxOTowMlrOGWqSfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowNTo1NVrOGXSlJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxNDcxOA==", "bodyText": "Instead of the ExpectedException rule, perhaps we should create our own variant of assetFailsWith that takes the expected error string, so you can do something like\nassertFailsWith<IllegalStateException)(\"The following changes cannot be made in additive-only schema mode:\") {\n  Realm.getInstance(config)\n}", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r426414718", "createdAt": "2020-05-18T07:19:02Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.IndexedFields\n+import io.realm.entities.PrimaryKeyAsString\n+import io.realm.entities.StringOnly\n+import io.realm.internal.OsObjectSchemaInfo\n+import io.realm.internal.OsRealmConfig\n+import io.realm.internal.OsSchemaInfo\n+import io.realm.internal.OsSharedRealm\n+import org.hamcrest.CoreMatchers\n+import org.junit.*\n+import org.junit.rules.ExpectedException\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Testing methods around migrations for Realms using a [SyncConfiguration].\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmMigrationTests {\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val thrown = ExpectedException.none()\n+\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun migrateRealm_syncConfigurationThrows() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app)).build()\n+        assertFailsWith<IllegalArgumentException> {\n+            Realm.migrateRealm(config)\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema are missing fields. These will be added\n+    // automatically.\n+    @Test\n+    fun addField_worksWithMigrationError() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with missing fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className) // Create empty class\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            assertTrue(realm.schema[className]!!.hasField(StringOnly.FIELD_CHARS)) // Field has been added\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema has more fields than in the model class.\n+    // The underlying field should not be deleted, just hidden.\n+    @Test\n+    fun missingFields_hiddenSilently() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with too many fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className)\n+                        .addField(StringOnly.FIELD_CHARS, String::class.java)\n+                        .addField(\"newField\", String::class.java)\n+                // A schema version has to be set otherwise Object Store will try to initialize the schema again and reach an\n+                // error branch. That is not a real case.\n+                dynamicRealm.version = 0\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            val stringOnlySchema = realm.schema[className]!!\n+            assertTrue(stringOnlySchema.hasField(StringOnly.FIELD_CHARS))\n+            assertTrue(stringOnlySchema.hasField(\"newField\"))\n+            assertEquals(2, stringOnlySchema.fieldNames.size.toLong())\n+        }\n+    }\n+\n+    // Check that a Realm cannot be opened if it contain breaking schema changes, like changing a primary key\n+    @Test\n+    fun breakingSchemaChange_throws() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(PrimaryKeyAsString::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with a different primary key)\n+        val expectedObjectSchema = OsObjectSchemaInfo.Builder(PrimaryKeyAsString.CLASS_NAME, 2, 0)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_PRIMARY_KEY, RealmFieldType.STRING, false, true, false)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_ID, RealmFieldType.INTEGER, true, true, true)\n+                .build()\n+        val list: MutableList<OsObjectSchemaInfo> = ArrayList()\n+        list.add(expectedObjectSchema)\n+        val schemaInfo = OsSchemaInfo(list)\n+        val configBuilder = OsRealmConfig.Builder(config).schemaInfo(schemaInfo)\n+        OsSharedRealm.getInstance(configBuilder, OsSharedRealm.VersionID.LIVE).close()\n+        thrown.expectMessage(\n+                CoreMatchers.containsString(\"The following changes cannot be made in additive-only schema mode:\"))\n+        thrown.expect(IllegalStateException::class.java)\n+        Realm.getInstance(config)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec59608977043ec9a0fb92532f5426edfcc65ab7"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUzMTIwNg==", "bodyText": "Yep, see details on ealier comment.", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r426531206", "createdAt": "2020-05-18T10:37:42Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.IndexedFields\n+import io.realm.entities.PrimaryKeyAsString\n+import io.realm.entities.StringOnly\n+import io.realm.internal.OsObjectSchemaInfo\n+import io.realm.internal.OsRealmConfig\n+import io.realm.internal.OsSchemaInfo\n+import io.realm.internal.OsSharedRealm\n+import org.hamcrest.CoreMatchers\n+import org.junit.*\n+import org.junit.rules.ExpectedException\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Testing methods around migrations for Realms using a [SyncConfiguration].\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmMigrationTests {\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val thrown = ExpectedException.none()\n+\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun migrateRealm_syncConfigurationThrows() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app)).build()\n+        assertFailsWith<IllegalArgumentException> {\n+            Realm.migrateRealm(config)\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema are missing fields. These will be added\n+    // automatically.\n+    @Test\n+    fun addField_worksWithMigrationError() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with missing fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className) // Create empty class\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            assertTrue(realm.schema[className]!!.hasField(StringOnly.FIELD_CHARS)) // Field has been added\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema has more fields than in the model class.\n+    // The underlying field should not be deleted, just hidden.\n+    @Test\n+    fun missingFields_hiddenSilently() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with too many fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className)\n+                        .addField(StringOnly.FIELD_CHARS, String::class.java)\n+                        .addField(\"newField\", String::class.java)\n+                // A schema version has to be set otherwise Object Store will try to initialize the schema again and reach an\n+                // error branch. That is not a real case.\n+                dynamicRealm.version = 0\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            val stringOnlySchema = realm.schema[className]!!\n+            assertTrue(stringOnlySchema.hasField(StringOnly.FIELD_CHARS))\n+            assertTrue(stringOnlySchema.hasField(\"newField\"))\n+            assertEquals(2, stringOnlySchema.fieldNames.size.toLong())\n+        }\n+    }\n+\n+    // Check that a Realm cannot be opened if it contain breaking schema changes, like changing a primary key\n+    @Test\n+    fun breakingSchemaChange_throws() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(PrimaryKeyAsString::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with a different primary key)\n+        val expectedObjectSchema = OsObjectSchemaInfo.Builder(PrimaryKeyAsString.CLASS_NAME, 2, 0)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_PRIMARY_KEY, RealmFieldType.STRING, false, true, false)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_ID, RealmFieldType.INTEGER, true, true, true)\n+                .build()\n+        val list: MutableList<OsObjectSchemaInfo> = ArrayList()\n+        list.add(expectedObjectSchema)\n+        val schemaInfo = OsSchemaInfo(list)\n+        val configBuilder = OsRealmConfig.Builder(config).schemaInfo(schemaInfo)\n+        OsSharedRealm.getInstance(configBuilder, OsSharedRealm.VersionID.LIVE).close()\n+        thrown.expectMessage(\n+                CoreMatchers.containsString(\"The following changes cannot be made in additive-only schema mode:\"))\n+        thrown.expect(IllegalStateException::class.java)\n+        Realm.getInstance(config)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxNDcxOA=="}, "originalCommit": {"oid": "ec59608977043ec9a0fb92532f5426edfcc65ab7"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3NDg1Mg==", "bodyText": "Using the previously mentioned assertFailsWithMessage: https://github.com/realm/realm-java/pull/6861/files#diff-c94fbae13da3fa85fe77b8c175bbe010R134", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r427074852", "createdAt": "2020-05-19T07:05:55Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.IndexedFields\n+import io.realm.entities.PrimaryKeyAsString\n+import io.realm.entities.StringOnly\n+import io.realm.internal.OsObjectSchemaInfo\n+import io.realm.internal.OsRealmConfig\n+import io.realm.internal.OsSchemaInfo\n+import io.realm.internal.OsSharedRealm\n+import org.hamcrest.CoreMatchers\n+import org.junit.*\n+import org.junit.rules.ExpectedException\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Testing methods around migrations for Realms using a [SyncConfiguration].\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmMigrationTests {\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val thrown = ExpectedException.none()\n+\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun migrateRealm_syncConfigurationThrows() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app)).build()\n+        assertFailsWith<IllegalArgumentException> {\n+            Realm.migrateRealm(config)\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema are missing fields. These will be added\n+    // automatically.\n+    @Test\n+    fun addField_worksWithMigrationError() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with missing fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className) // Create empty class\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            assertTrue(realm.schema[className]!!.hasField(StringOnly.FIELD_CHARS)) // Field has been added\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema has more fields than in the model class.\n+    // The underlying field should not be deleted, just hidden.\n+    @Test\n+    fun missingFields_hiddenSilently() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with too many fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className)\n+                        .addField(StringOnly.FIELD_CHARS, String::class.java)\n+                        .addField(\"newField\", String::class.java)\n+                // A schema version has to be set otherwise Object Store will try to initialize the schema again and reach an\n+                // error branch. That is not a real case.\n+                dynamicRealm.version = 0\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            val stringOnlySchema = realm.schema[className]!!\n+            assertTrue(stringOnlySchema.hasField(StringOnly.FIELD_CHARS))\n+            assertTrue(stringOnlySchema.hasField(\"newField\"))\n+            assertEquals(2, stringOnlySchema.fieldNames.size.toLong())\n+        }\n+    }\n+\n+    // Check that a Realm cannot be opened if it contain breaking schema changes, like changing a primary key\n+    @Test\n+    fun breakingSchemaChange_throws() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(PrimaryKeyAsString::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with a different primary key)\n+        val expectedObjectSchema = OsObjectSchemaInfo.Builder(PrimaryKeyAsString.CLASS_NAME, 2, 0)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_PRIMARY_KEY, RealmFieldType.STRING, false, true, false)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_ID, RealmFieldType.INTEGER, true, true, true)\n+                .build()\n+        val list: MutableList<OsObjectSchemaInfo> = ArrayList()\n+        list.add(expectedObjectSchema)\n+        val schemaInfo = OsSchemaInfo(list)\n+        val configBuilder = OsRealmConfig.Builder(config).schemaInfo(schemaInfo)\n+        OsSharedRealm.getInstance(configBuilder, OsSharedRealm.VersionID.LIVE).close()\n+        thrown.expectMessage(\n+                CoreMatchers.containsString(\"The following changes cannot be made in additive-only schema mode:\"))\n+        thrown.expect(IllegalStateException::class.java)\n+        Realm.getInstance(config)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxNDcxOA=="}, "originalCommit": {"oid": "ec59608977043ec9a0fb92532f5426edfcc65ab7"}, "originalPosition": 143}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 713, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}