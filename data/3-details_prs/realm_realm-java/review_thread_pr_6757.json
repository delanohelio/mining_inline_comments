{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwMzU0MzY3", "number": 6757, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOToxNDo1OVrODoPnbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMjozMzoxOFrODpFyPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNTI1NDg1OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOToxNDo1OVrOF2rLWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOTo0MToxN1rOF2sExA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3NDg0MA==", "bodyText": "Don't you wan't to add FIXME whenever you comment something out to be able to remember where to uncomment again?", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r392874840", "createdAt": "2020-03-16T09:14:59Z", "author": {"login": "bmunkholm"}, "path": "realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java", "diffHunk": "@@ -69,10 +69,10 @@ public void setUp() {\n \n     @After\n     public void tearDown() {\n-        UserStore userStore = SyncManager.getUserStore();\n-        for (SyncUser syncUser : userStore.allUsers()) {\n-            userStore.remove(syncUser.getIdentity(), syncUser.getAuthenticationUrl().toString());\n-        }\n+//        UserStore userStore = SyncManager.getUserStore();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3NTg0MQ==", "bodyText": "Yes, I should probably add FIXME's to all these places", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r392875841", "createdAt": "2020-03-16T09:16:49Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java", "diffHunk": "@@ -69,10 +69,10 @@ public void setUp() {\n \n     @After\n     public void tearDown() {\n-        UserStore userStore = SyncManager.getUserStore();\n-        for (SyncUser syncUser : userStore.allUsers()) {\n-            userStore.remove(syncUser.getIdentity(), syncUser.getAuthenticationUrl().toString());\n-        }\n+//        UserStore userStore = SyncManager.getUserStore();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3NDg0MA=="}, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4OTU0MA==", "bodyText": "I didn't add FIXME comment all those places - but there are quite a few :-)", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r392889540", "createdAt": "2020-03-16T09:41:17Z", "author": {"login": "bmunkholm"}, "path": "realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java", "diffHunk": "@@ -69,10 +69,10 @@ public void setUp() {\n \n     @After\n     public void tearDown() {\n-        UserStore userStore = SyncManager.getUserStore();\n-        for (SyncUser syncUser : userStore.allUsers()) {\n-            userStore.remove(syncUser.getIdentity(), syncUser.getAuthenticationUrl().toString());\n-        }\n+//        UserStore userStore = SyncManager.getUserStore();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3NDg0MA=="}, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNTI1ODAyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOToxNTo1M1rOF2rNPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOToxNTo1M1rOF2rNPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3NTMyNg==", "bodyText": "FIXME?", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r392875326", "createdAt": "2020-03-16T09:15:53Z", "author": {"login": "bmunkholm"}, "path": "realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java", "diffHunk": "@@ -61,9 +61,9 @@ public void tearDown() {\n         if (realm != null && !realm.isClosed()) {\n             realm.close();\n         }\n-        for (SyncUser user : SyncUser.all().values()) {\n-            user.logOut();\n-        }\n+//        for (RealmUser user : RealmApp.allUsers().values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNjU0MzIzOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDo0ODoyM1rOF23w0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDo0ODoyM1rOF23w0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA4MTA0Mw==", "bodyText": "You're already importing rules from androidx", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r393081043", "createdAt": "2020-03-16T14:48:23Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/build.gradle", "diffHunk": "@@ -211,12 +211,14 @@ dependencies {\n     }\n \n     kapt project(':realm-annotations-processor') // See https://github.com/realm/realm-java/issues/5799\n-    objectServerImplementation 'com.squareup.okhttp3:okhttp:3.10.0'\n+    objectServerImplementation 'com.squareup.okhttp3:okhttp:3.12.0' // Going above this requires minSDK 21\n \n     kaptAndroidTest project(':realm-annotations-processor')\n     androidTestImplementation 'io.reactivex.rxjava2:rxjava:2.1.5'\n     androidTestImplementation 'io.reactivex.rxjava2:rxandroid:2.1.1'\n     androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n+    androidTestImplementation 'com.android.support.test:rules:1.0.2'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNjU0NDI4OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDo0ODozOVrOF23xhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDo0ODozOVrOF23xhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA4MTIyMg==", "bodyText": "you're already importing 1.2.0 below", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r393081222", "createdAt": "2020-03-16T14:48:39Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/build.gradle", "diffHunk": "@@ -211,12 +211,14 @@ dependencies {\n     }\n \n     kapt project(':realm-annotations-processor') // See https://github.com/realm/realm-java/issues/5799\n-    objectServerImplementation 'com.squareup.okhttp3:okhttp:3.10.0'\n+    objectServerImplementation 'com.squareup.okhttp3:okhttp:3.12.0' // Going above this requires minSDK 21\n \n     kaptAndroidTest project(':realm-annotations-processor')\n     androidTestImplementation 'io.reactivex.rxjava2:rxjava:2.1.5'\n     androidTestImplementation 'io.reactivex.rxjava2:rxandroid:2.1.1'\n     androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n+    androidTestImplementation 'com.android.support.test:rules:1.0.2'\n+    androidTestImplementation 'androidx.test:rules:1.1.1'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzExNDAwOnYy", "diffSide": "RIGHT", "path": "tools/sync_test_server/setup_mongodb_realm.sh", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNjo1OToyOVrOF29bfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNjo1OToyOVrOF29bfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3Mzg4Nw==", "bodyText": "chmod a+x ./tools/sync_test_server/setup_mongodb_realm.sh\n\nto make it executable", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r393173887", "createdAt": "2020-03-16T16:59:29Z", "author": {"login": "nhachicha"}, "path": "tools/sync_test_server/setup_mongodb_realm.sh", "diffHunk": "@@ -0,0 +1,80 @@\n+#!/bin/sh", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzUyOTA1OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/TestRealmApp.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODo0ODo1N1rOF3Bi8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzoyNjozOFrOF4ip9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI0MTMyOQ==", "bodyText": "why not use an enum? you already have an HTTPMethod enum class\nI guess you're receiving from JNI the Http Method as a string ...", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r393241329", "createdAt": "2020-03-16T18:48:57Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/TestRealmApp.kt", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.internal.network.OkHttpNetworkTransport\n+import io.realm.internal.objectstore.OsJavaNetworkTransport\n+import io.realm.log.LogLevel\n+import java.lang.IllegalStateException\n+\n+/**\n+ * This class wraps various methods making it easier to create an RealmApp that can be used\n+ * for testing.\n+ *\n+ * NOTE: This class must remain in the [io.realm] package in order to work.\n+ */\n+class TestRealmApp private constructor() {\n+    companion object {\n+        private val applicationId = fetchApplicationId()\n+        val config = RealmAppConfiguration.Builder(applicationId)\n+                .logLevel(LogLevel.DEBUG)\n+                .baseUrl(\"http://127.0.0.1:9090\")\n+                .appName(\"MongoDB Realm Integration Tests\")\n+                .appVersion(\"1.0.\")\n+                .build()\n+\n+        private fun init() {\n+            Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        }\n+\n+        private fun fetchApplicationId(): String {\n+            init()\n+            val transport = OkHttpNetworkTransport()\n+            val response = transport.sendRequest(\n+                    \"get\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgzMjM3NA==", "bodyText": "Yes, the JNI interface is a String. I switched this to using the enum which now has the native string configured as part of it.", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394832374", "createdAt": "2020-03-19T07:26:38Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/TestRealmApp.kt", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.internal.network.OkHttpNetworkTransport\n+import io.realm.internal.objectstore.OsJavaNetworkTransport\n+import io.realm.log.LogLevel\n+import java.lang.IllegalStateException\n+\n+/**\n+ * This class wraps various methods making it easier to create an RealmApp that can be used\n+ * for testing.\n+ *\n+ * NOTE: This class must remain in the [io.realm] package in order to work.\n+ */\n+class TestRealmApp private constructor() {\n+    companion object {\n+        private val applicationId = fetchApplicationId()\n+        val config = RealmAppConfiguration.Builder(applicationId)\n+                .logLevel(LogLevel.DEBUG)\n+                .baseUrl(\"http://127.0.0.1:9090\")\n+                .appName(\"MongoDB Realm Integration Tests\")\n+                .appVersion(\"1.0.\")\n+                .build()\n+\n+        private fun init() {\n+            Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        }\n+\n+        private fun fetchApplicationId(): String {\n+            init()\n+            val transport = OkHttpNetworkTransport()\n+            val response = transport.sendRequest(\n+                    \"get\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI0MTMyOQ=="}, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzU0NDM5OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/transport/OkHttpNetworkTransportTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODo1MzoxMFrOF3BsUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODo1MzoxMFrOF3BsUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI0MzczMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * This class uses a a simple custom webserver written in Node that must be running when\n          \n          \n            \n             * This class uses a simple custom webserver written in Node that must be running when", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r393243730", "createdAt": "2020-03-16T18:53:10Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/transport/OkHttpNetworkTransportTests.kt", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.transport\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.Realm\n+import io.realm.internal.network.OkHttpNetworkTransport\n+import io.realm.internal.objectstore.OsJavaNetworkTransport\n+import junit.framework.Assert.assertEquals\n+import org.junit.Assert.assertTrue\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+\n+/**\n+ * This class is responsible for testing the OkHttp implementation of the network layer.\n+ * Any behavior happening after the network request has executed are not covered by this class,\n+ * but instead in [OsJavaNetworkTransportTests].\n+ *\n+ * This class uses a a simple custom webserver written in Node that must be running when", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzg2OTczOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/transport/OsJavaNetworkTransportTests.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMDo0MDoxM1rOF3E77Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzo0OTowNFrOF4jMig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5Njg3Nw==", "bodyText": "Why defining this endpoints, this test is only using the OsJavaNetworkTransport for login?", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r393296877", "createdAt": "2020-03-16T20:40:13Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/transport/OsJavaNetworkTransportTests.kt", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.transport\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.*\n+import io.realm.internal.objectstore.OsJavaNetworkTransport\n+import org.junit.Assert.*\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+\n+/**\n+ * This class is responsible for testing the general network transport layer, i.e. that\n+ * requests can round trip correctly through all layers and that exceptions/errors are reported\n+ * correctly.\n+ *\n+ * This class should _NOT_ test any real network logic. See [OkHttpNetworkTransportTests] for\n+ * tests using the actual network implementation.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class OsJavaNetworkTransportTests {\n+\n+    private lateinit var app: RealmApp\n+    private val successHeaders: Map<String, String> = mapOf(Pair(\"Content-Type\", \"application/json\"))\n+\n+    // Test that the round trip works in case of a successful HTTP request.\n+    @Test\n+    fun requestSuccess() {\n+        app = TestRealmApp.getInstance(object: OsJavaNetworkTransport() {\n+            override fun sendRequest(method: String, url: String, timeoutMs: Long, headers: MutableMap<String, String>, body: String): Response {\n+                var result = \"\"\n+                if (url.endsWith(\"/providers/${RealmCredentials.IdentityProvider.ANONYMOUS.id}/login\")) {\n+                    result = \"\"\"\n+                        {\n+                            \"access_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjVlNjk2M2RmYWZlYTYzMjU0NTgxYzAyNiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1ODM5NjcyMDgsImlhdCI6MTU4Mzk2NTQwOCwiaXNzIjoiNWU2OTY0ZTBhZmVhNjMyNTQ1ODFjMWEzIiwic3RpdGNoX2RldklkIjoiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIiwic3RpdGNoX2RvbWFpbklkIjoiNWU2OTYzZGVhZmVhNjMyNTQ1ODFjMDI1Iiwic3ViIjoiNWU2OTY0ZTBhZmVhNjMyNTQ1ODFjMWExIiwidHlwIjoiYWNjZXNzIn0.J4mp8LnlsxTQRV_7W2Er4qY0tptR76PJGG1k6HSMmUYqgfpJC2Fnbcf1VCoebzoNolH2-sr8AHDVBBCyjxRjqoY9OudFHmWZKmhDV1ysxPP4XmID0nUuN45qJSO8QEAqoOmP1crXjrUZWedFw8aaCZE-bxYfvcDHyjBcbNKZqzawwUw2PyTOlrNjgs01k2J4o5a5XzYkEsJuzr4_8UqKW6zXvYj24UtqnqoYatW5EzpX63m2qig8AcBwPK4ZHb5wEEUdf4QZxkRY5QmTgRHP8SSqVUB_mkHgKaizC_tSB3E0BekaDfLyWVC1taAstXJNfzgFtLI86AzuXS2dCiCfqQ\",\n+                            \"refresh_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjVlNjk2M2RmYWZlYTYzMjU0NTgxYzAyNiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1ODkxNDk0MDgsImlhdCI6MTU4Mzk2NTQwOCwic3RpdGNoX2RhdGEiOm51bGwsInN0aXRjaF9kZXZJZCI6IjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIsInN0aXRjaF9kb21haW5JZCI6IjVlNjk2M2RlYWZlYTYzMjU0NTgxYzAyNSIsInN0aXRjaF9pZCI6IjVlNjk2NGUwYWZlYTYzMjU0NTgxYzFhMyIsInN0aXRjaF9pZGVudCI6eyJpZCI6IjVlNjk2NGUwYWZlYTYzMjU0NTgxYzFhMC1oaWF2b3ZkbmJxbGNsYXBwYnl1cmJpaW8iLCJwcm92aWRlcl90eXBlIjoiYW5vbi11c2VyIiwicHJvdmlkZXJfaWQiOiI1ZTY5NjNlMGFmZWE2MzI1NDU4MWMwNGEifSwic3ViIjoiNWU2OTY0ZTBhZmVhNjMyNTQ1ODFjMWExIiwidHlwIjoicmVmcmVzaCJ9.FhLdpmL48Mw0SyUKWuaplz3wfeS8TCO8S7I9pIJenQww9nPqQ7lIvykQxjCCtinGvsZIJKt_7R31xYCq4Jp53Nw81By79IwkXtO7VXHPsXXZG5_2xV-s0u44e85sYD5su_H-xnx03sU2piJbWJLSB8dKu3rMD4mO-S0HNXCCAty-JkYKSaM2-d_nS8MNb6k7Vfm7y69iz_uwHc-bb_1rPg7r827K6DEeEMF41Hy3Nx1kCdAUOM9-6nYv3pZSU1PFrGYi2uyTXPJ7R7HigY5IGHWd0hwONb_NUr4An2omqfvlkLEd77ut4V9m6mExFkoKzRz7shzn-IGkh3e4h7ECGA\",\n+                            \"user_id\": \"5e6964e0afea63254581c1a1\",\n+                            \"device_id\": \"000000000000000000000000\"\n+                        }                    \n+                    \"\"\".trimIndent()\n+                } else if (url.endsWith(\"/auth/profile\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg0MTIyNg==", "bodyText": "This test calls app.login(), which results in a roundtrip through realm::Appin ObjectStore which make callbacks hitting these two endpoints when logging in. It does expose internal implementation details of ObjectStore, but I don't see a way around that if we want to stub the network itself.", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394841226", "createdAt": "2020-03-19T07:49:04Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/transport/OsJavaNetworkTransportTests.kt", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.transport\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.*\n+import io.realm.internal.objectstore.OsJavaNetworkTransport\n+import org.junit.Assert.*\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+\n+/**\n+ * This class is responsible for testing the general network transport layer, i.e. that\n+ * requests can round trip correctly through all layers and that exceptions/errors are reported\n+ * correctly.\n+ *\n+ * This class should _NOT_ test any real network logic. See [OkHttpNetworkTransportTests] for\n+ * tests using the actual network implementation.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class OsJavaNetworkTransportTests {\n+\n+    private lateinit var app: RealmApp\n+    private val successHeaders: Map<String, String> = mapOf(Pair(\"Content-Type\", \"application/json\"))\n+\n+    // Test that the round trip works in case of a successful HTTP request.\n+    @Test\n+    fun requestSuccess() {\n+        app = TestRealmApp.getInstance(object: OsJavaNetworkTransport() {\n+            override fun sendRequest(method: String, url: String, timeoutMs: Long, headers: MutableMap<String, String>, body: String): Response {\n+                var result = \"\"\n+                if (url.endsWith(\"/providers/${RealmCredentials.IdentityProvider.ANONYMOUS.id}/login\")) {\n+                    result = \"\"\"\n+                        {\n+                            \"access_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjVlNjk2M2RmYWZlYTYzMjU0NTgxYzAyNiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1ODM5NjcyMDgsImlhdCI6MTU4Mzk2NTQwOCwiaXNzIjoiNWU2OTY0ZTBhZmVhNjMyNTQ1ODFjMWEzIiwic3RpdGNoX2RldklkIjoiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIiwic3RpdGNoX2RvbWFpbklkIjoiNWU2OTYzZGVhZmVhNjMyNTQ1ODFjMDI1Iiwic3ViIjoiNWU2OTY0ZTBhZmVhNjMyNTQ1ODFjMWExIiwidHlwIjoiYWNjZXNzIn0.J4mp8LnlsxTQRV_7W2Er4qY0tptR76PJGG1k6HSMmUYqgfpJC2Fnbcf1VCoebzoNolH2-sr8AHDVBBCyjxRjqoY9OudFHmWZKmhDV1ysxPP4XmID0nUuN45qJSO8QEAqoOmP1crXjrUZWedFw8aaCZE-bxYfvcDHyjBcbNKZqzawwUw2PyTOlrNjgs01k2J4o5a5XzYkEsJuzr4_8UqKW6zXvYj24UtqnqoYatW5EzpX63m2qig8AcBwPK4ZHb5wEEUdf4QZxkRY5QmTgRHP8SSqVUB_mkHgKaizC_tSB3E0BekaDfLyWVC1taAstXJNfzgFtLI86AzuXS2dCiCfqQ\",\n+                            \"refresh_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjVlNjk2M2RmYWZlYTYzMjU0NTgxYzAyNiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1ODkxNDk0MDgsImlhdCI6MTU4Mzk2NTQwOCwic3RpdGNoX2RhdGEiOm51bGwsInN0aXRjaF9kZXZJZCI6IjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIsInN0aXRjaF9kb21haW5JZCI6IjVlNjk2M2RlYWZlYTYzMjU0NTgxYzAyNSIsInN0aXRjaF9pZCI6IjVlNjk2NGUwYWZlYTYzMjU0NTgxYzFhMyIsInN0aXRjaF9pZGVudCI6eyJpZCI6IjVlNjk2NGUwYWZlYTYzMjU0NTgxYzFhMC1oaWF2b3ZkbmJxbGNsYXBwYnl1cmJpaW8iLCJwcm92aWRlcl90eXBlIjoiYW5vbi11c2VyIiwicHJvdmlkZXJfaWQiOiI1ZTY5NjNlMGFmZWE2MzI1NDU4MWMwNGEifSwic3ViIjoiNWU2OTY0ZTBhZmVhNjMyNTQ1ODFjMWExIiwidHlwIjoicmVmcmVzaCJ9.FhLdpmL48Mw0SyUKWuaplz3wfeS8TCO8S7I9pIJenQww9nPqQ7lIvykQxjCCtinGvsZIJKt_7R31xYCq4Jp53Nw81By79IwkXtO7VXHPsXXZG5_2xV-s0u44e85sYD5su_H-xnx03sU2piJbWJLSB8dKu3rMD4mO-S0HNXCCAty-JkYKSaM2-d_nS8MNb6k7Vfm7y69iz_uwHc-bb_1rPg7r827K6DEeEMF41Hy3Nx1kCdAUOM9-6nYv3pZSU1PFrGYi2uyTXPJ7R7HigY5IGHWd0hwONb_NUr4An2omqfvlkLEd77ut4V9m6mExFkoKzRz7shzn-IGkh3e4h7ECGA\",\n+                            \"user_id\": \"5e6964e0afea63254581c1a1\",\n+                            \"device_id\": \"000000000000000000000000\"\n+                        }                    \n+                    \"\"\".trimIndent()\n+                } else if (url.endsWith(\"/auth/profile\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5Njg3Nw=="}, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzk4MzYwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsSyncUser.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMToxNjoyNFrOF3GDIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMToxNjoyNFrOF3GDIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxNTEwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int j = 0;\n          \n          \n            \n                if (arr == NULL) {\n          \n          \n            \n                        ThrowException(env, OutOfMemory, \"Could not allocate memory to return identites\");\n          \n          \n            \n                        return NULL;\n          \n          \n            \n                    }\n          \n          \n            \n                    int j = 0;", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r393315107", "createdAt": "2020-03-16T21:16:24Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsSyncUser.cpp", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include \"io_realm_internal_objectstore_OsSyncUser.h\"\n+\n+#include \"util.hpp\"\n+#include \"jni_util/java_class.hpp\"\n+\n+#include <sync/sync_user.hpp>\n+\n+using namespace realm;\n+using namespace realm::jni_util;\n+\n+static void finalize_user(jlong ptr)\n+{\n+    delete reinterpret_cast<std::shared_ptr<SyncUser>*>(ptr);\n+}\n+\n+JNIEXPORT jlong JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetFinalizerMethodPtr(JNIEnv*, jclass)\n+{\n+    return reinterpret_cast<jlong>(&finalize_user);\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetName(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().name);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetEmail(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().email);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetPictureUrl(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().picture_url);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetFirstName(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().first_name);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetLastName(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().last_name);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetGender(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().gender);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetBirthDay(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().birthday);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetMinAge(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().min_age);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetMaxAge(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().max_age);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetAccessToken(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        std::string token = user->access_token();\n+        return to_jstring(env, token);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetRefreshToken(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        std::string token = user->refresh_token();\n+        return to_jstring(env, token);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jobjectArray JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetIdentities(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        std::vector<SyncUserIdentity> ids = user->identities();\n+        static JavaClass stringClass(env, \"java/lang/String\");\n+        jobjectArray arr = env->NewObjectArray(ids.size()*2, stringClass, NULL);\n+        int j = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzk5MTUyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsSyncUser.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMToxOTozNFrOF3GIYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMToxOTozNFrOF3GIYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxNjQ0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    jobjectArray arr = env->NewObjectArray(ids.size()*2, stringClass, NULL);\n          \n          \n            \n                    jobjectArray arr = env->NewObjectArray(ids.size()*2, JavaClassGlobalDef::java_lang_string(), 0);", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r393316449", "createdAt": "2020-03-16T21:19:34Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsSyncUser.cpp", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include \"io_realm_internal_objectstore_OsSyncUser.h\"\n+\n+#include \"util.hpp\"\n+#include \"jni_util/java_class.hpp\"\n+\n+#include <sync/sync_user.hpp>\n+\n+using namespace realm;\n+using namespace realm::jni_util;\n+\n+static void finalize_user(jlong ptr)\n+{\n+    delete reinterpret_cast<std::shared_ptr<SyncUser>*>(ptr);\n+}\n+\n+JNIEXPORT jlong JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetFinalizerMethodPtr(JNIEnv*, jclass)\n+{\n+    return reinterpret_cast<jlong>(&finalize_user);\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetName(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().name);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetEmail(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().email);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetPictureUrl(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().picture_url);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetFirstName(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().first_name);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetLastName(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().last_name);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetGender(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().gender);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetBirthDay(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().birthday);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetMinAge(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().min_age);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetMaxAge(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().max_age);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetAccessToken(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        std::string token = user->access_token();\n+        return to_jstring(env, token);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetRefreshToken(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        std::string token = user->refresh_token();\n+        return to_jstring(env, token);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jobjectArray JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetIdentities(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        std::vector<SyncUserIdentity> ids = user->identities();\n+        static JavaClass stringClass(env, \"java/lang/String\");\n+        jobjectArray arr = env->NewObjectArray(ids.size()*2, stringClass, NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzk5MjcyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsSyncUser.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMToyMDowNFrOF3GJMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMToyMDowNFrOF3GJMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxNjY1OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    static JavaClass stringClass(env, \"java/lang/String\");", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r393316659", "createdAt": "2020-03-16T21:20:04Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsSyncUser.cpp", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include \"io_realm_internal_objectstore_OsSyncUser.h\"\n+\n+#include \"util.hpp\"\n+#include \"jni_util/java_class.hpp\"\n+\n+#include <sync/sync_user.hpp>\n+\n+using namespace realm;\n+using namespace realm::jni_util;\n+\n+static void finalize_user(jlong ptr)\n+{\n+    delete reinterpret_cast<std::shared_ptr<SyncUser>*>(ptr);\n+}\n+\n+JNIEXPORT jlong JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetFinalizerMethodPtr(JNIEnv*, jclass)\n+{\n+    return reinterpret_cast<jlong>(&finalize_user);\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetName(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().name);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetEmail(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().email);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetPictureUrl(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().picture_url);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetFirstName(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().first_name);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetLastName(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().last_name);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetGender(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().gender);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetBirthDay(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().birthday);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetMinAge(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().min_age);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetMaxAge(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        return to_jstring(env, user->user_profile().max_age);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetAccessToken(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        std::string token = user->access_token();\n+        return to_jstring(env, token);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetRefreshToken(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        std::string token = user->refresh_token();\n+        return to_jstring(env, token);\n+    }\n+    CATCH_STD();\n+    return nullptr;\n+}\n+\n+JNIEXPORT jobjectArray JNICALL Java_io_realm_internal_objectstore_OsSyncUser_nativeGetIdentities(JNIEnv* env, jclass, jlong j_native_ptr)\n+{\n+    try {\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_native_ptr);\n+        std::vector<SyncUserIdentity> ids = user->identities();\n+        static JavaClass stringClass(env, \"java/lang/String\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0Mzg4MTg3OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMToxNTo1NlrOF4AZ6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMToxNTo1NlrOF4AZ6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI3MTIwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Default session error handler handler that just output errors to LogCat\n          \n          \n            \n                // Default session error handler that just output errors to LogCat", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394271209", "createdAt": "2020-03-18T11:15:56Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.realm.internal.RealmNotifier;\n+import io.realm.internal.android.AndroidCapabilities;\n+import io.realm.internal.android.AndroidRealmNotifier;\n+import io.realm.internal.async.RealmAsyncTaskImpl;\n+import io.realm.internal.network.OkHttpNetworkTransport;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.log.RealmLog;\n+import io.realm.mongodb.RealmMongoDBService;\n+\n+/**\n+ * FIXME\n+ */\n+public class RealmApp {\n+\n+    // Implementation notes:\n+    // The public API's currently only allow for one RealmApp, however this is a restriction\n+    // we might want to lift in the future. So any implementation details so ideally be made\n+    // with that in mind, i.e. keep static state to minimum.\n+\n+    // Default session error handler handler that just output errors to LogCat", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0Mzg4OTMzOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMToxODoxMFrOF4Aefw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzo1MToyN1rOF4jQKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI3MjM4Mw==", "bodyText": "Is the automatic client reset still using this error code?", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394272383", "createdAt": "2020-03-18T11:18:10Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.realm.internal.RealmNotifier;\n+import io.realm.internal.android.AndroidCapabilities;\n+import io.realm.internal.android.AndroidRealmNotifier;\n+import io.realm.internal.async.RealmAsyncTaskImpl;\n+import io.realm.internal.network.OkHttpNetworkTransport;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.log.RealmLog;\n+import io.realm.mongodb.RealmMongoDBService;\n+\n+/**\n+ * FIXME\n+ */\n+public class RealmApp {\n+\n+    // Implementation notes:\n+    // The public API's currently only allow for one RealmApp, however this is a restriction\n+    // we might want to lift in the future. So any implementation details so ideally be made\n+    // with that in mind, i.e. keep static state to minimum.\n+\n+    // Default session error handler handler that just output errors to LogCat\n+    private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {\n+        @Override\n+        public void onError(SyncSession session, ObjectServerError error) {\n+            if (error.getErrorCode() == ErrorCode.CLIENT_RESET) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg0MjE1Mw==", "bodyText": "Client Reset support is still a bit unclear, but if anything has changed I would rather remove/make changes in a single PR since a lot of places are affected. This code was just a copy from SyncManager", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394842153", "createdAt": "2020-03-19T07:51:27Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.realm.internal.RealmNotifier;\n+import io.realm.internal.android.AndroidCapabilities;\n+import io.realm.internal.android.AndroidRealmNotifier;\n+import io.realm.internal.async.RealmAsyncTaskImpl;\n+import io.realm.internal.network.OkHttpNetworkTransport;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.log.RealmLog;\n+import io.realm.mongodb.RealmMongoDBService;\n+\n+/**\n+ * FIXME\n+ */\n+public class RealmApp {\n+\n+    // Implementation notes:\n+    // The public API's currently only allow for one RealmApp, however this is a restriction\n+    // we might want to lift in the future. So any implementation details so ideally be made\n+    // with that in mind, i.e. keep static state to minimum.\n+\n+    // Default session error handler handler that just output errors to LogCat\n+    private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {\n+        @Override\n+        public void onError(SyncSession session, ObjectServerError error) {\n+            if (error.getErrorCode() == ErrorCode.CLIENT_RESET) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI3MjM4Mw=="}, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0Mzg5ODY5OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMToyMToxOVrOF4AktA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMToyMToxOVrOF4AktA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI3Mzk3Mg==", "bodyText": "Why not using RealmThreadPoolExecutor.newDefaultExecutor() which builds a pool based on the available Core", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394273972", "createdAt": "2020-03-18T11:21:19Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.realm.internal.RealmNotifier;\n+import io.realm.internal.android.AndroidCapabilities;\n+import io.realm.internal.android.AndroidRealmNotifier;\n+import io.realm.internal.async.RealmAsyncTaskImpl;\n+import io.realm.internal.network.OkHttpNetworkTransport;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.log.RealmLog;\n+import io.realm.mongodb.RealmMongoDBService;\n+\n+/**\n+ * FIXME\n+ */\n+public class RealmApp {\n+\n+    // Implementation notes:\n+    // The public API's currently only allow for one RealmApp, however this is a restriction\n+    // we might want to lift in the future. So any implementation details so ideally be made\n+    // with that in mind, i.e. keep static state to minimum.\n+\n+    // Default session error handler handler that just output errors to LogCat\n+    private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {\n+        @Override\n+        public void onError(SyncSession session, ObjectServerError error) {\n+            if (error.getErrorCode() == ErrorCode.CLIENT_RESET) {\n+                RealmLog.error(\"Client Reset required for: \" + session.getConfiguration().getServerUrl());\n+                return;\n+            }\n+\n+            String errorMsg = String.format(Locale.US, \"Session Error[%s]: %s\",\n+                    session.getConfiguration().getServerUrl(),\n+                    error.toString());\n+            switch (error.getErrorCode().getCategory()) {\n+                case FATAL:\n+                    RealmLog.error(errorMsg);\n+                    break;\n+                case RECOVERABLE:\n+                    RealmLog.info(errorMsg);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported error category: \" + error.getErrorCode().getCategory());\n+            }\n+        }\n+    };\n+\n+    /**\n+     * Thread pool used when doing network requests against the MongoDB Realm Server.\n+     * <p>\n+     * This pool is only exposed for testing purposes and replacing it while the queue is not\n+     * empty will result in undefined behaviour.\n+     */\n+    @SuppressFBWarnings(\"MS_SHOULD_BE_FINAL\")\n+    public static ThreadPoolExecutor NETWORK_POOL_EXECUTOR = new ThreadPoolExecutor(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MzkyMDIwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMToyODowMVrOF4AyRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzo1MzowMVrOF4jS1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI3NzQ0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RealmApp(String appId) {\n          \n          \n            \n                public RealmApp(@Nonnull String appId) {", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394277447", "createdAt": "2020-03-18T11:28:01Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.realm.internal.RealmNotifier;\n+import io.realm.internal.android.AndroidCapabilities;\n+import io.realm.internal.android.AndroidRealmNotifier;\n+import io.realm.internal.async.RealmAsyncTaskImpl;\n+import io.realm.internal.network.OkHttpNetworkTransport;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.log.RealmLog;\n+import io.realm.mongodb.RealmMongoDBService;\n+\n+/**\n+ * FIXME\n+ */\n+public class RealmApp {\n+\n+    // Implementation notes:\n+    // The public API's currently only allow for one RealmApp, however this is a restriction\n+    // we might want to lift in the future. So any implementation details so ideally be made\n+    // with that in mind, i.e. keep static state to minimum.\n+\n+    // Default session error handler handler that just output errors to LogCat\n+    private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {\n+        @Override\n+        public void onError(SyncSession session, ObjectServerError error) {\n+            if (error.getErrorCode() == ErrorCode.CLIENT_RESET) {\n+                RealmLog.error(\"Client Reset required for: \" + session.getConfiguration().getServerUrl());\n+                return;\n+            }\n+\n+            String errorMsg = String.format(Locale.US, \"Session Error[%s]: %s\",\n+                    session.getConfiguration().getServerUrl(),\n+                    error.toString());\n+            switch (error.getErrorCode().getCategory()) {\n+                case FATAL:\n+                    RealmLog.error(errorMsg);\n+                    break;\n+                case RECOVERABLE:\n+                    RealmLog.info(errorMsg);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported error category: \" + error.getErrorCode().getCategory());\n+            }\n+        }\n+    };\n+\n+    /**\n+     * Thread pool used when doing network requests against the MongoDB Realm Server.\n+     * <p>\n+     * This pool is only exposed for testing purposes and replacing it while the queue is not\n+     * empty will result in undefined behaviour.\n+     */\n+    @SuppressFBWarnings(\"MS_SHOULD_BE_FINAL\")\n+    public static ThreadPoolExecutor NETWORK_POOL_EXECUTOR = new ThreadPoolExecutor(\n+            10, 10, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(100));\n+\n+    private final RealmAppConfiguration config;\n+    private OsJavaNetworkTransport networkTransport;\n+    private final long nativePtr;\n+    private CopyOnWriteArrayList<AuthenticationListener> authListeners = new CopyOnWriteArrayList<>();\n+\n+    public RealmApp(String appId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI3ODUwNA==", "bodyText": "same for the public-facing API to interop more friendly with Kotlin...", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394278504", "createdAt": "2020-03-18T11:30:03Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.realm.internal.RealmNotifier;\n+import io.realm.internal.android.AndroidCapabilities;\n+import io.realm.internal.android.AndroidRealmNotifier;\n+import io.realm.internal.async.RealmAsyncTaskImpl;\n+import io.realm.internal.network.OkHttpNetworkTransport;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.log.RealmLog;\n+import io.realm.mongodb.RealmMongoDBService;\n+\n+/**\n+ * FIXME\n+ */\n+public class RealmApp {\n+\n+    // Implementation notes:\n+    // The public API's currently only allow for one RealmApp, however this is a restriction\n+    // we might want to lift in the future. So any implementation details so ideally be made\n+    // with that in mind, i.e. keep static state to minimum.\n+\n+    // Default session error handler handler that just output errors to LogCat\n+    private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {\n+        @Override\n+        public void onError(SyncSession session, ObjectServerError error) {\n+            if (error.getErrorCode() == ErrorCode.CLIENT_RESET) {\n+                RealmLog.error(\"Client Reset required for: \" + session.getConfiguration().getServerUrl());\n+                return;\n+            }\n+\n+            String errorMsg = String.format(Locale.US, \"Session Error[%s]: %s\",\n+                    session.getConfiguration().getServerUrl(),\n+                    error.toString());\n+            switch (error.getErrorCode().getCategory()) {\n+                case FATAL:\n+                    RealmLog.error(errorMsg);\n+                    break;\n+                case RECOVERABLE:\n+                    RealmLog.info(errorMsg);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported error category: \" + error.getErrorCode().getCategory());\n+            }\n+        }\n+    };\n+\n+    /**\n+     * Thread pool used when doing network requests against the MongoDB Realm Server.\n+     * <p>\n+     * This pool is only exposed for testing purposes and replacing it while the queue is not\n+     * empty will result in undefined behaviour.\n+     */\n+    @SuppressFBWarnings(\"MS_SHOULD_BE_FINAL\")\n+    public static ThreadPoolExecutor NETWORK_POOL_EXECUTOR = new ThreadPoolExecutor(\n+            10, 10, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(100));\n+\n+    private final RealmAppConfiguration config;\n+    private OsJavaNetworkTransport networkTransport;\n+    private final long nativePtr;\n+    private CopyOnWriteArrayList<AuthenticationListener> authListeners = new CopyOnWriteArrayList<>();\n+\n+    public RealmApp(String appId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI3NzQ0Nw=="}, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg0MjgzNw==", "bodyText": "We have package level annotation files, so everything in io.realm should be marked @Nonnull by default.", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394842837", "createdAt": "2020-03-19T07:53:01Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.realm.internal.RealmNotifier;\n+import io.realm.internal.android.AndroidCapabilities;\n+import io.realm.internal.android.AndroidRealmNotifier;\n+import io.realm.internal.async.RealmAsyncTaskImpl;\n+import io.realm.internal.network.OkHttpNetworkTransport;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.log.RealmLog;\n+import io.realm.mongodb.RealmMongoDBService;\n+\n+/**\n+ * FIXME\n+ */\n+public class RealmApp {\n+\n+    // Implementation notes:\n+    // The public API's currently only allow for one RealmApp, however this is a restriction\n+    // we might want to lift in the future. So any implementation details so ideally be made\n+    // with that in mind, i.e. keep static state to minimum.\n+\n+    // Default session error handler handler that just output errors to LogCat\n+    private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {\n+        @Override\n+        public void onError(SyncSession session, ObjectServerError error) {\n+            if (error.getErrorCode() == ErrorCode.CLIENT_RESET) {\n+                RealmLog.error(\"Client Reset required for: \" + session.getConfiguration().getServerUrl());\n+                return;\n+            }\n+\n+            String errorMsg = String.format(Locale.US, \"Session Error[%s]: %s\",\n+                    session.getConfiguration().getServerUrl(),\n+                    error.toString());\n+            switch (error.getErrorCode().getCategory()) {\n+                case FATAL:\n+                    RealmLog.error(errorMsg);\n+                    break;\n+                case RECOVERABLE:\n+                    RealmLog.info(errorMsg);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported error category: \" + error.getErrorCode().getCategory());\n+            }\n+        }\n+    };\n+\n+    /**\n+     * Thread pool used when doing network requests against the MongoDB Realm Server.\n+     * <p>\n+     * This pool is only exposed for testing purposes and replacing it while the queue is not\n+     * empty will result in undefined behaviour.\n+     */\n+    @SuppressFBWarnings(\"MS_SHOULD_BE_FINAL\")\n+    public static ThreadPoolExecutor NETWORK_POOL_EXECUTOR = new ThreadPoolExecutor(\n+            10, 10, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(100));\n+\n+    private final RealmAppConfiguration config;\n+    private OsJavaNetworkTransport networkTransport;\n+    private final long nativePtr;\n+    private CopyOnWriteArrayList<AuthenticationListener> authListeners = new CopyOnWriteArrayList<>();\n+\n+    public RealmApp(String appId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI3NzQ0Nw=="}, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MzkzNTE2OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMTozMzowMFrOF4A8NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMTozMzowMFrOF4A8NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI3OTk4OA==", "bodyText": "access token or refresh token? access token expires more frequently, that it doesn't mean the user has logged out?", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394279988", "createdAt": "2020-03-18T11:33:00Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.realm.internal.RealmNotifier;\n+import io.realm.internal.android.AndroidCapabilities;\n+import io.realm.internal.android.AndroidRealmNotifier;\n+import io.realm.internal.async.RealmAsyncTaskImpl;\n+import io.realm.internal.network.OkHttpNetworkTransport;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.log.RealmLog;\n+import io.realm.mongodb.RealmMongoDBService;\n+\n+/**\n+ * FIXME\n+ */\n+public class RealmApp {\n+\n+    // Implementation notes:\n+    // The public API's currently only allow for one RealmApp, however this is a restriction\n+    // we might want to lift in the future. So any implementation details so ideally be made\n+    // with that in mind, i.e. keep static state to minimum.\n+\n+    // Default session error handler handler that just output errors to LogCat\n+    private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {\n+        @Override\n+        public void onError(SyncSession session, ObjectServerError error) {\n+            if (error.getErrorCode() == ErrorCode.CLIENT_RESET) {\n+                RealmLog.error(\"Client Reset required for: \" + session.getConfiguration().getServerUrl());\n+                return;\n+            }\n+\n+            String errorMsg = String.format(Locale.US, \"Session Error[%s]: %s\",\n+                    session.getConfiguration().getServerUrl(),\n+                    error.toString());\n+            switch (error.getErrorCode().getCategory()) {\n+                case FATAL:\n+                    RealmLog.error(errorMsg);\n+                    break;\n+                case RECOVERABLE:\n+                    RealmLog.info(errorMsg);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported error category: \" + error.getErrorCode().getCategory());\n+            }\n+        }\n+    };\n+\n+    /**\n+     * Thread pool used when doing network requests against the MongoDB Realm Server.\n+     * <p>\n+     * This pool is only exposed for testing purposes and replacing it while the queue is not\n+     * empty will result in undefined behaviour.\n+     */\n+    @SuppressFBWarnings(\"MS_SHOULD_BE_FINAL\")\n+    public static ThreadPoolExecutor NETWORK_POOL_EXECUTOR = new ThreadPoolExecutor(\n+            10, 10, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(100));\n+\n+    private final RealmAppConfiguration config;\n+    private OsJavaNetworkTransport networkTransport;\n+    private final long nativePtr;\n+    private CopyOnWriteArrayList<AuthenticationListener> authListeners = new CopyOnWriteArrayList<>();\n+\n+    public RealmApp(String appId) {\n+        this(new RealmAppConfiguration.Builder(appId).build());\n+    }\n+\n+    /**\n+     * FIXME\n+     * @param config\n+     */\n+    public RealmApp(RealmAppConfiguration config) {\n+        this.config = config;\n+        this.networkTransport = new OkHttpNetworkTransport();\n+        this.nativePtr = nativeCreate(\n+                config.getAppId(),\n+                config.getBaseUrl(),\n+                config.getAppName(),\n+                config.getAppVersion(),\n+                config.getRequestTimeoutMs());\n+    }\n+\n+    /**\n+     * Returns the current user that is logged in and still valid.\n+     * A user is invalidated when he/she logs out or the user's access token expires.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0Mzk0OTk3OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMTozNzo0NlrOF4BF2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzo1NTowOFrOF4jWSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI4MjQ1OA==", "bodyText": "This makes it less predictable from which user/sync you're working with since a user  A could be revoked/refresh_token expired, then this will default to another user B which defies the principle of least astonishment... I still think currentUser should be limited to one.", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394282458", "createdAt": "2020-03-18T11:37:46Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.realm.internal.RealmNotifier;\n+import io.realm.internal.android.AndroidCapabilities;\n+import io.realm.internal.android.AndroidRealmNotifier;\n+import io.realm.internal.async.RealmAsyncTaskImpl;\n+import io.realm.internal.network.OkHttpNetworkTransport;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.log.RealmLog;\n+import io.realm.mongodb.RealmMongoDBService;\n+\n+/**\n+ * FIXME\n+ */\n+public class RealmApp {\n+\n+    // Implementation notes:\n+    // The public API's currently only allow for one RealmApp, however this is a restriction\n+    // we might want to lift in the future. So any implementation details so ideally be made\n+    // with that in mind, i.e. keep static state to minimum.\n+\n+    // Default session error handler handler that just output errors to LogCat\n+    private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {\n+        @Override\n+        public void onError(SyncSession session, ObjectServerError error) {\n+            if (error.getErrorCode() == ErrorCode.CLIENT_RESET) {\n+                RealmLog.error(\"Client Reset required for: \" + session.getConfiguration().getServerUrl());\n+                return;\n+            }\n+\n+            String errorMsg = String.format(Locale.US, \"Session Error[%s]: %s\",\n+                    session.getConfiguration().getServerUrl(),\n+                    error.toString());\n+            switch (error.getErrorCode().getCategory()) {\n+                case FATAL:\n+                    RealmLog.error(errorMsg);\n+                    break;\n+                case RECOVERABLE:\n+                    RealmLog.info(errorMsg);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported error category: \" + error.getErrorCode().getCategory());\n+            }\n+        }\n+    };\n+\n+    /**\n+     * Thread pool used when doing network requests against the MongoDB Realm Server.\n+     * <p>\n+     * This pool is only exposed for testing purposes and replacing it while the queue is not\n+     * empty will result in undefined behaviour.\n+     */\n+    @SuppressFBWarnings(\"MS_SHOULD_BE_FINAL\")\n+    public static ThreadPoolExecutor NETWORK_POOL_EXECUTOR = new ThreadPoolExecutor(\n+            10, 10, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(100));\n+\n+    private final RealmAppConfiguration config;\n+    private OsJavaNetworkTransport networkTransport;\n+    private final long nativePtr;\n+    private CopyOnWriteArrayList<AuthenticationListener> authListeners = new CopyOnWriteArrayList<>();\n+\n+    public RealmApp(String appId) {\n+        this(new RealmAppConfiguration.Builder(appId).build());\n+    }\n+\n+    /**\n+     * FIXME\n+     * @param config\n+     */\n+    public RealmApp(RealmAppConfiguration config) {\n+        this.config = config;\n+        this.networkTransport = new OkHttpNetworkTransport();\n+        this.nativePtr = nativeCreate(\n+                config.getAppId(),\n+                config.getBaseUrl(),\n+                config.getAppName(),\n+                config.getAppVersion(),\n+                config.getRequestTimeoutMs());\n+    }\n+\n+    /**\n+     * Returns the current user that is logged in and still valid.\n+     * A user is invalidated when he/she logs out or the user's access token expires.\n+     * <p>\n+     * If two or more users are logged in, it is the last valid user that is returned by this method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg0MzcyMw==", "bodyText": "The currentUser semantics have been copied from old Stitch. I'm just describing the current semantics in ObjectStore. We cannot change them for Java alone. I added a note to our TODO list that we need to discuss exactly how this should work. There are other concerns around User lifecycle as well.", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394843723", "createdAt": "2020-03-19T07:55:08Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.realm.internal.RealmNotifier;\n+import io.realm.internal.android.AndroidCapabilities;\n+import io.realm.internal.android.AndroidRealmNotifier;\n+import io.realm.internal.async.RealmAsyncTaskImpl;\n+import io.realm.internal.network.OkHttpNetworkTransport;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.log.RealmLog;\n+import io.realm.mongodb.RealmMongoDBService;\n+\n+/**\n+ * FIXME\n+ */\n+public class RealmApp {\n+\n+    // Implementation notes:\n+    // The public API's currently only allow for one RealmApp, however this is a restriction\n+    // we might want to lift in the future. So any implementation details so ideally be made\n+    // with that in mind, i.e. keep static state to minimum.\n+\n+    // Default session error handler handler that just output errors to LogCat\n+    private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {\n+        @Override\n+        public void onError(SyncSession session, ObjectServerError error) {\n+            if (error.getErrorCode() == ErrorCode.CLIENT_RESET) {\n+                RealmLog.error(\"Client Reset required for: \" + session.getConfiguration().getServerUrl());\n+                return;\n+            }\n+\n+            String errorMsg = String.format(Locale.US, \"Session Error[%s]: %s\",\n+                    session.getConfiguration().getServerUrl(),\n+                    error.toString());\n+            switch (error.getErrorCode().getCategory()) {\n+                case FATAL:\n+                    RealmLog.error(errorMsg);\n+                    break;\n+                case RECOVERABLE:\n+                    RealmLog.info(errorMsg);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported error category: \" + error.getErrorCode().getCategory());\n+            }\n+        }\n+    };\n+\n+    /**\n+     * Thread pool used when doing network requests against the MongoDB Realm Server.\n+     * <p>\n+     * This pool is only exposed for testing purposes and replacing it while the queue is not\n+     * empty will result in undefined behaviour.\n+     */\n+    @SuppressFBWarnings(\"MS_SHOULD_BE_FINAL\")\n+    public static ThreadPoolExecutor NETWORK_POOL_EXECUTOR = new ThreadPoolExecutor(\n+            10, 10, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(100));\n+\n+    private final RealmAppConfiguration config;\n+    private OsJavaNetworkTransport networkTransport;\n+    private final long nativePtr;\n+    private CopyOnWriteArrayList<AuthenticationListener> authListeners = new CopyOnWriteArrayList<>();\n+\n+    public RealmApp(String appId) {\n+        this(new RealmAppConfiguration.Builder(appId).build());\n+    }\n+\n+    /**\n+     * FIXME\n+     * @param config\n+     */\n+    public RealmApp(RealmAppConfiguration config) {\n+        this.config = config;\n+        this.networkTransport = new OkHttpNetworkTransport();\n+        this.nativePtr = nativeCreate(\n+                config.getAppId(),\n+                config.getBaseUrl(),\n+                config.getAppName(),\n+                config.getAppVersion(),\n+                config.getRequestTimeoutMs());\n+    }\n+\n+    /**\n+     * Returns the current user that is logged in and still valid.\n+     * A user is invalidated when he/she logs out or the user's access token expires.\n+     * <p>\n+     * If two or more users are logged in, it is the last valid user that is returned by this method.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI4MjQ1OA=="}, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NDA2NzYxOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMjoxNDo1M1rOF4CRdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzozMDo0MFrOF4ivxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMwMTgxNQ==", "bodyText": "Naming: I thought we agreed to use Push Notification directly without prefix", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394301815", "createdAt": "2020-03-18T12:14:53Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.realm.internal.RealmNotifier;\n+import io.realm.internal.android.AndroidCapabilities;\n+import io.realm.internal.android.AndroidRealmNotifier;\n+import io.realm.internal.async.RealmAsyncTaskImpl;\n+import io.realm.internal.network.OkHttpNetworkTransport;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.log.RealmLog;\n+import io.realm.mongodb.RealmMongoDBService;\n+\n+/**\n+ * FIXME\n+ */\n+public class RealmApp {\n+\n+    // Implementation notes:\n+    // The public API's currently only allow for one RealmApp, however this is a restriction\n+    // we might want to lift in the future. So any implementation details so ideally be made\n+    // with that in mind, i.e. keep static state to minimum.\n+\n+    // Default session error handler handler that just output errors to LogCat\n+    private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {\n+        @Override\n+        public void onError(SyncSession session, ObjectServerError error) {\n+            if (error.getErrorCode() == ErrorCode.CLIENT_RESET) {\n+                RealmLog.error(\"Client Reset required for: \" + session.getConfiguration().getServerUrl());\n+                return;\n+            }\n+\n+            String errorMsg = String.format(Locale.US, \"Session Error[%s]: %s\",\n+                    session.getConfiguration().getServerUrl(),\n+                    error.toString());\n+            switch (error.getErrorCode().getCategory()) {\n+                case FATAL:\n+                    RealmLog.error(errorMsg);\n+                    break;\n+                case RECOVERABLE:\n+                    RealmLog.info(errorMsg);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported error category: \" + error.getErrorCode().getCategory());\n+            }\n+        }\n+    };\n+\n+    /**\n+     * Thread pool used when doing network requests against the MongoDB Realm Server.\n+     * <p>\n+     * This pool is only exposed for testing purposes and replacing it while the queue is not\n+     * empty will result in undefined behaviour.\n+     */\n+    @SuppressFBWarnings(\"MS_SHOULD_BE_FINAL\")\n+    public static ThreadPoolExecutor NETWORK_POOL_EXECUTOR = new ThreadPoolExecutor(\n+            10, 10, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(100));\n+\n+    private final RealmAppConfiguration config;\n+    private OsJavaNetworkTransport networkTransport;\n+    private final long nativePtr;\n+    private CopyOnWriteArrayList<AuthenticationListener> authListeners = new CopyOnWriteArrayList<>();\n+\n+    public RealmApp(String appId) {\n+        this(new RealmAppConfiguration.Builder(appId).build());\n+    }\n+\n+    /**\n+     * FIXME\n+     * @param config\n+     */\n+    public RealmApp(RealmAppConfiguration config) {\n+        this.config = config;\n+        this.networkTransport = new OkHttpNetworkTransport();\n+        this.nativePtr = nativeCreate(\n+                config.getAppId(),\n+                config.getBaseUrl(),\n+                config.getAppName(),\n+                config.getAppVersion(),\n+                config.getRequestTimeoutMs());\n+    }\n+\n+    /**\n+     * Returns the current user that is logged in and still valid.\n+     * A user is invalidated when he/she logs out or the user's access token expires.\n+     * <p>\n+     * If two or more users are logged in, it is the last valid user that is returned by this method.\n+     *\n+     * @return current {@link RealmUser} that has logged in and is still valid. {@code null} if no user is logged in or the user has\n+     * expired.\n+     */\n+    @Nullable\n+    public RealmUser currentUser() {\n+        Long userPtr = nativeCurrentUser(nativePtr);\n+        return (userPtr != null) ? new RealmUser(userPtr) : null;\n+    }\n+\n+    /**\n+     * FIXME\n+     * Returns all currently logged in users\n+     * @return\n+     */\n+    public Map<String, RealmUser> allUsers() {\n+        long[] nativeUsers = nativeAllUsers(nativePtr);\n+        HashMap<String, RealmUser> users = new HashMap<>(nativeUsers.length);\n+        for (int i = 0; i < nativeUsers.length; i++) {\n+            RealmUser user = new RealmUser(nativeUsers[i]);\n+            users.put(user.getId(), user);\n+        }\n+        return users;\n+    }\n+\n+    /**\n+     * TODO: Manually set the user returned by {@link #currentUser()}\n+     *\n+     * @param user\n+     */\n+    public static void setCurrentUser(SyncUser user) {\n+        // FIXME\n+    }\n+\n+    /**\n+     * FIXME\n+     *\n+     * @param credentials\n+     * @return\n+     * @throws ObjectServerError\n+     */\n+    public RealmUser login(RealmCredentials credentials) throws ObjectServerError {\n+        checkNull(credentials, \"credentials\");\n+        AtomicReference<RealmUser> user = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeLogin(nativePtr, credentials.osCredentials.getNativePtr(), new OsJavaNetworkTransport.NetworkTransportJNIResultCallback() {\n+            @Override\n+            public void onSuccess(Object result) {\n+                Long nativePtr = (Long) result;\n+                user.set(new RealmUser(nativePtr));\n+            }\n+            @Override\n+            public void onError(String nativeErrorCategory, int nativeErrorCode, String errorMessage) {\n+                ErrorCode code = ErrorCode.fromNativeError(nativeErrorCategory, nativeErrorCode);\n+                if (code == ErrorCode.UNKNOWN) {\n+                    // In case of UNKNOWN errors parse as much error information on as possible.\n+                    String detailedErrorMessage = String.format(\"{%s::%s} %s\", nativeErrorCategory, nativeErrorCode, errorMessage);\n+                    error.set(new ObjectServerError(code, detailedErrorMessage));\n+                } else {\n+                    error.set(new ObjectServerError(code, errorMessage));\n+                }\n+            }\n+        });\n+\n+        // ObjectStore runs all code in the same thread even though it is using a callback.\n+        // So results should be available here.\n+        if (user.get() == null && error.get() == null) {\n+            throw new IllegalStateException(\"Network result callback did not trigger correctly\");\n+        }\n+        if (user.get() != null) {\n+            return user.get();\n+        } else {\n+            throw error.get();\n+        }\n+    }\n+\n+    /**\n+     * FIXME\n+     * @param credentials\n+     * @param callback\n+     * @return\n+     */\n+    public RealmAsyncTask loginAsync(RealmCredentials credentials, Callback<RealmUser> callback) {\n+        checkLooperThread(\"Asynchronous login is only possible from looper threads.\");\n+        return new Request<RealmUser>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUser run() throws ObjectServerError {\n+                return login(credentials);\n+            }\n+        }.start();\n+    }\n+\n+    public static void logout(RealmUser user) {\n+\n+    }\n+    public RealmAsyncTask logoutAsync(RealmUser user, Callback<Void> callback) {\n+        return null;\n+    }\n+\n+    public RealmUser registerWithEmail(String email, String password) {\n+        return null;\n+    }\n+    public RealmAsyncTask registerWithEmailAsync(String email, String password, Callback<RealmUser> callback) {\n+        return null;\n+    }\n+    public RealmUser confirmUser(String token, String tokenId) {\n+        return null;\n+    }\n+    public RealmAsyncTask confirmUserAsync(String token, String tokenId, Callback<Void> callback) {\n+        return null;\n+    }\n+    public void resendConfirmationEmail(String email) {\n+    }\n+    public RealmAsyncTask resendConfirmationEmailAsync(String email, Callback<Void> callback) {\n+        return null;\n+    }\n+    public RealmUser resetPassword(String token, String tokenId, String password) {\n+        return null;\n+    }\n+    public RealmAsyncTask resetPasswordAsync(String token, String tokenId, String password, Callback<Void> callback) {\n+        return null;\n+    }\n+    public RealmUser sendResetPasswordEmail(String email) {\n+        return null;\n+    }\n+    public RealmAsyncTask sendResetPasswordEmailAsync(String email, Callback<Void> callback) {\n+        return null;\n+    }\n+\n+    public SyncSession getSyncSession(SyncConfiguration config) {\n+        return null;\n+    }\n+\n+    public void refreshConnections() {\n+\n+    }\n+\n+    /**\n+     * Sets a global authentication listener that will be notified about User events like\n+     * login and logout.\n+     *\n+     * @param listener listener to register.\n+     * @throws IllegalArgumentException if {@code listener} is {@code null}.\n+     */\n+    public void addAuthenticationListener(AuthenticationListener listener) {\n+        //noinspection ConstantConditions\n+        if (listener == null) {\n+            throw new IllegalArgumentException(\"Non-null 'listener' required.\");\n+        }\n+        authListeners.add(listener);\n+    }\n+\n+\n+    /**\n+     * Removes the provided global authentication listener.\n+     *\n+     * @param listener listener to remove.\n+     */\n+    public void removeAuthenticationListener(AuthenticationListener listener) {\n+        //noinspection ConstantConditions\n+        if (listener == null) {\n+            return;\n+        }\n+        authListeners.remove(listener);\n+    }\n+\n+    // Services entry point\n+    public RealmFunctions getFunctions() {\n+        // FIXME\n+        return null;\n+    }\n+\n+    public RealmFCMPushNotifications getFSMPushNotifications() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgzMzg2Mg==", "bodyText": "I don't remember exactly. I'll change it.", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394833862", "createdAt": "2020-03-19T07:30:40Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.realm.internal.RealmNotifier;\n+import io.realm.internal.android.AndroidCapabilities;\n+import io.realm.internal.android.AndroidRealmNotifier;\n+import io.realm.internal.async.RealmAsyncTaskImpl;\n+import io.realm.internal.network.OkHttpNetworkTransport;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.log.RealmLog;\n+import io.realm.mongodb.RealmMongoDBService;\n+\n+/**\n+ * FIXME\n+ */\n+public class RealmApp {\n+\n+    // Implementation notes:\n+    // The public API's currently only allow for one RealmApp, however this is a restriction\n+    // we might want to lift in the future. So any implementation details so ideally be made\n+    // with that in mind, i.e. keep static state to minimum.\n+\n+    // Default session error handler handler that just output errors to LogCat\n+    private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {\n+        @Override\n+        public void onError(SyncSession session, ObjectServerError error) {\n+            if (error.getErrorCode() == ErrorCode.CLIENT_RESET) {\n+                RealmLog.error(\"Client Reset required for: \" + session.getConfiguration().getServerUrl());\n+                return;\n+            }\n+\n+            String errorMsg = String.format(Locale.US, \"Session Error[%s]: %s\",\n+                    session.getConfiguration().getServerUrl(),\n+                    error.toString());\n+            switch (error.getErrorCode().getCategory()) {\n+                case FATAL:\n+                    RealmLog.error(errorMsg);\n+                    break;\n+                case RECOVERABLE:\n+                    RealmLog.info(errorMsg);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported error category: \" + error.getErrorCode().getCategory());\n+            }\n+        }\n+    };\n+\n+    /**\n+     * Thread pool used when doing network requests against the MongoDB Realm Server.\n+     * <p>\n+     * This pool is only exposed for testing purposes and replacing it while the queue is not\n+     * empty will result in undefined behaviour.\n+     */\n+    @SuppressFBWarnings(\"MS_SHOULD_BE_FINAL\")\n+    public static ThreadPoolExecutor NETWORK_POOL_EXECUTOR = new ThreadPoolExecutor(\n+            10, 10, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(100));\n+\n+    private final RealmAppConfiguration config;\n+    private OsJavaNetworkTransport networkTransport;\n+    private final long nativePtr;\n+    private CopyOnWriteArrayList<AuthenticationListener> authListeners = new CopyOnWriteArrayList<>();\n+\n+    public RealmApp(String appId) {\n+        this(new RealmAppConfiguration.Builder(appId).build());\n+    }\n+\n+    /**\n+     * FIXME\n+     * @param config\n+     */\n+    public RealmApp(RealmAppConfiguration config) {\n+        this.config = config;\n+        this.networkTransport = new OkHttpNetworkTransport();\n+        this.nativePtr = nativeCreate(\n+                config.getAppId(),\n+                config.getBaseUrl(),\n+                config.getAppName(),\n+                config.getAppVersion(),\n+                config.getRequestTimeoutMs());\n+    }\n+\n+    /**\n+     * Returns the current user that is logged in and still valid.\n+     * A user is invalidated when he/she logs out or the user's access token expires.\n+     * <p>\n+     * If two or more users are logged in, it is the last valid user that is returned by this method.\n+     *\n+     * @return current {@link RealmUser} that has logged in and is still valid. {@code null} if no user is logged in or the user has\n+     * expired.\n+     */\n+    @Nullable\n+    public RealmUser currentUser() {\n+        Long userPtr = nativeCurrentUser(nativePtr);\n+        return (userPtr != null) ? new RealmUser(userPtr) : null;\n+    }\n+\n+    /**\n+     * FIXME\n+     * Returns all currently logged in users\n+     * @return\n+     */\n+    public Map<String, RealmUser> allUsers() {\n+        long[] nativeUsers = nativeAllUsers(nativePtr);\n+        HashMap<String, RealmUser> users = new HashMap<>(nativeUsers.length);\n+        for (int i = 0; i < nativeUsers.length; i++) {\n+            RealmUser user = new RealmUser(nativeUsers[i]);\n+            users.put(user.getId(), user);\n+        }\n+        return users;\n+    }\n+\n+    /**\n+     * TODO: Manually set the user returned by {@link #currentUser()}\n+     *\n+     * @param user\n+     */\n+    public static void setCurrentUser(SyncUser user) {\n+        // FIXME\n+    }\n+\n+    /**\n+     * FIXME\n+     *\n+     * @param credentials\n+     * @return\n+     * @throws ObjectServerError\n+     */\n+    public RealmUser login(RealmCredentials credentials) throws ObjectServerError {\n+        checkNull(credentials, \"credentials\");\n+        AtomicReference<RealmUser> user = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeLogin(nativePtr, credentials.osCredentials.getNativePtr(), new OsJavaNetworkTransport.NetworkTransportJNIResultCallback() {\n+            @Override\n+            public void onSuccess(Object result) {\n+                Long nativePtr = (Long) result;\n+                user.set(new RealmUser(nativePtr));\n+            }\n+            @Override\n+            public void onError(String nativeErrorCategory, int nativeErrorCode, String errorMessage) {\n+                ErrorCode code = ErrorCode.fromNativeError(nativeErrorCategory, nativeErrorCode);\n+                if (code == ErrorCode.UNKNOWN) {\n+                    // In case of UNKNOWN errors parse as much error information on as possible.\n+                    String detailedErrorMessage = String.format(\"{%s::%s} %s\", nativeErrorCategory, nativeErrorCode, errorMessage);\n+                    error.set(new ObjectServerError(code, detailedErrorMessage));\n+                } else {\n+                    error.set(new ObjectServerError(code, errorMessage));\n+                }\n+            }\n+        });\n+\n+        // ObjectStore runs all code in the same thread even though it is using a callback.\n+        // So results should be available here.\n+        if (user.get() == null && error.get() == null) {\n+            throw new IllegalStateException(\"Network result callback did not trigger correctly\");\n+        }\n+        if (user.get() != null) {\n+            return user.get();\n+        } else {\n+            throw error.get();\n+        }\n+    }\n+\n+    /**\n+     * FIXME\n+     * @param credentials\n+     * @param callback\n+     * @return\n+     */\n+    public RealmAsyncTask loginAsync(RealmCredentials credentials, Callback<RealmUser> callback) {\n+        checkLooperThread(\"Asynchronous login is only possible from looper threads.\");\n+        return new Request<RealmUser>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUser run() throws ObjectServerError {\n+                return login(credentials);\n+            }\n+        }.start();\n+    }\n+\n+    public static void logout(RealmUser user) {\n+\n+    }\n+    public RealmAsyncTask logoutAsync(RealmUser user, Callback<Void> callback) {\n+        return null;\n+    }\n+\n+    public RealmUser registerWithEmail(String email, String password) {\n+        return null;\n+    }\n+    public RealmAsyncTask registerWithEmailAsync(String email, String password, Callback<RealmUser> callback) {\n+        return null;\n+    }\n+    public RealmUser confirmUser(String token, String tokenId) {\n+        return null;\n+    }\n+    public RealmAsyncTask confirmUserAsync(String token, String tokenId, Callback<Void> callback) {\n+        return null;\n+    }\n+    public void resendConfirmationEmail(String email) {\n+    }\n+    public RealmAsyncTask resendConfirmationEmailAsync(String email, Callback<Void> callback) {\n+        return null;\n+    }\n+    public RealmUser resetPassword(String token, String tokenId, String password) {\n+        return null;\n+    }\n+    public RealmAsyncTask resetPasswordAsync(String token, String tokenId, String password, Callback<Void> callback) {\n+        return null;\n+    }\n+    public RealmUser sendResetPasswordEmail(String email) {\n+        return null;\n+    }\n+    public RealmAsyncTask sendResetPasswordEmailAsync(String email, Callback<Void> callback) {\n+        return null;\n+    }\n+\n+    public SyncSession getSyncSession(SyncConfiguration config) {\n+        return null;\n+    }\n+\n+    public void refreshConnections() {\n+\n+    }\n+\n+    /**\n+     * Sets a global authentication listener that will be notified about User events like\n+     * login and logout.\n+     *\n+     * @param listener listener to register.\n+     * @throws IllegalArgumentException if {@code listener} is {@code null}.\n+     */\n+    public void addAuthenticationListener(AuthenticationListener listener) {\n+        //noinspection ConstantConditions\n+        if (listener == null) {\n+            throw new IllegalArgumentException(\"Non-null 'listener' required.\");\n+        }\n+        authListeners.add(listener);\n+    }\n+\n+\n+    /**\n+     * Removes the provided global authentication listener.\n+     *\n+     * @param listener listener to remove.\n+     */\n+    public void removeAuthenticationListener(AuthenticationListener listener) {\n+        //noinspection ConstantConditions\n+        if (listener == null) {\n+            return;\n+        }\n+        authListeners.remove(listener);\n+    }\n+\n+    // Services entry point\n+    public RealmFunctions getFunctions() {\n+        // FIXME\n+        return null;\n+    }\n+\n+    public RealmFCMPushNotifications getFSMPushNotifications() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMwMTgxNQ=="}, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 286}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NDA4MjE4OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMjoxOTo0NlrOF4CbHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMjoxOTo0NlrOF4CbHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMwNDI4NA==", "bodyText": "Could not be posted, instead ... and you can fallback to print the error on the stderr", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394304284", "createdAt": "2020-03-18T12:19:46Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.realm.internal.RealmNotifier;\n+import io.realm.internal.android.AndroidCapabilities;\n+import io.realm.internal.android.AndroidRealmNotifier;\n+import io.realm.internal.async.RealmAsyncTaskImpl;\n+import io.realm.internal.network.OkHttpNetworkTransport;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.log.RealmLog;\n+import io.realm.mongodb.RealmMongoDBService;\n+\n+/**\n+ * FIXME\n+ */\n+public class RealmApp {\n+\n+    // Implementation notes:\n+    // The public API's currently only allow for one RealmApp, however this is a restriction\n+    // we might want to lift in the future. So any implementation details so ideally be made\n+    // with that in mind, i.e. keep static state to minimum.\n+\n+    // Default session error handler handler that just output errors to LogCat\n+    private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {\n+        @Override\n+        public void onError(SyncSession session, ObjectServerError error) {\n+            if (error.getErrorCode() == ErrorCode.CLIENT_RESET) {\n+                RealmLog.error(\"Client Reset required for: \" + session.getConfiguration().getServerUrl());\n+                return;\n+            }\n+\n+            String errorMsg = String.format(Locale.US, \"Session Error[%s]: %s\",\n+                    session.getConfiguration().getServerUrl(),\n+                    error.toString());\n+            switch (error.getErrorCode().getCategory()) {\n+                case FATAL:\n+                    RealmLog.error(errorMsg);\n+                    break;\n+                case RECOVERABLE:\n+                    RealmLog.info(errorMsg);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported error category: \" + error.getErrorCode().getCategory());\n+            }\n+        }\n+    };\n+\n+    /**\n+     * Thread pool used when doing network requests against the MongoDB Realm Server.\n+     * <p>\n+     * This pool is only exposed for testing purposes and replacing it while the queue is not\n+     * empty will result in undefined behaviour.\n+     */\n+    @SuppressFBWarnings(\"MS_SHOULD_BE_FINAL\")\n+    public static ThreadPoolExecutor NETWORK_POOL_EXECUTOR = new ThreadPoolExecutor(\n+            10, 10, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(100));\n+\n+    private final RealmAppConfiguration config;\n+    private OsJavaNetworkTransport networkTransport;\n+    private final long nativePtr;\n+    private CopyOnWriteArrayList<AuthenticationListener> authListeners = new CopyOnWriteArrayList<>();\n+\n+    public RealmApp(String appId) {\n+        this(new RealmAppConfiguration.Builder(appId).build());\n+    }\n+\n+    /**\n+     * FIXME\n+     * @param config\n+     */\n+    public RealmApp(RealmAppConfiguration config) {\n+        this.config = config;\n+        this.networkTransport = new OkHttpNetworkTransport();\n+        this.nativePtr = nativeCreate(\n+                config.getAppId(),\n+                config.getBaseUrl(),\n+                config.getAppName(),\n+                config.getAppVersion(),\n+                config.getRequestTimeoutMs());\n+    }\n+\n+    /**\n+     * Returns the current user that is logged in and still valid.\n+     * A user is invalidated when he/she logs out or the user's access token expires.\n+     * <p>\n+     * If two or more users are logged in, it is the last valid user that is returned by this method.\n+     *\n+     * @return current {@link RealmUser} that has logged in and is still valid. {@code null} if no user is logged in or the user has\n+     * expired.\n+     */\n+    @Nullable\n+    public RealmUser currentUser() {\n+        Long userPtr = nativeCurrentUser(nativePtr);\n+        return (userPtr != null) ? new RealmUser(userPtr) : null;\n+    }\n+\n+    /**\n+     * FIXME\n+     * Returns all currently logged in users\n+     * @return\n+     */\n+    public Map<String, RealmUser> allUsers() {\n+        long[] nativeUsers = nativeAllUsers(nativePtr);\n+        HashMap<String, RealmUser> users = new HashMap<>(nativeUsers.length);\n+        for (int i = 0; i < nativeUsers.length; i++) {\n+            RealmUser user = new RealmUser(nativeUsers[i]);\n+            users.put(user.getId(), user);\n+        }\n+        return users;\n+    }\n+\n+    /**\n+     * TODO: Manually set the user returned by {@link #currentUser()}\n+     *\n+     * @param user\n+     */\n+    public static void setCurrentUser(SyncUser user) {\n+        // FIXME\n+    }\n+\n+    /**\n+     * FIXME\n+     *\n+     * @param credentials\n+     * @return\n+     * @throws ObjectServerError\n+     */\n+    public RealmUser login(RealmCredentials credentials) throws ObjectServerError {\n+        checkNull(credentials, \"credentials\");\n+        AtomicReference<RealmUser> user = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeLogin(nativePtr, credentials.osCredentials.getNativePtr(), new OsJavaNetworkTransport.NetworkTransportJNIResultCallback() {\n+            @Override\n+            public void onSuccess(Object result) {\n+                Long nativePtr = (Long) result;\n+                user.set(new RealmUser(nativePtr));\n+            }\n+            @Override\n+            public void onError(String nativeErrorCategory, int nativeErrorCode, String errorMessage) {\n+                ErrorCode code = ErrorCode.fromNativeError(nativeErrorCategory, nativeErrorCode);\n+                if (code == ErrorCode.UNKNOWN) {\n+                    // In case of UNKNOWN errors parse as much error information on as possible.\n+                    String detailedErrorMessage = String.format(\"{%s::%s} %s\", nativeErrorCategory, nativeErrorCode, errorMessage);\n+                    error.set(new ObjectServerError(code, detailedErrorMessage));\n+                } else {\n+                    error.set(new ObjectServerError(code, errorMessage));\n+                }\n+            }\n+        });\n+\n+        // ObjectStore runs all code in the same thread even though it is using a callback.\n+        // So results should be available here.\n+        if (user.get() == null && error.get() == null) {\n+            throw new IllegalStateException(\"Network result callback did not trigger correctly\");\n+        }\n+        if (user.get() != null) {\n+            return user.get();\n+        } else {\n+            throw error.get();\n+        }\n+    }\n+\n+    /**\n+     * FIXME\n+     * @param credentials\n+     * @param callback\n+     * @return\n+     */\n+    public RealmAsyncTask loginAsync(RealmCredentials credentials, Callback<RealmUser> callback) {\n+        checkLooperThread(\"Asynchronous login is only possible from looper threads.\");\n+        return new Request<RealmUser>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUser run() throws ObjectServerError {\n+                return login(credentials);\n+            }\n+        }.start();\n+    }\n+\n+    public static void logout(RealmUser user) {\n+\n+    }\n+    public RealmAsyncTask logoutAsync(RealmUser user, Callback<Void> callback) {\n+        return null;\n+    }\n+\n+    public RealmUser registerWithEmail(String email, String password) {\n+        return null;\n+    }\n+    public RealmAsyncTask registerWithEmailAsync(String email, String password, Callback<RealmUser> callback) {\n+        return null;\n+    }\n+    public RealmUser confirmUser(String token, String tokenId) {\n+        return null;\n+    }\n+    public RealmAsyncTask confirmUserAsync(String token, String tokenId, Callback<Void> callback) {\n+        return null;\n+    }\n+    public void resendConfirmationEmail(String email) {\n+    }\n+    public RealmAsyncTask resendConfirmationEmailAsync(String email, Callback<Void> callback) {\n+        return null;\n+    }\n+    public RealmUser resetPassword(String token, String tokenId, String password) {\n+        return null;\n+    }\n+    public RealmAsyncTask resetPasswordAsync(String token, String tokenId, String password, Callback<Void> callback) {\n+        return null;\n+    }\n+    public RealmUser sendResetPasswordEmail(String email) {\n+        return null;\n+    }\n+    public RealmAsyncTask sendResetPasswordEmailAsync(String email, Callback<Void> callback) {\n+        return null;\n+    }\n+\n+    public SyncSession getSyncSession(SyncConfiguration config) {\n+        return null;\n+    }\n+\n+    public void refreshConnections() {\n+\n+    }\n+\n+    /**\n+     * Sets a global authentication listener that will be notified about User events like\n+     * login and logout.\n+     *\n+     * @param listener listener to register.\n+     * @throws IllegalArgumentException if {@code listener} is {@code null}.\n+     */\n+    public void addAuthenticationListener(AuthenticationListener listener) {\n+        //noinspection ConstantConditions\n+        if (listener == null) {\n+            throw new IllegalArgumentException(\"Non-null 'listener' required.\");\n+        }\n+        authListeners.add(listener);\n+    }\n+\n+\n+    /**\n+     * Removes the provided global authentication listener.\n+     *\n+     * @param listener listener to remove.\n+     */\n+    public void removeAuthenticationListener(AuthenticationListener listener) {\n+        //noinspection ConstantConditions\n+        if (listener == null) {\n+            return;\n+        }\n+        authListeners.remove(listener);\n+    }\n+\n+    // Services entry point\n+    public RealmFunctions getFunctions() {\n+        // FIXME\n+        return null;\n+    }\n+\n+    public RealmFCMPushNotifications getFSMPushNotifications() {\n+        // FIXME\n+        return null;\n+\n+    }\n+\n+    public RealmMongoDBService getMongoDBService() {\n+        // FIXME\n+        return null;\n+    }\n+\n+    // Private API's for now.\n+\n+    /**\n+     * Exposed for testing.\n+     *\n+     * Swap the currently configured network transport with the provided one.\n+     * This should only be done if no network requests are currently running.\n+     */\n+    void setNetworkTransport(OsJavaNetworkTransport transport) {\n+        networkTransport = transport;\n+    }\n+\n+    OsJavaNetworkTransport getNetworkTransport() {\n+        return networkTransport;\n+    }\n+\n+    private static void checkLooperThread(String errorMessage) {\n+        AndroidCapabilities capabilities = new AndroidCapabilities();\n+        capabilities.checkCanDeliverNotification(errorMessage);\n+    }\n+\n+    private void checkNull(@Nullable Object argValue, String argName) {\n+        if (argValue == null) {\n+            throw new IllegalArgumentException(\"Nonnull '\" + argName + \"' required.\");\n+        }\n+    }\n+\n+    // Class wrapping requests made against MongoDB Realm. Is also responsible for calling with success/error on the\n+    // correct thread.\n+    private static abstract class Request<T> {\n+        @Nullable\n+        private final RealmApp.Callback<T> callback;\n+        private final RealmNotifier handler;\n+        private final ThreadPoolExecutor networkPoolExecutor;\n+\n+        Request(ThreadPoolExecutor networkPoolExecutor, @Nullable RealmApp.Callback<T> callback) {\n+            this.callback = callback;\n+            this.handler = new AndroidRealmNotifier(null, new AndroidCapabilities());\n+            this.networkPoolExecutor = networkPoolExecutor;\n+        }\n+\n+        // Implements the request. Return the current sync user if the request succeeded. Otherwise throw an error.\n+        public abstract T run() throws ObjectServerError;\n+\n+        // Start the request\n+        public RealmAsyncTask start() {\n+            Future<?> authenticateRequest = networkPoolExecutor.submit(new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        postSuccess(Request.this.run());\n+                    } catch (ObjectServerError e) {\n+                        postError(e);\n+                    } catch (Throwable e) {\n+                        postError(new ObjectServerError(ErrorCode.UNKNOWN, \"Unexpected error\", e));\n+                    }\n+                }\n+            });\n+            return new RealmAsyncTaskImpl(authenticateRequest, networkPoolExecutor);\n+        }\n+\n+        private void postError(final ObjectServerError error) {\n+            boolean errorHandled = false;\n+            if (callback != null) {\n+                Runnable action = new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        callback.onError(error);\n+                    }\n+                };\n+                errorHandled = handler.post(action);\n+            }\n+\n+            if (!errorHandled) {\n+                RealmLog.error(error, \"An error was thrown, but could not be handled.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 371}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NDA5ODgyOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmAppConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMjoyNDo0MVrOF4ClgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzozNjoxNVrOF4i37Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMwNjk0NA==", "bodyText": "TODO: maybe change to INFO for the release", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394306944", "createdAt": "2020-03-18T12:24:41Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmAppConfiguration.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import android.content.Context;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.log.LogLevel;\n+\n+/**\n+ * FIXME\n+ */\n+public class RealmAppConfiguration {\n+\n+    private final String appId;\n+    private final String appName;\n+    private final String appVersion;\n+    private final String baseUrl;\n+    private final Context context;\n+    private final SyncSession.ErrorHandler defaultErrorHandler;\n+    @Nullable private final byte[] encryptionKey;\n+    private final long logLevel;\n+    private final long requestTimeoutMs;\n+\n+    public RealmAppConfiguration(String appId,\n+                                 String appName,\n+                                 String appVersion,\n+                                 String baseUrl,\n+                                 Context context,\n+                                 SyncSession.ErrorHandler defaultErrorHandler,\n+                                 @Nullable byte[] encryptionKey,\n+                                 long logLevel,\n+                                 long requestTimeoutMs) {\n+\n+        this.appId = appId;\n+        this.appName = appName;\n+        this.appVersion = appVersion;\n+        this.baseUrl = baseUrl;\n+        this.context = context;\n+        this.defaultErrorHandler = defaultErrorHandler;\n+        this.encryptionKey = (encryptionKey == null) ? null : Arrays.copyOf(encryptionKey, encryptionKey.length);\n+        this.logLevel = logLevel;\n+        this.requestTimeoutMs = requestTimeoutMs;\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public String getAppId() {\n+        return appId;\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public String getAppName() {\n+        return appName;\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public String getAppVersion() {\n+        return appVersion;\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public String getBaseUrl() {\n+        return baseUrl;\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public Context getContext() {\n+        return context;\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public SyncSession.ErrorHandler getDefaultErrorHandler() {\n+        return defaultErrorHandler;\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public byte[] getEncryptionKey() {\n+        return encryptionKey == null ? null : Arrays.copyOf(encryptionKey, encryptionKey.length);\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public long getLogLevel() {\n+        return logLevel;\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public long getRequestTimeoutMs() {\n+        return requestTimeoutMs;\n+    }\n+\n+    /**\n+     * FIXME\n+     */\n+    public static class Builder {\n+        private String appId;\n+        private String appName;\n+        private String appVersion;\n+        private String baseUrl;\n+        private Context context;\n+        private SyncSession.ErrorHandler defaultErrorHandler;\n+        private byte[] encryptionKey;\n+        private long logLevel = LogLevel.WARN;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgzNTk0OQ==", "bodyText": "Added TODO, so we remember to visit", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394835949", "createdAt": "2020-03-19T07:36:15Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmAppConfiguration.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import android.content.Context;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.log.LogLevel;\n+\n+/**\n+ * FIXME\n+ */\n+public class RealmAppConfiguration {\n+\n+    private final String appId;\n+    private final String appName;\n+    private final String appVersion;\n+    private final String baseUrl;\n+    private final Context context;\n+    private final SyncSession.ErrorHandler defaultErrorHandler;\n+    @Nullable private final byte[] encryptionKey;\n+    private final long logLevel;\n+    private final long requestTimeoutMs;\n+\n+    public RealmAppConfiguration(String appId,\n+                                 String appName,\n+                                 String appVersion,\n+                                 String baseUrl,\n+                                 Context context,\n+                                 SyncSession.ErrorHandler defaultErrorHandler,\n+                                 @Nullable byte[] encryptionKey,\n+                                 long logLevel,\n+                                 long requestTimeoutMs) {\n+\n+        this.appId = appId;\n+        this.appName = appName;\n+        this.appVersion = appVersion;\n+        this.baseUrl = baseUrl;\n+        this.context = context;\n+        this.defaultErrorHandler = defaultErrorHandler;\n+        this.encryptionKey = (encryptionKey == null) ? null : Arrays.copyOf(encryptionKey, encryptionKey.length);\n+        this.logLevel = logLevel;\n+        this.requestTimeoutMs = requestTimeoutMs;\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public String getAppId() {\n+        return appId;\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public String getAppName() {\n+        return appName;\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public String getAppVersion() {\n+        return appVersion;\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public String getBaseUrl() {\n+        return baseUrl;\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public Context getContext() {\n+        return context;\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public SyncSession.ErrorHandler getDefaultErrorHandler() {\n+        return defaultErrorHandler;\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public byte[] getEncryptionKey() {\n+        return encryptionKey == null ? null : Arrays.copyOf(encryptionKey, encryptionKey.length);\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public long getLogLevel() {\n+        return logLevel;\n+    }\n+\n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    public long getRequestTimeoutMs() {\n+        return requestTimeoutMs;\n+    }\n+\n+    /**\n+     * FIXME\n+     */\n+    public static class Builder {\n+        private String appId;\n+        private String appName;\n+        private String appVersion;\n+        private String baseUrl;\n+        private Context context;\n+        private SyncSession.ErrorHandler defaultErrorHandler;\n+        private byte[] encryptionKey;\n+        private long logLevel = LogLevel.WARN;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMwNjk0NA=="}, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NDEwNDMxOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmAppConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMjoyNjowN1rOF4CowQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMjoyNjowN1rOF4CowQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMwNzc3Nw==", "bodyText": "ctor can be private", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394307777", "createdAt": "2020-03-18T12:26:07Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmAppConfiguration.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import android.content.Context;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.log.LogLevel;\n+\n+/**\n+ * FIXME\n+ */\n+public class RealmAppConfiguration {\n+\n+    private final String appId;\n+    private final String appName;\n+    private final String appVersion;\n+    private final String baseUrl;\n+    private final Context context;\n+    private final SyncSession.ErrorHandler defaultErrorHandler;\n+    @Nullable private final byte[] encryptionKey;\n+    private final long logLevel;\n+    private final long requestTimeoutMs;\n+\n+    public RealmAppConfiguration(String appId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NDEyOTkxOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmCredentials.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMjozMzoxOFrOF4C4bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzo1OTozOFrOF4jdzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMxMTc4OA==", "bodyText": "TODO: doc might not be up-to-date", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394311788", "createdAt": "2020-03-18T12:33:18Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmCredentials.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsAppCredentials;\n+\n+\n+/**\n+ * Credentials represent a login with a 3rd party login provider in an OAuth2 login flow, and are used by the Realm", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg0NTY0NQ==", "bodyText": "Added to the list", "url": "https://github.com/realm/realm-java/pull/6757#discussion_r394845645", "createdAt": "2020-03-19T07:59:38Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/RealmCredentials.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsAppCredentials;\n+\n+\n+/**\n+ * Credentials represent a login with a 3rd party login provider in an OAuth2 login flow, and are used by the Realm", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMxMTc4OA=="}, "originalCommit": {"oid": "d98304d6f7774cfdac5cd3bd396785473728554f"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 597, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}