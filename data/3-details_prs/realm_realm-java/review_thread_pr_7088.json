{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyMTE0MTc1", "number": 7088, "reviewThreads": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwOTowMzo0MFrOEjB-tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMzo1MzozNFrOEmnOmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTY4MDU1OnYy", "diffSide": "RIGHT", "path": "examples/compatibilityExample/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwOTowMzo0MFrOHRKiHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwOTowMzo0MFrOHRKiHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc2MDQxMg==", "bodyText": "Yes, as long as we don't require AndroidX we need to make sure we still work there. This project is specifically for this purpose.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487760412", "createdAt": "2020-09-14T09:03:40Z", "author": {"login": "cmelchior"}, "path": "examples/compatibilityExample/build.gradle", "diffHunk": "@@ -68,5 +68,6 @@ dependencies {\n     implementation 'com.android.support.constraint:constraint-layout:1.1.3'\n }\n \n-if ((project.findProperty(\"android.useAndroidX\") ?: false).toBoolean())\n-    throw new RuntimeException(\"Compatibility project should run without AndroidX\")\n+// FIXME should we still have this example given how extended jetpack already is?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTcwMDM1OnYy", "diffSide": "RIGHT", "path": "examples/coroutinesExample/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwOTowODo0OFrOHRKuFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwOTowODo0OFrOHRKuFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc2MzQ3Nw==", "bodyText": "Are these needed, we don't use them elsewhere? Same for the rest of them", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487763477", "createdAt": "2020-09-14T09:08:48Z", "author": {"login": "cmelchior"}, "path": "examples/coroutinesExample/build.gradle", "diffHunk": "@@ -0,0 +1,83 @@\n+buildscript {\n+    ext.kotlin_version = rootProject.kotlinVersion\n+    repositories {\n+        jcenter()\n+        mavenCentral()\n+    }\n+    dependencies {\n+        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n+    }\n+}\n+\n+apply plugin: 'com.android.application'\n+apply plugin: 'kotlin-android'\n+apply plugin: 'kotlin-android-extensions'\n+apply plugin: 'kotlin-kapt'\n+apply plugin: 'realm-android'\n+\n+android {\n+    //noinspection GroovyAssignabilityCheck", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjUwODgxOnYy", "diffSide": "RIGHT", "path": "examples/coroutinesExample/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1MToxM1rOHRSOzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1MToxM1rOHRSOzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4NjU0Mg==", "bodyText": "This should be set by default when the kotlin plugin is detected", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487886542", "createdAt": "2020-09-14T12:51:13Z", "author": {"login": "cmelchior"}, "path": "examples/coroutinesExample/build.gradle", "diffHunk": "@@ -0,0 +1,83 @@\n+buildscript {\n+    ext.kotlin_version = rootProject.kotlinVersion\n+    repositories {\n+        jcenter()\n+        mavenCentral()\n+    }\n+    dependencies {\n+        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n+    }\n+}\n+\n+apply plugin: 'com.android.application'\n+apply plugin: 'kotlin-android'\n+apply plugin: 'kotlin-android-extensions'\n+apply plugin: 'kotlin-kapt'\n+apply plugin: 'realm-android'\n+\n+android {\n+    //noinspection GroovyAssignabilityCheck\n+    compileSdkVersion rootProject.sdkVersion\n+    //noinspection GroovyAssignabilityCheck\n+    buildToolsVersion rootProject.buildTools\n+\n+    defaultConfig {\n+        applicationId \"io.realm.examples.coroutinesexample\"\n+        //noinspection GroovyAssignabilityCheck\n+        targetSdkVersion rootProject.sdkVersion\n+        minSdkVersion rootProject.minSdkVersion\n+        versionCode 1\n+        versionName \"1.0\"\n+\n+        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n+    }\n+\n+    buildTypes {\n+        release {\n+            minifyEnabled false\n+            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n+        }\n+    }\n+\n+    packagingOptions {\n+        exclude 'META-INF/LICENSE'\n+    }\n+\n+    compileOptions {\n+        sourceCompatibility JavaVersion.VERSION_1_8\n+        targetCompatibility JavaVersion.VERSION_1_8\n+    }\n+\n+    kotlinOptions {\n+        jvmTarget = JavaVersion.VERSION_1_8.toString()\n+    }\n+}\n+\n+realm {\n+    kotlinExtensionsEnabled = true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjUwOTY4OnYy", "diffSide": "RIGHT", "path": "examples/coroutinesExample/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1MToyM1rOHRSPRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1MToyM1rOHRSPRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4NjY2Mw==", "bodyText": "Delete?", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487886663", "createdAt": "2020-09-14T12:51:23Z", "author": {"login": "cmelchior"}, "path": "examples/coroutinesExample/build.gradle", "diffHunk": "@@ -0,0 +1,83 @@\n+buildscript {\n+    ext.kotlin_version = rootProject.kotlinVersion\n+    repositories {\n+        jcenter()\n+        mavenCentral()\n+    }\n+    dependencies {\n+        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n+    }\n+}\n+\n+apply plugin: 'com.android.application'\n+apply plugin: 'kotlin-android'\n+apply plugin: 'kotlin-android-extensions'\n+apply plugin: 'kotlin-kapt'\n+apply plugin: 'realm-android'\n+\n+android {\n+    //noinspection GroovyAssignabilityCheck\n+    compileSdkVersion rootProject.sdkVersion\n+    //noinspection GroovyAssignabilityCheck\n+    buildToolsVersion rootProject.buildTools\n+\n+    defaultConfig {\n+        applicationId \"io.realm.examples.coroutinesexample\"\n+        //noinspection GroovyAssignabilityCheck\n+        targetSdkVersion rootProject.sdkVersion\n+        minSdkVersion rootProject.minSdkVersion\n+        versionCode 1\n+        versionName \"1.0\"\n+\n+        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n+    }\n+\n+    buildTypes {\n+        release {\n+            minifyEnabled false\n+            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n+        }\n+    }\n+\n+    packagingOptions {\n+        exclude 'META-INF/LICENSE'\n+    }\n+\n+    compileOptions {\n+        sourceCompatibility JavaVersion.VERSION_1_8\n+        targetCompatibility JavaVersion.VERSION_1_8\n+    }\n+\n+    kotlinOptions {\n+        jvmTarget = JavaVersion.VERSION_1_8.toString()\n+    }\n+}\n+\n+realm {\n+    kotlinExtensionsEnabled = true\n+}\n+\n+dependencies {\n+    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n+    implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n+\n+    implementation \"androidx.constraintlayout:constraintlayout:2.0.1\"\n+\n+//    implementation 'android.arch.lifecycle:extensions:1.1.1'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjUxMDA5OnYy", "diffSide": "RIGHT", "path": "examples/coroutinesExample/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1MToyOFrOHRSPiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1MToyOFrOHRSPiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4NjcyOA==", "bodyText": "Delete?", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487886728", "createdAt": "2020-09-14T12:51:28Z", "author": {"login": "cmelchior"}, "path": "examples/coroutinesExample/build.gradle", "diffHunk": "@@ -0,0 +1,83 @@\n+buildscript {\n+    ext.kotlin_version = rootProject.kotlinVersion\n+    repositories {\n+        jcenter()\n+        mavenCentral()\n+    }\n+    dependencies {\n+        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n+    }\n+}\n+\n+apply plugin: 'com.android.application'\n+apply plugin: 'kotlin-android'\n+apply plugin: 'kotlin-android-extensions'\n+apply plugin: 'kotlin-kapt'\n+apply plugin: 'realm-android'\n+\n+android {\n+    //noinspection GroovyAssignabilityCheck\n+    compileSdkVersion rootProject.sdkVersion\n+    //noinspection GroovyAssignabilityCheck\n+    buildToolsVersion rootProject.buildTools\n+\n+    defaultConfig {\n+        applicationId \"io.realm.examples.coroutinesexample\"\n+        //noinspection GroovyAssignabilityCheck\n+        targetSdkVersion rootProject.sdkVersion\n+        minSdkVersion rootProject.minSdkVersion\n+        versionCode 1\n+        versionName \"1.0\"\n+\n+        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n+    }\n+\n+    buildTypes {\n+        release {\n+            minifyEnabled false\n+            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n+        }\n+    }\n+\n+    packagingOptions {\n+        exclude 'META-INF/LICENSE'\n+    }\n+\n+    compileOptions {\n+        sourceCompatibility JavaVersion.VERSION_1_8\n+        targetCompatibility JavaVersion.VERSION_1_8\n+    }\n+\n+    kotlinOptions {\n+        jvmTarget = JavaVersion.VERSION_1_8.toString()\n+    }\n+}\n+\n+realm {\n+    kotlinExtensionsEnabled = true\n+}\n+\n+dependencies {\n+    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n+    implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n+\n+    implementation \"androidx.constraintlayout:constraintlayout:2.0.1\"\n+\n+//    implementation 'android.arch.lifecycle:extensions:1.1.1'\n+\n+    implementation \"androidx.activity:activity-ktx:1.1.0\"\n+    implementation \"androidx.fragment:fragment-ktx:1.2.5\"\n+\n+    implementation \"androidx.appcompat:appcompat:1.2.0\"\n+\n+//    implementation 'androidx.core:core-ktx:1.3.1'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjUxMTU5OnYy", "diffSide": "RIGHT", "path": "examples/coroutinesExample/src/main/java/io/realm/examples/coroutinesexample/MainActivity.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1MTo0OFrOHRSQag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1MTo0OFrOHRSQag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4Njk1NA==", "bodyText": "All of these files need license headers", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487886954", "createdAt": "2020-09-14T12:51:48Z", "author": {"login": "cmelchior"}, "path": "examples/coroutinesExample/src/main/java/io/realm/examples/coroutinesexample/MainActivity.kt", "diffHunk": "@@ -0,0 +1,18 @@\n+package io.realm.examples.coroutinesexample", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjUxMjkyOnYy", "diffSide": "RIGHT", "path": "examples/coroutinesExample/src/main/java/io/realm/examples/coroutinesexample/model/Doggo.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1MjowN1rOHRSRJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1MjowN1rOHRSRJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4NzE0MA==", "bodyText": "Dog?", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487887140", "createdAt": "2020-09-14T12:52:07Z", "author": {"login": "cmelchior"}, "path": "examples/coroutinesExample/src/main/java/io/realm/examples/coroutinesexample/model/Doggo.kt", "diffHunk": "@@ -0,0 +1,11 @@\n+package io.realm.examples.coroutinesexample.model\n+\n+import io.realm.RealmObject\n+import io.realm.annotations.PrimaryKey\n+\n+open class Doggo : RealmObject() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjUxNTAzOnYy", "diffSide": "RIGHT", "path": "examples/coroutinesExample/src/main/java/io/realm/examples/coroutinesexample/repository/Repository.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1MjozN1rOHRSSag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMDozNToxMVrOHRlnnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4NzQ2Ng==", "bodyText": "I assume this should also use executeTransactionAsync ?", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487887466", "createdAt": "2020-09-14T12:52:37Z", "author": {"login": "cmelchior"}, "path": "examples/coroutinesExample/src/main/java/io/realm/examples/coroutinesexample/repository/Repository.kt", "diffHunk": "@@ -0,0 +1,48 @@\n+package io.realm.examples.coroutinesexample.repository\n+\n+import android.util.Log\n+import io.realm.Realm\n+import io.realm.examples.coroutinesexample.model.Doggo\n+import io.realm.kotlin.executeTransactionAwait\n+import io.realm.kotlin.toFlow\n+import kotlinx.coroutines.flow.Flow\n+\n+interface Repository {\n+    suspend fun insertDogs()\n+    fun getDogs(): Flow<List<Doggo>>\n+    fun deleteDogs()\n+}\n+\n+class RealmRepository : Repository {\n+\n+    override suspend fun insertDogs() {\n+        Realm.getDefaultInstance().use { defaultRealm ->\n+            defaultRealm.executeTransactionAwait { realm ->\n+                Log.e(\"--->\", \"---> ${Thread.currentThread().name} - BEFORE  transaction\")\n+                for (i in 1..10000000) {\n+                    realm.insertOrUpdate(Doggo().apply {\n+                        name = \"Fluffy $i\"\n+                        age = 1\n+                        owner = \"Jane Doe\"\n+                    })\n+                }\n+                Log.e(\"--->\", \"---> ${Thread.currentThread().name} - AFTER   transaction\")\n+            }\n+        }\n+    }\n+\n+    override fun getDogs(): Flow<List<Doggo>> {\n+        return Realm.getDefaultInstance()\n+                .where(Doggo::class.java)\n+                .findAllAsync()\n+                .toFlow()\n+    }\n+\n+    override fun deleteDogs() {\n+        Realm.getDefaultInstance().use { defaultRealm ->\n+            defaultRealm.executeTransaction { realm ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIwNDE4OQ==", "bodyText": "That is right, I completely missed it.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r488204189", "createdAt": "2020-09-14T20:35:11Z", "author": {"login": "edualonso"}, "path": "examples/coroutinesExample/src/main/java/io/realm/examples/coroutinesexample/repository/Repository.kt", "diffHunk": "@@ -0,0 +1,48 @@\n+package io.realm.examples.coroutinesexample.repository\n+\n+import android.util.Log\n+import io.realm.Realm\n+import io.realm.examples.coroutinesexample.model.Doggo\n+import io.realm.kotlin.executeTransactionAwait\n+import io.realm.kotlin.toFlow\n+import kotlinx.coroutines.flow.Flow\n+\n+interface Repository {\n+    suspend fun insertDogs()\n+    fun getDogs(): Flow<List<Doggo>>\n+    fun deleteDogs()\n+}\n+\n+class RealmRepository : Repository {\n+\n+    override suspend fun insertDogs() {\n+        Realm.getDefaultInstance().use { defaultRealm ->\n+            defaultRealm.executeTransactionAwait { realm ->\n+                Log.e(\"--->\", \"---> ${Thread.currentThread().name} - BEFORE  transaction\")\n+                for (i in 1..10000000) {\n+                    realm.insertOrUpdate(Doggo().apply {\n+                        name = \"Fluffy $i\"\n+                        age = 1\n+                        owner = \"Jane Doe\"\n+                    })\n+                }\n+                Log.e(\"--->\", \"---> ${Thread.currentThread().name} - AFTER   transaction\")\n+            }\n+        }\n+    }\n+\n+    override fun getDogs(): Flow<List<Doggo>> {\n+        return Realm.getDefaultInstance()\n+                .where(Doggo::class.java)\n+                .findAllAsync()\n+                .toFlow()\n+    }\n+\n+    override fun deleteDogs() {\n+        Realm.getDefaultInstance().use { defaultRealm ->\n+            defaultRealm.executeTransaction { realm ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4NzQ2Ng=="}, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjUyOTA0OnYy", "diffSide": "RIGHT", "path": "examples/coroutinesExample/src/main/java/io/realm/examples/coroutinesexample/ui/main/MainFragment.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1NTo0M1rOHRSapw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1NTo0M1rOHRSapw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4OTU3NQ==", "bodyText": "We have  realm.where<Doggo> as an extension function", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487889575", "createdAt": "2020-09-14T12:55:43Z", "author": {"login": "cmelchior"}, "path": "examples/coroutinesExample/src/main/java/io/realm/examples/coroutinesexample/ui/main/MainFragment.kt", "diffHunk": "@@ -0,0 +1,55 @@\n+package io.realm.examples.coroutinesexample.ui.main\n+\n+import android.os.Bundle\n+import android.util.Log\n+import android.view.LayoutInflater\n+import android.view.View\n+import android.view.ViewGroup\n+import android.widget.Button\n+import androidx.fragment.app.Fragment\n+import androidx.fragment.app.viewModels\n+import androidx.lifecycle.Observer\n+import io.realm.Realm\n+import io.realm.examples.coroutinesexample.R\n+import io.realm.examples.coroutinesexample.model.Doggo\n+\n+class MainFragment : Fragment() {\n+\n+    companion object {\n+        fun newInstance() = MainFragment()\n+    }\n+\n+    private val viewModel: MainViewModel by viewModels()\n+\n+    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,\n+                              savedInstanceState: Bundle?): View {\n+        return inflater.inflate(R.layout.main_fragment, container, false)\n+                .also { view ->\n+                    view.findViewById<Button>(R.id.buttonCount).setOnClickListener {\n+                        Realm.getDefaultInstance().use { realm ->\n+                            Log.e(\"--->\", \"---> ${Thread.currentThread().name} - count: ${realm.where(Doggo::class.java).count()}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjUzNzYzOnYy", "diffSide": "RIGHT", "path": "examples/settings.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1NzozM1rOHRSffw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1NzozM1rOHRSffw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MDgxNQ==", "bodyText": "Should be below the rootProject.name entry", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487890815", "createdAt": "2020-09-14T12:57:33Z", "author": {"login": "cmelchior"}, "path": "examples/settings.gradle", "diffHunk": "@@ -1,3 +1,4 @@\n+include ':coroutinesExample'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjUzOTczOnYy", "diffSide": "RIGHT", "path": "realm/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1ODowMlrOHRSgxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1ODowMlrOHRSgxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MTE0MQ==", "bodyText": "We should probably move this to the dependencies.list alongside the Kotlin version definition", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487891141", "createdAt": "2020-09-14T12:58:02Z", "author": {"login": "cmelchior"}, "path": "realm/build.gradle", "diffHunk": "@@ -2,6 +2,7 @@ buildscript {\n     def projectDependencies = new Properties()\n     projectDependencies.load(new FileInputStream(\"${rootDir}/../dependencies.list\"))\n     ext.kotlin_version = projectDependencies.get('KOTLIN')\n+    ext.coroutines_android_version = '1.3.9'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjU0MzUzOnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/build.gradle", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1ODo1NVrOHRSjKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMDoyNzozNlrOHT0TlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MTc1Mw==", "bodyText": "Is this really needed for the Kotlin Extensions? I would assume those would be relatively small? Or do the coroutine support really bring in that many things?", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487891753", "createdAt": "2020-09-14T12:58:55Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/build.gradle", "diffHunk": "@@ -26,6 +26,7 @@ android {\n         minSdkVersion rootProject.minSdkVersion\n         targetSdkVersion rootProject.compileSdkVersion\n         versionName version\n+        multiDexEnabled true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MjU5NQ==", "bodyText": "Also, how does Multidex work on libraries if you include it in an app that doesn't define Multidex?", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487892595", "createdAt": "2020-09-14T13:00:12Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/build.gradle", "diffHunk": "@@ -26,6 +26,7 @@ android {\n         minSdkVersion rootProject.minSdkVersion\n         targetSdkVersion rootProject.compileSdkVersion\n         versionName version\n+        multiDexEnabled true", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MTc1Mw=="}, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQ1NzE5NA==", "bodyText": "Maybe just needed for tests?", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r488457194", "createdAt": "2020-09-15T07:46:29Z", "author": {"login": "rorbech"}, "path": "realm/kotlin-extensions/build.gradle", "diffHunk": "@@ -26,6 +26,7 @@ android {\n         minSdkVersion rootProject.minSdkVersion\n         targetSdkVersion rootProject.compileSdkVersion\n         versionName version\n+        multiDexEnabled true", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MTc1Mw=="}, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUzODg5Nw==", "bodyText": "The extensions project won't compile unless added. Interestingly, the gradle dependency isn't needed though.\nAlso, I'm not sure this setting can be set only for tests.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r490538897", "createdAt": "2020-09-17T20:21:59Z", "author": {"login": "edualonso"}, "path": "realm/kotlin-extensions/build.gradle", "diffHunk": "@@ -26,6 +26,7 @@ android {\n         minSdkVersion rootProject.minSdkVersion\n         targetSdkVersion rootProject.compileSdkVersion\n         versionName version\n+        multiDexEnabled true", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MTc1Mw=="}, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU0MTk3Mw==", "bodyText": "Not sure about how a non-multidex app behaves with a multidex library, I need to test it.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r490541973", "createdAt": "2020-09-17T20:27:36Z", "author": {"login": "edualonso"}, "path": "realm/kotlin-extensions/build.gradle", "diffHunk": "@@ -26,6 +26,7 @@ android {\n         minSdkVersion rootProject.minSdkVersion\n         targetSdkVersion rootProject.compileSdkVersion\n         versionName version\n+        multiDexEnabled true", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MTc1Mw=="}, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjU2NDk2OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzowNDowMlrOHRSv_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzowNDowMlrOHRSv_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5NTAzNw==", "bodyText": "We should not use getDefaultInstance() but the Realm setup in the setUp method. Same in all the other tests.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487895037", "createdAt": "2020-09-14T13:04:02Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -0,0 +1,147 @@\n+package io.realm\n+\n+import io.realm.entities.SimpleClass\n+import io.realm.kotlin.executeTransactionAwait\n+import io.realm.kotlin.toFlow\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import kotlinx.coroutines.CoroutineScope\n+import kotlinx.coroutines.Dispatchers\n+import kotlinx.coroutines.cancel\n+import kotlinx.coroutines.flow.collect\n+import kotlinx.coroutines.flow.launchIn\n+import kotlinx.coroutines.flow.onCompletion\n+import kotlinx.coroutines.flow.onEach\n+import kotlinx.coroutines.launch\n+import kotlinx.coroutines.test.TestCoroutineDispatcher\n+import kotlinx.coroutines.test.TestCoroutineScope\n+import kotlinx.coroutines.test.runBlockingTest\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+import java.util.concurrent.CountDownLatch\n+import kotlin.test.*\n+\n+class CoroutineTests {\n+\n+    @Suppress(\"MemberVisibilityCanPrivate\")\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private lateinit var testDispatcher: TestCoroutineDispatcher\n+    private lateinit var testScope: TestCoroutineScope\n+    private lateinit var realm: Realm\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        realm = Realm.getInstance(configFactory.createConfiguration())\n+\n+        with(Realm.getDefaultInstance()) {\n+            executeTransaction { it.deleteAll() }\n+            close()\n+        }\n+\n+        testDispatcher = TestCoroutineDispatcher()\n+        testScope = TestCoroutineScope(testDispatcher)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun toFlow_emittedOnCollect() {\n+        Realm.getDefaultInstance().use { defaultRealm ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjU3MDIwOnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzowNToxMFrOHRSy9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzowNToxMFrOHRSy9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5NTc5Nw==", "bodyText": "use TestHelper.awaitOrThrow(countDownLatch) to avoid blocking CI for 1.5 hours if something in this test doesn't work.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487895797", "createdAt": "2020-09-14T13:05:10Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -0,0 +1,147 @@\n+package io.realm\n+\n+import io.realm.entities.SimpleClass\n+import io.realm.kotlin.executeTransactionAwait\n+import io.realm.kotlin.toFlow\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import kotlinx.coroutines.CoroutineScope\n+import kotlinx.coroutines.Dispatchers\n+import kotlinx.coroutines.cancel\n+import kotlinx.coroutines.flow.collect\n+import kotlinx.coroutines.flow.launchIn\n+import kotlinx.coroutines.flow.onCompletion\n+import kotlinx.coroutines.flow.onEach\n+import kotlinx.coroutines.launch\n+import kotlinx.coroutines.test.TestCoroutineDispatcher\n+import kotlinx.coroutines.test.TestCoroutineScope\n+import kotlinx.coroutines.test.runBlockingTest\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+import java.util.concurrent.CountDownLatch\n+import kotlin.test.*\n+\n+class CoroutineTests {\n+\n+    @Suppress(\"MemberVisibilityCanPrivate\")\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private lateinit var testDispatcher: TestCoroutineDispatcher\n+    private lateinit var testScope: TestCoroutineScope\n+    private lateinit var realm: Realm\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        realm = Realm.getInstance(configFactory.createConfiguration())\n+\n+        with(Realm.getDefaultInstance()) {\n+            executeTransaction { it.deleteAll() }\n+            close()\n+        }\n+\n+        testDispatcher = TestCoroutineDispatcher()\n+        testScope = TestCoroutineScope(testDispatcher)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun toFlow_emittedOnCollect() {\n+        Realm.getDefaultInstance().use { defaultRealm ->\n+            defaultRealm.executeTransactionAsync {\n+                it.createObject(SimpleClass::class.java).name = \"Foo\"\n+                it.createObject(SimpleClass::class.java).name = \"Bar\"\n+            }\n+        }\n+\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // TODO check this out for better testing: https://proandroiddev.com/from-rxjava-to-kotlin-flow-testing-42f1641d8433\n+        val scope = CoroutineScope(Dispatchers.Main)\n+        scope.launch {\n+            Realm.getDefaultInstance()\n+                    .where(SimpleClass::class.java)\n+                    .findAll()\n+                    .toFlow()\n+                    .onEach { flowResults ->\n+                        assertTrue(flowResults.isFrozen)\n+                        if (flowResults.size == 2) {\n+                            scope.cancel()\n+                        }\n+                    }.onCompletion {\n+                        countDownLatch.countDown()\n+                    }.launchIn(scope)\n+        }\n+        countDownLatch.await()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjU3NDk4OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzowNjoyMVrOHRS1vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzowNjoyMVrOHRS1vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5NjUxMA==", "bodyText": "Use realm.where<SimpleClass>(), this also applies to a lot of the other tests", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487896510", "createdAt": "2020-09-14T13:06:21Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -0,0 +1,147 @@\n+package io.realm\n+\n+import io.realm.entities.SimpleClass\n+import io.realm.kotlin.executeTransactionAwait\n+import io.realm.kotlin.toFlow\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import kotlinx.coroutines.CoroutineScope\n+import kotlinx.coroutines.Dispatchers\n+import kotlinx.coroutines.cancel\n+import kotlinx.coroutines.flow.collect\n+import kotlinx.coroutines.flow.launchIn\n+import kotlinx.coroutines.flow.onCompletion\n+import kotlinx.coroutines.flow.onEach\n+import kotlinx.coroutines.launch\n+import kotlinx.coroutines.test.TestCoroutineDispatcher\n+import kotlinx.coroutines.test.TestCoroutineScope\n+import kotlinx.coroutines.test.runBlockingTest\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+import java.util.concurrent.CountDownLatch\n+import kotlin.test.*\n+\n+class CoroutineTests {\n+\n+    @Suppress(\"MemberVisibilityCanPrivate\")\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private lateinit var testDispatcher: TestCoroutineDispatcher\n+    private lateinit var testScope: TestCoroutineScope\n+    private lateinit var realm: Realm\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        realm = Realm.getInstance(configFactory.createConfiguration())\n+\n+        with(Realm.getDefaultInstance()) {\n+            executeTransaction { it.deleteAll() }\n+            close()\n+        }\n+\n+        testDispatcher = TestCoroutineDispatcher()\n+        testScope = TestCoroutineScope(testDispatcher)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun toFlow_emittedOnCollect() {\n+        Realm.getDefaultInstance().use { defaultRealm ->\n+            defaultRealm.executeTransactionAsync {\n+                it.createObject(SimpleClass::class.java).name = \"Foo\"\n+                it.createObject(SimpleClass::class.java).name = \"Bar\"\n+            }\n+        }\n+\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // TODO check this out for better testing: https://proandroiddev.com/from-rxjava-to-kotlin-flow-testing-42f1641d8433\n+        val scope = CoroutineScope(Dispatchers.Main)\n+        scope.launch {\n+            Realm.getDefaultInstance()\n+                    .where(SimpleClass::class.java)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjU4MDI4OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzowNzozNlrOHRS41g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzowNzozNlrOHRS41g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5NzMwMg==", "bodyText": "Don't also call collect() if the intend is that it is toFlow() that throws.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487897302", "createdAt": "2020-09-14T13:07:36Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -0,0 +1,147 @@\n+package io.realm\n+\n+import io.realm.entities.SimpleClass\n+import io.realm.kotlin.executeTransactionAwait\n+import io.realm.kotlin.toFlow\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import kotlinx.coroutines.CoroutineScope\n+import kotlinx.coroutines.Dispatchers\n+import kotlinx.coroutines.cancel\n+import kotlinx.coroutines.flow.collect\n+import kotlinx.coroutines.flow.launchIn\n+import kotlinx.coroutines.flow.onCompletion\n+import kotlinx.coroutines.flow.onEach\n+import kotlinx.coroutines.launch\n+import kotlinx.coroutines.test.TestCoroutineDispatcher\n+import kotlinx.coroutines.test.TestCoroutineScope\n+import kotlinx.coroutines.test.runBlockingTest\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+import java.util.concurrent.CountDownLatch\n+import kotlin.test.*\n+\n+class CoroutineTests {\n+\n+    @Suppress(\"MemberVisibilityCanPrivate\")\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private lateinit var testDispatcher: TestCoroutineDispatcher\n+    private lateinit var testScope: TestCoroutineScope\n+    private lateinit var realm: Realm\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        realm = Realm.getInstance(configFactory.createConfiguration())\n+\n+        with(Realm.getDefaultInstance()) {\n+            executeTransaction { it.deleteAll() }\n+            close()\n+        }\n+\n+        testDispatcher = TestCoroutineDispatcher()\n+        testScope = TestCoroutineScope(testDispatcher)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun toFlow_emittedOnCollect() {\n+        Realm.getDefaultInstance().use { defaultRealm ->\n+            defaultRealm.executeTransactionAsync {\n+                it.createObject(SimpleClass::class.java).name = \"Foo\"\n+                it.createObject(SimpleClass::class.java).name = \"Bar\"\n+            }\n+        }\n+\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // TODO check this out for better testing: https://proandroiddev.com/from-rxjava-to-kotlin-flow-testing-42f1641d8433\n+        val scope = CoroutineScope(Dispatchers.Main)\n+        scope.launch {\n+            Realm.getDefaultInstance()\n+                    .where(SimpleClass::class.java)\n+                    .findAll()\n+                    .toFlow()\n+                    .onEach { flowResults ->\n+                        assertTrue(flowResults.isFrozen)\n+                        if (flowResults.size == 2) {\n+                            scope.cancel()\n+                        }\n+                    }.onCompletion {\n+                        countDownLatch.countDown()\n+                    }.launchIn(scope)\n+        }\n+        countDownLatch.await()\n+    }\n+\n+    @Test\n+    fun toFlow_throwsDueToThreadViolation() {\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // Get results from the test thread\n+        val findAll = Realm.getDefaultInstance()\n+                .where(SimpleClass::class.java)\n+                .findAll()\n+\n+        CoroutineScope(Dispatchers.Main).launch {\n+            assertFailsWith<IllegalStateException> {\n+                // Now we are on the main thread, which means crash\n+                findAll.toFlow().collect()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjU5NjM0OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxMTowN1rOHRTCkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxMTowN1rOHRTCkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5OTc5Mg==", "bodyText": "Use Realm.getInstance(realm.configuration) if you need to use a configuration from the existing Realm or save the configuration in an test class property so you can do Realm.getInstance(config)", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487899792", "createdAt": "2020-09-14T13:11:07Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -0,0 +1,147 @@\n+package io.realm\n+\n+import io.realm.entities.SimpleClass\n+import io.realm.kotlin.executeTransactionAwait\n+import io.realm.kotlin.toFlow\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import kotlinx.coroutines.CoroutineScope\n+import kotlinx.coroutines.Dispatchers\n+import kotlinx.coroutines.cancel\n+import kotlinx.coroutines.flow.collect\n+import kotlinx.coroutines.flow.launchIn\n+import kotlinx.coroutines.flow.onCompletion\n+import kotlinx.coroutines.flow.onEach\n+import kotlinx.coroutines.launch\n+import kotlinx.coroutines.test.TestCoroutineDispatcher\n+import kotlinx.coroutines.test.TestCoroutineScope\n+import kotlinx.coroutines.test.runBlockingTest\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+import java.util.concurrent.CountDownLatch\n+import kotlin.test.*\n+\n+class CoroutineTests {\n+\n+    @Suppress(\"MemberVisibilityCanPrivate\")\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private lateinit var testDispatcher: TestCoroutineDispatcher\n+    private lateinit var testScope: TestCoroutineScope\n+    private lateinit var realm: Realm\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        realm = Realm.getInstance(configFactory.createConfiguration())\n+\n+        with(Realm.getDefaultInstance()) {\n+            executeTransaction { it.deleteAll() }\n+            close()\n+        }\n+\n+        testDispatcher = TestCoroutineDispatcher()\n+        testScope = TestCoroutineScope(testDispatcher)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun toFlow_emittedOnCollect() {\n+        Realm.getDefaultInstance().use { defaultRealm ->\n+            defaultRealm.executeTransactionAsync {\n+                it.createObject(SimpleClass::class.java).name = \"Foo\"\n+                it.createObject(SimpleClass::class.java).name = \"Bar\"\n+            }\n+        }\n+\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // TODO check this out for better testing: https://proandroiddev.com/from-rxjava-to-kotlin-flow-testing-42f1641d8433\n+        val scope = CoroutineScope(Dispatchers.Main)\n+        scope.launch {\n+            Realm.getDefaultInstance()\n+                    .where(SimpleClass::class.java)\n+                    .findAll()\n+                    .toFlow()\n+                    .onEach { flowResults ->\n+                        assertTrue(flowResults.isFrozen)\n+                        if (flowResults.size == 2) {\n+                            scope.cancel()\n+                        }\n+                    }.onCompletion {\n+                        countDownLatch.countDown()\n+                    }.launchIn(scope)\n+        }\n+        countDownLatch.await()\n+    }\n+\n+    @Test\n+    fun toFlow_throwsDueToThreadViolation() {\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // Get results from the test thread\n+        val findAll = Realm.getDefaultInstance()\n+                .where(SimpleClass::class.java)\n+                .findAll()\n+\n+        CoroutineScope(Dispatchers.Main).launch {\n+            assertFailsWith<IllegalStateException> {\n+                // Now we are on the main thread, which means crash\n+                findAll.toFlow().collect()\n+                fail(\"toFlow() must be called from the thread that retrieved the results!\")\n+            }\n+            countDownLatch.countDown()\n+        }\n+        countDownLatch.await()\n+    }\n+\n+    @Test\n+    fun executeTransactionAwait() {\n+        testScope.runBlockingTest {\n+            Realm.getDefaultInstance().use { defaultRealm ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjYwMTU4OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxMjoxNlrOHRTFrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxMjoxNlrOHRTFrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMDU4OA==", "bodyText": "IMO this assert should be right after you called defaultRealm.executeTransactionAwait to make sure that the result is available immediately.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487900588", "createdAt": "2020-09-14T13:12:16Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -0,0 +1,147 @@\n+package io.realm\n+\n+import io.realm.entities.SimpleClass\n+import io.realm.kotlin.executeTransactionAwait\n+import io.realm.kotlin.toFlow\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import kotlinx.coroutines.CoroutineScope\n+import kotlinx.coroutines.Dispatchers\n+import kotlinx.coroutines.cancel\n+import kotlinx.coroutines.flow.collect\n+import kotlinx.coroutines.flow.launchIn\n+import kotlinx.coroutines.flow.onCompletion\n+import kotlinx.coroutines.flow.onEach\n+import kotlinx.coroutines.launch\n+import kotlinx.coroutines.test.TestCoroutineDispatcher\n+import kotlinx.coroutines.test.TestCoroutineScope\n+import kotlinx.coroutines.test.runBlockingTest\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+import java.util.concurrent.CountDownLatch\n+import kotlin.test.*\n+\n+class CoroutineTests {\n+\n+    @Suppress(\"MemberVisibilityCanPrivate\")\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private lateinit var testDispatcher: TestCoroutineDispatcher\n+    private lateinit var testScope: TestCoroutineScope\n+    private lateinit var realm: Realm\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        realm = Realm.getInstance(configFactory.createConfiguration())\n+\n+        with(Realm.getDefaultInstance()) {\n+            executeTransaction { it.deleteAll() }\n+            close()\n+        }\n+\n+        testDispatcher = TestCoroutineDispatcher()\n+        testScope = TestCoroutineScope(testDispatcher)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun toFlow_emittedOnCollect() {\n+        Realm.getDefaultInstance().use { defaultRealm ->\n+            defaultRealm.executeTransactionAsync {\n+                it.createObject(SimpleClass::class.java).name = \"Foo\"\n+                it.createObject(SimpleClass::class.java).name = \"Bar\"\n+            }\n+        }\n+\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // TODO check this out for better testing: https://proandroiddev.com/from-rxjava-to-kotlin-flow-testing-42f1641d8433\n+        val scope = CoroutineScope(Dispatchers.Main)\n+        scope.launch {\n+            Realm.getDefaultInstance()\n+                    .where(SimpleClass::class.java)\n+                    .findAll()\n+                    .toFlow()\n+                    .onEach { flowResults ->\n+                        assertTrue(flowResults.isFrozen)\n+                        if (flowResults.size == 2) {\n+                            scope.cancel()\n+                        }\n+                    }.onCompletion {\n+                        countDownLatch.countDown()\n+                    }.launchIn(scope)\n+        }\n+        countDownLatch.await()\n+    }\n+\n+    @Test\n+    fun toFlow_throwsDueToThreadViolation() {\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // Get results from the test thread\n+        val findAll = Realm.getDefaultInstance()\n+                .where(SimpleClass::class.java)\n+                .findAll()\n+\n+        CoroutineScope(Dispatchers.Main).launch {\n+            assertFailsWith<IllegalStateException> {\n+                // Now we are on the main thread, which means crash\n+                findAll.toFlow().collect()\n+                fail(\"toFlow() must be called from the thread that retrieved the results!\")\n+            }\n+            countDownLatch.countDown()\n+        }\n+        countDownLatch.await()\n+    }\n+\n+    @Test\n+    fun executeTransactionAwait() {\n+        testScope.runBlockingTest {\n+            Realm.getDefaultInstance().use { defaultRealm ->\n+                assertEquals(0, defaultRealm.where(SimpleClass::class.java).findAll().size)\n+\n+                defaultRealm.executeTransactionAwait(testDispatcher) { transactionRealm ->\n+                    val simpleObject = SimpleClass().apply { name = \"simpleName\" }\n+                    transactionRealm.insert(simpleObject)\n+                }\n+            }\n+        }\n+        assertEquals(1, Realm.getDefaultInstance().where(SimpleClass::class.java).findAll().size)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjYwMzIyOnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxMjo0M1rOHRTGvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxMjo0M1rOHRTGvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMDg2MA==", "bodyText": "Use TestHelper.awaitOrThrow", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487900860", "createdAt": "2020-09-14T13:12:43Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -0,0 +1,147 @@\n+package io.realm\n+\n+import io.realm.entities.SimpleClass\n+import io.realm.kotlin.executeTransactionAwait\n+import io.realm.kotlin.toFlow\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import kotlinx.coroutines.CoroutineScope\n+import kotlinx.coroutines.Dispatchers\n+import kotlinx.coroutines.cancel\n+import kotlinx.coroutines.flow.collect\n+import kotlinx.coroutines.flow.launchIn\n+import kotlinx.coroutines.flow.onCompletion\n+import kotlinx.coroutines.flow.onEach\n+import kotlinx.coroutines.launch\n+import kotlinx.coroutines.test.TestCoroutineDispatcher\n+import kotlinx.coroutines.test.TestCoroutineScope\n+import kotlinx.coroutines.test.runBlockingTest\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+import java.util.concurrent.CountDownLatch\n+import kotlin.test.*\n+\n+class CoroutineTests {\n+\n+    @Suppress(\"MemberVisibilityCanPrivate\")\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private lateinit var testDispatcher: TestCoroutineDispatcher\n+    private lateinit var testScope: TestCoroutineScope\n+    private lateinit var realm: Realm\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Before\n+    fun setUp() {\n+        realm = Realm.getInstance(configFactory.createConfiguration())\n+\n+        with(Realm.getDefaultInstance()) {\n+            executeTransaction { it.deleteAll() }\n+            close()\n+        }\n+\n+        testDispatcher = TestCoroutineDispatcher()\n+        testScope = TestCoroutineScope(testDispatcher)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun toFlow_emittedOnCollect() {\n+        Realm.getDefaultInstance().use { defaultRealm ->\n+            defaultRealm.executeTransactionAsync {\n+                it.createObject(SimpleClass::class.java).name = \"Foo\"\n+                it.createObject(SimpleClass::class.java).name = \"Bar\"\n+            }\n+        }\n+\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // TODO check this out for better testing: https://proandroiddev.com/from-rxjava-to-kotlin-flow-testing-42f1641d8433\n+        val scope = CoroutineScope(Dispatchers.Main)\n+        scope.launch {\n+            Realm.getDefaultInstance()\n+                    .where(SimpleClass::class.java)\n+                    .findAll()\n+                    .toFlow()\n+                    .onEach { flowResults ->\n+                        assertTrue(flowResults.isFrozen)\n+                        if (flowResults.size == 2) {\n+                            scope.cancel()\n+                        }\n+                    }.onCompletion {\n+                        countDownLatch.countDown()\n+                    }.launchIn(scope)\n+        }\n+        countDownLatch.await()\n+    }\n+\n+    @Test\n+    fun toFlow_throwsDueToThreadViolation() {\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // Get results from the test thread\n+        val findAll = Realm.getDefaultInstance()\n+                .where(SimpleClass::class.java)\n+                .findAll()\n+\n+        CoroutineScope(Dispatchers.Main).launch {\n+            assertFailsWith<IllegalStateException> {\n+                // Now we are on the main thread, which means crash\n+                findAll.toFlow().collect()\n+                fail(\"toFlow() must be called from the thread that retrieved the results!\")\n+            }\n+            countDownLatch.countDown()\n+        }\n+        countDownLatch.await()\n+    }\n+\n+    @Test\n+    fun executeTransactionAwait() {\n+        testScope.runBlockingTest {\n+            Realm.getDefaultInstance().use { defaultRealm ->\n+                assertEquals(0, defaultRealm.where(SimpleClass::class.java).findAll().size)\n+\n+                defaultRealm.executeTransactionAwait(testDispatcher) { transactionRealm ->\n+                    val simpleObject = SimpleClass().apply { name = \"simpleName\" }\n+                    transactionRealm.insert(simpleObject)\n+                }\n+            }\n+        }\n+        assertEquals(1, Realm.getDefaultInstance().where(SimpleClass::class.java).findAll().size)\n+    }\n+\n+    @Test\n+    fun executeTransactionAwait_throwsDueToThreadViolation() {\n+        // Just to prevent the test to end prematurely\n+        val countDownLatch = CountDownLatch(1)\n+\n+        var exception: IllegalStateException? = null\n+\n+        // Obtain a Realm from a thread other than the one used in the coroutine context\n+        val defaultRealm = Realm.getDefaultInstance()\n+\n+        // It will crash so long we aren't using Dispatchers.Unconfined\n+        CoroutineScope(Dispatchers.IO).launch {\n+            assertFailsWith<IllegalStateException> {\n+                defaultRealm.where(SimpleClass::class.java).findAll()\n+                countDownLatch.countDown()\n+            }.let {\n+                exception = it\n+            }\n+        }\n+        countDownLatch.await()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjYwNTA0OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/KotlinRealmTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxMzowOVrOHRTH1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxMzowOVrOHRTH1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMTE0MQ==", "bodyText": "Don't use getDefaultInstance()", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487901141", "createdAt": "2020-09-14T13:13:09Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/KotlinRealmTests.kt", "diffHunk": "@@ -5,31 +5,42 @@ import io.realm.entities.PrimaryKeyClass\n import io.realm.entities.SimpleClass\n import io.realm.kotlin.createObject\n import io.realm.kotlin.where\n+import io.realm.rule.BlockingLooperThread\n import io.realm.rule.TestRealmConfigurationFactory\n import org.junit.After\n-import org.junit.Assert.assertEquals\n import org.junit.Before\n import org.junit.Rule\n import org.junit.Test\n import org.junit.runner.RunWith\n+import kotlin.test.assertEquals\n \n @Suppress(\"FunctionName\")\n @RunWith(AndroidJUnit4::class)\n class KotlinRealmTests {\n \n     @Suppress(\"MemberVisibilityCanPrivate\")\n-    @Rule @JvmField val configFactory = TestRealmConfigurationFactory()\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n \n     private lateinit var realm: Realm\n \n+    private val looperThread = BlockingLooperThread()\n+\n     @Before\n     fun setUp() {\n         realm = Realm.getInstance(configFactory.createConfiguration())\n     }\n \n     @After\n     fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }\n         realm.close()\n+\n+        with(Realm.getDefaultInstance()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjYwOTMwOnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/rule/BlockingLooperThread.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxNDoxM1rOHRTKcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxNDoxM1rOHRTKcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMTgwOA==", "bodyText": "We should avoid copying files between realm-library and kotlin-extensions. In the past we used a shared sourceset to keep these files in. Doesn't that work?", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487901808", "createdAt": "2020-09-14T13:14:13Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/rule/BlockingLooperThread.kt", "diffHunk": "@@ -0,0 +1,366 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.rule\n+\n+import android.os.Handler\n+import android.os.Looper\n+import io.realm.TestHelper\n+import io.realm.TestHelper.LooperTest\n+import io.realm.internal.android.AndroidCapabilities\n+import org.junit.runners.model.MultipleFailureException\n+import java.io.Closeable\n+import java.io.PrintStream\n+import java.util.*\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.ExecutorService\n+import java.util.concurrent.Executors\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.locks.ReentrantLock\n+import kotlin.collections.ArrayList\n+\n+/**\n+ * Helper class that makes it easier to run a piece of code inside a Looper Thread. This is done by\n+ * calling the `run` method. This method will block until the Looper either completes or throws\n+ * an exception.\n+ *\n+ * Usage:\n+ * ```\n+ * val lopperThread = LooperThreadTest()\n+ *\n+ * @Before\n+ * fun setUp() {\n+ *     // Runs before test\n+ * }\n+ *\n+ * @After\n+ * fun tearDown() {\n+ *     // Runs after test completed or failed\n+ * }\n+ *\n+ * @Test\n+ * fun myTest() = looperThread.run {\n+ *     // test code\n+ * }\n+ * ```\n+ */\n+class BlockingLooperThread {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjYxMjA2OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmExtensions.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxNDo1MlrOHRTMHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxNDo1MlrOHRTMHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjIzNg==", "bodyText": "Missing?", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487902236", "createdAt": "2020-09-14T13:14:52Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmExtensions.kt", "diffHunk": "@@ -91,15 +100,37 @@ inline fun <reified T : RealmModel> Realm.createEmbeddedObject(parentObject: Rea\n     return this.createEmbeddedObject(T::class.java, parentObject, parentProperty)\n }\n \n+/**\n+ * FIXME", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjYxOTkwOnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmExtensions.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxNjozNlrOHRTQ3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxNjozNlrOHRTQ3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMzQ1Mw==", "bodyText": "Delete this?", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487903453", "createdAt": "2020-09-14T13:16:36Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmExtensions.kt", "diffHunk": "@@ -91,15 +100,37 @@ inline fun <reified T : RealmModel> Realm.createEmbeddedObject(parentObject: Rea\n     return this.createEmbeddedObject(T::class.java, parentObject, parentProperty)\n }\n \n+/**\n+ * FIXME\n+ *\n+ * @param context FIXME\n+ * @param transaction FIXME\n+ */\n+suspend fun Realm.executeTransactionAwait(\n+        context: CoroutineContext = Realm.asyncTaskExecutor.asCoroutineDispatcher(),\n+        transaction: (realm: Realm) -> Unit\n+) {\n+    // Default to our own thread pool executor (as dispatcher)\n+    withContext(context) {\n+        // Get a new coroutine-confined Realm instance from the original Realm's configuration\n+        Realm.getInstance(configuration).use { coroutineRealm ->\n+            coroutineRealm.executeTransaction(transaction)\n+        }\n+    }\n+\n+    // force refresh because we risk fetching stale data from other realms\n+    refresh()\n+}\n+\n /**\n TODO: Figure out if we should include this is or not. Using this makes it possible to do\n \n inline fun <T> Realm.callTransaction(crossinline action: Realm.() -> T): T {\n-    val ref = AtomicReference<T>()\n-    executeTransaction {\n-        ref.set(action(it))\n-    }\n-    return ref.get()\n+val ref = AtomicReference<T>()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjYyMTcwOnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmResultsExtensions.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxNjo1OFrOHRTR8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxNjo1OFrOHRTR8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMzcyOA==", "bodyText": "Remove this?", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487903728", "createdAt": "2020-09-14T13:16:58Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmResultsExtensions.kt", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.kotlin\n+\n+import io.realm.Realm\n+import io.realm.RealmChangeListener\n+import io.realm.RealmModel\n+import io.realm.RealmResults\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+@Beta\n+fun <T : RealmModel> RealmResults<T>.toFlow(): Flow<RealmResults<T>> {\n+    // Return \"as is\" if frozen, there will be no listening for changes\n+    if (realm.isFrozen) {\n+        flowOf(this)\n+    }\n+\n+    val config = realm.configuration\n+\n+    return callbackFlow {\n+        // Emit current (frozen) value immediately\n+        offer(freeze())\n+\n+        val results = this@toFlow\n+\n+        // Do nothing if the results are invalid\n+        if (!results.isValid) return@callbackFlow\n+\n+        // Get instance to ensure the Realm is open for as long we are listening\n+        val flowRealm = Realm.getInstance(config)\n+        val listener = RealmChangeListener<RealmResults<T>> { listenerResults ->\n+            offer(listenerResults.freeze())\n+        }\n+\n+        results.addChangeListener(listener)\n+\n+        awaitClose {\n+            // Remove listener and cleanup\n+            if (!flowRealm.isClosed) {\n+                results.removeChangeListener(listener)\n+                flowRealm.close()\n+            }\n+        }\n+    }\n+}\n+\n+/*\n+ *\n+ * ALTERNATIVE IMPLEMENTATION USING flow INSTEAD OF callbackFlow\n+ *\n+ *\n+\n+@Beta\n+fun <T : RealmModel> RealmResults<T>.toFlowNew(): Flow<RealmResults<T>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjYyNjQ2OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/java/io/realm/BaseRealm.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxODowNFrOHRTUtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzowMTo1M1rOHVO7KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNDQzNg==", "bodyText": "Should we have two thread pools? One for writes and one for Reads? The pool for writes just need 1 thread since you cannot parallelize these anyway.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r487904436", "createdAt": "2020-09-14T13:18:04Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/BaseRealm.java", "diffHunk": "@@ -73,8 +73,9 @@\n \n     static volatile Context applicationContext;\n \n+    // FIXME: document this\n     // Thread pool for all async operations (Query & transaction)\n-    static final RealmThreadPoolExecutor asyncTaskExecutor = RealmThreadPoolExecutor.newDefaultExecutor();\n+    public static final RealmThreadPoolExecutor asyncTaskExecutor = RealmThreadPoolExecutor.newDefaultExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyNjY2NQ==", "bodyText": "I've ended up adding one public thread pool with one thread which is used only for executeTransactionAwait. I don't think it's needed to add an additional one for reads as flows need to be collected on the same thread the query was performed.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r492026665", "createdAt": "2020-09-21T13:01:53Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/main/java/io/realm/BaseRealm.java", "diffHunk": "@@ -73,8 +73,9 @@\n \n     static volatile Context applicationContext;\n \n+    // FIXME: document this\n     // Thread pool for all async operations (Query & transaction)\n-    static final RealmThreadPoolExecutor asyncTaskExecutor = RealmThreadPoolExecutor.newDefaultExecutor();\n+    public static final RealmThreadPoolExecutor asyncTaskExecutor = RealmThreadPoolExecutor.newDefaultExecutor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNDQzNg=="}, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NjIzOTMyOnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/main/AndroidManifest.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNzo0NjoxMVrOHR1DMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNzo0NjoxMVrOHR1DMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQ1NzAwOQ==", "bodyText": "If this is only needed for test you should define it in the test manifest.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r488457009", "createdAt": "2020-09-15T07:46:11Z", "author": {"login": "rorbech"}, "path": "realm/kotlin-extensions/src/main/AndroidManifest.xml", "diffHunk": "@@ -1,2 +1,5 @@\n <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n-          package=\"io.realm.kotlin\"/>\n+    package=\"io.realm.kotlin\">\n+\n+    <application android:name=\"androidx.multidex.MultiDexApplication\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NjI0MzM3OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNzo0NzoyMFrOHR1FzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNzo0NzoyMFrOHR1FzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQ1NzY3Ng==", "bodyText": "Could this be limited to androidTestImplementation?", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r488457676", "createdAt": "2020-09-15T07:47:20Z", "author": {"login": "rorbech"}, "path": "realm/kotlin-extensions/build.gradle", "diffHunk": "@@ -75,7 +81,15 @@ android {\n \n dependencies {\n     implementation project(':realm-library')\n+\n     implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\n+    implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutines_android_version\"\n+    implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:$coroutines_android_version\"\n+    androidTestImplementation \"org.jetbrains.kotlinx:kotlinx-coroutines-test:$coroutines_android_version\"\n+    androidTestImplementation \"org.jetbrains.kotlin:kotlin-test:$kotlin_version\"\n+\n+    implementation \"androidx.multidex:multidex:2.0.0\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1418317ea3179c9918e002ec697c0b213ab9d00"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Mjg1NTkwOnYy", "diffSide": "RIGHT", "path": "examples/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTo0MDowMFrOHVyHHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTo0MDowMFrOHVyHHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMzE2Nw==", "bodyText": "This should use the version defined in dependencies.list", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r492603167", "createdAt": "2020-09-22T09:40:00Z", "author": {"login": "cmelchior"}, "path": "examples/build.gradle", "diffHunk": "@@ -29,6 +29,9 @@ allprojects {\n     }\n \n     buildscript {\n+        ext {\n+            kotlin_version = '1.3.72'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed2c6cea6cd6cf5acfdf2ea44367c4343fd93270"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Mjg1NzY5OnYy", "diffSide": "RIGHT", "path": "examples/coroutinesExample/.gitignore", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTo0MDoyNlrOHVyIJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTo0MDoyNlrOHVyIJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMzQyOQ==", "bodyText": "This one should already be covered by the .gitignore at the root folder", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r492603429", "createdAt": "2020-09-22T09:40:26Z", "author": {"login": "cmelchior"}, "path": "examples/coroutinesExample/.gitignore", "diffHunk": "@@ -0,0 +1 @@\n+/build", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed2c6cea6cd6cf5acfdf2ea44367c4343fd93270"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODc0MzA0OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjoyOToxMVrOHWqs8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjoyOToxMVrOHWqs8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzMDM1NQ==", "bodyText": "No need to delete data. When using the configFactory we create a separate folder for each test, so data between tests shouldn't interact.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r493530355", "createdAt": "2020-09-23T12:29:11Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -0,0 +1,510 @@\n+package io.realm\n+\n+import io.realm.entities.AllTypes\n+import io.realm.entities.Dog\n+import io.realm.entities.SimpleClass\n+import io.realm.kotlin.*\n+import io.realm.rule.TestRealmConfigurationFactory\n+import kotlinx.coroutines.*\n+import kotlinx.coroutines.flow.*\n+import kotlinx.coroutines.test.TestCoroutineDispatcher\n+import kotlinx.coroutines.test.TestCoroutineScope\n+import kotlinx.coroutines.test.runBlockingTest\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+import java.util.concurrent.CountDownLatch\n+import kotlin.test.*\n+\n+@ExperimentalCoroutinesApi\n+class CoroutineTests {\n+\n+    @Suppress(\"MemberVisibilityCanPrivate\")\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private lateinit var configuration: RealmConfiguration\n+    private lateinit var testDispatcher: TestCoroutineDispatcher\n+    private lateinit var testScope: TestCoroutineScope\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        testDispatcher = TestCoroutineDispatcher()\n+        testScope = TestCoroutineScope(testDispatcher)\n+        configuration = configFactory.createConfiguration()\n+        realm = Realm.getInstance(configuration)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e454f5fb8506704a36e833345a702fc012f7f37d"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODc5NDY2OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjozNzo1N1rOHWrMlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNjowMjowOVrOHW1vDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzODQ1NQ==", "bodyText": "Why do you need this when you already start inside the scope?", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r493538455", "createdAt": "2020-09-23T12:37:57Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -0,0 +1,510 @@\n+package io.realm\n+\n+import io.realm.entities.AllTypes\n+import io.realm.entities.Dog\n+import io.realm.entities.SimpleClass\n+import io.realm.kotlin.*\n+import io.realm.rule.TestRealmConfigurationFactory\n+import kotlinx.coroutines.*\n+import kotlinx.coroutines.flow.*\n+import kotlinx.coroutines.test.TestCoroutineDispatcher\n+import kotlinx.coroutines.test.TestCoroutineScope\n+import kotlinx.coroutines.test.runBlockingTest\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+import java.util.concurrent.CountDownLatch\n+import kotlin.test.*\n+\n+@ExperimentalCoroutinesApi\n+class CoroutineTests {\n+\n+    @Suppress(\"MemberVisibilityCanPrivate\")\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private lateinit var configuration: RealmConfiguration\n+    private lateinit var testDispatcher: TestCoroutineDispatcher\n+    private lateinit var testScope: TestCoroutineScope\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        testDispatcher = TestCoroutineDispatcher()\n+        testScope = TestCoroutineScope(testDispatcher)\n+        configuration = configFactory.createConfiguration()\n+        realm = Realm.getInstance(configuration)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun toFlow_emittedOnCollect() {\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // TODO check this out for better testing: https://proandroiddev.com/from-rxjava-to-kotlin-flow-testing-42f1641d8433\n+        val context = Dispatchers.Main\n+        val scope = CoroutineScope(context)\n+\n+        scope.launch {\n+            val realmInstance = Realm.getInstance(configuration)\n+\n+            realmInstance.where<SimpleClass>()\n+                    .findAllAsync()\n+                    .toFlow()\n+                    .flowOn(context)\n+                    .onEach { flowResults ->\n+                        assertTrue(flowResults.isFrozen)\n+                        assertEquals(0, flowResults.size)\n+                        scope.cancel(\"Cancelling scope...\")\n+                    }.onCompletion {\n+                        realmInstance.close()\n+                        countDownLatch.countDown()\n+                    }.launchIn(scope)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e454f5fb8506704a36e833345a702fc012f7f37d"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY3NTM4MA==", "bodyText": "Maybe this one is not the best way to start collecting results from a flow, but launchIn is shorthand for scope.launch { flow.collect() }. The advantage is that it returns a Job, so that may come in handy for other purposes. But yeah, in this case I'm not doing anything with the job, so I might as well use collect instead.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r493675380", "createdAt": "2020-09-23T15:13:45Z", "author": {"login": "edualonso"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -0,0 +1,510 @@\n+package io.realm\n+\n+import io.realm.entities.AllTypes\n+import io.realm.entities.Dog\n+import io.realm.entities.SimpleClass\n+import io.realm.kotlin.*\n+import io.realm.rule.TestRealmConfigurationFactory\n+import kotlinx.coroutines.*\n+import kotlinx.coroutines.flow.*\n+import kotlinx.coroutines.test.TestCoroutineDispatcher\n+import kotlinx.coroutines.test.TestCoroutineScope\n+import kotlinx.coroutines.test.runBlockingTest\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+import java.util.concurrent.CountDownLatch\n+import kotlin.test.*\n+\n+@ExperimentalCoroutinesApi\n+class CoroutineTests {\n+\n+    @Suppress(\"MemberVisibilityCanPrivate\")\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private lateinit var configuration: RealmConfiguration\n+    private lateinit var testDispatcher: TestCoroutineDispatcher\n+    private lateinit var testScope: TestCoroutineScope\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        testDispatcher = TestCoroutineDispatcher()\n+        testScope = TestCoroutineScope(testDispatcher)\n+        configuration = configFactory.createConfiguration()\n+        realm = Realm.getInstance(configuration)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun toFlow_emittedOnCollect() {\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // TODO check this out for better testing: https://proandroiddev.com/from-rxjava-to-kotlin-flow-testing-42f1641d8433\n+        val context = Dispatchers.Main\n+        val scope = CoroutineScope(context)\n+\n+        scope.launch {\n+            val realmInstance = Realm.getInstance(configuration)\n+\n+            realmInstance.where<SimpleClass>()\n+                    .findAllAsync()\n+                    .toFlow()\n+                    .flowOn(context)\n+                    .onEach { flowResults ->\n+                        assertTrue(flowResults.isFrozen)\n+                        assertEquals(0, flowResults.size)\n+                        scope.cancel(\"Cancelling scope...\")\n+                    }.onCompletion {\n+                        realmInstance.close()\n+                        countDownLatch.countDown()\n+                    }.launchIn(scope)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzODQ1NQ=="}, "originalCommit": {"oid": "e454f5fb8506704a36e833345a702fc012f7f37d"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY3NTg3Mw==", "bodyText": "There is a difference though, which is launchIn is not a coroutine and collect is.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r493675873", "createdAt": "2020-09-23T15:14:23Z", "author": {"login": "edualonso"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -0,0 +1,510 @@\n+package io.realm\n+\n+import io.realm.entities.AllTypes\n+import io.realm.entities.Dog\n+import io.realm.entities.SimpleClass\n+import io.realm.kotlin.*\n+import io.realm.rule.TestRealmConfigurationFactory\n+import kotlinx.coroutines.*\n+import kotlinx.coroutines.flow.*\n+import kotlinx.coroutines.test.TestCoroutineDispatcher\n+import kotlinx.coroutines.test.TestCoroutineScope\n+import kotlinx.coroutines.test.runBlockingTest\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+import java.util.concurrent.CountDownLatch\n+import kotlin.test.*\n+\n+@ExperimentalCoroutinesApi\n+class CoroutineTests {\n+\n+    @Suppress(\"MemberVisibilityCanPrivate\")\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private lateinit var configuration: RealmConfiguration\n+    private lateinit var testDispatcher: TestCoroutineDispatcher\n+    private lateinit var testScope: TestCoroutineScope\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        testDispatcher = TestCoroutineDispatcher()\n+        testScope = TestCoroutineScope(testDispatcher)\n+        configuration = configFactory.createConfiguration()\n+        realm = Realm.getInstance(configuration)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun toFlow_emittedOnCollect() {\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // TODO check this out for better testing: https://proandroiddev.com/from-rxjava-to-kotlin-flow-testing-42f1641d8433\n+        val context = Dispatchers.Main\n+        val scope = CoroutineScope(context)\n+\n+        scope.launch {\n+            val realmInstance = Realm.getInstance(configuration)\n+\n+            realmInstance.where<SimpleClass>()\n+                    .findAllAsync()\n+                    .toFlow()\n+                    .flowOn(context)\n+                    .onEach { flowResults ->\n+                        assertTrue(flowResults.isFrozen)\n+                        assertEquals(0, flowResults.size)\n+                        scope.cancel(\"Cancelling scope...\")\n+                    }.onCompletion {\n+                        realmInstance.close()\n+                        countDownLatch.countDown()\n+                    }.launchIn(scope)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzODQ1NQ=="}, "originalCommit": {"oid": "e454f5fb8506704a36e833345a702fc012f7f37d"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcxMTExNg==", "bodyText": "This actually means that if we call collect and the flow isn't cancelled somehow, it will never end and will hog the thread on which it's running, which isn't a problem here, but it is for instance in toFlow_resultsCancelBeforeCollectActualResults since we are doing things within the coroutine scope after calling collect.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r493711116", "createdAt": "2020-09-23T16:02:09Z", "author": {"login": "edualonso"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -0,0 +1,510 @@\n+package io.realm\n+\n+import io.realm.entities.AllTypes\n+import io.realm.entities.Dog\n+import io.realm.entities.SimpleClass\n+import io.realm.kotlin.*\n+import io.realm.rule.TestRealmConfigurationFactory\n+import kotlinx.coroutines.*\n+import kotlinx.coroutines.flow.*\n+import kotlinx.coroutines.test.TestCoroutineDispatcher\n+import kotlinx.coroutines.test.TestCoroutineScope\n+import kotlinx.coroutines.test.runBlockingTest\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+import java.util.concurrent.CountDownLatch\n+import kotlin.test.*\n+\n+@ExperimentalCoroutinesApi\n+class CoroutineTests {\n+\n+    @Suppress(\"MemberVisibilityCanPrivate\")\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private lateinit var configuration: RealmConfiguration\n+    private lateinit var testDispatcher: TestCoroutineDispatcher\n+    private lateinit var testScope: TestCoroutineScope\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        testDispatcher = TestCoroutineDispatcher()\n+        testScope = TestCoroutineScope(testDispatcher)\n+        configuration = configFactory.createConfiguration()\n+        realm = Realm.getInstance(configuration)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun toFlow_emittedOnCollect() {\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // TODO check this out for better testing: https://proandroiddev.com/from-rxjava-to-kotlin-flow-testing-42f1641d8433\n+        val context = Dispatchers.Main\n+        val scope = CoroutineScope(context)\n+\n+        scope.launch {\n+            val realmInstance = Realm.getInstance(configuration)\n+\n+            realmInstance.where<SimpleClass>()\n+                    .findAllAsync()\n+                    .toFlow()\n+                    .flowOn(context)\n+                    .onEach { flowResults ->\n+                        assertTrue(flowResults.isFrozen)\n+                        assertEquals(0, flowResults.size)\n+                        scope.cancel(\"Cancelling scope...\")\n+                    }.onCompletion {\n+                        realmInstance.close()\n+                        countDownLatch.countDown()\n+                    }.launchIn(scope)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzODQ1NQ=="}, "originalCommit": {"oid": "e454f5fb8506704a36e833345a702fc012f7f37d"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODc5ODY4OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjozODo0MFrOHWrPPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNToxNTo1OVrOHWzqgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzOTEzNA==", "bodyText": "Is this needed to trigger onCompletion?", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r493539134", "createdAt": "2020-09-23T12:38:40Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -0,0 +1,510 @@\n+package io.realm\n+\n+import io.realm.entities.AllTypes\n+import io.realm.entities.Dog\n+import io.realm.entities.SimpleClass\n+import io.realm.kotlin.*\n+import io.realm.rule.TestRealmConfigurationFactory\n+import kotlinx.coroutines.*\n+import kotlinx.coroutines.flow.*\n+import kotlinx.coroutines.test.TestCoroutineDispatcher\n+import kotlinx.coroutines.test.TestCoroutineScope\n+import kotlinx.coroutines.test.runBlockingTest\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+import java.util.concurrent.CountDownLatch\n+import kotlin.test.*\n+\n+@ExperimentalCoroutinesApi\n+class CoroutineTests {\n+\n+    @Suppress(\"MemberVisibilityCanPrivate\")\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private lateinit var configuration: RealmConfiguration\n+    private lateinit var testDispatcher: TestCoroutineDispatcher\n+    private lateinit var testScope: TestCoroutineScope\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        testDispatcher = TestCoroutineDispatcher()\n+        testScope = TestCoroutineScope(testDispatcher)\n+        configuration = configFactory.createConfiguration()\n+        realm = Realm.getInstance(configuration)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun toFlow_emittedOnCollect() {\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // TODO check this out for better testing: https://proandroiddev.com/from-rxjava-to-kotlin-flow-testing-42f1641d8433\n+        val context = Dispatchers.Main\n+        val scope = CoroutineScope(context)\n+\n+        scope.launch {\n+            val realmInstance = Realm.getInstance(configuration)\n+\n+            realmInstance.where<SimpleClass>()\n+                    .findAllAsync()\n+                    .toFlow()\n+                    .flowOn(context)\n+                    .onEach { flowResults ->\n+                        assertTrue(flowResults.isFrozen)\n+                        assertEquals(0, flowResults.size)\n+                        scope.cancel(\"Cancelling scope...\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e454f5fb8506704a36e833345a702fc012f7f37d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY3NzE4NA==", "bodyText": "Yep, calling cancel on a scope will trigger onComplete, otherwise the flow will never end.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r493677184", "createdAt": "2020-09-23T15:15:59Z", "author": {"login": "edualonso"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -0,0 +1,510 @@\n+package io.realm\n+\n+import io.realm.entities.AllTypes\n+import io.realm.entities.Dog\n+import io.realm.entities.SimpleClass\n+import io.realm.kotlin.*\n+import io.realm.rule.TestRealmConfigurationFactory\n+import kotlinx.coroutines.*\n+import kotlinx.coroutines.flow.*\n+import kotlinx.coroutines.test.TestCoroutineDispatcher\n+import kotlinx.coroutines.test.TestCoroutineScope\n+import kotlinx.coroutines.test.runBlockingTest\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+import java.util.concurrent.CountDownLatch\n+import kotlin.test.*\n+\n+@ExperimentalCoroutinesApi\n+class CoroutineTests {\n+\n+    @Suppress(\"MemberVisibilityCanPrivate\")\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private lateinit var configuration: RealmConfiguration\n+    private lateinit var testDispatcher: TestCoroutineDispatcher\n+    private lateinit var testScope: TestCoroutineScope\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        testDispatcher = TestCoroutineDispatcher()\n+        testScope = TestCoroutineScope(testDispatcher)\n+        configuration = configFactory.createConfiguration()\n+        realm = Realm.getInstance(configuration)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun toFlow_emittedOnCollect() {\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // TODO check this out for better testing: https://proandroiddev.com/from-rxjava-to-kotlin-flow-testing-42f1641d8433\n+        val context = Dispatchers.Main\n+        val scope = CoroutineScope(context)\n+\n+        scope.launch {\n+            val realmInstance = Realm.getInstance(configuration)\n+\n+            realmInstance.where<SimpleClass>()\n+                    .findAllAsync()\n+                    .toFlow()\n+                    .flowOn(context)\n+                    .onEach { flowResults ->\n+                        assertTrue(flowResults.isFrozen)\n+                        assertEquals(0, flowResults.size)\n+                        scope.cancel(\"Cancelling scope...\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzOTEzNA=="}, "originalCommit": {"oid": "e454f5fb8506704a36e833345a702fc012f7f37d"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODgyNDU1OnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjo0MjozN1rOHWrfRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNToyMzoyNFrOHW0AVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0MzIzNg==", "bodyText": "Maybe add onEach { results -> fail() }", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r493543236", "createdAt": "2020-09-23T12:42:37Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -0,0 +1,510 @@\n+package io.realm\n+\n+import io.realm.entities.AllTypes\n+import io.realm.entities.Dog\n+import io.realm.entities.SimpleClass\n+import io.realm.kotlin.*\n+import io.realm.rule.TestRealmConfigurationFactory\n+import kotlinx.coroutines.*\n+import kotlinx.coroutines.flow.*\n+import kotlinx.coroutines.test.TestCoroutineDispatcher\n+import kotlinx.coroutines.test.TestCoroutineScope\n+import kotlinx.coroutines.test.runBlockingTest\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+import java.util.concurrent.CountDownLatch\n+import kotlin.test.*\n+\n+@ExperimentalCoroutinesApi\n+class CoroutineTests {\n+\n+    @Suppress(\"MemberVisibilityCanPrivate\")\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private lateinit var configuration: RealmConfiguration\n+    private lateinit var testDispatcher: TestCoroutineDispatcher\n+    private lateinit var testScope: TestCoroutineScope\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        testDispatcher = TestCoroutineDispatcher()\n+        testScope = TestCoroutineScope(testDispatcher)\n+        configuration = configFactory.createConfiguration()\n+        realm = Realm.getInstance(configuration)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun toFlow_emittedOnCollect() {\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // TODO check this out for better testing: https://proandroiddev.com/from-rxjava-to-kotlin-flow-testing-42f1641d8433\n+        val context = Dispatchers.Main\n+        val scope = CoroutineScope(context)\n+\n+        scope.launch {\n+            val realmInstance = Realm.getInstance(configuration)\n+\n+            realmInstance.where<SimpleClass>()\n+                    .findAllAsync()\n+                    .toFlow()\n+                    .flowOn(context)\n+                    .onEach { flowResults ->\n+                        assertTrue(flowResults.isFrozen)\n+                        assertEquals(0, flowResults.size)\n+                        scope.cancel(\"Cancelling scope...\")\n+                    }.onCompletion {\n+                        realmInstance.close()\n+                        countDownLatch.countDown()\n+                    }.launchIn(scope)\n+        }\n+\n+        TestHelper.awaitOrFail(countDownLatch)\n+    }\n+\n+    @Test\n+    fun toFlow_resultsEmittedAfterCollect() {\n+        realm.executeTransactionAsync { transactionRealm ->\n+            transactionRealm.createObject<SimpleClass>().name = \"Foo\"\n+            transactionRealm.createObject<SimpleClass>().name = \"Bar\"\n+        }\n+\n+        val countDownLatch = CountDownLatch(1)\n+\n+        val context = Dispatchers.Main\n+        val scope = CoroutineScope(context)\n+\n+        scope.launch {\n+            val realmInstance = Realm.getInstance(configuration)\n+            realmInstance.where<SimpleClass>()\n+                    .findAllAsync()\n+                    .toFlow()\n+                    .flowOn(context)\n+                    .onEach { flowResults ->\n+                        assertTrue(flowResults.isFrozen)\n+                        if (flowResults.size == 2) {\n+                            scope.cancel(\"Cancelling scope...\")\n+                        }\n+                    }.onCompletion {\n+                        realmInstance.close()\n+                        countDownLatch.countDown()\n+                    }.launchIn(scope)\n+        }\n+\n+        TestHelper.awaitOrFail(countDownLatch)\n+    }\n+\n+    @Test\n+    fun toFlow_resultsCancelBeforeCollect() {\n+        val countDownLatch = CountDownLatch(1)\n+\n+        val context = Dispatchers.Main\n+        val scope = CoroutineScope(context)\n+\n+        scope.launch {\n+            val realmInstance = Realm.getInstance(configuration)\n+            realmInstance.where<SimpleClass>()\n+                    .findAllAsync()\n+                    .toFlow()\n+                    .flowOn(context)\n+                    .onCompletion {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e454f5fb8506704a36e833345a702fc012f7f37d"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY4Mjc3NA==", "bodyText": "toFlow emits whatever results we have immediately, and normally it is an empty result the first time, which means onEach will be called most likely at least once with empty RealmResults. However, since this test is tightly synchronised - look at the delay(100) just a few lines below - maybe it doesn't even make sense to test it...?", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r493682774", "createdAt": "2020-09-23T15:23:24Z", "author": {"login": "edualonso"}, "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -0,0 +1,510 @@\n+package io.realm\n+\n+import io.realm.entities.AllTypes\n+import io.realm.entities.Dog\n+import io.realm.entities.SimpleClass\n+import io.realm.kotlin.*\n+import io.realm.rule.TestRealmConfigurationFactory\n+import kotlinx.coroutines.*\n+import kotlinx.coroutines.flow.*\n+import kotlinx.coroutines.test.TestCoroutineDispatcher\n+import kotlinx.coroutines.test.TestCoroutineScope\n+import kotlinx.coroutines.test.runBlockingTest\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+import java.util.concurrent.CountDownLatch\n+import kotlin.test.*\n+\n+@ExperimentalCoroutinesApi\n+class CoroutineTests {\n+\n+    @Suppress(\"MemberVisibilityCanPrivate\")\n+    @Rule\n+    @JvmField\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private lateinit var configuration: RealmConfiguration\n+    private lateinit var testDispatcher: TestCoroutineDispatcher\n+    private lateinit var testScope: TestCoroutineScope\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        testDispatcher = TestCoroutineDispatcher()\n+        testScope = TestCoroutineScope(testDispatcher)\n+        configuration = configFactory.createConfiguration()\n+        realm = Realm.getInstance(configuration)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        realm.executeTransaction { it.deleteAll() }\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun toFlow_emittedOnCollect() {\n+        val countDownLatch = CountDownLatch(1)\n+\n+        // TODO check this out for better testing: https://proandroiddev.com/from-rxjava-to-kotlin-flow-testing-42f1641d8433\n+        val context = Dispatchers.Main\n+        val scope = CoroutineScope(context)\n+\n+        scope.launch {\n+            val realmInstance = Realm.getInstance(configuration)\n+\n+            realmInstance.where<SimpleClass>()\n+                    .findAllAsync()\n+                    .toFlow()\n+                    .flowOn(context)\n+                    .onEach { flowResults ->\n+                        assertTrue(flowResults.isFrozen)\n+                        assertEquals(0, flowResults.size)\n+                        scope.cancel(\"Cancelling scope...\")\n+                    }.onCompletion {\n+                        realmInstance.close()\n+                        countDownLatch.countDown()\n+                    }.launchIn(scope)\n+        }\n+\n+        TestHelper.awaitOrFail(countDownLatch)\n+    }\n+\n+    @Test\n+    fun toFlow_resultsEmittedAfterCollect() {\n+        realm.executeTransactionAsync { transactionRealm ->\n+            transactionRealm.createObject<SimpleClass>().name = \"Foo\"\n+            transactionRealm.createObject<SimpleClass>().name = \"Bar\"\n+        }\n+\n+        val countDownLatch = CountDownLatch(1)\n+\n+        val context = Dispatchers.Main\n+        val scope = CoroutineScope(context)\n+\n+        scope.launch {\n+            val realmInstance = Realm.getInstance(configuration)\n+            realmInstance.where<SimpleClass>()\n+                    .findAllAsync()\n+                    .toFlow()\n+                    .flowOn(context)\n+                    .onEach { flowResults ->\n+                        assertTrue(flowResults.isFrozen)\n+                        if (flowResults.size == 2) {\n+                            scope.cancel(\"Cancelling scope...\")\n+                        }\n+                    }.onCompletion {\n+                        realmInstance.close()\n+                        countDownLatch.countDown()\n+                    }.launchIn(scope)\n+        }\n+\n+        TestHelper.awaitOrFail(countDownLatch)\n+    }\n+\n+    @Test\n+    fun toFlow_resultsCancelBeforeCollect() {\n+        val countDownLatch = CountDownLatch(1)\n+\n+        val context = Dispatchers.Main\n+        val scope = CoroutineScope(context)\n+\n+        scope.launch {\n+            val realmInstance = Realm.getInstance(configuration)\n+            realmInstance.where<SimpleClass>()\n+                    .findAllAsync()\n+                    .toFlow()\n+                    .flowOn(context)\n+                    .onCompletion {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0MzIzNg=="}, "originalCommit": {"oid": "e454f5fb8506704a36e833345a702fc012f7f37d"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4OTIyNjcyOnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMzo1MDo0NVrOHWvfrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMzo1MDo0NVrOHWvfrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYwODg3OA==", "bodyText": "We don't have tests for this elsewhere. Just deleting this comment would be good enough.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r493608878", "createdAt": "2020-09-23T13:50:45Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.kotlin\n+\n+import io.realm.*\n+import io.realm.RealmObject.freeze\n+import io.realm.annotations.Beta\n+import io.realm.internal.RealmObjectProxy\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Returns a [Flow] that monitors changes to this RealmObject. It will emit the current\n+ * RealmObject when subscribed to. Object updates will continually be emitted as the RealmObject is\n+ * updated - `onCompletion` will never be called.\n+ *\n+ * Items emitted from Realm flows are frozen - see [RealmObject.freeze]. This means that they are\n+ * immutable and can be read from any thread.\n+ *\n+ * Realm flows always emit items from the thread holding the live RealmObject. This means that if\n+ * you need to do further processing, it is recommended to collect the values on a computation\n+ * dispatcher:\n+ *\n+ * ```\n+ * object.toFlow()\n+ *   .map { obj -> doExpensiveWork(obj) }\n+ *   .flowOn(Dispatchers.IO)\n+ *   .onEach { flowObject ->\n+ *     // ...\n+ *   }.launchIn(Dispatchers.Main)\n+ * ```\n+ *\n+ * If your would like `toFlow()` to stop emitting items you can instruct the flow to only emit the\n+ * first item by calling [kotlinx.coroutines.flow.first]:\n+ * ```\n+ * val foo = object.toFlow()\n+ *   .flowOn(context)\n+ *   .first()\n+ * ```\n+ *\n+ * @return Kotlin [Flow] on which calls to `onEach` or `collect` can be made.\n+ */\n+@Beta\n+fun <T : RealmModel> T.toFlow(): Flow<T> {\n+    val obj = this\n+    return if (obj is RealmObjectProxy) {\n+        val proxy = obj as RealmObjectProxy\n+        val realm = proxy.`realmGet$proxyState`().`realm$realm`\n+\n+        when (realm) {\n+            is Realm -> flowFromRealm<T>(realm, obj)\n+            is DynamicRealm -> {\n+                val dynamicObject = obj as DynamicRealmObject\n+                flowFromDynamicRealm(realm, dynamicObject) as Flow<T>\n+            }\n+            // FIXME: exception text", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e454f5fb8506704a36e833345a702fc012f7f37d"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4OTIzNDUwOnYy", "diffSide": "RIGHT", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMzo1MjoxNVrOHWvkfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMzo1MjoxNVrOHWvkfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYxMDEwOQ==", "bodyText": "Good point. I can see that we disallow this for RxJava Observables as well. I cannot remember exactly why we did that.\nThis seems similar to frozen objects so probably fine to allow?", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r493610109", "createdAt": "2020-09-23T13:52:15Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.kotlin\n+\n+import io.realm.*\n+import io.realm.RealmObject.freeze\n+import io.realm.annotations.Beta\n+import io.realm.internal.RealmObjectProxy\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Returns a [Flow] that monitors changes to this RealmObject. It will emit the current\n+ * RealmObject when subscribed to. Object updates will continually be emitted as the RealmObject is\n+ * updated - `onCompletion` will never be called.\n+ *\n+ * Items emitted from Realm flows are frozen - see [RealmObject.freeze]. This means that they are\n+ * immutable and can be read from any thread.\n+ *\n+ * Realm flows always emit items from the thread holding the live RealmObject. This means that if\n+ * you need to do further processing, it is recommended to collect the values on a computation\n+ * dispatcher:\n+ *\n+ * ```\n+ * object.toFlow()\n+ *   .map { obj -> doExpensiveWork(obj) }\n+ *   .flowOn(Dispatchers.IO)\n+ *   .onEach { flowObject ->\n+ *     // ...\n+ *   }.launchIn(Dispatchers.Main)\n+ * ```\n+ *\n+ * If your would like `toFlow()` to stop emitting items you can instruct the flow to only emit the\n+ * first item by calling [kotlinx.coroutines.flow.first]:\n+ * ```\n+ * val foo = object.toFlow()\n+ *   .flowOn(context)\n+ *   .first()\n+ * ```\n+ *\n+ * @return Kotlin [Flow] on which calls to `onEach` or `collect` can be made.\n+ */\n+@Beta\n+fun <T : RealmModel> T.toFlow(): Flow<T> {\n+    val obj = this\n+    return if (obj is RealmObjectProxy) {\n+        val proxy = obj as RealmObjectProxy\n+        val realm = proxy.`realmGet$proxyState`().`realm$realm`\n+\n+        when (realm) {\n+            is Realm -> flowFromRealm<T>(realm, obj)\n+            is DynamicRealm -> {\n+                val dynamicObject = obj as DynamicRealmObject\n+                flowFromDynamicRealm(realm, dynamicObject) as Flow<T>\n+            }\n+            // FIXME: exception text\n+            else -> throw UnsupportedOperationException(\"${realm.javaClass} does not support RxJava. See https://realm.io/docs/java/latest/#rxjava for more details.\")\n+        }\n+    } else {\n+        // TODO Is this true? Should we just return Observable.just(object) ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e454f5fb8506704a36e833345a702fc012f7f37d"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4OTI0MDU4OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/main/java/io/realm/BaseRealm.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMzo1MzozNFrOHWvocw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMzo1Mzo1NFrOHWvpjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYxMTEyMw==", "bodyText": "We should use WRITE_EXECUTOR since this is public. If we introduce this, we should probably also redirect executeTransactionAsync to use it.", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r493611123", "createdAt": "2020-09-23T13:53:34Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/BaseRealm.java", "diffHunk": "@@ -76,6 +76,12 @@\n     // Thread pool for all async operations (Query & transaction)\n     static final RealmThreadPoolExecutor asyncTaskExecutor = RealmThreadPoolExecutor.newDefaultExecutor();\n \n+    /**\n+     * Thread pool executor used for write operations - only one thread is needed as writes cannot\n+     * be parallelized.\n+     */\n+    public static final RealmThreadPoolExecutor writeExecutor = RealmThreadPoolExecutor.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e454f5fb8506704a36e833345a702fc012f7f37d"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYxMTQwNw==", "bodyText": "But it is fine to create an issue for that and do it in a followup PR", "url": "https://github.com/realm/realm-java/pull/7088#discussion_r493611407", "createdAt": "2020-09-23T13:53:54Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/BaseRealm.java", "diffHunk": "@@ -76,6 +76,12 @@\n     // Thread pool for all async operations (Query & transaction)\n     static final RealmThreadPoolExecutor asyncTaskExecutor = RealmThreadPoolExecutor.newDefaultExecutor();\n \n+    /**\n+     * Thread pool executor used for write operations - only one thread is needed as writes cannot\n+     * be parallelized.\n+     */\n+    public static final RealmThreadPoolExecutor writeExecutor = RealmThreadPoolExecutor.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYxMTEyMw=="}, "originalCommit": {"oid": "e454f5fb8506704a36e833345a702fc012f7f37d"}, "originalPosition": 8}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 523, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}