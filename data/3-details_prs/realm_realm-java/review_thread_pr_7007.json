{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3Mzk0NDc2", "number": 7007, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMjowMTo0MFrOEWL_8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMjoxMTo1NVrOEWMOFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNzAwNzIwOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMjowMTo0MFrOG9XLbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDoyODo1OFrOG9cGPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk5NjA3Nw==", "bodyText": "Is this always true? Wouldn't the sync potentially already have fetched stuff.", "url": "https://github.com/realm/realm-java/pull/7007#discussion_r466996077", "createdAt": "2020-08-07T12:01:40Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "diffHunk": "@@ -232,6 +239,222 @@ class SyncedRealmTests {\n         }\n     }\n \n+    @Test\n+    fun embeddedObject_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                realm.createObject<EmbeddedSimpleParent>(primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79cef318e87830aae00666dc0dee0065b74ee42a"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3NjY3MQ==", "bodyText": "I thought of adding this because I was debugging something else a number of times and I found it curious that the local realm never had any objects at this point. I guess in all fairness that the synchronisation process could just be slow, so making this assumption might not be correct. I will delete it.", "url": "https://github.com/realm/realm-java/pull/7007#discussion_r467076671", "createdAt": "2020-08-07T14:28:58Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "diffHunk": "@@ -232,6 +239,222 @@ class SyncedRealmTests {\n         }\n     }\n \n+    @Test\n+    fun embeddedObject_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                realm.createObject<EmbeddedSimpleParent>(primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk5NjA3Nw=="}, "originalCommit": {"oid": "79cef318e87830aae00666dc0dee0065b74ee42a"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNzAyNDIzOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMjowNjoxOFrOG9XUrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMjowNjoxOFrOG9XUrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk5ODQ0Nw==", "bodyText": "Maybe also verify that the children are actually embedded in the parent.", "url": "https://github.com/realm/realm-java/pull/7007#discussion_r466998447", "createdAt": "2020-08-07T12:06:18Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "diffHunk": "@@ -232,6 +239,222 @@ class SyncedRealmTests {\n         }\n     }\n \n+    @Test\n+    fun embeddedObject_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                realm.createObject<EmbeddedSimpleParent>(primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    // FIXME: remove ignore when sync issue fixed\n+    @Test\n+    @Ignore(\"ignored until https://jira.mongodb.org/browse/REALMC-6541 is fixed\")\n+    fun embeddedObject_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                val parent = EmbeddedSimpleParent(primaryKeyValue)\n+\n+//                parent.child = EmbeddedSimpleChild()\n+                val managedParent = it.copyToRealmOrUpdate(parent)\n+                // FIXME: instantiating the child in managedParent yields this from sync:\n+                //  \"MongoDB error: Updating the path 'child.childID' would create a conflict at 'child'\"\n+                managedParent.child = EmbeddedSimpleChild() // Will copy the object to Realm\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(EmbeddedSimpleListParent::class.java, primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(2, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleListParent>()\n+            assertEquals(1, parentResults.count())\n+            val parentFromResults = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parentFromResults._id)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79cef318e87830aae00666dc0dee0065b74ee42a"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNzAzNDc1OnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMjowOToyMlrOG9XamA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMjowOToyMlrOG9XamA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk5OTk2MA==", "bodyText": "I would prefer explicit naming to avoid confusion.", "url": "https://github.com/realm/realm-java/pull/7007#discussion_r466999960", "createdAt": "2020-08-07T12:09:22Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "diffHunk": "@@ -232,6 +239,222 @@ class SyncedRealmTests {\n         }\n     }\n \n+    @Test\n+    fun embeddedObject_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                realm.createObject<EmbeddedSimpleParent>(primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    // FIXME: remove ignore when sync issue fixed\n+    @Test\n+    @Ignore(\"ignored until https://jira.mongodb.org/browse/REALMC-6541 is fixed\")\n+    fun embeddedObject_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                val parent = EmbeddedSimpleParent(primaryKeyValue)\n+\n+//                parent.child = EmbeddedSimpleChild()\n+                val managedParent = it.copyToRealmOrUpdate(parent)\n+                // FIXME: instantiating the child in managedParent yields this from sync:\n+                //  \"MongoDB error: Updating the path 'child.childID' would create a conflict at 'child'\"\n+                managedParent.child = EmbeddedSimpleChild() // Will copy the object to Realm\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(EmbeddedSimpleListParent::class.java, primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(2, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleListParent>()\n+            assertEquals(1, parentResults.count())\n+            val parentFromResults = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parentFromResults._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                EmbeddedSimpleListParent(primaryKeyValue).apply {\n+                    children = RealmList(EmbeddedSimpleChild(\"child1\"), EmbeddedSimpleChild(\"child2\"))\n+                    it.insert(this)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79cef318e87830aae00666dc0dee0065b74ee42a"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNzA0MzQzOnYy", "diffSide": "RIGHT", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMjoxMTo1NVrOG9Xfsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMjoyMjo1NFrOG9XyzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAwMTI2Ng==", "bodyText": "Do we have a reference to the issue?", "url": "https://github.com/realm/realm-java/pull/7007#discussion_r467001266", "createdAt": "2020-08-07T12:11:55Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "diffHunk": "@@ -232,6 +239,222 @@ class SyncedRealmTests {\n         }\n     }\n \n+    @Test\n+    fun embeddedObject_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                realm.createObject<EmbeddedSimpleParent>(primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    // FIXME: remove ignore when sync issue fixed\n+    @Test\n+    @Ignore(\"ignored until https://jira.mongodb.org/browse/REALMC-6541 is fixed\")\n+    fun embeddedObject_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                val parent = EmbeddedSimpleParent(primaryKeyValue)\n+\n+//                parent.child = EmbeddedSimpleChild()\n+                val managedParent = it.copyToRealmOrUpdate(parent)\n+                // FIXME: instantiating the child in managedParent yields this from sync:\n+                //  \"MongoDB error: Updating the path 'child.childID' would create a conflict at 'child'\"\n+                managedParent.child = EmbeddedSimpleChild() // Will copy the object to Realm\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(EmbeddedSimpleListParent::class.java, primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(2, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleListParent>()\n+            assertEquals(1, parentResults.count())\n+            val parentFromResults = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parentFromResults._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                EmbeddedSimpleListParent(primaryKeyValue).apply {\n+                    children = RealmList(EmbeddedSimpleChild(\"child1\"), EmbeddedSimpleChild(\"child2\"))\n+                    it.insert(this)\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(1, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(2, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleListParent>()\n+            assertEquals(1, parentResults.count())\n+            val parentFromResults = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parentFromResults._id)\n+            assertEquals(\"child1\", childResults.findAll()[0]!!.childId)\n+            assertEquals(\"child2\", childResults.findAll()[1]!!.childId)\n+        }\n+    }\n+\n+    @Test\n+    @Ignore(\"Enable when a bug server-side is fixed\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79cef318e87830aae00666dc0dee0065b74ee42a"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAwNjE1Ng==", "bodyText": "I've just got feedback from Nikola, I'll update when creating a ticket for them \ud83d\udc4d", "url": "https://github.com/realm/realm-java/pull/7007#discussion_r467006156", "createdAt": "2020-08-07T12:22:54Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "diffHunk": "@@ -232,6 +239,222 @@ class SyncedRealmTests {\n         }\n     }\n \n+    @Test\n+    fun embeddedObject_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                realm.createObject<EmbeddedSimpleParent>(primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    // FIXME: remove ignore when sync issue fixed\n+    @Test\n+    @Ignore(\"ignored until https://jira.mongodb.org/browse/REALMC-6541 is fixed\")\n+    fun embeddedObject_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                val parent = EmbeddedSimpleParent(primaryKeyValue)\n+\n+//                parent.child = EmbeddedSimpleChild()\n+                val managedParent = it.copyToRealmOrUpdate(parent)\n+                // FIXME: instantiating the child in managedParent yields this from sync:\n+                //  \"MongoDB error: Updating the path 'child.childID' would create a conflict at 'child'\"\n+                managedParent.child = EmbeddedSimpleChild() // Will copy the object to Realm\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(EmbeddedSimpleListParent::class.java, primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(2, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleListParent>()\n+            assertEquals(1, parentResults.count())\n+            val parentFromResults = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parentFromResults._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                EmbeddedSimpleListParent(primaryKeyValue).apply {\n+                    children = RealmList(EmbeddedSimpleChild(\"child1\"), EmbeddedSimpleChild(\"child2\"))\n+                    it.insert(this)\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(1, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(2, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleListParent>()\n+            assertEquals(1, parentResults.count())\n+            val parentFromResults = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parentFromResults._id)\n+            assertEquals(\"child1\", childResults.findAll()[0]!!.childId)\n+            assertEquals(\"child2\", childResults.findAll()[1]!!.childId)\n+        }\n+    }\n+\n+    @Test\n+    @Ignore(\"Enable when a bug server-side is fixed\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAwMTI2Ng=="}, "originalCommit": {"oid": "79cef318e87830aae00666dc0dee0065b74ee42a"}, "originalPosition": 207}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 447, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}