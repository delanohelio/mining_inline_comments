{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4NDc4NzQx", "number": 7191, "title": "Added FlowFactory interface and default implementation for coroutines flows", "bodyText": "Closes #7164\nCloses #7165\nFlows can be tricky to work with. Additionally some users might need to implement a custom emission behaviour - e.g. using a Dropbox Store repository requires disabling the emission of the current value when calling findAllAsync upon collection to enable a correct delivery of cached results.\nTo allow this, we have added the option of configuring a Realm using a FlowFactory for coroutines. The default implementation, RealmFlowFactory, is addded by default when creating a configuration and works as a port of the RealmObservableFactory we already use for supporting custom RxJava flowables.\nIt was necessary to add Kotlin and Kotlin coroutines dependencies to the main library project. Using compileOnly ensures those dependencies will not be present in the delivered artefacts.\nTwo somewhat important changes have been made to RealmResults and RealmList in connection with adding support for flows for DynamicRealms. The flow factory is located inside the configuration object, therefore fetching the Realm instance for results and lists is needed to gain access to said factory. However, accessing the Realm instance which owns results and list is forbidden for dynamic Realms from an extension function, which is a restriction that stems from how the type system was built for dynamic and regular Realms. Changing the getRealm method in these classes is not feasible due to this very constraint, so we decided to make the realm property public and rename it to baseRealm (as it already typed BaseRealm). We discourage accessing this property directly from any RealmResults or RealmList instance.", "createdAt": "2020-11-10T13:11:53Z", "url": "https://github.com/realm/realm-java/pull/7191", "merged": true, "mergeCommit": {"oid": "0c43d47436880d9993a07548c567257efcc30cb9"}, "closed": true, "closedAt": "2020-11-17T11:36:38Z", "author": {"login": "edualonso"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSwfDZAH2gAyNTE4NDc4NzQxOjk3M2Q0MzcyNWQzYmMyYThiZDA1Mzg5MmRkYWIwZmYyODU2ZGFhMTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABddWy9sgH2gAyNTE4NDc4NzQxOjBiMzEzYzg1NGQ3YTg4YjczZTk1NzE5YjI5MGQ2ZDc1YmVhYzZkYjk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "973d43725d3bc2a8bd053892ddab0ff2856daa12", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/973d43725d3bc2a8bd053892ddab0ff2856daa12", "committedDate": "2020-10-15T11:57:14Z", "message": "Prepare next dev iteration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69a044b05ee93656f0fb7e2f8a0c9e32ae4b50e2", "author": {"user": {"login": "nathan-contino-mongo", "name": "nate contino"}}, "url": "https://github.com/realm/realm-java/commit/69a044b05ee93656f0fb7e2f8a0c9e32ae4b50e2", "committedDate": "2020-11-05T10:06:07Z", "message": "Add Decimal128 and ObjectId to Javadoc on supported types (#7183)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac2d4540df081d03854b66be7f06875bef651d61", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/ac2d4540df081d03854b66be7f06875bef651d61", "committedDate": "2020-11-06T11:19:35Z", "message": "Merge branch 'releases'\n\n# Conflicts:\n#\tversion.txt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2557b6349e0eea4cc8ee43cee5d56d0d03e40ed", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/a2557b6349e0eea4cc8ee43cee5d56d0d03e40ed", "committedDate": "2020-11-06T15:06:24Z", "message": "First steps towards having a coroutines factory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0728b79fbe65f3e83d0e95061099bf8c4ab7628", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/e0728b79fbe65f3e83d0e95061099bf8c4ab7628", "committedDate": "2020-11-06T16:31:02Z", "message": "Hid Kotlin dependencies from artifact, only for compile time"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7156b30f2257e3b81757e2d992f9aba73d0504a", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/c7156b30f2257e3b81757e2d992f9aba73d0504a", "committedDate": "2020-11-09T11:40:33Z", "message": "Added dependencies for testing, added missing toFlow methods and tests for config and syncconfig"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4efc7147d3e2b4ca6092aa7f0dccda6101dca10f", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/4efc7147d3e2b4ca6092aa7f0dccda6101dca10f", "committedDate": "2020-11-09T11:56:12Z", "message": "Corrected signatures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa67c34f1321f582208df616dc040a435caddae2", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/aa67c34f1321f582208df616dc040a435caddae2", "committedDate": "2020-11-09T15:46:40Z", "message": "Added missing realm instance flow methods to factory and tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbfd23d50809a755686da6df3d222eb8a88f6e1b", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/dbfd23d50809a755686da6df3d222eb8a88f6e1b", "committedDate": "2020-11-10T12:47:52Z", "message": "Made realm property in RealmResults and RealmList public so that it can be accessed from extension functions (the existing getRealm method cannot be used for DynamicRealms so that would break the API), added missing flow methods for dynamic realms and tests, and added docs and beta annotations to factory methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29d15d070c602e4083386cf9e0270048caabd9bd", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/29d15d070c602e4083386cf9e0270048caabd9bd", "committedDate": "2020-11-10T13:11:24Z", "message": "Added missing documentation and renamed builder method to flowFactory instead"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e14d72296c6f6c2aadcc2423efaa2b0e8cfb226c", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/e14d72296c6f6c2aadcc2423efaa2b0e8cfb226c", "committedDate": "2020-11-11T10:21:10Z", "message": "Added support for Flows with no results when using findFirst"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29abccae77f9f0e37f278080bfbf791a73448051", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/29abccae77f9f0e37f278080bfbf791a73448051", "committedDate": "2020-11-11T10:31:24Z", "message": "Added exclusion of Kotlin files for javadoc generation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65feabb11ab4021d80d44a32ab19988c2f639e3d", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/65feabb11ab4021d80d44a32ab19988c2f639e3d", "committedDate": "2020-11-11T13:34:03Z", "message": "Added test for null object to flow"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc71055cd4eba2099b340784927ecac540c00e73", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/fc71055cd4eba2099b340784927ecac540c00e73", "committedDate": "2020-11-11T14:06:16Z", "message": "Added missing collect to trigger thread violation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "committedDate": "2020-11-11T14:32:32Z", "message": "Fixed test factories"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NzcwNjU3", "url": "https://github.com/realm/realm-java/pull/7191#pullrequestreview-528770657", "createdAt": "2020-11-12T06:00:44Z", "commit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNjowMDo0NFrOHxrrhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzozNjozMFrOHyhNJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1NzkyNA==", "bodyText": "Missing license header", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r521857924", "createdAt": "2020-11-12T06:00:44Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/DynamicRealmExtensions.kt", "diffHunk": "@@ -0,0 +1,17 @@\n+package io.realm.kotlin", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxMTczMg==", "bodyText": "Can this ever be null here?", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522711732", "createdAt": "2020-11-13T07:11:22Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "diffHunk": "@@ -56,94 +54,25 @@ import kotlinx.coroutines.flow.flowOf\n  * @return Kotlin [Flow] on which calls to `onEach` or `collect` can be made.\n  */\n @Beta\n-fun <T : RealmModel> T.toFlow(): Flow<T> {\n-    val obj = this\n-    return if (obj is RealmObjectProxy) {\n-        val proxy = obj as RealmObjectProxy\n-        val realm = proxy.`realmGet$proxyState`().`realm$realm`\n-\n-        when (realm) {\n-            is Realm -> flowFromRealm<T>(realm, obj)\n-            is DynamicRealm -> {\n-                val dynamicObject = obj as DynamicRealmObject\n-                flowFromDynamicRealm(realm, dynamicObject) as Flow<T>\n-            }\n-            else -> throw UnsupportedOperationException(\"${realm.javaClass} does not support RxJava. See https://realm.io/docs/java/latest/#rxjava for more details.\")\n-        }\n-    } else {\n-        return flowOf(this)\n-    }\n-}\n-\n-private fun <T : RealmModel> flowFromRealm(realm: Realm, obj: T): Flow<T> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (realm.isFrozen) {\n-        return flowOf(obj)\n-    }\n-\n-    val config = realm.configuration\n-\n-    return callbackFlow<T> {\n-        // Do nothing if the object is invalid\n-        if (!obj.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<T> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        obj.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(obj))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                obj.removeChangeListener(listener)\n-                flowRealm.close()\n-            }\n-        }\n-    }\n-}\n-\n-private fun flowFromDynamicRealm(\n-        dynamicRealm: DynamicRealm,\n-        dynamicObject: DynamicRealmObject\n-): Flow<DynamicRealmObject> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (dynamicRealm.isFrozen) {\n-        return flowOf(dynamicObject)\n-    }\n-\n-    val config = dynamicRealm.configuration\n-\n-    return callbackFlow<DynamicRealmObject> {\n-        // Do nothing if the object is invalid\n-        if (!dynamicObject.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<DynamicRealmObject> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        dynamicObject.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(dynamicObject))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                dynamicObject.removeChangeListener(listener)\n-                flowRealm.close()\n+fun <T : RealmModel> T?.toFlow(): Flow<T?> {\n+    // Return flow with object or null flow if this function is called on null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxMzQ5MA==", "bodyText": "Maybe add a comment about unmanaged objects only being emitted once?", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522713490", "createdAt": "2020-11-13T07:13:19Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "diffHunk": "@@ -56,94 +54,25 @@ import kotlinx.coroutines.flow.flowOf\n  * @return Kotlin [Flow] on which calls to `onEach` or `collect` can be made.\n  */\n @Beta\n-fun <T : RealmModel> T.toFlow(): Flow<T> {\n-    val obj = this\n-    return if (obj is RealmObjectProxy) {\n-        val proxy = obj as RealmObjectProxy\n-        val realm = proxy.`realmGet$proxyState`().`realm$realm`\n-\n-        when (realm) {\n-            is Realm -> flowFromRealm<T>(realm, obj)\n-            is DynamicRealm -> {\n-                val dynamicObject = obj as DynamicRealmObject\n-                flowFromDynamicRealm(realm, dynamicObject) as Flow<T>\n-            }\n-            else -> throw UnsupportedOperationException(\"${realm.javaClass} does not support RxJava. See https://realm.io/docs/java/latest/#rxjava for more details.\")\n-        }\n-    } else {\n-        return flowOf(this)\n-    }\n-}\n-\n-private fun <T : RealmModel> flowFromRealm(realm: Realm, obj: T): Flow<T> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (realm.isFrozen) {\n-        return flowOf(obj)\n-    }\n-\n-    val config = realm.configuration\n-\n-    return callbackFlow<T> {\n-        // Do nothing if the object is invalid\n-        if (!obj.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<T> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        obj.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(obj))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                obj.removeChangeListener(listener)\n-                flowRealm.close()\n-            }\n-        }\n-    }\n-}\n-\n-private fun flowFromDynamicRealm(\n-        dynamicRealm: DynamicRealm,\n-        dynamicObject: DynamicRealmObject\n-): Flow<DynamicRealmObject> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (dynamicRealm.isFrozen) {\n-        return flowOf(dynamicObject)\n-    }\n-\n-    val config = dynamicRealm.configuration\n-\n-    return callbackFlow<DynamicRealmObject> {\n-        // Do nothing if the object is invalid\n-        if (!dynamicObject.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<DynamicRealmObject> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        dynamicObject.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(dynamicObject))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                dynamicObject.removeChangeListener(listener)\n-                flowRealm.close()\n+fun <T : RealmModel> T?.toFlow(): Flow<T?> {\n+    // Return flow with object or null flow if this function is called on null\n+    return this?.let { obj ->\n+        if (obj is RealmObjectProxy) {\n+            val proxy = obj as RealmObjectProxy\n+\n+            @Suppress(\"INACCESSIBLE_TYPE\")\n+            when (val realm = proxy.`realmGet$proxyState`().`realm$realm`) {\n+                is Realm -> realm.configuration.flowFactory?.from<T>(realm, obj)\n+                        ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")\n+                is DynamicRealm ->\n+                    (obj as DynamicRealmObject).let { dynamicRealmObject ->\n+                        (realm.configuration.flowFactory?.from(realm, dynamicRealmObject)\n+                                ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")) as Flow<T?>\n+                    }\n+                else -> throw UnsupportedOperationException(\"${realm.javaClass} is not supported as a candidate for 'toFlow'. Only subclasses of RealmModel/RealmObject can be used.\")\n             }\n+        } else {\n+            return flowOf(this)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxNTIzOQ==", "bodyText": "After thinking a bit about this,  I think we should introduce this method as well. IMO the one just returning the RealmResults are far easier to consume, this one is slightly annoying as you have to unpack things everytime, but it still has a lot of uses.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522715239", "createdAt": "2020-11-13T07:15:21Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmResultsExtensions.kt", "diffHunk": "@@ -63,38 +57,17 @@ import kotlinx.coroutines.flow.flowOf\n  */\n @Beta\n fun <T : RealmModel> RealmResults<T>.toFlow(): Flow<RealmResults<T>> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (realm.isFrozen) {\n-        return flowOf(this)\n-    }\n-\n-    val config = realm.configuration\n-\n-    return callbackFlow {\n-        val results = this@toFlow\n-\n-        // Do nothing if the results are invalid\n-        if (!results.isValid) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<RealmResults<T>> { listenerResults ->\n-            offer(listenerResults.freeze())\n-        }\n-\n-        results.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze())\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                results.removeChangeListener(listener)\n-                flowRealm.close()\n-            }\n-        }\n+    @Suppress(\"INACCESSIBLE_TYPE\")\n+    return when (val realmInstance = baseRealm) {\n+        is Realm -> realmInstance.configuration.flowFactory?.from(baseRealm as Realm, this)\n+                ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")\n+        is DynamicRealm -> realmInstance.configuration.flowFactory?.from(baseRealm as DynamicRealm, this)\n+                ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")\n+        else -> throw IllegalStateException(\"Wrong type of Realm.\")\n     }\n }\n+\n+// TODO figure out if we want to do this as a separate method or merge both in one that delivers changesets and results", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxNjczMA==", "bodyText": "I would probably just delete this comment.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522716730", "createdAt": "2020-11-13T07:16:53Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/build.gradle", "diffHunk": "@@ -208,8 +208,14 @@ repositories {\n \n dependencies {\n \n+    // Hidden from deliverable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMTgxMw==", "bodyText": "Missing test for what happens if you try to assign null to the factory. I assume we want to throw an IllegalArgumentException?", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522721813", "createdAt": "2020-11-13T07:22:16Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java", "diffHunk": "@@ -796,6 +801,68 @@ public void rxFactory() {\n         assertFalse(configuration2.getRxFactory() == dummyFactory);\n     }\n \n+    @Test\n+    public void coroutinesFactory_defaultNotNull() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMjI0NQ==", "bodyText": "Same, missing test for what happens if you assign null", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522722245", "createdAt": "2020-11-13T07:22:47Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncConfigurationTests.kt", "diffHunk": "@@ -424,4 +431,57 @@ class SyncConfigurationTests {\n                 .build()\n         assertTrue(configuration.isAllowWritesOnUiThread)\n     }\n+\n+    @Test\n+    fun coroutinesFactory_defaultNonNull() {\n+        val configuration = SyncConfiguration.Builder(createTestUser(app), DEFAULT_PARTITION)\n+                .build()\n+        assertNotNull(configuration.flowFactory)\n+    }\n+\n+    @Test\n+    fun coroutinesFactory() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMjkzNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Warning: we discourage using this property directly from your code.\n          \n          \n            \n                 * Warning: This field is only exposed for internal usage, and should not be used.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522722934", "createdAt": "2020-11-13T07:23:32Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java", "diffHunk": "@@ -25,7 +25,13 @@\n     private static final String NOT_SUPPORTED_MESSAGE = \"This method is not supported by 'RealmResults' or\" +\n             \" 'OrderedRealmCollectionSnapshot'.\";\n \n-    final BaseRealm realm;\n+    /**\n+     * The {@link BaseRealm} instance in which this collection resides.\n+     * <p>\n+     * Warning: we discourage using this property directly from your code.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMzk3MA==", "bodyText": "Missing Javadoc", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522723970", "createdAt": "2020-11-13T07:24:39Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/RealmConfiguration.java", "diffHunk": "@@ -267,6 +272,18 @@ public RxObservableFactory getRxFactory() {\n         return rxObservableFactory;\n     }\n \n+    /**\n+     * FIXME", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyNDM3MA==", "bodyText": "We should guard against this in the builder so it can never be null here.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522724370", "createdAt": "2020-11-13T07:25:06Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/RealmConfiguration.java", "diffHunk": "@@ -267,6 +272,18 @@ public RxObservableFactory getRxFactory() {\n         return rxObservableFactory;\n     }\n \n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    @Nullable\n+    public FlowFactory getFlowFactory() {\n+        if (flowFactory == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyNjQ5Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Warning: we discourage using this property directly from your code.\n          \n          \n            \n                 * Warning: This field is only exposed for internal usage, and should not be used.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522726496", "createdAt": "2020-11-13T07:27:13Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/RealmList.java", "diffHunk": "@@ -73,7 +73,14 @@\n \n     // Always null if RealmList is unmanaged, always non-null if managed.\n     private final ManagedListOperator<E> osListOperator;\n-    protected final BaseRealm realm;\n+\n+    /**\n+     * The {@link BaseRealm} instance in which this list resides.\n+     * <p>\n+     * Warning: we discourage using this property directly from your code.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyOTYyMw==", "bodyText": "I think we might want to add the changeSetsFrom methods already now to this interface. Even if we don't expose them in this PR, it will prevent a later breaking change?\nBut then again, the interface is marked Beta.\nThoughts?", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522729623", "createdAt": "2020-11-13T07:30:41Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/FlowFactory.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines;\n+\n+import javax.annotation.Nonnull;\n+\n+import io.realm.DynamicRealm;\n+import io.realm.DynamicRealmObject;\n+import io.realm.Realm;\n+import io.realm.RealmList;\n+import io.realm.RealmModel;\n+import io.realm.RealmObject;\n+import io.realm.RealmResults;\n+import io.realm.annotations.Beta;\n+import kotlinx.coroutines.flow.Flow;\n+\n+/**\n+ * Factory interface for creating Kotlin {@link Flow}s for Realm classes.\n+ */\n+@Beta\n+public interface FlowFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczMTg0NQ==", "bodyText": "Flow\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Flow factory used by Realm by default.\n          \n          \n            \n             * Factory class used to create coroutine Flows. This class is used by default unless overridden in {@link RealmConfiguration.Builder#flowFactory(FlowFactory)}.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522731845", "createdAt": "2020-11-13T07:33:03Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,357 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Flow factory used by Realm by default.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczMjUwNg==", "bodyText": "What actually happens in our Javadoc? Is this class even listed there? If not, that is a problem, that might prevent us from implementing this in Kotlin. \ud83e\udd14", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522732506", "createdAt": "2020-11-13T07:33:47Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,357 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Flow factory used by Realm by default.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczNDQ2Mg==", "bodyText": "We should guard against null here.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522734462", "createdAt": "2020-11-13T07:36:02Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/sync/SyncConfiguration.java", "diffHunk": "@@ -793,6 +799,17 @@ public Builder rxFactory(RxObservableFactory factory) {\n             return this;\n         }\n \n+        /**\n+         * Sets the {@link FlowFactory} used to create coroutines Flows from Realm objects.\n+         * The default factory is {@link RealmFlowFactory}.\n+         *\n+         * @param factory factory to use.\n+         */\n+        public Builder flowFactory(FlowFactory factory) {\n+            flowFactory = factory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczNDg4Ng==", "bodyText": "We seem to be missing tests for this?", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522734886", "createdAt": "2020-11-13T07:36:30Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "diffHunk": "@@ -56,94 +54,25 @@ import kotlinx.coroutines.flow.flowOf\n  * @return Kotlin [Flow] on which calls to `onEach` or `collect` can be made.\n  */\n @Beta\n-fun <T : RealmModel> T.toFlow(): Flow<T> {\n-    val obj = this\n-    return if (obj is RealmObjectProxy) {\n-        val proxy = obj as RealmObjectProxy\n-        val realm = proxy.`realmGet$proxyState`().`realm$realm`\n-\n-        when (realm) {\n-            is Realm -> flowFromRealm<T>(realm, obj)\n-            is DynamicRealm -> {\n-                val dynamicObject = obj as DynamicRealmObject\n-                flowFromDynamicRealm(realm, dynamicObject) as Flow<T>\n-            }\n-            else -> throw UnsupportedOperationException(\"${realm.javaClass} does not support RxJava. See https://realm.io/docs/java/latest/#rxjava for more details.\")\n-        }\n-    } else {\n-        return flowOf(this)\n-    }\n-}\n-\n-private fun <T : RealmModel> flowFromRealm(realm: Realm, obj: T): Flow<T> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (realm.isFrozen) {\n-        return flowOf(obj)\n-    }\n-\n-    val config = realm.configuration\n-\n-    return callbackFlow<T> {\n-        // Do nothing if the object is invalid\n-        if (!obj.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<T> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        obj.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(obj))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                obj.removeChangeListener(listener)\n-                flowRealm.close()\n-            }\n-        }\n-    }\n-}\n-\n-private fun flowFromDynamicRealm(\n-        dynamicRealm: DynamicRealm,\n-        dynamicObject: DynamicRealmObject\n-): Flow<DynamicRealmObject> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (dynamicRealm.isFrozen) {\n-        return flowOf(dynamicObject)\n-    }\n-\n-    val config = dynamicRealm.configuration\n-\n-    return callbackFlow<DynamicRealmObject> {\n-        // Do nothing if the object is invalid\n-        if (!dynamicObject.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<DynamicRealmObject> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        dynamicObject.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(dynamicObject))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                dynamicObject.removeChangeListener(listener)\n-                flowRealm.close()\n+fun <T : RealmModel> T?.toFlow(): Flow<T?> {\n+    // Return flow with object or null flow if this function is called on null\n+    return this?.let { obj ->\n+        if (obj is RealmObjectProxy) {\n+            val proxy = obj as RealmObjectProxy\n+\n+            @Suppress(\"INACCESSIBLE_TYPE\")\n+            when (val realm = proxy.`realmGet$proxyState`().`realm$realm`) {\n+                is Realm -> realm.configuration.flowFactory?.from<T>(realm, obj)\n+                        ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")\n+                is DynamicRealm ->\n+                    (obj as DynamicRealmObject).let { dynamicRealmObject ->\n+                        (realm.configuration.flowFactory?.from(realm, dynamicRealmObject)\n+                                ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")) as Flow<T?>\n+                    }\n+                else -> throw UnsupportedOperationException(\"${realm.javaClass} is not supported as a candidate for 'toFlow'. Only subclasses of RealmModel/RealmObject can be used.\")\n             }\n+        } else {\n+            return flowOf(this)\n         }\n-    }\n+    } ?: flowOf(null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c"}, "originalPosition": 129}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe9fd64231c1aeb639f8b83311003eb2ce856868", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/fe9fd64231c1aeb639f8b83311003eb2ce856868", "committedDate": "2020-11-13T11:05:06Z", "message": "Added check for null rx and flow factories in config builder, added check for flows present in classpath, added missing null factory checks, added missing docs and cleaned up a bit"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwMDAwNjAx", "url": "https://github.com/realm/realm-java/pull/7191#pullrequestreview-530000601", "createdAt": "2020-11-13T11:53:44Z", "commit": {"oid": "fe9fd64231c1aeb639f8b83311003eb2ce856868"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMTo1Mzo0NFrOHyrg2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMTo1NDowM1rOHyrhXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwMzc3MQ==", "bodyText": "Remember to awaitClose {}. And maybe also add a test for that path.\nAccording to #7180.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522903771", "createdAt": "2020-11-13T11:53:44Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Factory class used to create coroutine [Flow]s.\n+ *\n+ * This class is used by default unless overridden in [RealmConfiguration.Builder.flowFactory].\n+ */\n+@Beta\n+class RealmFlowFactory(\n+        private val returnFrozenObjects: Boolean = true\n+) : FlowFactory {\n+\n+    @Beta\n+    override fun from(realm: Realm): Flow<Realm> {\n+        if (realm.isFrozen) {\n+            return flowOf(realm)\n+        }\n+\n+        return callbackFlow {\n+            val flowRealm = Realm.getInstance(realm.configuration)\n+            val listener = RealmChangeListener<Realm> { listenerRealm ->\n+                if (returnFrozenObjects) {\n+                    offer(realm.freeze())\n+                } else {\n+                    offer(listenerRealm)\n+                }\n+            }\n+\n+            flowRealm.addChangeListener(listener)\n+\n+            if (returnFrozenObjects) {\n+                offer(flowRealm.freeze())\n+            } else {\n+                offer(flowRealm)\n+            }\n+\n+            awaitClose {\n+                flowRealm.removeChangeListener(listener)\n+                flowRealm.close()\n+            }\n+        }\n+    }\n+\n+    @Beta\n+    override fun from(dynamicRealm: DynamicRealm): Flow<DynamicRealm> {\n+        if (dynamicRealm.isFrozen) {\n+            return flowOf(dynamicRealm)\n+        }\n+\n+        return callbackFlow {\n+            val flowRealm = DynamicRealm.getInstance(dynamicRealm.configuration)\n+            val listener = RealmChangeListener<DynamicRealm> { listenerRealm ->\n+                if (returnFrozenObjects) {\n+                    offer(dynamicRealm.freeze())\n+                } else {\n+                    offer(listenerRealm)\n+                }\n+            }\n+\n+            flowRealm.addChangeListener(listener)\n+\n+            if (returnFrozenObjects) {\n+                offer(flowRealm.freeze())\n+            } else {\n+                offer(flowRealm)\n+            }\n+\n+            awaitClose {\n+                flowRealm.removeChangeListener(listener)\n+                flowRealm.close()\n+            }\n+        }\n+    }\n+\n+    @Beta\n+    override fun <T> from(realm: Realm, results: RealmResults<T>): Flow<RealmResults<T>> {\n+        // Return \"as is\" if frozen, there will be no listening for changes\n+        if (realm.isFrozen) {\n+            return flowOf(results)\n+        }\n+\n+        val config = realm.configuration\n+\n+        return callbackFlow {\n+            // Do nothing if the results are invalid\n+            if (!results.isValid) {\n+                return@callbackFlow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9fd64231c1aeb639f8b83311003eb2ce856868"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwMzkwMg==", "bodyText": "Same.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522903902", "createdAt": "2020-11-13T11:54:03Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Factory class used to create coroutine [Flow]s.\n+ *\n+ * This class is used by default unless overridden in [RealmConfiguration.Builder.flowFactory].\n+ */\n+@Beta\n+class RealmFlowFactory(\n+        private val returnFrozenObjects: Boolean = true\n+) : FlowFactory {\n+\n+    @Beta\n+    override fun from(realm: Realm): Flow<Realm> {\n+        if (realm.isFrozen) {\n+            return flowOf(realm)\n+        }\n+\n+        return callbackFlow {\n+            val flowRealm = Realm.getInstance(realm.configuration)\n+            val listener = RealmChangeListener<Realm> { listenerRealm ->\n+                if (returnFrozenObjects) {\n+                    offer(realm.freeze())\n+                } else {\n+                    offer(listenerRealm)\n+                }\n+            }\n+\n+            flowRealm.addChangeListener(listener)\n+\n+            if (returnFrozenObjects) {\n+                offer(flowRealm.freeze())\n+            } else {\n+                offer(flowRealm)\n+            }\n+\n+            awaitClose {\n+                flowRealm.removeChangeListener(listener)\n+                flowRealm.close()\n+            }\n+        }\n+    }\n+\n+    @Beta\n+    override fun from(dynamicRealm: DynamicRealm): Flow<DynamicRealm> {\n+        if (dynamicRealm.isFrozen) {\n+            return flowOf(dynamicRealm)\n+        }\n+\n+        return callbackFlow {\n+            val flowRealm = DynamicRealm.getInstance(dynamicRealm.configuration)\n+            val listener = RealmChangeListener<DynamicRealm> { listenerRealm ->\n+                if (returnFrozenObjects) {\n+                    offer(dynamicRealm.freeze())\n+                } else {\n+                    offer(listenerRealm)\n+                }\n+            }\n+\n+            flowRealm.addChangeListener(listener)\n+\n+            if (returnFrozenObjects) {\n+                offer(flowRealm.freeze())\n+            } else {\n+                offer(flowRealm)\n+            }\n+\n+            awaitClose {\n+                flowRealm.removeChangeListener(listener)\n+                flowRealm.close()\n+            }\n+        }\n+    }\n+\n+    @Beta\n+    override fun <T> from(realm: Realm, results: RealmResults<T>): Flow<RealmResults<T>> {\n+        // Return \"as is\" if frozen, there will be no listening for changes\n+        if (realm.isFrozen) {\n+            return flowOf(results)\n+        }\n+\n+        val config = realm.configuration\n+\n+        return callbackFlow {\n+            // Do nothing if the results are invalid\n+            if (!results.isValid) {\n+                return@callbackFlow\n+            }\n+\n+            // Get instance to ensure the Realm is open for as long as we are listening\n+            val flowRealm = Realm.getInstance(config)\n+            val listener = RealmChangeListener<RealmResults<T>> { listenerResults ->\n+                if (returnFrozenObjects) {\n+                    offer(listenerResults.freeze())\n+                } else {\n+                    offer(listenerResults)\n+                }\n+            }\n+\n+            results.addChangeListener(listener)\n+\n+            // Emit current value\n+            if (returnFrozenObjects) {\n+                offer(results.freeze())\n+            } else {\n+                offer(results)\n+            }\n+\n+            awaitClose {\n+                // Remove listener and cleanup\n+                if (!flowRealm.isClosed) {\n+                    results.removeChangeListener(listener)\n+                    flowRealm.close()\n+                }\n+            }\n+        }\n+    }\n+\n+    override fun <T> from(dynamicRealm: DynamicRealm, results: RealmResults<T>): Flow<RealmResults<T>> {\n+        // Return \"as is\" if frozen, there will be no listening for changes\n+        if (dynamicRealm.isFrozen) {\n+            return flowOf(results)\n+        }\n+\n+        val config = dynamicRealm.configuration\n+\n+        return callbackFlow {\n+            // Do nothing if the results are invalid\n+            if (!results.isValid) {\n+                return@callbackFlow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9fd64231c1aeb639f8b83311003eb2ce856868"}, "originalPosition": 153}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3064a573189ba45f4b115deb1ab8b5685d947226", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/3064a573189ba45f4b115deb1ab8b5685d947226", "committedDate": "2020-11-13T13:56:38Z", "message": "Created internal factory in Kotlin and left the default implementation in Java to avoid issues with javadoc, plus added invalid object tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be61d91aa2f10f031f2cb8c62b4b3b542e94515d", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/be61d91aa2f10f031f2cb8c62b4b3b542e94515d", "committedDate": "2020-11-13T14:13:34Z", "message": "Removed conceptually-wrong test, it passed before due not having added the awaitClose to the callbackFlow blocks when invalid results/objects are detected (which was the case, as the realm instance had been closed right before starting collection of the flow for the second time)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39dc648bda9f102501af7d90375f4f4f7fc8a133", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/39dc648bda9f102501af7d90375f4f4f7fc8a133", "committedDate": "2020-11-13T15:47:24Z", "message": "Added changeset methods and tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "462a04b17c2803f9e8ab4cb77029b82b80aaed7b", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/462a04b17c2803f9e8ab4cb77029b82b80aaed7b", "committedDate": "2020-11-16T09:38:39Z", "message": "Added final missing tests plus renamed two wrongly-named ones"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdb3c5ba35b14601f56d299d7f6309819e033de4", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/cdb3c5ba35b14601f56d299d7f6309819e033de4", "committedDate": "2020-11-16T10:33:45Z", "message": "Added missing methods in test factory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e525c24b41d67adcc47cf58c9a6e48562dbda75d", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/e525c24b41d67adcc47cf58c9a6e48562dbda75d", "committedDate": "2020-11-16T11:31:26Z", "message": "Added missing methods in test factory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d59993e4dac2cb4e3a5bdd94c9f3b0c3bd8d8eb", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/7d59993e4dac2cb4e3a5bdd94c9f3b0c3bd8d8eb", "committedDate": "2020-11-16T21:14:01Z", "message": "Changed check for a closed realm instead of invalid object since findFirstAsync always returns \"invalid object\" right away, so we can't use isValid"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMTczNTIx", "url": "https://github.com/realm/realm-java/pull/7191#pullrequestreview-532173521", "createdAt": "2020-11-17T09:30:47Z", "commit": {"oid": "7d59993e4dac2cb4e3a5bdd94c9f3b0c3bd8d8eb"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTozMDo0N1rOH0r7JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTozNzoyMFrOH0sMkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwNzY1Mg==", "bodyText": "Why is there a nullability check here when not for DynamicRealm?", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r525007652", "createdAt": "2020-11-17T09:30:47Z", "author": {"login": "cmelchior"}, "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmExtensions.kt", "diffHunk": "@@ -96,6 +98,18 @@ inline fun <reified T : RealmModel> Realm.createEmbeddedObject(parentObject: Rea\n     return this.createEmbeddedObject(T::class.java, parentObject, parentProperty)\n }\n \n+/**\n+ * Creates a [Flow] for a [Realm]. It should emit the initial state of the Realm when subscribed to and\n+ * on each subsequent update of the Realm.\n+ *\n+ * @return Kotlin [Flow] that emit all updates to the Realm.\n+ */\n+@Beta\n+fun Realm.toflow(): Flow<Realm> {\n+    return configuration.flowFactory?.from(this)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d59993e4dac2cb4e3a5bdd94c9f3b0c3bd8d8eb"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAxMDA0Mg==", "bodyText": "Normally we would do this to prevent accidental bugs to trigger the wrong failure:\nprivate RealmConfiguration.Builder builder =  configFactory.createConfigurationBuilder()\ntry {\n  builder.rxFactory(null)\n} catch (IllegalArgumentException e {\n  //...\n}", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r525010042", "createdAt": "2020-11-17T09:34:23Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java", "diffHunk": "@@ -796,6 +801,120 @@ public void rxFactory() {\n         assertFalse(configuration2.getRxFactory() == dummyFactory);\n     }\n \n+    @Test\n+    public void rxFactory_nullThrows() {\n+        try {\n+            configFactory.createConfigurationBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d59993e4dac2cb4e3a5bdd94c9f3b0c3bd8d8eb"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAxMjExNQ==", "bodyText": "The argument about frozen should also be exposed as a public constructor for this class, as people cannot otherwise customize it.", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r525012115", "createdAt": "2020-11-17T09:37:20Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines;\n+\n+import javax.annotation.Nonnull;\n+\n+import io.realm.DynamicRealm;\n+import io.realm.DynamicRealmObject;\n+import io.realm.Realm;\n+import io.realm.RealmList;\n+import io.realm.RealmModel;\n+import io.realm.RealmResults;\n+import io.realm.annotations.Beta;\n+import io.realm.internal.coroutines.InternalFlowFactory;\n+import io.realm.rx.CollectionChange;\n+import io.realm.rx.ObjectChange;\n+import kotlinx.coroutines.flow.Flow;\n+\n+/**\n+ * Factory class used to create coroutine {@link Flow}s.\n+ *\n+ * This class is used by default unless overridden in {@link io.realm.RealmConfiguration.Builder#flowFactory(FlowFactory}.\n+ */\n+@Beta\n+public class RealmFlowFactory implements FlowFactory {\n+\n+    private final InternalFlowFactory factory = new InternalFlowFactory(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d59993e4dac2cb4e3a5bdd94c9f3b0c3bd8d8eb"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da5f7d9684c139b3ba3d5b63662440c1743aaae7", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/da5f7d9684c139b3ba3d5b63662440c1743aaae7", "committedDate": "2020-11-17T09:48:51Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d0881d3ec4044d6be0ee912842b1eb6ef987cba", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/0d0881d3ec4044d6be0ee912842b1eb6ef987cba", "committedDate": "2020-11-17T10:07:18Z", "message": "Added returnFrozenObjects parameter to factory constructor, added missing documentation and cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "985779d31d5c6609ce9deb5c92f188967c4654c1", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/985779d31d5c6609ce9deb5c92f188967c4654c1", "committedDate": "2020-11-17T10:14:25Z", "message": "Merge branch 'releases' into el/coroutines-factory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b313c854d7a88b73e95719b290d6d75beac6db9", "author": {"user": null}, "url": "https://github.com/realm/realm-java/commit/0b313c854d7a88b73e95719b290d6d75beac6db9", "committedDate": "2020-11-17T10:14:37Z", "message": "Updated changelog"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2190, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}