{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4Njg0NDY1", "number": 6861, "title": "Migrate and reenable SyncedRealmMigrationTests", "bodyText": "", "createdAt": "2020-05-15T16:23:23Z", "url": "https://github.com/realm/realm-java/pull/6861", "merged": true, "mergeCommit": {"oid": "ddf75c9a1a1b662243dc336f16bb8d48e8d093e7"}, "closed": true, "closedAt": "2020-05-25T12:37:21Z", "author": {"login": "rorbech"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABchkj0EgH2gAyNDE4Njg0NDY1OmVjNTk2MDg5NzcwNDNlYzlhMGZiOTI1MzJmNTQyNmVkZmNjNjVhYjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABckuzFNgH2gAyNDE4Njg0NDY1OjkzYjNjMDk1NTBjYzNlOWJiODgyMzhlMzY2NGE1YjE1NWNkMmM1OGQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ec59608977043ec9a0fb92532f5426edfcc65ab7", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/ec59608977043ec9a0fb92532f5426edfcc65ab7", "committedDate": "2020-05-15T16:21:17Z", "message": "Migrate and reenable SyncedRealmMigrationTests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMzI0Nzk4", "url": "https://github.com/realm/realm-java/pull/6861#pullrequestreview-413324798", "createdAt": "2020-05-18T07:13:55Z", "commit": {"oid": "ec59608977043ec9a0fb92532f5426edfcc65ab7"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzoxMzo1NVrOGWqJow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzoxOTowMlrOGWqSfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxMjQ1MQ==", "bodyText": "I think this Rule can largely be replaced with assertFailsWith ?", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r426412451", "createdAt": "2020-05-18T07:13:55Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.IndexedFields\n+import io.realm.entities.PrimaryKeyAsString\n+import io.realm.entities.StringOnly\n+import io.realm.internal.OsObjectSchemaInfo\n+import io.realm.internal.OsRealmConfig\n+import io.realm.internal.OsSchemaInfo\n+import io.realm.internal.OsSharedRealm\n+import org.hamcrest.CoreMatchers\n+import org.junit.*\n+import org.junit.rules.ExpectedException\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Testing methods around migrations for Realms using a [SyncConfiguration].\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmMigrationTests {\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val thrown = ExpectedException.none()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec59608977043ec9a0fb92532f5426edfcc65ab7"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxMzg2MQ==", "bodyText": "Does this needs to be a MutableList? Any reason not to just use val list = listOf(expectedObjectSchema) ?", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r426413861", "createdAt": "2020-05-18T07:17:04Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.IndexedFields\n+import io.realm.entities.PrimaryKeyAsString\n+import io.realm.entities.StringOnly\n+import io.realm.internal.OsObjectSchemaInfo\n+import io.realm.internal.OsRealmConfig\n+import io.realm.internal.OsSchemaInfo\n+import io.realm.internal.OsSharedRealm\n+import org.hamcrest.CoreMatchers\n+import org.junit.*\n+import org.junit.rules.ExpectedException\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Testing methods around migrations for Realms using a [SyncConfiguration].\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmMigrationTests {\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val thrown = ExpectedException.none()\n+\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun migrateRealm_syncConfigurationThrows() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app)).build()\n+        assertFailsWith<IllegalArgumentException> {\n+            Realm.migrateRealm(config)\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema are missing fields. These will be added\n+    // automatically.\n+    @Test\n+    fun addField_worksWithMigrationError() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with missing fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className) // Create empty class\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            assertTrue(realm.schema[className]!!.hasField(StringOnly.FIELD_CHARS)) // Field has been added\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema has more fields than in the model class.\n+    // The underlying field should not be deleted, just hidden.\n+    @Test\n+    fun missingFields_hiddenSilently() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with too many fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className)\n+                        .addField(StringOnly.FIELD_CHARS, String::class.java)\n+                        .addField(\"newField\", String::class.java)\n+                // A schema version has to be set otherwise Object Store will try to initialize the schema again and reach an\n+                // error branch. That is not a real case.\n+                dynamicRealm.version = 0\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            val stringOnlySchema = realm.schema[className]!!\n+            assertTrue(stringOnlySchema.hasField(StringOnly.FIELD_CHARS))\n+            assertTrue(stringOnlySchema.hasField(\"newField\"))\n+            assertEquals(2, stringOnlySchema.fieldNames.size.toLong())\n+        }\n+    }\n+\n+    // Check that a Realm cannot be opened if it contain breaking schema changes, like changing a primary key\n+    @Test\n+    fun breakingSchemaChange_throws() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(PrimaryKeyAsString::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with a different primary key)\n+        val expectedObjectSchema = OsObjectSchemaInfo.Builder(PrimaryKeyAsString.CLASS_NAME, 2, 0)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_PRIMARY_KEY, RealmFieldType.STRING, false, true, false)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_ID, RealmFieldType.INTEGER, true, true, true)\n+                .build()\n+        val list: MutableList<OsObjectSchemaInfo> = ArrayList()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec59608977043ec9a0fb92532f5426edfcc65ab7"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxNDcxOA==", "bodyText": "Instead of the ExpectedException rule, perhaps we should create our own variant of assetFailsWith that takes the expected error string, so you can do something like\nassertFailsWith<IllegalStateException)(\"The following changes cannot be made in additive-only schema mode:\") {\n  Realm.getInstance(config)\n}", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r426414718", "createdAt": "2020-05-18T07:19:02Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.IndexedFields\n+import io.realm.entities.PrimaryKeyAsString\n+import io.realm.entities.StringOnly\n+import io.realm.internal.OsObjectSchemaInfo\n+import io.realm.internal.OsRealmConfig\n+import io.realm.internal.OsSchemaInfo\n+import io.realm.internal.OsSharedRealm\n+import org.hamcrest.CoreMatchers\n+import org.junit.*\n+import org.junit.rules.ExpectedException\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Testing methods around migrations for Realms using a [SyncConfiguration].\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmMigrationTests {\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val thrown = ExpectedException.none()\n+\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun migrateRealm_syncConfigurationThrows() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app)).build()\n+        assertFailsWith<IllegalArgumentException> {\n+            Realm.migrateRealm(config)\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema are missing fields. These will be added\n+    // automatically.\n+    @Test\n+    fun addField_worksWithMigrationError() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with missing fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className) // Create empty class\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            assertTrue(realm.schema[className]!!.hasField(StringOnly.FIELD_CHARS)) // Field has been added\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema has more fields than in the model class.\n+    // The underlying field should not be deleted, just hidden.\n+    @Test\n+    fun missingFields_hiddenSilently() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with too many fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className)\n+                        .addField(StringOnly.FIELD_CHARS, String::class.java)\n+                        .addField(\"newField\", String::class.java)\n+                // A schema version has to be set otherwise Object Store will try to initialize the schema again and reach an\n+                // error branch. That is not a real case.\n+                dynamicRealm.version = 0\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            val stringOnlySchema = realm.schema[className]!!\n+            assertTrue(stringOnlySchema.hasField(StringOnly.FIELD_CHARS))\n+            assertTrue(stringOnlySchema.hasField(\"newField\"))\n+            assertEquals(2, stringOnlySchema.fieldNames.size.toLong())\n+        }\n+    }\n+\n+    // Check that a Realm cannot be opened if it contain breaking schema changes, like changing a primary key\n+    @Test\n+    fun breakingSchemaChange_throws() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(PrimaryKeyAsString::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with a different primary key)\n+        val expectedObjectSchema = OsObjectSchemaInfo.Builder(PrimaryKeyAsString.CLASS_NAME, 2, 0)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_PRIMARY_KEY, RealmFieldType.STRING, false, true, false)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_ID, RealmFieldType.INTEGER, true, true, true)\n+                .build()\n+        val list: MutableList<OsObjectSchemaInfo> = ArrayList()\n+        list.add(expectedObjectSchema)\n+        val schemaInfo = OsSchemaInfo(list)\n+        val configBuilder = OsRealmConfig.Builder(config).schemaInfo(schemaInfo)\n+        OsSharedRealm.getInstance(configBuilder, OsSharedRealm.VersionID.LIVE).close()\n+        thrown.expectMessage(\n+                CoreMatchers.containsString(\"The following changes cannot be made in additive-only schema mode:\"))\n+        thrown.expect(IllegalStateException::class.java)\n+        Realm.getInstance(config)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec59608977043ec9a0fb92532f5426edfcc65ab7"}, "originalPosition": 143}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13aa71f2a8ba5b0e07eef39712fc82c54cf0c663", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/13aa71f2a8ba5b0e07eef39712fc82c54cf0c663", "committedDate": "2020-05-18T20:20:58Z", "message": "Review comments updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c08e9b8a946c7ac83f2aeabaf92775c0b6872cf", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/0c08e9b8a946c7ac83f2aeabaf92775c0b6872cf", "committedDate": "2020-05-18T20:21:29Z", "message": "Merge branch 'v10' into cr/sync-test-migration-syncedrealmmigration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93b3c09550cc3e9bb88238e3664a5b155cd2c58d", "author": {"user": {"login": "rorbech", "name": "Claus R\u00f8rbech"}}, "url": "https://github.com/realm/realm-java/commit/93b3c09550cc3e9bb88238e3664a5b155cd2c58d", "committedDate": "2020-05-25T11:58:47Z", "message": "Merge branch 'v10' into cr/sync-test-migration-syncedrealmmigration"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2541, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}