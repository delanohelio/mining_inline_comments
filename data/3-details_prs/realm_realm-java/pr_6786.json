{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0NjI0Mjg4", "number": 6786, "title": "Add support for ApiKeyAuthProvider", "bodyText": "Depends on #6783 being merged first.\nThis PR adds support for the ApiKeyAuthProvider with the following methods:\n\ncreateApiKey(name: String): RealmUserApiKey\nfetchApiKey(id: ObjectId): RealmUserApiKey\nfetchAllApiKeys(): List<RealmUserApiKey>\ndeleteApiKey(id: ObjectId): Void\nenableApiKey(id: ObjectId): Void\ndeleteApiKey(id: ObjectId): Void\n\nA new wrapper class representing the key has been introduced as well:\nclass RealmUserApiKey {\n  val id: ObjectId\n  val name: String\n  val value?: String\n  val enabled: boolean\n}\n\nNote, the server sends a \"disabled\" key. This has been reversed in the API to enabled as exposing negative booleans is generally discouraged.", "createdAt": "2020-03-27T08:43:16Z", "url": "https://github.com/realm/realm-java/pull/6786", "merged": true, "mergeCommit": {"oid": "0d0bc5a2e5f785495db4a692f8e929eaf4ae4ea4"}, "closed": true, "closedAt": "2020-04-03T13:28:22Z", "author": {"login": "cmelchior"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRsjQyAH2gAyMzk0NjI0Mjg4OjM5MmE2ZTExYjNhYTFmYzZhZmM2ZGQxYmJjNzAxODZhNGQ4MTY4OWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcUAv1egFqTM4NzI0NTA5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "392a6e11b3aa1fc6afc6dd1bbc70186a4d81689f", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/392a6e11b3aa1fc6afc6dd1bbc70186a4d81689f", "committedDate": "2020-03-27T08:37:08Z", "message": "Add support for ApiKeyAuthProvider"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5137c16ae8e151b471790a14a4c499ddc902904c", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/5137c16ae8e151b471790a14a4c499ddc902904c", "committedDate": "2020-03-29T21:50:41Z", "message": "Merge branch 'v10' into cm/app/apikeyauthprovider\n\n# Conflicts:\n#\trealm/realm-library/src/main/cpp/CMakeLists.txt\n#\trealm/realm-library/src/objectServer/java/io/realm/RealmApp.java\n#\trealm/realm-library/src/testUtils/java/io/realm/TestHelper.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59a0cd0c111216375910a78209da24f4a34b5007", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/59a0cd0c111216375910a78209da24f4a34b5007", "committedDate": "2020-04-01T08:03:48Z", "message": "Merge branch 'v10' into cm/app/apikeyauthprovider\n\n# Conflicts:\n#\trealm/realm-library/src/objectServer/java/io/realm/RealmUser.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a3951c9c135046ed066e64f8adcc136b67c4b42", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/2a3951c9c135046ed066e64f8adcc136b67c4b42", "committedDate": "2020-04-01T11:27:41Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f1478fb24493f10fe7f668825a6b70ba5bc9e89", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/0f1478fb24493f10fe7f668825a6b70ba5bc9e89", "committedDate": "2020-04-01T11:31:31Z", "message": "Bump minSdk for kotlin-extensions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75", "committedDate": "2020-04-01T11:48:30Z", "message": "Set minSdk for examples"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MjYzMzIx", "url": "https://github.com/realm/realm-java/pull/6786#pullrequestreview-386263321", "createdAt": "2020-04-02T09:40:32Z", "commit": {"oid": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo0MDozM1rOF_jUoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo0MDozM1rOF_jUoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4MzMyOQ==", "bodyText": "It can be", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402183329", "createdAt": "2020-04-02T09:40:33Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MjY1MDk3", "url": "https://github.com/realm/realm-java/pull/6786#pullrequestreview-386265097", "createdAt": "2020-04-02T09:42:55Z", "commit": {"oid": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo0Mjo1NVrOF_jaag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo0Mjo1NVrOF_jaag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4NDgxMA==", "bodyText": "Not sure I understand The keys value. Do you mean the value of the key?", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402184810", "createdAt": "2020-04-02T09:42:55Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MjY1MjMw", "url": "https://github.com/realm/realm-java/pull/6786#pullrequestreview-386265230", "createdAt": "2020-04-02T09:43:05Z", "commit": {"oid": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo0MzowNlrOF_ja1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo0MzowNlrOF_ja1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4NDkxNw==", "bodyText": "Same as above.", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402184917", "createdAt": "2020-04-02T09:43:06Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MjY1NjAz", "url": "https://github.com/realm/realm-java/pull/6786#pullrequestreview-386265603", "createdAt": "2020-04-02T09:43:31Z", "commit": {"oid": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo0MzozMVrOF_jb-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo0MzozMVrOF_jb-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4NTIwOA==", "bodyText": "It can be", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402185208", "createdAt": "2020-04-02T09:43:31Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75"}, "originalPosition": 90}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MjY1ODYy", "url": "https://github.com/realm/realm-java/pull/6786#pullrequestreview-386265862", "createdAt": "2020-04-02T09:43:52Z", "commit": {"oid": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo0Mzo1MlrOF_jctg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo0Mzo1MlrOF_jctg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4NTM5OA==", "bodyText": "this this", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402185398", "createdAt": "2020-04-02T09:43:52Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @param callback callback when key creation has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MjY4NjQ4", "url": "https://github.com/realm/realm-java/pull/6786#pullrequestreview-386268648", "createdAt": "2020-04-02T09:47:44Z", "commit": {"oid": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "committedDate": "2020-04-02T12:54:44Z", "message": "Doc updates"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NTQyNjcz", "url": "https://github.com/realm/realm-java/pull/6786#pullrequestreview-386542673", "createdAt": "2020-04-02T15:29:58Z", "commit": {"oid": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyOTo1OFrOF_w5Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMDozMDoyNlrOGABIBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNTY1NQ==", "bodyText": "is the order of keys guarantee/stable ?", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402405655", "createdAt": "2020-04-02T15:29:58Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/ApiKeyAuthProviderTests.kt", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.admin.ServerAdmin\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Assert.*\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+\n+@RunWith(AndroidJUnit4::class)\n+class ApiKeyAuthProviderTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+    private lateinit var app: TestRealmApp\n+    private lateinit var admin: ServerAdmin\n+    private lateinit var user: RealmUser\n+    private lateinit var provider: ApiKeyAuthProvider\n+\n+    // Callback use to verify that an Illegal Argument was thrown from async methods\n+    private val checkNullInVoidCallback = RealmApp.Callback<Void> { result ->\n+        if (result.isSuccess) {\n+            fail()\n+        } else {\n+            assertEquals(ErrorCode.UNKNOWN, result.error.errorCode)\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    private val checkNullInApiKeyCallback = RealmApp.Callback<RealmUserApiKey> { result ->\n+        if (result.isSuccess) {\n+            fail()\n+        } else {\n+            assertEquals(ErrorCode.UNKNOWN, result.error.errorCode)\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    // Methods exposed by the EmailPasswordAuthProvider\n+    enum class Method {\n+        CREATE,\n+        FETCH_SINGLE,\n+        FETCH_ALL,\n+        DELETE,\n+        ENABLE,\n+        DISABLE\n+    }\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        admin = ServerAdmin()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        provider = app.apiKeyAuthProvider\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        app.close()\n+        admin.deleteAllUsers()\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    inline fun testNullArg(method: () -> Unit) {\n+        try {\n+            method()\n+            fail()\n+        } catch (ignore: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun createApiKey() {\n+        val key: RealmUserApiKey = provider.createApiKey(\"my-key\")\n+        assertEquals(\"my-key\", key.name)\n+        assertNotNull(\"my-key\", key.value)\n+        assertNotNull(\"my-key\", key.id)\n+        assertTrue(\"my-key\", key.isEnabled)\n+    }\n+\n+    @Test\n+    fun createApiKey_invalidServerArgsThrows() {\n+        try {\n+            provider.createApiKey(\"%s\")\n+            fail()\n+        } catch (e: ObjectServerError) {\n+            assertEquals(ErrorCode.INVALID_PARAMETER, e.errorCode)\n+        }\n+    }\n+\n+    @Test\n+    fun createApiKey_invalidArgumentThrows() {\n+        testNullArg { provider.createApiKey(TestHelper.getNull()) }\n+        testNullArg { provider.createApiKey(\"\") }\n+        looperThread.runBlocking {\n+            provider.createApiKeyAsync(TestHelper.getNull(), checkNullInApiKeyCallback)\n+        }\n+        looperThread.runBlocking {\n+            provider.createApiKeyAsync(\"\", checkNullInApiKeyCallback)\n+        }\n+    }\n+\n+    @Test\n+    fun createApiKeyAsync() = looperThread.runBlocking {\n+        provider.createApiKeyAsync(\"my-key\") { result ->\n+            val key = result.orThrow\n+            assertEquals(\"my-key\", key.name)\n+            assertNotNull(\"my-key\", key.value)\n+            assertNotNull(\"my-key\", key.id)\n+            assertTrue(\"my-key\", key.isEnabled)\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun createApiKeyAsync_invalidServerArgsThrows() = looperThread.runBlocking {\n+        provider.createApiKeyAsync(\"%s\") { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else {\n+                assertEquals(ErrorCode.INVALID_PARAMETER, result.error.errorCode)\n+                looperThread.testComplete()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun fetchApiKey() {\n+        val key1: RealmUserApiKey = provider.createApiKey(\"my-key\")\n+        val key2: RealmUserApiKey = provider.fetchApiKey(key1.id)\n+\n+        assertEquals(key1.id, key2.id)\n+        assertEquals(key1.name, key2.name)\n+        assertNull(key2.value)\n+        assertEquals(key1.isEnabled, key2.isEnabled)\n+    }\n+\n+    @Test\n+    fun fetchApiKey_nonExistingKey() {\n+        try {\n+            provider.fetchApiKey(ObjectId())\n+            fail()\n+        } catch (e: ObjectServerError) {\n+            assertEquals(ErrorCode.API_KEY_NOT_FOUND, e.errorCode)\n+        }\n+    }\n+\n+    @Test\n+    fun fetchApiKey_invalidArgumentThrows() {\n+        testNullArg { provider.fetchApiKey(TestHelper.getNull()) }\n+        looperThread.runBlocking {\n+            provider.fetchApiKeyAsync(TestHelper.getNull(), checkNullInApiKeyCallback)\n+        }\n+    }\n+\n+    @Test\n+    fun fetchApiKeyAsync() {\n+        val key1: RealmUserApiKey = provider.createApiKey(\"my-key\")\n+        looperThread.runBlocking {\n+            provider.fetchApiKeyAsync(key1.id) { result ->\n+                val key2 = result.orThrow\n+                assertEquals(key1.id, key2.id)\n+                assertEquals(key1.name, key2.name)\n+                assertNull(key2.value)\n+                assertEquals(key1.isEnabled, key2.isEnabled)\n+                looperThread.testComplete()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun fetchAllApiKeys() {\n+        val key1: RealmUserApiKey = provider.createApiKey(\"my-key\")\n+        val key2: RealmUserApiKey = provider.createApiKey(\"other-key\")\n+        val allKeys: List<RealmUserApiKey> = provider.fetchAllApiKeys()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyMjE4OA==", "bodyText": "is the provider considered disabled when the user logs out?", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402422188", "createdAt": "2020-04-02T15:52:59Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmAppTests.kt", "diffHunk": "@@ -267,4 +267,22 @@ class RealmAppTests {\n         } catch (ignore: IllegalStateException) {\n         }\n     }\n+\n+    @Test\n+    fun getApiKeyAuthProvider() {\n+        val user1: RealmUser = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        val provider1: ApiKeyAuthProvider = app.apiKeyAuthProvider\n+        val user2: RealmUser = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        val provider2: ApiKeyAuthProvider = app.apiKeyAuthProvider\n+\n+        assertNotEquals(provider1, provider2)\n+        user2.logOut()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyNTAzOA==", "bodyText": "This is confusing to me, apiKeyAuthProvider should be related to (an API of) RealmUser ... why it is exposed via the RealmApp ?", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402425038", "createdAt": "2020-04-02T15:56:42Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmAppTests.kt", "diffHunk": "@@ -267,4 +267,22 @@ class RealmAppTests {\n         } catch (ignore: IllegalStateException) {\n         }\n     }\n+\n+    @Test\n+    fun getApiKeyAuthProvider() {\n+        val user1: RealmUser = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        val provider1: ApiKeyAuthProvider = app.apiKeyAuthProvider\n+        val user2: RealmUser = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        val provider2: ApiKeyAuthProvider = app.apiKeyAuthProvider\n+\n+        assertNotEquals(provider1, provider2)\n+        user2.logOut()\n+        assertEquals(provider1, app.apiKeyAuthProvider)\n+        user1.logOut()\n+        try {\n+            app.apiKeyAuthProvider", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQzMDcyNg==", "bodyText": "The \"java/lang/Object\" jclass is already looked up in java_class_global_def.hpp,  add definition of\ninline static const jni_util::JavaClass& java_lang_object()\n    {\n        return instance()->m_java_lang_object;\n    }\nand use it here", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402430726", "createdAt": "2020-04-02T16:04:46Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/main/cpp/io_realm_ApiKeyAuthProvider.cpp", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include \"io_realm_ApiKeyAuthProvider.h\"\n+\n+#include \"java_network_transport.hpp\"\n+#include \"util.hpp\"\n+#include \"jni_util/java_method.hpp\"\n+#include \"jni_util/jni_utils.hpp\"\n+#include \"object-store/src/sync/app.hpp\"\n+\n+#include <realm/util/optional.hpp>\n+#include <sync/app.hpp>\n+\n+using namespace realm;\n+using namespace realm::app;\n+using namespace realm::jni_util;\n+using namespace realm::_impl;\n+\n+static jobjectArray map_key(JNIEnv* env, App::UserAPIKey& key)\n+{\n+    jobjectArray arr = (jobjectArray)env->NewObjectArray(4, env->FindClass(\"java/lang/Object\"), NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQzMjk2MA==", "bodyText": "name is required not the key?", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402432960", "createdAt": "2020-04-02T16:07:52Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/main/cpp/io_realm_ApiKeyAuthProvider.cpp", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include \"io_realm_ApiKeyAuthProvider.h\"\n+\n+#include \"java_network_transport.hpp\"\n+#include \"util.hpp\"\n+#include \"jni_util/java_method.hpp\"\n+#include \"jni_util/jni_utils.hpp\"\n+#include \"object-store/src/sync/app.hpp\"\n+\n+#include <realm/util/optional.hpp>\n+#include <sync/app.hpp>\n+\n+using namespace realm;\n+using namespace realm::app;\n+using namespace realm::jni_util;\n+using namespace realm::_impl;\n+\n+static jobjectArray map_key(JNIEnv* env, App::UserAPIKey& key)\n+{\n+    jobjectArray arr = (jobjectArray)env->NewObjectArray(4, env->FindClass(\"java/lang/Object\"), NULL);\n+    if (arr == NULL) {\n+        ThrowException(env, OutOfMemory, \"Could not allocate memory to return API key.\");\n+        return NULL;\n+    }\n+    std::string api_key_id = key.id.to_string();\n+    env->SetObjectArrayElement(arr, 0, to_jstring(env, api_key_id));\n+    env->SetObjectArrayElement(arr, 1, (key.key) ? to_jstring(env, key.key) : NULL);\n+    env->SetObjectArrayElement(arr, 2, to_jstring(env, key.name));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQzNTY2Mg==", "bodyText": "use java_lang_object()", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402435662", "createdAt": "2020-04-02T16:11:52Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/main/cpp/io_realm_ApiKeyAuthProvider.cpp", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include \"io_realm_ApiKeyAuthProvider.h\"\n+\n+#include \"java_network_transport.hpp\"\n+#include \"util.hpp\"\n+#include \"jni_util/java_method.hpp\"\n+#include \"jni_util/jni_utils.hpp\"\n+#include \"object-store/src/sync/app.hpp\"\n+\n+#include <realm/util/optional.hpp>\n+#include <sync/app.hpp>\n+\n+using namespace realm;\n+using namespace realm::app;\n+using namespace realm::jni_util;\n+using namespace realm::_impl;\n+\n+static jobjectArray map_key(JNIEnv* env, App::UserAPIKey& key)\n+{\n+    jobjectArray arr = (jobjectArray)env->NewObjectArray(4, env->FindClass(\"java/lang/Object\"), NULL);\n+    if (arr == NULL) {\n+        ThrowException(env, OutOfMemory, \"Could not allocate memory to return API key.\");\n+        return NULL;\n+    }\n+    std::string api_key_id = key.id.to_string();\n+    env->SetObjectArrayElement(arr, 0, to_jstring(env, api_key_id));\n+    env->SetObjectArrayElement(arr, 1, (key.key) ? to_jstring(env, key.key) : NULL);\n+    env->SetObjectArrayElement(arr, 2, to_jstring(env, key.name));\n+    env->SetObjectArrayElement(arr, 3, JavaClassGlobalDef::new_boolean(env, key.disabled));\n+    return arr;\n+}\n+\n+// Shared mapper function for mapping UserApiKey to Java Object[]\n+static std::function<jobject(JNIEnv*, App::UserAPIKey)> single_key_mapper = [](JNIEnv* env, App::UserAPIKey key) {\n+    return map_key(env, key);\n+};\n+\n+// Shared mapper function for mapping Vector<UserApiKey> to Java Object[][]\n+static std::function<jobject(JNIEnv*, std::vector<App::UserAPIKey>)> multi_key_mapper = [](JNIEnv* env, std::vector<App::UserAPIKey> keys) {\n+    jobjectArray arr = (jobjectArray)env->NewObjectArray(static_cast<jsize>(keys.size()), env->FindClass(\"java/lang/Object\"), NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ0MzI1NQ==", "bodyText": "Is there a length/format requirement of the name we should check for upfront?", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402443255", "createdAt": "2020-04-02T16:23:06Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/main/cpp/io_realm_ApiKeyAuthProvider.cpp", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include \"io_realm_ApiKeyAuthProvider.h\"\n+\n+#include \"java_network_transport.hpp\"\n+#include \"util.hpp\"\n+#include \"jni_util/java_method.hpp\"\n+#include \"jni_util/jni_utils.hpp\"\n+#include \"object-store/src/sync/app.hpp\"\n+\n+#include <realm/util/optional.hpp>\n+#include <sync/app.hpp>\n+\n+using namespace realm;\n+using namespace realm::app;\n+using namespace realm::jni_util;\n+using namespace realm::_impl;\n+\n+static jobjectArray map_key(JNIEnv* env, App::UserAPIKey& key)\n+{\n+    jobjectArray arr = (jobjectArray)env->NewObjectArray(4, env->FindClass(\"java/lang/Object\"), NULL);\n+    if (arr == NULL) {\n+        ThrowException(env, OutOfMemory, \"Could not allocate memory to return API key.\");\n+        return NULL;\n+    }\n+    std::string api_key_id = key.id.to_string();\n+    env->SetObjectArrayElement(arr, 0, to_jstring(env, api_key_id));\n+    env->SetObjectArrayElement(arr, 1, (key.key) ? to_jstring(env, key.key) : NULL);\n+    env->SetObjectArrayElement(arr, 2, to_jstring(env, key.name));\n+    env->SetObjectArrayElement(arr, 3, JavaClassGlobalDef::new_boolean(env, key.disabled));\n+    return arr;\n+}\n+\n+// Shared mapper function for mapping UserApiKey to Java Object[]\n+static std::function<jobject(JNIEnv*, App::UserAPIKey)> single_key_mapper = [](JNIEnv* env, App::UserAPIKey key) {\n+    return map_key(env, key);\n+};\n+\n+// Shared mapper function for mapping Vector<UserApiKey> to Java Object[][]\n+static std::function<jobject(JNIEnv*, std::vector<App::UserAPIKey>)> multi_key_mapper = [](JNIEnv* env, std::vector<App::UserAPIKey> keys) {\n+    jobjectArray arr = (jobjectArray)env->NewObjectArray(static_cast<jsize>(keys.size()), env->FindClass(\"java/lang/Object\"), NULL);\n+    if (arr == NULL) {\n+        ThrowException(env, OutOfMemory, \"Could not allocate memory to return list of API keys.\");\n+        return arr;\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        env->SetObjectArrayElement(arr, i, map_key(env, keys[i]));\n+    }\n+    return arr;\n+};\n+\n+JNIEXPORT void JNICALL Java_io_realm_ApiKeyAuthProvider_nativeCallFunction(JNIEnv* env,\n+                                                                           jclass,\n+                                                                           jint j_function_type,\n+                                                                           jlong j_app_ptr,\n+                                                                           jlong j_user_ptr,\n+                                                                           jstring j_arg,\n+                                                                           jobject j_callback)\n+{\n+    try {\n+        App* app = reinterpret_cast<App*>(j_app_ptr);\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_user_ptr);\n+        auto client = app->provider_client<App::UserAPIKeyProviderClient>();\n+        switch(j_function_type) {\n+            case io_realm_ApiKeyAuthProvider_TYPE_CREATE: {\n+                JStringAccessor name(env, j_arg);\n+                auto callback = JavaNetworkTransport::create_result_callback(env, j_callback, single_key_mapper);\n+                client.create_api_key(name, user, callback);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ0NjA4OA==", "bodyText": "add\ninline static const jni_util::JavaClass& java_lang_object()\n    {\n        return instance()->m_java_lang_object;\n    }\nto be used", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402446088", "createdAt": "2020-04-02T16:27:33Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/main/cpp/java_class_global_def.hpp", "diffHunk": "@@ -61,6 +62,7 @@ class JavaClassGlobalDef {\n     jni_util::JavaClass m_java_util_date;\n     jni_util::JavaClass m_java_lang_string;\n     jni_util::JavaClass m_java_lang_boolean;\n+    jni_util::JavaClass m_java_lang_object;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2ODY2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param callback callback used when the the key was fetched or the call failed. The callback\n          \n          \n            \n                 * @param callback callback used when the key was fetched or the call failed. The callback", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402668662", "createdAt": "2020-04-03T00:19:45Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @param callback callback when key creation has completed or failed. The callback will always\n+     * happen on the same thread as this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask createApiKeyAsync(String name, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous creation of api keys are only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return createApiKey(name);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @throws ObjectServer if the server failed to fetch the API key.\n+     */\n+    public RealmUserApiKey fetchApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_SINGLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @param callback callback used when the the key was fetched or the call failed. The callback", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTI3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param callback callback used when the the keys were fetched or the call failed. The callback\n          \n          \n            \n                 * @param callback callback used when the keys were fetched or the call failed. The callback", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402669273", "createdAt": "2020-04-03T00:22:12Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @param callback callback when key creation has completed or failed. The callback will always\n+     * happen on the same thread as this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask createApiKeyAsync(String name, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous creation of api keys are only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return createApiKey(name);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @throws ObjectServer if the server failed to fetch the API key.\n+     */\n+    public RealmUserApiKey fetchApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_SINGLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @param callback callback used when the the key was fetched or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask fetchApiKeyAsync(ObjectId id, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous fetching an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return fetchApiKey(id);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @throws ObjectServer if the server failed to fetch the API keys.\n+     */\n+    public List<RealmUserApiKey> fetchAllApiKeys() throws ObjectServerError {\n+        AtomicReference<List<RealmUserApiKey>> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_ALL, user.getApp().nativePtr, user.osUser.getNativePtr(), null, new RealmApp.OsJNIResultCallback<List<RealmUserApiKey>>(success, error) {\n+            @Override\n+            protected List<RealmUserApiKey> mapSuccess(Object result) {\n+                Object[] keyData = (Object[]) result;\n+                List<RealmUserApiKey> list = new ArrayList<>();\n+                for (int i = 0; i < keyData.length; i++) {\n+                    list.add(createKeyFromNative((Object[]) keyData[i]));\n+                }\n+                return list;\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @param callback callback used when the the keys were fetched or the call failed. The callback", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDQ3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param callback callback used when the the key was deleted or the call failed. The callback\n          \n          \n            \n                 * @param callback callback used when the key was deleted or the call failed. The callback", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402670470", "createdAt": "2020-04-03T00:26:31Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @param callback callback when key creation has completed or failed. The callback will always\n+     * happen on the same thread as this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask createApiKeyAsync(String name, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous creation of api keys are only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return createApiKey(name);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @throws ObjectServer if the server failed to fetch the API key.\n+     */\n+    public RealmUserApiKey fetchApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_SINGLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @param callback callback used when the the key was fetched or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask fetchApiKeyAsync(ObjectId id, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous fetching an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return fetchApiKey(id);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @throws ObjectServer if the server failed to fetch the API keys.\n+     */\n+    public List<RealmUserApiKey> fetchAllApiKeys() throws ObjectServerError {\n+        AtomicReference<List<RealmUserApiKey>> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_ALL, user.getApp().nativePtr, user.osUser.getNativePtr(), null, new RealmApp.OsJNIResultCallback<List<RealmUserApiKey>>(success, error) {\n+            @Override\n+            protected List<RealmUserApiKey> mapSuccess(Object result) {\n+                Object[] keyData = (Object[]) result;\n+                List<RealmUserApiKey> list = new ArrayList<>();\n+                for (int i = 0; i < keyData.length; i++) {\n+                    list.add(createKeyFromNative((Object[]) keyData[i]));\n+                }\n+                return list;\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @param callback callback used when the the keys were fetched or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask fetchAllApiKeys(RealmApp.Callback<List<RealmUserApiKey>> callback) {\n+        Util.checkLooperThread(\"Asynchronous fetching an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<List<RealmUserApiKey>>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public List<RealmUserApiKey> run() throws ObjectServerError {\n+                return fetchAllApiKeys();\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Deletes a specific API key created by the user.\n+     *\n+     * @param id the id of the key to delete.\n+     * @throws ObjectServer if the server failed to delete the API key.\n+     */\n+    public void deleteApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_DELETE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIVoidResultCallback(error));\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Deletes a specific API key created by the user.\n+     *\n+     * @param id the id of the key to delete.\n+     * @param callback callback used when the the key was deleted or the call failed. The callback", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTYyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param callback callback used when the the key was enabled or the call failed. The callback\n          \n          \n            \n                 * @param callback callback used when the key was enabled or the call failed. The callback", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402671620", "createdAt": "2020-04-03T00:30:26Z", "author": {"login": "nhachicha"}, "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @param callback callback when key creation has completed or failed. The callback will always\n+     * happen on the same thread as this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask createApiKeyAsync(String name, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous creation of api keys are only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return createApiKey(name);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @throws ObjectServer if the server failed to fetch the API key.\n+     */\n+    public RealmUserApiKey fetchApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_SINGLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @param callback callback used when the the key was fetched or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask fetchApiKeyAsync(ObjectId id, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous fetching an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return fetchApiKey(id);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @throws ObjectServer if the server failed to fetch the API keys.\n+     */\n+    public List<RealmUserApiKey> fetchAllApiKeys() throws ObjectServerError {\n+        AtomicReference<List<RealmUserApiKey>> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_ALL, user.getApp().nativePtr, user.osUser.getNativePtr(), null, new RealmApp.OsJNIResultCallback<List<RealmUserApiKey>>(success, error) {\n+            @Override\n+            protected List<RealmUserApiKey> mapSuccess(Object result) {\n+                Object[] keyData = (Object[]) result;\n+                List<RealmUserApiKey> list = new ArrayList<>();\n+                for (int i = 0; i < keyData.length; i++) {\n+                    list.add(createKeyFromNative((Object[]) keyData[i]));\n+                }\n+                return list;\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @param callback callback used when the the keys were fetched or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask fetchAllApiKeys(RealmApp.Callback<List<RealmUserApiKey>> callback) {\n+        Util.checkLooperThread(\"Asynchronous fetching an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<List<RealmUserApiKey>>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public List<RealmUserApiKey> run() throws ObjectServerError {\n+                return fetchAllApiKeys();\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Deletes a specific API key created by the user.\n+     *\n+     * @param id the id of the key to delete.\n+     * @throws ObjectServer if the server failed to delete the API key.\n+     */\n+    public void deleteApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_DELETE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIVoidResultCallback(error));\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Deletes a specific API key created by the user.\n+     *\n+     * @param id the id of the key to delete.\n+     * @param callback callback used when the the key was deleted or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask deleteApiKeyAsync(ObjectId id, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous deleting an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                deleteApiKey(id);\n+                return null;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Disables a specific API key created by the user.\n+     *\n+     * @param id the id of the key to disable.\n+     * @throws ObjectServer if the server failed to disable the API key.\n+     */\n+    public void disableApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_DISABLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIVoidResultCallback(error));\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Disables a specific API key created by the user.\n+     *\n+     * @param id the id of the key to disable.\n+     * @param callback callback used when the the key was disabled or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask disableApiKeyAsync(ObjectId id, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous disabling an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                disableApiKey(id);\n+                return null;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Enables a specific API key created by the user.\n+     *\n+     * @param id the id of the key to enable.\n+     * @throws ObjectServer if the server failed to enable the API key.\n+     */\n+    public void enableApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_ENABLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIVoidResultCallback(error));\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Enables a specific API key created by the user.\n+     *\n+     * @param id the id of the key to enable.\n+     * @param callback callback used when the the key was enabled or the call failed. The callback", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43"}, "originalPosition": 265}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b941b1817dfe13a62a13f30155f0d14291467789", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/b941b1817dfe13a62a13f30155f0d14291467789", "committedDate": "2020-04-03T08:57:17Z", "message": "PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e489725fa9f14496990ccb6d0ec0140bb68ad9ac", "author": {"user": {"login": "cmelchior", "name": "Christian Melchior"}}, "url": "https://github.com/realm/realm-java/commit/e489725fa9f14496990ccb6d0ec0140bb68ad9ac", "committedDate": "2020-04-03T08:59:31Z", "message": "Missed using global def"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MjQ1MDky", "url": "https://github.com/realm/realm-java/pull/6786#pullrequestreview-387245092", "createdAt": "2020-04-03T13:16:49Z", "commit": {"oid": "e489725fa9f14496990ccb6d0ec0140bb68ad9ac"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2468, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}