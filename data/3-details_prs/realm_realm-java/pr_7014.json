{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyMDI0Mzg1", "number": 7014, "title": "Add support for watch collection watch streams", "bodyText": "It allows to watch collections synchronously. Asynchronous support being developed\nThis feature is handled in Java, object-store just helps through the process. Sequence:\n\nA RealmStreamTask is created when we watch a collection. It provides sync and async access to the change event stream.\nWhen we start requesting events, Realm-java generates via the object-store a streaming request for the given collection Request App::make_streaming_request.\nRealm-java triggers the streaming request via OkHttpNetworkTransport.\nWith this response we create an EventStream that will pass the network response input to the WatchStream helper.\nWhen the WatchStream helper will consume data until it generates a ChangeEvent sequence.\n\nRenamed branch, original PR: #6999", "createdAt": "2020-08-03T08:15:50Z", "url": "https://github.com/realm/realm-java/pull/7014", "merged": true, "mergeCommit": {"oid": "134e039480c5d8152f839f99f2cf92e62ff516d3"}, "closed": true, "closedAt": "2020-08-25T08:54:57Z", "author": {"login": "clementetb"}, "timelineItems": {"totalCount": 55, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3JaBSgH2gAyNDYyMDI0Mzg1OjdmNDUwNDRmYzNjOTVkNWNkOTJhMjE1MTcwNzJiZWNmM2FiN2YxMTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCTTiMgH2gAyNDYyMDI0Mzg1OmI2NDMwMzMzYjE4ZjQ3OGVlZmQ2MGI3YTZlMGEzYTllZGM4MWRlNjA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7f45044fc3c95d5cd92a21517072becf3ab7f110", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/7f45044fc3c95d5cd92a21517072becf3ab7f110", "committedDate": "2020-07-21T17:09:29Z", "message": "Support collection watch synchronously"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd0efe5b4787c8e8be64a341ad010cb959151184", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/fd0efe5b4787c8e8be64a341ad010cb959151184", "committedDate": "2020-07-22T10:36:15Z", "message": "Update realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsWatchStream.java\n\nCo-authored-by: Eduardo L\u00f3pez <1874445+edualonso@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c32124417cba73e2dfe2dc5025e9b6219fa2947c", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/c32124417cba73e2dfe2dc5025e9b6219fa2947c", "committedDate": "2020-07-22T10:52:58Z", "message": "Update realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java\n\nCo-authored-by: Eduardo L\u00f3pez <1874445+edualonso@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27e72349e9b96f1a2eabd50e2c3b9faab9eba2d4", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/27e72349e9b96f1a2eabd50e2c3b9faab9eba2d4", "committedDate": "2020-07-24T11:20:19Z", "message": "Encapsulate access to stream functions\nAsync streams"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c9b739364ba33d17e602bad0976fd41ad378d36", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/6c9b739364ba33d17e602bad0976fd41ad378d36", "committedDate": "2020-07-24T15:43:35Z", "message": "Clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdee813124e25e03b57eee816ab5533955ed37cd", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/fdee813124e25e03b57eee816ab5533955ed37cd", "committedDate": "2020-07-24T18:56:35Z", "message": "Introduce ChangeEvent class to handle events"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69d9a2b112ceb635d3146171c9277c5941fd1151", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/69d9a2b112ceb635d3146171c9277c5941fd1151", "committedDate": "2020-07-28T07:44:07Z", "message": "Fix return type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4becb098783519afbda7aacac8bf1bb76a417d8f", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/4becb098783519afbda7aacac8bf1bb76a417d8f", "committedDate": "2020-07-28T09:02:22Z", "message": "Fix findbugs issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7058c79084f09b256deba911632065d563a9111", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/e7058c79084f09b256deba911632065d563a9111", "committedDate": "2020-07-28T09:55:21Z", "message": "Fix missing switch case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4ad81b51d7b958c7ca11c73fc6c26971530c7fe", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/b4ad81b51d7b958c7ca11c73fc6c26971530c7fe", "committedDate": "2020-07-28T10:42:59Z", "message": "Catch http errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5cdaf85343e37d6eef2dd947f684109bd4a7bd8", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/d5cdaf85343e37d6eef2dd947f684109bd4a7bd8", "committedDate": "2020-07-29T13:05:10Z", "message": "Use busy wait instead of sleep"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9419f93684c986b0d0f6a8654d1ba2edd5350b6", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/f9419f93684c986b0d0f6a8654d1ba2edd5350b6", "committedDate": "2020-07-29T16:04:42Z", "message": "Rename events package"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f11fd233b53dda14e503e9ca1462e817a93503f2", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/f11fd233b53dda14e503e9ca1462e817a93503f2", "committedDate": "2020-07-29T22:53:43Z", "message": "Fix class visibility"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6746aec9188603355419d6259d8ef7e9c877cda", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/b6746aec9188603355419d6259d8ef7e9c877cda", "committedDate": "2020-07-30T08:22:08Z", "message": "Improve documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "539d864acee367d2263437022e5cedc727c993d3", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/539d864acee367d2263437022e5cedc727c993d3", "committedDate": "2020-07-30T08:29:42Z", "message": "Improve stream task thread naming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5f97bd95797d978dd10b7ad0c969ea04aecb00e", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/b5f97bd95797d978dd10b7ad0c969ea04aecb00e", "committedDate": "2020-07-30T09:54:45Z", "message": "PR fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "217deac3ec18633a1ee15970c94cabfa35fcdfa8", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/217deac3ec18633a1ee15970c94cabfa35fcdfa8", "committedDate": "2020-07-30T16:53:20Z", "message": "Fix nullpointer when closing okio buffers, as they are not being thread safe \ud83d\ude14"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30ac85113920d4b244c9702212ffdf8b94ca663f", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/30ac85113920d4b244c9702212ffdf8b94ca663f", "committedDate": "2020-07-31T11:48:37Z", "message": "Clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/f11d988aac149a5f946d3a87e14c57d89a09856c", "committedDate": "2020-07-31T13:21:47Z", "message": "Merge branch 'v10' into ct/RJAVA-611"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNjQxODgw", "url": "https://github.com/realm/realm-java/pull/7014#pullrequestreview-460641880", "createdAt": "2020-08-04T09:19:28Z", "commit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNTgwNzAz", "url": "https://github.com/realm/realm-java/pull/7014#pullrequestreview-460580703", "createdAt": "2020-08-04T07:57:10Z", "commit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "state": "COMMENTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwNzo1NzoxMFrOG7VXPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOTo0ODo1MVrOG7ZTJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg2OTE4Mw==", "bodyText": "Is it really needed to do all of this advanced locking inside this method to test the behavior? I would think that just having called the sync method first would be enough?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464869183", "createdAt": "2020-08-04T07:57:10Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/internal/async/RealmStreamTaskImplTest.kt", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.internal.objectserver.EventStream\n+import io.realm.mongodb.mongo.events.BaseChangeEvent\n+import io.realm.rule.BlockingLooperThread\n+import junit.framework.Assert.assertEquals\n+import junit.framework.Assert.fail\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.util.concurrent.locks.ReentrantLock\n+import kotlin.concurrent.thread\n+\n+@RunWith(AndroidJUnit4::class)\n+class RealmStreamTaskImplTest {\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Test\n+    fun syncExclusiveAccess() {\n+        // Validates that we cannot access asynchronously if we are already\n+        // accessing the stream synchronously.\n+\n+        looperThread.runBlocking {\n+            val lock = ReentrantLock()\n+\n+            val syncLoadedCondition = lock.newCondition()\n+            val asyncLoadedCondition = lock.newCondition()\n+\n+            val task = RealmEventStreamTaskImpl(\"test\", object : RealmEventStreamTaskImpl.Executor<String>() {\n+                override fun run(): EventStream<String> {\n+                    return object : EventStream<String> {\n+                        var opened: Boolean = true\n+\n+                        override fun getNextEvent(): BaseChangeEvent<String>? {\n+                            lock.lock()\n+\n+                            syncLoadedCondition.signal()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg2OTU3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464869578", "createdAt": "2020-08-04T07:57:49Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/internal/async/RealmStreamTaskImplTest.kt", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.internal.objectserver.EventStream\n+import io.realm.mongodb.mongo.events.BaseChangeEvent\n+import io.realm.rule.BlockingLooperThread\n+import junit.framework.Assert.assertEquals\n+import junit.framework.Assert.fail\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.util.concurrent.locks.ReentrantLock\n+import kotlin.concurrent.thread\n+\n+@RunWith(AndroidJUnit4::class)\n+class RealmStreamTaskImplTest {\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Test\n+    fun syncExclusiveAccess() {\n+        // Validates that we cannot access asynchronously if we are already\n+        // accessing the stream synchronously.\n+\n+        looperThread.runBlocking {\n+            val lock = ReentrantLock()\n+\n+            val syncLoadedCondition = lock.newCondition()\n+            val asyncLoadedCondition = lock.newCondition()\n+\n+            val task = RealmEventStreamTaskImpl(\"test\", object : RealmEventStreamTaskImpl.Executor<String>() {\n+                override fun run(): EventStream<String> {\n+                    return object : EventStream<String> {\n+                        var opened: Boolean = true\n+\n+                        override fun getNextEvent(): BaseChangeEvent<String>? {\n+                            lock.lock()\n+\n+                            syncLoadedCondition.signal()\n+                            asyncLoadedCondition.await()\n+\n+                            lock.unlock()\n+\n+                            return null\n+                        }\n+\n+                        override fun close() {\n+                            opened = false\n+                        }\n+\n+                        override fun isOpen(): Boolean {\n+                            return opened\n+                        }\n+                    }\n+                }\n+            })\n+\n+            lock.lock()\n+\n+            thread {\n+                task.next\n+                looperThread.testComplete()\n+            }\n+\n+            syncLoadedCondition.await()\n+            lock.unlock()\n+\n+            task.getAsync { result ->\n+                lock.lock()\n+\n+                if (result.isSuccess) {\n+                    fail()\n+                } else {\n+                    assertEquals(io.realm.mongodb.ErrorCode.RUNTIME_EXCEPTION, result.error.errorCode)\n+                }\n+\n+                asyncLoadedCondition.signal()\n+                lock.unlock()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun asyncExclusiveAccess() {\n+        // Validates that we cannot access synchronously if we are already\n+        // accessing the stream asynchronously.\n+\n+        looperThread.runBlocking {\n+            val lock = ReentrantLock()\n+\n+            val syncLoadedCondition = lock.newCondition()\n+            val asyncLoadedCondition = lock.newCondition()\n+\n+            val task = RealmEventStreamTaskImpl(\"test\", object : RealmEventStreamTaskImpl.Executor<String>() {\n+                override fun run(): EventStream<String> {\n+                    return object : EventStream<String> {\n+                        var opened: Boolean = true\n+\n+                        override fun getNextEvent(): BaseChangeEvent<String>? {\n+                            return null\n+                        }\n+\n+                        override fun close() {\n+                            opened = false\n+                        }\n+\n+                        override fun isOpen(): Boolean {\n+                            return opened\n+                        }\n+                    }\n+                }\n+            })\n+\n+            lock.lock()\n+\n+            task.getAsync { result ->\n+                lock.lock()\n+\n+                asyncLoadedCondition.signal()\n+                syncLoadedCondition.await()\n+\n+                lock.unlock()\n+\n+                looperThread.testComplete()\n+            }\n+\n+            asyncLoadedCondition.await()\n+\n+            val exception = kotlin.test.assertFailsWith<RuntimeException> {\n+                task.next\n+            }\n+\n+            assertEquals(\"Resource already open\", exception.message)\n+\n+            syncLoadedCondition.signal()\n+            lock.unlock()\n+        }\n+    }\n+\n+    @Test\n+    fun openClose() {\n+        val task = RealmEventStreamTaskImpl(\"test\", object : RealmEventStreamTaskImpl.Executor<String>() {\n+            override fun run(): EventStream<String> {\n+                return object : EventStream<String> {\n+                    var opened: Boolean = false\n+\n+                    override fun getNextEvent(): BaseChangeEvent<String>? {\n+                        opened = true\n+                        return null\n+                    }\n+\n+                    override fun close() {\n+                        opened = false\n+                    }\n+\n+                    override fun isOpen(): Boolean {\n+                        return opened\n+                    }\n+                }\n+            }\n+        })\n+\n+        assertEquals(false, task.isOpen)\n+        assertEquals(false, task.isCancelled)\n+\n+        task.next\n+\n+        assertEquals(true, task.isOpen)\n+        assertEquals(false, task.isCancelled)\n+\n+        task.cancel()\n+\n+        assertEquals(false, task.isOpen)\n+        assertEquals(true, task.isCancelled)\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3MjYzNw==", "bodyText": "Why the -1 ?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464872637", "createdAt": "2020-08-04T08:03:20Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt", "diffHunk": "@@ -876,6 +885,386 @@ class MongoClientTest {\n         }\n     }\n \n+    fun assertDocumentEquals(expected: Document, actual: Document) {\n+        assertEquals(expected.keys.size, actual.keys.size - 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3NDMzMQ==", "bodyText": "Question: Do we think there is use cases for exposing a public method for this, either as a callback or some kind of wait method (waitUntilReady/waitForOpen/<cannotThinkOfAGoodName>)?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464874331", "createdAt": "2020-08-04T08:06:28Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt", "diffHunk": "@@ -876,6 +885,386 @@ class MongoClientTest {\n         }\n     }\n \n+    fun assertDocumentEquals(expected: Document, actual: Document) {\n+        assertEquals(expected.keys.size, actual.keys.size - 1)\n+\n+        for (key in expected.keys) {\n+            assertTrue(actual.keys.contains(key))\n+            assertEquals(expected[key], actual[key])\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamSynchronous() {\n+        looperThread.runBlocking {\n+            with(getCollectionInternal()) {\n+\n+                val insertedDocument = Document(\"watch\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val updatedDocument = Document(\"watch\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 2\n+                        }\n+\n+\n+                val watcher = this.watch()\n+\n+                thread {\n+                    watcher.next.let { changeEvent ->\n+                        assertEquals(OperationType.INSERT, changeEvent.operationType)\n+                        assertDocumentEquals(insertedDocument, changeEvent.fullDocument!!)\n+                    }\n+\n+                    watcher.next.let { changeEvent ->\n+                        assertEquals(OperationType.REPLACE, changeEvent.operationType)\n+                        assertDocumentEquals(updatedDocument, changeEvent.fullDocument!!)\n+                    }\n+\n+                    watcher.next.let { changeEvent ->\n+                        assertEquals(OperationType.DELETE, changeEvent.operationType)\n+                        assertNull(changeEvent.fullDocument)\n+                    }\n+\n+                    looperThread.testComplete()\n+                }\n+\n+                // Busy wait till watcher is ready to receive updates.\n+                // It syncs the event producer thread (current thread) with\n+                // the event consumer thread.\n+                while (!watcher.isOpen) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwMjkwMQ==", "bodyText": "Isn't there a race condition here? Shouldn't this thread wait for a lock we release after calling watcher.cancel() ?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464902901", "createdAt": "2020-08-04T08:55:28Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt", "diffHunk": "@@ -876,6 +885,386 @@ class MongoClientTest {\n         }\n     }\n \n+    fun assertDocumentEquals(expected: Document, actual: Document) {\n+        assertEquals(expected.keys.size, actual.keys.size - 1)\n+\n+        for (key in expected.keys) {\n+            assertTrue(actual.keys.contains(key))\n+            assertEquals(expected[key], actual[key])\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamSynchronous() {\n+        looperThread.runBlocking {\n+            with(getCollectionInternal()) {\n+\n+                val insertedDocument = Document(\"watch\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val updatedDocument = Document(\"watch\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 2\n+                        }\n+\n+\n+                val watcher = this.watch()\n+\n+                thread {\n+                    watcher.next.let { changeEvent ->\n+                        assertEquals(OperationType.INSERT, changeEvent.operationType)\n+                        assertDocumentEquals(insertedDocument, changeEvent.fullDocument!!)\n+                    }\n+\n+                    watcher.next.let { changeEvent ->\n+                        assertEquals(OperationType.REPLACE, changeEvent.operationType)\n+                        assertDocumentEquals(updatedDocument, changeEvent.fullDocument!!)\n+                    }\n+\n+                    watcher.next.let { changeEvent ->\n+                        assertEquals(OperationType.DELETE, changeEvent.operationType)\n+                        assertNull(changeEvent.fullDocument)\n+                    }\n+\n+                    looperThread.testComplete()\n+                }\n+\n+                // Busy wait till watcher is ready to receive updates.\n+                // It syncs the event producer thread (current thread) with\n+                // the event consumer thread.\n+                while (!watcher.isOpen) {\n+                }\n+\n+                this.insertOne(insertedDocument).get()\n+\n+                val filter = Document(\"watch\", \"1\")\n+                this.updateOne(filter, updatedDocument).get()\n+                this.deleteOne(filter).get()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamDocumentsFilterSynchronous() {\n+        looperThread.runBlocking {\n+            with(getCollectionInternal()) {\n+                val type1 = Document(\"type\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val type2 = Document(\"type\", \"2\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val filter = Document(\"fullDocument.type\", \"1\")\n+                val watcher = this.watchWithFilter(filter)\n+\n+                thread {\n+                    watcher.next.let { changeEvent ->\n+                        assertEquals(OperationType.INSERT, changeEvent.operationType)\n+                        assertEquals(\"1\", changeEvent.fullDocument!![\"type\"])\n+                    }\n+\n+                    watcher.cancel()\n+                    looperThread.testComplete()\n+                }\n+\n+                // Busy wait till watcher is ready to receive updates.\n+                // It syncs the event producer thread (current thread) with\n+                // the event consumer thread.\n+                while (!watcher.isOpen) {\n+                }\n+\n+                this.insertOne(type2).get()\n+                this.insertOne(type1).get()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamBsonDocumentFilterSynchronous() {\n+        looperThread.runBlocking {\n+            with(getCollectionInternal()) {\n+                val type1 = Document(\"type\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val type2 = Document(\"type\", \"2\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val filter = BsonDocument(\"fullDocument.type\", BsonString(\"1\"))\n+                val watcher = this.watchWithFilter(filter)\n+\n+                thread {\n+                    watcher.next.let { changeEvent ->\n+                        assertEquals(OperationType.INSERT, changeEvent.operationType)\n+                        assertEquals(\"1\", changeEvent.fullDocument!![\"type\"])\n+                    }\n+\n+                    watcher.cancel()\n+                    looperThread.testComplete()\n+\n+                }\n+\n+                // Busy wait till watcher is ready to receive updates.\n+                // It syncs the event producer thread (current thread) with\n+                // the event consumer thread.\n+                while (!watcher.isOpen) {\n+                }\n+\n+                this.insertOne(type2).get()\n+                this.insertOne(type1).get()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamObjectIdsSynchronous() {\n+        looperThread.runBlocking {\n+            with(getCollectionInternal()) {\n+                val doc1 = Document(\"document\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val doc2 = Document(\"document\", \"2\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val doc1Id = this.insertOne(doc1).get()\n+                val doc2Id = this.insertOne(doc2).get()\n+\n+                val watcherObjectId = this.watch(doc1Id.insertedId.asObjectId().value)\n+\n+                thread {\n+                    watcherObjectId.next.let { changeEvent ->\n+                        assertEquals(OperationType.REPLACE, changeEvent.operationType)\n+                        assertEquals(\"1\", changeEvent.fullDocument!![\"document\"])\n+                    }\n+                    watcherObjectId.cancel()\n+                    looperThread.testComplete()\n+                }\n+\n+                // Busy wait till watcher is ready to receive updates.\n+                // It syncs the event producer thread (current thread) with\n+                // the event consumer thread.\n+                while (!watcherObjectId.isOpen) {\n+                }\n+\n+                doc1.apply {\n+                    this[\"num\"] = 2\n+                }\n+\n+                doc2.apply {\n+                    this[\"num\"] = 2\n+                }\n+\n+                val filter1 = Document(\"_id\", doc1Id.insertedId)\n+                val filter2 = Document(\"_id\", doc2Id.insertedId)\n+\n+                this.updateOne(filter2, doc2).get()\n+                this.updateOne(filter1, doc1).get()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamIdsSynchronous() {\n+        looperThread.runBlocking {\n+            with(getCollectionInternal()) {\n+                val doc1 = Document(\"document\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val doc2 = Document(\"document\", \"2\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val doc1Id = this.insertOne(doc1).get()\n+                val doc2Id = this.insertOne(doc2).get()\n+\n+                val watcherBsonValue = this.watch(doc1Id.insertedId)\n+\n+                thread {\n+                    watcherBsonValue.next.let { changeEvent ->\n+                        assertEquals(OperationType.REPLACE, changeEvent.operationType)\n+                        assertEquals(\"1\", changeEvent.fullDocument!![\"document\"])\n+                    }\n+\n+                    watcherBsonValue.cancel()\n+                    looperThread.testComplete()\n+                }\n+\n+                // Busy wait till watcher is ready to receive updates.\n+                // It syncs the event producer thread (current thread) with\n+                // the event consumer thread.\n+                while (!watcherBsonValue.isOpen) {\n+                }\n+\n+                doc1.apply {\n+                    this[\"num\"] = 2\n+                }\n+\n+                doc2.apply {\n+                    this[\"num\"] = 2\n+                }\n+\n+                val filter1 = Document(\"_id\", doc1Id.insertedId)\n+                val filter2 = Document(\"_id\", doc2Id.insertedId)\n+\n+                this.updateOne(filter2, doc2).get()\n+                this.updateOne(filter1, doc1).get()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamAsynchronous() {\n+        looperThread.runBlocking {\n+            with(getCollectionInternal()) {\n+                val insertedDocument = Document(\"watch\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val updatedDocument = Document(\"watch\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 2\n+                        }\n+\n+\n+                val watcher = this.watch()\n+\n+                var eventCount = 0\n+                watcher.getAsync { it ->\n+                    if (it.isSuccess) {\n+                        it.get().let { changeEvent ->\n+                            when (eventCount) {\n+                                0 -> {\n+                                    assertEquals(OperationType.INSERT, changeEvent.operationType)\n+                                    assertDocumentEquals(insertedDocument, changeEvent.fullDocument!!)\n+                                }\n+                                1 -> {\n+                                    assertEquals(OperationType.REPLACE, changeEvent.operationType)\n+                                    assertDocumentEquals(updatedDocument, changeEvent.fullDocument!!)\n+                                }\n+                                2 -> {\n+                                    assertEquals(OperationType.DELETE, changeEvent.operationType)\n+                                    assertNull(changeEvent.fullDocument)\n+\n+                                    watcher.cancel()\n+                                }\n+                            }\n+                        }\n+\n+                        eventCount++\n+                    } else {\n+                        when (it.error.errorCode) {\n+                            ErrorCode.NETWORK_IO_EXCEPTION -> looperThread.testComplete()\n+                            else -> fail()\n+                        }\n+                        looperThread.testComplete()\n+                    }\n+                }\n+\n+                // Busy wait till watcher is ready to receive updates.\n+                // It syncs the event producer thread (current thread) with\n+                // the event consumer thread.\n+                while (!watcher.isOpen) {\n+                }\n+\n+                this.insertOne(insertedDocument).get()\n+\n+                val filter = Document(\"watch\", \"1\")\n+                this.updateOne(filter, updatedDocument).get()\n+                this.deleteOne(filter).get()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamCancelSynchronous() {\n+        looperThread.runBlocking {\n+            with(getCollectionInternal()) {\n+                val watcher = this.watch()\n+\n+                thread {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 349}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMTQxMg==", "bodyText": "We shouldn't look this up on every request. If you make it static it only happens once", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464911412", "createdAt": "2020-08-04T09:10:18Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/cpp/io_realm_mongodb_App.cpp", "diffHunk": "@@ -241,3 +242,60 @@ JNIEXPORT void JNICALL Java_io_realm_mongodb_App_nativeSwitchUser(JNIEnv* env,\n     CATCH_STD()\n }\n \n+JNIEXPORT jobject JNICALL Java_io_realm_mongodb_App_nativeMakeStreamingRequest(JNIEnv* env,\n+                                                                  jclass,\n+                                                                  jlong j_app_ptr,\n+                                                                  jlong j_user_ptr,\n+                                                                  jstring j_function_name,\n+                                                                  jstring j_bson_args,\n+                                                                  jstring j_service_name)\n+{\n+    try {\n+        auto app = *reinterpret_cast<std::shared_ptr<App>*>(j_app_ptr);\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_user_ptr);\n+\n+        JStringAccessor function_name(env, j_function_name);\n+        JStringAccessor service_name(env, j_service_name);\n+\n+        bson::BsonArray filter(JniBsonProtocol::parse_checked(env, j_bson_args, Bson::Type::Array, \"BSON filter must be an Array\"));\n+\n+        const Request &request = app->make_streaming_request(user, function_name, filter,\n+                                                             std::string(service_name));\n+\n+        jstring j_method;\n+\n+        switch (request.method){\n+            case HttpMethod::get:\n+                j_method = env->NewStringUTF(\"get\");\n+                break;\n+            case HttpMethod::post:\n+                j_method = env->NewStringUTF(\"post\");\n+                break;\n+            case HttpMethod::patch:\n+                j_method = env->NewStringUTF(\"patch\");\n+                break;\n+            case HttpMethod::put:\n+                j_method = env->NewStringUTF(\"put\");\n+                break;\n+            case HttpMethod::del:\n+                j_method = env->NewStringUTF(\"del\");\n+                break;\n+        }\n+\n+        jstring j_url = env->NewStringUTF(request.url.c_str());\n+        jobject j_headers = JniUtils::to_hashmap(env, request.headers);\n+        jstring j_body = env->NewStringUTF(request.body.c_str());\n+\n+        jclass request_class = env->FindClass(\"io/realm/internal/objectstore/OsJavaNetworkTransport$Request\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMTY0Nw==", "bodyText": "Same", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464911647", "createdAt": "2020-08-04T09:10:43Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/cpp/io_realm_mongodb_App.cpp", "diffHunk": "@@ -241,3 +242,60 @@ JNIEXPORT void JNICALL Java_io_realm_mongodb_App_nativeSwitchUser(JNIEnv* env,\n     CATCH_STD()\n }\n \n+JNIEXPORT jobject JNICALL Java_io_realm_mongodb_App_nativeMakeStreamingRequest(JNIEnv* env,\n+                                                                  jclass,\n+                                                                  jlong j_app_ptr,\n+                                                                  jlong j_user_ptr,\n+                                                                  jstring j_function_name,\n+                                                                  jstring j_bson_args,\n+                                                                  jstring j_service_name)\n+{\n+    try {\n+        auto app = *reinterpret_cast<std::shared_ptr<App>*>(j_app_ptr);\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_user_ptr);\n+\n+        JStringAccessor function_name(env, j_function_name);\n+        JStringAccessor service_name(env, j_service_name);\n+\n+        bson::BsonArray filter(JniBsonProtocol::parse_checked(env, j_bson_args, Bson::Type::Array, \"BSON filter must be an Array\"));\n+\n+        const Request &request = app->make_streaming_request(user, function_name, filter,\n+                                                             std::string(service_name));\n+\n+        jstring j_method;\n+\n+        switch (request.method){\n+            case HttpMethod::get:\n+                j_method = env->NewStringUTF(\"get\");\n+                break;\n+            case HttpMethod::post:\n+                j_method = env->NewStringUTF(\"post\");\n+                break;\n+            case HttpMethod::patch:\n+                j_method = env->NewStringUTF(\"patch\");\n+                break;\n+            case HttpMethod::put:\n+                j_method = env->NewStringUTF(\"put\");\n+                break;\n+            case HttpMethod::del:\n+                j_method = env->NewStringUTF(\"del\");\n+                break;\n+        }\n+\n+        jstring j_url = env->NewStringUTF(request.url.c_str());\n+        jobject j_headers = JniUtils::to_hashmap(env, request.headers);\n+        jstring j_body = env->NewStringUTF(request.body.c_str());\n+\n+        jclass request_class = env->FindClass(\"io/realm/internal/objectstore/OsJavaNetworkTransport$Request\");\n+        jmethodID request_constructor = env->GetMethodID(request_class, \"<init>\",\"(Ljava/lang/String;Ljava/lang/String;Ljava/util/Map;Ljava/lang/String;)V\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMzE4Ng==", "bodyText": "Same as above. Looking up classes is expensive so should be minimized. If a class is used in multiple places we try to pre-load them all in java_class_global_def.hpp. Otherwise making the field static will make sure it is only initialized once.", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464913186", "createdAt": "2020-08-04T09:13:30Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp", "diffHunk": "@@ -65,3 +66,26 @@ void JniUtils::keep_global_ref(JavaGlobalRefByMove& ref)\n     s_instance->m_global_refs.push_back(std::move(ref));\n }\n \n+jobject JniUtils::to_hashmap(JNIEnv* env, std::map<std::string, std::string> map)\n+{\n+    jclass hash_map_class= env->FindClass(\"java/util/HashMap\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMzUyOQ==", "bodyText": "Same", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464913529", "createdAt": "2020-08-04T09:14:05Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp", "diffHunk": "@@ -65,3 +66,26 @@ void JniUtils::keep_global_ref(JavaGlobalRefByMove& ref)\n     s_instance->m_global_refs.push_back(std::move(ref));\n }\n \n+jobject JniUtils::to_hashmap(JNIEnv* env, std::map<std::string, std::string> map)\n+{\n+    jclass hash_map_class= env->FindClass(\"java/util/HashMap\");\n+    jmethodID hash_map_constructor = env->GetMethodID(hash_map_class, \"<init>\", \"(I)V\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMzU4Nw==", "bodyText": "Same", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464913587", "createdAt": "2020-08-04T09:14:11Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp", "diffHunk": "@@ -65,3 +66,26 @@ void JniUtils::keep_global_ref(JavaGlobalRefByMove& ref)\n     s_instance->m_global_refs.push_back(std::move(ref));\n }\n \n+jobject JniUtils::to_hashmap(JNIEnv* env, std::map<std::string, std::string> map)\n+{\n+    jclass hash_map_class= env->FindClass(\"java/util/HashMap\");\n+    jmethodID hash_map_constructor = env->GetMethodID(hash_map_class, \"<init>\", \"(I)V\");\n+    jobject hash_map = env->NewObject(hash_map_class, hash_map_constructor, (jint) map.size());\n+    jmethodID hasMapPut = env->GetMethodID(hash_map_class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMzkxMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Transforms a string map into a string hashmap\n          \n          \n            \n                // Transforms a string map into a Java String HashMap", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464913911", "createdAt": "2020-08-04T09:14:41Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp", "diffHunk": "@@ -46,6 +47,8 @@ class JniUtils {\n     static void detach_current_thread();\n     // Keep the given global reference until JNI_OnUnload is called.\n     static void keep_global_ref(JavaGlobalRefByMove& ref);\n+    // Transforms a string map into a string hashmap", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxNjU4Mg==", "bodyText": "With this implementation, you can still change between Async/Sync execution. I don't know if this was intended?\nE.g ... this would work:\nwatcher.getNext()\nwatcher.getAsync()\n\nIf intended, it should probably be named getNextAsync()? Alternatively, we set a mode boolean when calling either getNext/getAsync() and throw if the wrong get method is called. So you choose a mode when calling the first get method. Thoughts?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464916582", "createdAt": "2020-08-04T09:19:01Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/async/RealmEventStreamTaskImpl.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async;\n+\n+import java.io.IOException;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectserver.EventStream;\n+import io.realm.mongodb.App;\n+import io.realm.mongodb.AppException;\n+import io.realm.mongodb.ErrorCode;\n+import io.realm.mongodb.RealmEventStreamTask;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+public class RealmEventStreamTaskImpl<T> implements RealmEventStreamTask<T> {\n+    private final String name;\n+    private final Executor<T> executor;\n+    private volatile EventStream<T> eventStream;\n+    private volatile boolean isCancelled;\n+    private final ReentrantLock lock;\n+\n+    public RealmEventStreamTaskImpl(final String name, final Executor<T> executor) {\n+        Util.checkNull(executor, \"name\");\n+        Util.checkNull(executor, \"executor\");\n+\n+        this.lock = new ReentrantLock();\n+        this.executor = executor;\n+        this.name = name;\n+    }\n+\n+    synchronized EventStream<T> getEventStream() throws IOException {\n+        if (eventStream == null) {\n+            eventStream = executor.run();\n+        }\n+\n+        return this.eventStream;\n+    }\n+\n+    @Override\n+    public BaseChangeEvent<T> getNext() throws IOException {\n+        if (lock.tryLock()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNDA0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464924042", "createdAt": "2020-08-04T09:32:02Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/internal/async/RealmStreamTaskImplTest.kt", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.internal.objectserver.EventStream\n+import io.realm.mongodb.mongo.events.BaseChangeEvent\n+import io.realm.rule.BlockingLooperThread\n+import junit.framework.Assert.assertEquals\n+import junit.framework.Assert.fail\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.util.concurrent.locks.ReentrantLock\n+import kotlin.concurrent.thread\n+\n+@RunWith(AndroidJUnit4::class)\n+class RealmStreamTaskImplTest {\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Test\n+    fun syncExclusiveAccess() {\n+        // Validates that we cannot access asynchronously if we are already\n+        // accessing the stream synchronously.\n+\n+        looperThread.runBlocking {\n+            val lock = ReentrantLock()\n+\n+            val syncLoadedCondition = lock.newCondition()\n+            val asyncLoadedCondition = lock.newCondition()\n+\n+            val task = RealmEventStreamTaskImpl(\"test\", object : RealmEventStreamTaskImpl.Executor<String>() {\n+                override fun run(): EventStream<String> {\n+                    return object : EventStream<String> {\n+                        var opened: Boolean = true\n+\n+                        override fun getNextEvent(): BaseChangeEvent<String>? {\n+                            lock.lock()\n+\n+                            syncLoadedCondition.signal()\n+                            asyncLoadedCondition.await()\n+\n+                            lock.unlock()\n+\n+                            return null\n+                        }\n+\n+                        override fun close() {\n+                            opened = false\n+                        }\n+\n+                        override fun isOpen(): Boolean {\n+                            return opened\n+                        }\n+                    }\n+                }\n+            })\n+\n+            lock.lock()\n+\n+            thread {\n+                task.next\n+                looperThread.testComplete()\n+            }\n+\n+            syncLoadedCondition.await()\n+            lock.unlock()\n+\n+            task.getAsync { result ->\n+                lock.lock()\n+\n+                if (result.isSuccess) {\n+                    fail()\n+                } else {\n+                    assertEquals(io.realm.mongodb.ErrorCode.RUNTIME_EXCEPTION, result.error.errorCode)\n+                }\n+\n+                asyncLoadedCondition.signal()\n+                lock.unlock()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun asyncExclusiveAccess() {\n+        // Validates that we cannot access synchronously if we are already\n+        // accessing the stream asynchronously.\n+\n+        looperThread.runBlocking {\n+            val lock = ReentrantLock()\n+\n+            val syncLoadedCondition = lock.newCondition()\n+            val asyncLoadedCondition = lock.newCondition()\n+\n+            val task = RealmEventStreamTaskImpl(\"test\", object : RealmEventStreamTaskImpl.Executor<String>() {\n+                override fun run(): EventStream<String> {\n+                    return object : EventStream<String> {\n+                        var opened: Boolean = true\n+\n+                        override fun getNextEvent(): BaseChangeEvent<String>? {\n+                            return null\n+                        }\n+\n+                        override fun close() {\n+                            opened = false\n+                        }\n+\n+                        override fun isOpen(): Boolean {\n+                            return opened\n+                        }\n+                    }\n+                }\n+            })\n+\n+            lock.lock()\n+\n+            task.getAsync { result ->\n+                lock.lock()\n+\n+                asyncLoadedCondition.signal()\n+                syncLoadedCondition.await()\n+\n+                lock.unlock()\n+\n+                looperThread.testComplete()\n+            }\n+\n+            asyncLoadedCondition.await()\n+\n+            val exception = kotlin.test.assertFailsWith<RuntimeException> {\n+                task.next\n+            }\n+\n+            assertEquals(\"Resource already open\", exception.message)\n+\n+            syncLoadedCondition.signal()\n+            lock.unlock()\n+        }\n+    }\n+\n+    @Test\n+    fun openClose() {\n+        val task = RealmEventStreamTaskImpl(\"test\", object : RealmEventStreamTaskImpl.Executor<String>() {\n+            override fun run(): EventStream<String> {\n+                return object : EventStream<String> {\n+                    var opened: Boolean = false\n+\n+                    override fun getNextEvent(): BaseChangeEvent<String>? {\n+                        opened = true\n+                        return null\n+                    }\n+\n+                    override fun close() {\n+                        opened = false\n+                    }\n+\n+                    override fun isOpen(): Boolean {\n+                        return opened\n+                    }\n+                }\n+            }\n+        })\n+\n+        assertEquals(false, task.isOpen)\n+        assertEquals(false, task.isCancelled)\n+\n+        task.next\n+\n+        assertEquals(true, task.isOpen)\n+        assertEquals(false, task.isCancelled)\n+\n+        task.cancel()\n+\n+        assertEquals(false, task.isOpen)\n+        assertEquals(true, task.isCancelled)\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNDkxNQ==", "bodyText": "There are a lot of magic constants here. Is there a spec or something we can refer to for the source of truth for these?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464924915", "createdAt": "2020-08-04T09:33:33Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)\n+                && ((BsonValue) getFullDocument()).isDocument()) {\n+            asDoc.put(Fields.FULL_DOCUMENT_FIELD, (BsonValue) getFullDocument());\n+        }\n+\n+        if (getUpdateDescription() != null) {\n+            asDoc.put(Fields.UPDATE_DESCRIPTION_FIELD, getUpdateDescription().toBsonDocument());\n+        }\n+\n+        asDoc.put(Fields.WRITE_PENDING_FIELD, new BsonBoolean(hasUncommittedWrites()));\n+        return asDoc;\n+    }\n+\n+    /**\n+     * Deserializes a {@link BsonDocument} into an instance of change event.\n+     * @param document the serialized document\n+     * @return the deserialized change event\n+     */\n+    static <T> ChangeEvent<T> fromBsonDocument(final BsonDocument document, final Class<T> documentClass, CodecRegistry codecRegistry) {\n+        keyPresent(Fields.ID_FIELD, document);\n+        keyPresent(Fields.OPERATION_TYPE_FIELD, document);\n+        keyPresent(Fields.NS_FIELD, document);\n+        keyPresent(Fields.DOCUMENT_KEY_FIELD, document);\n+\n+        final BsonDocument nsDoc = document.getDocument(Fields.NS_FIELD);\n+\n+        final UpdateDescription updateDescription;\n+        if (document.containsKey(Fields.UPDATE_DESCRIPTION_FIELD)) {\n+            updateDescription = UpdateDescription.fromBsonDocument(\n+                    document.getDocument(Fields.UPDATE_DESCRIPTION_FIELD)\n+            );\n+        } else {\n+            updateDescription = null;\n+        }\n+\n+        final T fullDocument;\n+\n+        if (document.containsKey(Fields.FULL_DOCUMENT_FIELD)) {\n+            final BsonValue fdVal = document.get(Fields.FULL_DOCUMENT_FIELD);\n+            if (fdVal.isDocument()) {\n+                fullDocument = codecRegistry.get(documentClass).decode(fdVal.asDocument().asBsonReader(), DecoderContext.builder().build());\n+            } else {\n+                fullDocument = null;\n+            }\n+        } else {\n+            fullDocument = null;\n+        }\n+\n+        return new ChangeEvent<>(\n+                document.getDocument(Fields.ID_FIELD),\n+                fromRemote(document.getString(Fields.OPERATION_TYPE_FIELD).getValue()),\n+                fullDocument,\n+                new MongoNamespace(\n+                        nsDoc.getString(Fields.NS_DB_FIELD).getValue(),\n+                        nsDoc.getString(Fields.NS_COLL_FIELD).getValue()),\n+                document.getDocument(Fields.DOCUMENT_KEY_FIELD),\n+                updateDescription,\n+                document.getBoolean(Fields.WRITE_PENDING_FIELD, BsonBoolean.FALSE).getValue());\n+    }\n+\n+    private static final class Fields {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNjkyNA==", "bodyText": "Can we forward the underlying http exception message instead? Sometimes the server sends useful information there. \"Http error code considered fatal\" doesn't really provide anything useful.", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464926924", "createdAt": "2020-08-04T09:37:04Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpNetworkTransport.java", "diffHunk": "@@ -31,47 +34,82 @@ public OkHttpNetworkTransport(@Nullable HttpLogObfuscator httpLogObfuscator) {\n         this.httpLogObfuscator = httpLogObfuscator;\n     }\n \n+    private okhttp3.Request makeRequest(String method, String url, Map<String, String> headers, String body){\n+        okhttp3.Request.Builder builder = new okhttp3.Request.Builder().url(url);\n+        switch (method) {\n+            case \"get\":\n+                builder.get();\n+                break;\n+            case \"delete\":\n+                builder.delete(RequestBody.create(JSON, body));\n+                break;\n+            case \"patch\":\n+                builder.patch(RequestBody.create(JSON, body));\n+                break;\n+            case \"post\":\n+                builder.post(RequestBody.create(JSON, body));\n+                break;\n+            case \"put\":\n+                builder.put(RequestBody.create(JSON, body));\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown method type: \" + method);\n+        }\n+\n+        for (Map.Entry<String, String> entry : headers.entrySet()) {\n+            builder.addHeader(entry.getKey(), entry.getValue());\n+        }\n+\n+        return builder.build();\n+    }\n+\n     @Override\n     public Response sendRequest(String method, String url, long timeoutMs, Map<String, String> headers, String body) {\n         try {\n             OkHttpClient client = getClient(timeoutMs);\n+\n             okhttp3.Response response = null;\n             try {\n-                Request.Builder builder = new Request.Builder().url(url);\n-                switch(method) {\n-                    case \"get\": builder.get(); break;\n-                    case \"delete\": builder.delete(RequestBody.create(JSON, body)); break;\n-                    case \"patch\": builder.patch(RequestBody.create(JSON, body)); break;\n-                    case \"post\": builder.post(RequestBody.create(JSON, body)); break;\n-                    case \"put\": builder.put(RequestBody.create(JSON, body)); break;\n-                    default: throw new IllegalArgumentException(\"Unknown method type: \"+ method);\n-                }\n+                okhttp3.Request request = makeRequest(method, url, headers, body);\n \n-                for (Map.Entry<String, String> entry : headers.entrySet()) {\n-                    builder.addHeader(entry.getKey(), entry.getValue());\n-                }\n-                Call call = client.newCall(builder.build());\n+                Call call = client.newCall(request);\n                 response = call.execute();\n                 ResponseBody responseBody = response.body();\n                 String result = \"\";\n                 if (responseBody != null) {\n                     result = responseBody.string();\n                 }\n-                return Response.httpResponse(response.code(), parseHeaders(response.headers()), result);\n+                return OkHttpResponse.httpResponse(response.code(), parseHeaders(response.headers()), result);\n             } catch (IOException ex) {\n-                return Response.ioError(ex.toString());\n+                return OkHttpResponse.ioError(ex.toString());\n             } catch (Exception ex) {\n-                return Response.unknownError(ex.toString());\n+                return OkHttpResponse.unknownError(ex.toString());\n             } finally {\n                 if (response != null) {\n                     response.close();\n                 }\n             }\n         } catch (Exception e) {\n-            return Response.unknownError(e.toString());\n+            return OkHttpResponse.unknownError(e.toString());\n         }\n     }\n \n+    @Override\n+    public Response sendStreamingRequest(Request request) throws IOException, AppException {\n+        OkHttpClient client = getStreamClient();\n+\n+        okhttp3.Request okRequest = makeRequest(request.getMethod(), request.getUrl(), request.getHeaders(), request.getBody());\n+\n+        Call call = client.newCall(okRequest);\n+        okhttp3.Response response = call.execute();\n+\n+        if((response.code() >= 300) || ((response.code() < 200) && (response.code() != 0))) {\n+            throw new AppException(ErrorCode.fromNativeError(ErrorCode.Type.HTTP, response.code()), \"http error code considered fatal\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNzgxNg==", "bodyText": "It feels a bit awkward and duplicates meaning to have this class named OkHttpResponse since it is already wrapped inside OkHttpNetworkTransport, so it becomes OkHttpNetworkTransport.OkHttpResponse ... OkHttpNetworkTransport.Response seems more readable.", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464927816", "createdAt": "2020-08-04T09:38:34Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpNetworkTransport.java", "diffHunk": "@@ -90,14 +128,87 @@ private synchronized OkHttpClient getClient(long timeoutMs) {\n         return client;\n     }\n \n+    private synchronized OkHttpClient getStreamClient() {\n+        if (streamClient == null) {\n+            streamClient = new OkHttpClient.Builder()\n+                    .readTimeout(0, TimeUnit.MILLISECONDS)\n+                    .followRedirects(true)\n+                    .addInterceptor(new LoggingInterceptor(httpLogObfuscator))\n+                    .build();\n+        }\n+\n+        return streamClient;\n+    }\n+\n     // Parse Headers output from OKHttp to the format expected by ObjectStore\n     private Map<String, String> parseHeaders(Headers headers) {\n-        HashMap<String, String> osHeaders = new HashMap<>(headers.size()/2);\n+        HashMap<String, String> osHeaders = new HashMap<>(headers.size() / 2);\n         for (String key : headers.names()) {\n             osHeaders.put(key, headers.get(key));\n         }\n         return osHeaders;\n     }\n \n+    public static class OkHttpResponse extends OsJavaNetworkTransport.Response {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMTM4Ng==", "bodyText": "Not 100% sure why this is in the App class even when package protected? It feels a bit out of place?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464931386", "createdAt": "2020-08-04T09:44:45Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/App.java", "diffHunk": "@@ -511,16 +514,34 @@ public AppConfiguration getConfiguration() {\n     }\n \n     /**\n-     * Exposed for testing.\n+     * Creates a request for a streaming function\n      *\n+     * @param user         that requests the execution\n+     * @param functionName name of the function\n+     * @param bsonArgs     function arguments as a {@link BsonArray}\n+     * @param serviceName  service that will handle the function\n+     * @return {@link io.realm.internal.objectstore.OsJavaNetworkTransport.Request}\n+     */\n+    OsJavaNetworkTransport.Request makeStreamingRequest(User user,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMjkwOA==", "bodyText": "Having this being public makes it part of the public API, which is probably a mistake?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464932908", "createdAt": "2020-08-04T09:47:26Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/StreamNetworkTransportImpl.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb;\n+\n+import org.bson.BsonArray;\n+\n+import java.io.IOException;\n+\n+import io.realm.internal.network.StreamNetworkTransport;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+public class StreamNetworkTransportImpl extends StreamNetworkTransport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMzU0NA==", "bodyText": "These should probably be wrapped in <a href ... tags to render correctly?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464933544", "createdAt": "2020-08-04T09:48:36Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -805,4 +814,101 @@ public ResultT run() {\n             }\n         });\n     }\n+\n+    /**\n+     * Watches a collection. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch() {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final BsonValue... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection. This convenience overload supports the use case\n+     * of non-{@link BsonValue} instances of {@link ObjectId} by wrapping them in\n+     * {@link BsonObjectId} instances for the user.\n+     *\n+     * @param ids unique object identifiers of the IDs to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final ObjectId... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided document will be used as a match expression filter on\n+     * the change events coming from the stream. This convenience overload supports the use of\n+     * non-{@link BsonDocument} instances for the user.\n+     * <p>\n+     * See https://docs.mongodb.com/manual/reference/operator/aggregation/match/ for documentation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMzYxMg==", "bodyText": "Same", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464933612", "createdAt": "2020-08-04T09:48:43Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -805,4 +814,101 @@ public ResultT run() {\n             }\n         });\n     }\n+\n+    /**\n+     * Watches a collection. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch() {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final BsonValue... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection. This convenience overload supports the use case\n+     * of non-{@link BsonValue} instances of {@link ObjectId} by wrapping them in\n+     * {@link BsonObjectId} instances for the user.\n+     *\n+     * @param ids unique object identifiers of the IDs to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final ObjectId... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided document will be used as a match expression filter on\n+     * the change events coming from the stream. This convenience overload supports the use of\n+     * non-{@link BsonDocument} instances for the user.\n+     * <p>\n+     * See https://docs.mongodb.com/manual/reference/operator/aggregation/match/ for documentation\n+     * around how to define a match filter.\n+     * <p>\n+     * Defining the match expression to filter ChangeEvents is similar to defining the match\n+     * expression for triggers: https://docs.mongodb.com/realm/triggers/database-triggers/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMzY2OQ==", "bodyText": "Same", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464933669", "createdAt": "2020-08-04T09:48:51Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -805,4 +814,101 @@ public ResultT run() {\n             }\n         });\n     }\n+\n+    /**\n+     * Watches a collection. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch() {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final BsonValue... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection. This convenience overload supports the use case\n+     * of non-{@link BsonValue} instances of {@link ObjectId} by wrapping them in\n+     * {@link BsonObjectId} instances for the user.\n+     *\n+     * @param ids unique object identifiers of the IDs to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final ObjectId... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided document will be used as a match expression filter on\n+     * the change events coming from the stream. This convenience overload supports the use of\n+     * non-{@link BsonDocument} instances for the user.\n+     * <p>\n+     * See https://docs.mongodb.com/manual/reference/operator/aggregation/match/ for documentation\n+     * around how to define a match filter.\n+     * <p>\n+     * Defining the match expression to filter ChangeEvents is similar to defining the match\n+     * expression for triggers: https://docs.mongodb.com/realm/triggers/database-triggers/\n+     *\n+     * @param matchFilter the $match filter to apply to incoming change events\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watchWithFilter(Document matchFilter) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watchWithFilter(matchFilter);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided BSON document will be used as a match expression filter on\n+     * the change events coming from the stream.\n+     * <p>\n+     * See https://docs.mongodb.com/manual/reference/operator/aggregation/match/ for documentation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNzg2NjAx", "url": "https://github.com/realm/realm-java/pull/7014#pullrequestreview-460786601", "createdAt": "2020-08-04T12:58:25Z", "commit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf9653563af30491ecdeacc1ce04663c627916ac", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/bf9653563af30491ecdeacc1ce04663c627916ac", "committedDate": "2020-08-10T17:00:57Z", "message": "Implement PR requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "825c53fb171aff79a15bbcbcc5b712d7717df56a", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/825c53fb171aff79a15bbcbcc5b712d7717df56a", "committedDate": "2020-08-11T10:26:56Z", "message": "Remove any stream internal functionality from the public API"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00ce1bc0fd2ee01ab0ccce02e5fa1b8cff8bda4d", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/00ce1bc0fd2ee01ab0ccce02e5fa1b8cff8bda4d", "committedDate": "2020-08-11T11:23:52Z", "message": "Update changelog"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/159bcadff210c5d0cc68440e2d5cee9d563173a6", "committedDate": "2020-08-11T19:39:32Z", "message": "Merge branch 'v10' into ct/watch-event-streams"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NjM3MzYy", "url": "https://github.com/realm/realm-java/pull/7014#pullrequestreview-465637362", "createdAt": "2020-08-12T06:56:42Z", "commit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "state": "COMMENTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNjo1Njo0MlrOG_UNTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoyMjowOVrOG_W6WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA0NDU1OQ==", "bodyText": "Unused import?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469044559", "createdAt": "2020-08-12T06:56:42Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/UserTests.kt", "diffHunk": "@@ -13,15 +13,16 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package io.realm\n+package io.realm.mongodb\n \n import androidx.test.ext.junit.runners.AndroidJUnit4\n import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n import io.realm.admin.ServerAdmin\n-import io.realm.mongodb.*\n import io.realm.mongodb.auth.ApiKeyAuth\n import io.realm.mongodb.auth.UserApiKey\n import io.realm.rule.BlockingLooperThread\n+import org.bson.BsonArray", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA0NzUwNA==", "bodyText": "Unused include?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469047504", "createdAt": "2020-08-12T07:03:24Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/cpp/io_realm_mongodb_App.cpp", "diffHunk": "@@ -24,6 +24,7 @@\n #include <binding_callback_thread_observer.hpp>\n #include <sync/app.hpp>\n #include <sync/sync_manager.hpp>\n+#include <jni_util/bson_util.hpp>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MDY5NA==", "bodyText": "Maybe just Unknown key: %s", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469050694", "createdAt": "2020-08-12T07:10:21Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/java/io/realm/internal/Util.java", "diffHunk": "@@ -220,4 +221,16 @@ public static synchronized boolean isRxJavaAvailable() {\n         return rxJavaAvailable;\n     }\n \n+    /**\n+     * Throw IllegalStateException if key is not present in map.\n+     * @param key the key to expect.\n+     * @param map the map to search.\n+     * @throws IllegalArgumentException if key is not in map.\n+     */\n+    public static void keyPresent(final String key, final Map<String, ?> map) {\n+        if (!map.containsKey(key)) {\n+            throw new IllegalStateException(\n+                    String.format(\"expected %s to be present\", key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MTQ1Nw==", "bodyText": "Funny phrasing.", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469051457", "createdAt": "2020-08-12T07:11:55Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/java/io/realm/internal/Util.java", "diffHunk": "@@ -220,4 +221,16 @@ public static synchronized boolean isRxJavaAvailable() {\n         return rxJavaAvailable;\n     }\n \n+    /**\n+     * Throw IllegalStateException if key is not present in map.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MTYwOQ==", "bodyText": "Does not match exception thrown.", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469051609", "createdAt": "2020-08-12T07:12:12Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/java/io/realm/internal/Util.java", "diffHunk": "@@ -220,4 +221,16 @@ public static synchronized boolean isRxJavaAvailable() {\n         return rxJavaAvailable;\n     }\n \n+    /**\n+     * Throw IllegalStateException if key is not present in map.\n+     * @param key the key to expect.\n+     * @param map the map to search.\n+     * @throws IllegalArgumentException if key is not in map.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MzgwMA==", "bodyText": "Following naming from other check functions would give an immediate impression that this is actually throwing an exception if key is not present.", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469053800", "createdAt": "2020-08-12T07:16:36Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/main/java/io/realm/internal/Util.java", "diffHunk": "@@ -220,4 +221,16 @@ public static synchronized boolean isRxJavaAvailable() {\n         return rxJavaAvailable;\n     }\n \n+    /**\n+     * Throw IllegalStateException if key is not present in map.\n+     * @param key the key to expect.\n+     * @param map the map to search.\n+     * @throws IllegalArgumentException if key is not in map.\n+     */\n+    public static void keyPresent(final String key, final Map<String, ?> map) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzY0Nw==", "bodyText": "Is this semantically correct?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469057647", "createdAt": "2020-08-12T07:24:08Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/async/RealmResultTaskImpl.java", "diffHunk": "@@ -122,6 +122,7 @@ private void postError(RealmNotifier handler,\n             public void run() {\n                 if (!isCancelled) {\n                     callback.onResult(App.Result.withError(error));\n+                    isCancelled = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1OTA2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return the serialized document.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @return the serialized document.", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469059068", "createdAt": "2020-08-12T07:27:01Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MDA5MQ==", "bodyText": "Use local variables for something that is retrieved multiple times.", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469060091", "createdAt": "2020-08-12T07:28:58Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MTMxNQ==", "bodyText": "Maybe considering a specific stream related error code when protocol is not met in ErrorCodes.java instead of propagating the InvalidStateException?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469061315", "createdAt": "2020-08-12T07:31:16Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)\n+                && ((BsonValue) getFullDocument()).isDocument()) {\n+            asDoc.put(Fields.FULL_DOCUMENT_FIELD, (BsonValue) getFullDocument());\n+        }\n+\n+        if (getUpdateDescription() != null) {\n+            asDoc.put(Fields.UPDATE_DESCRIPTION_FIELD, getUpdateDescription().toBsonDocument());\n+        }\n+\n+        asDoc.put(Fields.WRITE_PENDING_FIELD, new BsonBoolean(hasUncommittedWrites()));\n+        return asDoc;\n+    }\n+\n+    /**\n+     * Deserializes a {@link BsonDocument} into an instance of change event.\n+     * @param document the serialized document\n+     * @return the deserialized change event\n+     */\n+    static <T> ChangeEvent<T> fromBsonDocument(final BsonDocument document, final Class<T> documentClass, CodecRegistry codecRegistry) {\n+        keyPresent(Fields.ID_FIELD, document);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2NTgwNg==", "bodyText": "Only taking CRUD operations into account. Are the invalidate events not to be considered at our level?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469065806", "createdAt": "2020-08-12T07:39:48Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)\n+                && ((BsonValue) getFullDocument()).isDocument()) {\n+            asDoc.put(Fields.FULL_DOCUMENT_FIELD, (BsonValue) getFullDocument());\n+        }\n+\n+        if (getUpdateDescription() != null) {\n+            asDoc.put(Fields.UPDATE_DESCRIPTION_FIELD, getUpdateDescription().toBsonDocument());\n+        }\n+\n+        asDoc.put(Fields.WRITE_PENDING_FIELD, new BsonBoolean(hasUncommittedWrites()));\n+        return asDoc;\n+    }\n+\n+    /**\n+     * Deserializes a {@link BsonDocument} into an instance of change event.\n+     * @param document the serialized document\n+     * @return the deserialized change event\n+     */\n+    static <T> ChangeEvent<T> fromBsonDocument(final BsonDocument document, final Class<T> documentClass, CodecRegistry codecRegistry) {\n+        keyPresent(Fields.ID_FIELD, document);\n+        keyPresent(Fields.OPERATION_TYPE_FIELD, document);\n+        keyPresent(Fields.NS_FIELD, document);\n+        keyPresent(Fields.DOCUMENT_KEY_FIELD, document);\n+\n+        final BsonDocument nsDoc = document.getDocument(Fields.NS_FIELD);\n+\n+        final UpdateDescription updateDescription;\n+        if (document.containsKey(Fields.UPDATE_DESCRIPTION_FIELD)) {\n+            updateDescription = UpdateDescription.fromBsonDocument(\n+                    document.getDocument(Fields.UPDATE_DESCRIPTION_FIELD)\n+            );\n+        } else {\n+            updateDescription = null;\n+        }\n+\n+        final T fullDocument;\n+\n+        if (document.containsKey(Fields.FULL_DOCUMENT_FIELD)) {\n+            final BsonValue fdVal = document.get(Fields.FULL_DOCUMENT_FIELD);\n+            if (fdVal.isDocument()) {\n+                fullDocument = codecRegistry.get(documentClass).decode(fdVal.asDocument().asBsonReader(), DecoderContext.builder().build());\n+            } else {\n+                fullDocument = null;\n+            }\n+        } else {\n+            fullDocument = null;\n+        }\n+\n+        return new ChangeEvent<>(\n+                document.getDocument(Fields.ID_FIELD),\n+                fromRemote(document.getString(Fields.OPERATION_TYPE_FIELD).getValue()),\n+                fullDocument,\n+                new MongoNamespace(\n+                        nsDoc.getString(Fields.NS_DB_FIELD).getValue(),\n+                        nsDoc.getString(Fields.NS_COLL_FIELD).getValue()),\n+                document.getDocument(Fields.DOCUMENT_KEY_FIELD),\n+                updateDescription,\n+                document.getBoolean(Fields.WRITE_PENDING_FIELD, BsonBoolean.FALSE).getValue());\n+    }\n+\n+    private static final class Fields {\n+        static final String ID_FIELD = \"_id\";\n+        static final String OPERATION_TYPE_FIELD = \"operationType\";\n+        static final String FULL_DOCUMENT_FIELD = \"fullDocument\";\n+        static final String DOCUMENT_KEY_FIELD = \"documentKey\";\n+\n+        static final String NS_FIELD = \"ns\";\n+        static final String NS_DB_FIELD = \"db\";\n+        static final String NS_COLL_FIELD = \"coll\";\n+\n+        static final String UPDATE_DESCRIPTION_FIELD = \"updateDescription\";\n+        static final String WRITE_PENDING_FIELD = \"writePending\";\n+    }\n+\n+    /**\n+     * Returns the appropriate local operation type enum value based on the remote operation type\n+     * string from a change stream event.\n+     *\n+     * @param type the string description of the operation type.\n+     * @return the operation type.\n+     */\n+    private static OperationType fromRemote(final String type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2NTkzMg==", "bodyText": "Same as above", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469065932", "createdAt": "2020-08-12T07:39:58Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)\n+                && ((BsonValue) getFullDocument()).isDocument()) {\n+            asDoc.put(Fields.FULL_DOCUMENT_FIELD, (BsonValue) getFullDocument());\n+        }\n+\n+        if (getUpdateDescription() != null) {\n+            asDoc.put(Fields.UPDATE_DESCRIPTION_FIELD, getUpdateDescription().toBsonDocument());\n+        }\n+\n+        asDoc.put(Fields.WRITE_PENDING_FIELD, new BsonBoolean(hasUncommittedWrites()));\n+        return asDoc;\n+    }\n+\n+    /**\n+     * Deserializes a {@link BsonDocument} into an instance of change event.\n+     * @param document the serialized document\n+     * @return the deserialized change event\n+     */\n+    static <T> ChangeEvent<T> fromBsonDocument(final BsonDocument document, final Class<T> documentClass, CodecRegistry codecRegistry) {\n+        keyPresent(Fields.ID_FIELD, document);\n+        keyPresent(Fields.OPERATION_TYPE_FIELD, document);\n+        keyPresent(Fields.NS_FIELD, document);\n+        keyPresent(Fields.DOCUMENT_KEY_FIELD, document);\n+\n+        final BsonDocument nsDoc = document.getDocument(Fields.NS_FIELD);\n+\n+        final UpdateDescription updateDescription;\n+        if (document.containsKey(Fields.UPDATE_DESCRIPTION_FIELD)) {\n+            updateDescription = UpdateDescription.fromBsonDocument(\n+                    document.getDocument(Fields.UPDATE_DESCRIPTION_FIELD)\n+            );\n+        } else {\n+            updateDescription = null;\n+        }\n+\n+        final T fullDocument;\n+\n+        if (document.containsKey(Fields.FULL_DOCUMENT_FIELD)) {\n+            final BsonValue fdVal = document.get(Fields.FULL_DOCUMENT_FIELD);\n+            if (fdVal.isDocument()) {\n+                fullDocument = codecRegistry.get(documentClass).decode(fdVal.asDocument().asBsonReader(), DecoderContext.builder().build());\n+            } else {\n+                fullDocument = null;\n+            }\n+        } else {\n+            fullDocument = null;\n+        }\n+\n+        return new ChangeEvent<>(\n+                document.getDocument(Fields.ID_FIELD),\n+                fromRemote(document.getString(Fields.OPERATION_TYPE_FIELD).getValue()),\n+                fullDocument,\n+                new MongoNamespace(\n+                        nsDoc.getString(Fields.NS_DB_FIELD).getValue(),\n+                        nsDoc.getString(Fields.NS_COLL_FIELD).getValue()),\n+                document.getDocument(Fields.DOCUMENT_KEY_FIELD),\n+                updateDescription,\n+                document.getBoolean(Fields.WRITE_PENDING_FIELD, BsonBoolean.FALSE).getValue());\n+    }\n+\n+    private static final class Fields {\n+        static final String ID_FIELD = \"_id\";\n+        static final String OPERATION_TYPE_FIELD = \"operationType\";\n+        static final String FULL_DOCUMENT_FIELD = \"fullDocument\";\n+        static final String DOCUMENT_KEY_FIELD = \"documentKey\";\n+\n+        static final String NS_FIELD = \"ns\";\n+        static final String NS_DB_FIELD = \"db\";\n+        static final String NS_COLL_FIELD = \"coll\";\n+\n+        static final String UPDATE_DESCRIPTION_FIELD = \"updateDescription\";\n+        static final String WRITE_PENDING_FIELD = \"writePending\";\n+    }\n+\n+    /**\n+     * Returns the appropriate local operation type enum value based on the remote operation type\n+     * string from a change stream event.\n+     *\n+     * @param type the string description of the operation type.\n+     * @return the operation type.\n+     */\n+    private static OperationType fromRemote(final String type) {\n+        switch (type) {\n+            case \"insert\":\n+                return INSERT;\n+            case \"delete\":\n+                return DELETE;\n+            case \"replace\":\n+                return REPLACE;\n+            case \"update\":\n+                return UPDATE;\n+            default:\n+                return UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Converts this operation to the remote string representation of the operation as\n+     * represented in a {@link ChangeEvent} from a remote cluster.\n+     *\n+     * @return the remote representation of the update operation.\n+     */\n+    private String toRemote(OperationType operationType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2OTY4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Fetch the next event from a given stream\n          \n          \n            \n                 * Fetch the next event from a given stream.", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469069680", "createdAt": "2020-08-12T07:46:55Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/EventStream.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.objectserver;\n+\n+import java.io.IOException;\n+\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+public interface EventStream<T> {\n+    /**\n+     * Fetch the next event from a given stream", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3MjQyMg==", "bodyText": "Maybe we should consider using the codec registry to allow automatic conversion from all sorts of arguments. This could also collapse the method with the below. See the Functions.callFunction implementation for details.", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469072422", "createdAt": "2020-08-12T07:51:54Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "diffHunk": "@@ -525,34 +550,93 @@ protected ResultT mapSuccess(Object result) {\n         }\n     }\n \n+    private EventStream<DocumentT> watchInternal(int type, @Nullable BsonArray ids, @Nullable BsonDocument matchFilter) throws IOException {\n+        BsonArray args = new BsonArray();\n+        BsonDocument watchArgs = new BsonDocument(\"database\", new BsonString(namespace.getDatabaseName()));\n+        args.add(watchArgs);\n+\n+        watchArgs.put(\"collection\", new BsonString(namespace.getCollectionName()));\n+\n+        switch (type) {\n+            case WATCH:\n+                break;\n+            case WATCH_IDS:\n+                watchArgs.put(\"ids\", ids);\n+                break;\n+            case WATCH_WITH_FILTER:\n+                watchArgs.put(\"filter\", matchFilter);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid watch type: \" + type);\n+        }\n+\n+        OsJavaNetworkTransport.Request request = streamNetworkTransport.makeStreamingRequest(\"watch\", args, serviceName);\n+        OsJavaNetworkTransport.Response response = streamNetworkTransport.sendRequest(request);\n+\n+        return new NetworkEventStream<>(response, codecRegistry, documentClass);\n+    }\n+\n+    public EventStream<DocumentT> watch() throws IOException {\n+        return watchInternal(WATCH, null, null);\n+    }\n+\n+    public EventStream<DocumentT> watch(final BsonValue... ids) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3NTU2OA==", "bodyText": "Seems a bit general!?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469075568", "createdAt": "2020-08-12T07:57:35Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/ErrorCode.java", "diffHunk": "@@ -47,6 +47,8 @@\n     BSON_CODEC_NOT_FOUND(Type.JAVA, 1100),\n     BSON_ENCODING(Type.JAVA, 1101),\n     BSON_DECODING(Type.JAVA, 1102),\n+    // Java errors\n+    RUNTIME_EXCEPTION(Type.JAVA, 1200),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3Njc1MQ==", "bodyText": "Maybe use codec registry to allow automatic argument conversion as in Functions.callFunction. Would allow collapsing this with the below method.", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469076751", "createdAt": "2020-08-12T07:59:45Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -805,4 +816,194 @@ public ResultT run() {\n             }\n         });\n     }\n+\n+    /**\n+     * Watches a collection. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch() {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final BsonValue... ids) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3NzU2Mg==", "bodyText": "Same as previous with automatic argument conversion.", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469077562", "createdAt": "2020-08-12T08:01:18Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -805,4 +816,194 @@ public ResultT run() {\n             }\n         });\n     }\n+\n+    /**\n+     * Watches a collection. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch() {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final BsonValue... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection. This convenience overload supports the use case\n+     * of non-{@link BsonValue} instances of {@link ObjectId} by wrapping them in\n+     * {@link BsonObjectId} instances for the user.\n+     *\n+     * @param ids unique object identifiers of the IDs to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final ObjectId... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided document will be used as a match expression filter on\n+     * the change events coming from the stream. This convenience overload supports the use of\n+     * non-{@link BsonDocument} instances for the user.\n+     * <p>\n+     * See <a href=\"https://docs.mongodb.com/manual/reference/operator/aggregation/match/\" target=\"_blank\">how to define a match filter</a>.\n+     * <p>\n+     * Defining the match expression to filter ChangeEvents is similar to\n+     * <a href=\"https://docs.mongodb.com/realm/triggers/database-triggers/\" target=\"_blank\">how to define the match expression for triggers</a>\n+     *\n+     * @param matchFilter the $match filter to apply to incoming change events\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watchWithFilter(Document matchFilter) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watchWithFilter(matchFilter);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided BSON document will be used as a match expression filter on\n+     * the change events coming from the stream.\n+     * <p>\n+     * See <a href=\"https://docs.mongodb.com/manual/reference/operator/aggregation/match/\" target=\"_blank\">how to define a match filter</a>.\n+     * <p>\n+     * Defining the match expression to filter ChangeEvents is similar to\n+     * <a href=\"https://docs.mongodb.com/realm/triggers/database-triggers/\" target=\"_blank\">how to define the match expression for triggers</a>\n+     *\n+     * @param matchFilter the $match filter to apply to incoming change events\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watchWithFilter(BsonDocument matchFilter) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watchWithFilter(matchFilter);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection asynchronously. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamAsyncTask<DocumentT> watchAsync() {\n+        return new RealmEventStreamAsyncTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamAsyncTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection asynchronously.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamAsyncTask<DocumentT> watchAsync(final BsonValue... ids) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4NjcxMA==", "bodyText": "We should probably guard this catching all non IOExceptions too and emit them as some other error to prevents accidential crashes.", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469086710", "createdAt": "2020-08-12T08:18:30Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/async/RealmEventStreamAsyncTaskImpl.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async;\n+\n+import java.io.IOException;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectserver.EventStream;\n+import io.realm.mongodb.App;\n+import io.realm.mongodb.AppException;\n+import io.realm.mongodb.ErrorCode;\n+import io.realm.mongodb.RealmEventStreamAsyncTask;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+public class RealmEventStreamAsyncTaskImpl<T> implements RealmEventStreamAsyncTask<T> {\n+    private final String name;\n+    private final Executor<T> executor;\n+    private volatile EventStream<T> eventStream;\n+    private volatile boolean isCancelled;\n+    private Thread thread;\n+\n+    public RealmEventStreamAsyncTaskImpl(final String name, final Executor<T> executor) {\n+        Util.checkNull(executor, \"name\");\n+        Util.checkNull(executor, \"executor\");\n+\n+        this.executor = executor;\n+        this.name = name;\n+    }\n+\n+    @Override\n+    public synchronized void get(App.Callback<BaseChangeEvent<T>> callback) throws IllegalStateException {\n+        Util.checkNull(callback, \"callback\");\n+\n+        if (thread != null) {\n+            throw new IllegalStateException(\"Resource already open\");\n+        } else {\n+            thread = new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        eventStream = executor.run();\n+\n+                        while (true) {\n+                            BaseChangeEvent<T> nextEvent = eventStream.getNextEvent();\n+\n+                            callback.onResult(App.Result.withResult(nextEvent));\n+                        }\n+                    } catch (IOException exception) {\n+                        callback.onResult(App.Result.withError(new AppException(ErrorCode.NETWORK_IO_EXCEPTION, exception)));\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4ODg1Ng==", "bodyText": "@cmelchior Do we have a convention about logging and swallowing user exceptions? Seen it somewhere, but maybe it is preferable that users gets the attention?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469088856", "createdAt": "2020-08-12T08:22:09Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/async/RealmEventStreamAsyncTaskImpl.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async;\n+\n+import java.io.IOException;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectserver.EventStream;\n+import io.realm.mongodb.App;\n+import io.realm.mongodb.AppException;\n+import io.realm.mongodb.ErrorCode;\n+import io.realm.mongodb.RealmEventStreamAsyncTask;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+public class RealmEventStreamAsyncTaskImpl<T> implements RealmEventStreamAsyncTask<T> {\n+    private final String name;\n+    private final Executor<T> executor;\n+    private volatile EventStream<T> eventStream;\n+    private volatile boolean isCancelled;\n+    private Thread thread;\n+\n+    public RealmEventStreamAsyncTaskImpl(final String name, final Executor<T> executor) {\n+        Util.checkNull(executor, \"name\");\n+        Util.checkNull(executor, \"executor\");\n+\n+        this.executor = executor;\n+        this.name = name;\n+    }\n+\n+    @Override\n+    public synchronized void get(App.Callback<BaseChangeEvent<T>> callback) throws IllegalStateException {\n+        Util.checkNull(callback, \"callback\");\n+\n+        if (thread != null) {\n+            throw new IllegalStateException(\"Resource already open\");\n+        } else {\n+            thread = new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        eventStream = executor.run();\n+\n+                        while (true) {\n+                            BaseChangeEvent<T> nextEvent = eventStream.getNextEvent();\n+\n+                            callback.onResult(App.Result.withResult(nextEvent));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 60}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35d396751a2ffcb93bf926d79c6b54b53454ff6b", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/35d396751a2ffcb93bf926d79c6b54b53454ff6b", "committedDate": "2020-08-12T10:03:14Z", "message": "Implements PR CR and fixes merge issues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTk0MzQz", "url": "https://github.com/realm/realm-java/pull/7014#pullrequestreview-467594343", "createdAt": "2020-08-14T13:55:34Z", "commit": {"oid": "35d396751a2ffcb93bf926d79c6b54b53454ff6b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzo1NTozNVrOHA1gXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzo1ODoxNlrOHA1mlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzODY4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        doc1.apply {\n          \n          \n            \n                            this[\"num\"] = 2\n          \n          \n            \n                        }\n          \n          \n            \n                        doc1[\"num\"] = 2", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r470638686", "createdAt": "2020-08-14T13:55:35Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt", "diffHunk": "@@ -876,6 +882,392 @@ class MongoClientTest {\n         }\n     }\n \n+    fun assertDocumentEquals(expected: Document, actual: Document) {\n+        // Accounts for the missing _id field in the expected document\n+        assertTrue {\n+            actual.remove(\"_id\") != null\n+        }\n+\n+        assertEquals(expected.keys.size, actual.keys.size)\n+\n+        for (key in expected.keys) {\n+            assertTrue(actual.keys.contains(key))\n+            assertEquals(expected[key], actual[key])\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamSynchronous() {\n+        with(getCollectionInternal()) {\n+            val insertedDocument = Document(\"watch\", \"1\")\n+                    .apply {\n+                        this[\"num\"] = 1\n+                    }\n+\n+            val updatedDocument = Document(\"watch\", \"1\")\n+                    .apply {\n+                        this[\"num\"] = 2\n+                    }\n+\n+\n+            val watcher = this.watch()\n+\n+            val condition = looperThread.runDetached {\n+                watcher.next.let { changeEvent ->\n+                    assertEquals(OperationType.INSERT, changeEvent.operationType)\n+                    assertDocumentEquals(insertedDocument, changeEvent.fullDocument!!)\n+                }\n+\n+                watcher.next.let { changeEvent ->\n+                    assertEquals(OperationType.REPLACE, changeEvent.operationType)\n+                    assertDocumentEquals(updatedDocument, changeEvent.fullDocument!!)\n+                }\n+\n+                watcher.next.let { changeEvent ->\n+                    assertEquals(OperationType.DELETE, changeEvent.operationType)\n+                    assertNull(changeEvent.fullDocument)\n+                }\n+\n+                looperThread.testComplete()\n+            }\n+\n+            // Busy wait till watcher is ready to receive updates.\n+            // It syncs the event producer thread (current thread) with\n+            // the event consumer thread.\n+            while (!watcher.isOpen) {\n+            }\n+\n+            this.insertOne(insertedDocument).get()\n+\n+            val filter = Document(\"watch\", \"1\")\n+            this.updateOne(filter, updatedDocument).get()\n+            this.deleteOne(filter).get()\n+\n+            condition?.await()\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamDocumentsFilterSynchronous() {\n+        with(getCollectionInternal()) {\n+            val type1 = Document(\"type\", \"1\")\n+                    .apply {\n+                        this[\"num\"] = 1\n+                    }\n+\n+            val type2 = Document(\"type\", \"2\")\n+                    .apply {\n+                        this[\"num\"] = 1\n+                    }\n+\n+            val filter = Document(\"fullDocument.type\", \"1\")\n+            val watcher = this.watchWithFilter(filter)\n+\n+            val condition = looperThread.runDetached {\n+                watcher.next.let { changeEvent ->\n+                    assertEquals(OperationType.INSERT, changeEvent.operationType)\n+                    assertEquals(\"1\", changeEvent.fullDocument!![\"type\"])\n+                }\n+\n+                watcher.cancel()\n+                looperThread.testComplete()\n+            }\n+\n+            // Busy wait till watcher is ready to receive updates.\n+            // It syncs the event producer thread (current thread) with\n+            // the event consumer thread.\n+            while (!watcher.isOpen) {\n+            }\n+\n+            this.insertOne(type2).get()\n+            this.insertOne(type1).get()\n+\n+            condition?.await()\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamBsonDocumentFilterSynchronous() {\n+        with(getCollectionInternal()) {\n+            val type1 = Document(\"type\", \"1\")\n+                    .apply {\n+                        this[\"num\"] = 1\n+                    }\n+\n+            val type2 = Document(\"type\", \"2\")\n+                    .apply {\n+                        this[\"num\"] = 1\n+                    }\n+\n+            val filter = BsonDocument(\"fullDocument.type\", BsonString(\"1\"))\n+            val watcher = this.watchWithFilter(filter)\n+\n+            val condition = looperThread.runDetached {\n+                watcher.next.let { changeEvent ->\n+                    assertEquals(OperationType.INSERT, changeEvent.operationType)\n+                    assertEquals(\"1\", changeEvent.fullDocument!![\"type\"])\n+                }\n+\n+                watcher.cancel()\n+                looperThread.testComplete()\n+\n+            }\n+\n+            // Busy wait till watcher is ready to receive updates.\n+            // It syncs the event producer thread (current thread) with\n+            // the event consumer thread.\n+            while (!watcher.isOpen) {\n+            }\n+\n+            this.insertOne(type2).get()\n+            this.insertOne(type1).get()\n+\n+            condition?.await()\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamObjectIdsSynchronous() {\n+        with(getCollectionInternal()) {\n+            val doc1 = Document(\"document\", \"1\")\n+                    .apply {\n+                        this[\"num\"] = 1\n+                    }\n+\n+            val doc2 = Document(\"document\", \"2\")\n+                    .apply {\n+                        this[\"num\"] = 1\n+                    }\n+\n+            val doc1Id = this.insertOne(doc1).get()\n+            val doc2Id = this.insertOne(doc2).get()\n+\n+            val watcherObjectId = this.watch(doc1Id.insertedId.asObjectId().value)\n+\n+            val condition = looperThread.runDetached {\n+                watcherObjectId.next.let { changeEvent ->\n+                    assertEquals(OperationType.REPLACE, changeEvent.operationType)\n+                    assertEquals(\"1\", changeEvent.fullDocument!![\"document\"])\n+                }\n+                watcherObjectId.cancel()\n+\n+                looperThread.testComplete()\n+            }\n+\n+            // Busy wait till watcher is ready to receive updates.\n+            // It syncs the event producer thread (current thread) with\n+            // the event consumer thread.\n+            while (!watcherObjectId.isOpen) {\n+            }\n+\n+            doc1.apply {\n+                this[\"num\"] = 2\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d396751a2ffcb93bf926d79c6b54b53454ff6b"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY0MDI3OQ==", "bodyText": "Multiple sequential calls to watchStream.getState(). If it is not changing in between then use a local variable.", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r470640279", "createdAt": "2020-08-14T13:58:16Z", "author": {"login": "rorbech"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/NetworkEventStream.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.realm.internal.events;\n+\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import java.io.IOException;\n+\n+import io.realm.internal.objectserver.EventStream;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.internal.objectstore.OsWatchStream;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+public class NetworkEventStream<T> implements EventStream<T> {\n+    private final OsJavaNetworkTransport.Response response;\n+    private final OsWatchStream<T> watchStream;\n+    private final CodecRegistry codecRegistry;\n+    private final Class<T> documentClass;\n+\n+    public NetworkEventStream(OsJavaNetworkTransport.Response response, CodecRegistry codecRegistry, Class<T> documentClass) {\n+        this.response = response;\n+        this.watchStream = new OsWatchStream<>(codecRegistry);\n+        this.codecRegistry = codecRegistry;\n+        this.documentClass = documentClass;\n+    }\n+\n+    /**\n+     * Fetch the next event from a given stream\n+     *\n+     * @return the next event\n+     * @throws IOException any io exception that could occur\n+     */\n+    @Override\n+    public BaseChangeEvent<T> getNextEvent() throws IOException {\n+        String line;\n+\n+        while ((((line = response.readBodyLine())) != null)) {\n+            watchStream.feedLine(line);\n+\n+            if (watchStream.getState().equals(OsWatchStream.HAVE_EVENT))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d396751a2ffcb93bf926d79c6b54b53454ff6b"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c566df1ff134d99ef08fd2ac6964dc6ee01bea7", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/1c566df1ff134d99ef08fd2ac6964dc6ee01bea7", "committedDate": "2020-08-17T14:28:56Z", "message": "Implement PR changes\nBetter error handling\nAutomatic argument conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94ff30d870892a57b434794f30d42d621bccbe88", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/94ff30d870892a57b434794f30d42d621bccbe88", "committedDate": "2020-08-17T14:30:43Z", "message": "Merge branch 'v10' into ct/watch-event-streams"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "703c55ef368348544436843b24aad0c382cb501b", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/703c55ef368348544436843b24aad0c382cb501b", "committedDate": "2020-08-18T13:19:31Z", "message": "Split App class following the object store pattern (#7038)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwMTczMTY5", "url": "https://github.com/realm/realm-java/pull/7014#pullrequestreview-470173169", "createdAt": "2020-08-19T06:57:01Z", "commit": {"oid": "703c55ef368348544436843b24aad0c382cb501b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNjo1NzowMVrOHC4Eug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNjo1NzowMVrOHC4Eug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc3NzkxNA==", "bodyText": "This needs to go into the 10.0.7 section instead", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r472777914", "createdAt": "2020-08-19T06:57:01Z", "author": {"login": "rorbech"}, "path": "CHANGELOG.md", "diffHunk": "@@ -13,6 +13,7 @@ The old Realm Cloud legacy APIs have undergone significant refactoring. The new\n * RealmLists can now be marked final. (Issue [#6892](https://github.com/realm/realm-java/issues/6892))\n * It is now possible to create embedded objects using [DynamicRealm]s. (Issue [#6982](https://github.com/realm/realm-java/pull/6982))\n * Added extra validation and more meaningful error messages when creating embedded objects pointing to the wrong parent property. (See issue above)\n+* Add support for watching change streams to MongoCollection (Issue [#6912](https://github.com/realm/realm-java/issues/6912))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "703c55ef368348544436843b24aad0c382cb501b"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwMzA2Nzc0", "url": "https://github.com/realm/realm-java/pull/7014#pullrequestreview-470306774", "createdAt": "2020-08-19T09:59:51Z", "commit": {"oid": "703c55ef368348544436843b24aad0c382cb501b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwOTo1OTo1MlrOHDAL-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwOTo1OTo1MlrOHDAL-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxMDg0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                fun assertDocumentEquals(expected: Document, actual: Document) {\n          \n          \n            \n                private fun assertDocumentEquals(expected: Document, actual: Document) {", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r472910840", "createdAt": "2020-08-19T09:59:52Z", "author": {"login": "edualonso"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt", "diffHunk": "@@ -876,6 +882,391 @@ class MongoClientTest {\n         }\n     }\n \n+    fun assertDocumentEquals(expected: Document, actual: Document) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "703c55ef368348544436843b24aad0c382cb501b"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "148da00538fe087a0ec5fa003fde0ac9fcfc792a", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/148da00538fe087a0ec5fa003fde0ac9fcfc792a", "committedDate": "2020-08-20T08:59:51Z", "message": "Update realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt\n\nCo-authored-by: Eduardo L\u00f3pez <1874445+edualonso@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d984970150b282c4d4ac676d6ad8a3cd9acf1b27", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/d984970150b282c4d4ac676d6ad8a3cd9acf1b27", "committedDate": "2020-08-20T19:35:11Z", "message": "Merge branch 'v10' into ct/watch-event-streams"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad1d8e122d297e6ba8a37acbd807b27cbcac76f1", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/ad1d8e122d297e6ba8a37acbd807b27cbcac76f1", "committedDate": "2020-08-20T19:39:23Z", "message": "Update changelog in the right build version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ff3de792890950b38dc52a029aa696026a34144", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/3ff3de792890950b38dc52a029aa696026a34144", "committedDate": "2020-08-20T19:46:56Z", "message": "Add missing space"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMjUwNjU4", "url": "https://github.com/realm/realm-java/pull/7014#pullrequestreview-472250658", "createdAt": "2020-08-21T07:00:50Z", "commit": {"oid": "3ff3de792890950b38dc52a029aa696026a34144"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNzowMDo1MVrOHEd8XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNzozNzo1NVrOHEfvcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0Njk0MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Add support for watching change streams to MongoCollection (Issue [#6912](https://github.com/realm/realm-java/issues/6912))\n          \n          \n            \n            * Support for watching MongoCollection change streams (Issue [#6912](https://github.com/realm/realm-java/issues/6912))", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474446941", "createdAt": "2020-08-21T07:00:51Z", "author": {"login": "cmelchior"}, "path": "CHANGELOG.md", "diffHunk": "@@ -1,3 +1,25 @@\n+## 10.0.0-BETA.7 (YYYY-MM-DD)\n+\n+We no longer support Realm Cloud (legacy), but instead the new MongoDB Realm Cloud. MongoDB Realm is a serverless platform that enables developers to quickly build applications without having to set up server infrastructure. MongoDB Realm is built on top of MongoDB Atlas, automatically integrating the connection to your database.\n+\n+The old Realm Cloud legacy APIs have undergone significant refactoring. The new APIs are all located in the `io.realm.mongodb` package with `io.realm.mongodb.App` as the entry point.\n+\n+### Breaking Changes \n+* None\n+\n+### Enhancements\n+* Add support for watching change streams to MongoCollection (Issue [#6912](https://github.com/realm/realm-java/issues/6912))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ff3de792890950b38dc52a029aa696026a34144"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0NzUyNQ==", "bodyText": "Nice \ud83d\udcaf", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474447525", "createdAt": "2020-08-21T07:01:39Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTest/kotlin/io/realm/rule/BlockingLooperThread.kt", "diffHunk": "@@ -88,7 +89,14 @@ class BlockingLooperThread {\n      * Runs the test on a Looper thread\n      */\n     fun runBlocking(threadName: String = \"TestLooperThread\", emulateMainThread: Boolean = false, test: () -> Unit) {\n-        RunInLooperThreadStatement(threadName, emulateMainThread, test).evaluate()\n+        RunInLooperThreadStatement(threadName, emulateMainThread, test).evaluate(false)\n+    }\n+\n+    /**\n+     * Runs the test on a Looper thread. Returns an object that can be used to wait for the test to complete\n+     */\n+    fun runDetached(threadName: String = \"TestLooperThread\", emulateMainThread: Boolean = false, test: () -> Unit): Condition? {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ff3de792890950b38dc52a029aa696026a34144"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ2MDA3OA==", "bodyText": "But why is the return value Condition?. It always returns the condition and it would clean up some ? used in the test code.", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474460078", "createdAt": "2020-08-21T07:17:54Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTest/kotlin/io/realm/rule/BlockingLooperThread.kt", "diffHunk": "@@ -88,7 +89,14 @@ class BlockingLooperThread {\n      * Runs the test on a Looper thread\n      */\n     fun runBlocking(threadName: String = \"TestLooperThread\", emulateMainThread: Boolean = false, test: () -> Unit) {\n-        RunInLooperThreadStatement(threadName, emulateMainThread, test).evaluate()\n+        RunInLooperThreadStatement(threadName, emulateMainThread, test).evaluate(false)\n+    }\n+\n+    /**\n+     * Runs the test on a Looper thread. Returns an object that can be used to wait for the test to complete\n+     */\n+    fun runDetached(threadName: String = \"TestLooperThread\", emulateMainThread: Boolean = false, test: () -> Unit): Condition? {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0NzUyNQ=="}, "originalCommit": {"oid": "3ff3de792890950b38dc52a029aa696026a34144"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ2MDI2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474460268", "createdAt": "2020-08-21T07:18:08Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/internal/async/RealmStreamTaskImplTest.kt", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.internal.objectserver.EventStream\n+import io.realm.mongodb.mongo.events.BaseChangeEvent\n+import io.realm.rule.BlockingLooperThread\n+import junit.framework.Assert.assertEquals\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.lang.IllegalStateException\n+import kotlin.test.assertFailsWith\n+\n+@RunWith(AndroidJUnit4::class)\n+class RealmStreamTaskImplTest {\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Test\n+    fun asyncExclusiveAccess() {\n+        // Validates that we cannot access synchronously if we are already\n+        // accessing the stream asynchronously.\n+\n+        val task = RealmEventStreamAsyncTaskImpl(\"test\", object : RealmEventStreamAsyncTaskImpl.Executor<String>() {\n+            override fun run(): EventStream<String> {\n+                return object : EventStream<String> {\n+                    var opened: Boolean = true\n+\n+                    override fun getNextEvent(): BaseChangeEvent<String>? {\n+                        return null\n+                    }\n+\n+                    override fun close() {\n+                        opened = false\n+                    }\n+\n+                    override fun isOpen(): Boolean {\n+                        return opened\n+                    }\n+                }\n+            }\n+        })\n+\n+        task.get { }\n+\n+        assertFailsWith<IllegalStateException> {\n+            task.get { }\n+        }\n+    }\n+\n+    @Test\n+    fun openClose() {\n+        val task = RealmEventStreamTaskImpl(\"test\", object : RealmEventStreamTaskImpl.Executor<String>() {\n+            override fun run(): EventStream<String> {\n+                return object : EventStream<String> {\n+                    var opened: Boolean = false\n+\n+                    override fun getNextEvent(): BaseChangeEvent<String>? {\n+                        opened = true\n+                        return null\n+                    }\n+\n+                    override fun close() {\n+                        opened = false\n+                    }\n+\n+                    override fun isOpen(): Boolean {\n+                        return opened\n+                    }\n+                }\n+            }\n+        })\n+\n+        assertEquals(false, task.isOpen)\n+        assertEquals(false, task.isCancelled)\n+\n+        task.next\n+\n+        assertEquals(true, task.isOpen)\n+        assertEquals(false, task.isCancelled)\n+\n+        task.cancel()\n+\n+        assertEquals(false, task.isOpen)\n+        assertEquals(true, task.isCancelled)\n+    }\n+\n+    @Test\n+    fun openCloseAsync() {\n+        val task = RealmEventStreamAsyncTaskImpl(\"test\", object : RealmEventStreamAsyncTaskImpl.Executor<String>() {\n+            override fun run(): EventStream<String> {\n+                return object : EventStream<String> {\n+                    var opened: Boolean = false\n+\n+                    override fun getNextEvent(): BaseChangeEvent<String>? {\n+                        opened = true\n+                        return null\n+                    }\n+\n+                    override fun close() {\n+                        opened = false\n+                    }\n+\n+                    override fun isOpen(): Boolean {\n+                        return opened\n+                    }\n+                }\n+            }\n+        })\n+\n+        assertEquals(false, task.isOpen)\n+        assertEquals(false, task.isCancelled)\n+\n+        looperThread.runBlocking {\n+            task.get {\n+                looperThread.testComplete()\n+            }\n+        }\n+\n+        assertEquals(true, task.isOpen)\n+        assertEquals(false, task.isCancelled)\n+\n+        task.cancel()\n+\n+        assertEquals(false, task.isOpen)\n+        assertEquals(true, task.isCancelled)\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ff3de792890950b38dc52a029aa696026a34144"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ2NDc1Mw==", "bodyText": "This hasn't been addressed", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474464753", "createdAt": "2020-08-21T07:23:57Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MDA5MQ=="}, "originalCommit": {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ2NTM4NA==", "bodyText": "This hasn't been addressed.", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474465384", "createdAt": "2020-08-21T07:24:44Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)\n+                && ((BsonValue) getFullDocument()).isDocument()) {\n+            asDoc.put(Fields.FULL_DOCUMENT_FIELD, (BsonValue) getFullDocument());\n+        }\n+\n+        if (getUpdateDescription() != null) {\n+            asDoc.put(Fields.UPDATE_DESCRIPTION_FIELD, getUpdateDescription().toBsonDocument());\n+        }\n+\n+        asDoc.put(Fields.WRITE_PENDING_FIELD, new BsonBoolean(hasUncommittedWrites()));\n+        return asDoc;\n+    }\n+\n+    /**\n+     * Deserializes a {@link BsonDocument} into an instance of change event.\n+     * @param document the serialized document\n+     * @return the deserialized change event\n+     */\n+    static <T> ChangeEvent<T> fromBsonDocument(final BsonDocument document, final Class<T> documentClass, CodecRegistry codecRegistry) {\n+        keyPresent(Fields.ID_FIELD, document);\n+        keyPresent(Fields.OPERATION_TYPE_FIELD, document);\n+        keyPresent(Fields.NS_FIELD, document);\n+        keyPresent(Fields.DOCUMENT_KEY_FIELD, document);\n+\n+        final BsonDocument nsDoc = document.getDocument(Fields.NS_FIELD);\n+\n+        final UpdateDescription updateDescription;\n+        if (document.containsKey(Fields.UPDATE_DESCRIPTION_FIELD)) {\n+            updateDescription = UpdateDescription.fromBsonDocument(\n+                    document.getDocument(Fields.UPDATE_DESCRIPTION_FIELD)\n+            );\n+        } else {\n+            updateDescription = null;\n+        }\n+\n+        final T fullDocument;\n+\n+        if (document.containsKey(Fields.FULL_DOCUMENT_FIELD)) {\n+            final BsonValue fdVal = document.get(Fields.FULL_DOCUMENT_FIELD);\n+            if (fdVal.isDocument()) {\n+                fullDocument = codecRegistry.get(documentClass).decode(fdVal.asDocument().asBsonReader(), DecoderContext.builder().build());\n+            } else {\n+                fullDocument = null;\n+            }\n+        } else {\n+            fullDocument = null;\n+        }\n+\n+        return new ChangeEvent<>(\n+                document.getDocument(Fields.ID_FIELD),\n+                fromRemote(document.getString(Fields.OPERATION_TYPE_FIELD).getValue()),\n+                fullDocument,\n+                new MongoNamespace(\n+                        nsDoc.getString(Fields.NS_DB_FIELD).getValue(),\n+                        nsDoc.getString(Fields.NS_COLL_FIELD).getValue()),\n+                document.getDocument(Fields.DOCUMENT_KEY_FIELD),\n+                updateDescription,\n+                document.getBoolean(Fields.WRITE_PENDING_FIELD, BsonBoolean.FALSE).getValue());\n+    }\n+\n+    private static final class Fields {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNDkxNQ=="}, "originalCommit": {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ3NjIwNA==", "bodyText": "This is no longer true?", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474476204", "createdAt": "2020-08-21T07:37:38Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/RealmEventStreamTask.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb;\n+\n+import java.io.IOException;\n+\n+import io.realm.RealmAsyncTask;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+\n+/**\n+ * The RealmStreamTask is a specific version of {@link RealmAsyncTask} that provides a mechanism\n+ * to work with asynchronous operations carried out against MongoDB Realm that yield stream results.\n+ * <p>\n+ * This class offers both blocking ({@code get}) and non-blocking ({@code getAsync}) method calls.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ff3de792890950b38dc52a029aa696026a34144"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ3NjQwMw==", "bodyText": "This is no longer true", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474476403", "createdAt": "2020-08-21T07:37:55Z", "author": {"login": "cmelchior"}, "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/RealmEventStreamAsyncTask.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb;\n+\n+import io.realm.RealmAsyncTask;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+\n+/**\n+ * The RealmStreamAsyncTask is a specific version of {@link RealmAsyncTask} that provides a mechanism\n+ * to work with asynchronous operations carried out against MongoDB Realm that yield stream results.\n+ * <p>\n+ * This class offers both blocking ({@code get}) and non-blocking ({@code getAsync}) method calls.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ff3de792890950b38dc52a029aa696026a34144"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e588e87354b6db11ad619b7451af3cbc4f74e952", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/e588e87354b6db11ad619b7451af3cbc4f74e952", "committedDate": "2020-08-21T07:59:59Z", "message": "Update CHANGELOG.md\n\nCo-authored-by: Christian Melchior <christian@ilios.dk>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87f162f38888966c576b5549e99db4f2ec083053", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/87f162f38888966c576b5549e99db4f2ec083053", "committedDate": "2020-08-21T08:14:11Z", "message": "Update realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/internal/async/RealmStreamTaskImplTest.kt\n\nCo-authored-by: Christian Melchior <christian@ilios.dk>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59f515355258b32c7a8a32df6c49840d8895251a", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/59f515355258b32c7a8a32df6c49840d8895251a", "committedDate": "2020-08-21T08:38:44Z", "message": "Transform keyPresent function into a check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7065f993f684b5285aa2320a180aa9200fe43307", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/7065f993f684b5285aa2320a180aa9200fe43307", "committedDate": "2020-08-21T08:43:17Z", "message": "Update realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java\n\nCo-authored-by: Claus R\u00f8rbech <claus.rorbech@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e1f8d3c055ba88c29f813b922639dbc2f646d94", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/9e1f8d3c055ba88c29f813b922639dbc2f646d94", "committedDate": "2020-08-21T08:45:40Z", "message": "Change eventstream tasks description"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10a511c15ac0d092015aef80a5ba4c1066c70779", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/10a511c15ac0d092015aef80a5ba4c1066c70779", "committedDate": "2020-08-21T08:51:40Z", "message": "Update realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/EventStream.java\n\nCo-authored-by: Claus R\u00f8rbech <claus.rorbech@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dc5716634f9cbaa64e45d7b44e293b3c6f4275d", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/8dc5716634f9cbaa64e45d7b44e293b3c6f4275d", "committedDate": "2020-08-21T09:06:36Z", "message": "Merge branch 'ct/watch-event-streams' of ssh://github.com/realm/realm-java into ct/watch-event-streams"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f76b662e588dc0e6b289858ac224f758f5417b3", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/0f76b662e588dc0e6b289858ac224f758f5417b3", "committedDate": "2020-08-21T09:10:07Z", "message": "Claus PR change requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d02f9240afff6c616cfd5bb4d78450033c8a510", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/3d02f9240afff6c616cfd5bb4d78450033c8a510", "committedDate": "2020-08-21T09:22:54Z", "message": "Added link to realm change events spec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5da5ccc8a213a13fdd39f366310a724071d43368", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/5da5ccc8a213a13fdd39f366310a724071d43368", "committedDate": "2020-08-21T10:16:33Z", "message": "BlockingLooperThread runDetached returns non null values"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7570829040b4600e4ad44e81ce71e2e9a30efa54", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/7570829040b4600e4ad44e81ce71e2e9a30efa54", "committedDate": "2020-08-21T10:24:28Z", "message": "Use static class and method references"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2afd68a0b65882a7acca8d4a2b19804dec75f4c", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/b2afd68a0b65882a7acca8d4a2b19804dec75f4c", "committedDate": "2020-08-21T10:27:04Z", "message": "Better comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "319483675412a252c3c931c7ff0604296a0ab7f3", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/319483675412a252c3c931c7ff0604296a0ab7f3", "committedDate": "2020-08-21T10:42:16Z", "message": "Return response message on http stream error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3a956e0a663def9edfff370610831bb4137d26e", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/f3a956e0a663def9edfff370610831bb4137d26e", "committedDate": "2020-08-21T10:43:21Z", "message": "Rename OkHttpNetworkTransport response"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MTkzMDQ5", "url": "https://github.com/realm/realm-java/pull/7014#pullrequestreview-474193049", "createdAt": "2020-08-25T07:10:07Z", "commit": {"oid": "f3a956e0a663def9edfff370610831bb4137d26e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6430333b18f478eefd60b7a6e0a3a9edc81de60", "author": {"user": {"login": "clementetb", "name": null}}, "url": "https://github.com/realm/realm-java/commit/b6430333b18f478eefd60b7a6e0a3a9edc81de60", "committedDate": "2020-08-25T08:54:37Z", "message": "Merge branch 'v10' into ct/watch-event-streams"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2293, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}