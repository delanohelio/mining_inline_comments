{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5OTI1MjY0", "number": 4744, "title": "DB-10895 Complete DB2 varchar compatibility for MultiProbeScan.", "bodyText": "This completes the work to support DB2 varchar compatibility mode for queries using MultiProbeScan.\nTrailing spaces are ignored when comparing a varchar with any other string.  Normally in Splice, comparisons of varchars do not ignore trailing spaces.  The original work was done by DB-10597, which utilizes a new SQLVarcharDB2Compatible DataValueDescriptor in place of SQLVarchar, where required.  This follow-on work uses the same approach.\n\ncall syscs_util.syscs_set_global_database_property('splice.db2.varchar.compatible', true);\ncreate table t (v varchar(14), c char(2));\ncreate index ti on t (v,c);\ninsert into t values ('ABC','A ');\n/* Should return one row. */\nselect * from t --splice-properties index=ti\nWHERE v in ( ' ', 'ABC      ');", "createdAt": "2020-12-01T02:15:49Z", "url": "https://github.com/splicemachine/spliceengine/pull/4744", "merged": true, "mergeCommit": {"oid": "0328e223466a3f94fb83bd3441154a9e1471395f"}, "closed": true, "closedAt": "2020-12-03T00:06:10Z", "author": {"login": "msirek"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdhwOFnAH2gAyNTI5OTI1MjY0OjAyN2FhYjRkZDk1MTYxZGJjNTRhNzVlZTE0YmUwZDlhNzgyODMwNDU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdiUm-cAH2gAyNTI5OTI1MjY0OjA3ODhjY2QyNTIwMDk0NjdhNzFjYzA2MTA4YWMzMDE1NTc3NTFiZDk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "027aab4dd95161dbc54a75ee14be0d9a78283045", "author": {"user": {"login": "msirek", "name": "Mark Sirek"}}, "url": "https://github.com/splicemachine/spliceengine/commit/027aab4dd95161dbc54a75ee14be0d9a78283045", "committedDate": "2020-12-01T02:07:34Z", "message": "DB-10895 Complete DB2 varchar compatibility for MultiProbeScan."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNzI4MTU0", "url": "https://github.com/splicemachine/spliceengine/pull/4744#pullrequestreview-541728154", "createdAt": "2020-12-01T09:52:21Z", "commit": {"oid": "027aab4dd95161dbc54a75ee14be0d9a78283045"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTo1MjoyMlrOH8i5Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTo1NToyNFrOH8jI3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI0ODMwNg==", "bodyText": "same code as 347-361. i think we should combine those in a function", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533248306", "createdAt": "2020-12-01T09:52:22Z", "author": {"login": "martinrupp"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/MultiProbeDerbyScanInformation.java", "diffHunk": "@@ -293,39 +301,64 @@ public void readExternal(ObjectInput in) throws IOException, ClassNotFoundExcept\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint maxSize = dtd.getMaximumWidth();\n+\t\t\t\tDataValueDescriptor targetDesc = templateRow.getColumn(keyTablePositionMap[keyDecodingMap[position]] + 1);\n+\t\t\t\tboolean targetIsSQLVarcharDB2Compatible = targetDesc instanceof SQLVarcharDB2Compatible;\n \t\t\t\tfor (int index = 0; index < probingVals.length; index++) {\n \t\t\t\t\t DataValueDescriptor dvd = probingVals[index];\n \t\t\t\t\t if (dvd instanceof ListDataType) {\n \t\t\t\t\t\t ListDataType listData = (ListDataType) dvd;\n \t\t\t\t\t\t DataValueDescriptor dvd1 = listData.getDVD(position);\n-\t\t\t\t\t\t if (dvd1 instanceof SQLChar) {\n+\t\t\t\t\t\t boolean isSQLVarcharDB2Compatible = dvd1 instanceof SQLVarcharDB2Compatible;\n+\t\t\t\t\t\t if (isSQLVarcharDB2Compatible) {\n+\t\t\t\t\t\t\tDataValueDescriptor newDVD =\n+\t\t\t\t\t\t\t\tQualifierUtils.convertChar((SQLChar) dvd1, dvd1.getLength(),\n+\t\t\t\t\t\t\t\t                           inlistDataTypes[position].getMaximumWidth());\n+\t\t\t\t\t\t\tlistData.setDVD(position, newDVD);\n+\t\t\t\t\t\t }\n+\t\t\t\t\t\t else if (dvd1 instanceof SQLChar) {\n \t\t\t\t\t\t \t// we may prune some probe value based on the string length\n-\t\t\t\t\t\t \tif (isFixedCharType && dvd1.getLength() != maxSize) {\n-\t\t\t\t\t\t\t\ttoRemove[index] = true;\n-\t\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t\t} else if (isVarCharType && dvd1.getLength() > maxSize) {\n+\t\t\t\t\t\t \tif (isVarCharType && dvd1.getLength() > maxSize &&\n+\t\t\t\t\t\t\t    !targetIsSQLVarcharDB2Compatible) {\n \t\t\t\t\t\t\t\ttoRemove[index] = true;\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t // if column is of varchar type, we need to change the probe values from SQLChar to SQLVarchar,\n-\t\t\t\t\t\t\t // so that duplicate removal won't ignore the trailing spaces\n-\t\t\t\t\t\t\t if (isVarCharType && !(dvd1 instanceof SQLVarchar))\n-\t\t\t\t\t\t\t\t listData.setDVD(position, new SQLVarchar(dvd1.getString()));\n+\t\t\t\t\t\t\t // so that duplicate removal won't ignore the trailing spaces,\n+\t\t\t\t\t\t\t // unless we're in DB2 varchar compatibility mode.\n+\t\t\t\t\t\t\t if (isVarCharType) {\n+\t\t\t\t\t\t\t \tif (targetIsSQLVarcharDB2Compatible) {\n+\t\t\t\t\t\t\t \t\tif (dvd1.getClass().equals(SQLVarchar.class))\n+\t\t\t\t\t\t\t \t\t\tlistData.setDVD(position,\n+\t\t\t\t\t\t\t\t\t\t                new SQLVarcharDB2Compatible(dvd1.getString()));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t \telse if (!(dvd1 instanceof SQLVarchar))\n+\t\t\t\t\t\t\t\t     listData.setDVD(position, new SQLVarchar(dvd1.getString()));\n+\t\t\t\t\t\t\t }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "027aab4dd95161dbc54a75ee14be0d9a78283045"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1MjMxNw==", "bodyText": "this strings are weirdly intended. i think we should intend multi-line commands like e.g.\nString sqlTemplate = \"select * from t a --splice-properties useSpark=\" + useSpark.toString() +\n        \", index=%s\\n\" +\n        \"where v in ('SBVGCCC    ', 'G')\\n\" +\n        \"and c in ( ' ', CAST('A' AS CHAR(2)))\";", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533252317", "createdAt": "2020-12-01T09:55:24Z", "author": {"login": "martinrupp"}, "path": "splice_machine/src/test/java/com/splicemachine/db/impl/sql/compile/DB2VarcharCompatibilityIT.java", "diffHunk": "@@ -325,4 +340,140 @@ public void testInvalidateStoredStatements() throws Exception {\n         // Restore the flag setting to the value when this test started.\n         methodWatcher.executeUpdate(\"call syscs_util.syscs_set_global_database_property('splice.db2.varchar.compatible', true)\");\n     }\n+\n+    @Test\n+    public void testMultiProbeScan() throws Exception {\n+        String sqlTemplate = \"select * from t a --splice-properties useSpark=\" + useSpark.toString() +\n+        \", index=%s\\n\" +\n+        \"where v in ('SBVGCCC    ', 'G')\\n\" +\n+        \"and c in ( ' ', CAST('A' AS CHAR(2)))\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "027aab4dd95161dbc54a75ee14be0d9a78283045"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNzk3MTU4", "url": "https://github.com/splicemachine/spliceengine/pull/4744#pullrequestreview-541797158", "createdAt": "2020-12-01T11:18:00Z", "commit": {"oid": "027aab4dd95161dbc54a75ee14be0d9a78283045"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMToxODowMFrOH8n-xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMToyNjozMFrOH8oRng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzMTY1Mg==", "bodyText": "It feels dangerous to change usefulCount to 1 here because usefulCount is used not only for multi-probe scan construction but also later to determine start/stop keys. Suppose we have several other predicates together with one in-list on a varchar column so we enter this code path. Setting usefulCount to 1 would prevent all other predicates to be scan start/stop keys. Or am I missing anything?\nIf we don't want to build a MultiProbe...Scan for this in-list, is it sufficient to remove it from inlistPreds and clean up its states in other data structures (e.g., usefulPredicates[], usefulCount--, isEquality[], etc.) ?", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533331652", "createdAt": "2020-12-01T11:18:00Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java", "diffHunk": "@@ -1111,15 +1116,28 @@ private void orderUsefulPredicates(Optimizable optTable,\n         ArrayList<Predicate> predsForNewInList = null;\n     \n         if (inlistQualified) {\n-          // Only combine multiple IN lists if not using Spark.\n-          // Adding extra RDDs and unioning them together hinders performance.\n-          if (inlistPreds.size() > 1) {\n+          // In DB2 mode, probe keys can be overlapping with eachother.\n+          // On HBase the overlapping keys are merged together, but on\n+          // mem they aren't causing duplicate rows.  So here we avoid\n+          // constructing the overlapping keys on mem.\n+          boolean varcharDB2CompatibilityMode = getCompilerContext().getVarcharDB2CompatibilityMode();\n+          if (varcharDB2CompatibilityMode && isMemPlatform()) {\n+              BinaryRelationalOperatorNode bron =\n+                  (BinaryRelationalOperatorNode) usefulPredicates[0].getRelop();\n+              boolean isVarChar =\n+                  bron.getLeftOperand().getTypeServices().\n+                         getTypeName().equals(TypeId.VARCHAR_NAME);\n+              if (isVarChar)\n+                  usefulCount = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "027aab4dd95161dbc54a75ee14be0d9a78283045"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzNjQ3OA==", "bodyText": "+1 for this", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533336478", "createdAt": "2020-12-01T11:26:30Z", "author": {"login": "ascend1"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/MultiProbeDerbyScanInformation.java", "diffHunk": "@@ -293,39 +301,64 @@ public void readExternal(ObjectInput in) throws IOException, ClassNotFoundExcept\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint maxSize = dtd.getMaximumWidth();\n+\t\t\t\tDataValueDescriptor targetDesc = templateRow.getColumn(keyTablePositionMap[keyDecodingMap[position]] + 1);\n+\t\t\t\tboolean targetIsSQLVarcharDB2Compatible = targetDesc instanceof SQLVarcharDB2Compatible;\n \t\t\t\tfor (int index = 0; index < probingVals.length; index++) {\n \t\t\t\t\t DataValueDescriptor dvd = probingVals[index];\n \t\t\t\t\t if (dvd instanceof ListDataType) {\n \t\t\t\t\t\t ListDataType listData = (ListDataType) dvd;\n \t\t\t\t\t\t DataValueDescriptor dvd1 = listData.getDVD(position);\n-\t\t\t\t\t\t if (dvd1 instanceof SQLChar) {\n+\t\t\t\t\t\t boolean isSQLVarcharDB2Compatible = dvd1 instanceof SQLVarcharDB2Compatible;\n+\t\t\t\t\t\t if (isSQLVarcharDB2Compatible) {\n+\t\t\t\t\t\t\tDataValueDescriptor newDVD =\n+\t\t\t\t\t\t\t\tQualifierUtils.convertChar((SQLChar) dvd1, dvd1.getLength(),\n+\t\t\t\t\t\t\t\t                           inlistDataTypes[position].getMaximumWidth());\n+\t\t\t\t\t\t\tlistData.setDVD(position, newDVD);\n+\t\t\t\t\t\t }\n+\t\t\t\t\t\t else if (dvd1 instanceof SQLChar) {\n \t\t\t\t\t\t \t// we may prune some probe value based on the string length\n-\t\t\t\t\t\t \tif (isFixedCharType && dvd1.getLength() != maxSize) {\n-\t\t\t\t\t\t\t\ttoRemove[index] = true;\n-\t\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t\t} else if (isVarCharType && dvd1.getLength() > maxSize) {\n+\t\t\t\t\t\t \tif (isVarCharType && dvd1.getLength() > maxSize &&\n+\t\t\t\t\t\t\t    !targetIsSQLVarcharDB2Compatible) {\n \t\t\t\t\t\t\t\ttoRemove[index] = true;\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t // if column is of varchar type, we need to change the probe values from SQLChar to SQLVarchar,\n-\t\t\t\t\t\t\t // so that duplicate removal won't ignore the trailing spaces\n-\t\t\t\t\t\t\t if (isVarCharType && !(dvd1 instanceof SQLVarchar))\n-\t\t\t\t\t\t\t\t listData.setDVD(position, new SQLVarchar(dvd1.getString()));\n+\t\t\t\t\t\t\t // so that duplicate removal won't ignore the trailing spaces,\n+\t\t\t\t\t\t\t // unless we're in DB2 varchar compatibility mode.\n+\t\t\t\t\t\t\t if (isVarCharType) {\n+\t\t\t\t\t\t\t \tif (targetIsSQLVarcharDB2Compatible) {\n+\t\t\t\t\t\t\t \t\tif (dvd1.getClass().equals(SQLVarchar.class))\n+\t\t\t\t\t\t\t \t\t\tlistData.setDVD(position,\n+\t\t\t\t\t\t\t\t\t\t                new SQLVarcharDB2Compatible(dvd1.getString()));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t \telse if (!(dvd1 instanceof SQLVarchar))\n+\t\t\t\t\t\t\t\t     listData.setDVD(position, new SQLVarchar(dvd1.getString()));\n+\t\t\t\t\t\t\t }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI0ODMwNg=="}, "originalCommit": {"oid": "027aab4dd95161dbc54a75ee14be0d9a78283045"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxOTY0NDE1", "url": "https://github.com/splicemachine/spliceengine/pull/4744#pullrequestreview-541964415", "createdAt": "2020-12-01T14:39:42Z", "commit": {"oid": "027aab4dd95161dbc54a75ee14be0d9a78283045"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDozOTo0M1rOH8voDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDo0MjoxOVrOH8v2MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ1NjkwOA==", "bodyText": "Is it possible to avoid this?", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533456908", "createdAt": "2020-12-01T14:39:43Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java", "diffHunk": "@@ -847,6 +848,10 @@ private void saveOriginalInListPreds(Predicate newPred, List<Predicate> predsFor\n         newPred.setOriginalInListPredList(origList);\n     }\n \n+    private boolean isMemPlatform() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "027aab4dd95161dbc54a75ee14be0d9a78283045"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ2MDUyOA==", "bodyText": "Can we fix this on Mem by merging those keys? I dislike introducing knowledge of the platform in the engine itself.", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533460528", "createdAt": "2020-12-01T14:42:19Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java", "diffHunk": "@@ -1111,15 +1116,28 @@ private void orderUsefulPredicates(Optimizable optTable,\n         ArrayList<Predicate> predsForNewInList = null;\n     \n         if (inlistQualified) {\n-          // Only combine multiple IN lists if not using Spark.\n-          // Adding extra RDDs and unioning them together hinders performance.\n-          if (inlistPreds.size() > 1) {\n+          // In DB2 mode, probe keys can be overlapping with eachother.\n+          // On HBase the overlapping keys are merged together, but on\n+          // mem they aren't causing duplicate rows.  So here we avoid", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "027aab4dd95161dbc54a75ee14be0d9a78283045"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3876bc431b564b7521b33940ae7cfe3d26068c9b", "author": {"user": {"login": "msirek", "name": "Mark Sirek"}}, "url": "https://github.com/splicemachine/spliceengine/commit/3876bc431b564b7521b33940ae7cfe3d26068c9b", "committedDate": "2020-12-01T21:56:31Z", "message": "DB-10895 Address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyOTc5NTQ0", "url": "https://github.com/splicemachine/spliceengine/pull/4744#pullrequestreview-542979544", "createdAt": "2020-12-02T15:53:54Z", "commit": {"oid": "3876bc431b564b7521b33940ae7cfe3d26068c9b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNTo1Mzo1NFrOH9hudw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNTo1Mzo1NFrOH9hudw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3Nzc1MQ==", "bodyText": "Remove this since we don't rely on it anymore.", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r534277751", "createdAt": "2020-12-02T15:53:54Z", "author": {"login": "dgomezferro"}, "path": "mem_sql/src/main/java/com/splicemachine/derby/lifecycle/MemDatabase.java", "diffHunk": "@@ -59,6 +59,7 @@ public static void main(String...args) throws Exception{\n             System.setProperty(\"com.splicemachine.enableLegacyAsserts\",Boolean.TRUE.toString());\n             SanityManager.DEBUG_SET(\"DumpOptimizedTree\");\n         }\n+        System.setProperty(\"com.splicemachine.isMemPlatform\",Boolean.TRUE.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3876bc431b564b7521b33940ae7cfe3d26068c9b"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5838bd2e31f166387edd3863eec6872cfe38498", "author": {"user": {"login": "msirek", "name": "Mark Sirek"}}, "url": "https://github.com/splicemachine/spliceengine/commit/b5838bd2e31f166387edd3863eec6872cfe38498", "committedDate": "2020-12-02T16:06:08Z", "message": "DB-10895 Address review comments, part 2."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMDE3NTAx", "url": "https://github.com/splicemachine/spliceengine/pull/4744#pullrequestreview-543017501", "createdAt": "2020-12-02T16:30:53Z", "commit": {"oid": "b5838bd2e31f166387edd3863eec6872cfe38498"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMDkwNjY0", "url": "https://github.com/splicemachine/spliceengine/pull/4744#pullrequestreview-543090664", "createdAt": "2020-12-02T17:49:05Z", "commit": {"oid": "b5838bd2e31f166387edd3863eec6872cfe38498"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0788ccd252009467a71cc06108ac301557751bd9", "author": {"user": {"login": "msirek", "name": "Mark Sirek"}}, "url": "https://github.com/splicemachine/spliceengine/commit/0788ccd252009467a71cc06108ac301557751bd9", "committedDate": "2020-12-02T20:31:20Z", "message": "DB-10895 Fix InListMultiprobeIT"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1039, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}