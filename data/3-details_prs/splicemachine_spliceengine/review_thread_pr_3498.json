{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwODc0MjYy", "number": 3498, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1OTowMVrOD78-fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODowMTo0MlrOD79CNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTkxNjEzOnYy", "diffSide": "RIGHT", "path": "hbase_sql/src/main/java/com/splicemachine/compactions/SpliceCompactionRequest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1OTowMVrOGUl3hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODo1MDo1NVrOGUn1Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0NTEyNw==", "bodyText": "Now that I look at the code and the comment, the memstoreAware field already had the role of guarding against failed compactions, if compactionCountIncremented is false then memstoreAware will also be null, right? I think compactionCountIncremented is redundant.", "url": "https://github.com/splicemachine/spliceengine/pull/3498#discussion_r424245127", "createdAt": "2020-05-13T07:59:01Z", "author": {"login": "dgomezferro"}, "path": "hbase_sql/src/main/java/com/splicemachine/compactions/SpliceCompactionRequest.java", "diffHunk": "@@ -51,19 +55,35 @@ public void preStorefilesRename() throws IOException {\n                 }\n                 continue;\n             }\n-            if(memstoreAware.compareAndSet(latest, MemstoreAware.incrementCompactionCount(latest)))\n+            if(memstoreAware.compareAndSet(latest, MemstoreAware.incrementCompactionCount(latest))) {\n+                if(LOG.isDebugEnabled()) {\n+                    SpliceLogUtils.debug(LOG, \"memstoreAware@\" + System.identityHashCode(memstoreAware) +\n+                            \" 's compactionCount incremented from \" + latest.currentCompactionCount +\n+                            \" to \" + (latest.currentCompactionCount + 1));\n+                }\n+                assert !compactionCountIncremented;\n+                compactionCountIncremented = true;\n                 break;\n+            }\n         }\n     }\n     public void afterExecute(){\n-        if (memstoreAware == null) {\n+        if (memstoreAware == null || !compactionCountIncremented) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9968c9044b37f9cf0552b64a67f116fed61c3a33"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI3NDkyOQ==", "bodyText": "I don't think so. Without compactionCountIncremented, we end up decrementing compactionCount below 0.\nThat's because we setMemstoreAware in preCompact but we call preStorefilesRename after the actual execution in SpliceDefaultCompactor.compact()", "url": "https://github.com/splicemachine/spliceengine/pull/3498#discussion_r424274929", "createdAt": "2020-05-13T08:47:09Z", "author": {"login": "arnaud-splice"}, "path": "hbase_sql/src/main/java/com/splicemachine/compactions/SpliceCompactionRequest.java", "diffHunk": "@@ -51,19 +55,35 @@ public void preStorefilesRename() throws IOException {\n                 }\n                 continue;\n             }\n-            if(memstoreAware.compareAndSet(latest, MemstoreAware.incrementCompactionCount(latest)))\n+            if(memstoreAware.compareAndSet(latest, MemstoreAware.incrementCompactionCount(latest))) {\n+                if(LOG.isDebugEnabled()) {\n+                    SpliceLogUtils.debug(LOG, \"memstoreAware@\" + System.identityHashCode(memstoreAware) +\n+                            \" 's compactionCount incremented from \" + latest.currentCompactionCount +\n+                            \" to \" + (latest.currentCompactionCount + 1));\n+                }\n+                assert !compactionCountIncremented;\n+                compactionCountIncremented = true;\n                 break;\n+            }\n         }\n     }\n     public void afterExecute(){\n-        if (memstoreAware == null) {\n+        if (memstoreAware == null || !compactionCountIncremented) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0NTEyNw=="}, "originalCommit": {"oid": "9968c9044b37f9cf0552b64a67f116fed61c3a33"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI3NzI1MA==", "bodyText": "That's right, I got confused and thought we were setting it in preStorefilesRename. Looks good!", "url": "https://github.com/splicemachine/spliceengine/pull/3498#discussion_r424277250", "createdAt": "2020-05-13T08:50:55Z", "author": {"login": "dgomezferro"}, "path": "hbase_sql/src/main/java/com/splicemachine/compactions/SpliceCompactionRequest.java", "diffHunk": "@@ -51,19 +55,35 @@ public void preStorefilesRename() throws IOException {\n                 }\n                 continue;\n             }\n-            if(memstoreAware.compareAndSet(latest, MemstoreAware.incrementCompactionCount(latest)))\n+            if(memstoreAware.compareAndSet(latest, MemstoreAware.incrementCompactionCount(latest))) {\n+                if(LOG.isDebugEnabled()) {\n+                    SpliceLogUtils.debug(LOG, \"memstoreAware@\" + System.identityHashCode(memstoreAware) +\n+                            \" 's compactionCount incremented from \" + latest.currentCompactionCount +\n+                            \" to \" + (latest.currentCompactionCount + 1));\n+                }\n+                assert !compactionCountIncremented;\n+                compactionCountIncremented = true;\n                 break;\n+            }\n         }\n     }\n     public void afterExecute(){\n-        if (memstoreAware == null) {\n+        if (memstoreAware == null || !compactionCountIncremented) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0NTEyNw=="}, "originalCommit": {"oid": "9968c9044b37f9cf0552b64a67f116fed61c3a33"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTkyMTA3OnYy", "diffSide": "RIGHT", "path": "hbase_sql/src/main/java/com/splicemachine/compactions/SpliceCompactionRequest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODowMDoyN1rOGUl6zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODo0MDowNlrOGUnZtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0NTk2NQ==", "bodyText": "These two methods can be removed since they don't change the superclass implementation.", "url": "https://github.com/splicemachine/spliceengine/pull/3498#discussion_r424245965", "createdAt": "2020-05-13T08:00:27Z", "author": {"login": "dgomezferro"}, "path": "hbase_sql/src/main/java/com/splicemachine/compactions/SpliceCompactionRequest.java", "diffHunk": "@@ -82,4 +102,26 @@ public void setRegion(HRegion region) {\n         this.region = region;\n     }\n \n+    @Override\n+    public void setOffPeak(boolean value) {\n+        // We hijack setOffPeak because it is only called twice:\n+        // 1. set to true in SpliceDefaultCompactionPolicy before compaction happens\n+        // 2. set to false in HStore.finishCompactionRequest (hbase code)\n+        // At those points, the value passed is irrelevant and is \"only\" used for logging\n+        // purpose, so we can hijack it.\n+        super.setOffPeak(value);\n+        if (!value) {\n+            afterExecute();\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9968c9044b37f9cf0552b64a67f116fed61c3a33"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI3MDI2Mw==", "bodyText": "Those are there as documentation to satisfy spotbugs.", "url": "https://github.com/splicemachine/spliceengine/pull/3498#discussion_r424270263", "createdAt": "2020-05-13T08:40:06Z", "author": {"login": "arnaud-splice"}, "path": "hbase_sql/src/main/java/com/splicemachine/compactions/SpliceCompactionRequest.java", "diffHunk": "@@ -82,4 +102,26 @@ public void setRegion(HRegion region) {\n         this.region = region;\n     }\n \n+    @Override\n+    public void setOffPeak(boolean value) {\n+        // We hijack setOffPeak because it is only called twice:\n+        // 1. set to true in SpliceDefaultCompactionPolicy before compaction happens\n+        // 2. set to false in HStore.finishCompactionRequest (hbase code)\n+        // At those points, the value passed is irrelevant and is \"only\" used for logging\n+        // purpose, so we can hijack it.\n+        super.setOffPeak(value);\n+        if (!value) {\n+            afterExecute();\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0NTk2NQ=="}, "originalCommit": {"oid": "9968c9044b37f9cf0552b64a67f116fed61c3a33"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTkyNTY0OnYy", "diffSide": "RIGHT", "path": "hbase_sql/src/main/java/com/splicemachine/compactions/SpliceDefaultCompactionPolicy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODowMTo0MlrOGUl9pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwOTozNzozMVrOGUpmhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0NjY5Mg==", "bodyText": "Are there any interactions with real off-peak compactions scheduled from HBase?", "url": "https://github.com/splicemachine/spliceengine/pull/3498#discussion_r424246692", "createdAt": "2020-05-13T08:01:42Z", "author": {"login": "dgomezferro"}, "path": "hbase_sql/src/main/java/com/splicemachine/compactions/SpliceDefaultCompactionPolicy.java", "diffHunk": "@@ -48,7 +48,9 @@ public CompactionRequestImpl selectCompaction(Collection<HStoreFile> candidateFi\n         HRegion region = store.getHRegion();\n         String storeName = store.getColumnFamilyName();\n         scr.setIsMajor(cr.isMajor(), cr.isAllFiles());\n-        scr.setOffPeak(cr.isOffPeak());\n+        // Ignoring cr.isOffPeak() and hardcoding true because SpliceCompactionRequest.setOffPeak is hijacked to run\n+        // SpliceCompactionRequest.afterExecute if isOffPeak(false) is called.\n+        scr.setOffPeak(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9968c9044b37f9cf0552b64a67f116fed61c3a33"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMwNjMwOQ==", "bodyText": "Based on what I could see, this parameter was ignored anyway, so it should not have any impact.", "url": "https://github.com/splicemachine/spliceengine/pull/3498#discussion_r424306309", "createdAt": "2020-05-13T09:37:31Z", "author": {"login": "arnaud-splice"}, "path": "hbase_sql/src/main/java/com/splicemachine/compactions/SpliceDefaultCompactionPolicy.java", "diffHunk": "@@ -48,7 +48,9 @@ public CompactionRequestImpl selectCompaction(Collection<HStoreFile> candidateFi\n         HRegion region = store.getHRegion();\n         String storeName = store.getColumnFamilyName();\n         scr.setIsMajor(cr.isMajor(), cr.isAllFiles());\n-        scr.setOffPeak(cr.isOffPeak());\n+        // Ignoring cr.isOffPeak() and hardcoding true because SpliceCompactionRequest.setOffPeak is hijacked to run\n+        // SpliceCompactionRequest.afterExecute if isOffPeak(false) is called.\n+        scr.setOffPeak(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0NjY5Mg=="}, "originalCommit": {"oid": "9968c9044b37f9cf0552b64a67f116fed61c3a33"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3208, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}