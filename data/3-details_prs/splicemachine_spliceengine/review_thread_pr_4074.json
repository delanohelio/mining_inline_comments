{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3OTc5MDg0", "number": 4074, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNToyMzoyOVrOEgPrwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNjoyNzo1NFrOEgQfdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjQ2ODQ5OnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNToyMzoyOVrOHM__0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzowODoxN1rOHThN8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5MzQ5MA==", "bodyText": "This token should not be put in the reserved kyeword section, it should be put in the nonReservedKeyword() section.", "url": "https://github.com/splicemachine/spliceengine/pull/4074#discussion_r483393490", "createdAt": "2020-09-04T05:23:29Z", "author": {"login": "yxia92"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj", "diffHunk": "@@ -17796,6 +17818,7 @@ reservedKeyword() :\n |    tok = <FUNCTION>\n |    tok = <GET>\n |    tok = <GET_CURRENT_CONNECTION>\n+|    tok = <GET_NEAREST_TRANSACTION>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7019b47f1536da0ce877d3d22dd4a31e969bcd8"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIyOTIzNA==", "bodyText": "done.", "url": "https://github.com/splicemachine/spliceengine/pull/4074#discussion_r490229234", "createdAt": "2020-09-17T13:08:17Z", "author": {"login": "hatyo"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj", "diffHunk": "@@ -17796,6 +17818,7 @@ reservedKeyword() :\n |    tok = <FUNCTION>\n |    tok = <GET>\n |    tok = <GET_CURRENT_CONNECTION>\n+|    tok = <GET_NEAREST_TRANSACTION>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5MzQ5MA=="}, "originalCommit": {"oid": "f7019b47f1536da0ce877d3d22dd4a31e969bcd8"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjYwMDg2OnYy", "diffSide": "RIGHT", "path": "splice_machine/src/test/java/com/splicemachine/derby/transactions/GetNearestTransactionIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNjoyNzo1NFrOHNBNdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzowMzoxOFrOHThA-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQxMzM2NA==", "bodyText": "If there are other ITs running concurrently at the time of this test, and there is another write txn goes in between the two calls of values get_nearest_transaction(current_timestamp), would we guarantee to get result1=result2?", "url": "https://github.com/splicemachine/spliceengine/pull/4074#discussion_r483413364", "createdAt": "2020-09-04T06:27:54Z", "author": {"login": "yxia92"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/transactions/GetNearestTransactionIT.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.derby.transactions;\n+\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceTableWatcher;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import com.splicemachine.derby.test.framework.TestConnection;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import static org.hamcrest.Matchers.lessThan;\n+\n+public class GetNearestTransactionIT {\n+\n+    private static final String schemaName = GetNearestTransactionIT.class.getSimpleName().toUpperCase();\n+\n+    private static final SpliceSchemaWatcher schemaWatcher = new SpliceSchemaWatcher(schemaName);\n+\n+    private static final SpliceTableWatcher table = new SpliceTableWatcher(\"A\",schemaWatcher.schemaName,\"(a INT)\");\n+\n+    private static final SpliceWatcher classWatcher = new SpliceWatcher();\n+\n+    @ClassRule\n+    public static TestRule chain = RuleChain.outerRule(classWatcher)\n+            .around(schemaWatcher)\n+            .around(table);\n+\n+    private static TestConnection conn;\n+    private static TestConnection connACOff;\n+\n+    @BeforeClass\n+    public static void setUpClass() throws Exception {\n+        conn = classWatcher.getOrCreateConnection();\n+        connACOff = classWatcher.createConnection();\n+        connACOff.setAutoCommit(false);\n+    }\n+\n+    long resultOf(String query, TestConnection conn) throws SQLException {\n+        ResultSet rs = conn.query(query);\n+        Assert.assertTrue(rs.next());\n+        long result = rs.getLong(1);\n+        Assert.assertFalse(rs.wasNull());\n+        Assert.assertFalse(rs.next());\n+        return result;\n+    }\n+\n+    @Test\n+    public void GetNearestTransactionBeforeFirstTransactionReturnsNull() throws Exception {\n+        ResultSet rs = conn.query(\"VALUES get_nearest_Transaction(TIMESTAMPADD(SQL_TSI_MONTH, -10, CURRENT_TIMESTAMP ))\");\n+        Assert.assertTrue(rs.next());\n+        Assert.assertEquals(0, rs.getLong(1));\n+        Assert.assertTrue(rs.wasNull());\n+        Assert.assertFalse(rs.next());\n+    }\n+\n+    @Test\n+    public void GetNearestTransactionWorksCorrectlyWithAutoCommit() throws Exception {\n+        try {\n+            long result1 = resultOf(\"VALUES get_nearest_Transaction(CURRENT_TIMESTAMP)\", connACOff);\n+            long result2 = resultOf(\"VALUES get_nearest_Transaction(CURRENT_TIMESTAMP)\", connACOff);\n+            Assert.assertEquals(result1, result2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7019b47f1536da0ce877d3d22dd4a31e969bcd8"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIyNTkxMw==", "bodyText": "You're right, this test could fail if other tests run on parallel with it.", "url": "https://github.com/splicemachine/spliceengine/pull/4074#discussion_r490225913", "createdAt": "2020-09-17T13:03:18Z", "author": {"login": "hatyo"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/transactions/GetNearestTransactionIT.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.derby.transactions;\n+\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceTableWatcher;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import com.splicemachine.derby.test.framework.TestConnection;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import static org.hamcrest.Matchers.lessThan;\n+\n+public class GetNearestTransactionIT {\n+\n+    private static final String schemaName = GetNearestTransactionIT.class.getSimpleName().toUpperCase();\n+\n+    private static final SpliceSchemaWatcher schemaWatcher = new SpliceSchemaWatcher(schemaName);\n+\n+    private static final SpliceTableWatcher table = new SpliceTableWatcher(\"A\",schemaWatcher.schemaName,\"(a INT)\");\n+\n+    private static final SpliceWatcher classWatcher = new SpliceWatcher();\n+\n+    @ClassRule\n+    public static TestRule chain = RuleChain.outerRule(classWatcher)\n+            .around(schemaWatcher)\n+            .around(table);\n+\n+    private static TestConnection conn;\n+    private static TestConnection connACOff;\n+\n+    @BeforeClass\n+    public static void setUpClass() throws Exception {\n+        conn = classWatcher.getOrCreateConnection();\n+        connACOff = classWatcher.createConnection();\n+        connACOff.setAutoCommit(false);\n+    }\n+\n+    long resultOf(String query, TestConnection conn) throws SQLException {\n+        ResultSet rs = conn.query(query);\n+        Assert.assertTrue(rs.next());\n+        long result = rs.getLong(1);\n+        Assert.assertFalse(rs.wasNull());\n+        Assert.assertFalse(rs.next());\n+        return result;\n+    }\n+\n+    @Test\n+    public void GetNearestTransactionBeforeFirstTransactionReturnsNull() throws Exception {\n+        ResultSet rs = conn.query(\"VALUES get_nearest_Transaction(TIMESTAMPADD(SQL_TSI_MONTH, -10, CURRENT_TIMESTAMP ))\");\n+        Assert.assertTrue(rs.next());\n+        Assert.assertEquals(0, rs.getLong(1));\n+        Assert.assertTrue(rs.wasNull());\n+        Assert.assertFalse(rs.next());\n+    }\n+\n+    @Test\n+    public void GetNearestTransactionWorksCorrectlyWithAutoCommit() throws Exception {\n+        try {\n+            long result1 = resultOf(\"VALUES get_nearest_Transaction(CURRENT_TIMESTAMP)\", connACOff);\n+            long result2 = resultOf(\"VALUES get_nearest_Transaction(CURRENT_TIMESTAMP)\", connACOff);\n+            Assert.assertEquals(result1, result2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQxMzM2NA=="}, "originalCommit": {"oid": "f7019b47f1536da0ce877d3d22dd4a31e969bcd8"}, "originalPosition": 81}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3034, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}