{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0ODU3NTQ1", "number": 3771, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDoyNzowNlrOEMBE7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzozMzoyNFrOEV7QjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDM2MDEyOnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/execute/ResultSetFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDoyNzowNlrOGt4fcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDoyNzowNlrOGt4fcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NDY1OA==", "bodyText": "@yxia92 @jyuanca do we need to do something here regarding upgrades?", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450764658", "createdAt": "2020-07-07T10:27:06Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/execute/ResultSetFactory.java", "diffHunk": "@@ -1012,7 +1013,8 @@ NoPutResultSet getTableScanResultSet(\n \t\t\t\t\t\t\t\tString location,\n \t\t\t\t\t\t\t\tint partitionByRefItem,\n \t\t\t\t\t\t\t\tGeneratedMethod defaultRowFunc,\n-\t\t\t\t\t\t\t\tint defaultValueMapItem\n+\t\t\t\t\t\t\t\tint defaultValueMapItem,\n+\t\t\t\t\t\t\t\tGeneratedMethod pastTxFunctor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDM2Mjg5OnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDoyNzo1NFrOGt4hEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNTo1NjowN1rOGxaOMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NTA3Mg==", "bodyText": "I'm not a fan of the isBulkDeleteOrTxId parameter, would it be possible to add an extra parameter for the transaction id ?", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450765072", "createdAt": "2020-07-07T10:27:54Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -196,36 +196,30 @@\n     private AggregateNode aggrForSpecialMaxScan;\n \n     private boolean isBulkDelete = false;\n+\n+    private ValueNode pastTxIdExpression = null;\n+\n     @Override\n     public boolean isParallelizable(){\n         return false;\n     }\n \n     /**\n-     * Initializer for a table in a FROM list. Parameters are as follows:\n-     * <p/>\n-     * <ul>\n-     * <li>tableName            The name of the table</li>\n-     * <li>correlationName    The correlation name</li>\n-     * <li>derivedRCL        The derived column list</li>\n-     * <li>tableProperties    The Properties list associated with the table.</li>\n-     * </ul>\n-     * <p/>\n-     * <p>\n-     * - OR -\n-     * </p>\n-     * <p/>\n-     * <ul>\n-     * <li>tableName            The name of the table</li>\n-     * <li>correlationName    The correlation name</li>\n-     * <li>updateOrDelete    Table is being updated/deleted from. </li>\n-     * <li>derivedRCL        The derived column list</li>\n-     * </ul>\n+     * Initializer for a table in a FROM list.\n+     * @param tableName The name of the table\n+     * @param correlationName The correlation name\n+     * @param rclOrUD update/delete flag or result column list\n+     * @param propsOrRcl properties or result column list\n+     * @param isBulkDeleteOrTxId bulk delete flag or past tx id expression.\n      */\n     @Override\n-    public void init(Object tableName,Object correlationName,Object rclOrUD,Object propsOrRcl, Object isBulkDelete){\n+    public void init(Object tableName,Object correlationName,Object rclOrUD,Object propsOrRcl, Object isBulkDeleteOrTxId){\n+        if(isBulkDeleteOrTxId instanceof Boolean) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ2MzAyNA==", "bodyText": "Right, I did it in the base change (DB-9714). The new signature looks like this:\npublic void init(Object tableName,Object correlationName,Object rclOrUD,Object propsOrRcl, Object isBulkDelete, Object pastTxIdExpr)", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r454463024", "createdAt": "2020-07-14T15:56:07Z", "author": {"login": "hatyo"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -196,36 +196,30 @@\n     private AggregateNode aggrForSpecialMaxScan;\n \n     private boolean isBulkDelete = false;\n+\n+    private ValueNode pastTxIdExpression = null;\n+\n     @Override\n     public boolean isParallelizable(){\n         return false;\n     }\n \n     /**\n-     * Initializer for a table in a FROM list. Parameters are as follows:\n-     * <p/>\n-     * <ul>\n-     * <li>tableName            The name of the table</li>\n-     * <li>correlationName    The correlation name</li>\n-     * <li>derivedRCL        The derived column list</li>\n-     * <li>tableProperties    The Properties list associated with the table.</li>\n-     * </ul>\n-     * <p/>\n-     * <p>\n-     * - OR -\n-     * </p>\n-     * <p/>\n-     * <ul>\n-     * <li>tableName            The name of the table</li>\n-     * <li>correlationName    The correlation name</li>\n-     * <li>updateOrDelete    Table is being updated/deleted from. </li>\n-     * <li>derivedRCL        The derived column list</li>\n-     * </ul>\n+     * Initializer for a table in a FROM list.\n+     * @param tableName The name of the table\n+     * @param correlationName The correlation name\n+     * @param rclOrUD update/delete flag or result column list\n+     * @param propsOrRcl properties or result column list\n+     * @param isBulkDeleteOrTxId bulk delete flag or past tx id expression.\n      */\n     @Override\n-    public void init(Object tableName,Object correlationName,Object rclOrUD,Object propsOrRcl, Object isBulkDelete){\n+    public void init(Object tableName,Object correlationName,Object rclOrUD,Object propsOrRcl, Object isBulkDeleteOrTxId){\n+        if(isBulkDeleteOrTxId instanceof Boolean) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NTA3Mg=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDM2NTk4OnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDoyODo1NlrOGt4i_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNTo1Njo0OVrOGxaQGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NTU2NQ==", "bodyText": "Remove comments", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450765565", "createdAt": "2020-07-07T10:28:56Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -3410,7 +3431,11 @@ private String getClassName(String niceIndexName) throws StandardException {\n         if(niceIndexName!=null){\n             cName = \"IndexScan[\"+niceIndexName+\"]\";\n         }else{\n-            cName = \"TableScan[\"+getPrettyTableName()+\"]\";\n+            cName = \"TableScan[\"+getPrettyTableName();\n+//            if(pastTxIdExpression >= 0){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ2MzUxMw==", "bodyText": "Done", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r454463513", "createdAt": "2020-07-14T15:56:49Z", "author": {"login": "hatyo"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -3410,7 +3431,11 @@ private String getClassName(String niceIndexName) throws StandardException {\n         if(niceIndexName!=null){\n             cName = \"IndexScan[\"+niceIndexName+\"]\";\n         }else{\n-            cName = \"TableScan[\"+getPrettyTableName()+\"]\";\n+            cName = \"TableScan[\"+getPrettyTableName();\n+//            if(pastTxIdExpression >= 0){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NTU2NQ=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDM2OTE2OnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDozMDowMFrOGt4lDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNTo1ODowNVrOGxaTfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NjA5NQ==", "bodyText": "Is it possible to remove the look ahead here?", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450766095", "createdAt": "2020-07-07T10:30:00Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj", "diffHunk": "@@ -10914,28 +10915,45 @@ tableReferenceTypes(boolean nestedInParens) throws StandardException :\n Object[]\n optionalTableClauses() throws StandardException :\n {\n-    Object[]             otc = null;\n-    Properties            tableProperties = null;\n-    ResultColumnList    derivedRCL = null;\n-    String                correlationName = null;\n+    Object[]         otc = null;\n+    Properties       tableProperties = null;\n+    ResultColumnList derivedRCL = null;\n+    String           correlationName = null;\n+    ValueNode        txnIdExpression = null;\n }\n {\n     otc = optionalTableProperties()\n     {\n         otc[OPTIONAL_TABLE_CLAUSES_DERIVED_RCL] = derivedRCL;\n         otc[OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME] = correlationName;\n+        otc[OPTIONAL_TABLE_CLAUSES_TXN_ID] = txnIdExpression;\n         return otc;\n     }\n |\n+    LOOKAHEAD( { getToken(1).kind != AS || getToken(2).kind != OF })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ2NDM4MQ==", "bodyText": "Would you please check my comment here? I am not sure I can remove it actually but maybe I missed something.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r454464381", "createdAt": "2020-07-14T15:58:05Z", "author": {"login": "hatyo"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj", "diffHunk": "@@ -10914,28 +10915,45 @@ tableReferenceTypes(boolean nestedInParens) throws StandardException :\n Object[]\n optionalTableClauses() throws StandardException :\n {\n-    Object[]             otc = null;\n-    Properties            tableProperties = null;\n-    ResultColumnList    derivedRCL = null;\n-    String                correlationName = null;\n+    Object[]         otc = null;\n+    Properties       tableProperties = null;\n+    ResultColumnList derivedRCL = null;\n+    String           correlationName = null;\n+    ValueNode        txnIdExpression = null;\n }\n {\n     otc = optionalTableProperties()\n     {\n         otc[OPTIONAL_TABLE_CLAUSES_DERIVED_RCL] = derivedRCL;\n         otc[OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME] = correlationName;\n+        otc[OPTIONAL_TABLE_CLAUSES_TXN_ID] = txnIdExpression;\n         return otc;\n     }\n |\n+    LOOKAHEAD( { getToken(1).kind != AS || getToken(2).kind != OF })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NjA5NQ=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDM5NDE3OnYy", "diffSide": "RIGHT", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDozNzo1NVrOGt40fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMTo1NDoxM1rOG2HK0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDA0Ng==", "bodyText": "If I'm understanding this correctly, this is mapping the Txn begin timestamp to the instant when the transaction was last updated. This would be wrong for long running transactions:\n\ntxn1 is created at instant1\na long time passes\ntxn1 is committed at instant500\nthis function maps txnId 1 to instant 500 (it should map txnId 1 to instant 1)", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450770046", "createdAt": "2020-07-07T10:37:55Z", "author": {"login": "dgomezferro"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.hbase.CellUtils;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.Source;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.filter.PrefixFilter;\n+import org.apache.hadoop.hbase.regionserver.HRegion;\n+import org.apache.hadoop.hbase.regionserver.RegionScanner;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public class HBaseTxnFinder implements TxnFinder {\n+\n+    private HRegion region;\n+\n+    public HBaseTxnFinder(HRegion region) {\n+        this.region = region;\n+    }\n+\n+    private class ScanTimestampIterator implements Source<Pair<Long, Long>> {\n+        private final RegionScanner regionScanner;\n+        protected Pair<Long, Long> next;\n+        private List<Cell> currentResults;\n+\n+        protected Pair<Long, Long> decode(List<Cell> keyValues) throws IOException{\n+            if(keyValues.size()<=0) return null;\n+            Cell dataKv=null;\n+            long ts = 0;\n+\n+            for(Cell kv : keyValues){\n+                if(CellUtils.singleMatchingColumn(kv,V2TxnDecoder.FAMILY,V2TxnDecoder.DATA_QUALIFIER_BYTES)) {\n+                    dataKv=kv;\n+                }\n+                if(ts <  kv.getTimestamp()) {\n+                    ts = kv.getTimestamp(); // get last update\n+                }\n+            }\n+            if(dataKv==null) return null;\n+            long txnId= TxnUtils.txnIdFromRowKey(dataKv.getRowArray(),dataKv.getRowOffset(),dataKv.getRowLength());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4MTMwOQ==", "bodyText": "You're right, what's a better way to correlate? maybe parse and check the timestamp of COMMIT_QUALIFIER_BYTES or STATE_QUALIFIER_BYTES (sorry maybe we already went through this once, but I just want to make sure).", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r454481309", "createdAt": "2020-07-14T16:23:32Z", "author": {"login": "hatyo"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.hbase.CellUtils;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.Source;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.filter.PrefixFilter;\n+import org.apache.hadoop.hbase.regionserver.HRegion;\n+import org.apache.hadoop.hbase.regionserver.RegionScanner;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public class HBaseTxnFinder implements TxnFinder {\n+\n+    private HRegion region;\n+\n+    public HBaseTxnFinder(HRegion region) {\n+        this.region = region;\n+    }\n+\n+    private class ScanTimestampIterator implements Source<Pair<Long, Long>> {\n+        private final RegionScanner regionScanner;\n+        protected Pair<Long, Long> next;\n+        private List<Cell> currentResults;\n+\n+        protected Pair<Long, Long> decode(List<Cell> keyValues) throws IOException{\n+            if(keyValues.size()<=0) return null;\n+            Cell dataKv=null;\n+            long ts = 0;\n+\n+            for(Cell kv : keyValues){\n+                if(CellUtils.singleMatchingColumn(kv,V2TxnDecoder.FAMILY,V2TxnDecoder.DATA_QUALIFIER_BYTES)) {\n+                    dataKv=kv;\n+                }\n+                if(ts <  kv.getTimestamp()) {\n+                    ts = kv.getTimestamp(); // get last update\n+                }\n+            }\n+            if(dataKv==null) return null;\n+            long txnId= TxnUtils.txnIdFromRowKey(dataKv.getRowArray(),dataKv.getRowOffset(),dataKv.getRowLength());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDA0Ng=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0MzUyNw==", "bodyText": "I think the best option would be to scan for STATE_QUALIFIER_BYTES with ACTIVE value (0x00), since that's what's written when the transaction is first created. In principle there should only be 2 states at most (ACTIVE, superseded by COMMITTED or ROLLEDBACK) but I think I saw some cases where ROLLEDBACK was written multiple times. If there's such a case and the ACTIVE keyvalue is not available I'd ignore that row.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456343527", "createdAt": "2020-07-17T09:55:41Z", "author": {"login": "dgomezferro"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.hbase.CellUtils;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.Source;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.filter.PrefixFilter;\n+import org.apache.hadoop.hbase.regionserver.HRegion;\n+import org.apache.hadoop.hbase.regionserver.RegionScanner;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public class HBaseTxnFinder implements TxnFinder {\n+\n+    private HRegion region;\n+\n+    public HBaseTxnFinder(HRegion region) {\n+        this.region = region;\n+    }\n+\n+    private class ScanTimestampIterator implements Source<Pair<Long, Long>> {\n+        private final RegionScanner regionScanner;\n+        protected Pair<Long, Long> next;\n+        private List<Cell> currentResults;\n+\n+        protected Pair<Long, Long> decode(List<Cell> keyValues) throws IOException{\n+            if(keyValues.size()<=0) return null;\n+            Cell dataKv=null;\n+            long ts = 0;\n+\n+            for(Cell kv : keyValues){\n+                if(CellUtils.singleMatchingColumn(kv,V2TxnDecoder.FAMILY,V2TxnDecoder.DATA_QUALIFIER_BYTES)) {\n+                    dataKv=kv;\n+                }\n+                if(ts <  kv.getTimestamp()) {\n+                    ts = kv.getTimestamp(); // get last update\n+                }\n+            }\n+            if(dataKv==null) return null;\n+            long txnId= TxnUtils.txnIdFromRowKey(dataKv.getRowArray(),dataKv.getRowOffset(),dataKv.getRowLength());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDA0Ng=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM5Mzc0Ng==", "bodyText": "Done, we're reading now the STATE_QUALIFIER_BYTES qualifier (all versions), iterate over the results and pick the timestamp of ACTIVE state if found, if not found, we simply ignore the row and proceed further.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r459393746", "createdAt": "2020-07-23T11:54:13Z", "author": {"login": "hatyo"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.hbase.CellUtils;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.Source;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.filter.PrefixFilter;\n+import org.apache.hadoop.hbase.regionserver.HRegion;\n+import org.apache.hadoop.hbase.regionserver.RegionScanner;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public class HBaseTxnFinder implements TxnFinder {\n+\n+    private HRegion region;\n+\n+    public HBaseTxnFinder(HRegion region) {\n+        this.region = region;\n+    }\n+\n+    private class ScanTimestampIterator implements Source<Pair<Long, Long>> {\n+        private final RegionScanner regionScanner;\n+        protected Pair<Long, Long> next;\n+        private List<Cell> currentResults;\n+\n+        protected Pair<Long, Long> decode(List<Cell> keyValues) throws IOException{\n+            if(keyValues.size()<=0) return null;\n+            Cell dataKv=null;\n+            long ts = 0;\n+\n+            for(Cell kv : keyValues){\n+                if(CellUtils.singleMatchingColumn(kv,V2TxnDecoder.FAMILY,V2TxnDecoder.DATA_QUALIFIER_BYTES)) {\n+                    dataKv=kv;\n+                }\n+                if(ts <  kv.getTimestamp()) {\n+                    ts = kv.getTimestamp(); // get last update\n+                }\n+            }\n+            if(dataKv==null) return null;\n+            long txnId= TxnUtils.txnIdFromRowKey(dataKv.getRowArray(),dataKv.getRowOffset(),dataKv.getRowLength());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDA0Ng=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDM5ODEwOnYy", "diffSide": "RIGHT", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDozOToxNlrOGt42_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMTo1NDoyMlrOG2HLCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDY4Nw==", "bodyText": "You can specify the column you are interested in directly in the scan, so you don't have to check for the right KV.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450770687", "createdAt": "2020-07-07T10:39:16Z", "author": {"login": "dgomezferro"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.hbase.CellUtils;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.Source;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.filter.PrefixFilter;\n+import org.apache.hadoop.hbase.regionserver.HRegion;\n+import org.apache.hadoop.hbase.regionserver.RegionScanner;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public class HBaseTxnFinder implements TxnFinder {\n+\n+    private HRegion region;\n+\n+    public HBaseTxnFinder(HRegion region) {\n+        this.region = region;\n+    }\n+\n+    private class ScanTimestampIterator implements Source<Pair<Long, Long>> {\n+        private final RegionScanner regionScanner;\n+        protected Pair<Long, Long> next;\n+        private List<Cell> currentResults;\n+\n+        protected Pair<Long, Long> decode(List<Cell> keyValues) throws IOException{\n+            if(keyValues.size()<=0) return null;\n+            Cell dataKv=null;\n+            long ts = 0;\n+\n+            for(Cell kv : keyValues){\n+                if(CellUtils.singleMatchingColumn(kv,V2TxnDecoder.FAMILY,V2TxnDecoder.DATA_QUALIFIER_BYTES)) {\n+                    dataKv=kv;\n+                }\n+                if(ts <  kv.getTimestamp()) {\n+                    ts = kv.getTimestamp(); // get last update\n+                }\n+            }\n+            if(dataKv==null) return null;\n+            long txnId= TxnUtils.txnIdFromRowKey(dataKv.getRowArray(),dataKv.getRowOffset(),dataKv.getRowLength());\n+            return new Pair<>(txnId, ts);\n+        }\n+\n+\n+        public ScanTimestampIterator(RegionScanner scanner){\n+            this.regionScanner=scanner;\n+        }\n+\n+        @Override\n+        public boolean hasNext() throws IOException{\n+            if(next!=null) return true;\n+            if(currentResults==null)\n+                currentResults=new ArrayList<>(10);\n+            boolean shouldContinue;\n+            do{\n+                shouldContinue=regionScanner.next(currentResults);\n+                if(currentResults.size()<=0) return false;\n+\n+                this.next = decode(currentResults);\n+                currentResults.clear();\n+            }while(next==null && shouldContinue);\n+\n+            return next!=null;\n+        }\n+\n+        @Override\n+        public Pair<Long, Long> next() throws IOException{\n+            if(!hasNext()) throw new NoSuchElementException();\n+            Pair<Long, Long> n=next;\n+            next=null;\n+            return n;\n+        }\n+\n+        @Override\n+        public void close() throws IOException{\n+            regionScanner.close();\n+        }\n+    }\n+\n+    @Override\n+    public Pair<Long, Long> find(byte bucket, byte[] begin, boolean reverse) throws IOException {\n+        Scan s = new Scan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM5MzgwMA==", "bodyText": "Thanks, done, now we're reading only STATE_QUALIFIER_BYTES column qualifier (all versions).\nhbaseScan.addColumn(V2TxnDecoder.FAMILY, V2TxnDecoder.STATE_QUALIFIER_BYTES)\n         .setReversed(reverse)\n         .readAllVersions()\n         .setFilter(new PrefixFilter(new byte[]{bucket})); // todo get one row only", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r459393800", "createdAt": "2020-07-23T11:54:22Z", "author": {"login": "hatyo"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.hbase.CellUtils;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.Source;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.filter.PrefixFilter;\n+import org.apache.hadoop.hbase.regionserver.HRegion;\n+import org.apache.hadoop.hbase.regionserver.RegionScanner;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public class HBaseTxnFinder implements TxnFinder {\n+\n+    private HRegion region;\n+\n+    public HBaseTxnFinder(HRegion region) {\n+        this.region = region;\n+    }\n+\n+    private class ScanTimestampIterator implements Source<Pair<Long, Long>> {\n+        private final RegionScanner regionScanner;\n+        protected Pair<Long, Long> next;\n+        private List<Cell> currentResults;\n+\n+        protected Pair<Long, Long> decode(List<Cell> keyValues) throws IOException{\n+            if(keyValues.size()<=0) return null;\n+            Cell dataKv=null;\n+            long ts = 0;\n+\n+            for(Cell kv : keyValues){\n+                if(CellUtils.singleMatchingColumn(kv,V2TxnDecoder.FAMILY,V2TxnDecoder.DATA_QUALIFIER_BYTES)) {\n+                    dataKv=kv;\n+                }\n+                if(ts <  kv.getTimestamp()) {\n+                    ts = kv.getTimestamp(); // get last update\n+                }\n+            }\n+            if(dataKv==null) return null;\n+            long txnId= TxnUtils.txnIdFromRowKey(dataKv.getRowArray(),dataKv.getRowOffset(),dataKv.getRowLength());\n+            return new Pair<>(txnId, ts);\n+        }\n+\n+\n+        public ScanTimestampIterator(RegionScanner scanner){\n+            this.regionScanner=scanner;\n+        }\n+\n+        @Override\n+        public boolean hasNext() throws IOException{\n+            if(next!=null) return true;\n+            if(currentResults==null)\n+                currentResults=new ArrayList<>(10);\n+            boolean shouldContinue;\n+            do{\n+                shouldContinue=regionScanner.next(currentResults);\n+                if(currentResults.size()<=0) return false;\n+\n+                this.next = decode(currentResults);\n+                currentResults.clear();\n+            }while(next==null && shouldContinue);\n+\n+            return next!=null;\n+        }\n+\n+        @Override\n+        public Pair<Long, Long> next() throws IOException{\n+            if(!hasNext()) throw new NoSuchElementException();\n+            Pair<Long, Long> n=next;\n+            next=null;\n+            return n;\n+        }\n+\n+        @Override\n+        public void close() throws IOException{\n+            regionScanner.close();\n+        }\n+    }\n+\n+    @Override\n+    public Pair<Long, Long> find(byte bucket, byte[] begin, boolean reverse) throws IOException {\n+        Scan s = new Scan();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDY4Nw=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDQyMjAwOnYy", "diffSide": "LEFT", "path": "mem_sql/pom.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDo0Njo1NlrOGt5Fww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoyMDo1N1rOGzJ9yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NDQ2Nw==", "bodyText": "Recomment this", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450774467", "createdAt": "2020-07-07T10:46:56Z", "author": {"login": "dgomezferro"}, "path": "mem_sql/pom.xml", "diffHunk": "@@ -268,12 +268,10 @@\n                             <key>com.splicemachine.enableLegacyAsserts</key>\n                             <value>true</value>\n                         </systemProperty>\n-                     <!-- Uncomment the following to dump activation class files for mem platform to the mem_sql directory.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MzgzNA==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456293834", "createdAt": "2020-07-17T08:20:57Z", "author": {"login": "hatyo"}, "path": "mem_sql/pom.xml", "diffHunk": "@@ -268,12 +268,10 @@\n                             <key>com.splicemachine.enableLegacyAsserts</key>\n                             <value>true</value>\n                         </systemProperty>\n-                     <!-- Uncomment the following to dump activation class files for mem platform to the mem_sql directory.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NDQ2Nw=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDQyMjc3OnYy", "diffSide": "RIGHT", "path": "platform_it/pom.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDo0NzoxMFrOGt5GQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoyMjoxNVrOGzKAew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NDU5NQ==", "bodyText": "comment this by default", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450774595", "createdAt": "2020-07-07T10:47:10Z", "author": {"login": "dgomezferro"}, "path": "platform_it/pom.xml", "diffHunk": "@@ -1055,6 +1055,7 @@\n                                 <argument>-Dderby.language.updateSystemProcs=false</argument>\n                                 <!-- Setting the logStatementText option to true enables logging of all statements. -->\n                                 <argument>-Dderby.infolog.append=true</argument>\n+                                <argument>-Dderby.debug.true=DumpClassFile</argument>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NDUyMw==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456294523", "createdAt": "2020-07-17T08:22:15Z", "author": {"login": "hatyo"}, "path": "platform_it/pom.xml", "diffHunk": "@@ -1055,6 +1055,7 @@\n                                 <argument>-Dderby.language.updateSystemProcs=false</argument>\n                                 <!-- Setting the logStatementText option to true enables logging of all statements. -->\n                                 <argument>-Dderby.infolog.append=true</argument>\n+                                <argument>-Dderby.debug.true=DumpClassFile</argument>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NDU5NQ=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDQyOTg1OnYy", "diffSide": "RIGHT", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDo0OTozMVrOGt5KkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzozNToyM1rOG2Kypw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NTY5Nw==", "bodyText": "Txn id 0 is used for the ROOT_TRANSACTION, which is a special transaction parent of all user level transactions. I don't think this is going to be problematic but I'd rather use a different transaction id other than 0, in case we think at some point this is actually the root transaction.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450775697", "createdAt": "2020-07-07T10:49:31Z", "author": {"login": "dgomezferro"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java", "diffHunk": "@@ -175,10 +190,34 @@ public TableScanOperation(long conglomId,\n         this.indexColItem=indexColItem;\n         this.indexName=indexName;\n         init();\n+        if(pastTxFunctor != null) {\n+            this.pastTx = MapToTxId((DataValueDescriptor)pastTxFunctor.invoke(activation));\n+            if(pastTx == -1) {\n+                pastTx = 0; // force going back to oldest transaction instead of ignoring it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ1MzA5NQ==", "bodyText": "Done. I created a constant: public static final long OLDEST_TIME_TRAVEL_TX = TRASANCTION_INCREMENT; and I am using it here instead of simply using zero.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r459453095", "createdAt": "2020-07-23T13:35:23Z", "author": {"login": "hatyo"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java", "diffHunk": "@@ -175,10 +190,34 @@ public TableScanOperation(long conglomId,\n         this.indexColItem=indexColItem;\n         this.indexName=indexName;\n         init();\n+        if(pastTxFunctor != null) {\n+            this.pastTx = MapToTxId((DataValueDescriptor)pastTxFunctor.invoke(activation));\n+            if(pastTx == -1) {\n+                pastTx = 0; // force going back to oldest transaction instead of ignoring it.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NTY5Nw=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDQzMTgxOnYy", "diffSide": "RIGHT", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDo1MDowNVrOGt5LwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoyMzowM1rOGzKCTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NjAwMQ==", "bodyText": "Method names should start with lowercase", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450776001", "createdAt": "2020-07-07T10:50:05Z", "author": {"login": "dgomezferro"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java", "diffHunk": "@@ -175,10 +190,34 @@ public TableScanOperation(long conglomId,\n         this.indexColItem=indexColItem;\n         this.indexName=indexName;\n         init();\n+        if(pastTxFunctor != null) {\n+            this.pastTx = MapToTxId((DataValueDescriptor)pastTxFunctor.invoke(activation));\n+            if(pastTx == -1) {\n+                pastTx = 0; // force going back to oldest transaction instead of ignoring it.\n+            }\n+        } else {\n+            this.pastTx = -1; // nothing is set, go ahead and use latest transaction.\n+        }\n         if(LOG.isTraceEnabled())\n             SpliceLogUtils.trace(LOG,\"isTopResultSet=%s,optimizerEstimatedCost=%f,optimizerEstimatedRowCount=%f\",isTopResultSet,optimizerEstimatedCost,optimizerEstimatedRowCount);\n     }\n \n+    private long MapToTxId(DataValueDescriptor dataValue) throws StandardException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NDk5MA==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456294990", "createdAt": "2020-07-17T08:23:03Z", "author": {"login": "hatyo"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java", "diffHunk": "@@ -175,10 +190,34 @@ public TableScanOperation(long conglomId,\n         this.indexColItem=indexColItem;\n         this.indexName=indexName;\n         init();\n+        if(pastTxFunctor != null) {\n+            this.pastTx = MapToTxId((DataValueDescriptor)pastTxFunctor.invoke(activation));\n+            if(pastTx == -1) {\n+                pastTx = 0; // force going back to oldest transaction instead of ignoring it.\n+            }\n+        } else {\n+            this.pastTx = -1; // nothing is set, go ahead and use latest transaction.\n+        }\n         if(LOG.isTraceEnabled())\n             SpliceLogUtils.trace(LOG,\"isTopResultSet=%s,optimizerEstimatedCost=%f,optimizerEstimatedRowCount=%f\",isTopResultSet,optimizerEstimatedCost,optimizerEstimatedRowCount);\n     }\n \n+    private long MapToTxId(DataValueDescriptor dataValue) throws StandardException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NjAwMQ=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDQzNzE2OnYy", "diffSide": "RIGHT", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDo1MTo0MFrOGt5PEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoyNDowOFrOGzKErg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3Njg1MQ==", "bodyText": "Method names start lowercase", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450776851", "createdAt": "2020-07-07T10:51:40Z", "author": {"login": "dgomezferro"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NTU5OA==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456295598", "createdAt": "2020-07-17T08:24:08Z", "author": {"login": "hatyo"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3Njg1MQ=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDQzNzg2OnYy", "diffSide": "RIGHT", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDo1MTo1M1rOGt5PiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoyNDoxOFrOGzKE-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3Njk2OA==", "bodyText": "ditto", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450776968", "createdAt": "2020-07-07T10:51:53Z", "author": {"login": "dgomezferro"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {\n+        long result = -1;\n+        ResultSet rs =  watcher.executeQuery(\"CALL SYSCS_UTIL.SYSCS_GET_CURRENT_TRANSACTION()\");\n+        Assert.assertTrue(rs.next());\n+        result = rs.getLong(1);\n+        Assert.assertFalse(rs.next());\n+        return result;\n+    }\n+\n+    static int counter = 0;\n+    private static String GenerateTableName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NTY3NQ==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456295675", "createdAt": "2020-07-17T08:24:18Z", "author": {"login": "hatyo"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {\n+        long result = -1;\n+        ResultSet rs =  watcher.executeQuery(\"CALL SYSCS_UTIL.SYSCS_GET_CURRENT_TRANSACTION()\");\n+        Assert.assertTrue(rs.next());\n+        result = rs.getLong(1);\n+        Assert.assertFalse(rs.next());\n+        return result;\n+    }\n+\n+    static int counter = 0;\n+    private static String GenerateTableName() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3Njk2OA=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDQ0MTI5OnYy", "diffSide": "RIGHT", "path": "splice_si_api/src/main/java/com/splicemachine/si/impl/TxnUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDo1Mjo1MFrOGt5Rfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoyOTowNlrOGzKP0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NzQ3MA==", "bodyText": "Remove", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450777470", "createdAt": "2020-07-07T10:52:50Z", "author": {"login": "dgomezferro"}, "path": "splice_si_api/src/main/java/com/splicemachine/si/impl/TxnUtils.java", "diffHunk": "@@ -30,10 +30,23 @@ private TxnUtils(){}\n \t\tlong beginTS = txnId & SIConstants.TRANSANCTION_ID_MASK;\n \t\tbyte[] rowKey = new byte[9];\n \t\trowKey[0] = (byte)((beginTS / SIConstants.TRASANCTION_INCREMENT) & (TRANSACTION_TABLE_BUCKET_COUNT-1));\n+\t\trowKey[0] = (byte)(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5ODQ0OQ==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456298449", "createdAt": "2020-07-17T08:29:06Z", "author": {"login": "hatyo"}, "path": "splice_si_api/src/main/java/com/splicemachine/si/impl/TxnUtils.java", "diffHunk": "@@ -30,10 +30,23 @@ private TxnUtils(){}\n \t\tlong beginTS = txnId & SIConstants.TRANSANCTION_ID_MASK;\n \t\tbyte[] rowKey = new byte[9];\n \t\trowKey[0] = (byte)((beginTS / SIConstants.TRASANCTION_INCREMENT) & (TRANSACTION_TABLE_BUCKET_COUNT-1));\n+\t\trowKey[0] = (byte)(2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NzQ3MA=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzc0NDA3OnYy", "diffSide": "RIGHT", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/CoprocessorTxnStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNTo0ODo1MFrOGuZBWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOTowNjowNFrOGzLb_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5NzYyNg==", "bodyText": "we don't really have a code convention, but i think this could use a bit more spaces, e.g.\n} catch(Throwable throwable) {\n(same for other lines)\nI don't really need the spaces after (, but like around operators e.g. if(keyValues.size()<=0) -> if(keyValues.size() <= 0).", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451297626", "createdAt": "2020-07-08T05:48:50Z", "author": {"login": "martinrupp"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/CoprocessorTxnStore.java", "diffHunk": "@@ -268,6 +268,17 @@ public int compare(TxnView o1,TxnView o2){\n         }\n     }\n \n+    @Override\n+    public long getTxnAt(long ts) throws IOException {\n+        final TxnMessage.TxnAtRequest request=TxnMessage.TxnAtRequest.newBuilder().setTs(ts).build();\n+        try(TxnNetworkLayer table = tableFactory.accessTxnNetwork()){\n+            TxnMessage.TxnAtResponse result = table.getTxnAt(request);\n+            return result.getTxnId();\n+        }catch(Throwable throwable){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNzk0OQ==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456317949", "createdAt": "2020-07-17T09:06:04Z", "author": {"login": "hatyo"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/CoprocessorTxnStore.java", "diffHunk": "@@ -268,6 +268,17 @@ public int compare(TxnView o1,TxnView o2){\n         }\n     }\n \n+    @Override\n+    public long getTxnAt(long ts) throws IOException {\n+        final TxnMessage.TxnAtRequest request=TxnMessage.TxnAtRequest.newBuilder().setTs(ts).build();\n+        try(TxnNetworkLayer table = tableFactory.accessTxnNetwork()){\n+            TxnMessage.TxnAtResponse result = table.getTxnAt(request);\n+            return result.getTxnId();\n+        }catch(Throwable throwable){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5NzYyNg=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzc1NTcxOnYy", "diffSide": "RIGHT", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNTo1Mzo1MlrOGuZIEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOTowNTowNlrOGzLZ-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5OTM0NA==", "bodyText": "really LOG level, not TRACE? i'm not even sure we should have this here at all, even in trace level.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451299344", "createdAt": "2020-07-08T05:53:52Z", "author": {"login": "martinrupp"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+\n+public class TxnTimeTraveler {\n+    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n+\n+    private TxnFinder txnFinder;\n+\n+    public TxnTimeTraveler(TxnFinder txnFinder) {\n+        this.txnFinder = txnFinder;\n+    }\n+\n+    /// @return Pair<closest tx id, closest tx's ts>\n+    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n+                                     byte[] end, long endTS) throws IOException {\n+        if(LOG.isTraceEnabled())\n+            SpliceLogUtils.trace(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n+                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n+                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n+        byte[] left = begin, right = end, middle;\n+        long leftTS = beginTS, rightTS = endTS;\n+        boolean changed = true, reversed = false;\n+        while(changed) {\n+            if(Arrays.equals(left, right)) {\n+                if(leftTS < needleTS) {\n+                    return new Pair<>(txOf(left), leftTS);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            changed = false;\n+            middle = middle(left, right);\n+            Pair<Long, Long> middleTx;\n+            middleTx = txnFinder.find(bucket, middle, reversed);\n+            reversed = false;\n+            if(LOG.isTraceEnabled())\n+                SpliceLogUtils.trace(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNzQzNA==", "bodyText": "Yeah, I changed all of them back to DEBUG.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456317434", "createdAt": "2020-07-17T09:05:06Z", "author": {"login": "hatyo"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+\n+public class TxnTimeTraveler {\n+    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n+\n+    private TxnFinder txnFinder;\n+\n+    public TxnTimeTraveler(TxnFinder txnFinder) {\n+        this.txnFinder = txnFinder;\n+    }\n+\n+    /// @return Pair<closest tx id, closest tx's ts>\n+    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n+                                     byte[] end, long endTS) throws IOException {\n+        if(LOG.isTraceEnabled())\n+            SpliceLogUtils.trace(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n+                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n+                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n+        byte[] left = begin, right = end, middle;\n+        long leftTS = beginTS, rightTS = endTS;\n+        boolean changed = true, reversed = false;\n+        while(changed) {\n+            if(Arrays.equals(left, right)) {\n+                if(leftTS < needleTS) {\n+                    return new Pair<>(txOf(left), leftTS);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            changed = false;\n+            middle = middle(left, right);\n+            Pair<Long, Long> middleTx;\n+            middleTx = txnFinder.find(bucket, middle, reversed);\n+            reversed = false;\n+            if(LOG.isTraceEnabled())\n+                SpliceLogUtils.trace(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5OTM0NA=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzc1OTQ2OnYy", "diffSide": "RIGHT", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNTo1NToyMlrOGuZKIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOTowMzowMlrOGzLV0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5OTg3Mw==", "bodyText": "TRACE or DEBUG?", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451299873", "createdAt": "2020-07-08T05:55:22Z", "author": {"login": "martinrupp"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+\n+public class TxnTimeTraveler {\n+    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n+\n+    private TxnFinder txnFinder;\n+\n+    public TxnTimeTraveler(TxnFinder txnFinder) {\n+        this.txnFinder = txnFinder;\n+    }\n+\n+    /// @return Pair<closest tx id, closest tx's ts>\n+    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n+                                     byte[] end, long endTS) throws IOException {\n+        if(LOG.isTraceEnabled())\n+            SpliceLogUtils.trace(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n+                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n+                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n+        byte[] left = begin, right = end, middle;\n+        long leftTS = beginTS, rightTS = endTS;\n+        boolean changed = true, reversed = false;\n+        while(changed) {\n+            if(Arrays.equals(left, right)) {\n+                if(leftTS < needleTS) {\n+                    return new Pair<>(txOf(left), leftTS);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            changed = false;\n+            middle = middle(left, right);\n+            Pair<Long, Long> middleTx;\n+            middleTx = txnFinder.find(bucket, middle, reversed);\n+            reversed = false;\n+            if(LOG.isTraceEnabled())\n+                SpliceLogUtils.trace(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",\n+                        TxnUtils.rowKeytoHbaseEscaped(left), new Timestamp(leftTS).toString(), txOf(left),\n+                        TxnUtils.rowKeytoHbaseEscaped(right), new Timestamp(rightTS).toString(), txOf(right),\n+                        TxnUtils.rowKeytoHbaseEscaped(middle), new Timestamp(middleTx.getSecond()).toString(), middleTx.getFirst().toString());\n+            long middleTS = middleTx.getSecond();\n+            if(middleTS == needleTS) {\n+                return middleTx;\n+            } else if(needleTS < middleTS) {\n+                if(middleTS == rightTS)\n+                {\n+                    reversed = true;\n+                    changed = true;\n+                }\n+                else if(middleTS < rightTS)\n+                {\n+                    right = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                    rightTS = middleTS;\n+                    changed = true;\n+                }\n+            } else if(leftTS < middleTS) {\n+                left = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                leftTS = middleTS;\n+                changed = true;\n+            }\n+        }\n+        return new Pair<>(txOf(left), leftTS);\n+    }\n+\n+    private long txOf(byte[] rowKey) {\n+        return TxnUtils.txnIdFromRowKey(rowKey, 0, rowKey.length);\n+    }\n+\n+    private byte[] middle(byte[] left, byte[] right) {\n+        assert(left.length == 9); assert(right.length == 9);\n+        byte lBucket = left[0], rBucket = right[0];\n+        assert(lBucket == rBucket);\n+        long lTxnId = txOf(left), rTxnId = txOf(right), middleTxnId = (lTxnId + rTxnId) / 2;\n+        return toRowKeyWithBucket(middleTxnId, lBucket);\n+    }\n+\n+    private Pair<Long, Long> first(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,false);\n+    }\n+\n+    private Pair<Long, Long> last(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,true);\n+    }\n+\n+    private byte[] toRowKeyWithBucket(long txId, byte bucket) {\n+        byte[] result = TxnUtils.getRowKey(txId);\n+        assert result.length == 9 : \"unexpected rowKey format\";\n+        result[0] = bucket;\n+        return result;\n+    }\n+\n+    // When we use a past transaction P whose timestamp is T, we can read data which is committed before T\n+    // i.e. all data with time < T will be visible, therefore, to be able to read the data of the past\n+    // transaction itself, we slide to the next tx.\n+    private long slideToNextTx(long tx) throws IOException {\n+        if(tx == -1) { // special case for timestamp that happened before the first transaction.\n+            return -1;\n+        }\n+        return tx + SIConstants.TRASANCTION_INCREMENT;\n+    }\n+\n+    public Pair<Long, Long> getTxAt(long ts) throws IOException {\n+        long closestTS = Long.MAX_VALUE, closestTx = -1;\n+        Pair<Long, Long> before, after;\n+        for(byte i = 0; i < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT; ++i) {\n+            before = first(i);\n+            if(before == null /*|| before.getBeginTs() > ts*/) {\n+                continue; // region is empty, or the earliest tx in there happened after 'ts'\n+            }\n+            if(before.getSecond() > ts) {\n+                if(LOG.isTraceEnabled())\n+                    SpliceLogUtils.trace(LOG,\"in bucket %d the first txn [%s (TS: %s), id %s] happened after the needle (%s) exiting!\",\n+                            (int)i,\n+                            TxnUtils.rowKeytoHbaseEscaped(toRowKeyWithBucket(before.getFirst(), i)),\n+                            new Timestamp(before.getSecond()).toString(),\n+                            before.getFirst().toString(),\n+                            new Timestamp(ts).toString());\n+                    return new Pair<>(slideToNextTx(closestTx), closestTS); // nothing, needle is too early: <needle> ....... [before ...... after]\n+            }\n+            after = last(i);\n+            if(after.getSecond() < ts) {\n+                if(LOG.isTraceEnabled())\n+                    SpliceLogUtils.trace(LOG,\"in bucket %d the last txn [%s (TS: %s), id %s] happened before the needle (%s) exiting!\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNjM3MA==", "bodyText": "Right, I don't know why I chose TRACE and not DEBUG, I will change it on DEBUG level then.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456316370", "createdAt": "2020-07-17T09:03:02Z", "author": {"login": "hatyo"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+\n+public class TxnTimeTraveler {\n+    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n+\n+    private TxnFinder txnFinder;\n+\n+    public TxnTimeTraveler(TxnFinder txnFinder) {\n+        this.txnFinder = txnFinder;\n+    }\n+\n+    /// @return Pair<closest tx id, closest tx's ts>\n+    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n+                                     byte[] end, long endTS) throws IOException {\n+        if(LOG.isTraceEnabled())\n+            SpliceLogUtils.trace(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n+                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n+                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n+        byte[] left = begin, right = end, middle;\n+        long leftTS = beginTS, rightTS = endTS;\n+        boolean changed = true, reversed = false;\n+        while(changed) {\n+            if(Arrays.equals(left, right)) {\n+                if(leftTS < needleTS) {\n+                    return new Pair<>(txOf(left), leftTS);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            changed = false;\n+            middle = middle(left, right);\n+            Pair<Long, Long> middleTx;\n+            middleTx = txnFinder.find(bucket, middle, reversed);\n+            reversed = false;\n+            if(LOG.isTraceEnabled())\n+                SpliceLogUtils.trace(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",\n+                        TxnUtils.rowKeytoHbaseEscaped(left), new Timestamp(leftTS).toString(), txOf(left),\n+                        TxnUtils.rowKeytoHbaseEscaped(right), new Timestamp(rightTS).toString(), txOf(right),\n+                        TxnUtils.rowKeytoHbaseEscaped(middle), new Timestamp(middleTx.getSecond()).toString(), middleTx.getFirst().toString());\n+            long middleTS = middleTx.getSecond();\n+            if(middleTS == needleTS) {\n+                return middleTx;\n+            } else if(needleTS < middleTS) {\n+                if(middleTS == rightTS)\n+                {\n+                    reversed = true;\n+                    changed = true;\n+                }\n+                else if(middleTS < rightTS)\n+                {\n+                    right = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                    rightTS = middleTS;\n+                    changed = true;\n+                }\n+            } else if(leftTS < middleTS) {\n+                left = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                leftTS = middleTS;\n+                changed = true;\n+            }\n+        }\n+        return new Pair<>(txOf(left), leftTS);\n+    }\n+\n+    private long txOf(byte[] rowKey) {\n+        return TxnUtils.txnIdFromRowKey(rowKey, 0, rowKey.length);\n+    }\n+\n+    private byte[] middle(byte[] left, byte[] right) {\n+        assert(left.length == 9); assert(right.length == 9);\n+        byte lBucket = left[0], rBucket = right[0];\n+        assert(lBucket == rBucket);\n+        long lTxnId = txOf(left), rTxnId = txOf(right), middleTxnId = (lTxnId + rTxnId) / 2;\n+        return toRowKeyWithBucket(middleTxnId, lBucket);\n+    }\n+\n+    private Pair<Long, Long> first(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,false);\n+    }\n+\n+    private Pair<Long, Long> last(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,true);\n+    }\n+\n+    private byte[] toRowKeyWithBucket(long txId, byte bucket) {\n+        byte[] result = TxnUtils.getRowKey(txId);\n+        assert result.length == 9 : \"unexpected rowKey format\";\n+        result[0] = bucket;\n+        return result;\n+    }\n+\n+    // When we use a past transaction P whose timestamp is T, we can read data which is committed before T\n+    // i.e. all data with time < T will be visible, therefore, to be able to read the data of the past\n+    // transaction itself, we slide to the next tx.\n+    private long slideToNextTx(long tx) throws IOException {\n+        if(tx == -1) { // special case for timestamp that happened before the first transaction.\n+            return -1;\n+        }\n+        return tx + SIConstants.TRASANCTION_INCREMENT;\n+    }\n+\n+    public Pair<Long, Long> getTxAt(long ts) throws IOException {\n+        long closestTS = Long.MAX_VALUE, closestTx = -1;\n+        Pair<Long, Long> before, after;\n+        for(byte i = 0; i < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT; ++i) {\n+            before = first(i);\n+            if(before == null /*|| before.getBeginTs() > ts*/) {\n+                continue; // region is empty, or the earliest tx in there happened after 'ts'\n+            }\n+            if(before.getSecond() > ts) {\n+                if(LOG.isTraceEnabled())\n+                    SpliceLogUtils.trace(LOG,\"in bucket %d the first txn [%s (TS: %s), id %s] happened after the needle (%s) exiting!\",\n+                            (int)i,\n+                            TxnUtils.rowKeytoHbaseEscaped(toRowKeyWithBucket(before.getFirst(), i)),\n+                            new Timestamp(before.getSecond()).toString(),\n+                            before.getFirst().toString(),\n+                            new Timestamp(ts).toString());\n+                    return new Pair<>(slideToNextTx(closestTx), closestTS); // nothing, needle is too early: <needle> ....... [before ...... after]\n+            }\n+            after = last(i);\n+            if(after.getSecond() < ts) {\n+                if(LOG.isTraceEnabled())\n+                    SpliceLogUtils.trace(LOG,\"in bucket %d the last txn [%s (TS: %s), id %s] happened before the needle (%s) exiting!\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5OTg3Mw=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzc4MjUxOnYy", "diffSide": "RIGHT", "path": "hbase_storage/src/test/java/com/splicemachine/si/impl/TimeTravelTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjowNTo1N1rOGuZXog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODo1OTozMVrOGzLO_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwMzMzMA==", "bodyText": "SortedMap<Long, Long> m = txnTimeline.get(bucket); and if(m.size() == 0) { return null\ncan be done independent of if(begin == null) and if(reverse).\nI think you can add at the beginning of this function\nSortedMap<Long, Long> m = txnTimeline.get(bucket);\nif(m.size() == 0) {\n    return null;\n}\n\nand remove in other lines.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451303330", "createdAt": "2020-07-08T06:05:57Z", "author": {"login": "martinrupp"}, "path": "hbase_storage/src/test/java/com/splicemachine/si/impl/TimeTravelTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.splicemachine.si.impl;\n+\n+import com.splicemachine.primitives.Bytes;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.region.TxnFinder;\n+import com.splicemachine.si.impl.region.TxnTimeTraveler;\n+import com.splicemachine.utils.Pair;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+public class TimeTravelTest {\n+\n+    private static Long toTs(String s) throws ParseException {\n+        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss.SSS\");\n+        Date parsedDate = dateFormat.parse(s);\n+        Timestamp timestamp = new java.sql.Timestamp(parsedDate.getTime());\n+        return timestamp.getTime();\n+    }\n+\n+    class MockTxnFinder implements TxnFinder {\n+\n+\n+        List<SortedMap<Long, Long>> txnTimeline = new ArrayList<>();\n+\n+        MockTxnFinder() {\n+            for(int i = 0; i < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT; ++i) {\n+                txnTimeline.add(new TreeMap<>());\n+            }\n+        }\n+\n+        MockTxnFinder AddTxn(int bucket, long txnId, String ts) throws ParseException {\n+            assert bucket >= 0 && bucket < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT;\n+            txnTimeline.get(bucket).put(txnId, toTs(ts));\n+            return this;\n+        }\n+\n+        @Override\n+        public Pair<Long, Long> find(byte bucket, byte[] begin, boolean reverse) throws IOException {\n+            if(begin == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNDYyMA==", "bodyText": "You're absolutely right! Thank you \ud83d\udc4d I fixed it.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456314620", "createdAt": "2020-07-17T08:59:31Z", "author": {"login": "hatyo"}, "path": "hbase_storage/src/test/java/com/splicemachine/si/impl/TimeTravelTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.splicemachine.si.impl;\n+\n+import com.splicemachine.primitives.Bytes;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.region.TxnFinder;\n+import com.splicemachine.si.impl.region.TxnTimeTraveler;\n+import com.splicemachine.utils.Pair;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+public class TimeTravelTest {\n+\n+    private static Long toTs(String s) throws ParseException {\n+        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss.SSS\");\n+        Date parsedDate = dateFormat.parse(s);\n+        Timestamp timestamp = new java.sql.Timestamp(parsedDate.getTime());\n+        return timestamp.getTime();\n+    }\n+\n+    class MockTxnFinder implements TxnFinder {\n+\n+\n+        List<SortedMap<Long, Long>> txnTimeline = new ArrayList<>();\n+\n+        MockTxnFinder() {\n+            for(int i = 0; i < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT; ++i) {\n+                txnTimeline.add(new TreeMap<>());\n+            }\n+        }\n+\n+        MockTxnFinder AddTxn(int bucket, long txnId, String ts) throws ParseException {\n+            assert bucket >= 0 && bucket < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT;\n+            txnTimeline.get(bucket).put(txnId, toTs(ts));\n+            return this;\n+        }\n+\n+        @Override\n+        public Pair<Long, Long> find(byte bucket, byte[] begin, boolean reverse) throws IOException {\n+            if(begin == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwMzMzMA=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzgwNDIyOnYy", "diffSide": "RIGHT", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjoxNTo0NVrOGuZklg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoyODowN1rOGzKNvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwNjY0Ng==", "bodyText": "do we really need this? maybe sth like \"testTimeTravelWorksT\" would be more intuitive? the SpliceWatcher will drop these tables automatically, so you can run the test multiple times.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451306646", "createdAt": "2020-07-08T06:15:45Z", "author": {"login": "martinrupp"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {\n+        long result = -1;\n+        ResultSet rs =  watcher.executeQuery(\"CALL SYSCS_UTIL.SYSCS_GET_CURRENT_TRANSACTION()\");\n+        Assert.assertTrue(rs.next());\n+        result = rs.getLong(1);\n+        Assert.assertFalse(rs.next());\n+        return result;\n+    }\n+\n+    static int counter = 0;\n+    private static String GenerateTableName() {\n+        return \"T\" + counter++;\n+    }\n+\n+    @Test\n+    public void testTimeTravelWorks() throws Exception {\n+        String tbl = GenerateTableName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NzkxOA==", "bodyText": "I actually find this more elegant, I am already using a SpliceWatcher for the schema so I can repeat my tests since the schema (which is the same for all tests in this class) will be dropped and created again in the next run.\nI don't use a watcher for each table because it is just too cumbersome and unnecessary.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456297918", "createdAt": "2020-07-17T08:28:07Z", "author": {"login": "hatyo"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {\n+        long result = -1;\n+        ResultSet rs =  watcher.executeQuery(\"CALL SYSCS_UTIL.SYSCS_GET_CURRENT_TRANSACTION()\");\n+        Assert.assertTrue(rs.next());\n+        result = rs.getLong(1);\n+        Assert.assertFalse(rs.next());\n+        return result;\n+    }\n+\n+    static int counter = 0;\n+    private static String GenerateTableName() {\n+        return \"T\" + counter++;\n+    }\n+\n+    @Test\n+    public void testTimeTravelWorks() throws Exception {\n+        String tbl = GenerateTableName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwNjY0Ng=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDI2NDQ1OnYy", "diffSide": "RIGHT", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzozMzoyNFrOG89fxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzozMzoyNFrOG89fxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3NTMwMQ==", "bodyText": "While  misspellings generally aren't noteworthy and this isn't a blocker for merging today, the literal here is spelled wrong. Could make searching for it harder in the future, so can we fix this in a future release?", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r466575301", "createdAt": "2020-08-06T17:33:24Z", "author": {"login": "carolp-503"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+\n+public class TxnTimeTraveler {\n+    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n+\n+    private TxnFinder txnFinder;\n+\n+    public TxnTimeTraveler(TxnFinder txnFinder) {\n+        this.txnFinder = txnFinder;\n+    }\n+\n+    /// @return Pair<closest tx id, closest tx's ts>\n+    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n+                                     byte[] end, long endTS) throws IOException {\n+        if(LOG.isDebugEnabled())\n+            SpliceLogUtils.debug(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n+                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n+                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n+        byte[] left = begin, right = end, middle;\n+        long leftTS = beginTS, rightTS = endTS;\n+        boolean changed = true, reversed = false;\n+        while(changed) {\n+            if(Arrays.equals(left, right)) {\n+                if(leftTS < needleTS) {\n+                    return new Pair<>(txOf(left), leftTS);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            changed = false;\n+            middle = middle(left, right);\n+            Pair<Long, Long> middleTx;\n+            middleTx = txnFinder.find(bucket, middle, reversed);\n+            reversed = false;\n+            if(LOG.isDebugEnabled())\n+                SpliceLogUtils.debug(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",\n+                        TxnUtils.rowKeytoHbaseEscaped(left), new Timestamp(leftTS).toString(), txOf(left),\n+                        TxnUtils.rowKeytoHbaseEscaped(right), new Timestamp(rightTS).toString(), txOf(right),\n+                        TxnUtils.rowKeytoHbaseEscaped(middle), new Timestamp(middleTx.getSecond()).toString(), middleTx.getFirst().toString());\n+            long middleTS = middleTx.getSecond();\n+            if(middleTS == needleTS) {\n+                return middleTx;\n+            } else if(needleTS < middleTS) {\n+                if(middleTS == rightTS)\n+                {\n+                    reversed = true;\n+                    changed = true;\n+                }\n+                else if(middleTS < rightTS)\n+                {\n+                    right = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                    rightTS = middleTS;\n+                    changed = true;\n+                }\n+            } else if(leftTS < middleTS) {\n+                left = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                leftTS = middleTS;\n+                changed = true;\n+            }\n+        }\n+        return new Pair<>(txOf(left), leftTS);\n+    }\n+\n+    private long txOf(byte[] rowKey) {\n+        return TxnUtils.txnIdFromRowKey(rowKey, 0, rowKey.length);\n+    }\n+\n+    private byte[] middle(byte[] left, byte[] right) {\n+        assert(left.length == 9); assert(right.length == 9);\n+        byte lBucket = left[0], rBucket = right[0];\n+        assert(lBucket == rBucket);\n+        long lTxnId = txOf(left), rTxnId = txOf(right), middleTxnId = (lTxnId + rTxnId) / 2;\n+        return toRowKeyWithBucket(middleTxnId, lBucket);\n+    }\n+\n+    private Pair<Long, Long> first(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,false);\n+    }\n+\n+    private Pair<Long, Long> last(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,true);\n+    }\n+\n+    private byte[] toRowKeyWithBucket(long txId, byte bucket) {\n+        byte[] result = TxnUtils.getRowKey(txId);\n+        assert result.length == 9 : \"unexpected rowKey format\";\n+        result[0] = bucket;\n+        return result;\n+    }\n+\n+    // When we use a past transaction P whose timestamp is T, we can read data which is committed before T\n+    // i.e. all data with time < T will be visible, therefore, to be able to read the data of the past\n+    // transaction itself, we slide to the next tx.\n+    private long slideToNextTx(long tx) throws IOException {\n+        if(tx == -1) { // special case for timestamp that happened before the first transaction.\n+            return -1;\n+        }\n+        return tx + SIConstants.TRASANCTION_INCREMENT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb8b5ed9082f6d18a3865968cf5c63bac777c43a"}, "originalPosition": 109}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3161, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}