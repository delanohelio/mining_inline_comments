{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2MzI0NDQ5", "number": 3969, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMToxODo0M1rOEYbs-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzoxMToyNFrOEavH0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MDU1MTYyOnYy", "diffSide": "RIGHT", "path": "hbase_sql/src/main/java/com/splicemachine/derby/impl/SpliceSpark.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMToxODo0M1rOHAw-zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMDoxMjo0MlrOHBCEXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU2NDU1OQ==", "bodyText": "Can we get rid of spark.driver.allowMultipleContexts in tests and remove this special case?", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r470564559", "createdAt": "2020-08-14T11:18:43Z", "author": {"login": "dgomezferro"}, "path": "hbase_sql/src/main/java/com/splicemachine/derby/impl/SpliceSpark.java", "diffHunk": "@@ -108,11 +111,30 @@ public static synchronized SparkSession getSessionUnsafe() {\n             } catch (IOException e) {\n                 throw new RuntimeException(e);\n             }\n-            System.exit(0);\n-            session = initializeSparkSession();\n+            if (isOlapWorker)\n+                System.exit(0);\n+            sessionToUse = session = initializeSparkSession();\n             ctx =  new JavaSparkContext(session.sparkContext());\n         }\n-        return session;\n+        else {\n+            if (sessionToUse == null || needsReinitialization) {\n+                String allowMultipleContextsString = null;\n+                try {\n+                    allowMultipleContextsString = session.conf().get(\"spark.driver.allowMultipleContexts\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa47b88ff181212c6e4ec3d9f9d9ffc3edb01d45"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg0NDUwOA==", "bodyText": "Done.  spark.driver.allowMultipleContexts doesn't exist in the tests.  This is just a spark setting I was experimenting with.  I've removed this option.", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r470844508", "createdAt": "2020-08-14T20:12:42Z", "author": {"login": "msirek"}, "path": "hbase_sql/src/main/java/com/splicemachine/derby/impl/SpliceSpark.java", "diffHunk": "@@ -108,11 +111,30 @@ public static synchronized SparkSession getSessionUnsafe() {\n             } catch (IOException e) {\n                 throw new RuntimeException(e);\n             }\n-            System.exit(0);\n-            session = initializeSparkSession();\n+            if (isOlapWorker)\n+                System.exit(0);\n+            sessionToUse = session = initializeSparkSession();\n             ctx =  new JavaSparkContext(session.sparkContext());\n         }\n-        return session;\n+        else {\n+            if (sessionToUse == null || needsReinitialization) {\n+                String allowMultipleContextsString = null;\n+                try {\n+                    allowMultipleContextsString = session.conf().get(\"spark.driver.allowMultipleContexts\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU2NDU1OQ=="}, "originalCommit": {"oid": "fa47b88ff181212c6e4ec3d9f9d9ffc3edb01d45"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MDU1NDIzOnYy", "diffSide": "RIGHT", "path": "hbase_sql/src/main/java/com/splicemachine/derby/impl/SpliceSpark.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMToxOTo1MFrOHAxAew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMDoxMjo1NFrOHBCEjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU2NDk4Nw==", "bodyText": "Please add a LOG here so it's clear why we are shutting down", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r470564987", "createdAt": "2020-08-14T11:19:50Z", "author": {"login": "dgomezferro"}, "path": "hbase_sql/src/main/java/com/splicemachine/derby/impl/SpliceSpark.java", "diffHunk": "@@ -108,11 +111,30 @@ public static synchronized SparkSession getSessionUnsafe() {\n             } catch (IOException e) {\n                 throw new RuntimeException(e);\n             }\n-            System.exit(0);\n-            session = initializeSparkSession();\n+            if (isOlapWorker)\n+                System.exit(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa47b88ff181212c6e4ec3d9f9d9ffc3edb01d45"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg0NDU1Nw==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r470844557", "createdAt": "2020-08-14T20:12:54Z", "author": {"login": "msirek"}, "path": "hbase_sql/src/main/java/com/splicemachine/derby/impl/SpliceSpark.java", "diffHunk": "@@ -108,11 +111,30 @@ public static synchronized SparkSession getSessionUnsafe() {\n             } catch (IOException e) {\n                 throw new RuntimeException(e);\n             }\n-            System.exit(0);\n-            session = initializeSparkSession();\n+            if (isOlapWorker)\n+                System.exit(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU2NDk4Nw=="}, "originalCommit": {"oid": "fa47b88ff181212c6e4ec3d9f9d9ffc3edb01d45"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MDU2MzQ1OnYy", "diffSide": "RIGHT", "path": "splice_machine/src/main/java/com/splicemachine/derby/ddl/DDLWatchRefresher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMToyMzozMVrOHAxGFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMDoxMzowNVrOHBCE2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU2NjQyMw==", "bodyText": "Can you remove the stack trace from the comment? I think it makes sense to have it on the JIRA but not here (feel free to keep the explanation and a pointer to the JIRA for instance)", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r470566423", "createdAt": "2020-08-14T11:23:31Z", "author": {"login": "dgomezferro"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/ddl/DDLWatchRefresher.java", "diffHunk": "@@ -214,7 +216,30 @@ private void clearFinishedChanges(Collection<String> children,Collection<DDLWatc\n     private void assignDDLDemarcationPoint(DDLChange ddlChange) {\n         try {\n             TxnView txn = new LazyTxnView(ddlChange.getTxnId(),txnSupplier,exceptionFactory);\n-            assert txn.allowsWrites(): \"DDLChange \"+ddlChange+\" does not have a writable transaction\";\n+            // A full Restore operation overwrite SPLICE_TXN, so the transaction used by the restore\n+            // may not be found.  Avoid the assertion to avoid crashing, e.g.,\n+            // 2020-08-11 18:28:11,785 (ZooKeeperDDLWatcherRefresher) ERROR [c.s.d.d.AsynchronousDDLWatcher] - Failed to refresh ddl\n+            //java.lang.RuntimeException: com.splicemachine.si.api.txn.TransactionMissing: Couldn't resolve transaction with id 81981952", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa47b88ff181212c6e4ec3d9f9d9ffc3edb01d45"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg0NDYzMw==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r470844633", "createdAt": "2020-08-14T20:13:05Z", "author": {"login": "msirek"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/ddl/DDLWatchRefresher.java", "diffHunk": "@@ -214,7 +216,30 @@ private void clearFinishedChanges(Collection<String> children,Collection<DDLWatc\n     private void assignDDLDemarcationPoint(DDLChange ddlChange) {\n         try {\n             TxnView txn = new LazyTxnView(ddlChange.getTxnId(),txnSupplier,exceptionFactory);\n-            assert txn.allowsWrites(): \"DDLChange \"+ddlChange+\" does not have a writable transaction\";\n+            // A full Restore operation overwrite SPLICE_TXN, so the transaction used by the restore\n+            // may not be found.  Avoid the assertion to avoid crashing, e.g.,\n+            // 2020-08-11 18:28:11,785 (ZooKeeperDDLWatcherRefresher) ERROR [c.s.d.d.AsynchronousDDLWatcher] - Failed to refresh ddl\n+            //java.lang.RuntimeException: com.splicemachine.si.api.txn.TransactionMissing: Couldn't resolve transaction with id 81981952", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU2NjQyMw=="}, "originalCommit": {"oid": "fa47b88ff181212c6e4ec3d9f9d9ffc3edb01d45"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MDU3NTU2OnYy", "diffSide": "RIGHT", "path": "splice_spark/src/test/scala/com/splicemachine/spark/splicemachine/TestContext.scala", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMToyNzo1MVrOHAxM5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMDoxNToxOVrOHBCIjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU2ODE2NQ==", "bodyText": "Does this make sense? We'd have to set those before instantiating the session, and this is already after that point, right?", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r470568165", "createdAt": "2020-08-14T11:27:51Z", "author": {"login": "dgomezferro"}, "path": "splice_spark/src/test/scala/com/splicemachine/spark/splicemachine/TestContext.scala", "diffHunk": "@@ -169,9 +170,14 @@ trait TestContext extends BeforeAndAfterAll { self: Suite =>\n   )\n \n   override def beforeAll() {\n-    sc = new SparkContext(conf)\n-    SpliceSpark.setContext(sc)\n-    spark = SparkSession.builder.config(conf).getOrCreate\n+    spark = SpliceSpark.getSessionUnsafe\n+    sqlContext = spark.sqlContext\n+    spark.conf.set(\"spark.master\", \"local[*]\")\n+    spark.conf.set(\"spark.app.name\", \"test\")\n+    spark.conf.set(\"spark.ui.enabled\", \"false\")\n+    spark.conf.set(\"spark.app.id\", appID)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa47b88ff181212c6e4ec3d9f9d9ffc3edb01d45"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg0NTU4Mg==", "bodyText": "This isn't a SparkConf, as in initializeSparkSession().  This is a RuntimeConfig:\n`  /**\n\nRuntime configuration interface for Spark.\n\nThis is the interface through which the user can get and set all Spark and Hadoop\nconfigurations that are relevant to Spark SQL. When getting the value of a config,\nthis defaults to the value set in the underlying SparkContext, if any.\n\n@SInCE 2.0.0\n*/\n@transient lazy val conf: RuntimeConfig = new RuntimeConfig(sessionState.conf)`", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r470845582", "createdAt": "2020-08-14T20:15:19Z", "author": {"login": "msirek"}, "path": "splice_spark/src/test/scala/com/splicemachine/spark/splicemachine/TestContext.scala", "diffHunk": "@@ -169,9 +170,14 @@ trait TestContext extends BeforeAndAfterAll { self: Suite =>\n   )\n \n   override def beforeAll() {\n-    sc = new SparkContext(conf)\n-    SpliceSpark.setContext(sc)\n-    spark = SparkSession.builder.config(conf).getOrCreate\n+    spark = SpliceSpark.getSessionUnsafe\n+    sqlContext = spark.sqlContext\n+    spark.conf.set(\"spark.master\", \"local[*]\")\n+    spark.conf.set(\"spark.app.name\", \"test\")\n+    spark.conf.set(\"spark.ui.enabled\", \"false\")\n+    spark.conf.set(\"spark.app.id\", appID)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU2ODE2NQ=="}, "originalCommit": {"oid": "fa47b88ff181212c6e4ec3d9f9d9ffc3edb01d45"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MDYwODgyOnYy", "diffSide": "RIGHT", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMTozOTozNVrOHAxgAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMDoxNTo0NlrOHBCJQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU3MzA1Nw==", "bodyText": "Can you move all these checks to a separate method to bring into focus the logic of the method?", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r470573057", "createdAt": "2020-08-14T11:39:35Z", "author": {"login": "dgomezferro"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java", "diffHunk": "@@ -71,11 +72,36 @@ private boolean isSorted(List<Cell> list) {\n     }\n \n     public void mutate(List<Cell> rawList, List<TxnView> txns, List<Cell> results) throws IOException {\n-        assert dataToReturn.isEmpty();\n-        assert results.isEmpty();\n-        assert maxTombstone == null;\n-        assert !LOG.isDebugEnabled() || isSorted(rawList) : \"CompactionStateMutate: rawList not sorted\";\n-        assert rawList.size() == txns.size();\n+        final boolean dataToReturnIsEmpty = dataToReturn.isEmpty();\n+        final boolean resultsIsEmpty = results.isEmpty();\n+        final boolean maxTombstoneIsNull = maxTombstone == null;\n+        final boolean rawListAndTxnListSameSize = rawList.size() == txns.size();\n+        final boolean debugSortCheck = !LOG.isDebugEnabled() || isSorted(rawList);\n+        if (!debugSortCheck) {\n+            bypassPurge = true;\n+            LOG.warn(\"Skipping tombstone purge.  rawList is not sorted.\");\n+        }\n+        if (!dataToReturnIsEmpty) {\n+            bypassPurge = true;\n+            LOG.warn(\"Skipping tombstone purge.  dataToReturn is not properly initialized.\");\n+        }\n+        if (!resultsIsEmpty) {\n+            bypassPurge = true;\n+            LOG.warn(\"Skipping tombstone purge.  results list not properly initialized.\");\n+        }\n+        if (!maxTombstoneIsNull) {\n+            bypassPurge = true;\n+            LOG.warn(\"Skipping tombstone purge.  maxTombstone not properly initialized to null.\");\n+        }\n+        if (!rawListAndTxnListSameSize) {\n+            bypassPurge = true;\n+            LOG.warn(\"Skipping tombstone purge.  rawList and txn list not the same length.\");\n+        }\n+        assert dataToReturnIsEmpty;\n+        assert resultsIsEmpty;\n+        assert maxTombstoneIsNull;\n+        assert debugSortCheck : \"CompactionStateMutate: rawList not sorted\";\n+        assert rawListAndTxnListSameSize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa47b88ff181212c6e4ec3d9f9d9ffc3edb01d45"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg0NTc2Mg==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r470845762", "createdAt": "2020-08-14T20:15:46Z", "author": {"login": "msirek"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java", "diffHunk": "@@ -71,11 +72,36 @@ private boolean isSorted(List<Cell> list) {\n     }\n \n     public void mutate(List<Cell> rawList, List<TxnView> txns, List<Cell> results) throws IOException {\n-        assert dataToReturn.isEmpty();\n-        assert results.isEmpty();\n-        assert maxTombstone == null;\n-        assert !LOG.isDebugEnabled() || isSorted(rawList) : \"CompactionStateMutate: rawList not sorted\";\n-        assert rawList.size() == txns.size();\n+        final boolean dataToReturnIsEmpty = dataToReturn.isEmpty();\n+        final boolean resultsIsEmpty = results.isEmpty();\n+        final boolean maxTombstoneIsNull = maxTombstone == null;\n+        final boolean rawListAndTxnListSameSize = rawList.size() == txns.size();\n+        final boolean debugSortCheck = !LOG.isDebugEnabled() || isSorted(rawList);\n+        if (!debugSortCheck) {\n+            bypassPurge = true;\n+            LOG.warn(\"Skipping tombstone purge.  rawList is not sorted.\");\n+        }\n+        if (!dataToReturnIsEmpty) {\n+            bypassPurge = true;\n+            LOG.warn(\"Skipping tombstone purge.  dataToReturn is not properly initialized.\");\n+        }\n+        if (!resultsIsEmpty) {\n+            bypassPurge = true;\n+            LOG.warn(\"Skipping tombstone purge.  results list not properly initialized.\");\n+        }\n+        if (!maxTombstoneIsNull) {\n+            bypassPurge = true;\n+            LOG.warn(\"Skipping tombstone purge.  maxTombstone not properly initialized to null.\");\n+        }\n+        if (!rawListAndTxnListSameSize) {\n+            bypassPurge = true;\n+            LOG.warn(\"Skipping tombstone purge.  rawList and txn list not the same length.\");\n+        }\n+        assert dataToReturnIsEmpty;\n+        assert resultsIsEmpty;\n+        assert maxTombstoneIsNull;\n+        assert debugSortCheck : \"CompactionStateMutate: rawList not sorted\";\n+        assert rawListAndTxnListSameSize;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU3MzA1Nw=="}, "originalCommit": {"oid": "fa47b88ff181212c6e4ec3d9f9d9ffc3edb01d45"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MDYxMDI5OnYy", "diffSide": "RIGHT", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMTo0MDowMlrOHAxg3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMDoxOTowNVrOHBCObA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU3MzI3Nw==", "bodyText": "Is this something that happens sometimes or just defensive programming?", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r470573277", "createdAt": "2020-08-14T11:40:02Z", "author": {"login": "dgomezferro"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java", "diffHunk": "@@ -71,11 +72,36 @@ private boolean isSorted(List<Cell> list) {\n     }\n \n     public void mutate(List<Cell> rawList, List<TxnView> txns, List<Cell> results) throws IOException {\n-        assert dataToReturn.isEmpty();\n-        assert results.isEmpty();\n-        assert maxTombstone == null;\n-        assert !LOG.isDebugEnabled() || isSorted(rawList) : \"CompactionStateMutate: rawList not sorted\";\n-        assert rawList.size() == txns.size();\n+        final boolean dataToReturnIsEmpty = dataToReturn.isEmpty();\n+        final boolean resultsIsEmpty = results.isEmpty();\n+        final boolean maxTombstoneIsNull = maxTombstone == null;\n+        final boolean rawListAndTxnListSameSize = rawList.size() == txns.size();\n+        final boolean debugSortCheck = !LOG.isDebugEnabled() || isSorted(rawList);\n+        if (!debugSortCheck) {\n+            bypassPurge = true;\n+            LOG.warn(\"Skipping tombstone purge.  rawList is not sorted.\");\n+        }\n+        if (!dataToReturnIsEmpty) {\n+            bypassPurge = true;\n+            LOG.warn(\"Skipping tombstone purge.  dataToReturn is not properly initialized.\");\n+        }\n+        if (!resultsIsEmpty) {\n+            bypassPurge = true;\n+            LOG.warn(\"Skipping tombstone purge.  results list not properly initialized.\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa47b88ff181212c6e4ec3d9f9d9ffc3edb01d45"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg0NzA4NA==", "bodyText": "Yes, this is mainly just defensive programming.  I only ran across 2 of the assertions being hit (not the above 2 you highlighted), but I decided to handle all assertions, just in case.  An alternative would be to convert the assert statements into checks which throw IOExceptions.  These would be active on a cluster as well, whether or not assertions were enabled on it.", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r470847084", "createdAt": "2020-08-14T20:19:05Z", "author": {"login": "msirek"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java", "diffHunk": "@@ -71,11 +72,36 @@ private boolean isSorted(List<Cell> list) {\n     }\n \n     public void mutate(List<Cell> rawList, List<TxnView> txns, List<Cell> results) throws IOException {\n-        assert dataToReturn.isEmpty();\n-        assert results.isEmpty();\n-        assert maxTombstone == null;\n-        assert !LOG.isDebugEnabled() || isSorted(rawList) : \"CompactionStateMutate: rawList not sorted\";\n-        assert rawList.size() == txns.size();\n+        final boolean dataToReturnIsEmpty = dataToReturn.isEmpty();\n+        final boolean resultsIsEmpty = results.isEmpty();\n+        final boolean maxTombstoneIsNull = maxTombstone == null;\n+        final boolean rawListAndTxnListSameSize = rawList.size() == txns.size();\n+        final boolean debugSortCheck = !LOG.isDebugEnabled() || isSorted(rawList);\n+        if (!debugSortCheck) {\n+            bypassPurge = true;\n+            LOG.warn(\"Skipping tombstone purge.  rawList is not sorted.\");\n+        }\n+        if (!dataToReturnIsEmpty) {\n+            bypassPurge = true;\n+            LOG.warn(\"Skipping tombstone purge.  dataToReturn is not properly initialized.\");\n+        }\n+        if (!resultsIsEmpty) {\n+            bypassPurge = true;\n+            LOG.warn(\"Skipping tombstone purge.  results list not properly initialized.\");\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU3MzI3Nw=="}, "originalCommit": {"oid": "fa47b88ff181212c6e4ec3d9f9d9ffc3edb01d45"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Nzc4MDA3OnYy", "diffSide": "RIGHT", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjo0MToyNVrOHBwaDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjo0MToyNVrOHBwaDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYwMzcyNA==", "bodyText": "More accurately, assertions are thrown during our IT runs as well.", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r471603724", "createdAt": "2020-08-17T16:41:25Z", "author": {"login": "arnaud-splice"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java", "diffHunk": "@@ -161,10 +206,24 @@ private void mutate(Cell element, TxnView txn) throws IOException {\n                 lastSeenAntiTombstone = element;\n                 break;\n             case FIRST_WRITE_TOKEN:\n+                // Assertions are only thrown on standalone.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5389c7a3a2872eab22ecfa596ad0982d370da7d"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NDcwNDgyOnYy", "diffSide": "LEFT", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzoxMToyNFrOHEWPDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwMjoxODoxMFrOHEZRdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMDY1Mg==", "bodyText": "We may want to keep assertions because they are fired during ITs and can catch bugs. In case they are disables on a cluster, handleSanity Checks can safely bypass purge.", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r474320652", "createdAt": "2020-08-20T23:11:24Z", "author": {"login": "jyuanca"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java", "diffHunk": "@@ -71,15 +72,43 @@ private boolean isSorted(List<Cell> list) {\n         return true;\n     }\n \n+    private void handleSanityChecks(List<Cell> results,\n+                                    List<Cell> rawList,\n+                                    List<TxnView> txns) {\n+        final boolean dataToReturnIsEmpty = dataToReturn.isEmpty();\n+        final boolean resultsIsEmpty = results.isEmpty();\n+        final boolean maxTombstoneIsNull = maxTombstone == null;\n+        final boolean rawListAndTxnListSameSize = rawList.size() == txns.size();\n+        final boolean debugSortCheck = !LOG.isDebugEnabled() || isSorted(rawList);\n+\n+        if (!debugSortCheck)\n+            setBypassPurgeWithWarning(\"CompactionStateMutate: rawList is not sorted.\");\n+        if (!dataToReturnIsEmpty)\n+            setBypassPurgeWithWarning(\"dataToReturn is not properly initialized.\");\n+        if (!resultsIsEmpty)\n+            setBypassPurgeWithWarning(\"results list not properly initialized.\");\n+        if (!maxTombstoneIsNull)\n+            setBypassPurgeWithWarning(\"maxTombstone not properly initialized to null.\");\n+        if (!rawListAndTxnListSameSize)\n+            setBypassPurgeWithWarning(\"rawList and txn list not the same length.\");\n+\n+        assert dataToReturnIsEmpty;\n+        assert resultsIsEmpty;\n+        assert maxTombstoneIsNull;\n+        assert debugSortCheck : \"CompactionStateMutate: rawList not sorted\";\n+        assert rawListAndTxnListSameSize;\n+    }\n+\n+    private void setBypassPurgeWithWarning(String warningMessage) {\n+        bypassPurge = true;\n+        LOG.warn(\"Skipping tombstone purge.  \" + warningMessage);\n+    }\n+\n     /***\n      * @return the size of all cells in the `rawList` parameter.\n      */\n     public long mutate(List<Cell> rawList, List<TxnView> txns, List<Cell> results) throws IOException {\n-        assert dataToReturn.isEmpty();\n-        assert results.isEmpty();\n-        assert maxTombstone == null;\n-        assert !LOG.isDebugEnabled() || isSorted(rawList) : \"CompactionStateMutate: rawList not sorted\";\n-        assert rawList.size() == txns.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77e5ad1bc16f7fdffc5ef613366f7116cb279833"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyOTkyMw==", "bodyText": "Looks like the same assertions were moved into the handleSanityChecks method, so they are being kept.", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r474329923", "createdAt": "2020-08-20T23:43:02Z", "author": {"login": "jpanko1"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java", "diffHunk": "@@ -71,15 +72,43 @@ private boolean isSorted(List<Cell> list) {\n         return true;\n     }\n \n+    private void handleSanityChecks(List<Cell> results,\n+                                    List<Cell> rawList,\n+                                    List<TxnView> txns) {\n+        final boolean dataToReturnIsEmpty = dataToReturn.isEmpty();\n+        final boolean resultsIsEmpty = results.isEmpty();\n+        final boolean maxTombstoneIsNull = maxTombstone == null;\n+        final boolean rawListAndTxnListSameSize = rawList.size() == txns.size();\n+        final boolean debugSortCheck = !LOG.isDebugEnabled() || isSorted(rawList);\n+\n+        if (!debugSortCheck)\n+            setBypassPurgeWithWarning(\"CompactionStateMutate: rawList is not sorted.\");\n+        if (!dataToReturnIsEmpty)\n+            setBypassPurgeWithWarning(\"dataToReturn is not properly initialized.\");\n+        if (!resultsIsEmpty)\n+            setBypassPurgeWithWarning(\"results list not properly initialized.\");\n+        if (!maxTombstoneIsNull)\n+            setBypassPurgeWithWarning(\"maxTombstone not properly initialized to null.\");\n+        if (!rawListAndTxnListSameSize)\n+            setBypassPurgeWithWarning(\"rawList and txn list not the same length.\");\n+\n+        assert dataToReturnIsEmpty;\n+        assert resultsIsEmpty;\n+        assert maxTombstoneIsNull;\n+        assert debugSortCheck : \"CompactionStateMutate: rawList not sorted\";\n+        assert rawListAndTxnListSameSize;\n+    }\n+\n+    private void setBypassPurgeWithWarning(String warningMessage) {\n+        bypassPurge = true;\n+        LOG.warn(\"Skipping tombstone purge.  \" + warningMessage);\n+    }\n+\n     /***\n      * @return the size of all cells in the `rawList` parameter.\n      */\n     public long mutate(List<Cell> rawList, List<TxnView> txns, List<Cell> results) throws IOException {\n-        assert dataToReturn.isEmpty();\n-        assert results.isEmpty();\n-        assert maxTombstone == null;\n-        assert !LOG.isDebugEnabled() || isSorted(rawList) : \"CompactionStateMutate: rawList not sorted\";\n-        assert rawList.size() == txns.size();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMDY1Mg=="}, "originalCommit": {"oid": "77e5ad1bc16f7fdffc5ef613366f7116cb279833"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMDkwOQ==", "bodyText": "They become warning messages and does not cause a failure for IT", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r474330909", "createdAt": "2020-08-20T23:46:30Z", "author": {"login": "jyuanca"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java", "diffHunk": "@@ -71,15 +72,43 @@ private boolean isSorted(List<Cell> list) {\n         return true;\n     }\n \n+    private void handleSanityChecks(List<Cell> results,\n+                                    List<Cell> rawList,\n+                                    List<TxnView> txns) {\n+        final boolean dataToReturnIsEmpty = dataToReturn.isEmpty();\n+        final boolean resultsIsEmpty = results.isEmpty();\n+        final boolean maxTombstoneIsNull = maxTombstone == null;\n+        final boolean rawListAndTxnListSameSize = rawList.size() == txns.size();\n+        final boolean debugSortCheck = !LOG.isDebugEnabled() || isSorted(rawList);\n+\n+        if (!debugSortCheck)\n+            setBypassPurgeWithWarning(\"CompactionStateMutate: rawList is not sorted.\");\n+        if (!dataToReturnIsEmpty)\n+            setBypassPurgeWithWarning(\"dataToReturn is not properly initialized.\");\n+        if (!resultsIsEmpty)\n+            setBypassPurgeWithWarning(\"results list not properly initialized.\");\n+        if (!maxTombstoneIsNull)\n+            setBypassPurgeWithWarning(\"maxTombstone not properly initialized to null.\");\n+        if (!rawListAndTxnListSameSize)\n+            setBypassPurgeWithWarning(\"rawList and txn list not the same length.\");\n+\n+        assert dataToReturnIsEmpty;\n+        assert resultsIsEmpty;\n+        assert maxTombstoneIsNull;\n+        assert debugSortCheck : \"CompactionStateMutate: rawList not sorted\";\n+        assert rawListAndTxnListSameSize;\n+    }\n+\n+    private void setBypassPurgeWithWarning(String warningMessage) {\n+        bypassPurge = true;\n+        LOG.warn(\"Skipping tombstone purge.  \" + warningMessage);\n+    }\n+\n     /***\n      * @return the size of all cells in the `rawList` parameter.\n      */\n     public long mutate(List<Cell> rawList, List<TxnView> txns, List<Cell> results) throws IOException {\n-        assert dataToReturn.isEmpty();\n-        assert results.isEmpty();\n-        assert maxTombstone == null;\n-        assert !LOG.isDebugEnabled() || isSorted(rawList) : \"CompactionStateMutate: rawList not sorted\";\n-        assert rawList.size() == txns.size();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMDY1Mg=="}, "originalCommit": {"oid": "77e5ad1bc16f7fdffc5ef613366f7116cb279833"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM3MDQyMA==", "bodyText": "Feel free to write a Jira.  I'm merging now so it can get into this week's build.", "url": "https://github.com/splicemachine/spliceengine/pull/3969#discussion_r474370420", "createdAt": "2020-08-21T02:18:10Z", "author": {"login": "jpanko1"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java", "diffHunk": "@@ -71,15 +72,43 @@ private boolean isSorted(List<Cell> list) {\n         return true;\n     }\n \n+    private void handleSanityChecks(List<Cell> results,\n+                                    List<Cell> rawList,\n+                                    List<TxnView> txns) {\n+        final boolean dataToReturnIsEmpty = dataToReturn.isEmpty();\n+        final boolean resultsIsEmpty = results.isEmpty();\n+        final boolean maxTombstoneIsNull = maxTombstone == null;\n+        final boolean rawListAndTxnListSameSize = rawList.size() == txns.size();\n+        final boolean debugSortCheck = !LOG.isDebugEnabled() || isSorted(rawList);\n+\n+        if (!debugSortCheck)\n+            setBypassPurgeWithWarning(\"CompactionStateMutate: rawList is not sorted.\");\n+        if (!dataToReturnIsEmpty)\n+            setBypassPurgeWithWarning(\"dataToReturn is not properly initialized.\");\n+        if (!resultsIsEmpty)\n+            setBypassPurgeWithWarning(\"results list not properly initialized.\");\n+        if (!maxTombstoneIsNull)\n+            setBypassPurgeWithWarning(\"maxTombstone not properly initialized to null.\");\n+        if (!rawListAndTxnListSameSize)\n+            setBypassPurgeWithWarning(\"rawList and txn list not the same length.\");\n+\n+        assert dataToReturnIsEmpty;\n+        assert resultsIsEmpty;\n+        assert maxTombstoneIsNull;\n+        assert debugSortCheck : \"CompactionStateMutate: rawList not sorted\";\n+        assert rawListAndTxnListSameSize;\n+    }\n+\n+    private void setBypassPurgeWithWarning(String warningMessage) {\n+        bypassPurge = true;\n+        LOG.warn(\"Skipping tombstone purge.  \" + warningMessage);\n+    }\n+\n     /***\n      * @return the size of all cells in the `rawList` parameter.\n      */\n     public long mutate(List<Cell> rawList, List<TxnView> txns, List<Cell> results) throws IOException {\n-        assert dataToReturn.isEmpty();\n-        assert results.isEmpty();\n-        assert maxTombstone == null;\n-        assert !LOG.isDebugEnabled() || isSorted(rawList) : \"CompactionStateMutate: rawList not sorted\";\n-        assert rawList.size() == txns.size();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMDY1Mg=="}, "originalCommit": {"oid": "77e5ad1bc16f7fdffc5ef613366f7116cb279833"}, "originalPosition": 52}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3064, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}