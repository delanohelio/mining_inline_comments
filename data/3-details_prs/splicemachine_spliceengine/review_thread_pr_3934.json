{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyODgxODg5", "number": 3934, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwOTo1NzozMlrOEVwuPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwOTo1NzozMlrOEVwuPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMjUzODIyOnYy", "diffSide": "RIGHT", "path": "db-tools-ij/src/main/resources/com/splicemachine/db/loc/toolsmessages_de_DE.properties", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwOTo1NzozMlrOG8sz9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNToyODozN1rOG9ePhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMwMTk0MQ==", "bodyText": "This might be a stupid question, but the newly added SPOOL message will show in German if IJ_IjErro0=IJ-FEHLER\\: {0} is deleted?", "url": "https://github.com/splicemachine/spliceengine/pull/3934#discussion_r466301941", "createdAt": "2020-08-06T09:57:32Z", "author": {"login": "ascend1"}, "path": "db-tools-ij/src/main/resources/com/splicemachine/db/loc/toolsmessages_de_DE.properties", "diffHunk": "@@ -86,8 +86,7 @@ IJ_Fata01=Schwerwiegende Ausnahme\\: {0}\\: {1}\n IJ_FataExceTerm=Schwerwiegende Ausnahme. Das Tool wird beendet.\n IJ_FileNotFoun=Datei nicht gefunden\n IJ_GetcCallFail=Aufruf von getConnection gescheitert\n-IJ_HelpText=\\ \\n\\ Unter anderem werden folgende Befehle unterst\\u00FCtzt:\\n\\  PROTOCOL ''JDBC-Protokoll'' [ AS Kennung ];\\n\\                               -- definiert ein benanntes oder Standardprotokoll\\n\\  DRIVER ''Treiberklasse'';   -- l\\u00E4dt die benannte Klasse\\n\\ CONNECT ''Datenbank-URL'' [ PROTOCOL benanntesProtokoll ] [ AS Verbindungsname ];\\n\\                               -- stellt Verbindung zum Datenbank-URL her\\n\\                               -- kann eine Kennung zuordnen\\n\\  SET CONNECTION Verbindungsname; -- schaltet auf die angegebene Verbindung um\\n\\  SHOW CONNECTIONS;             -- listet alle Verbindungen auf\\n\\ AUTOCOMMIT [ ON | OFF ];     -- legt das automatische Festschreiben der Verbindung fest\\n\\ DISCONNECT [ CURRENT | Verbindungsname | ALL ];\\n\\                               -- aktuelle, benannte oder alle Verbindungen trennen;\\n\\                                -- Standardeinstellung: CURRENT\\n\\ \\n\\ SHOW SCHEMAS;                -- listet alle Schemata in der aktuellen Datenbank auf\\n\\  SHOW [ TABLES | VIEWS | PROCEDURES | FUNCTIONS | SYNONYMS ] '{' IN Schema '}';\\n\\                               -- listet Tabellen, Ansichten, Prozeduren, Funktionen oder Synonyme auf\\n\\  SHOW INDEXES '{' IN Schema | FROM Tabelle '}';\\n\\                                -- listet Indizes in einem Schema oder f\\u00FCr eine Tabelle auf\\n\\ SHOW ROLES;                   -- listet alle definierten Rollen in der Datenbank auf,\\n\\                               -- sortiert\\n\\  SHOW ENABLED_ROLES;          -- listet die aktivierten Rollen f\\u00FCr die aktuelle\\n\\                               -- Verbindung auf (siehe die Verwendung der aktuellen Rolle\\n\\                               -- VALUES CURRENT_ROLE), sortiert\\n\\  SHOW SETTABLE_ROLES;         -- listet die Rollen auf, die f\\u00FCr\\n\\                               -- die aktuelle Verbindung festgelegt werden k\\u00F6nnen, sortiert\\n\\  DESCRIBE Name;               -- listet die Spalten in der benannten Tabelle auf\\n\\ \\n\\  COMMIT;                      -- schreibt die aktuelle Transaktion fest\\n\\  ROLLBACK;                    -- setzt die aktuelle Transaktion zur\\u00FCck\\n\\ \\n\\  PREPARE Name AS ''SQL-J-Text''; -- bereitet den SQL-J-Text vor\\n\\  EXECUTE '{' Name | ''SQL-J-Text'' '}' [ USING '{' Name | ''SQL-J-Text'' '}' ] ;\\n\\                               -- f\\u00FChrt die Anweisung mit Parameterwerten\\n\\                               -- von der USING-ResultSet-Zeile durch\\n\\  REMOVE Name;                 -- entfernt die benannte zuvor vorbereitete Anweisung\\n\\ \\n\\  RUN ''Dateiname'';              -- f\\u00FChrt Befehle von der benannten Datei aus\\n\\ \\n\\  ELAPSEDTIME [ ON | OFF ];    -- legt den Modus f\\u00FCr abgelaufene Zeit f\\u00FCr ij fest\\n\\  MAXIMUMDISPLAYWIDTH Ganzzahlwert;\\n\\                               -- legt die maximale Anzeigebreite f\\u00FCr\\n\\                               -- jede Spalte auf einen Ganzzahlwert fest\\n\\ \\n\\  ASYNC Name ''SQL-J-Text'';     -- f\\u00FChrt den Befehl in einem anderen Thread aus\\n\\  WAIT FOR Name;               -- warten auf Ergebnis von Befehl f\\u00FCr ASYNC\\n\\ \\n\\  GET [SCROLL INSENSITIVE] [WITH  '{HOLD | NOHOLD}'] CURSOR Name AS ''SQL-J-Abfrage'';\\n\\                               -- ruft einen Cursor (JDBC-ResultSet) f\\u00FCr die Abfrage ab\\n\\                               -- der Standard ist ein Forward-Only-Cursor mit Holdability\\n\\  NEXT Name;                   -- ruft die n\\u00E4chste Zeile aus dem benannten Cursor ab\\n\\  FIRST Name;                  -- ruft die erste Zeile aus dem benannten Scroll-Cursor ab\\n\\  LAST Name;                   -- ruft die letzte Zeile aus dem benannten Scroll-Cursor ab\\n\\  PREVIOUS Name;               -- ruft die vorige Zeile aus dem benannten Scroll-Cursor ab\\n\\  ABSOLUTE Ganzzahlname;       -- positioniert den benannten Scroll-Cursor an der absoluten Zeilenzahl\\n\\                               -- (Eine negative Zahl gibt die Position von der letzten Zeile an.) \\n\\  RELATIVE ganzeZahl Name;        -- platziert den benannten Scroll-Cursor relativ zur aktuellen Zeile\\n\\       -- (ganzeZahl ist die Anzahl der Zeilen)\\n\\  AFTER LAST Name;                -- platziert den benannten Scroll-Cursor hinter der letzten Zeile\\n\\  BEFORE FIRST Name;              -- platziert den benannten Scroll-Cursor vor der ersten Zeile\\n\\  GETCURRENTROWNUMBER Name;       -- gibt f\\u00FCr die aktuelle Position des benannten Scroll-Cursors die Zeilennummer an\\n\\                                  -- (Befindet sich der Cursor nicht in einer Zeile, wird 0 zur\\u00FCckgegeben.) \\n\\  CLOSE Name;                     -- schlie\\u00DFt den benannten Cursor\\n\\  LOCALIZEDDISPLAY [ ON | OFF ];\\n\\  -- steuert die Darstellung von Daten, die von der L\\u00E4ndereinstellung abh\\u00E4ngen\\n\\ \\n\\  EXIT;                                             -- beendet IJ\\n\\  HELP;                 -- zeigt diese Nachricht an\\n\\ \\n\\ Nicht erkannte Befehle werden als potenzielle SQL-J-Befehle angesehen und direkt ausgef\\u00FChrt.\\n\\ \\n\n-IJ_IjErro0=IJ-FEHLER\\: {0}\n+IJ_HelpText=\\ \\n\\ Unter anderem werden folgende Befehle unterst\\u00FCtzt:\\n\\  PROTOCOL ''JDBC-Protokoll'' [ AS Kennung ];\\n\\                               -- definiert ein benanntes oder Standardprotokoll\\n\\  DRIVER ''Treiberklasse'';   -- l\\u00E4dt die benannte Klasse\\n\\ CONNECT ''Datenbank-URL'' [ PROTOCOL benanntesProtokoll ] [ AS Verbindungsname ];\\n\\                               -- stellt Verbindung zum Datenbank-URL her\\n\\                               -- kann eine Kennung zuordnen\\n\\  SET CONNECTION Verbindungsname; -- schaltet auf die angegebene Verbindung um\\n\\  SHOW CONNECTIONS;             -- listet alle Verbindungen auf\\n\\ AUTOCOMMIT [ ON | OFF ];     -- legt das automatische Festschreiben der Verbindung fest\\n\\ DISCONNECT [ CURRENT | Verbindungsname | ALL ];\\n\\                               -- aktuelle, benannte oder alle Verbindungen trennen;\\n\\                                -- Standardeinstellung: CURRENT\\n\\ \\n\\ SHOW SCHEMAS;                -- listet alle Schemata in der aktuellen Datenbank auf\\n\\  SHOW [ TABLES | VIEWS | PROCEDURES | FUNCTIONS | SYNONYMS ] '{' IN Schema '}';\\n\\                               -- listet Tabellen, Ansichten, Prozeduren, Funktionen oder Synonyme auf\\n\\  SHOW INDEXES '{' IN Schema | FROM Tabelle '}';\\n\\                                -- listet Indizes in einem Schema oder f\\u00FCr eine Tabelle auf\\n\\ SHOW ROLES;                   -- listet alle definierten Rollen in der Datenbank auf,\\n\\                               -- sortiert\\n\\  SHOW ENABLED_ROLES;          -- listet die aktivierten Rollen f\\u00FCr die aktuelle\\n\\                               -- Verbindung auf (siehe die Verwendung der aktuellen Rolle\\n\\                               -- VALUES CURRENT_ROLE), sortiert\\n\\  SHOW SETTABLE_ROLES;         -- listet die Rollen auf, die f\\u00FCr\\n\\                               -- die aktuelle Verbindung festgelegt werden k\\u00F6nnen, sortiert\\n\\  DESCRIBE Name;               -- listet die Spalten in der benannten Tabelle auf\\n\\ \\n\\  COMMIT;                      -- schreibt die aktuelle Transaktion fest\\n\\  ROLLBACK;                    -- setzt die aktuelle Transaktion zur\\u00FCck\\n\\ \\n\\  PREPARE Name AS ''SQL-J-Text''; -- bereitet den SQL-J-Text vor\\n\\  EXECUTE '{' Name | ''SQL-J-Text'' '}' [ USING '{' Name | ''SQL-J-Text'' '}' ] ;\\n\\                               -- f\\u00FChrt die Anweisung mit Parameterwerten\\n\\                               -- von der USING-ResultSet-Zeile durch\\n\\  REMOVE Name;                 -- entfernt die benannte zuvor vorbereitete Anweisung\\n\\ \\n\\  RUN ''Dateiname'';              -- f\\u00FChrt Befehle von der benannten Datei aus\\n\\ \\n\\  ELAPSEDTIME [ ON | OFF ];    -- legt den Modus f\\u00FCr abgelaufene Zeit f\\u00FCr ij fest\\n\\  MAXIMUMDISPLAYWIDTH Ganzzahlwert;\\n\\                               -- legt die maximale Anzeigebreite f\\u00FCr\\n\\                               -- jede Spalte auf einen Ganzzahlwert fest\\n\\ \\n\\  ASYNC Name ''SQL-J-Text'';     -- f\\u00FChrt den Befehl in einem anderen Thread aus\\n\\  WAIT FOR Name;               -- warten auf Ergebnis von Befehl f\\u00FCr ASYNC\\n\\ \\n\\  GET [SCROLL INSENSITIVE] [WITH  '{HOLD | NOHOLD}'] CURSOR Name AS ''SQL-J-Abfrage'';\\n\\                               -- ruft einen Cursor (JDBC-ResultSet) f\\u00FCr die Abfrage ab\\n\\                               -- der Standard ist ein Forward-Only-Cursor mit Holdability\\n\\  NEXT Name;                   -- ruft die n\\u00E4chste Zeile aus dem benannten Cursor ab\\n\\  FIRST Name;                  -- ruft die erste Zeile aus dem benannten Scroll-Cursor ab\\n\\  LAST Name;                   -- ruft die letzte Zeile aus dem benannten Scroll-Cursor ab\\n\\  PREVIOUS Name;               -- ruft die vorige Zeile aus dem benannten Scroll-Cursor ab\\n\\  ABSOLUTE Ganzzahlname;       -- positioniert den benannten Scroll-Cursor an der absoluten Zeilenzahl\\n\\                               -- (Eine negative Zahl gibt die Position von der letzten Zeile an.) \\n\\  RELATIVE ganzeZahl Name;        -- platziert den benannten Scroll-Cursor relativ zur aktuellen Zeile\\n\\       -- (ganzeZahl ist die Anzahl der Zeilen)\\n\\  AFTER LAST Name;                -- platziert den benannten Scroll-Cursor hinter der letzten Zeile\\n\\  BEFORE FIRST Name;              -- platziert den benannten Scroll-Cursor vor der ersten Zeile\\n\\  GETCURRENTROWNUMBER Name;       -- gibt f\\u00FCr die aktuelle Position des benannten Scroll-Cursors die Zeilennummer an\\n\\                                  -- (Befindet sich der Cursor nicht in einer Zeile, wird 0 zur\\u00FCckgegeben.) \\n\\  CLOSE Name;                     -- schlie\\u00DFt den benannten Cursor\\n\\  LOCALIZEDDISPLAY [ ON | OFF ];\\n\\  -- steuert die Darstellung von Daten, die von der L\\u00E4ndereinstellung abh\\u00E4ngen\\n\\ \\n\\  EXIT;                                             -- beendet IJ\\n\\  HELP;                 -- zeigt diese Nachricht an\\n\\\\n\\  SPOOL '<DATEI>';                 -- schreibt SQL Befehle und ihre Ergebnisse in <DATEI>\\n\\  SPOOL STOP;                 -- h\\u00F6rt auf, SQL Befehle und ihre Ergebnisse in Datei zu schreiben\\n\\  SPOOL CLEAR;                 -- l\\u00F6scht Daten aus der Datei, in die SQL Befehle und ihre Ergebnisse geschrieben sind\\n\\ \\n\\ Nicht erkannte Befehle werden als potenzielle SQL-J-Befehle angesehen und direkt ausgef\\u00FChrt.\\n\\ \\nIJ_IjErro0=IJ-FEHLER\\: {0}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a51d0c11b0d6ffe95de961caf8e936e42384ec06"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExMTgxMw==", "bodyText": "fixed and cleaned up the German help message.", "url": "https://github.com/splicemachine/spliceengine/pull/3934#discussion_r467111813", "createdAt": "2020-08-07T15:28:37Z", "author": {"login": "hatyo"}, "path": "db-tools-ij/src/main/resources/com/splicemachine/db/loc/toolsmessages_de_DE.properties", "diffHunk": "@@ -86,8 +86,7 @@ IJ_Fata01=Schwerwiegende Ausnahme\\: {0}\\: {1}\n IJ_FataExceTerm=Schwerwiegende Ausnahme. Das Tool wird beendet.\n IJ_FileNotFoun=Datei nicht gefunden\n IJ_GetcCallFail=Aufruf von getConnection gescheitert\n-IJ_HelpText=\\ \\n\\ Unter anderem werden folgende Befehle unterst\\u00FCtzt:\\n\\  PROTOCOL ''JDBC-Protokoll'' [ AS Kennung ];\\n\\                               -- definiert ein benanntes oder Standardprotokoll\\n\\  DRIVER ''Treiberklasse'';   -- l\\u00E4dt die benannte Klasse\\n\\ CONNECT ''Datenbank-URL'' [ PROTOCOL benanntesProtokoll ] [ AS Verbindungsname ];\\n\\                               -- stellt Verbindung zum Datenbank-URL her\\n\\                               -- kann eine Kennung zuordnen\\n\\  SET CONNECTION Verbindungsname; -- schaltet auf die angegebene Verbindung um\\n\\  SHOW CONNECTIONS;             -- listet alle Verbindungen auf\\n\\ AUTOCOMMIT [ ON | OFF ];     -- legt das automatische Festschreiben der Verbindung fest\\n\\ DISCONNECT [ CURRENT | Verbindungsname | ALL ];\\n\\                               -- aktuelle, benannte oder alle Verbindungen trennen;\\n\\                                -- Standardeinstellung: CURRENT\\n\\ \\n\\ SHOW SCHEMAS;                -- listet alle Schemata in der aktuellen Datenbank auf\\n\\  SHOW [ TABLES | VIEWS | PROCEDURES | FUNCTIONS | SYNONYMS ] '{' IN Schema '}';\\n\\                               -- listet Tabellen, Ansichten, Prozeduren, Funktionen oder Synonyme auf\\n\\  SHOW INDEXES '{' IN Schema | FROM Tabelle '}';\\n\\                                -- listet Indizes in einem Schema oder f\\u00FCr eine Tabelle auf\\n\\ SHOW ROLES;                   -- listet alle definierten Rollen in der Datenbank auf,\\n\\                               -- sortiert\\n\\  SHOW ENABLED_ROLES;          -- listet die aktivierten Rollen f\\u00FCr die aktuelle\\n\\                               -- Verbindung auf (siehe die Verwendung der aktuellen Rolle\\n\\                               -- VALUES CURRENT_ROLE), sortiert\\n\\  SHOW SETTABLE_ROLES;         -- listet die Rollen auf, die f\\u00FCr\\n\\                               -- die aktuelle Verbindung festgelegt werden k\\u00F6nnen, sortiert\\n\\  DESCRIBE Name;               -- listet die Spalten in der benannten Tabelle auf\\n\\ \\n\\  COMMIT;                      -- schreibt die aktuelle Transaktion fest\\n\\  ROLLBACK;                    -- setzt die aktuelle Transaktion zur\\u00FCck\\n\\ \\n\\  PREPARE Name AS ''SQL-J-Text''; -- bereitet den SQL-J-Text vor\\n\\  EXECUTE '{' Name | ''SQL-J-Text'' '}' [ USING '{' Name | ''SQL-J-Text'' '}' ] ;\\n\\                               -- f\\u00FChrt die Anweisung mit Parameterwerten\\n\\                               -- von der USING-ResultSet-Zeile durch\\n\\  REMOVE Name;                 -- entfernt die benannte zuvor vorbereitete Anweisung\\n\\ \\n\\  RUN ''Dateiname'';              -- f\\u00FChrt Befehle von der benannten Datei aus\\n\\ \\n\\  ELAPSEDTIME [ ON | OFF ];    -- legt den Modus f\\u00FCr abgelaufene Zeit f\\u00FCr ij fest\\n\\  MAXIMUMDISPLAYWIDTH Ganzzahlwert;\\n\\                               -- legt die maximale Anzeigebreite f\\u00FCr\\n\\                               -- jede Spalte auf einen Ganzzahlwert fest\\n\\ \\n\\  ASYNC Name ''SQL-J-Text'';     -- f\\u00FChrt den Befehl in einem anderen Thread aus\\n\\  WAIT FOR Name;               -- warten auf Ergebnis von Befehl f\\u00FCr ASYNC\\n\\ \\n\\  GET [SCROLL INSENSITIVE] [WITH  '{HOLD | NOHOLD}'] CURSOR Name AS ''SQL-J-Abfrage'';\\n\\                               -- ruft einen Cursor (JDBC-ResultSet) f\\u00FCr die Abfrage ab\\n\\                               -- der Standard ist ein Forward-Only-Cursor mit Holdability\\n\\  NEXT Name;                   -- ruft die n\\u00E4chste Zeile aus dem benannten Cursor ab\\n\\  FIRST Name;                  -- ruft die erste Zeile aus dem benannten Scroll-Cursor ab\\n\\  LAST Name;                   -- ruft die letzte Zeile aus dem benannten Scroll-Cursor ab\\n\\  PREVIOUS Name;               -- ruft die vorige Zeile aus dem benannten Scroll-Cursor ab\\n\\  ABSOLUTE Ganzzahlname;       -- positioniert den benannten Scroll-Cursor an der absoluten Zeilenzahl\\n\\                               -- (Eine negative Zahl gibt die Position von der letzten Zeile an.) \\n\\  RELATIVE ganzeZahl Name;        -- platziert den benannten Scroll-Cursor relativ zur aktuellen Zeile\\n\\       -- (ganzeZahl ist die Anzahl der Zeilen)\\n\\  AFTER LAST Name;                -- platziert den benannten Scroll-Cursor hinter der letzten Zeile\\n\\  BEFORE FIRST Name;              -- platziert den benannten Scroll-Cursor vor der ersten Zeile\\n\\  GETCURRENTROWNUMBER Name;       -- gibt f\\u00FCr die aktuelle Position des benannten Scroll-Cursors die Zeilennummer an\\n\\                                  -- (Befindet sich der Cursor nicht in einer Zeile, wird 0 zur\\u00FCckgegeben.) \\n\\  CLOSE Name;                     -- schlie\\u00DFt den benannten Cursor\\n\\  LOCALIZEDDISPLAY [ ON | OFF ];\\n\\  -- steuert die Darstellung von Daten, die von der L\\u00E4ndereinstellung abh\\u00E4ngen\\n\\ \\n\\  EXIT;                                             -- beendet IJ\\n\\  HELP;                 -- zeigt diese Nachricht an\\n\\ \\n\\ Nicht erkannte Befehle werden als potenzielle SQL-J-Befehle angesehen und direkt ausgef\\u00FChrt.\\n\\ \\n\n-IJ_IjErro0=IJ-FEHLER\\: {0}\n+IJ_HelpText=\\ \\n\\ Unter anderem werden folgende Befehle unterst\\u00FCtzt:\\n\\  PROTOCOL ''JDBC-Protokoll'' [ AS Kennung ];\\n\\                               -- definiert ein benanntes oder Standardprotokoll\\n\\  DRIVER ''Treiberklasse'';   -- l\\u00E4dt die benannte Klasse\\n\\ CONNECT ''Datenbank-URL'' [ PROTOCOL benanntesProtokoll ] [ AS Verbindungsname ];\\n\\                               -- stellt Verbindung zum Datenbank-URL her\\n\\                               -- kann eine Kennung zuordnen\\n\\  SET CONNECTION Verbindungsname; -- schaltet auf die angegebene Verbindung um\\n\\  SHOW CONNECTIONS;             -- listet alle Verbindungen auf\\n\\ AUTOCOMMIT [ ON | OFF ];     -- legt das automatische Festschreiben der Verbindung fest\\n\\ DISCONNECT [ CURRENT | Verbindungsname | ALL ];\\n\\                               -- aktuelle, benannte oder alle Verbindungen trennen;\\n\\                                -- Standardeinstellung: CURRENT\\n\\ \\n\\ SHOW SCHEMAS;                -- listet alle Schemata in der aktuellen Datenbank auf\\n\\  SHOW [ TABLES | VIEWS | PROCEDURES | FUNCTIONS | SYNONYMS ] '{' IN Schema '}';\\n\\                               -- listet Tabellen, Ansichten, Prozeduren, Funktionen oder Synonyme auf\\n\\  SHOW INDEXES '{' IN Schema | FROM Tabelle '}';\\n\\                                -- listet Indizes in einem Schema oder f\\u00FCr eine Tabelle auf\\n\\ SHOW ROLES;                   -- listet alle definierten Rollen in der Datenbank auf,\\n\\                               -- sortiert\\n\\  SHOW ENABLED_ROLES;          -- listet die aktivierten Rollen f\\u00FCr die aktuelle\\n\\                               -- Verbindung auf (siehe die Verwendung der aktuellen Rolle\\n\\                               -- VALUES CURRENT_ROLE), sortiert\\n\\  SHOW SETTABLE_ROLES;         -- listet die Rollen auf, die f\\u00FCr\\n\\                               -- die aktuelle Verbindung festgelegt werden k\\u00F6nnen, sortiert\\n\\  DESCRIBE Name;               -- listet die Spalten in der benannten Tabelle auf\\n\\ \\n\\  COMMIT;                      -- schreibt die aktuelle Transaktion fest\\n\\  ROLLBACK;                    -- setzt die aktuelle Transaktion zur\\u00FCck\\n\\ \\n\\  PREPARE Name AS ''SQL-J-Text''; -- bereitet den SQL-J-Text vor\\n\\  EXECUTE '{' Name | ''SQL-J-Text'' '}' [ USING '{' Name | ''SQL-J-Text'' '}' ] ;\\n\\                               -- f\\u00FChrt die Anweisung mit Parameterwerten\\n\\                               -- von der USING-ResultSet-Zeile durch\\n\\  REMOVE Name;                 -- entfernt die benannte zuvor vorbereitete Anweisung\\n\\ \\n\\  RUN ''Dateiname'';              -- f\\u00FChrt Befehle von der benannten Datei aus\\n\\ \\n\\  ELAPSEDTIME [ ON | OFF ];    -- legt den Modus f\\u00FCr abgelaufene Zeit f\\u00FCr ij fest\\n\\  MAXIMUMDISPLAYWIDTH Ganzzahlwert;\\n\\                               -- legt die maximale Anzeigebreite f\\u00FCr\\n\\                               -- jede Spalte auf einen Ganzzahlwert fest\\n\\ \\n\\  ASYNC Name ''SQL-J-Text'';     -- f\\u00FChrt den Befehl in einem anderen Thread aus\\n\\  WAIT FOR Name;               -- warten auf Ergebnis von Befehl f\\u00FCr ASYNC\\n\\ \\n\\  GET [SCROLL INSENSITIVE] [WITH  '{HOLD | NOHOLD}'] CURSOR Name AS ''SQL-J-Abfrage'';\\n\\                               -- ruft einen Cursor (JDBC-ResultSet) f\\u00FCr die Abfrage ab\\n\\                               -- der Standard ist ein Forward-Only-Cursor mit Holdability\\n\\  NEXT Name;                   -- ruft die n\\u00E4chste Zeile aus dem benannten Cursor ab\\n\\  FIRST Name;                  -- ruft die erste Zeile aus dem benannten Scroll-Cursor ab\\n\\  LAST Name;                   -- ruft die letzte Zeile aus dem benannten Scroll-Cursor ab\\n\\  PREVIOUS Name;               -- ruft die vorige Zeile aus dem benannten Scroll-Cursor ab\\n\\  ABSOLUTE Ganzzahlname;       -- positioniert den benannten Scroll-Cursor an der absoluten Zeilenzahl\\n\\                               -- (Eine negative Zahl gibt die Position von der letzten Zeile an.) \\n\\  RELATIVE ganzeZahl Name;        -- platziert den benannten Scroll-Cursor relativ zur aktuellen Zeile\\n\\       -- (ganzeZahl ist die Anzahl der Zeilen)\\n\\  AFTER LAST Name;                -- platziert den benannten Scroll-Cursor hinter der letzten Zeile\\n\\  BEFORE FIRST Name;              -- platziert den benannten Scroll-Cursor vor der ersten Zeile\\n\\  GETCURRENTROWNUMBER Name;       -- gibt f\\u00FCr die aktuelle Position des benannten Scroll-Cursors die Zeilennummer an\\n\\                                  -- (Befindet sich der Cursor nicht in einer Zeile, wird 0 zur\\u00FCckgegeben.) \\n\\  CLOSE Name;                     -- schlie\\u00DFt den benannten Cursor\\n\\  LOCALIZEDDISPLAY [ ON | OFF ];\\n\\  -- steuert die Darstellung von Daten, die von der L\\u00E4ndereinstellung abh\\u00E4ngen\\n\\ \\n\\  EXIT;                                             -- beendet IJ\\n\\  HELP;                 -- zeigt diese Nachricht an\\n\\\\n\\  SPOOL '<DATEI>';                 -- schreibt SQL Befehle und ihre Ergebnisse in <DATEI>\\n\\  SPOOL STOP;                 -- h\\u00F6rt auf, SQL Befehle und ihre Ergebnisse in Datei zu schreiben\\n\\  SPOOL CLEAR;                 -- l\\u00F6scht Daten aus der Datei, in die SQL Befehle und ihre Ergebnisse geschrieben sind\\n\\ \\n\\ Nicht erkannte Befehle werden als potenzielle SQL-J-Befehle angesehen und direkt ausgef\\u00FChrt.\\n\\ \\nIJ_IjErro0=IJ-FEHLER\\: {0}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMwMTk0MQ=="}, "originalCommit": {"oid": "a51d0c11b0d6ffe95de961caf8e936e42384ec06"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3055, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}