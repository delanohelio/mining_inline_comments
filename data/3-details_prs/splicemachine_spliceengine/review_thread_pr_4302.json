{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA0MDY5MTgz", "number": 4302, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOToxODozNlrOEvrjXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwMToxMTozNVrOE16FrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDMyMDkzOnYy", "diffSide": "RIGHT", "path": "splice_machine/src/test/java/com/splicemachine/db/impl/sql/compile/MergeJoinSelectivityIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOToxODozNlrOHkyx8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo1NjozNVrOHyBgSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0Mjc2OA==", "bodyText": "afaik you can just do SpliceUnitTest.rowContainsQuery(levels, query, \"rows=10\",\"MergeJoin\"); which does the try/createStatement for you", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508342768", "createdAt": "2020-10-20T09:18:36Z", "author": {"login": "martinrupp"}, "path": "splice_machine/src/test/java/com/splicemachine/db/impl/sql/compile/MergeJoinSelectivityIT.java", "diffHunk": "@@ -51,6 +51,16 @@ public void innerJoin() throws Exception {\n                     \"explain select * from --splice-properties joinOrder=fixed\\n ts_10_spk, ts_5_spk --splice-properties joinStrategy=MERGE\\n where ts_10_spk.c1 = ts_5_spk.c1\",\n                     \"rows=10\",\"MergeJoin\");\n         }\n+\n+        try(Statement s = methodWatcher.getOrCreateConnection().createStatement()){\n+            rowContainsQuery(s,\n+                    new int[]{1,3},\n+                    \"explain select upper(ts_10_spk.c2), upper(ts_5_spk.c2) from --splice-properties joinOrder=fixed\\n \" +\n+                            \"ts_10_spk --splice-properties index=ts_10_spk_expr_idx\\n, \" +\n+                            \"ts_5_spk --splice-properties index=ts_5_spk_expr_idx, joinStrategy=MERGE\\n \" +\n+                            \"where upper(ts_10_spk.c2) = upper(ts_5_spk.c2)\",\n+                    \"rows=10\",\"MergeJoin\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxNTQ5OQ==", "bodyText": "That's right. Currently, xJoinSelectivityIT tests are derived from BaseJoinSelectivityIT but not from SpliceUnitTest. So we don't have the rowContainsQuery() here. The one we see in these tests are actually a method in BaseJoinSelectivityIT that does the same...\nAll these tests probably should be adapted to derive from SpliceUnitTest. But I guess I'll do this in the very end since they are just tests.", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522215499", "createdAt": "2020-11-12T15:56:35Z", "author": {"login": "ascend1"}, "path": "splice_machine/src/test/java/com/splicemachine/db/impl/sql/compile/MergeJoinSelectivityIT.java", "diffHunk": "@@ -51,6 +51,16 @@ public void innerJoin() throws Exception {\n                     \"explain select * from --splice-properties joinOrder=fixed\\n ts_10_spk, ts_5_spk --splice-properties joinStrategy=MERGE\\n where ts_10_spk.c1 = ts_5_spk.c1\",\n                     \"rows=10\",\"MergeJoin\");\n         }\n+\n+        try(Statement s = methodWatcher.getOrCreateConnection().createStatement()){\n+            rowContainsQuery(s,\n+                    new int[]{1,3},\n+                    \"explain select upper(ts_10_spk.c2), upper(ts_5_spk.c2) from --splice-properties joinOrder=fixed\\n \" +\n+                            \"ts_10_spk --splice-properties index=ts_10_spk_expr_idx\\n, \" +\n+                            \"ts_5_spk --splice-properties index=ts_5_spk_expr_idx, joinStrategy=MERGE\\n \" +\n+                            \"where upper(ts_10_spk.c2) = upper(ts_5_spk.c2)\",\n+                    \"rows=10\",\"MergeJoin\");\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0Mjc2OA=="}, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDMzNTg0OnYy", "diffSide": "RIGHT", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOToyMjowOVrOHky7Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMToyNjoyMVrOHyV9tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0NTE2Mg==", "bodyText": "i would do a slightly reordering here:\nif (outerColumnInfo == null) continuel\n\nint outerTableNum = outerColumnInfo.getFirst();\nint outerColNum = outerColumnInfo.getSecond();\n\nthat way, there's no doubt outerTableNum and outerColNum are initialized.", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508345162", "createdAt": "2020-10-20T09:22:09Z", "author": {"login": "martinrupp"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java", "diffHunk": "@@ -277,29 +283,37 @@ private boolean mergeable(RowOrdering outerRowOrdering,\n                         \"Programmer error: RelationalOperator of type \"+ relop.getClass()+\" detected\";\n                 BinaryRelationalOperatorNode bron = (BinaryRelationalOperatorNode)relop;\n                 if (bron.getOperator() == RelationalOperator.EQUALS_RELOP) {\n-                    ColumnReference innerColumn = relop.getColumnOperand(innerTable);\n-                    ColumnReference outerColumn = getOuterColumn(bron, innerColumn);\n-                    if (innerColumn == null || outerColumn == null) continue;\n-                    int innerColumnNumber = innerColumn.getColumnNumber();\n+                    ColumnReference innerColumn = null;\n+                    int innerColumnNumber;\n+                    int outerTableNum;\n+                    int outerColNum;\n+\n+                    if (isIndexOnExpr) {\n+                        innerColumnNumber = pred.hasEqualOnIndexExpression(innerTable);\n+                    } else {\n+                        innerColumn = relop.getColumnOperand(innerTable);\n+                        if (innerColumn == null) {\n+                            continue;\n+                        }\n+                        innerColumnNumber = innerColumn.getColumnNumber();\n+                    }\n+\n+                    Pair<Integer, Integer> outerColumnInfo = getOuterColumnInfo(bron, innerTable, innerColumn);\n+                    if (outerColumnInfo != null) {\n+                        outerTableNum = outerColumnInfo.getFirst();\n+                        outerColNum = outerColumnInfo.getSecond();\n+                    } else {\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1MDcxMA==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522550710", "createdAt": "2020-11-13T01:26:21Z", "author": {"login": "ascend1"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java", "diffHunk": "@@ -277,29 +283,37 @@ private boolean mergeable(RowOrdering outerRowOrdering,\n                         \"Programmer error: RelationalOperator of type \"+ relop.getClass()+\" detected\";\n                 BinaryRelationalOperatorNode bron = (BinaryRelationalOperatorNode)relop;\n                 if (bron.getOperator() == RelationalOperator.EQUALS_RELOP) {\n-                    ColumnReference innerColumn = relop.getColumnOperand(innerTable);\n-                    ColumnReference outerColumn = getOuterColumn(bron, innerColumn);\n-                    if (innerColumn == null || outerColumn == null) continue;\n-                    int innerColumnNumber = innerColumn.getColumnNumber();\n+                    ColumnReference innerColumn = null;\n+                    int innerColumnNumber;\n+                    int outerTableNum;\n+                    int outerColNum;\n+\n+                    if (isIndexOnExpr) {\n+                        innerColumnNumber = pred.hasEqualOnIndexExpression(innerTable);\n+                    } else {\n+                        innerColumn = relop.getColumnOperand(innerTable);\n+                        if (innerColumn == null) {\n+                            continue;\n+                        }\n+                        innerColumnNumber = innerColumn.getColumnNumber();\n+                    }\n+\n+                    Pair<Integer, Integer> outerColumnInfo = getOuterColumnInfo(bron, innerTable, innerColumn);\n+                    if (outerColumnInfo != null) {\n+                        outerTableNum = outerColumnInfo.getFirst();\n+                        outerColNum = outerColumnInfo.getSecond();\n+                    } else {\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0NTE2Mg=="}, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDM0MjY0OnYy", "diffSide": "RIGHT", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOToyMzo0NFrOHky_jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMToyNTowN1rOHyV8Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0NjI1NQ==", "bodyText": "reorder\nif (outerColumnInfo == null) continue;\nint outerTableNum = outerColumnInfo.getFirst();\nint outerColNum = outerColumnInfo.getSecond();\n\n(now clear everything is initialized)", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508346255", "createdAt": "2020-10-20T09:23:44Z", "author": {"login": "martinrupp"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java", "diffHunk": "@@ -218,33 +219,38 @@ private boolean mergeable(RowOrdering outerRowOrdering,\n                                 IndexRowGenerator innerRowGenerator,\n                                 OptimizablePredicateList predList,\n                                 Optimizable innerTable) throws StandardException{\n-        int[] keyColumnPositionMap = innerRowGenerator.baseColumnPositions();\n+        boolean isIndexOnExpr = innerRowGenerator.isOnExpression();\n+        int[] keyColumnPositionMap = isIndexOnExpr ? null : innerRowGenerator.baseColumnPositions();\n         boolean[] keyAscending = innerRowGenerator.isAscending();\n \n-        BitSet innerColumns = new BitSet(keyColumnPositionMap.length);\n-        BitSet outerColumns = new BitSet(keyColumnPositionMap.length);\n+        BitSet innerColumns = new BitSet(keyAscending.length);\n+        BitSet outerColumns = new BitSet(keyAscending.length);\n         for(int p = 0;p<predList.size();p++){\n             Predicate pred = (Predicate)predList.getOptPredicate(p);\n             if(pred.isJoinPredicate()) continue; //we'll deal with these later\n             RelationalOperator relop=pred.getRelop();\n             if(!(relop instanceof BinaryRelationalOperatorNode)) continue;\n             if(relop.getOperator()==RelationalOperator.EQUALS_RELOP) {\n-                int innerEquals = pred.hasEqualOnColumnList(keyColumnPositionMap, innerTable);\n-                if (innerEquals >= 0) innerColumns.set(innerEquals);\n-                else {\n-\n+                int innerEquals = isIndexOnExpr ? pred.hasEqualOnIndexExpression(innerTable)\n+                                                : pred.hasEqualOnColumnList(keyColumnPositionMap, innerTable);\n+                if (innerEquals >= 0) {\n+                    innerColumns.set(innerEquals);\n+                } else {\n                     BinaryRelationalOperatorNode bron = (BinaryRelationalOperatorNode) relop;\n-                    ValueNode vn = bron.getLeftOperand();\n-                    if (!(vn instanceof ColumnReference))\n-                        vn = bron.getRightOperand();\n-                    if (!(vn instanceof ColumnReference)) continue;\n-                    ColumnReference outerColumn = (ColumnReference) vn;\n+                    int outerTableNum;\n+                    int outerColNum;\n+\n                     /*\n                      * We are still sortable if we have constant predicates on the first N keys on the outer\n                      * side of the join, as long as we match the inner columns\n                      */\n-                    int outerTableNum = outerColumn.getTableNumber();\n-                    int outerColNum = outerColumn.getColumnNumber();\n+                    Pair<Integer, Integer> outerColumnInfo = getOuterColumnInfo(bron, innerTable, null);\n+                    if (outerColumnInfo != null) {\n+                        outerTableNum = outerColumnInfo.getFirst();\n+                        outerColNum = outerColumnInfo.getSecond();\n+                    } else {\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1MDMzOQ==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522550339", "createdAt": "2020-11-13T01:25:07Z", "author": {"login": "ascend1"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java", "diffHunk": "@@ -218,33 +219,38 @@ private boolean mergeable(RowOrdering outerRowOrdering,\n                                 IndexRowGenerator innerRowGenerator,\n                                 OptimizablePredicateList predList,\n                                 Optimizable innerTable) throws StandardException{\n-        int[] keyColumnPositionMap = innerRowGenerator.baseColumnPositions();\n+        boolean isIndexOnExpr = innerRowGenerator.isOnExpression();\n+        int[] keyColumnPositionMap = isIndexOnExpr ? null : innerRowGenerator.baseColumnPositions();\n         boolean[] keyAscending = innerRowGenerator.isAscending();\n \n-        BitSet innerColumns = new BitSet(keyColumnPositionMap.length);\n-        BitSet outerColumns = new BitSet(keyColumnPositionMap.length);\n+        BitSet innerColumns = new BitSet(keyAscending.length);\n+        BitSet outerColumns = new BitSet(keyAscending.length);\n         for(int p = 0;p<predList.size();p++){\n             Predicate pred = (Predicate)predList.getOptPredicate(p);\n             if(pred.isJoinPredicate()) continue; //we'll deal with these later\n             RelationalOperator relop=pred.getRelop();\n             if(!(relop instanceof BinaryRelationalOperatorNode)) continue;\n             if(relop.getOperator()==RelationalOperator.EQUALS_RELOP) {\n-                int innerEquals = pred.hasEqualOnColumnList(keyColumnPositionMap, innerTable);\n-                if (innerEquals >= 0) innerColumns.set(innerEquals);\n-                else {\n-\n+                int innerEquals = isIndexOnExpr ? pred.hasEqualOnIndexExpression(innerTable)\n+                                                : pred.hasEqualOnColumnList(keyColumnPositionMap, innerTable);\n+                if (innerEquals >= 0) {\n+                    innerColumns.set(innerEquals);\n+                } else {\n                     BinaryRelationalOperatorNode bron = (BinaryRelationalOperatorNode) relop;\n-                    ValueNode vn = bron.getLeftOperand();\n-                    if (!(vn instanceof ColumnReference))\n-                        vn = bron.getRightOperand();\n-                    if (!(vn instanceof ColumnReference)) continue;\n-                    ColumnReference outerColumn = (ColumnReference) vn;\n+                    int outerTableNum;\n+                    int outerColNum;\n+\n                     /*\n                      * We are still sortable if we have constant predicates on the first N keys on the outer\n                      * side of the join, as long as we match the inner columns\n                      */\n-                    int outerTableNum = outerColumn.getTableNumber();\n-                    int outerColNum = outerColumn.getColumnNumber();\n+                    Pair<Integer, Integer> outerColumnInfo = getOuterColumnInfo(bron, innerTable, null);\n+                    if (outerColumnInfo != null) {\n+                        outerTableNum = outerColumnInfo.getFirst();\n+                        outerColNum = outerColumnInfo.getSecond();\n+                    } else {\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0NjI1NQ=="}, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDM1MDkyOnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryOperatorNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOToyNTozNVrOHkzEkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMToyNzoyN1rOHyV-_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0NzUzNg==", "bodyText": "(nitpic) 0.0f is float, you mean 0.0 (double)", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508347536", "createdAt": "2020-10-20T09:25:35Z", "author": {"login": "martinrupp"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryOperatorNode.java", "diffHunk": "@@ -915,4 +915,10 @@ public boolean isConstantOrParameterTreeNode() {\n         // for count(*), operand is null\n         return operand != null && operand.isConstantOrParameterTreeNode();\n     }\n+\n+    public double getBaseOperationCost() throws StandardException { return getOperandCost(); }\n+\n+    protected double getOperandCost() throws StandardException {\n+        return operand == null ? 0.0f : operand.getBaseOperationCost();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1MTAzNg==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522551036", "createdAt": "2020-11-13T01:27:27Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryOperatorNode.java", "diffHunk": "@@ -915,4 +915,10 @@ public boolean isConstantOrParameterTreeNode() {\n         // for count(*), operand is null\n         return operand != null && operand.isConstantOrParameterTreeNode();\n     }\n+\n+    public double getBaseOperationCost() throws StandardException { return getOperandCost(); }\n+\n+    protected double getOperandCost() throws StandardException {\n+        return operand == null ? 0.0f : operand.getBaseOperationCost();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0NzUzNg=="}, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDM1NjQ0OnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryDateTimestampOperatorNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOToyNjo1MlrOHkzH8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMTozNzowOFrOHyWKkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0ODQwMg==", "bodyText": "you have consts for everything but not for 1.0 and 2.0, and i'm not sure what they represent. Why is the cost twice if there's an operand?", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508348402", "createdAt": "2020-10-20T09:26:52Z", "author": {"login": "martinrupp"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryDateTimestampOperatorNode.java", "diffHunk": "@@ -181,4 +183,12 @@ public void generateExpression(ExpressionClassBuilder acb,\n         mb.cast(ClassName.DataValueDescriptor);\n         mb.callMethod(VMOpcode.INVOKEINTERFACE,(String)null,methodName,getTypeCompiler().interfaceName(),1);\n     } // end of generateExpression\n+\n+    @Override\n+    public double getBaseOperationCost() throws StandardException {\n+        double lowerCost = getOperandCost();\n+        double localCost = SIMPLE_OP_COST * (operand == null ? 1.0 : 2.0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1NDAwMw==", "bodyText": "It just indicates that if the function has an operand, probably it executes more instructions to finish. I didn't look into the code of date and timestamp. But the costing is also like a heuristic. No need to make the cost absolutely accurate because in the end, it's about comparing options, always relative.", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522554003", "createdAt": "2020-11-13T01:37:08Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryDateTimestampOperatorNode.java", "diffHunk": "@@ -181,4 +183,12 @@ public void generateExpression(ExpressionClassBuilder acb,\n         mb.cast(ClassName.DataValueDescriptor);\n         mb.callMethod(VMOpcode.INVOKEINTERFACE,(String)null,methodName,getTypeCompiler().interfaceName(),1);\n     } // end of generateExpression\n+\n+    @Override\n+    public double getBaseOperationCost() throws StandardException {\n+        double lowerCost = getOperandCost();\n+        double localCost = SIMPLE_OP_COST * (operand == null ? 1.0 : 2.0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0ODQwMg=="}, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDM1ODQ4OnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/TimestampOperatorNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOToyNzoxOFrOHkzJNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMTozOTo0MVrOHyWNiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0ODcyNA==", "bodyText": "why 2", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508348724", "createdAt": "2020-10-20T09:27:18Z", "author": {"login": "martinrupp"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/TimestampOperatorNode.java", "diffHunk": "@@ -162,4 +162,10 @@ public ValueNode getClone() throws StandardException {\n         return newTS;\n     }\n \n+\t@Override\n+\tpublic double getBaseOperationCost() throws StandardException {\n+\t\tdouble localCost = SIMPLE_OP_COST * 2.0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1NDc2MA==", "bodyText": "Similar to the other place, no particular reason for having 2.0, but just to indicate that it should be at least more expensive than a simple addition, which has cost of SIMPLE_OP_COST. The operator may be much more expensive than two addition, but I'm worried that expression evaluation cost accumulates fast, don't want this part to dominate the cost. This could be a future work.", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522554760", "createdAt": "2020-11-13T01:39:41Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/TimestampOperatorNode.java", "diffHunk": "@@ -162,4 +162,10 @@ public ValueNode getClone() throws StandardException {\n         return newTS;\n     }\n \n+\t@Override\n+\tpublic double getBaseOperationCost() throws StandardException {\n+\t\tdouble localCost = SIMPLE_OP_COST * 2.0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0ODcyNA=="}, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQ4NjE2OnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/store/access/StoreCostController.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1Nzo0N1rOHk0YVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMToxMjo1M1rOHyqXEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2ODk4MA==", "bodyText": "I wonder if rather than sprinkling boolean forExprIndex in many methods, would it make sense to have a StoreCostController implementation for index expressions? It could extend our current StoreCostControllerImpl and override only the desired methods. It might even be enough to modify the initialization.\nThis is just a suggestion, not sure if it would actually simplify things.", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508368980", "createdAt": "2020-10-20T09:57:47Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/iapi/store/access/StoreCostController.java", "diffHunk": "@@ -120,9 +123,10 @@\n      * @throws StandardException Standard exception policy.\n      * @see RowUtil\n      */\n-    void getFetchFromFullKeyCost(BitSet validColumns,\n+    void getFetchFromFullKeyCost(boolean forExprIndex,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg4NDg4Mg==", "bodyText": "That's a good idea. I did it in the current way because when an index on expressions is not covering, we need both base table statistics and index on expressions statistics at the same time. That's why we have them together in StoreCostController and have this flag in methods. It's a quick step.\nIdeally we should be able to have multiple StoreCostControllers representing statistics on different conglomerates. A bit more refactoring is needed to achieve it, though. I think when we want to improve index statistics handling, this is a necessary prior step.", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522884882", "createdAt": "2020-11-13T11:12:53Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/iapi/store/access/StoreCostController.java", "diffHunk": "@@ -120,9 +123,10 @@\n      * @throws StandardException Standard exception policy.\n      * @see RowUtil\n      */\n-    void getFetchFromFullKeyCost(BitSet validColumns,\n+    void getFetchFromFullKeyCost(boolean forExprIndex,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2ODk4MA=="}, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDU3MDgyOnYy", "diffSide": "RIGHT", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/HalfMergeSortJoinStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMDoxOTozOFrOHk1Nng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMTo0NjoyNFrOHyWVWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM4MjYyMg==", "bodyText": "This class is not used, it can be removed", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508382622", "createdAt": "2020-10-20T10:19:38Z", "author": {"login": "dgomezferro"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/HalfMergeSortJoinStrategy.java", "diffHunk": "@@ -144,29 +144,39 @@ public int maxCapacity(int userSpecifiedCapacity, int maxMemoryPerTable, double\n     private boolean mergeable(IndexRowGenerator innerRowGenerator,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1Njc2Mg==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522556762", "createdAt": "2020-11-13T01:46:24Z", "author": {"login": "ascend1"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/HalfMergeSortJoinStrategy.java", "diffHunk": "@@ -144,29 +144,39 @@ public int maxCapacity(int userSpecifiedCapacity, int maxMemoryPerTable, double\n     private boolean mergeable(IndexRowGenerator innerRowGenerator,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM4MjYyMg=="}, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDU3Mjg4OnYy", "diffSide": "RIGHT", "path": "hbase_sql/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/HalfMergeSortSparkIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMDoyMDoxMFrOHk1O-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMTo0NjozM1rOHyWViQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM4Mjk3MA==", "bodyText": "This test is ignored, and the class is unused, it can be removed.", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508382970", "createdAt": "2020-10-20T10:20:10Z", "author": {"login": "dgomezferro"}, "path": "hbase_sql/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/HalfMergeSortSparkIT.java", "diffHunk": "@@ -156,6 +151,7 @@ public void testHalfSortMergeAfterSplit() throws Throwable {\n             \"(c1 int, c2 int, c3 int, c4 int)\");\n \n     protected static SpliceIndexWatcher aIndex = new SpliceIndexWatcher(A, CLASS_NAME, A_IDX,CLASS_NAME,\"(c1 desc, c2 asc, c3 desc)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1NjgwOQ==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522556809", "createdAt": "2020-11-13T01:46:33Z", "author": {"login": "ascend1"}, "path": "hbase_sql/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/HalfMergeSortSparkIT.java", "diffHunk": "@@ -156,6 +151,7 @@ public void testHalfSortMergeAfterSplit() throws Throwable {\n             \"(c1 int, c2 int, c3 int, c4 int)\");\n \n     protected static SpliceIndexWatcher aIndex = new SpliceIndexWatcher(A, CLASS_NAME, A_IDX,CLASS_NAME,\"(c1 desc, c2 asc, c3 desc)\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM4Mjk3MA=="}, "originalCommit": {"oid": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0OTYxNzA4OnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/DB2LengthOperatorNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwMToxMTozNVrOHucmaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMTo1NTo1OFrOHyWgTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2NTEyOA==", "bodyText": "Is the cost really multiplied by the length of the data type?  What if you have a really long string, is it really that expensive?", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r518465128", "createdAt": "2020-11-06T01:11:35Z", "author": {"login": "msirek"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/DB2LengthOperatorNode.java", "diffHunk": "@@ -194,5 +194,17 @@ private int getConstantNodeLength() throws StandardException\n         if( operand instanceof ConstantNode)\n             return ((ConstantNode) operand).getValue().getLength();\n         return -1;\n-    }        \n+    }\n+\n+    @Override\n+    public double getBaseOperationCost() throws StandardException {\n+        double cost = 0.0;\n+        if (operand != null) {\n+            if (getConstantLength() == -1) {\n+                cost += SIMPLE_OP_COST * operand.getTypeServices().getNull().getLength();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d802991e5d2ccb715d30a82d9c72f0eee5766ca7"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1OTU2Ng==", "bodyText": "I have the same concern here actually...I took a look at SQLChar.getLength() and it seems to have chance to calculate it in O(n). But then the expression evaluation cost could accumulate fast, soon dominating the plan cost. In the latest commit, I add an upper bound on this, hopefully better than linear.", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522559566", "createdAt": "2020-11-13T01:55:58Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/DB2LengthOperatorNode.java", "diffHunk": "@@ -194,5 +194,17 @@ private int getConstantNodeLength() throws StandardException\n         if( operand instanceof ConstantNode)\n             return ((ConstantNode) operand).getValue().getLength();\n         return -1;\n-    }        \n+    }\n+\n+    @Override\n+    public double getBaseOperationCost() throws StandardException {\n+        double cost = 0.0;\n+        if (operand != null) {\n+            if (getConstantLength() == -1) {\n+                cost += SIMPLE_OP_COST * operand.getTypeServices().getNull().getLength();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2NTEyOA=="}, "originalCommit": {"oid": "d802991e5d2ccb715d30a82d9c72f0eee5766ca7"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2881, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}