{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI2NjkyMjk5", "number": 4689, "title": "DB-10774 Wrap SetOp subquery in a derived table so it can be flattened.", "bodyText": "This wraps a UNION/INTERSECT/EXCEPT subquery in a derived table so that it can be flattened and participate in join planning, e.g.\n\nexplain\nselect a1,a2 from A\nWHERE -a1 in (select -a1 from A\nWHERE -a1 in (\nSELECT b1*2 FROM B\nUNION ALL\nSELECT -b1 FROM B\nEXCEPT\nSELECT b1 FROM B where b1 in (10,20,30,40,50)\nINTERSECT\nSELECT b1 FROM B ));\nCursor(n=29,rows=23,updateMode=READ_ONLY (1),engine=OLTP (default))\n->  ScrollInsensitive(n=29,totalCost=57.712,outputRows=23,outputHeapSize=69 B,partitions=1,parallelTasks=1)\n->  ProjectRestrict(n=28,totalCost=49.312,outputRows=23,outputHeapSize=69 B,partitions=1,parallelTasks=1)\n->  ProjectRestrict(n=27,totalCost=49.312,outputRows=23,outputHeapSize=69 B,partitions=1,parallelTasks=1)\n->  BroadcastJoin(n=26,totalCost=49.312,outputRows=23,outputHeapSize=69 B,partitions=1,parallelTasks=1,preds=[(A1[26:3] = SQLCol1[26:4])])\n->  ProjectRestrict(n=24,totalCost=37.009,outputRows=29,outputHeapSize=28 B,partitions=1,parallelTasks=1)\n->  ProjectRestrict(n=23,totalCost=37.009,outputRows=29,outputHeapSize=28 B,partitions=1,parallelTasks=1)\n->  BroadcastJoin(n=22,totalCost=37.009,outputRows=29,outputHeapSize=28 B,partitions=1,parallelTasks=1,preds=[(A1[22:2] = ###UnnamedDT_WrappedSetOpCol0[22:3])])\n->  Except(n=18,totalCost=32.94,outputRows=36,outputHeapSize=0 B,partitions=1,parallelTasks=1)\n->  Intersect(n=17,totalCost=16.46,outputRows=9,outputHeapSize=0 B,partitions=1,parallelTasks=1)\n->  TableScan[B(1696)](n=14,totalCost=4.04,scannedRows=20,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1)\n->  ProjectRestrict(n=12,totalCost=4.04,outputRows=18,outputHeapSize=18 B,partitions=1,parallelTasks=1,preds=[(B1[11:1] IN (10,20,30,40,50))])\n->  TableScan[B(1696)](n=11,totalCost=4.04,scannedRows=20,outputRows=20,outputHeapSize=18 B,partitions=1,parallelTasks=1)\n->  Union(n=10,totalCost=8.08,outputRows=40,outputHeapSize=40 B,partitions=2,parallelTasks=1)\n->  ProjectRestrict(n=9,totalCost=4.04,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1)\n->  TableScan[B(1696)](n=7,totalCost=4.04,scannedRows=20,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1)\n->  ProjectRestrict(n=6,totalCost=4.04,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1)\n->  TableScan[B(1696)](n=4,totalCost=4.04,scannedRows=20,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1)\n->  ProjectRestrict(n=3,totalCost=4.04,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1)\n->  TableScan[A(1680)](n=2,totalCost=4.04,scannedRows=20,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1)\n->  ProjectRestrict(n=1,totalCost=4.04,outputRows=20,outputHeapSize=40 B,partitions=1,parallelTasks=1)\n->  TableScan[A(1680)](n=0,totalCost=4.04,scannedRows=20,outputRows=20,outputHeapSize=40 B,partitions=1,parallelTasks=1)\n\nExplain without the fix:\n\nCursor(n=24,rows=20,updateMode=READ_ONLY (1),engine=OLTP (default))\n->  ScrollInsensitive(n=24,totalCost=8.24,outputRows=20,outputHeapSize=40 B,partitions=1,parallelTasks=1)\n->  ProjectRestrict(n=23,totalCost=4.04,outputRows=20,outputHeapSize=40 B,partitions=1,parallelTasks=1,preds=[is not null(subq=22)])\n->  Subquery(n=22,totalCost=8.24,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1,correlated=true,expression=false,invariant=true)\n->  ProjectRestrict(n=22,totalCost=4.04,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1,preds=[(-(A1[1:1]) = SQLCol1[21:1])])\n->  ProjectRestrict(n=21,totalCost=4.04,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1,preds=[is not null(subq=20)])\n->  Subquery(n=20,totalCost=32.94,outputRows=36,outputHeapSize=0 B,partitions=1,parallelTasks=1,correlated=false,expression=false,invariant=true)\n->  ProjectRestrict(n=20,totalCost=32.94,outputRows=36,outputHeapSize=0 B,partitions=1,parallelTasks=1,preds=[(-(A1[3:1]) = SQLCol2[19:1])])\n->  Except(n=18,totalCost=32.94,outputRows=36,outputHeapSize=0 B,partitions=1,parallelTasks=1)\n->  Intersect(n=17,totalCost=16.46,outputRows=9,outputHeapSize=0 B,partitions=1,parallelTasks=1)\n->  TableScan[B(1696)](n=14,totalCost=4.04,scannedRows=20,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1)\n->  ProjectRestrict(n=12,totalCost=4.04,outputRows=18,outputHeapSize=18 B,partitions=1,parallelTasks=1,preds=[(B1[11:1] IN (10,20,30,40,50))])\n->  TableScan[B(1696)](n=11,totalCost=4.04,scannedRows=20,outputRows=20,outputHeapSize=18 B,partitions=1,parallelTasks=1)\n->  Union(n=10,totalCost=12.28,outputRows=40,outputHeapSize=20 B,partitions=1,parallelTasks=1)\n->  ProjectRestrict(n=9,totalCost=4.04,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1)\n->  TableScan[B(1696)](n=7,totalCost=4.04,scannedRows=20,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1)\n->  ProjectRestrict(n=6,totalCost=4.04,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1)\n->  TableScan[B(1696)](n=4,totalCost=4.04,scannedRows=20,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1)\n->  ProjectRestrict(n=3,totalCost=4.04,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1)\n->  TableScan[A(1680)](n=2,totalCost=4.04,scannedRows=20,outputRows=20,outputHeapSize=20 B,partitions=1,parallelTasks=1)\n->  ProjectRestrict(n=1,totalCost=4.04,outputRows=20,outputHeapSize=40 B,partitions=1,parallelTasks=1)\n->  TableScan[A(1680)](n=0,totalCost=4.04,scannedRows=20,outputRows=20,outputHeapSize=40 B,partitions=1,parallelTasks=1)", "createdAt": "2020-11-24T19:01:17Z", "url": "https://github.com/splicemachine/spliceengine/pull/4689", "merged": true, "mergeCommit": {"oid": "c37fdc398482520805c612f84c1f3092d8ee0ac6"}, "closed": true, "closedAt": "2020-11-25T10:02:04Z", "author": {"login": "msirek"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdfu3LBgH2gAyNTI2NjkyMjk5OmU1MjBmZjNjMDkwYTg1OWMxZjQwYzk1MmM2MzRmNGI2NDc2NjgxZDk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdf2ImIgFqTUzODEzODAxOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e520ff3c090a859c1f40c952c634f4b6476681d9", "author": {"user": {"login": "msirek", "name": "Mark Sirek"}}, "url": "https://github.com/splicemachine/spliceengine/commit/e520ff3c090a859c1f40c952c634f4b6476681d9", "committedDate": "2020-11-24T19:24:47Z", "message": "DB-10774 Wrap SetOp subquery in a derived table so it can be flattened."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2bfbc06d1de185f44e1f3ad8d8b353b5fbd51f5f", "author": {"user": {"login": "msirek", "name": "Mark Sirek"}}, "url": "https://github.com/splicemachine/spliceengine/commit/2bfbc06d1de185f44e1f3ad8d8b353b5fbd51f5f", "committedDate": "2020-11-24T18:57:38Z", "message": "DB-10774 Wrap SetOp subquery in a derived table so it can be flattened."}, "afterCommit": {"oid": "e520ff3c090a859c1f40c952c634f4b6476681d9", "author": {"user": {"login": "msirek", "name": "Mark Sirek"}}, "url": "https://github.com/splicemachine/spliceengine/commit/e520ff3c090a859c1f40c952c634f4b6476681d9", "committedDate": "2020-11-24T19:24:47Z", "message": "DB-10774 Wrap SetOp subquery in a derived table so it can be flattened."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4MDEzMzk4", "url": "https://github.com/splicemachine/spliceengine/pull/4689#pullrequestreview-538013398", "createdAt": "2020-11-24T22:18:44Z", "commit": {"oid": "e520ff3c090a859c1f40c952c634f4b6476681d9"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjoxODo0NFrOH5YdtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjoxODo0NFrOH5YdtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkzMTcwMQ==", "bodyText": "Not used", "url": "https://github.com/splicemachine/spliceengine/pull/4689#discussion_r529931701", "createdAt": "2020-11-24T22:18:44Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SubqueryNode.java", "diffHunk": "@@ -403,6 +406,107 @@ public ValueNode remapColumnReferencesToExpressions() throws StandardException{\n         return this;\n     }\n \n+    private void updateColumnNamesInSetQuery(SetOperatorNode setOperatorNode,\n+                                             String columnName,\n+                                             int columnPosition)   throws StandardException {\n+        ResultColumn rc;\n+        boolean replacementDone = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e520ff3c090a859c1f40c952c634f4b6476681d9"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4MDEwMDEy", "url": "https://github.com/splicemachine/spliceengine/pull/4689#pullrequestreview-538010012", "createdAt": "2020-11-24T22:12:35Z", "commit": {"oid": "e520ff3c090a859c1f40c952c634f4b6476681d9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjoxMjozNVrOH5YFAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzozMjowN1rOH5dBdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkyNTM3Nw==", "bodyText": "subqueryType cannot be NOT_EXISTS_SUBQUERY at this point, so we can safely remove this condition. subqueryType is modified later when eliminateNots is called in preprocssing the predicate containing this subquery.", "url": "https://github.com/splicemachine/spliceengine/pull/4689#discussion_r529925377", "createdAt": "2020-11-24T22:12:35Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SubqueryNode.java", "diffHunk": "@@ -425,6 +529,16 @@ public ValueNode bindExpression(FromList fromList,\n         //check if subquery is allowed in expression tree\n         checkReliability(CompilerContext.SUBQUERY_ILLEGAL,SQLState.LANG_SUBQUERY);\n \n+        // Rewrite a set operator tree so it's wrapped in a derived table.\n+        // This allows it to be flattenable, allowing for more efficient joins.\n+        // Disallow multicolumn IN/NOT IN for now to be safe.\n+        if (resultSet instanceof SetOperatorNode &&\n+            this.subqueryType != SubqueryNode.FROM_SUBQUERY &&\n+            (resultSet.getResultColumns().size() == 1 ||\n+             this.subqueryType == EXISTS_SUBQUERY     ||\n+             this.subqueryType == NOT_EXISTS_SUBQUERY ))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e520ff3c090a859c1f40c952c634f4b6476681d9"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk1OTA2OQ==", "bodyText": "These two seem to be always nulls. Should we just pass in null, null or I missed something here?", "url": "https://github.com/splicemachine/spliceengine/pull/4689#discussion_r529959069", "createdAt": "2020-11-24T22:44:18Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SubqueryNode.java", "diffHunk": "@@ -403,6 +406,107 @@ public ValueNode remapColumnReferencesToExpressions() throws StandardException{\n         return this;\n     }\n \n+    private void updateColumnNamesInSetQuery(SetOperatorNode setOperatorNode,\n+                                             String columnName,\n+                                             int columnPosition)   throws StandardException {\n+        ResultColumn rc;\n+        boolean replacementDone = false;\n+        if (setOperatorNode.getLeftResultSet() instanceof SetOperatorNode) {\n+            updateColumnNamesInSetQuery((SetOperatorNode)setOperatorNode.getLeftResultSet(), columnName, columnPosition);\n+\n+        }\n+        else {\n+            rc = setOperatorNode.getLeftResultSet().getResultColumns().elementAt(columnPosition);\n+            rc.setName(columnName);\n+        }\n+        if (setOperatorNode.getRightResultSet() instanceof SetOperatorNode)\n+            updateColumnNamesInSetQuery((SetOperatorNode)setOperatorNode.getRightResultSet(), columnName, columnPosition);\n+        else {\n+            rc = setOperatorNode.getRightResultSet().getResultColumns().elementAt(columnPosition);\n+            rc.setName(columnName);\n+        }\n+        rc = setOperatorNode.getResultColumns().elementAt(columnPosition);;\n+        rc.setName(columnName);\n+        ColumnReference columnReference = (ColumnReference) getNodeFactory().getNode(\n+            C_NodeTypes.COLUMN_REFERENCE,\n+            columnName,\n+            null,\n+            getContextManager());\n+        rc.setExpression(columnReference);\n+    }\n+\n+    // Subquery flattening logic only knows how to flatten a SelectNode\n+    // in a subquery.  Everything else must be evaluated one row-at-a-time.\n+    // Let's get around the restriction by wrapping SetOp queries\n+    // (UNION, EXCEPT, INTERSECT) in a derived table, which itself\n+    // is represented as a SelectNode.\n+    // TODO:  Enhance subquery flattening logic to not require the\n+    //        the subquery expression to be a SelectNode.\n+    private void wrapSetQueryInDerivedTable() throws StandardException {\n+        if (!(resultSet instanceof SetOperatorNode))\n+            return;\n+        SetOperatorNode setOperatorNode = (SetOperatorNode)resultSet;\n+        ValueNode[] offsetClauses = new ValueNode[ OFFSET_CLAUSE_COUNT ];\n+        SubqueryNode derivedTable = (SubqueryNode) getNodeFactory().getNode(\n+                                        C_NodeTypes.SUBQUERY_NODE,\n+                                        resultSet,  // SetOperatorNode\n+                                        ReuseFactory.getInteger(SubqueryNode.FROM_SUBQUERY),\n+                                        null, // leftOperand,\n+                                        null, // orderCols,\n+                                        offsetClauses[ OFFSET_CLAUSE ],\n+                                        offsetClauses[ FETCH_FIRST_CLAUSE ],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e520ff3c090a859c1f40c952c634f4b6476681d9"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2MTgzNg==", "bodyText": "This flag is not used anywhere. Remove?", "url": "https://github.com/splicemachine/spliceengine/pull/4689#discussion_r529961836", "createdAt": "2020-11-24T22:46:59Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SubqueryNode.java", "diffHunk": "@@ -403,6 +406,107 @@ public ValueNode remapColumnReferencesToExpressions() throws StandardException{\n         return this;\n     }\n \n+    private void updateColumnNamesInSetQuery(SetOperatorNode setOperatorNode,\n+                                             String columnName,\n+                                             int columnPosition)   throws StandardException {\n+        ResultColumn rc;\n+        boolean replacementDone = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e520ff3c090a859c1f40c952c634f4b6476681d9"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2Mzk3MA==", "bodyText": "dummy semicolon at the end of line", "url": "https://github.com/splicemachine/spliceengine/pull/4689#discussion_r529963970", "createdAt": "2020-11-24T22:49:07Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SubqueryNode.java", "diffHunk": "@@ -403,6 +406,107 @@ public ValueNode remapColumnReferencesToExpressions() throws StandardException{\n         return this;\n     }\n \n+    private void updateColumnNamesInSetQuery(SetOperatorNode setOperatorNode,\n+                                             String columnName,\n+                                             int columnPosition)   throws StandardException {\n+        ResultColumn rc;\n+        boolean replacementDone = false;\n+        if (setOperatorNode.getLeftResultSet() instanceof SetOperatorNode) {\n+            updateColumnNamesInSetQuery((SetOperatorNode)setOperatorNode.getLeftResultSet(), columnName, columnPosition);\n+\n+        }\n+        else {\n+            rc = setOperatorNode.getLeftResultSet().getResultColumns().elementAt(columnPosition);\n+            rc.setName(columnName);\n+        }\n+        if (setOperatorNode.getRightResultSet() instanceof SetOperatorNode)\n+            updateColumnNamesInSetQuery((SetOperatorNode)setOperatorNode.getRightResultSet(), columnName, columnPosition);\n+        else {\n+            rc = setOperatorNode.getRightResultSet().getResultColumns().elementAt(columnPosition);\n+            rc.setName(columnName);\n+        }\n+        rc = setOperatorNode.getResultColumns().elementAt(columnPosition);;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e520ff3c090a859c1f40c952c634f4b6476681d9"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwNjM5MA==", "bodyText": "We have an IT called Subquery_Flattening_Exists_Union_IT, probably a better match for this case. But it's your decision whether to move it or not.", "url": "https://github.com/splicemachine/spliceengine/pull/4689#discussion_r530006390", "createdAt": "2020-11-24T23:32:07Z", "author": {"login": "ascend1"}, "path": "splice_machine/src/test/java/com/splicemachine/subquery/Subquery_Flattening_InList_IT.java", "diffHunk": "@@ -360,4 +360,100 @@ public void numberOfColumnsMismatch() throws Exception {\n             Assert.assertEquals(\"42X58\", e.getSQLState());\n         }\n     }\n+\n+    @Test\n+    public void testSetOpInSubQFlatten() throws Exception {\n+\n+        String expected =\n+            \"A1 |A2 |\\n\" +\n+            \"--------\\n\" +\n+            \" 0 | 0 |\\n\" +\n+            \" 1 |10 |\\n\" +\n+            \" 2 |20 |\\n\" +\n+            \" 3 |30 |\\n\" +\n+            \" 4 |40 |\\n\" +\n+            \" 5 |50 |\";\n+        String sql = \"select a1,a2 from A\\n\" +\n+                \"WHERE a1 in (select a1 from A\" +\n+                \"            WHERE a1 in (\\n\" +\n+                \"            SELECT b1 FROM B \" +\n+                \"            UNION \" +\n+                \"            SELECT b1 FROM B ))\";\n+        assertUnorderedResult(methodWatcher.getOrCreateConnection(),\n+                              sql , ZERO_SUBQUERY_NODES, expected );\n+        sql = \"select a1,a2 from A\\n\" +\n+                \"WHERE a1 in (select a1 from A\" +\n+                \"            WHERE a1+a1 in (\\n\" +\n+                \"            SELECT b1+b1 FROM B \" +\n+                \"            UNION \" +\n+                \"            SELECT b1 FROM B ))\";\n+        assertUnorderedResult(methodWatcher.getOrCreateConnection(),\n+                              sql , ZERO_SUBQUERY_NODES, expected );\n+        sql = \"select a1,a2 from A\\n\" +\n+                \"WHERE a1 in (select a1 from A\" +\n+                \"            WHERE a1+a1 in (\\n\" +\n+                \"            SELECT b1 FROM B \" +\n+                \"            UNION \" +\n+                \"            SELECT b1+b1 FROM B ))\";\n+        assertUnorderedResult(methodWatcher.getOrCreateConnection(),\n+                              sql , ZERO_SUBQUERY_NODES, expected );\n+\n+        sql = \"select a1,a2 from A\\n\" +\n+                \"WHERE exists (select a1 from A\" +\n+                \"            WHERE a1+a1 in (\\n\" +\n+                \"            SELECT b1 FROM B \" +\n+                \"            UNION \" +\n+                \"            SELECT b1+b1 FROM B ))\";\n+        assertUnorderedResult(methodWatcher.getOrCreateConnection(),\n+                              sql , ONE_SUBQUERY_NODE, expected );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e520ff3c090a859c1f40c952c634f4b6476681d9"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "726120377daba8cdc910ea6c81351af68cb7fc8f", "author": {"user": {"login": "msirek", "name": "Mark Sirek"}}, "url": "https://github.com/splicemachine/spliceengine/commit/726120377daba8cdc910ea6c81351af68cb7fc8f", "committedDate": "2020-11-24T23:46:31Z", "message": "DB-10774 Address review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4MDU2OTc2", "url": "https://github.com/splicemachine/spliceengine/pull/4689#pullrequestreview-538056976", "createdAt": "2020-11-24T23:51:16Z", "commit": {"oid": "726120377daba8cdc910ea6c81351af68cb7fc8f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4MTM4MDE4", "url": "https://github.com/splicemachine/spliceengine/pull/4689#pullrequestreview-538138018", "createdAt": "2020-11-25T03:53:09Z", "commit": {"oid": "e520ff3c090a859c1f40c952c634f4b6476681d9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1026, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}