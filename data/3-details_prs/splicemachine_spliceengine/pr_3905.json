{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NTUxMTA1", "number": 3905, "title": "DB-9883 spliceck - HBase/Splice Support Tool", "bodyText": "Also DB-9901 and DB-9903 tasks.", "createdAt": "2020-07-29T16:33:13Z", "url": "https://github.com/splicemachine/spliceengine/pull/3905", "merged": true, "mergeCommit": {"oid": "6b2dc5e1bb9cf062d0c37eea6dea7983a5714329"}, "closed": true, "closedAt": "2020-08-18T15:05:42Z", "author": {"login": "hatyo"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3c8NAgH2gAyNDU4NTUxMTA1OjI1YjE5ZWI3NDlhYmI0MzdjZWMxZjIwMTlkYTYzNjQzMGVkZTI3OTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc_9zFVgFqTQ2ODk1MzM5NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "25b19eb749abb437cec1f2019da636430ede2794", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/25b19eb749abb437cec1f2019da636430ede2794", "committedDate": "2020-07-22T15:55:01Z", "message": "DB-9883 implement API for print HBase row."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31e93781e170139cc9e1f906325012cf9aa72406", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/31e93781e170139cc9e1f906325012cf9aa72406", "committedDate": "2020-07-24T17:06:19Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9883"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/a1b39e822872ffbab0c544cb9c20ab3fe9926536", "committedDate": "2020-07-29T18:00:47Z", "message": "DB-9883 first version of spliceck.\n\n- tlist, rget, tschema, tableof, regionof commands are implemented."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "06df1690fc53dece8bb17e6059cdb9d8076d5379", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/06df1690fc53dece8bb17e6059cdb9d8076d5379", "committedDate": "2020-07-29T16:30:11Z", "message": "DB-9883 first version of spliceck.\n\n- tlist, rget, tschema, tableof, regionof commands are implemented."}, "afterCommit": {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/a1b39e822872ffbab0c544cb9c20ab3fe9926536", "committedDate": "2020-07-29T18:00:47Z", "message": "DB-9883 first version of spliceck.\n\n- tlist, rget, tschema, tableof, regionof commands are implemented."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3ODkyNjQ3", "url": "https://github.com/splicemachine/spliceengine/pull/3905#pullrequestreview-457892647", "createdAt": "2020-07-29T20:58:58Z", "commit": {"oid": "25b19eb749abb437cec1f2019da636430ede2794"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMDo1ODo1OFrOG5J8TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMToyNDo1NlrOG5Kw3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NDkwOA==", "bodyText": "note: mostly whitespace changes", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462584908", "createdAt": "2020-07-29T20:58:58Z", "author": {"login": "martinrupp"}, "path": "db-tools-ij/src/main/java/com/splicemachine/db/impl/tools/ij/Main.java", "diffHunk": "@@ -55,220 +49,192 @@\n  * If it is not an ij command, it is treated as a JSQL\n  * statement and executed against the current connection.\n  * ijParser controls the current connection, and so contains\n- * all of the state information for executing JSQL statements.\n+ * all the state information for executing JSQL statements.\n  * <p>\n  * This was written to facilitate a test harness for language\n  * functionality tests.\n- *\n- *\n  */\n public class Main {\n-\tprivate utilMain utilInstance;\n-\n-\t/**\n-\t * ij can be used directly on a shell command line through\n-\t * its main program.\n-\t * @param args allows 1 file name to be specified, from which\n-\t *    input will be read; if not specified, stdin is used.\n-\t */\n-\tpublic static void main(String[] args)\t\n-\t\tthrows IOException \n-\t{\n-\t\tmainCore(args, new Main(true));\n-\t}\n+    private utilMain utilInstance;\n \n-\tpublic static void mainCore(String[] args, Main main)\n-\t\tthrows IOException \n-\t{\n-\t\tLocalizedInput in = null;\n-\t\tInputStream in1 = null;\n-\t\tMain me;\n-\t\tString file;\n-\t\tString inputResourceName;\n-\n-\t\tLocalizedResource langUtil = LocalizedResource.getInstance();\n-\t\tLocalizedOutput out = langUtil.getNewOutput(System.out);\n-\n-                // Validate arguments, check for --help.\n-\t\tif (util.invalidArgs(args)) {\n-\t\t\tutil.Usage(out);\n-      \t\treturn;\n-\t\t}\n-\n-\t\t// load the property file if specified\n-\t\tutil.getPropertyArg(args);\n-\n-\t\t// readjust output to db.ui.locale and db.ui.codeset if\n-                // they were loaded from a property file.\n-\t\tlangUtil.init();\n-\t\tout = langUtil.getNewOutput(System.out);\n-                main.initAppUI();\n-\n-\t\tfile = util.getFileArg(args);\n-\t\tinputResourceName = util.getInputResourceNameArg(args);\n-\t\tif (inputResourceName != null) {\n-\t\t\tin = langUtil.getNewInput(util.getResourceAsStream(inputResourceName));\n-\t\t\tif (in == null) {\n-\t\t\t\tout.println(langUtil.getTextMessage(\"IJ_IjErroResoNo\",inputResourceName));\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t} else if (file == null) {\n-\t\t\tin = langUtil.getNewInput(System.in);\n-                        out.flush();\n-    \t        } else {\n+    /**\n+     * ij can be used directly on a shell command line through\n+     * its main program.\n+     *\n+     * @param args allows 1 file name to be specified, from which\n+     *  input will be read; if not specified, stdin is used.\n+     */\n+    public static void main(String[] args)\n+            throws IOException {\n+        mainCore(args, new Main(true));\n+    }\n+\n+    public static void mainCore(String[] args, Main main)\n+            throws IOException {\n+        LocalizedResource langUtil = LocalizedResource.getInstance();\n+        LocalizedOutput out = langUtil.getNewOutput(System.out);\n+        // Validate arguments, check for --help.\n+        if (util.invalidArgs(args)) {\n+            util.Usage(out);\n+            return;\n+        }\n+\n+        // load the property file if specified\n+        util.getPropertyArg(args);\n+\n+        // readjust output to db.ui.locale and db.ui.codeset if\n+        // they were loaded from a property file.\n+        langUtil.init();\n+        out = langUtil.getNewOutput(System.out);\n+        main.initAppUI();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b19eb749abb437cec1f2019da636430ede2794"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NjE0Ng==", "bodyText": "(minor comment) tab/space alignment looks off", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462586146", "createdAt": "2020-07-29T21:01:16Z", "author": {"login": "martinrupp"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSCOLUMNSRowFactory.java", "diffHunk": "@@ -60,17 +60,17 @@\n public class SYSCOLUMNSRowFactory extends CatalogRowFactory {\n     public static final String\t\tTABLENAME_STRING = \"SYSCOLUMNS\";\n \n-    protected static final int\t\tSYSCOLUMNS_COLUMN_COUNT = 13;\n+    public static final int\t\tSYSCOLUMNS_COLUMN_COUNT = 13;\n \t/* Column #s for syscolumns (1 based) */\n \n     //TABLEID is an obsolete name, it is better to use\n     //REFERENCEID, but to make life easier you can use either\n     protected static final int\t\tSYSCOLUMNS_TABLEID = 1;\n-    protected static final int\t\tSYSCOLUMNS_REFERENCEID = 1;\n-    protected static final int\t\tSYSCOLUMNS_COLUMNNAME = 2;\n-    protected static final int\t\tSYSCOLUMNS_COLUMNNUMBER = 3;\n+    public static final int\t\tSYSCOLUMNS_REFERENCEID = 1;\n+    public static final int\t\tSYSCOLUMNS_COLUMNNAME = 2;\n+    public static final int\t\tSYSCOLUMNS_COLUMNNUMBER = 3;\n     protected static final int\t\tSYSCOLUMNS_STORAGECOLUMNNUMBER = 4;\n-    protected static final int\t\tSYSCOLUMNS_COLUMNDATATYPE = 5;\n+    public static final int\t\tSYSCOLUMNS_COLUMNDATATYPE = 5;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NjU3OA==", "bodyText": "please use line breaks (80-100 columns max i would say)", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462586578", "createdAt": "2020-07-29T21:02:03Z", "author": {"login": "martinrupp"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSCOLUMNSRowFactory.java", "diffHunk": "@@ -208,27 +208,33 @@ public ExecRow makeRow(TupleDescriptor td, TupleDescriptor parent) throws Standa\n \n \t\t    /* Build the row to insert  */\n         row = getExecutionFactory().getValueRow(SYSCOLUMNS_COLUMN_COUNT);\n+        setRowColumns(row, colName, defaultID, tabID, colID, storageNumber, typeDesc, defaultSerializable, autoincStart,\n+                autoincInc, autoincValue, partitionPosition, autoinc_create_or_modify_Start_Increment, collectStats, useExtrapolation);\n \n-\t\t    /* 1st column is REFERENCEID (UUID - char(36)) */\n+        return row;\n+    }\n+\n+    public static void setRowColumns(ExecRow row, String colName, String defaultID, String tabID, Integer colID, Integer storageNumber, TypeDescriptor typeDesc, Object defaultSerializable, long autoincStart, long autoincInc, long autoincValue, int partitionPosition, long autoinc_create_or_modify_Start_Increment, boolean collectStats, byte useExtrapolation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NzYxMw==", "bodyText": "are these... tabs? ;-)", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462587613", "createdAt": "2020-07-29T21:03:54Z", "author": {"login": "martinrupp"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java", "diffHunk": "@@ -257,6 +257,27 @@ public ExecRow makeRow(TupleDescriptor td,\n \t\t/* Build the row to insert  */\n \t\trow = getExecutionFactory().getValueRow(SYSTABLES_COLUMN_COUNT);\n \n+\t\tsetRowColumns(row, tableID, tableName, tabSType, schemaID, lockGranularity, tableVersion, columnSequence,\n+\t\t\t\tdelimited, escaped, lines, storedAs, location, compression, isPinned, purgeDeletedRows);\n+\t\treturn row;\n+\t}\n+\n+\tpublic static void setRowColumns(ExecRow row,\n+\t\t\t\t\t\t\t\t\t String tableID,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4ODU1Mw==", "bodyText": "maybe we should be able to use this also for cdh5.12.0, or is this all the same?\nPLATFORM=$1\nshift # ignore $1\nmvn -q -Pcore,${PLATFORM} -f ./splice_ck/pom.xml exec:java -Dexec.args=\"$*\"", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462588553", "createdAt": "2020-07-29T21:05:37Z", "author": {"login": "martinrupp"}, "path": "sck.sh", "diffHunk": "@@ -0,0 +1,4 @@\n+#!/bin/bash\n+\n+mvn -q -Pcore,cdh6.3.0 -f ./splice_ck/pom.xml exec:java -Dexec.args=\"$*\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5MjAzMQ==", "bodyText": "maybe \"\"\" + value + \"\"\", to differentiate the string \"NULL\" from NULL ?\nAnd maybe also escape strings? Not sure how \"pro\" this needs to be\nif( value == null )\n  return \"NULL\";\n\nreturn \"\\\"\" + value.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\") + \"\\\"\";", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462592031", "createdAt": "2020-07-29T21:12:06Z", "author": {"login": "martinrupp"}, "path": "splice_ck/src/main/java/com/splicemachine/ck/HBaseInspector.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package com.splicemachine.ck;\n+\n+import com.splicemachine.ck.decoder.SysColsDataDecoder;\n+import com.splicemachine.ck.decoder.SysTableDataDecoder;\n+import com.splicemachine.ck.decoder.UserDataDecoder;\n+import com.splicemachine.ck.decoder.UserDefinedDataDecoder;\n+import com.splicemachine.ck.visitor.CellPrinter;\n+import com.splicemachine.ck.visitor.ICellVisitor;\n+import com.splicemachine.db.catalog.types.TypeDescriptorImpl;\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.impl.sql.catalog.SYSCOLUMNSRowFactory;\n+import com.splicemachine.db.impl.sql.catalog.SYSTABLESRowFactory;\n+import com.splicemachine.si.constants.SIConstants;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.*;\n+import org.apache.hadoop.hbase.client.*;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+public class HBaseInspector {\n+\n+    private Configuration config;\n+\n+    public HBaseInspector(Configuration config) {\n+        this.config = config;\n+    }\n+\n+    public static class ScanPrinter implements AutoCloseable {\n+        @Override\n+        public void close() {\n+        }\n+\n+        public void ProcessRow(Result r, ICellVisitor visitor) throws Exception {\n+            CellScanner scanner = r.cellScanner();\n+            while (scanner.advance()) {\n+                Cell cell = scanner.current();\n+                visitor.visit(cell);\n+            }\n+        }\n+    }\n+\n+    public String scanRow(String region, String rowKey, Utils.SQLType[] schema) throws Exception {\n+        StringBuilder result = new StringBuilder();\n+        try {\n+            try (Connection conn = ConnectionFactory.createConnection(config)) {\n+                Table table = conn.getTable(TableName.valueOf(region));\n+                Scan scan = new Scan();\n+                scan.withStartRow(Bytes.fromHex(rowKey)).setLimit(1).readAllVersions();\n+                try (ResultScanner results = table.getScanner(scan)) {\n+                    ScanPrinter scanner = new ScanPrinter();\n+                    CellPrinter cellPrinter = new CellPrinter(new UserDefinedDataDecoder(schema, 4));\n+                    for (Result r : results) {\n+                        scanner.ProcessRow(r, cellPrinter);\n+                        result.append(cellPrinter.getOutput());\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            return Utils.checkException(e, region);\n+        }\n+        return result.toString();\n+    }\n+\n+    private Utils.Tabular getListTables() throws Exception {\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            List<TableDescriptor> descriptors = conn.getAdmin().listTableDescriptors(Pattern.compile(\"splice.*\"));\n+\n+            Utils.Tabular tabular = new Utils.Tabular(\"hbase name\", \"schema\", \"table\", \"index\", \"create txn\");\n+            for (TableDescriptor td : descriptors) {\n+                tabular.addRow(CheckNull(td.getTableName().toString()),\n+                        CheckNull(td.getValue(SIConstants.SCHEMA_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TABLE_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.INDEX_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TRANSACTION_ID_ATTR)));\n+            }\n+            return tabular;\n+        }\n+    }\n+\n+    private String CheckNull(String value) {\n+        return value == null ? \"NULL\" : value;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NDIxMw==", "bodyText": "tableName", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462594213", "createdAt": "2020-07-29T21:16:29Z", "author": {"login": "martinrupp"}, "path": "splice_ck/src/main/java/com/splicemachine/ck/HBaseInspector.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package com.splicemachine.ck;\n+\n+import com.splicemachine.ck.decoder.SysColsDataDecoder;\n+import com.splicemachine.ck.decoder.SysTableDataDecoder;\n+import com.splicemachine.ck.decoder.UserDataDecoder;\n+import com.splicemachine.ck.decoder.UserDefinedDataDecoder;\n+import com.splicemachine.ck.visitor.CellPrinter;\n+import com.splicemachine.ck.visitor.ICellVisitor;\n+import com.splicemachine.db.catalog.types.TypeDescriptorImpl;\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.impl.sql.catalog.SYSCOLUMNSRowFactory;\n+import com.splicemachine.db.impl.sql.catalog.SYSTABLESRowFactory;\n+import com.splicemachine.si.constants.SIConstants;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.*;\n+import org.apache.hadoop.hbase.client.*;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+public class HBaseInspector {\n+\n+    private Configuration config;\n+\n+    public HBaseInspector(Configuration config) {\n+        this.config = config;\n+    }\n+\n+    public static class ScanPrinter implements AutoCloseable {\n+        @Override\n+        public void close() {\n+        }\n+\n+        public void ProcessRow(Result r, ICellVisitor visitor) throws Exception {\n+            CellScanner scanner = r.cellScanner();\n+            while (scanner.advance()) {\n+                Cell cell = scanner.current();\n+                visitor.visit(cell);\n+            }\n+        }\n+    }\n+\n+    public String scanRow(String region, String rowKey, Utils.SQLType[] schema) throws Exception {\n+        StringBuilder result = new StringBuilder();\n+        try {\n+            try (Connection conn = ConnectionFactory.createConnection(config)) {\n+                Table table = conn.getTable(TableName.valueOf(region));\n+                Scan scan = new Scan();\n+                scan.withStartRow(Bytes.fromHex(rowKey)).setLimit(1).readAllVersions();\n+                try (ResultScanner results = table.getScanner(scan)) {\n+                    ScanPrinter scanner = new ScanPrinter();\n+                    CellPrinter cellPrinter = new CellPrinter(new UserDefinedDataDecoder(schema, 4));\n+                    for (Result r : results) {\n+                        scanner.ProcessRow(r, cellPrinter);\n+                        result.append(cellPrinter.getOutput());\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            return Utils.checkException(e, region);\n+        }\n+        return result.toString();\n+    }\n+\n+    private Utils.Tabular getListTables() throws Exception {\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            List<TableDescriptor> descriptors = conn.getAdmin().listTableDescriptors(Pattern.compile(\"splice.*\"));\n+\n+            Utils.Tabular tabular = new Utils.Tabular(\"hbase name\", \"schema\", \"table\", \"index\", \"create txn\");\n+            for (TableDescriptor td : descriptors) {\n+                tabular.addRow(CheckNull(td.getTableName().toString()),\n+                        CheckNull(td.getValue(SIConstants.SCHEMA_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TABLE_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.INDEX_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TRANSACTION_ID_ATTR)));\n+            }\n+            return tabular;\n+        }\n+    }\n+\n+    private String CheckNull(String value) {\n+        return value == null ? \"NULL\" : value;\n+    }\n+\n+    public String listTables() throws Exception {\n+        return Utils.printTabularResults(getListTables());\n+    }\n+\n+    public Utils.Tabular schemaOf(String table) throws Exception {\n+        String systableId = getHbaseRegionOf(SYSTABLESRowFactory.TABLENAME_STRING);\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            Table hbaseTable = conn.getTable(TableName.valueOf(systableId));\n+            Scan scan = new Scan().addColumn(SIConstants.DEFAULT_FAMILY_BYTES, SIConstants.PACKED_COLUMN_BYTES);\n+            try (ResultScanner results = hbaseTable.getScanner(scan)) {\n+                final ValContainer<Pair<Long, String>> tableId = new ValContainer<>(null);\n+                for (Result r : results) {\n+                    ICellVisitor cellVisitor = new ICellVisitor() {\n+                        @Override\n+                        protected void visitUserData(Cell userData) throws StandardException {\n+                            UserDataDecoder decoder = new SysTableDataDecoder();\n+                            ExecRow er = decoder.decode(userData);\n+                            if (table.equals(er.getColumn(SYSTABLESRowFactory.SYSTABLES_TABLENAME).getString())) {\n+                                if (tableId.get() == null || (tableId.get() != null && tableId.get().getFirst() < userData.getTimestamp())) {\n+                                    tableId.set(new Pair<>(userData.getTimestamp(), er.getColumn(SYSTABLESRowFactory.SYSTABLES_TABLEID).getString()));\n+                                }\n+                            }\n+                        }\n+                    };\n+                    for (Cell cell : r.listCells()) {\n+                        cellVisitor.visit(cell);\n+                    }\n+                }\n+                if (tableId.get() == null) {\n+                    throw new TableNotFoundException();\n+                }\n+                return constructSchemaFromSysColsTable(tableId.get().getSecond());\n+            }\n+        }\n+    }\n+\n+    private Utils.Tabular constructSchemaFromSysColsTable(String tableId) throws Exception {\n+        String systableId = getHbaseRegionOf(SYSCOLUMNSRowFactory.TABLENAME_STRING);\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            Table table = conn.getTable(TableName.valueOf(systableId));\n+            Scan scan = new Scan().addColumn(SIConstants.DEFAULT_FAMILY_BYTES, SIConstants.PACKED_COLUMN_BYTES);\n+            try (ResultScanner results = table.getScanner(scan)) {\n+                final ValContainer<Utils.Tabular> schema = new ValContainer<>(new Utils.Tabular(\"column index\", \"column name\", \"column type\"));\n+                for (Result r : results) {\n+                    ICellVisitor cellVisitor = new ICellVisitor() {\n+                        @Override\n+                        protected void visitUserData(Cell userData) throws StandardException {\n+                            UserDataDecoder decoder = new SysColsDataDecoder();\n+                            ExecRow er = decoder.decode(userData);\n+                            if (er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_REFERENCEID) != null\n+                                    && tableId.equals(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_REFERENCEID).getString())) {\n+                                schema.get().addRow(Integer.toString(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNNUMBER).getInt()),\n+                                        CheckNull(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNNAME).toString()),\n+                                        CheckNull(((TypeDescriptorImpl)(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNDATATYPE)).getObject()).getTypeName()));\n+                            }\n+                        }\n+                    };\n+                    for (Cell cell : r.listCells()) {\n+                        cellVisitor.visit(cell);\n+                    }\n+                }\n+                return schema.get();\n+            }\n+        }\n+    }\n+\n+    public String getHbaseRegionOf(String tableName) throws Exception {\n+        Utils.Tabular results = getListTables();\n+        Utils.Tabular.Row r = results.rows.stream().filter(result -> result.cols.get(2 /*name*/).equals(tableName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NDcyNQ==", "bodyText": "index? isn't that transactionId?", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462594725", "createdAt": "2020-07-29T21:17:25Z", "author": {"login": "martinrupp"}, "path": "splice_ck/src/main/java/com/splicemachine/ck/HBaseInspector.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package com.splicemachine.ck;\n+\n+import com.splicemachine.ck.decoder.SysColsDataDecoder;\n+import com.splicemachine.ck.decoder.SysTableDataDecoder;\n+import com.splicemachine.ck.decoder.UserDataDecoder;\n+import com.splicemachine.ck.decoder.UserDefinedDataDecoder;\n+import com.splicemachine.ck.visitor.CellPrinter;\n+import com.splicemachine.ck.visitor.ICellVisitor;\n+import com.splicemachine.db.catalog.types.TypeDescriptorImpl;\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.impl.sql.catalog.SYSCOLUMNSRowFactory;\n+import com.splicemachine.db.impl.sql.catalog.SYSTABLESRowFactory;\n+import com.splicemachine.si.constants.SIConstants;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.*;\n+import org.apache.hadoop.hbase.client.*;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+public class HBaseInspector {\n+\n+    private Configuration config;\n+\n+    public HBaseInspector(Configuration config) {\n+        this.config = config;\n+    }\n+\n+    public static class ScanPrinter implements AutoCloseable {\n+        @Override\n+        public void close() {\n+        }\n+\n+        public void ProcessRow(Result r, ICellVisitor visitor) throws Exception {\n+            CellScanner scanner = r.cellScanner();\n+            while (scanner.advance()) {\n+                Cell cell = scanner.current();\n+                visitor.visit(cell);\n+            }\n+        }\n+    }\n+\n+    public String scanRow(String region, String rowKey, Utils.SQLType[] schema) throws Exception {\n+        StringBuilder result = new StringBuilder();\n+        try {\n+            try (Connection conn = ConnectionFactory.createConnection(config)) {\n+                Table table = conn.getTable(TableName.valueOf(region));\n+                Scan scan = new Scan();\n+                scan.withStartRow(Bytes.fromHex(rowKey)).setLimit(1).readAllVersions();\n+                try (ResultScanner results = table.getScanner(scan)) {\n+                    ScanPrinter scanner = new ScanPrinter();\n+                    CellPrinter cellPrinter = new CellPrinter(new UserDefinedDataDecoder(schema, 4));\n+                    for (Result r : results) {\n+                        scanner.ProcessRow(r, cellPrinter);\n+                        result.append(cellPrinter.getOutput());\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            return Utils.checkException(e, region);\n+        }\n+        return result.toString();\n+    }\n+\n+    private Utils.Tabular getListTables() throws Exception {\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            List<TableDescriptor> descriptors = conn.getAdmin().listTableDescriptors(Pattern.compile(\"splice.*\"));\n+\n+            Utils.Tabular tabular = new Utils.Tabular(\"hbase name\", \"schema\", \"table\", \"index\", \"create txn\");\n+            for (TableDescriptor td : descriptors) {\n+                tabular.addRow(CheckNull(td.getTableName().toString()),\n+                        CheckNull(td.getValue(SIConstants.SCHEMA_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TABLE_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.INDEX_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TRANSACTION_ID_ATTR)));\n+            }\n+            return tabular;\n+        }\n+    }\n+\n+    private String CheckNull(String value) {\n+        return value == null ? \"NULL\" : value;\n+    }\n+\n+    public String listTables() throws Exception {\n+        return Utils.printTabularResults(getListTables());\n+    }\n+\n+    public Utils.Tabular schemaOf(String table) throws Exception {\n+        String systableId = getHbaseRegionOf(SYSTABLESRowFactory.TABLENAME_STRING);\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            Table hbaseTable = conn.getTable(TableName.valueOf(systableId));\n+            Scan scan = new Scan().addColumn(SIConstants.DEFAULT_FAMILY_BYTES, SIConstants.PACKED_COLUMN_BYTES);\n+            try (ResultScanner results = hbaseTable.getScanner(scan)) {\n+                final ValContainer<Pair<Long, String>> tableId = new ValContainer<>(null);\n+                for (Result r : results) {\n+                    ICellVisitor cellVisitor = new ICellVisitor() {\n+                        @Override\n+                        protected void visitUserData(Cell userData) throws StandardException {\n+                            UserDataDecoder decoder = new SysTableDataDecoder();\n+                            ExecRow er = decoder.decode(userData);\n+                            if (table.equals(er.getColumn(SYSTABLESRowFactory.SYSTABLES_TABLENAME).getString())) {\n+                                if (tableId.get() == null || (tableId.get() != null && tableId.get().getFirst() < userData.getTimestamp())) {\n+                                    tableId.set(new Pair<>(userData.getTimestamp(), er.getColumn(SYSTABLESRowFactory.SYSTABLES_TABLEID).getString()));\n+                                }\n+                            }\n+                        }\n+                    };\n+                    for (Cell cell : r.listCells()) {\n+                        cellVisitor.visit(cell);\n+                    }\n+                }\n+                if (tableId.get() == null) {\n+                    throw new TableNotFoundException();\n+                }\n+                return constructSchemaFromSysColsTable(tableId.get().getSecond());\n+            }\n+        }\n+    }\n+\n+    private Utils.Tabular constructSchemaFromSysColsTable(String tableId) throws Exception {\n+        String systableId = getHbaseRegionOf(SYSCOLUMNSRowFactory.TABLENAME_STRING);\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            Table table = conn.getTable(TableName.valueOf(systableId));\n+            Scan scan = new Scan().addColumn(SIConstants.DEFAULT_FAMILY_BYTES, SIConstants.PACKED_COLUMN_BYTES);\n+            try (ResultScanner results = table.getScanner(scan)) {\n+                final ValContainer<Utils.Tabular> schema = new ValContainer<>(new Utils.Tabular(\"column index\", \"column name\", \"column type\"));\n+                for (Result r : results) {\n+                    ICellVisitor cellVisitor = new ICellVisitor() {\n+                        @Override\n+                        protected void visitUserData(Cell userData) throws StandardException {\n+                            UserDataDecoder decoder = new SysColsDataDecoder();\n+                            ExecRow er = decoder.decode(userData);\n+                            if (er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_REFERENCEID) != null\n+                                    && tableId.equals(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_REFERENCEID).getString())) {\n+                                schema.get().addRow(Integer.toString(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNNUMBER).getInt()),\n+                                        CheckNull(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNNAME).toString()),\n+                                        CheckNull(((TypeDescriptorImpl)(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNDATATYPE)).getObject()).getTypeName()));\n+                            }\n+                        }\n+                    };\n+                    for (Cell cell : r.listCells()) {\n+                        cellVisitor.visit(cell);\n+                    }\n+                }\n+                return schema.get();\n+            }\n+        }\n+    }\n+\n+    public String getHbaseRegionOf(String tableName) throws Exception {\n+        Utils.Tabular results = getListTables();\n+        Utils.Tabular.Row r = results.rows.stream().filter(result -> result.cols.get(2 /*name*/).equals(tableName)\n+                && result.cols.get(3 /*index*/).equals(\"NULL\")).findAny().orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NDgxNA==", "bodyText": "schemaName?", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462594814", "createdAt": "2020-07-29T21:17:39Z", "author": {"login": "martinrupp"}, "path": "splice_ck/src/main/java/com/splicemachine/ck/HBaseInspector.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package com.splicemachine.ck;\n+\n+import com.splicemachine.ck.decoder.SysColsDataDecoder;\n+import com.splicemachine.ck.decoder.SysTableDataDecoder;\n+import com.splicemachine.ck.decoder.UserDataDecoder;\n+import com.splicemachine.ck.decoder.UserDefinedDataDecoder;\n+import com.splicemachine.ck.visitor.CellPrinter;\n+import com.splicemachine.ck.visitor.ICellVisitor;\n+import com.splicemachine.db.catalog.types.TypeDescriptorImpl;\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.impl.sql.catalog.SYSCOLUMNSRowFactory;\n+import com.splicemachine.db.impl.sql.catalog.SYSTABLESRowFactory;\n+import com.splicemachine.si.constants.SIConstants;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.*;\n+import org.apache.hadoop.hbase.client.*;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+public class HBaseInspector {\n+\n+    private Configuration config;\n+\n+    public HBaseInspector(Configuration config) {\n+        this.config = config;\n+    }\n+\n+    public static class ScanPrinter implements AutoCloseable {\n+        @Override\n+        public void close() {\n+        }\n+\n+        public void ProcessRow(Result r, ICellVisitor visitor) throws Exception {\n+            CellScanner scanner = r.cellScanner();\n+            while (scanner.advance()) {\n+                Cell cell = scanner.current();\n+                visitor.visit(cell);\n+            }\n+        }\n+    }\n+\n+    public String scanRow(String region, String rowKey, Utils.SQLType[] schema) throws Exception {\n+        StringBuilder result = new StringBuilder();\n+        try {\n+            try (Connection conn = ConnectionFactory.createConnection(config)) {\n+                Table table = conn.getTable(TableName.valueOf(region));\n+                Scan scan = new Scan();\n+                scan.withStartRow(Bytes.fromHex(rowKey)).setLimit(1).readAllVersions();\n+                try (ResultScanner results = table.getScanner(scan)) {\n+                    ScanPrinter scanner = new ScanPrinter();\n+                    CellPrinter cellPrinter = new CellPrinter(new UserDefinedDataDecoder(schema, 4));\n+                    for (Result r : results) {\n+                        scanner.ProcessRow(r, cellPrinter);\n+                        result.append(cellPrinter.getOutput());\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            return Utils.checkException(e, region);\n+        }\n+        return result.toString();\n+    }\n+\n+    private Utils.Tabular getListTables() throws Exception {\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            List<TableDescriptor> descriptors = conn.getAdmin().listTableDescriptors(Pattern.compile(\"splice.*\"));\n+\n+            Utils.Tabular tabular = new Utils.Tabular(\"hbase name\", \"schema\", \"table\", \"index\", \"create txn\");\n+            for (TableDescriptor td : descriptors) {\n+                tabular.addRow(CheckNull(td.getTableName().toString()),\n+                        CheckNull(td.getValue(SIConstants.SCHEMA_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TABLE_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.INDEX_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TRANSACTION_ID_ATTR)));\n+            }\n+            return tabular;\n+        }\n+    }\n+\n+    private String CheckNull(String value) {\n+        return value == null ? \"NULL\" : value;\n+    }\n+\n+    public String listTables() throws Exception {\n+        return Utils.printTabularResults(getListTables());\n+    }\n+\n+    public Utils.Tabular schemaOf(String table) throws Exception {\n+        String systableId = getHbaseRegionOf(SYSTABLESRowFactory.TABLENAME_STRING);\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            Table hbaseTable = conn.getTable(TableName.valueOf(systableId));\n+            Scan scan = new Scan().addColumn(SIConstants.DEFAULT_FAMILY_BYTES, SIConstants.PACKED_COLUMN_BYTES);\n+            try (ResultScanner results = hbaseTable.getScanner(scan)) {\n+                final ValContainer<Pair<Long, String>> tableId = new ValContainer<>(null);\n+                for (Result r : results) {\n+                    ICellVisitor cellVisitor = new ICellVisitor() {\n+                        @Override\n+                        protected void visitUserData(Cell userData) throws StandardException {\n+                            UserDataDecoder decoder = new SysTableDataDecoder();\n+                            ExecRow er = decoder.decode(userData);\n+                            if (table.equals(er.getColumn(SYSTABLESRowFactory.SYSTABLES_TABLENAME).getString())) {\n+                                if (tableId.get() == null || (tableId.get() != null && tableId.get().getFirst() < userData.getTimestamp())) {\n+                                    tableId.set(new Pair<>(userData.getTimestamp(), er.getColumn(SYSTABLESRowFactory.SYSTABLES_TABLEID).getString()));\n+                                }\n+                            }\n+                        }\n+                    };\n+                    for (Cell cell : r.listCells()) {\n+                        cellVisitor.visit(cell);\n+                    }\n+                }\n+                if (tableId.get() == null) {\n+                    throw new TableNotFoundException();\n+                }\n+                return constructSchemaFromSysColsTable(tableId.get().getSecond());\n+            }\n+        }\n+    }\n+\n+    private Utils.Tabular constructSchemaFromSysColsTable(String tableId) throws Exception {\n+        String systableId = getHbaseRegionOf(SYSCOLUMNSRowFactory.TABLENAME_STRING);\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            Table table = conn.getTable(TableName.valueOf(systableId));\n+            Scan scan = new Scan().addColumn(SIConstants.DEFAULT_FAMILY_BYTES, SIConstants.PACKED_COLUMN_BYTES);\n+            try (ResultScanner results = table.getScanner(scan)) {\n+                final ValContainer<Utils.Tabular> schema = new ValContainer<>(new Utils.Tabular(\"column index\", \"column name\", \"column type\"));\n+                for (Result r : results) {\n+                    ICellVisitor cellVisitor = new ICellVisitor() {\n+                        @Override\n+                        protected void visitUserData(Cell userData) throws StandardException {\n+                            UserDataDecoder decoder = new SysColsDataDecoder();\n+                            ExecRow er = decoder.decode(userData);\n+                            if (er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_REFERENCEID) != null\n+                                    && tableId.equals(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_REFERENCEID).getString())) {\n+                                schema.get().addRow(Integer.toString(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNNUMBER).getInt()),\n+                                        CheckNull(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNNAME).toString()),\n+                                        CheckNull(((TypeDescriptorImpl)(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNDATATYPE)).getObject()).getTypeName()));\n+                            }\n+                        }\n+                    };\n+                    for (Cell cell : r.listCells()) {\n+                        cellVisitor.visit(cell);\n+                    }\n+                }\n+                return schema.get();\n+            }\n+        }\n+    }\n+\n+    public String getHbaseRegionOf(String tableName) throws Exception {\n+        Utils.Tabular results = getListTables();\n+        Utils.Tabular.Row r = results.rows.stream().filter(result -> result.cols.get(2 /*name*/).equals(tableName)\n+                && result.cols.get(3 /*index*/).equals(\"NULL\")).findAny().orElse(null);\n+        if (r == null) {\n+            throw new TableNotFoundException();\n+        } else {\n+            return r.cols.get(0);\n+        }\n+    }\n+\n+    public String getSpliceTableNameOf(String regionName) throws Exception {\n+        Utils.Tabular results = getListTables();\n+        Utils.Tabular.Row r = results.rows.stream().filter(result -> result.cols.get(0 /*name*/).equals(regionName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NDg5MQ==", "bodyText": "transactionId?", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462594891", "createdAt": "2020-07-29T21:17:50Z", "author": {"login": "martinrupp"}, "path": "splice_ck/src/main/java/com/splicemachine/ck/HBaseInspector.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package com.splicemachine.ck;\n+\n+import com.splicemachine.ck.decoder.SysColsDataDecoder;\n+import com.splicemachine.ck.decoder.SysTableDataDecoder;\n+import com.splicemachine.ck.decoder.UserDataDecoder;\n+import com.splicemachine.ck.decoder.UserDefinedDataDecoder;\n+import com.splicemachine.ck.visitor.CellPrinter;\n+import com.splicemachine.ck.visitor.ICellVisitor;\n+import com.splicemachine.db.catalog.types.TypeDescriptorImpl;\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.impl.sql.catalog.SYSCOLUMNSRowFactory;\n+import com.splicemachine.db.impl.sql.catalog.SYSTABLESRowFactory;\n+import com.splicemachine.si.constants.SIConstants;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.*;\n+import org.apache.hadoop.hbase.client.*;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+public class HBaseInspector {\n+\n+    private Configuration config;\n+\n+    public HBaseInspector(Configuration config) {\n+        this.config = config;\n+    }\n+\n+    public static class ScanPrinter implements AutoCloseable {\n+        @Override\n+        public void close() {\n+        }\n+\n+        public void ProcessRow(Result r, ICellVisitor visitor) throws Exception {\n+            CellScanner scanner = r.cellScanner();\n+            while (scanner.advance()) {\n+                Cell cell = scanner.current();\n+                visitor.visit(cell);\n+            }\n+        }\n+    }\n+\n+    public String scanRow(String region, String rowKey, Utils.SQLType[] schema) throws Exception {\n+        StringBuilder result = new StringBuilder();\n+        try {\n+            try (Connection conn = ConnectionFactory.createConnection(config)) {\n+                Table table = conn.getTable(TableName.valueOf(region));\n+                Scan scan = new Scan();\n+                scan.withStartRow(Bytes.fromHex(rowKey)).setLimit(1).readAllVersions();\n+                try (ResultScanner results = table.getScanner(scan)) {\n+                    ScanPrinter scanner = new ScanPrinter();\n+                    CellPrinter cellPrinter = new CellPrinter(new UserDefinedDataDecoder(schema, 4));\n+                    for (Result r : results) {\n+                        scanner.ProcessRow(r, cellPrinter);\n+                        result.append(cellPrinter.getOutput());\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            return Utils.checkException(e, region);\n+        }\n+        return result.toString();\n+    }\n+\n+    private Utils.Tabular getListTables() throws Exception {\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            List<TableDescriptor> descriptors = conn.getAdmin().listTableDescriptors(Pattern.compile(\"splice.*\"));\n+\n+            Utils.Tabular tabular = new Utils.Tabular(\"hbase name\", \"schema\", \"table\", \"index\", \"create txn\");\n+            for (TableDescriptor td : descriptors) {\n+                tabular.addRow(CheckNull(td.getTableName().toString()),\n+                        CheckNull(td.getValue(SIConstants.SCHEMA_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TABLE_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.INDEX_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TRANSACTION_ID_ATTR)));\n+            }\n+            return tabular;\n+        }\n+    }\n+\n+    private String CheckNull(String value) {\n+        return value == null ? \"NULL\" : value;\n+    }\n+\n+    public String listTables() throws Exception {\n+        return Utils.printTabularResults(getListTables());\n+    }\n+\n+    public Utils.Tabular schemaOf(String table) throws Exception {\n+        String systableId = getHbaseRegionOf(SYSTABLESRowFactory.TABLENAME_STRING);\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            Table hbaseTable = conn.getTable(TableName.valueOf(systableId));\n+            Scan scan = new Scan().addColumn(SIConstants.DEFAULT_FAMILY_BYTES, SIConstants.PACKED_COLUMN_BYTES);\n+            try (ResultScanner results = hbaseTable.getScanner(scan)) {\n+                final ValContainer<Pair<Long, String>> tableId = new ValContainer<>(null);\n+                for (Result r : results) {\n+                    ICellVisitor cellVisitor = new ICellVisitor() {\n+                        @Override\n+                        protected void visitUserData(Cell userData) throws StandardException {\n+                            UserDataDecoder decoder = new SysTableDataDecoder();\n+                            ExecRow er = decoder.decode(userData);\n+                            if (table.equals(er.getColumn(SYSTABLESRowFactory.SYSTABLES_TABLENAME).getString())) {\n+                                if (tableId.get() == null || (tableId.get() != null && tableId.get().getFirst() < userData.getTimestamp())) {\n+                                    tableId.set(new Pair<>(userData.getTimestamp(), er.getColumn(SYSTABLESRowFactory.SYSTABLES_TABLEID).getString()));\n+                                }\n+                            }\n+                        }\n+                    };\n+                    for (Cell cell : r.listCells()) {\n+                        cellVisitor.visit(cell);\n+                    }\n+                }\n+                if (tableId.get() == null) {\n+                    throw new TableNotFoundException();\n+                }\n+                return constructSchemaFromSysColsTable(tableId.get().getSecond());\n+            }\n+        }\n+    }\n+\n+    private Utils.Tabular constructSchemaFromSysColsTable(String tableId) throws Exception {\n+        String systableId = getHbaseRegionOf(SYSCOLUMNSRowFactory.TABLENAME_STRING);\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            Table table = conn.getTable(TableName.valueOf(systableId));\n+            Scan scan = new Scan().addColumn(SIConstants.DEFAULT_FAMILY_BYTES, SIConstants.PACKED_COLUMN_BYTES);\n+            try (ResultScanner results = table.getScanner(scan)) {\n+                final ValContainer<Utils.Tabular> schema = new ValContainer<>(new Utils.Tabular(\"column index\", \"column name\", \"column type\"));\n+                for (Result r : results) {\n+                    ICellVisitor cellVisitor = new ICellVisitor() {\n+                        @Override\n+                        protected void visitUserData(Cell userData) throws StandardException {\n+                            UserDataDecoder decoder = new SysColsDataDecoder();\n+                            ExecRow er = decoder.decode(userData);\n+                            if (er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_REFERENCEID) != null\n+                                    && tableId.equals(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_REFERENCEID).getString())) {\n+                                schema.get().addRow(Integer.toString(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNNUMBER).getInt()),\n+                                        CheckNull(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNNAME).toString()),\n+                                        CheckNull(((TypeDescriptorImpl)(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNDATATYPE)).getObject()).getTypeName()));\n+                            }\n+                        }\n+                    };\n+                    for (Cell cell : r.listCells()) {\n+                        cellVisitor.visit(cell);\n+                    }\n+                }\n+                return schema.get();\n+            }\n+        }\n+    }\n+\n+    public String getHbaseRegionOf(String tableName) throws Exception {\n+        Utils.Tabular results = getListTables();\n+        Utils.Tabular.Row r = results.rows.stream().filter(result -> result.cols.get(2 /*name*/).equals(tableName)\n+                && result.cols.get(3 /*index*/).equals(\"NULL\")).findAny().orElse(null);\n+        if (r == null) {\n+            throw new TableNotFoundException();\n+        } else {\n+            return r.cols.get(0);\n+        }\n+    }\n+\n+    public String getSpliceTableNameOf(String regionName) throws Exception {\n+        Utils.Tabular results = getListTables();\n+        Utils.Tabular.Row r = results.rows.stream().filter(result -> result.cols.get(0 /*name*/).equals(regionName)\n+                && result.cols.get(3 /*index*/).equals(\"NULL\")).findAny().orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NTI5Ng==", "bodyText": "make 5 a descriptive constant", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462595296", "createdAt": "2020-07-29T21:18:36Z", "author": {"login": "martinrupp"}, "path": "splice_ck/src/main/java/com/splicemachine/ck/Utils.java", "diffHunk": "@@ -0,0 +1,206 @@\n+package com.splicemachine.ck;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.services.io.StoredFormatIds;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.iapi.types.TypeId;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.TableNotFoundException;\n+\n+import java.io.UncheckedIOException;\n+import java.util.*;\n+\n+import static com.splicemachine.db.iapi.types.TypeId.BOOLEAN_NAME;\n+\n+public class Utils {\n+\n+    public static final String HBASE_CONFIGURATION_ZOOKEEPER_QUORUM = \"hbase.zookeeper.quorum\";\n+    public static final String HBASE_CONFIGURATION_ZOOKEEPER_CLIENTPORT = \"hbase.zookeeper.property.clientPort\";\n+\n+    public static Configuration constructConfig(String zkq, int port) {\n+        Configuration conf = HBaseConfiguration.create();\n+        conf.set(HBASE_CONFIGURATION_ZOOKEEPER_QUORUM, zkq);\n+        conf.set(HBASE_CONFIGURATION_ZOOKEEPER_CLIENTPORT, Integer.toString(port));\n+        return conf;\n+    }\n+\n+    public static class Tabular {\n+        public static class Row implements Comparable<Row> {\n+            public List<String> cols;\n+\n+            public Row(String... cols) {\n+                assert cols.length > 0;\n+                this.cols = Arrays.asList(cols);\n+            }\n+\n+            @Override\n+            public int compareTo(Row o) {\n+                return cols.get(0).compareTo(o.cols.get(0));\n+            }\n+        }\n+\n+        public Set<Row> rows;\n+        public List<String> headers;\n+\n+        public Tabular(String... headers) {\n+            assert headers.length > 0;\n+            this.headers = Arrays.asList(headers);\n+            rows = new TreeSet<>();\n+        }\n+\n+        public void addRow(String... cols) {\n+            assert cols.length == headers.size();\n+            rows.add(new Row(cols));\n+        }\n+\n+        public List<String> getCol(int index) {\n+            assert index >= 0 && index < headers.size();\n+            List<String> result = new ArrayList<>(rows.size());\n+            for(final Row row : rows) {\n+                result.add(row.cols.get(index));\n+            }\n+            return result;\n+        }\n+    }\n+\n+    public static String printTabularResults(Tabular tabular) {\n+        List<Integer> lengths = new ArrayList<>(tabular.headers.size());\n+        for(int i = 0; i < tabular.headers.size(); ++i) {\n+            lengths.add(tabular.headers.get(i).length());\n+        }\n+        for(Tabular.Row row : tabular.rows) {\n+            for(int i = 0; i < row.cols.size(); ++i) {\n+                if(lengths.get(i) < row.cols.get(i).length()) {\n+                    lengths.set(i, row.cols.get(i).length());\n+                }\n+            }\n+        }\n+\n+        List<String> formats = new ArrayList<>(lengths.size());\n+        for(Integer length : lengths) {\n+            formats.add(\"%-\" + (length + 5) + \"s\");\n+        }\n+\n+        StringBuilder stringBuilder = new StringBuilder();\n+        for(int i = 0; i < tabular.headers.size(); ++i) {\n+            stringBuilder.append(Colored.boldWhite(String.format(formats.get(i), tabular.headers.get(i))));\n+        }\n+        stringBuilder.append(\"\\n\");\n+        int totalLength = lengths.stream().reduce(0, Integer::sum);\n+        totalLength += 5 * lengths.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NjQyMA==", "bodyText": "woah these are some sweet util classes! i'm not sure maybe we would want a way to disable coloring for some weird terminals / file forwarding", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462596420", "createdAt": "2020-07-29T21:20:51Z", "author": {"login": "martinrupp"}, "path": "splice_ck/src/main/java/com/splicemachine/ck/Utils.java", "diffHunk": "@@ -0,0 +1,206 @@\n+package com.splicemachine.ck;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.services.io.StoredFormatIds;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.iapi.types.TypeId;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.TableNotFoundException;\n+\n+import java.io.UncheckedIOException;\n+import java.util.*;\n+\n+import static com.splicemachine.db.iapi.types.TypeId.BOOLEAN_NAME;\n+\n+public class Utils {\n+\n+    public static final String HBASE_CONFIGURATION_ZOOKEEPER_QUORUM = \"hbase.zookeeper.quorum\";\n+    public static final String HBASE_CONFIGURATION_ZOOKEEPER_CLIENTPORT = \"hbase.zookeeper.property.clientPort\";\n+\n+    public static Configuration constructConfig(String zkq, int port) {\n+        Configuration conf = HBaseConfiguration.create();\n+        conf.set(HBASE_CONFIGURATION_ZOOKEEPER_QUORUM, zkq);\n+        conf.set(HBASE_CONFIGURATION_ZOOKEEPER_CLIENTPORT, Integer.toString(port));\n+        return conf;\n+    }\n+\n+    public static class Tabular {\n+        public static class Row implements Comparable<Row> {\n+            public List<String> cols;\n+\n+            public Row(String... cols) {\n+                assert cols.length > 0;\n+                this.cols = Arrays.asList(cols);\n+            }\n+\n+            @Override\n+            public int compareTo(Row o) {\n+                return cols.get(0).compareTo(o.cols.get(0));\n+            }\n+        }\n+\n+        public Set<Row> rows;\n+        public List<String> headers;\n+\n+        public Tabular(String... headers) {\n+            assert headers.length > 0;\n+            this.headers = Arrays.asList(headers);\n+            rows = new TreeSet<>();\n+        }\n+\n+        public void addRow(String... cols) {\n+            assert cols.length == headers.size();\n+            rows.add(new Row(cols));\n+        }\n+\n+        public List<String> getCol(int index) {\n+            assert index >= 0 && index < headers.size();\n+            List<String> result = new ArrayList<>(rows.size());\n+            for(final Row row : rows) {\n+                result.add(row.cols.get(index));\n+            }\n+            return result;\n+        }\n+    }\n+\n+    public static String printTabularResults(Tabular tabular) {\n+        List<Integer> lengths = new ArrayList<>(tabular.headers.size());\n+        for(int i = 0; i < tabular.headers.size(); ++i) {\n+            lengths.add(tabular.headers.get(i).length());\n+        }\n+        for(Tabular.Row row : tabular.rows) {\n+            for(int i = 0; i < row.cols.size(); ++i) {\n+                if(lengths.get(i) < row.cols.get(i).length()) {\n+                    lengths.set(i, row.cols.get(i).length());\n+                }\n+            }\n+        }\n+\n+        List<String> formats = new ArrayList<>(lengths.size());\n+        for(Integer length : lengths) {\n+            formats.add(\"%-\" + (length + 5) + \"s\");\n+        }\n+\n+        StringBuilder stringBuilder = new StringBuilder();\n+        for(int i = 0; i < tabular.headers.size(); ++i) {\n+            stringBuilder.append(Colored.boldWhite(String.format(formats.get(i), tabular.headers.get(i))));\n+        }\n+        stringBuilder.append(\"\\n\");\n+        int totalLength = lengths.stream().reduce(0, Integer::sum);\n+        totalLength += 5 * lengths.size();\n+        String separate = new String(new char[totalLength]).replace(\"\\0\", \"=\");\n+        stringBuilder.append(Colored.boldWhite(separate)).append(\"\\n\");\n+        for(Tabular.Row row : tabular.rows) {\n+            for(int i = 0; i < row.cols.size(); ++i) {\n+                stringBuilder.append(String.format(formats.get(i), row.cols.get(i)));\n+            }\n+            stringBuilder.append(\"\\n\");\n+        }\n+        return stringBuilder.toString();\n+    }\n+\n+    public static String toString(ExecRow er) throws StandardException {\n+        StringJoiner joiner = new StringJoiner(\",\");\n+        for(int i = 1; i <= er.nColumns(); ++i) {\n+            joiner.add(er.getColumn(i).toString());\n+        }\n+        return joiner.toString();\n+    }\n+\n+    public enum SQLType { BOOLEAN, TINYINT, SMALLINT, INT, BIGINT, DOUBLE, REAL, NUMERIC,\n+        DECIMAL, CHAR, VARCHAR, REF, TIMESTAMP, DATE, TIME, LONG_VARCHAR, BLOB, CLOB, BIT,\n+        VARBIT, LONGVARBIT, XML, LIST, UNKNOWN }\n+\n+    private static Map<String, SQLType> typeMap;\n+    static {\n+        typeMap = new HashMap<>();\n+        typeMap.put(TypeId.BOOLEAN_NAME, SQLType.BOOLEAN);\n+        typeMap.put(TypeId.TINYINT_NAME, SQLType.TINYINT);\n+        typeMap.put(TypeId.SMALLINT_NAME, SQLType.SMALLINT);\n+        typeMap.put(TypeId.INTEGER_NAME, SQLType.INT);\n+        typeMap.put(TypeId.LONGINT_NAME, SQLType.BIGINT);\n+        typeMap.put(TypeId.DECIMAL_NAME, SQLType.DECIMAL);\n+        typeMap.put(TypeId.NUMERIC_NAME, SQLType.NUMERIC);\n+        typeMap.put(TypeId.DOUBLE_NAME, SQLType.DOUBLE);\n+        typeMap.put(TypeId.REAL_NAME, SQLType.REAL);\n+        typeMap.put(TypeId.CHAR_NAME, SQLType.CHAR);\n+        typeMap.put(TypeId.VARCHAR_NAME, SQLType.VARCHAR);\n+        typeMap.put(TypeId.REF_NAME, SQLType.REF);\n+        typeMap.put(TypeId.LONGVARCHAR_NAME, SQLType.LONG_VARCHAR);\n+        typeMap.put(TypeId.BLOB_NAME, SQLType.BLOB);\n+        typeMap.put(TypeId.CLOB_NAME, SQLType.CLOB);\n+        typeMap.put(TypeId.DATE_NAME, SQLType.DATE);\n+        typeMap.put(TypeId.TIME_NAME, SQLType.TIME);\n+        typeMap.put(TypeId.TIMESTAMP_NAME, SQLType.TIMESTAMP);\n+        typeMap.put(TypeId.BIT_NAME, SQLType.BIT);\n+        typeMap.put(TypeId.VARBIT_NAME, SQLType.VARBIT);\n+        typeMap.put(TypeId.LONGVARBIT_NAME, SQLType.LONGVARBIT);\n+        typeMap.put(TypeId.XML_NAME, SQLType.XML);\n+        typeMap.put(TypeId.LIST_NAME, SQLType.LIST);\n+    }\n+\n+    public static SQLType[] toSQLTypeArray(List<String> values) {\n+        SQLType[] result = new SQLType[values.size()];\n+        int cnt = 0;\n+        for(String value : values) {\n+            result[cnt++] = typeMap.get(value);\n+        }\n+        return result;\n+    }\n+\n+    public static class Colored {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5ODM2Nw==", "bodyText": "too long line", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462598367", "createdAt": "2020-07-29T21:24:56Z", "author": {"login": "martinrupp"}, "path": "splice_ck/src/main/java/com/splicemachine/ck/visitor/CellPrinter.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.splicemachine.ck.visitor;\n+\n+import com.splicemachine.ck.Utils;\n+import com.splicemachine.ck.decoder.UserDataDecoder;\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import org.apache.hadoop.hbase.Cell;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+public class CellPrinter extends ICellVisitor {\n+\n+    private final UserDataDecoder decoder;\n+    StringBuilder stringBuilder;\n+    SortedMap<Long, List<String>> events;\n+\n+    public CellPrinter(UserDataDecoder decoder) {\n+        this.decoder = decoder;\n+        this.stringBuilder = new StringBuilder();\n+        events = new TreeMap<>();\n+    }\n+\n+    public String getOutput() {\n+        StringBuilder sb = new StringBuilder();\n+        for (long event : events.keySet()) {\n+            sb.append(Utils.Colored.boldWhite(\"at: \")).append(Utils.Colored.boldWhite(Long.toString(event))).append(\"\\n\");\n+            for(String eventResult : events.get(event)) {\n+                sb.append(\"\\t\").append(eventResult).append(\"\\n\");\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    protected void preVisit(Cell cell) {\n+        stringBuilder.setLength(0);\n+    }\n+\n+    @Override\n+    protected void postVisit(Cell cell) {\n+        Long key = cell.getTimestamp();\n+        events.computeIfAbsent(key, k -> new ArrayList<>());\n+        events.get(key).add(stringBuilder.toString());\n+    }\n+\n+    @Override\n+    public void visitCommitTimestamp(Cell cell) {\n+        stringBuilder.append(Utils.Colored.green(\"commit timestamp \"));\n+        stringBuilder.append(Utils.Colored.green(Long.toString(com.splicemachine.primitives.Bytes.toLong(cell.getValueArray(),cell.getValueOffset(),cell.getValueLength()))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536"}, "originalPosition": 52}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1535b5f8017fca7821722ca99a83d14deb779ee8", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/1535b5f8017fca7821722ca99a83d14deb779ee8", "committedDate": "2020-07-31T17:23:40Z", "message": "DB-9883 add more commands, fixes, refactoring.\n\n- add txlist command which prints the splice_txn table.\n- add rput command which allows the user to modify a hbase row.\n- refatoring, bug fixes, code simplifications."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "02a1521bd3b87e72d8fdcd285d2e17f4fc9134b7", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/02a1521bd3b87e72d8fdcd285d2e17f4fc9134b7", "committedDate": "2020-07-31T17:20:07Z", "message": "DB-9883 add more commands, fixes, refactoring.\n\n- add txlist command which prints the splice_txn table.\n- add rput command which allows the user to modify a hbase row.\n- refatoring, bug fixes, code simplifications."}, "afterCommit": {"oid": "1535b5f8017fca7821722ca99a83d14deb779ee8", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/1535b5f8017fca7821722ca99a83d14deb779ee8", "committedDate": "2020-07-31T17:23:40Z", "message": "DB-9883 add more commands, fixes, refactoring.\n\n- add txlist command which prints the splice_txn table.\n- add rput command which allows the user to modify a hbase row.\n- refatoring, bug fixes, code simplifications."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1b61c9d8cbdeaa6afd96d26f5a149b94cd71b69", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/f1b61c9d8cbdeaa6afd96d26f5a149b94cd71b69", "committedDate": "2020-08-03T11:22:32Z", "message": "DB-9883 use decoder bitset to check if values are set.\n\n- rget now distinguishes between non-set values and NULL-set\n  values.\n- this is relevant when printing partial row updates where some\n  values are not set, previously they were printed as NULL, now\n  '[]' is printed instead."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e01c74f568173c80576e7a5e88b99addab34aeb", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/0e01c74f568173c80576e7a5e88b99addab34aeb", "committedDate": "2020-08-03T14:44:40Z", "message": "DB-9883 refactoring."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e2da4888d5981cd0761d1c696f4391a108abb20", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/1e2da4888d5981cd0761d1c696f4391a108abb20", "committedDate": "2020-08-03T16:18:51Z", "message": "DB-9883 Add license note to files."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8aa7b907a91949a0c486004594af9d35e9072548", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/8aa7b907a91949a0c486004594af9d35e9072548", "committedDate": "2020-08-03T17:39:46Z", "message": "DB-9883 addressed spotbug issues and comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bc6336b91a5f9a92a9560abde935b75528bb099", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/1bc6336b91a5f9a92a9560abde935b75528bb099", "committedDate": "2020-08-03T17:50:42Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9883"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c02f63af6d765e9e2077578b2769a938d9af111", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/1c02f63af6d765e9e2077578b2769a938d9af111", "committedDate": "2020-08-03T18:00:24Z", "message": "DB-9883 manually update the parent version in splice-ck pom.xml."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11b2e022c227cf0c2c32453c78f69c1935cf24bd", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/11b2e022c227cf0c2c32453c78f69c1935cf24bd", "committedDate": "2020-08-03T18:13:00Z", "message": "DB-9883 move splice-ck from core to cdh*, hdp* and dbaas profiles."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNTkzNTQ1", "url": "https://github.com/splicemachine/spliceengine/pull/3905#pullrequestreview-460593545", "createdAt": "2020-08-04T08:15:03Z", "commit": {"oid": "11b2e022c227cf0c2c32453c78f69c1935cf24bd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwODoxNTowNFrOG7V9JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwODo1Mzo1MVrOG7XW_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3ODg4NQ==", "bodyText": "Remove", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464878885", "createdAt": "2020-08-04T08:15:04Z", "author": {"login": "arnaud-splice"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/utils/marshall/EntryDataDecoder.java", "diffHunk": "@@ -26,6 +26,7 @@\n import com.splicemachine.db.iapi.error.StandardException;\n import com.splicemachine.db.iapi.sql.execute.ExecRow;\n import com.splicemachine.db.iapi.types.DataValueDescriptor;\n+import org.apache.spark.sql.Row;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11b2e022c227cf0c2c32453c78f69c1935cf24bd"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg4MzEwNw==", "bodyText": "This help message does not seem to match what's happening: running ./sck.sh --platform=cdh6.3.0 gives me Unknown option: '--platform=cdh6.3.0'", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464883107", "createdAt": "2020-08-04T08:22:22Z", "author": {"login": "arnaud-splice"}, "path": "sck.sh", "diffHunk": "@@ -0,0 +1,22 @@\n+#!/bin/bash\n+\n+platform=cdh6.3.0\n+\n+function help() {\n+  echo \"sck.sh [--platform=<platform>] command\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11b2e022c227cf0c2c32453c78f69c1935cf24bd"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg5NTA0Mw==", "bodyText": "I would add quite the disclaimer here, informing that doing so may compromise data integrity, break our MVCC model, etc.", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464895043", "createdAt": "2020-08-04T08:42:29Z", "author": {"login": "arnaud-splice"}, "path": "splice_ck/src/main/java/com/splicemachine/ck/command/RPutCommand.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.ck.command;\n+\n+import com.splicemachine.ck.HBaseInspector;\n+import com.splicemachine.ck.Utils;\n+import com.splicemachine.ck.encoder.RPutConfigBuilder;\n+import org.apache.commons.lang3.StringUtils;\n+import picocli.CommandLine;\n+\n+import java.util.concurrent.Callable;\n+\n+\n+@CommandLine.Command(name = \"rput\",\n+        description = \"modify HBase row\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11b2e022c227cf0c2c32453c78f69c1935cf24bd"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg5NzMyNg==", "bodyText": "If a table exists in multiple schemas, this will always select the latest one. It'd be nice to be able to specify the schema. We'd need to find a way to distinguish between the schema in which the table resides and the schema you already use here (boolean, int, etc.)\nAlso, table names and schema names should be normalised (EngineUtils.validateTable, EngineUtils.validateSchema) so that the end user can write t2 instead of T2 for example.", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464897326", "createdAt": "2020-08-04T08:46:11Z", "author": {"login": "arnaud-splice"}, "path": "splice_ck/src/main/java/com/splicemachine/ck/command/RGetCommand.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11b2e022c227cf0c2c32453c78f69c1935cf24bd"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwMDU2Nw==", "bodyText": "The helper message lets the user believe that -l prints coloured output whereas it disabled colours on my side.", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464900567", "createdAt": "2020-08-04T08:51:33Z", "author": {"login": "arnaud-splice"}, "path": "splice_ck/src/main/java/com/splicemachine/ck/Utils.java", "diffHunk": "@@ -0,0 +1,206 @@\n+package com.splicemachine.ck;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.services.io.StoredFormatIds;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.iapi.types.TypeId;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.TableNotFoundException;\n+\n+import java.io.UncheckedIOException;\n+import java.util.*;\n+\n+import static com.splicemachine.db.iapi.types.TypeId.BOOLEAN_NAME;\n+\n+public class Utils {\n+\n+    public static final String HBASE_CONFIGURATION_ZOOKEEPER_QUORUM = \"hbase.zookeeper.quorum\";\n+    public static final String HBASE_CONFIGURATION_ZOOKEEPER_CLIENTPORT = \"hbase.zookeeper.property.clientPort\";\n+\n+    public static Configuration constructConfig(String zkq, int port) {\n+        Configuration conf = HBaseConfiguration.create();\n+        conf.set(HBASE_CONFIGURATION_ZOOKEEPER_QUORUM, zkq);\n+        conf.set(HBASE_CONFIGURATION_ZOOKEEPER_CLIENTPORT, Integer.toString(port));\n+        return conf;\n+    }\n+\n+    public static class Tabular {\n+        public static class Row implements Comparable<Row> {\n+            public List<String> cols;\n+\n+            public Row(String... cols) {\n+                assert cols.length > 0;\n+                this.cols = Arrays.asList(cols);\n+            }\n+\n+            @Override\n+            public int compareTo(Row o) {\n+                return cols.get(0).compareTo(o.cols.get(0));\n+            }\n+        }\n+\n+        public Set<Row> rows;\n+        public List<String> headers;\n+\n+        public Tabular(String... headers) {\n+            assert headers.length > 0;\n+            this.headers = Arrays.asList(headers);\n+            rows = new TreeSet<>();\n+        }\n+\n+        public void addRow(String... cols) {\n+            assert cols.length == headers.size();\n+            rows.add(new Row(cols));\n+        }\n+\n+        public List<String> getCol(int index) {\n+            assert index >= 0 && index < headers.size();\n+            List<String> result = new ArrayList<>(rows.size());\n+            for(final Row row : rows) {\n+                result.add(row.cols.get(index));\n+            }\n+            return result;\n+        }\n+    }\n+\n+    public static String printTabularResults(Tabular tabular) {\n+        List<Integer> lengths = new ArrayList<>(tabular.headers.size());\n+        for(int i = 0; i < tabular.headers.size(); ++i) {\n+            lengths.add(tabular.headers.get(i).length());\n+        }\n+        for(Tabular.Row row : tabular.rows) {\n+            for(int i = 0; i < row.cols.size(); ++i) {\n+                if(lengths.get(i) < row.cols.get(i).length()) {\n+                    lengths.set(i, row.cols.get(i).length());\n+                }\n+            }\n+        }\n+\n+        List<String> formats = new ArrayList<>(lengths.size());\n+        for(Integer length : lengths) {\n+            formats.add(\"%-\" + (length + 5) + \"s\");\n+        }\n+\n+        StringBuilder stringBuilder = new StringBuilder();\n+        for(int i = 0; i < tabular.headers.size(); ++i) {\n+            stringBuilder.append(Colored.boldWhite(String.format(formats.get(i), tabular.headers.get(i))));\n+        }\n+        stringBuilder.append(\"\\n\");\n+        int totalLength = lengths.stream().reduce(0, Integer::sum);\n+        totalLength += 5 * lengths.size();\n+        String separate = new String(new char[totalLength]).replace(\"\\0\", \"=\");\n+        stringBuilder.append(Colored.boldWhite(separate)).append(\"\\n\");\n+        for(Tabular.Row row : tabular.rows) {\n+            for(int i = 0; i < row.cols.size(); ++i) {\n+                stringBuilder.append(String.format(formats.get(i), row.cols.get(i)));\n+            }\n+            stringBuilder.append(\"\\n\");\n+        }\n+        return stringBuilder.toString();\n+    }\n+\n+    public static String toString(ExecRow er) throws StandardException {\n+        StringJoiner joiner = new StringJoiner(\",\");\n+        for(int i = 1; i <= er.nColumns(); ++i) {\n+            joiner.add(er.getColumn(i).toString());\n+        }\n+        return joiner.toString();\n+    }\n+\n+    public enum SQLType { BOOLEAN, TINYINT, SMALLINT, INT, BIGINT, DOUBLE, REAL, NUMERIC,\n+        DECIMAL, CHAR, VARCHAR, REF, TIMESTAMP, DATE, TIME, LONG_VARCHAR, BLOB, CLOB, BIT,\n+        VARBIT, LONGVARBIT, XML, LIST, UNKNOWN }\n+\n+    private static Map<String, SQLType> typeMap;\n+    static {\n+        typeMap = new HashMap<>();\n+        typeMap.put(TypeId.BOOLEAN_NAME, SQLType.BOOLEAN);\n+        typeMap.put(TypeId.TINYINT_NAME, SQLType.TINYINT);\n+        typeMap.put(TypeId.SMALLINT_NAME, SQLType.SMALLINT);\n+        typeMap.put(TypeId.INTEGER_NAME, SQLType.INT);\n+        typeMap.put(TypeId.LONGINT_NAME, SQLType.BIGINT);\n+        typeMap.put(TypeId.DECIMAL_NAME, SQLType.DECIMAL);\n+        typeMap.put(TypeId.NUMERIC_NAME, SQLType.NUMERIC);\n+        typeMap.put(TypeId.DOUBLE_NAME, SQLType.DOUBLE);\n+        typeMap.put(TypeId.REAL_NAME, SQLType.REAL);\n+        typeMap.put(TypeId.CHAR_NAME, SQLType.CHAR);\n+        typeMap.put(TypeId.VARCHAR_NAME, SQLType.VARCHAR);\n+        typeMap.put(TypeId.REF_NAME, SQLType.REF);\n+        typeMap.put(TypeId.LONGVARCHAR_NAME, SQLType.LONG_VARCHAR);\n+        typeMap.put(TypeId.BLOB_NAME, SQLType.BLOB);\n+        typeMap.put(TypeId.CLOB_NAME, SQLType.CLOB);\n+        typeMap.put(TypeId.DATE_NAME, SQLType.DATE);\n+        typeMap.put(TypeId.TIME_NAME, SQLType.TIME);\n+        typeMap.put(TypeId.TIMESTAMP_NAME, SQLType.TIMESTAMP);\n+        typeMap.put(TypeId.BIT_NAME, SQLType.BIT);\n+        typeMap.put(TypeId.VARBIT_NAME, SQLType.VARBIT);\n+        typeMap.put(TypeId.LONGVARBIT_NAME, SQLType.LONGVARBIT);\n+        typeMap.put(TypeId.XML_NAME, SQLType.XML);\n+        typeMap.put(TypeId.LIST_NAME, SQLType.LIST);\n+    }\n+\n+    public static SQLType[] toSQLTypeArray(List<String> values) {\n+        SQLType[] result = new SQLType[values.size()];\n+        int cnt = 0;\n+        for(String value : values) {\n+            result[cnt++] = typeMap.get(value);\n+        }\n+        return result;\n+    }\n+\n+    public static class Colored {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NjQyMA=="}, "originalCommit": {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwMTg4NA==", "bodyText": "The same goes for verbose. It seems enabled by default and -v disables it.\nI'd suggest to have colours enabled, verbose disabled, and the respective options to toggle that.", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464901884", "createdAt": "2020-08-04T08:53:51Z", "author": {"login": "arnaud-splice"}, "path": "splice_ck/src/main/java/com/splicemachine/ck/Utils.java", "diffHunk": "@@ -0,0 +1,206 @@\n+package com.splicemachine.ck;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.services.io.StoredFormatIds;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.iapi.types.TypeId;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.TableNotFoundException;\n+\n+import java.io.UncheckedIOException;\n+import java.util.*;\n+\n+import static com.splicemachine.db.iapi.types.TypeId.BOOLEAN_NAME;\n+\n+public class Utils {\n+\n+    public static final String HBASE_CONFIGURATION_ZOOKEEPER_QUORUM = \"hbase.zookeeper.quorum\";\n+    public static final String HBASE_CONFIGURATION_ZOOKEEPER_CLIENTPORT = \"hbase.zookeeper.property.clientPort\";\n+\n+    public static Configuration constructConfig(String zkq, int port) {\n+        Configuration conf = HBaseConfiguration.create();\n+        conf.set(HBASE_CONFIGURATION_ZOOKEEPER_QUORUM, zkq);\n+        conf.set(HBASE_CONFIGURATION_ZOOKEEPER_CLIENTPORT, Integer.toString(port));\n+        return conf;\n+    }\n+\n+    public static class Tabular {\n+        public static class Row implements Comparable<Row> {\n+            public List<String> cols;\n+\n+            public Row(String... cols) {\n+                assert cols.length > 0;\n+                this.cols = Arrays.asList(cols);\n+            }\n+\n+            @Override\n+            public int compareTo(Row o) {\n+                return cols.get(0).compareTo(o.cols.get(0));\n+            }\n+        }\n+\n+        public Set<Row> rows;\n+        public List<String> headers;\n+\n+        public Tabular(String... headers) {\n+            assert headers.length > 0;\n+            this.headers = Arrays.asList(headers);\n+            rows = new TreeSet<>();\n+        }\n+\n+        public void addRow(String... cols) {\n+            assert cols.length == headers.size();\n+            rows.add(new Row(cols));\n+        }\n+\n+        public List<String> getCol(int index) {\n+            assert index >= 0 && index < headers.size();\n+            List<String> result = new ArrayList<>(rows.size());\n+            for(final Row row : rows) {\n+                result.add(row.cols.get(index));\n+            }\n+            return result;\n+        }\n+    }\n+\n+    public static String printTabularResults(Tabular tabular) {\n+        List<Integer> lengths = new ArrayList<>(tabular.headers.size());\n+        for(int i = 0; i < tabular.headers.size(); ++i) {\n+            lengths.add(tabular.headers.get(i).length());\n+        }\n+        for(Tabular.Row row : tabular.rows) {\n+            for(int i = 0; i < row.cols.size(); ++i) {\n+                if(lengths.get(i) < row.cols.get(i).length()) {\n+                    lengths.set(i, row.cols.get(i).length());\n+                }\n+            }\n+        }\n+\n+        List<String> formats = new ArrayList<>(lengths.size());\n+        for(Integer length : lengths) {\n+            formats.add(\"%-\" + (length + 5) + \"s\");\n+        }\n+\n+        StringBuilder stringBuilder = new StringBuilder();\n+        for(int i = 0; i < tabular.headers.size(); ++i) {\n+            stringBuilder.append(Colored.boldWhite(String.format(formats.get(i), tabular.headers.get(i))));\n+        }\n+        stringBuilder.append(\"\\n\");\n+        int totalLength = lengths.stream().reduce(0, Integer::sum);\n+        totalLength += 5 * lengths.size();\n+        String separate = new String(new char[totalLength]).replace(\"\\0\", \"=\");\n+        stringBuilder.append(Colored.boldWhite(separate)).append(\"\\n\");\n+        for(Tabular.Row row : tabular.rows) {\n+            for(int i = 0; i < row.cols.size(); ++i) {\n+                stringBuilder.append(String.format(formats.get(i), row.cols.get(i)));\n+            }\n+            stringBuilder.append(\"\\n\");\n+        }\n+        return stringBuilder.toString();\n+    }\n+\n+    public static String toString(ExecRow er) throws StandardException {\n+        StringJoiner joiner = new StringJoiner(\",\");\n+        for(int i = 1; i <= er.nColumns(); ++i) {\n+            joiner.add(er.getColumn(i).toString());\n+        }\n+        return joiner.toString();\n+    }\n+\n+    public enum SQLType { BOOLEAN, TINYINT, SMALLINT, INT, BIGINT, DOUBLE, REAL, NUMERIC,\n+        DECIMAL, CHAR, VARCHAR, REF, TIMESTAMP, DATE, TIME, LONG_VARCHAR, BLOB, CLOB, BIT,\n+        VARBIT, LONGVARBIT, XML, LIST, UNKNOWN }\n+\n+    private static Map<String, SQLType> typeMap;\n+    static {\n+        typeMap = new HashMap<>();\n+        typeMap.put(TypeId.BOOLEAN_NAME, SQLType.BOOLEAN);\n+        typeMap.put(TypeId.TINYINT_NAME, SQLType.TINYINT);\n+        typeMap.put(TypeId.SMALLINT_NAME, SQLType.SMALLINT);\n+        typeMap.put(TypeId.INTEGER_NAME, SQLType.INT);\n+        typeMap.put(TypeId.LONGINT_NAME, SQLType.BIGINT);\n+        typeMap.put(TypeId.DECIMAL_NAME, SQLType.DECIMAL);\n+        typeMap.put(TypeId.NUMERIC_NAME, SQLType.NUMERIC);\n+        typeMap.put(TypeId.DOUBLE_NAME, SQLType.DOUBLE);\n+        typeMap.put(TypeId.REAL_NAME, SQLType.REAL);\n+        typeMap.put(TypeId.CHAR_NAME, SQLType.CHAR);\n+        typeMap.put(TypeId.VARCHAR_NAME, SQLType.VARCHAR);\n+        typeMap.put(TypeId.REF_NAME, SQLType.REF);\n+        typeMap.put(TypeId.LONGVARCHAR_NAME, SQLType.LONG_VARCHAR);\n+        typeMap.put(TypeId.BLOB_NAME, SQLType.BLOB);\n+        typeMap.put(TypeId.CLOB_NAME, SQLType.CLOB);\n+        typeMap.put(TypeId.DATE_NAME, SQLType.DATE);\n+        typeMap.put(TypeId.TIME_NAME, SQLType.TIME);\n+        typeMap.put(TypeId.TIMESTAMP_NAME, SQLType.TIMESTAMP);\n+        typeMap.put(TypeId.BIT_NAME, SQLType.BIT);\n+        typeMap.put(TypeId.VARBIT_NAME, SQLType.VARBIT);\n+        typeMap.put(TypeId.LONGVARBIT_NAME, SQLType.LONGVARBIT);\n+        typeMap.put(TypeId.XML_NAME, SQLType.XML);\n+        typeMap.put(TypeId.LIST_NAME, SQLType.LIST);\n+    }\n+\n+    public static SQLType[] toSQLTypeArray(List<String> values) {\n+        SQLType[] result = new SQLType[values.size()];\n+        int cnt = 0;\n+        for(String value : values) {\n+            result[cnt++] = typeMap.get(value);\n+        }\n+        return result;\n+    }\n+\n+    public static class Colored {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NjQyMA=="}, "originalCommit": {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536"}, "originalPosition": 152}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64cc90a205b4762565cbeec216c329eb39e111d8", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/64cc90a205b4762565cbeec216c329eb39e111d8", "committedDate": "2020-08-04T08:55:53Z", "message": "DB-9883 address spotbugs issues."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ea4ecf571c50534d2ea48fd4585075500d92efb", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/1ea4ecf571c50534d2ea48fd4585075500d92efb", "committedDate": "2020-08-04T14:40:57Z", "message": "DB-9883 Addressed comments, refactoring.\n\n- new command: slist, which views schemas is added."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDM2MDY0", "url": "https://github.com/splicemachine/spliceengine/pull/3905#pullrequestreview-461036064", "createdAt": "2020-08-04T17:48:04Z", "commit": {"oid": "1ea4ecf571c50534d2ea48fd4585075500d92efb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMjc0MjMy", "url": "https://github.com/splicemachine/spliceengine/pull/3905#pullrequestreview-463274232", "createdAt": "2020-08-07T12:32:51Z", "commit": {"oid": "1ea4ecf571c50534d2ea48fd4585075500d92efb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11d67acbde137eeb50f3a81e4ac1476165c301ba", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/11d67acbde137eeb50f3a81e4ac1476165c301ba", "committedDate": "2020-08-11T09:21:38Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9883"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "420dff4f42926399e485d30e644e3ab6337fb337", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/420dff4f42926399e485d30e644e3ab6337fb337", "committedDate": "2020-08-11T10:59:57Z", "message": "DB-9883 update parent version in splice_ck pom."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cc78ae6350c310f4aaf96a219fcc49419a9bd7d", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/1cc78ae6350c310f4aaf96a219fcc49419a9bd7d", "committedDate": "2020-08-14T08:56:16Z", "message": "DB-9883 change license to GNU Affero."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13dfd114056dfe48fc900aa63f895e1d5894cfd0", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/13dfd114056dfe48fc900aa63f895e1d5894cfd0", "committedDate": "2020-08-14T10:03:15Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9883"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTUzMzk0", "url": "https://github.com/splicemachine/spliceengine/pull/3905#pullrequestreview-468953394", "createdAt": "2020-08-18T02:43:20Z", "commit": {"oid": "13dfd114056dfe48fc900aa63f895e1d5894cfd0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1209, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}