{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5OTMzNTA0", "number": 4380, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwNDoxNTo1NFrOEyLRUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwOTozODoyMFrOEyQnKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMDQ4OTE0OnYy", "diffSide": "RIGHT", "path": "db-engine/src/test/java/com/splicemachine/db/impl/sql/SerializationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwNDoxNTo1NFrOHoq1Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxMDowMDoxNVrOHoz6VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQwNjg3OQ==", "bodyText": "Should this be uncommented?", "url": "https://github.com/splicemachine/spliceengine/pull/4380#discussion_r512406879", "createdAt": "2020-10-27T04:15:54Z", "author": {"login": "jyuanca"}, "path": "db-engine/src/test/java/com/splicemachine/db/impl/sql/SerializationTest.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package com.splicemachine.db.impl.sql;\n+\n+import com.splicemachine.db.iapi.sql.ResultColumnDescriptor;\n+import com.splicemachine.db.iapi.types.DataTypeDescriptor;\n+import com.splicemachine.db.iapi.types.TypeId;\n+import org.apache.spark.sql.types.StructField;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.io.*;\n+import java.sql.Types;\n+import java.util.Arrays;\n+\n+public class SerializationTest {\n+\n+    static class CustomResultColumnDescriptor implements ResultColumnDescriptor {\n+\n+        String sourceTableName, sourceSchemaName, name;\n+        int iColPos;\n+        DataTypeDescriptor type;\n+        boolean bUpdateableByCursor, bAutoIncrement, bHasGenerationClause;\n+\n+        public CustomResultColumnDescriptor(String name, String sourceTableName, String sourceSchemaName, int iColPos,\n+                                            DataTypeDescriptor type,\n+                                            boolean bAutoIncrement, boolean bUpdateableByCursor, boolean bHasGenerationClause) {\n+            this.name = name;\n+            this.sourceTableName = sourceTableName;\n+            this.sourceSchemaName = sourceSchemaName;\n+            this.iColPos = iColPos;\n+            this.type = type;\n+            this.bAutoIncrement = bAutoIncrement;\n+            this.bUpdateableByCursor = bUpdateableByCursor;\n+            this.bHasGenerationClause = bHasGenerationClause;\n+        }\n+\n+        @Override\n+        public DataTypeDescriptor getType() {\n+            return type;\n+        }\n+\n+        @Override\n+        public StructField getStructField() {\n+            Assert.fail(\"not expected call of getStructField\");\n+            return null;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public String getSourceSchemaName() {\n+            return sourceSchemaName;\n+        }\n+\n+        @Override\n+        public String getSourceTableName() {\n+            return sourceTableName;\n+        }\n+\n+        @Override\n+        public boolean updatableByCursor() {\n+            return bUpdateableByCursor;\n+        }\n+\n+        @Override\n+        public int getColumnPosition() {\n+            return iColPos;\n+        }\n+\n+        @Override\n+        public boolean isAutoincrement() {\n+            return bAutoIncrement;\n+        }\n+\n+        @Override\n+        public boolean hasGenerationClause() {\n+            return bHasGenerationClause;\n+        }\n+\n+        public static GenericColumnDescriptor sample1() {\n+            return new GenericColumnDescriptor(new CustomResultColumnDescriptor(\n+                    \"name\", \"tabName\", \"schemaName\", 3,\n+                    new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.DECIMAL), true, 10),\n+                    true, true, true)\n+            );\n+        }\n+        public static GenericColumnDescriptor sample2() {\n+            return new GenericColumnDescriptor(new CustomResultColumnDescriptor(\n+                    \"sample2name\", \"atable\", \"SPLICE\", 9,\n+                    new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.DOUBLE), false, 5),\n+                    false, false, false)\n+            );\n+        }\n+\n+        public static void assertEquals(ResultColumnDescriptor rcd1, ResultColumnDescriptor rcd2)\n+        {\n+            Assert.assertEquals(rcd1.getSourceSchemaName(), rcd2.getSourceSchemaName());\n+            Assert.assertEquals(rcd1.getSourceTableName(), rcd2.getSourceTableName());\n+            Assert.assertEquals(rcd1.getName(), rcd2.getName());\n+\n+            Assert.assertEquals(rcd1.getType(), rcd2.getType());\n+            Assert.assertEquals(rcd1.getColumnPosition(), rcd2.getColumnPosition());\n+            Assert.assertEquals(rcd1.isAutoincrement(), rcd2.isAutoincrement());\n+            Assert.assertEquals(rcd1.updatableByCursor(), rcd2.updatableByCursor());\n+\n+            // check this in DB-10582\n+            // Assert.assertEquals(rcd1.hasGenerationClause(), rcd2.hasGenerationClause());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ea6b4fc1eedf667a6f28a2de634ae17772182ae"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU1NTYwNA==", "bodyText": "uncommenting it will result in a test failure. addressing this is not part of this PR, but shouldn't be ignored, that's why i created https://splicemachine.atlassian.net/browse/DB-10582 .", "url": "https://github.com/splicemachine/spliceengine/pull/4380#discussion_r512555604", "createdAt": "2020-10-27T10:00:15Z", "author": {"login": "martinrupp"}, "path": "db-engine/src/test/java/com/splicemachine/db/impl/sql/SerializationTest.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package com.splicemachine.db.impl.sql;\n+\n+import com.splicemachine.db.iapi.sql.ResultColumnDescriptor;\n+import com.splicemachine.db.iapi.types.DataTypeDescriptor;\n+import com.splicemachine.db.iapi.types.TypeId;\n+import org.apache.spark.sql.types.StructField;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.io.*;\n+import java.sql.Types;\n+import java.util.Arrays;\n+\n+public class SerializationTest {\n+\n+    static class CustomResultColumnDescriptor implements ResultColumnDescriptor {\n+\n+        String sourceTableName, sourceSchemaName, name;\n+        int iColPos;\n+        DataTypeDescriptor type;\n+        boolean bUpdateableByCursor, bAutoIncrement, bHasGenerationClause;\n+\n+        public CustomResultColumnDescriptor(String name, String sourceTableName, String sourceSchemaName, int iColPos,\n+                                            DataTypeDescriptor type,\n+                                            boolean bAutoIncrement, boolean bUpdateableByCursor, boolean bHasGenerationClause) {\n+            this.name = name;\n+            this.sourceTableName = sourceTableName;\n+            this.sourceSchemaName = sourceSchemaName;\n+            this.iColPos = iColPos;\n+            this.type = type;\n+            this.bAutoIncrement = bAutoIncrement;\n+            this.bUpdateableByCursor = bUpdateableByCursor;\n+            this.bHasGenerationClause = bHasGenerationClause;\n+        }\n+\n+        @Override\n+        public DataTypeDescriptor getType() {\n+            return type;\n+        }\n+\n+        @Override\n+        public StructField getStructField() {\n+            Assert.fail(\"not expected call of getStructField\");\n+            return null;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public String getSourceSchemaName() {\n+            return sourceSchemaName;\n+        }\n+\n+        @Override\n+        public String getSourceTableName() {\n+            return sourceTableName;\n+        }\n+\n+        @Override\n+        public boolean updatableByCursor() {\n+            return bUpdateableByCursor;\n+        }\n+\n+        @Override\n+        public int getColumnPosition() {\n+            return iColPos;\n+        }\n+\n+        @Override\n+        public boolean isAutoincrement() {\n+            return bAutoIncrement;\n+        }\n+\n+        @Override\n+        public boolean hasGenerationClause() {\n+            return bHasGenerationClause;\n+        }\n+\n+        public static GenericColumnDescriptor sample1() {\n+            return new GenericColumnDescriptor(new CustomResultColumnDescriptor(\n+                    \"name\", \"tabName\", \"schemaName\", 3,\n+                    new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.DECIMAL), true, 10),\n+                    true, true, true)\n+            );\n+        }\n+        public static GenericColumnDescriptor sample2() {\n+            return new GenericColumnDescriptor(new CustomResultColumnDescriptor(\n+                    \"sample2name\", \"atable\", \"SPLICE\", 9,\n+                    new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.DOUBLE), false, 5),\n+                    false, false, false)\n+            );\n+        }\n+\n+        public static void assertEquals(ResultColumnDescriptor rcd1, ResultColumnDescriptor rcd2)\n+        {\n+            Assert.assertEquals(rcd1.getSourceSchemaName(), rcd2.getSourceSchemaName());\n+            Assert.assertEquals(rcd1.getSourceTableName(), rcd2.getSourceTableName());\n+            Assert.assertEquals(rcd1.getName(), rcd2.getName());\n+\n+            Assert.assertEquals(rcd1.getType(), rcd2.getType());\n+            Assert.assertEquals(rcd1.getColumnPosition(), rcd2.getColumnPosition());\n+            Assert.assertEquals(rcd1.isAutoincrement(), rcd2.isAutoincrement());\n+            Assert.assertEquals(rcd1.updatableByCursor(), rcd2.updatableByCursor());\n+\n+            // check this in DB-10582\n+            // Assert.assertEquals(rcd1.hasGenerationClause(), rcd2.hasGenerationClause());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQwNjg3OQ=="}, "originalCommit": {"oid": "5ea6b4fc1eedf667a6f28a2de634ae17772182ae"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMTM2NDI1OnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/GenericStorablePreparedStatement.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwOTozODoyMVrOHozBLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwOTozODoyMVrOHozBLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU0MDk3Mg==", "bodyText": "Yes, this is strange, here is an example of ConstantAction implementation that doesn't implement the Externalizable interface", "url": "https://github.com/splicemachine/spliceengine/pull/4380#discussion_r512540972", "createdAt": "2020-10-27T09:38:21Z", "author": {"login": "hatyo"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/GenericStorablePreparedStatement.java", "diffHunk": "@@ -147,12 +148,15 @@ public ExecPreparedStatement getClone() throws StandardException {\n     //\n     /////////////////////////////////////////////////////////////\n \n+    @SuppressFBWarnings(\"DMI_NONSERIALIZABLE_OBJECT_WRITTEN\") // todo in DB-10583\n     @Override\n     public void writeExternal(ObjectOutput out) throws IOException {\n+\n+        // DANGER: do NOT change this serialization unless you have an upgrade script, see DB-10566\n         out.writeObject(getCursorInfo());\n         out.writeBoolean(needsSavepoint());\n         out.writeBoolean(isAtomic);\n-        out.writeObject(executionConstants);\n+        out.writeObject(executionConstants); // DB-10583", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ea6b4fc1eedf667a6f28a2de634ae17772182ae"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2838, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}