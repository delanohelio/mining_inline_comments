{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3OTU0NjE3", "number": 3811, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo0MTozMFrOEOm7hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo0MTozMFrOEOm7hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzUzMzUxOnYy", "diffSide": "RIGHT", "path": "hbase_sql/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/CreateTableTypeHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo0MTozMFrOGx2cUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTozODo0N1rOGx6L_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyNTM5Mw==", "bodyText": "I guess this could also be replaced by streams, but that's not blocking", "url": "https://github.com/splicemachine/spliceengine/pull/3811#discussion_r454925393", "createdAt": "2020-07-15T09:41:30Z", "author": {"login": "arnaud-splice"}, "path": "hbase_sql/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/CreateTableTypeHelper.java", "diffHunk": "@@ -0,0 +1,243 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import org.junit.Assert;\n+\n+import java.sql.Clob;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.function.Consumer;\n+import java.util.function.IntFunction;\n+import java.util.stream.Collectors;\n+\n+/// a helper class to define column types, and then create external tables and insert data into them\n+/// to make writing tests for all column types easier.\n+\n+public class CreateTableTypeHelper {\n+    /// @param types: an array of Types that should be used\n+    /// @param ivalues: an array of values to use. 0 is NULL value, all other values will\n+    /// generate corresponding entries that are somewhat associated with the integer val\n+    /// e.g. mostly if the int values increase, the corresponding e.g. date value also increases.\n+    public CreateTableTypeHelper(int[] types, int[] ivalues)\n+    {\n+        schema = Arrays.stream(types).mapToObj(this::getTypesName).collect(Collectors.joining(\", \"));\n+        suggestedTypes = Arrays.stream(types).mapToObj(this::getTypesNameInfered).collect(Collectors.joining(\", \"));\n+\n+        IntFunction<String> iValueStringFunc = ivalue -> Arrays.stream(types)\n+                .mapToObj(type -> getTypeValue(type, ivalue))\n+                .collect(Collectors.joining(\", \"));\n+\n+        values2 = Arrays.stream(ivalues).mapToObj(iValueStringFunc).sorted().collect(Collectors.toList());\n+        insertValues = Arrays.stream(ivalues).mapToObj(iValueStringFunc).map(s -> \"(\" + s + \")\").collect(Collectors.joining(\", \"));\n+    }\n+\n+    public String getInsertValues() {\n+        return insertValues;\n+    }\n+\n+    /// @return schema as to be used in `create external table <NAME> ( <SCHEMA> ) ...`\n+    public String getSchema()\n+    {\n+        return schema;\n+    }\n+\n+    /// @return schema that will be returned when suggesting a schema to the user.\n+    public String getSuggestedTypes() {\n+        return suggestedTypes;\n+    }\n+\n+\n+    /// @return types that are supported by Parquet\n+    static public int[] getParquetTypes() {\n+        return new int[]{\n+                Types.VARCHAR, Types.CHAR,\n+                Types.DATE, Types.TIMESTAMP,\n+                // Types.TIME, // supported, but will be written as TIMESTAMP\n+                Types.TINYINT, Types.SMALLINT, Types.INTEGER, Types.BIGINT,\n+                Types.DOUBLE, Types.REAL, Types.DECIMAL, Types.BOOLEAN\n+        };\n+    }\n+\n+    /// @return types that are supported by ORC\n+    static public int[] getORCTypes() {\n+        return new int[]{\n+                Types.VARCHAR, Types.CHAR,\n+                Types.DATE, Types.TIMESTAMP,\n+                // Types.TIME, // supported, but will be written as TIMESTAMP\n+                Types.TINYINT, Types.SMALLINT, Types.INTEGER, Types.BIGINT,\n+                Types.DOUBLE, Types.REAL, Types.DECIMAL, Types.BOOLEAN\n+        };\n+    }\n+\n+    /// @return types that are supported by Avro\n+    static public int[] getAvroTypes() {\n+        return new int[]{\n+                Types.VARCHAR, Types.CHAR,\n+                // Types.DATE, Types.TIME // not supported\n+                Types.TIMESTAMP,\n+                //Types.TINYINT, Types.SMALLINT, // not supported\n+                Types.INTEGER, Types.BIGINT,\n+                Types.DOUBLE, Types.REAL,\n+                // Types.DECIMAL, // not supported\n+                Types.BOOLEAN\n+        };\n+    }\n+\n+    /// @return supported types by fileFormat PARQUET, ORC or AVRO\n+    static public int[] getTypes(String fileFormat) {\n+        if(fileFormat.equalsIgnoreCase(\"PARQUET\"))\n+            return getParquetTypes();\n+        else if(fileFormat.equalsIgnoreCase(\"ORC\"))\n+            return getORCTypes();\n+        else if(fileFormat.equalsIgnoreCase(\"AVRO\"))\n+            return getAvroTypes();\n+        throw new RuntimeException(\"unsupported fileformat \" + fileFormat);\n+    }\n+\n+    /// compare that result in ResultSet rs is the same as from the generated insert values.\n+    public void checkResultSetSelectAll(ResultSet rs) throws SQLException {\n+        ArrayList<String> results = new ArrayList<>();\n+        int nCols = rs.getMetaData().getColumnCount();\n+        while (rs.next()) {\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 1; i <= nCols; i++) {\n+                Object value = rs.getObject(i);\n+                if (value != null && value instanceof Clob) {\n+                    throw new RuntimeException(\"Clob not supported\");\n+                } else {\n+                    if( i > 1 ) sb.append(\", \");\n+                    if( value != null && value.toString() != null ) {\n+                        sb.append(\"'\");\n+                        sb.append(value.toString());\n+                        sb.append(\"'\");\n+                    }\n+                    else {\n+                        sb.append(\"NULL\");\n+                    }\n+                }\n+            }\n+            results.add(sb.toString());\n+        }\n+        results.sort(String::compareTo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e3d1f8f0251dd4538209bddc065ee1dc2abaab"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk4Njc1MQ==", "bodyText": "ResultSet doesn't have streaming interface, would need 1-2 helper classes for this.", "url": "https://github.com/splicemachine/spliceengine/pull/3811#discussion_r454986751", "createdAt": "2020-07-15T11:38:47Z", "author": {"login": "martinrupp"}, "path": "hbase_sql/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/CreateTableTypeHelper.java", "diffHunk": "@@ -0,0 +1,243 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import org.junit.Assert;\n+\n+import java.sql.Clob;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.function.Consumer;\n+import java.util.function.IntFunction;\n+import java.util.stream.Collectors;\n+\n+/// a helper class to define column types, and then create external tables and insert data into them\n+/// to make writing tests for all column types easier.\n+\n+public class CreateTableTypeHelper {\n+    /// @param types: an array of Types that should be used\n+    /// @param ivalues: an array of values to use. 0 is NULL value, all other values will\n+    /// generate corresponding entries that are somewhat associated with the integer val\n+    /// e.g. mostly if the int values increase, the corresponding e.g. date value also increases.\n+    public CreateTableTypeHelper(int[] types, int[] ivalues)\n+    {\n+        schema = Arrays.stream(types).mapToObj(this::getTypesName).collect(Collectors.joining(\", \"));\n+        suggestedTypes = Arrays.stream(types).mapToObj(this::getTypesNameInfered).collect(Collectors.joining(\", \"));\n+\n+        IntFunction<String> iValueStringFunc = ivalue -> Arrays.stream(types)\n+                .mapToObj(type -> getTypeValue(type, ivalue))\n+                .collect(Collectors.joining(\", \"));\n+\n+        values2 = Arrays.stream(ivalues).mapToObj(iValueStringFunc).sorted().collect(Collectors.toList());\n+        insertValues = Arrays.stream(ivalues).mapToObj(iValueStringFunc).map(s -> \"(\" + s + \")\").collect(Collectors.joining(\", \"));\n+    }\n+\n+    public String getInsertValues() {\n+        return insertValues;\n+    }\n+\n+    /// @return schema as to be used in `create external table <NAME> ( <SCHEMA> ) ...`\n+    public String getSchema()\n+    {\n+        return schema;\n+    }\n+\n+    /// @return schema that will be returned when suggesting a schema to the user.\n+    public String getSuggestedTypes() {\n+        return suggestedTypes;\n+    }\n+\n+\n+    /// @return types that are supported by Parquet\n+    static public int[] getParquetTypes() {\n+        return new int[]{\n+                Types.VARCHAR, Types.CHAR,\n+                Types.DATE, Types.TIMESTAMP,\n+                // Types.TIME, // supported, but will be written as TIMESTAMP\n+                Types.TINYINT, Types.SMALLINT, Types.INTEGER, Types.BIGINT,\n+                Types.DOUBLE, Types.REAL, Types.DECIMAL, Types.BOOLEAN\n+        };\n+    }\n+\n+    /// @return types that are supported by ORC\n+    static public int[] getORCTypes() {\n+        return new int[]{\n+                Types.VARCHAR, Types.CHAR,\n+                Types.DATE, Types.TIMESTAMP,\n+                // Types.TIME, // supported, but will be written as TIMESTAMP\n+                Types.TINYINT, Types.SMALLINT, Types.INTEGER, Types.BIGINT,\n+                Types.DOUBLE, Types.REAL, Types.DECIMAL, Types.BOOLEAN\n+        };\n+    }\n+\n+    /// @return types that are supported by Avro\n+    static public int[] getAvroTypes() {\n+        return new int[]{\n+                Types.VARCHAR, Types.CHAR,\n+                // Types.DATE, Types.TIME // not supported\n+                Types.TIMESTAMP,\n+                //Types.TINYINT, Types.SMALLINT, // not supported\n+                Types.INTEGER, Types.BIGINT,\n+                Types.DOUBLE, Types.REAL,\n+                // Types.DECIMAL, // not supported\n+                Types.BOOLEAN\n+        };\n+    }\n+\n+    /// @return supported types by fileFormat PARQUET, ORC or AVRO\n+    static public int[] getTypes(String fileFormat) {\n+        if(fileFormat.equalsIgnoreCase(\"PARQUET\"))\n+            return getParquetTypes();\n+        else if(fileFormat.equalsIgnoreCase(\"ORC\"))\n+            return getORCTypes();\n+        else if(fileFormat.equalsIgnoreCase(\"AVRO\"))\n+            return getAvroTypes();\n+        throw new RuntimeException(\"unsupported fileformat \" + fileFormat);\n+    }\n+\n+    /// compare that result in ResultSet rs is the same as from the generated insert values.\n+    public void checkResultSetSelectAll(ResultSet rs) throws SQLException {\n+        ArrayList<String> results = new ArrayList<>();\n+        int nCols = rs.getMetaData().getColumnCount();\n+        while (rs.next()) {\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 1; i <= nCols; i++) {\n+                Object value = rs.getObject(i);\n+                if (value != null && value instanceof Clob) {\n+                    throw new RuntimeException(\"Clob not supported\");\n+                } else {\n+                    if( i > 1 ) sb.append(\", \");\n+                    if( value != null && value.toString() != null ) {\n+                        sb.append(\"'\");\n+                        sb.append(value.toString());\n+                        sb.append(\"'\");\n+                    }\n+                    else {\n+                        sb.append(\"NULL\");\n+                    }\n+                }\n+            }\n+            results.add(sb.toString());\n+        }\n+        results.sort(String::compareTo);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyNTM5Mw=="}, "originalCommit": {"oid": "e0e3d1f8f0251dd4538209bddc065ee1dc2abaab"}, "originalPosition": 126}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3090, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}