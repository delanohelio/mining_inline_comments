{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5NjQ5MDE5", "number": 4735, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTo1Mjo1N1rOE_Dl0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDoxNjoyNFrOE_EnvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTU0NTc4OnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryComparisonOperatorNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTo1Mjo1N1rOH8i8WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDowOTozOVrOH8kLmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI0OTExMw==", "bodyText": "Should this be like this instead?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        leftOperand.addCastNodeForStringToNonStringComparison(rightOperand, leftOperand);\n          \n          \n            \n                        leftOperand = addCastNodeForStringToNonStringComparison(rightOperand, leftOperand);\n          \n      \n    \n    \n  \n\nIs it possible we are not testing this branch? Can we add a test?", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533249113", "createdAt": "2020-12-01T09:52:57Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryComparisonOperatorNode.java", "diffHunk": "@@ -55,154 +55,101 @@\n \n public abstract class BinaryComparisonOperatorNode extends BinaryOperatorNode\n {\n-\t// Use between selectivity?\n-\tprivate boolean forQueryRewrite;\n-\tprivate boolean betweenSelectivity;\n-\n-\t/**\n-\t * Initializer for a BinaryComparisonOperatorNode\n-\t *\n-\t * @param leftOperand\tThe left operand of the comparison\n-\t * @param rightOperand\tThe right operand of the comparison\n-\t * @param operator\t\tThe name of the operator\n-\t * @param methodName\tThe name of the method to call in the generated\n-\t *\t\t\t\t\t\tclass\n-\t */\n-\n-\tpublic void init(\n-\t\t\t\tObject\tleftOperand,\n-\t\t\t\tObject\trightOperand,\n-\t\t\t\tObject\t\toperator,\n-\t\t\t\tObject\t\tmethodName)\n-\t{\n-\t\tsuper.init(leftOperand, rightOperand, operator, methodName,\n-\t\t\t\tClassName.DataValueDescriptor, ClassName.DataValueDescriptor);\n-\t}\n-\n-\t/**\n-\t * This node was generated as part of a query rewrite. Bypass the\n-\t * normal comparability checks.\n-\t * @param val  true if this was for a query rewrite\n-\t */\n-\tpublic void setForQueryRewrite(boolean val)\n-\t{\n-\t\tforQueryRewrite=val;\n-\t}\n-\n-\t/**\n-\t * Was this node generated in a query rewrite?\n-\t *\n-\t * @return  true if it was generated in a query rewrite.\n-\t */\n-\tpublic boolean getForQueryRewrite()\n-\t{\n-\t\treturn forQueryRewrite;\n-\t}\n-\n-\t/**\n-\t * Use between selectivity when calculating the selectivity.\n-\t */\n-\tvoid setBetweenSelectivity()\n-\t{\n-\t\tbetweenSelectivity = true;\n-\t}\n-\n-\t/**\n-\t * Return whether or not to use the between selectivity for this node.\n-\t *\n-\t * @return Whether or not to use the between selectivity for this node.\n-\t */\n-\tboolean getBetweenSelectivity() {\n-\t\treturn betweenSelectivity;\n-\t}\n-\n-\n-\t/**\n-\t * Bind this comparison operator.  All that has to be done for binding\n-\t * a comparison operator is to bind the operands, check the compatibility\n-\t * of the types, and set the result type to SQLBoolean.\n-\t *\n-\t * @param fromList\t\t\tThe query's FROM list\n-\t * @param subqueryList\t\tThe subquery list being built as we find SubqueryNodes\n-\t * @param aggregateVector\tThe aggregate vector being built as we find AggregateNodes\n-\t *\n-\t * @return\tThe new top of the expression tree.\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n+    // Use between selectivity?\n+    private boolean forQueryRewrite;\n+    private boolean betweenSelectivity;\n+\n+    /**\n+     * Initializer for a BinaryComparisonOperatorNode\n+     *\n+     * @param leftOperand    The left operand of the comparison\n+     * @param rightOperand    The right operand of the comparison\n+     * @param operator        The name of the operator\n+     * @param methodName    The name of the method to call in the generated\n+     *                        class\n+     */\n+\n+    public void init(\n+                Object    leftOperand,\n+                Object    rightOperand,\n+                Object        operator,\n+                Object        methodName)\n+    {\n+        super.init(leftOperand, rightOperand, operator, methodName,\n+                ClassName.DataValueDescriptor, ClassName.DataValueDescriptor);\n+    }\n+\n+    /**\n+     * This node was generated as part of a query rewrite. Bypass the\n+     * normal comparability checks.\n+     * @param val  true if this was for a query rewrite\n+     */\n+    public void setForQueryRewrite(boolean val)\n+    {\n+        forQueryRewrite=val;\n+    }\n+\n+    /**\n+     * Was this node generated in a query rewrite?\n+     *\n+     * @return  true if it was generated in a query rewrite.\n+     */\n+    public boolean getForQueryRewrite()\n+    {\n+        return forQueryRewrite;\n+    }\n+\n+    /**\n+     * Use between selectivity when calculating the selectivity.\n+     */\n+    void setBetweenSelectivity()\n+    {\n+        betweenSelectivity = true;\n+    }\n+\n+    /**\n+     * Return whether or not to use the between selectivity for this node.\n+     *\n+     * @return Whether or not to use the between selectivity for this node.\n+     */\n+    boolean getBetweenSelectivity() {\n+        return betweenSelectivity;\n+    }\n+\n+\n+    /**\n+     * Bind this comparison operator.  All that has to be done for binding\n+     * a comparison operator is to bind the operands, check the compatibility\n+     * of the types, and set the result type to SQLBoolean.\n+     *\n+     * @param fromList            The query's FROM list\n+     * @param subqueryList        The subquery list being built as we find SubqueryNodes\n+     * @param aggregateVector    The aggregate vector being built as we find AggregateNodes\n+     *\n+     * @return    The new top of the expression tree.\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n \n     @Override\n-\tpublic ValueNode bindExpression(FromList fromList,\n+    public ValueNode bindExpression(FromList fromList,\n                                     SubqueryList subqueryList,\n                                     List<AggregateNode> aggregateVector) throws StandardException {\n-\t\tsuper.bindExpression(fromList, subqueryList, aggregateVector);\n+        super.bindExpression(fromList, subqueryList, aggregateVector);\n \n         TypeId leftTypeId = leftOperand.getTypeId();\n-\t\tTypeId rightTypeId = rightOperand.getTypeId();\n-\n-\t\t/*\n-\t\t * If we are comparing a non-string with a string type, then we\n-\t\t * must prevent the non-string value from being used to probe into\n-\t\t * an index on a string column. This is because the string types\n-\t\t * are all of low precedence, so the comparison rules of the non-string\n-\t\t * value are used, so it may not find values in a string index because\n-\t\t * it will be in the wrong order. So, cast the string value to its\n-\t\t * own type. This is easier than casting it to the non-string type,\n-\t\t * because we would have to figure out the right length to cast it to.\n-\t\t */\n-\t\tif (! leftTypeId.isStringTypeId() && rightTypeId.isStringTypeId())\n-\t\t{\n-\t\t\tif (leftTypeId.isBooleanTypeId() || leftTypeId.isDateTimeTimeStampTypeId()) {\n-\t\t\t\trightOperand = (ValueNode)\n-\t\t\t\t\t\tgetNodeFactory().getNode(\n-\t\t\t\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\t\t\t\trightOperand,\n-\t\t\t\t\t\t\t\tnew DataTypeDescriptor(\n-\t\t\t\t\t\t\t\t\t\tleftTypeId,\n-\t\t\t\t\t\t\t\t\t\ttrue,leftOperand.getTypeServices().getMaximumWidth()),\n-\t\t\t\t\t\t\t\tgetContextManager());\n-\t\t\t\t((CastNode) rightOperand).bindCastNodeOnly();\n-\t\t\t\trightTypeId = rightOperand.getTypeId();\n-\t\t\t}\n-\t\t\telse if (leftTypeId.isNumericTypeId() &&\n-\t\t\t\t     rightTypeId.isCharOrVarChar()) {\n-\n-\t\t\t\trightOperand = (ValueNode) getNodeFactory().getNode(\n-\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\trightOperand,\n-\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DOUBLE),\n-\t\t\t\t\tgetContextManager());\n-\t\t\t\t((CastNode) rightOperand).bindCastNodeOnly();\n-\t\t\t\trightTypeId = rightOperand.getTypeId();\n-\t\t\t}\n-\t\t}\n-\t\telse if (! rightTypeId.isStringTypeId() && leftTypeId.isStringTypeId())\n-\t\t{\n-\t\t\tif (rightTypeId.isBooleanTypeId() || rightTypeId.isDateTimeTimeStampTypeId()) {\n-\t\t\t\tleftOperand =  (ValueNode)\n-\t\t\t\t\t\tgetNodeFactory().getNode(\n-\t\t\t\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\t\t\t\tleftOperand,\n-\t\t\t\t\t\t\t\tnew DataTypeDescriptor(\n-\t\t\t\t\t\t\t\t\t\trightTypeId,\n-\t\t\t\t\t\t\t\t\t\ttrue,\n-\t\t\t\t\t\t\t\t\t\trightOperand.getTypeServices().getMaximumWidth()),\n-\t\t\t\t\t\t\t\tgetContextManager());\n-\t\t\t\t((CastNode) leftOperand).bindCastNodeOnly();\n-\t\t\t\tleftTypeId = leftOperand.getTypeId();\n-\t\t\t}\n-\t\t\telse if (rightTypeId.isNumericTypeId() &&\n-\t\t\t\t     leftTypeId.isCharOrVarChar()) {\n-\n-\t\t\t\tleftOperand = (ValueNode) getNodeFactory().getNode(\n-\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\tleftOperand,\n-\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DOUBLE),\n-\t\t\t\t\tgetContextManager());\n-\t\t\t\t((CastNode) leftOperand).bindCastNodeOnly();\n-\t\t\t\tleftTypeId = leftOperand.getTypeId();\n-\t\t\t}\n-\t\t}\n+        TypeId rightTypeId = rightOperand.getTypeId();\n+\n+        if (! leftTypeId.isStringTypeId() && rightTypeId.isStringTypeId())\n+        {\n+            rightOperand = addCastNodeForStringToNonStringComparison(leftOperand, rightOperand);\n+            rightTypeId = rightOperand.getTypeId();\n+        }\n+        else if (! rightTypeId.isStringTypeId() && leftTypeId.isStringTypeId())\n+        {\n+            leftOperand.addCastNodeForStringToNonStringComparison(rightOperand, leftOperand);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI2OTQwMg==", "bodyText": "Good point, I will add a test and fix that.", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533269402", "createdAt": "2020-12-01T10:09:39Z", "author": {"login": "arnaud-splice"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryComparisonOperatorNode.java", "diffHunk": "@@ -55,154 +55,101 @@\n \n public abstract class BinaryComparisonOperatorNode extends BinaryOperatorNode\n {\n-\t// Use between selectivity?\n-\tprivate boolean forQueryRewrite;\n-\tprivate boolean betweenSelectivity;\n-\n-\t/**\n-\t * Initializer for a BinaryComparisonOperatorNode\n-\t *\n-\t * @param leftOperand\tThe left operand of the comparison\n-\t * @param rightOperand\tThe right operand of the comparison\n-\t * @param operator\t\tThe name of the operator\n-\t * @param methodName\tThe name of the method to call in the generated\n-\t *\t\t\t\t\t\tclass\n-\t */\n-\n-\tpublic void init(\n-\t\t\t\tObject\tleftOperand,\n-\t\t\t\tObject\trightOperand,\n-\t\t\t\tObject\t\toperator,\n-\t\t\t\tObject\t\tmethodName)\n-\t{\n-\t\tsuper.init(leftOperand, rightOperand, operator, methodName,\n-\t\t\t\tClassName.DataValueDescriptor, ClassName.DataValueDescriptor);\n-\t}\n-\n-\t/**\n-\t * This node was generated as part of a query rewrite. Bypass the\n-\t * normal comparability checks.\n-\t * @param val  true if this was for a query rewrite\n-\t */\n-\tpublic void setForQueryRewrite(boolean val)\n-\t{\n-\t\tforQueryRewrite=val;\n-\t}\n-\n-\t/**\n-\t * Was this node generated in a query rewrite?\n-\t *\n-\t * @return  true if it was generated in a query rewrite.\n-\t */\n-\tpublic boolean getForQueryRewrite()\n-\t{\n-\t\treturn forQueryRewrite;\n-\t}\n-\n-\t/**\n-\t * Use between selectivity when calculating the selectivity.\n-\t */\n-\tvoid setBetweenSelectivity()\n-\t{\n-\t\tbetweenSelectivity = true;\n-\t}\n-\n-\t/**\n-\t * Return whether or not to use the between selectivity for this node.\n-\t *\n-\t * @return Whether or not to use the between selectivity for this node.\n-\t */\n-\tboolean getBetweenSelectivity() {\n-\t\treturn betweenSelectivity;\n-\t}\n-\n-\n-\t/**\n-\t * Bind this comparison operator.  All that has to be done for binding\n-\t * a comparison operator is to bind the operands, check the compatibility\n-\t * of the types, and set the result type to SQLBoolean.\n-\t *\n-\t * @param fromList\t\t\tThe query's FROM list\n-\t * @param subqueryList\t\tThe subquery list being built as we find SubqueryNodes\n-\t * @param aggregateVector\tThe aggregate vector being built as we find AggregateNodes\n-\t *\n-\t * @return\tThe new top of the expression tree.\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n+    // Use between selectivity?\n+    private boolean forQueryRewrite;\n+    private boolean betweenSelectivity;\n+\n+    /**\n+     * Initializer for a BinaryComparisonOperatorNode\n+     *\n+     * @param leftOperand    The left operand of the comparison\n+     * @param rightOperand    The right operand of the comparison\n+     * @param operator        The name of the operator\n+     * @param methodName    The name of the method to call in the generated\n+     *                        class\n+     */\n+\n+    public void init(\n+                Object    leftOperand,\n+                Object    rightOperand,\n+                Object        operator,\n+                Object        methodName)\n+    {\n+        super.init(leftOperand, rightOperand, operator, methodName,\n+                ClassName.DataValueDescriptor, ClassName.DataValueDescriptor);\n+    }\n+\n+    /**\n+     * This node was generated as part of a query rewrite. Bypass the\n+     * normal comparability checks.\n+     * @param val  true if this was for a query rewrite\n+     */\n+    public void setForQueryRewrite(boolean val)\n+    {\n+        forQueryRewrite=val;\n+    }\n+\n+    /**\n+     * Was this node generated in a query rewrite?\n+     *\n+     * @return  true if it was generated in a query rewrite.\n+     */\n+    public boolean getForQueryRewrite()\n+    {\n+        return forQueryRewrite;\n+    }\n+\n+    /**\n+     * Use between selectivity when calculating the selectivity.\n+     */\n+    void setBetweenSelectivity()\n+    {\n+        betweenSelectivity = true;\n+    }\n+\n+    /**\n+     * Return whether or not to use the between selectivity for this node.\n+     *\n+     * @return Whether or not to use the between selectivity for this node.\n+     */\n+    boolean getBetweenSelectivity() {\n+        return betweenSelectivity;\n+    }\n+\n+\n+    /**\n+     * Bind this comparison operator.  All that has to be done for binding\n+     * a comparison operator is to bind the operands, check the compatibility\n+     * of the types, and set the result type to SQLBoolean.\n+     *\n+     * @param fromList            The query's FROM list\n+     * @param subqueryList        The subquery list being built as we find SubqueryNodes\n+     * @param aggregateVector    The aggregate vector being built as we find AggregateNodes\n+     *\n+     * @return    The new top of the expression tree.\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n \n     @Override\n-\tpublic ValueNode bindExpression(FromList fromList,\n+    public ValueNode bindExpression(FromList fromList,\n                                     SubqueryList subqueryList,\n                                     List<AggregateNode> aggregateVector) throws StandardException {\n-\t\tsuper.bindExpression(fromList, subqueryList, aggregateVector);\n+        super.bindExpression(fromList, subqueryList, aggregateVector);\n \n         TypeId leftTypeId = leftOperand.getTypeId();\n-\t\tTypeId rightTypeId = rightOperand.getTypeId();\n-\n-\t\t/*\n-\t\t * If we are comparing a non-string with a string type, then we\n-\t\t * must prevent the non-string value from being used to probe into\n-\t\t * an index on a string column. This is because the string types\n-\t\t * are all of low precedence, so the comparison rules of the non-string\n-\t\t * value are used, so it may not find values in a string index because\n-\t\t * it will be in the wrong order. So, cast the string value to its\n-\t\t * own type. This is easier than casting it to the non-string type,\n-\t\t * because we would have to figure out the right length to cast it to.\n-\t\t */\n-\t\tif (! leftTypeId.isStringTypeId() && rightTypeId.isStringTypeId())\n-\t\t{\n-\t\t\tif (leftTypeId.isBooleanTypeId() || leftTypeId.isDateTimeTimeStampTypeId()) {\n-\t\t\t\trightOperand = (ValueNode)\n-\t\t\t\t\t\tgetNodeFactory().getNode(\n-\t\t\t\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\t\t\t\trightOperand,\n-\t\t\t\t\t\t\t\tnew DataTypeDescriptor(\n-\t\t\t\t\t\t\t\t\t\tleftTypeId,\n-\t\t\t\t\t\t\t\t\t\ttrue,leftOperand.getTypeServices().getMaximumWidth()),\n-\t\t\t\t\t\t\t\tgetContextManager());\n-\t\t\t\t((CastNode) rightOperand).bindCastNodeOnly();\n-\t\t\t\trightTypeId = rightOperand.getTypeId();\n-\t\t\t}\n-\t\t\telse if (leftTypeId.isNumericTypeId() &&\n-\t\t\t\t     rightTypeId.isCharOrVarChar()) {\n-\n-\t\t\t\trightOperand = (ValueNode) getNodeFactory().getNode(\n-\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\trightOperand,\n-\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DOUBLE),\n-\t\t\t\t\tgetContextManager());\n-\t\t\t\t((CastNode) rightOperand).bindCastNodeOnly();\n-\t\t\t\trightTypeId = rightOperand.getTypeId();\n-\t\t\t}\n-\t\t}\n-\t\telse if (! rightTypeId.isStringTypeId() && leftTypeId.isStringTypeId())\n-\t\t{\n-\t\t\tif (rightTypeId.isBooleanTypeId() || rightTypeId.isDateTimeTimeStampTypeId()) {\n-\t\t\t\tleftOperand =  (ValueNode)\n-\t\t\t\t\t\tgetNodeFactory().getNode(\n-\t\t\t\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\t\t\t\tleftOperand,\n-\t\t\t\t\t\t\t\tnew DataTypeDescriptor(\n-\t\t\t\t\t\t\t\t\t\trightTypeId,\n-\t\t\t\t\t\t\t\t\t\ttrue,\n-\t\t\t\t\t\t\t\t\t\trightOperand.getTypeServices().getMaximumWidth()),\n-\t\t\t\t\t\t\t\tgetContextManager());\n-\t\t\t\t((CastNode) leftOperand).bindCastNodeOnly();\n-\t\t\t\tleftTypeId = leftOperand.getTypeId();\n-\t\t\t}\n-\t\t\telse if (rightTypeId.isNumericTypeId() &&\n-\t\t\t\t     leftTypeId.isCharOrVarChar()) {\n-\n-\t\t\t\tleftOperand = (ValueNode) getNodeFactory().getNode(\n-\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\tleftOperand,\n-\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DOUBLE),\n-\t\t\t\t\tgetContextManager());\n-\t\t\t\t((CastNode) leftOperand).bindCastNodeOnly();\n-\t\t\t\tleftTypeId = leftOperand.getTypeId();\n-\t\t\t}\n-\t\t}\n+        TypeId rightTypeId = rightOperand.getTypeId();\n+\n+        if (! leftTypeId.isStringTypeId() && rightTypeId.isStringTypeId())\n+        {\n+            rightOperand = addCastNodeForStringToNonStringComparison(leftOperand, rightOperand);\n+            rightTypeId = rightOperand.getTypeId();\n+        }\n+        else if (! rightTypeId.isStringTypeId() && leftTypeId.isStringTypeId())\n+        {\n+            leftOperand.addCastNodeForStringToNonStringComparison(rightOperand, leftOperand);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI0OTExMw=="}, "originalCommit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f"}, "originalPosition": 238}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTU2MDA1OnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTo1NDo1MVrOH8jF8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDoxNzo1NVrOH8kxyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1MTU3MQ==", "bodyText": "We already checked this before calling this function, do you want it here too to emphasize it?", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533251571", "createdAt": "2020-12-01T09:54:51Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java", "diffHunk": "@@ -240,6 +240,20 @@ public ValueNode bindExpression(FromList fromList,\n         return this;\n     }\n \n+    private void addCastOnRightOperandForStringToNonStringComparison() throws StandardException {\n+        if (singleLeftOperand) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI2NjE1NQ==", "bodyText": "Yes. Would you rather I make that an assertion?", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533266155", "createdAt": "2020-12-01T10:06:51Z", "author": {"login": "arnaud-splice"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java", "diffHunk": "@@ -240,6 +240,20 @@ public ValueNode bindExpression(FromList fromList,\n         return this;\n     }\n \n+    private void addCastOnRightOperandForStringToNonStringComparison() throws StandardException {\n+        if (singleLeftOperand) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1MTU3MQ=="}, "originalCommit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3OTE3Ng==", "bodyText": "Either is fine with me, just wanted to make sure it was intended.", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533279176", "createdAt": "2020-12-01T10:17:55Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java", "diffHunk": "@@ -240,6 +240,20 @@ public ValueNode bindExpression(FromList fromList,\n         return this;\n     }\n \n+    private void addCastOnRightOperandForStringToNonStringComparison() throws StandardException {\n+        if (singleLeftOperand) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1MTU3MQ=="}, "originalCommit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTU5MzEwOnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTo1OToxNFrOH8jbzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTo1OToxNFrOH8jbzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1NzE2Ng==", "bodyText": "ValueNodeList.comparable() is only used here, I'd rather make it always return a boolean and explicitly raise an exception here (instead of adding the extra boolean parameter), to me it's surprising that comparable() would raise an exception instead of returning true/false", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533257166", "createdAt": "2020-12-01T09:59:14Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java", "diffHunk": "@@ -252,8 +266,13 @@ public void bindComparisonOperator() throws StandardException{\n \n         /* Can the types be compared to each other? */\n         /* Multicolumn IN list cannot currently be constructed before bind time. */\n-        if (singleLeftOperand)\n-            rightOperandList.comparable(getLeftOperand());\n+        if (singleLeftOperand) {\n+            if (!rightOperandList.comparable(getLeftOperand(), false)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTcxNDUyOnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ValueNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDoxNjoyNFrOH8kqRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMTowMzoyMFrOH8nePw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3NzI1Mw==", "bodyText": "Does it make sense to put this function in BinaryOperatorNode? It seems not used in any other context.", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533277253", "createdAt": "2020-12-01T10:16:24Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ValueNode.java", "diffHunk": "@@ -1622,6 +1624,46 @@ public boolean collectExpressions(Map<Integer, Set<ValueNode>> exprMap) {\n         return collectSingleExpression(exprMap);\n     }\n \n+    /*\n+     * Add a cast node to the rightOperand if it's of string type and need to be compared\n+     * to leftOperand\n+     * If we are comparing a non-string with a string type, then we\n+     * must prevent the non-string value from being used to probe into\n+     * an index on a string column. This is because the string types\n+     * are all of low precedence, so the comparison rules of the non-string\n+     * value are used, so it may not find values in a string index because\n+     * it will be in the wrong order. So, cast the string value to its\n+     * own type. This is easier than casting it to the non-string type,\n+     * because we would have to figure out the right length to cast it to.\n+     * @return the new rightOperand\n+     */\n+    protected ValueNode addCastNodeForStringToNonStringComparison(\n+            ValueNode leftOperand, ValueNode rightOperand) throws StandardException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyMzMyNw==", "bodyText": "It is used in both BinaryComparisonOperatorNode and BinaryListOperatorNode whose closest common ancestor is ValueNode", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533323327", "createdAt": "2020-12-01T11:03:20Z", "author": {"login": "arnaud-splice"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ValueNode.java", "diffHunk": "@@ -1622,6 +1624,46 @@ public boolean collectExpressions(Map<Integer, Set<ValueNode>> exprMap) {\n         return collectSingleExpression(exprMap);\n     }\n \n+    /*\n+     * Add a cast node to the rightOperand if it's of string type and need to be compared\n+     * to leftOperand\n+     * If we are comparing a non-string with a string type, then we\n+     * must prevent the non-string value from being used to probe into\n+     * an index on a string column. This is because the string types\n+     * are all of low precedence, so the comparison rules of the non-string\n+     * value are used, so it may not find values in a string index because\n+     * it will be in the wrong order. So, cast the string value to its\n+     * own type. This is easier than casting it to the non-string type,\n+     * because we would have to figure out the right length to cast it to.\n+     * @return the new rightOperand\n+     */\n+    protected ValueNode addCastNodeForStringToNonStringComparison(\n+            ValueNode leftOperand, ValueNode rightOperand) throws StandardException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3NzI1Mw=="}, "originalCommit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2766, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}