{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3OTA5NTU3", "number": 3706, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODoyODoyOFrOEIFfgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMTo0MDoyOFrOEaKs1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTE0MDQ5OnYy", "diffSide": "RIGHT", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODoyODoyOFrOGn1f1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODoyODoyOFrOGn1f1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQyNDE0OA==", "bodyText": "synchronized does not address the issue described in the bug.", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r444424148", "createdAt": "2020-06-23T18:28:28Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,78 +29,89 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n+    public long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n+        if (refresh) {\n+            synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "432812479b8304a747204ae41d20eb1c092d6d19"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTE3MTE0OnYy", "diffSide": "RIGHT", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODozODowNFrOGn1ziQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODozODowNFrOGn1ziQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQyOTE5Mw==", "bodyText": "Recursion is not justified. A simple loop is clearer and can be used in the calling method:\nwhile (nextTimestamp  > _maxReservedTimestamp ) { reserveNextBlock(_maxReservedTimestamp); } \nI wouldn't worry about \"double volatile read\": it's not on the hot path and synchronization cost along with ZK read make its extra cost negligible.", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r444429193", "createdAt": "2020-06-23T18:38:04Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,78 +29,89 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n+    public long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n+        if (refresh) {\n+            synchronized (this) {\n+                _maxReservedTimestamp = timestampBlockManager.initialize();\n+                _timestampCounter.set(_maxReservedTimestamp);\n+            }\n+        }\n+\n+        long nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read\n+        reserveNextBlockIfNecessary(maxTS);\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private void reserveNextBlockIfNecessary(long nextTimestamp) throws TimestampIOException {\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read\n+        if (nextTimestamp > maxTS) {\n+            reserveNextBlock(maxTS);\n+        }\n+        // Check if reserving next block was enough\n+        if (nextTimestamp > _maxReservedTimestamp) {\n+            reserveNextBlockIfNecessary(nextTimestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "432812479b8304a747204ae41d20eb1c092d6d19"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTg5MzUzOnYy", "diffSide": "RIGHT", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMjozOTo0MFrOGn8_qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMjozOTo0MFrOGn8_qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0Njk4Nw==", "bodyText": "nextTS ?", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r444546987", "createdAt": "2020-06-23T22:39:40Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,78 +29,89 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n+    public long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n+        if (refresh) {\n+            synchronized (this) {\n+                _maxReservedTimestamp = timestampBlockManager.initialize();\n+                _timestampCounter.set(_maxReservedTimestamp);\n+            }\n+        }\n+\n+        long nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read\n+        reserveNextBlockIfNecessary(maxTS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "432812479b8304a747204ae41d20eb1c092d6d19"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODExNTU4OnYy", "diffSide": "RIGHT", "path": "splice_timestamp_api/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxODo0NDoxMFrOGtjBGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMzo1NTowNVrOGwpqPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQxMjgyNA==", "bodyText": "Use ${project.version}", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r450412824", "createdAt": "2020-07-06T18:44:10Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/pom.xml", "diffHunk": "@@ -40,5 +40,11 @@\n             <version>${spark.version}</version>\n             <scope>provided</scope>\n         </dependency>\n+        <dependency>\n+            <groupId>com.splicemachine</groupId>\n+            <artifactId>splice_protocol</artifactId>\n+            <version>3.1.0.1962-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY2NzM5MQ==", "bodyText": "done", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r453667391", "createdAt": "2020-07-13T13:55:05Z", "author": {"login": "arnaud-splice"}, "path": "splice_timestamp_api/pom.xml", "diffHunk": "@@ -40,5 +40,11 @@\n             <version>${spark.version}</version>\n             <scope>provided</scope>\n         </dependency>\n+        <dependency>\n+            <groupId>com.splicemachine</groupId>\n+            <artifactId>splice_protocol</artifactId>\n+            <version>3.1.0.1962-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQxMjgyNA=="}, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODE3NTIyOnYy", "diffSide": "RIGHT", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxOTowMjowNFrOGtjlIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwODowNjozMlrOG9QmAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyMjA0OQ==", "bodyText": "If nextTS is larger than _maxReservedTimestamp by several blockSize, we'll go to ZK several times.\nWhy do that when we can do the right thing in one take?", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r450422049", "createdAt": "2020-07-06T19:02:04Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;\n+            _timestampCounter.set(timestamp);\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read\n+        if (nextTS > maxTS) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY4MDY1Mg==", "bodyText": "Fixed", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r453680652", "createdAt": "2020-07-13T14:14:25Z", "author": {"login": "arnaud-splice"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;\n+            _timestampCounter.set(timestamp);\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read\n+        if (nextTS > maxTS) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyMjA0OQ=="}, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwOTQ0NA==", "bodyText": "blockCount is not computed right (can be zero or even negative).", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r461109444", "createdAt": "2020-07-27T19:11:05Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;\n+            _timestampCounter.set(timestamp);\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read\n+        if (nextTS > maxTS) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyMjA0OQ=="}, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg4ODE5NQ==", "bodyText": "Fixed", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r466888195", "createdAt": "2020-08-07T08:06:32Z", "author": {"login": "arnaud-splice"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;\n+            _timestampCounter.set(timestamp);\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read\n+        if (nextTS > maxTS) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyMjA0OQ=="}, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODE5MTAwOnYy", "diffSide": "RIGHT", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxOTowNzoxOVrOGtju5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDowMzoyOVrOGwqB-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyNDU0OA==", "bodyText": "Double volatile read is gone. Can get rid of maxTS.", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r450424548", "createdAt": "2020-07-06T19:07:19Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;\n+            _timestampCounter.set(timestamp);\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3MzQ2NQ==", "bodyText": "Done", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r453673465", "createdAt": "2020-07-13T14:03:29Z", "author": {"login": "arnaud-splice"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;\n+            _timestampCounter.set(timestamp);\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyNDU0OA=="}, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODIyNTIzOnYy", "diffSide": "RIGHT", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxOToxODo0MlrOGtkEDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDo0Mjo0MFrOGwrtXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyOTk2Nw==", "bodyText": "By calling reserveNextBlock(timestamp) we have guaranteed that timestamp <= _maxReservedTimestamp. Reassigning _maxReservedTimestamp to  timestamp doesn't look right.", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r450429967", "createdAt": "2020-07-06T19:18:42Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcwMDk1OA==", "bodyText": "I'm not quite sure what else to put instead. @jyuanca, can you weigh in?", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r453700958", "createdAt": "2020-07-13T14:42:40Z", "author": {"login": "arnaud-splice"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyOTk2Nw=="}, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODIzMTg1OnYy", "diffSide": "RIGHT", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxOToyMDo1NFrOGtkH_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDo0MjoxMVrOGwrr-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQzMDk3NQ==", "bodyText": "synchronized doesn't guard _timestampCounter . I'd still like to see compareAndSet here.", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r450430975", "createdAt": "2020-07-06T19:20:54Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;\n+            _timestampCounter.set(timestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcwMDYwMw==", "bodyText": "done", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r453700603", "createdAt": "2020-07-13T14:42:11Z", "author": {"login": "arnaud-splice"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;\n+            _timestampCounter.set(timestamp);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQzMDk3NQ=="}, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3ODU2MjYxOnYy", "diffSide": "RIGHT", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxOToxMTo0OVrOG3v6NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwODowODowMlrOG9QoyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwOTgxMw==", "bodyText": "Use addAndGet()", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r461109813", "createdAt": "2020-07-27T19:11:49Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,115 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n-            long nextMax = _maxReservedTimestamp + blockSize;\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        if (newTimestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(newTimestamp);\n+            _maxReservedTimestamp = newTimestamp;\n+            _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, newTimestamp));\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        if (nextTS > _maxReservedTimestamp) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {\n+            long blockCount = (_maxReservedTimestamp - nextTS) / blockSize + 1;\n+            long nextMax = _maxReservedTimestamp + blockSize * blockCount;\n             timestampBlockManager.reserveNextBlock(nextMax);\n             _maxReservedTimestamp = nextMax;\n-            _numBlocksReserved.incrementAndGet(); // JMX metric\n+            for (int i = 0; i < blockCount; ++i)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "926df4339771cf4377e7b404fd5c58d11128eb2d"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg4ODkwNQ==", "bodyText": "Done", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r466888905", "createdAt": "2020-08-07T08:08:02Z", "author": {"login": "arnaud-splice"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,115 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n-            long nextMax = _maxReservedTimestamp + blockSize;\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        if (newTimestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(newTimestamp);\n+            _maxReservedTimestamp = newTimestamp;\n+            _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, newTimestamp));\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        if (nextTS > _maxReservedTimestamp) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {\n+            long blockCount = (_maxReservedTimestamp - nextTS) / blockSize + 1;\n+            long nextMax = _maxReservedTimestamp + blockSize * blockCount;\n             timestampBlockManager.reserveNextBlock(nextMax);\n             _maxReservedTimestamp = nextMax;\n-            _numBlocksReserved.incrementAndGet(); // JMX metric\n+            for (int i = 0; i < blockCount; ++i)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwOTgxMw=="}, "originalCommit": {"oid": "926df4339771cf4377e7b404fd5c58d11128eb2d"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3ODU3NDA4OnYy", "diffSide": "RIGHT", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxOToxNToxNFrOG3wBKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNzoyMTo1NFrOHDR2dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExMTU5Mw==", "bodyText": "reserveNextBlock assigns a new value to _maxReservedTimestamp, here it's overwritten.\nupdateAndGet ensures assignment (it has a loop), which is more than needed here; a simple compareAndSet with the value from the initial _timestampCounter.get() would suffice.", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r461111593", "createdAt": "2020-07-27T19:15:14Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,115 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n-            long nextMax = _maxReservedTimestamp + blockSize;\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        if (newTimestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(newTimestamp);\n+            _maxReservedTimestamp = newTimestamp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "926df4339771cf4377e7b404fd5c58d11128eb2d"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwMDI0Ng==", "bodyText": "Done", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r473200246", "createdAt": "2020-08-19T17:21:54Z", "author": {"login": "arnaud-splice"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,115 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n-            long nextMax = _maxReservedTimestamp + blockSize;\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        if (newTimestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(newTimestamp);\n+            _maxReservedTimestamp = newTimestamp;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExMTU5Mw=="}, "originalCommit": {"oid": "926df4339771cf4377e7b404fd5c58d11128eb2d"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0ODkwMjE3OnYy", "diffSide": "RIGHT", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMTozMTowMFrOHB7jTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNzoyMTo0OFrOHDR2Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4NjMxNg==", "bodyText": "Change to nextTS  - _maxReservedTimestamp to make it positive? Just in case next Ts is much larger than _maxReservedTimestamp and blockCount becomes negative.", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r471786316", "createdAt": "2020-08-17T21:31:00Z", "author": {"login": "jyuanca"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,115 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n-            long nextMax = _maxReservedTimestamp + blockSize;\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        if (newTimestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(newTimestamp);\n+            _maxReservedTimestamp = newTimestamp;\n+            _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, newTimestamp));\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        if (nextTS > _maxReservedTimestamp) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {\n+            long blockCount = (_maxReservedTimestamp - nextTS) / blockSize + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "926df4339771cf4377e7b404fd5c58d11128eb2d"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwMDE5NQ==", "bodyText": "Done", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r473200195", "createdAt": "2020-08-19T17:21:48Z", "author": {"login": "arnaud-splice"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,115 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n-            long nextMax = _maxReservedTimestamp + blockSize;\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        if (newTimestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(newTimestamp);\n+            _maxReservedTimestamp = newTimestamp;\n+            _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, newTimestamp));\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        if (nextTS > _maxReservedTimestamp) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {\n+            long blockCount = (_maxReservedTimestamp - nextTS) / blockSize + 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4NjMxNg=="}, "originalCommit": {"oid": "926df4339771cf4377e7b404fd5c58d11128eb2d"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1ODY0MTMxOnYy", "diffSide": "RIGHT", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMToyMTo0OVrOHDZ_Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwOToyMjowNFrOHD2zrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMzMzUwNg==", "bodyText": "\"while\" is redundant here, \"if\" would suffice", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r473333506", "createdAt": "2020-08-19T21:21:49Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,128 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n+    }\n+\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    private static long roundUp(long timestamp) {\n+        assert timestamp >= 0;\n+        long remainder = timestamp % TIMESTAMP_INCREMENT;\n+        if (remainder == 0) {\n+            return timestamp;\n+        }\n+        return timestamp - remainder + TIMESTAMP_INCREMENT;\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        newTimestamp = roundUp(newTimestamp);\n+        if (newTimestamp > _timestampCounter.get()) {\n+            if (newTimestamp> _maxReservedTimestamp) {\n+                reserveNextBlock(newTimestamp);\n+            }\n+            long currentTimestampCounter;\n+            while ((currentTimestampCounter = _timestampCounter.get()) < newTimestamp) {\n+                _timestampCounter.compareAndSet(currentTimestampCounter, newTimestamp);\n+            }\n+        }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n-            long nextMax = _maxReservedTimestamp + blockSize;\n-            timestampBlockManager.reserveNextBlock(nextMax);\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        if (nextTS > _maxReservedTimestamp) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd01c0d07609a5458fdf208f5f43cbce76949a4e"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgwNTc0MA==", "bodyText": "done", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r473805740", "createdAt": "2020-08-20T09:22:04Z", "author": {"login": "arnaud-splice"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,128 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n+    }\n+\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    private static long roundUp(long timestamp) {\n+        assert timestamp >= 0;\n+        long remainder = timestamp % TIMESTAMP_INCREMENT;\n+        if (remainder == 0) {\n+            return timestamp;\n+        }\n+        return timestamp - remainder + TIMESTAMP_INCREMENT;\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        newTimestamp = roundUp(newTimestamp);\n+        if (newTimestamp > _timestampCounter.get()) {\n+            if (newTimestamp> _maxReservedTimestamp) {\n+                reserveNextBlock(newTimestamp);\n+            }\n+            long currentTimestampCounter;\n+            while ((currentTimestampCounter = _timestampCounter.get()) < newTimestamp) {\n+                _timestampCounter.compareAndSet(currentTimestampCounter, newTimestamp);\n+            }\n+        }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n-            long nextMax = _maxReservedTimestamp + blockSize;\n-            timestampBlockManager.reserveNextBlock(nextMax);\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        if (nextTS > _maxReservedTimestamp) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMzMzUwNg=="}, "originalCommit": {"oid": "fd01c0d07609a5458fdf208f5f43cbce76949a4e"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1ODczNzUwOnYy", "diffSide": "RIGHT", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMTo0MDoyOFrOHDa93A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwOToyMjoxOFrOHD20iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM0OTU5Ng==", "bodyText": "compareAndSet returns true if successful, which also guarantees the condition is satisfied.\nConsider:\npublic synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n\tnewTimestamp = roundUp(newTimestamp);\n\tif (newTimestamp> _maxReservedTimestamp) {\n\t\treserveNextBlock(newTimestamp);\n\t}\n\tlong currentTimestampCounter;\n\twhile ((currentTimestampCounter = _timestampCounter.get()) < newTimestamp) {\n\t\tif (_timestampCounter.compareAndSet(currentTimestampCounter, newTimestamp)) break;\n\t}\n}", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r473349596", "createdAt": "2020-08-19T21:40:28Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,128 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n+    }\n+\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    private static long roundUp(long timestamp) {\n+        assert timestamp >= 0;\n+        long remainder = timestamp % TIMESTAMP_INCREMENT;\n+        if (remainder == 0) {\n+            return timestamp;\n+        }\n+        return timestamp - remainder + TIMESTAMP_INCREMENT;\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        newTimestamp = roundUp(newTimestamp);\n+        if (newTimestamp > _timestampCounter.get()) {\n+            if (newTimestamp> _maxReservedTimestamp) {\n+                reserveNextBlock(newTimestamp);\n+            }\n+            long currentTimestampCounter;\n+            while ((currentTimestampCounter = _timestampCounter.get()) < newTimestamp) {\n+                _timestampCounter.compareAndSet(currentTimestampCounter, newTimestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd01c0d07609a5458fdf208f5f43cbce76949a4e"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgwNTk2MQ==", "bodyText": "done", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r473805961", "createdAt": "2020-08-20T09:22:18Z", "author": {"login": "arnaud-splice"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,128 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n+    }\n+\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    private static long roundUp(long timestamp) {\n+        assert timestamp >= 0;\n+        long remainder = timestamp % TIMESTAMP_INCREMENT;\n+        if (remainder == 0) {\n+            return timestamp;\n+        }\n+        return timestamp - remainder + TIMESTAMP_INCREMENT;\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        newTimestamp = roundUp(newTimestamp);\n+        if (newTimestamp > _timestampCounter.get()) {\n+            if (newTimestamp> _maxReservedTimestamp) {\n+                reserveNextBlock(newTimestamp);\n+            }\n+            long currentTimestampCounter;\n+            while ((currentTimestampCounter = _timestampCounter.get()) < newTimestamp) {\n+                _timestampCounter.compareAndSet(currentTimestampCounter, newTimestamp);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM0OTU5Ng=="}, "originalCommit": {"oid": "fd01c0d07609a5458fdf208f5f43cbce76949a4e"}, "originalPosition": 119}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3141, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}