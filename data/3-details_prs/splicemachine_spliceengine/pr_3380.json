{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4MTg1MjY5", "number": 3380, "title": "DB-9336 Allow 'default null' in create table", "bodyText": "", "createdAt": "2020-04-03T13:49:00Z", "url": "https://github.com/splicemachine/spliceengine/pull/3380", "merged": true, "mergeCommit": {"oid": "c6d89cfb1b21938fe625511f51b879092d6dea9d"}, "closed": true, "closedAt": "2020-04-08T19:15:27Z", "author": {"login": "arnaud-splice"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcUBHdMgH2gAyMzk4MTg1MjY5OmFiNTk3MWZkYzhkMzBlNTI0NjEwODllMzJlM2YwNDRkNjQwZTllNjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVPr6fAFqTM4ODkzMTkwNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ab5971fdc8d30e52461089e32e3f044d640e9e67", "author": {"user": {"login": "arnaud-splice", "name": "Arnaud Lacurie"}}, "url": "https://github.com/splicemachine/spliceengine/commit/ab5971fdc8d30e52461089e32e3f044d640e9e67", "committedDate": "2020-04-03T13:42:37Z", "message": "DB-9336 Allow 'default null' in create table"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NjQyMjQ1", "url": "https://github.com/splicemachine/spliceengine/pull/3380#pullrequestreview-388642245", "createdAt": "2020-04-06T21:48:10Z", "commit": {"oid": "ab5971fdc8d30e52461089e32e3f044d640e9e67"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NzMzMTA5", "url": "https://github.com/splicemachine/spliceengine/pull/3380#pullrequestreview-388733109", "createdAt": "2020-04-07T01:50:58Z", "commit": {"oid": "ab5971fdc8d30e52461089e32e3f044d640e9e67"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMTo1MDo1OFrOGBwHKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMTo1MDo1OFrOGBwHKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ5MDAyNg==", "bodyText": "With the lines added after this line to set the value, this line become redundant and can be removed.", "url": "https://github.com/splicemachine/spliceengine/pull/3380#discussion_r404490026", "createdAt": "2020-04-07T01:50:58Z", "author": {"login": "yxia92"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UserTypeConstantNode.java", "diffHunk": "@@ -54,194 +54,199 @@\n import java.sql.Types;\n \n /**\n-\tUser type constants.  These are created by built-in types\n-\tthat use user types as their implementation. This could also\n-\tpotentially be used by an optimizer that wanted to store plans\n-\tfor frequently-used parameter values.\n+    User type constants.  These are created by built-in types\n+    that use user types as their implementation. This could also\n+    potentially be used by an optimizer that wanted to store plans\n+    for frequently-used parameter values.\n \n-\tThis is also used to represent nulls in user types, which occurs\n-\twhen NULL is inserted into or supplied as the update value for\n-\ta usertype column.\n+    This is also used to represent nulls in user types, which occurs\n+    when NULL is inserted into or supplied as the update value for\n+    a usertype column.\n \n  */\n public class UserTypeConstantNode extends ConstantNode {\n-\t/*\n-\t** This value field hides the value in the super-type.  It is here\n-\t** Because user-type constants work differently from built-in constants.\n-\t** User-type constant values are stored as Objects, while built-in\n-\t** constants are stored as StorableDataValues.\n-\t**\n-\t** RESOLVE: This is a bit of a mess, and should be fixed.  All constants\n-\t** should be represented the same way.\n-\t*/\n-\tObject\tvalue;\n-\n-\t/**\n-\t * Initializer for a typed null node\n-\t * or a date, time, or timestamp value. Parameters may be:\n-\t *\n-\t * <ul>\n-\t * <li>arg1\tThe TypeId for the type of the node</li>\n-\t * <li>arg2\tThe factory to get the TypeId and DataTypeServices factories from.</li>\n-\t * </ul>\n-\t *\n-\t * <p>\n-\t * - OR -\n-\t * </p>\n-\t *\n-\t * <ul>\n-\t * <li>arg1 the date, time, or timestamp value</li>\n-\t * </ul>\n-\t *\n-\t * @exception StandardException thrown on failure\n-\t */\n-\tpublic void init(Object arg1)\n-\t\t\tthrows StandardException {\n+    /*\n+    ** This value field hides the value in the super-type.  It is here\n+    ** Because user-type constants work differently from built-in constants.\n+    ** User-type constant values are stored as Objects, while built-in\n+    ** constants are stored as StorableDataValues.\n+    **\n+    ** RESOLVE: This is a bit of a mess, and should be fixed.  All constants\n+    ** should be represented the same way.\n+    */\n+    Object    value;\n+\n+    /**\n+     * Initializer for a typed null node\n+     * or a date, time, or timestamp value. Parameters may be:\n+     *\n+     * <ul>\n+     * <li>arg1    The TypeId for the type of the node</li>\n+     * <li>arg2    The factory to get the TypeId and DataTypeServices factories from.</li>\n+     * </ul>\n+     *\n+     * <p>\n+     * - OR -\n+     * </p>\n+     *\n+     * <ul>\n+     * <li>arg1 the date, time, or timestamp value</li>\n+     * </ul>\n+     *\n+     * @exception StandardException thrown on failure\n+     */\n+    public void init(Object arg1)\n+            throws StandardException {\n         DataValueDescriptor dvd = null;\n         \n-\t\tif (arg1 instanceof TypeId)\n-\t\t{\n-\t\t\tsuper.init(\n-\t\t\t\t\targ1,\n-\t\t\t\t\tBoolean.TRUE,\n-\t\t\t\t\tReuseFactory.getInteger(\n-\t\t\t\t\t\t\t\t\t\tTypeDescriptor.MAXIMUM_WIDTH_UNKNOWN));\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tInteger maxWidth = null;\n-\t\t\tTypeId\ttypeId = null;\n+        if (arg1 instanceof TypeId)\n+        {\n+            super.init(\n+                    arg1,\n+                    Boolean.TRUE,\n+                    ReuseFactory.getInteger(\n+                                        TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN));\n+        }\n+        else\n+        {\n+            Integer maxWidth = null;\n+            TypeId    typeId = null;\n \n             if( arg1 instanceof DataValueDescriptor)\n                 dvd = (DataValueDescriptor) arg1;\n-\t\t\tif (arg1 instanceof Date\n+            if (arg1 instanceof Date\n                 || (dvd != null && dvd.getTypeFormatId() == StoredFormatIds.SQL_DATE_ID))\n-\t\t\t{\n-\t\t\t\tmaxWidth = ReuseFactory.getInteger(TypeId.DATE_MAXWIDTH);\n-\t\t\t\ttypeId = TypeId.getBuiltInTypeId(Types.DATE);\n-\t\t\t}\n-\t\t\telse if (arg1 instanceof Time\n+            {\n+                maxWidth = ReuseFactory.getInteger(TypeId.DATE_MAXWIDTH);\n+                typeId = TypeId.getBuiltInTypeId(Types.DATE);\n+            }\n+            else if (arg1 instanceof Time\n                      || (dvd != null && dvd.getTypeFormatId() == StoredFormatIds.SQL_TIME_ID))\n-\t\t\t{\n-\t\t\t\tmaxWidth = ReuseFactory.getInteger(TypeId.TIME_MAXWIDTH);\n-\t\t\t\ttypeId = TypeId.getBuiltInTypeId(Types.TIME);\n-\t\t\t}\n-\t\t\telse if (arg1 instanceof Timestamp\n+            {\n+                maxWidth = ReuseFactory.getInteger(TypeId.TIME_MAXWIDTH);\n+                typeId = TypeId.getBuiltInTypeId(Types.TIME);\n+            }\n+            else if (arg1 instanceof Timestamp\n                      || (dvd != null && dvd.getTypeFormatId() == StoredFormatIds.SQL_TIMESTAMP_ID))\n-\t\t\t{\n-\t\t\t\tmaxWidth = ReuseFactory.getInteger(TypeId.TIMESTAMP_MAXWIDTH);\n-\t\t\t\ttypeId = TypeId.getBuiltInTypeId(Types.TIMESTAMP);\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tif (SanityManager.DEBUG)\n-\t\t\t\t{\n-\t\t\t\t\tSanityManager.THROWASSERT(\n-\t\t\t\t\t\t\t\"Unexpected class \" + arg1.getClass().getName());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tsuper.init( \n-\t\t\t\ttypeId,\n-\t\t\t\t(arg1 == null) ? Boolean.TRUE : Boolean.FALSE,\n-\t\t\t\tmaxWidth);\n-\n-            if( dvd != null)\n-                setValue( dvd);\n-\t\t\telse if (arg1 instanceof Date)\n-\t\t\t{\n-\t\t\t\tsetValue(new SQLDate((Date) arg1));\n-\t\t\t}\n-\t\t\telse if (arg1 instanceof Time)\n-\t\t\t{\n-\t\t\t\tsetValue(new SQLTime((Time) arg1));\n-\t\t\t}\n-\t\t\telse if (arg1 instanceof Timestamp)\n-\t\t\t{\n-\t\t\t\tsetValue(new SQLTimestamp((Timestamp) arg1));\n-\t\t\t}\n-\n-\t\t\tvalue = arg1;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Return the object value of this user defined type.\n-\t *\n-\t * @return\tthe value of this constant. can't use getValue() for this.\n-\t *\t\t\tgetValue() returns the DataValueDescriptor for the built-in\n-\t *\t\t\ttypes that are implemented as user types (date, time, timestamp)\n-\t */\n-    public\tObject\tgetObjectValue() { return value; }\n-\n-\t/**\n-\t * Return whether or not this node represents a typed null constant.\n-\t *\n-\t */\n-\tpublic boolean isNull()\n-\t{\n-\t\treturn (value == null);\n-\t}\n-\n-\t/**\n-\t * Return an Object representing the bind time value of this\n-\t * expression tree.  If the expression tree does not evaluate to\n-\t * a constant at bind time then we return null.\n-\t * This is useful for bind time resolution of VTIs.\n-\t * RESOLVE: What do we do for primitives?\n-\t *\n-\t * @return\tAn Object representing the bind time value of this expression tree.\n-\t *\t\t\t(null if not a bind time constant.)\n-\t *\n-\t */\n-\tpublic Object getConstantValueAsObject()\n-\t{\n-\t\treturn value;\n-\t}\n-\n-\t/**\n-\t * For a UserTypeConstantNode, we have to store away the object somewhere\n-\t * and have a way to get it back at runtime.\n-\t * These objects are serializable.  This gives us at least two options:\n-\t * 1) serialize it out into a byte array field, and serialize\n-\t *\t  it back in when needed, from the field.\n-\t * 2) have an array of objects in the prepared statement and a #,\n-\t *\t  to find the object directly. Because it is serializable, it\n-\t *\t  will store with the rest of the executable just fine.\n-\t * Choice 2 gives better performance -- the ser/deser cost is paid\n-\t * on database access for the statement, not for each execution of it.\n-\t * However, it requires some infrastructure support from prepared\n-\t * statements.  For now, we take choice 3, and make some assumptions\n-\t * about available methods on the user type.  This choice has the\n-\t * shortcoming that it will not work for arbitrary user types.\n-\t * REVISIT and implement choice 2 when a general solution is needed.\n-\t * <p>\n-\t * A null is generated as a Null value cast to the type of\n-\t * the constant node.\n-\t *\n-\t * @param acb\tThe ExpressionClassBuilder for the class being built\n-\t * @param mb\tThe method the expression will go into\n-\t *\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n-\tpublic void generateExpression(ExpressionClassBuilder acb,\n-\t\t\t\t\t\t\t\t\t\t\tMethodBuilder mb)\n-\t\t\t\t\t\t\t\t\tthrows StandardException {\n-\n-\t\tTypeCompiler\t\ttc = getTypeCompiler();\n+            {\n+                maxWidth = ReuseFactory.getInteger(TypeId.TIMESTAMP_MAXWIDTH);\n+                typeId = TypeId.getBuiltInTypeId(Types.TIMESTAMP);\n+            }\n+            else\n+            {\n+                if (SanityManager.DEBUG)\n+                {\n+                    SanityManager.THROWASSERT(\n+                            \"Unexpected class \" + arg1.getClass().getName());\n+                }\n+            }\n+\n+            assert maxWidth != null;\n+\n+            super.init(\n+                typeId,\n+                (arg1 == null) ? Boolean.TRUE : Boolean.FALSE,\n+                maxWidth);\n+\n+            if( dvd != null) {\n+                setValue(dvd);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab5971fdc8d30e52461089e32e3f044d640e9e67"}, "originalPosition": 263}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4OTMxOTA0", "url": "https://github.com/splicemachine/spliceengine/pull/3380#pullrequestreview-388931904", "createdAt": "2020-04-07T09:15:02Z", "commit": {"oid": "ab5971fdc8d30e52461089e32e3f044d640e9e67"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1405, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}