{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5Mjg1Njc4", "number": 3247, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwOTo1NTozOFrODopuNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMDoxMDoyN1rODoqCJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTUzMjA2OnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/services/context/ContextManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwOTo1NTozOFrOF3VCeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwOTo1NTozOFrOF3VCeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU2MDY5OA==", "bodyText": "I think a while() loop would be a bit clearer, but it's nitpicking.", "url": "https://github.com/splicemachine/spliceengine/pull/3247#discussion_r393560698", "createdAt": "2020-03-17T09:55:38Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/iapi/services/context/ContextManager.java", "diffHunk": "@@ -234,14 +246,23 @@ public final boolean isEmpty()\n \t * being traversed.\n \t * @param contextId the type of Context stack to return.\n \t * @return an unmodifiable \"view\" of the ArrayList backing the stack\n-\t * @see org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext#resetSavepoints()\n \t * @see com.splicemachine.db.iapi.sql.conn.StatementContext#resetSavePoint()\n \t */\n \tpublic final List<Context> getContextStack(String contextId) {\n-\t\tfinal CtxStack cs = ctxTable.get(contextId);\n-\t\treturn (cs==null?Collections.EMPTY_LIST:cs.getUnmodifiableList());\n+\t\tList<Context> contexts= new ArrayList<>();\n+\t\tfor (ContextManager cm = this; cm != null; cm = cm.parent) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30edfd786fb7fd9eff79cdef03b50afd3d4f4363"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTU4MzA5OnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/execute/TriggerEventActivator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMDoxMDoyN1rOF3Vjkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwMTozNTozN1rOF4dB_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU2OTE3MA==", "bodyText": "@OlegMazurov Do you think there's a chance of simplifying this now that we support nested context managers? Here's Mark's comment from the previous PR:\nYes it is messy. The ContextManager doesn't seem well designed for threading. The ExecutionStmtValidator is required to detect if we're doing DDL on a trigger table. The TriggerExecutionContext is required to be in both the LCC of the Activation and of the active ContextManager for proper trigger execution. A lot of the time the Activation and the ContextManager share the same LCC, which is what we want. But sometimes the ContextManager's LCC is pushed in someplace unexpected and we end up with a mismatch. I think the whole ContextManager logic should probably be revisited and maybe rewritten. I had tried some things to add more synchronization or use different data structures, e.g. ConcurrentHashMap in place of HashMap, but that either caused the database to run too slowly or caused hangs or other failures.", "url": "https://github.com/splicemachine/spliceengine/pull/3247#discussion_r393569170", "createdAt": "2020-03-17T10:10:27Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/execute/TriggerEventActivator.java", "diffHunk": "@@ -31,49 +31,78 @@\n \n package com.splicemachine.db.impl.sql.execute;\n \n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Vector;\n-\n import com.splicemachine.db.catalog.UUID;\n import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.jdbc.ConnectionContext;\n+import com.splicemachine.db.iapi.services.context.ContextService;\n import com.splicemachine.db.iapi.services.io.FormatableBitSet;\n import com.splicemachine.db.iapi.sql.Activation;\n+import com.splicemachine.db.iapi.sql.conn.ConnectionUtil;\n import com.splicemachine.db.iapi.sql.conn.LanguageConnectionContext;\n import com.splicemachine.db.iapi.sql.conn.StatementContext;\n import com.splicemachine.db.iapi.sql.dictionary.TriggerDescriptor;\n import com.splicemachine.db.iapi.sql.execute.CursorResultSet;\n \n+import java.sql.SQLException;\n+import java.util.*;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.splicemachine.db.impl.sql.execute.TriggerExecutionContext.pushLanguageConnectionContextToCM;\n+\n /**\n  * Responsible for firing a trigger or set of triggers based on an event.\n  */\n public class TriggerEventActivator {\n \n-    private LanguageConnectionContext lcc;\n     private TriggerInfo triggerInfo;\n     private TriggerExecutionContext tec;\n     private Map<TriggerEvent, List<GenericTriggerExecutor>> statementExecutorsMap = new HashMap<>();\n-    private Map<TriggerEvent, List<GenericTriggerExecutor>> rowExecutorsMap = new HashMap<>();\n+    private Map<TriggerEvent, List<TriggerDescriptor>> rowExecutorsMap = new HashMap<>();\n+    private Map<TriggerEvent, List<TriggerDescriptor>> rowConcurrentExecutorsMap = new HashMap<>();\n     private Activation activation;\n+    private ConnectionContext connectionContext;\n     private String statementText;\n     private UUID tableId;\n     private String tableName;\n-    private boolean tecPushed;\n+    private boolean triggerExecutionContextPushed;\n+    private boolean executionStmtValidatorPushed;\n+\n+    // getLcc() may return a different LanguageConnectionContext at the time\n+    // we pop the triggerExecutionContext and executionStmtValidator, versus\n+    // at the time they were pushed.  Saving the original \"LCC\" at the time of\n+    // the push ensures that we pop from the correct LCC.  We sometimes need to\n+    // save two versions LCCs because we may push to the LCC in the activation,\n+    // and also to the LCC stored in the current ContextManager, if they happen\n+    // to be different.  Trigger execution requires that both the activation and\n+    // the current ContextManager both have a triggerExecutionContext.\n+    private LanguageConnectionContext esvLCC1;\n+    private LanguageConnectionContext esvLCC2;\n+    private LanguageConnectionContext tecLCC1;\n+    private LanguageConnectionContext tecLCC2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f73a1564e7541add435de8faf4282de30fccfe7a"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc0MDIyMg==", "bodyText": "I have filed DB-9282: Rework DB-8883 to rely on nested ContextManager's to deal with this separately.", "url": "https://github.com/splicemachine/spliceengine/pull/3247#discussion_r394740222", "createdAt": "2020-03-19T01:35:37Z", "author": {"login": "OlegMazurov"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/execute/TriggerEventActivator.java", "diffHunk": "@@ -31,49 +31,78 @@\n \n package com.splicemachine.db.impl.sql.execute;\n \n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Vector;\n-\n import com.splicemachine.db.catalog.UUID;\n import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.jdbc.ConnectionContext;\n+import com.splicemachine.db.iapi.services.context.ContextService;\n import com.splicemachine.db.iapi.services.io.FormatableBitSet;\n import com.splicemachine.db.iapi.sql.Activation;\n+import com.splicemachine.db.iapi.sql.conn.ConnectionUtil;\n import com.splicemachine.db.iapi.sql.conn.LanguageConnectionContext;\n import com.splicemachine.db.iapi.sql.conn.StatementContext;\n import com.splicemachine.db.iapi.sql.dictionary.TriggerDescriptor;\n import com.splicemachine.db.iapi.sql.execute.CursorResultSet;\n \n+import java.sql.SQLException;\n+import java.util.*;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.splicemachine.db.impl.sql.execute.TriggerExecutionContext.pushLanguageConnectionContextToCM;\n+\n /**\n  * Responsible for firing a trigger or set of triggers based on an event.\n  */\n public class TriggerEventActivator {\n \n-    private LanguageConnectionContext lcc;\n     private TriggerInfo triggerInfo;\n     private TriggerExecutionContext tec;\n     private Map<TriggerEvent, List<GenericTriggerExecutor>> statementExecutorsMap = new HashMap<>();\n-    private Map<TriggerEvent, List<GenericTriggerExecutor>> rowExecutorsMap = new HashMap<>();\n+    private Map<TriggerEvent, List<TriggerDescriptor>> rowExecutorsMap = new HashMap<>();\n+    private Map<TriggerEvent, List<TriggerDescriptor>> rowConcurrentExecutorsMap = new HashMap<>();\n     private Activation activation;\n+    private ConnectionContext connectionContext;\n     private String statementText;\n     private UUID tableId;\n     private String tableName;\n-    private boolean tecPushed;\n+    private boolean triggerExecutionContextPushed;\n+    private boolean executionStmtValidatorPushed;\n+\n+    // getLcc() may return a different LanguageConnectionContext at the time\n+    // we pop the triggerExecutionContext and executionStmtValidator, versus\n+    // at the time they were pushed.  Saving the original \"LCC\" at the time of\n+    // the push ensures that we pop from the correct LCC.  We sometimes need to\n+    // save two versions LCCs because we may push to the LCC in the activation,\n+    // and also to the LCC stored in the current ContextManager, if they happen\n+    // to be different.  Trigger execution requires that both the activation and\n+    // the current ContextManager both have a triggerExecutionContext.\n+    private LanguageConnectionContext esvLCC1;\n+    private LanguageConnectionContext esvLCC2;\n+    private LanguageConnectionContext tecLCC1;\n+    private LanguageConnectionContext tecLCC2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU2OTE3MA=="}, "originalCommit": {"oid": "f73a1564e7541add435de8faf4282de30fccfe7a"}, "originalPosition": 65}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3317, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}