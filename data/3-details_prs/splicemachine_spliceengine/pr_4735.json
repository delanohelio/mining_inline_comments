{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5NjQ5MDE5", "number": 4735, "title": "DB-10914 + DB-10926 Long varchar to timestamp in prepared statements ", "bodyText": "", "createdAt": "2020-11-30T16:05:05Z", "url": "https://github.com/splicemachine/spliceengine/pull/4735", "merged": true, "mergeCommit": {"oid": "bf026edc9a9fa0d0f7f8560864aaa9043ec0e920"}, "closed": true, "closedAt": "2020-12-01T17:13:53Z", "author": {"login": "arnaud-splice"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdhnhyGAH2gAyNTI5NjQ5MDE5OmVhOTE1ZWNiMWQxYjljZGRhNTlkMTMyZTljODI4OWJkN2U0MWQ5NzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdh7PuvgFqTU0MTk4NDI5OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ea915ecb1d1b9cdda59d132e9c8289bd7e41d972", "author": {"user": {"login": "arnaud-splice", "name": "Arnaud Lacurie"}}, "url": "https://github.com/splicemachine/spliceengine/commit/ea915ecb1d1b9cdda59d132e9c8289bd7e41d972", "committedDate": "2020-11-30T15:59:56Z", "message": "DB-10914 Autocast string to timestamp in prepared statements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f", "author": {"user": {"login": "arnaud-splice", "name": "Arnaud Lacurie"}}, "url": "https://github.com/splicemachine/spliceengine/commit/763ed9e2584f400a2a529ce445d0fb9ed030b17f", "committedDate": "2020-11-30T19:01:14Z", "message": "DB-10914 Cast only when necessary"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNzI4Njkw", "url": "https://github.com/splicemachine/spliceengine/pull/4735#pullrequestreview-541728690", "createdAt": "2020-12-01T09:52:57Z", "commit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTo1Mjo1N1rOH8i8WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTo1OToxNFrOH8jbzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI0OTExMw==", "bodyText": "Should this be like this instead?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        leftOperand.addCastNodeForStringToNonStringComparison(rightOperand, leftOperand);\n          \n          \n            \n                        leftOperand = addCastNodeForStringToNonStringComparison(rightOperand, leftOperand);\n          \n      \n    \n    \n  \n\nIs it possible we are not testing this branch? Can we add a test?", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533249113", "createdAt": "2020-12-01T09:52:57Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryComparisonOperatorNode.java", "diffHunk": "@@ -55,154 +55,101 @@\n \n public abstract class BinaryComparisonOperatorNode extends BinaryOperatorNode\n {\n-\t// Use between selectivity?\n-\tprivate boolean forQueryRewrite;\n-\tprivate boolean betweenSelectivity;\n-\n-\t/**\n-\t * Initializer for a BinaryComparisonOperatorNode\n-\t *\n-\t * @param leftOperand\tThe left operand of the comparison\n-\t * @param rightOperand\tThe right operand of the comparison\n-\t * @param operator\t\tThe name of the operator\n-\t * @param methodName\tThe name of the method to call in the generated\n-\t *\t\t\t\t\t\tclass\n-\t */\n-\n-\tpublic void init(\n-\t\t\t\tObject\tleftOperand,\n-\t\t\t\tObject\trightOperand,\n-\t\t\t\tObject\t\toperator,\n-\t\t\t\tObject\t\tmethodName)\n-\t{\n-\t\tsuper.init(leftOperand, rightOperand, operator, methodName,\n-\t\t\t\tClassName.DataValueDescriptor, ClassName.DataValueDescriptor);\n-\t}\n-\n-\t/**\n-\t * This node was generated as part of a query rewrite. Bypass the\n-\t * normal comparability checks.\n-\t * @param val  true if this was for a query rewrite\n-\t */\n-\tpublic void setForQueryRewrite(boolean val)\n-\t{\n-\t\tforQueryRewrite=val;\n-\t}\n-\n-\t/**\n-\t * Was this node generated in a query rewrite?\n-\t *\n-\t * @return  true if it was generated in a query rewrite.\n-\t */\n-\tpublic boolean getForQueryRewrite()\n-\t{\n-\t\treturn forQueryRewrite;\n-\t}\n-\n-\t/**\n-\t * Use between selectivity when calculating the selectivity.\n-\t */\n-\tvoid setBetweenSelectivity()\n-\t{\n-\t\tbetweenSelectivity = true;\n-\t}\n-\n-\t/**\n-\t * Return whether or not to use the between selectivity for this node.\n-\t *\n-\t * @return Whether or not to use the between selectivity for this node.\n-\t */\n-\tboolean getBetweenSelectivity() {\n-\t\treturn betweenSelectivity;\n-\t}\n-\n-\n-\t/**\n-\t * Bind this comparison operator.  All that has to be done for binding\n-\t * a comparison operator is to bind the operands, check the compatibility\n-\t * of the types, and set the result type to SQLBoolean.\n-\t *\n-\t * @param fromList\t\t\tThe query's FROM list\n-\t * @param subqueryList\t\tThe subquery list being built as we find SubqueryNodes\n-\t * @param aggregateVector\tThe aggregate vector being built as we find AggregateNodes\n-\t *\n-\t * @return\tThe new top of the expression tree.\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n+    // Use between selectivity?\n+    private boolean forQueryRewrite;\n+    private boolean betweenSelectivity;\n+\n+    /**\n+     * Initializer for a BinaryComparisonOperatorNode\n+     *\n+     * @param leftOperand    The left operand of the comparison\n+     * @param rightOperand    The right operand of the comparison\n+     * @param operator        The name of the operator\n+     * @param methodName    The name of the method to call in the generated\n+     *                        class\n+     */\n+\n+    public void init(\n+                Object    leftOperand,\n+                Object    rightOperand,\n+                Object        operator,\n+                Object        methodName)\n+    {\n+        super.init(leftOperand, rightOperand, operator, methodName,\n+                ClassName.DataValueDescriptor, ClassName.DataValueDescriptor);\n+    }\n+\n+    /**\n+     * This node was generated as part of a query rewrite. Bypass the\n+     * normal comparability checks.\n+     * @param val  true if this was for a query rewrite\n+     */\n+    public void setForQueryRewrite(boolean val)\n+    {\n+        forQueryRewrite=val;\n+    }\n+\n+    /**\n+     * Was this node generated in a query rewrite?\n+     *\n+     * @return  true if it was generated in a query rewrite.\n+     */\n+    public boolean getForQueryRewrite()\n+    {\n+        return forQueryRewrite;\n+    }\n+\n+    /**\n+     * Use between selectivity when calculating the selectivity.\n+     */\n+    void setBetweenSelectivity()\n+    {\n+        betweenSelectivity = true;\n+    }\n+\n+    /**\n+     * Return whether or not to use the between selectivity for this node.\n+     *\n+     * @return Whether or not to use the between selectivity for this node.\n+     */\n+    boolean getBetweenSelectivity() {\n+        return betweenSelectivity;\n+    }\n+\n+\n+    /**\n+     * Bind this comparison operator.  All that has to be done for binding\n+     * a comparison operator is to bind the operands, check the compatibility\n+     * of the types, and set the result type to SQLBoolean.\n+     *\n+     * @param fromList            The query's FROM list\n+     * @param subqueryList        The subquery list being built as we find SubqueryNodes\n+     * @param aggregateVector    The aggregate vector being built as we find AggregateNodes\n+     *\n+     * @return    The new top of the expression tree.\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n \n     @Override\n-\tpublic ValueNode bindExpression(FromList fromList,\n+    public ValueNode bindExpression(FromList fromList,\n                                     SubqueryList subqueryList,\n                                     List<AggregateNode> aggregateVector) throws StandardException {\n-\t\tsuper.bindExpression(fromList, subqueryList, aggregateVector);\n+        super.bindExpression(fromList, subqueryList, aggregateVector);\n \n         TypeId leftTypeId = leftOperand.getTypeId();\n-\t\tTypeId rightTypeId = rightOperand.getTypeId();\n-\n-\t\t/*\n-\t\t * If we are comparing a non-string with a string type, then we\n-\t\t * must prevent the non-string value from being used to probe into\n-\t\t * an index on a string column. This is because the string types\n-\t\t * are all of low precedence, so the comparison rules of the non-string\n-\t\t * value are used, so it may not find values in a string index because\n-\t\t * it will be in the wrong order. So, cast the string value to its\n-\t\t * own type. This is easier than casting it to the non-string type,\n-\t\t * because we would have to figure out the right length to cast it to.\n-\t\t */\n-\t\tif (! leftTypeId.isStringTypeId() && rightTypeId.isStringTypeId())\n-\t\t{\n-\t\t\tif (leftTypeId.isBooleanTypeId() || leftTypeId.isDateTimeTimeStampTypeId()) {\n-\t\t\t\trightOperand = (ValueNode)\n-\t\t\t\t\t\tgetNodeFactory().getNode(\n-\t\t\t\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\t\t\t\trightOperand,\n-\t\t\t\t\t\t\t\tnew DataTypeDescriptor(\n-\t\t\t\t\t\t\t\t\t\tleftTypeId,\n-\t\t\t\t\t\t\t\t\t\ttrue,leftOperand.getTypeServices().getMaximumWidth()),\n-\t\t\t\t\t\t\t\tgetContextManager());\n-\t\t\t\t((CastNode) rightOperand).bindCastNodeOnly();\n-\t\t\t\trightTypeId = rightOperand.getTypeId();\n-\t\t\t}\n-\t\t\telse if (leftTypeId.isNumericTypeId() &&\n-\t\t\t\t     rightTypeId.isCharOrVarChar()) {\n-\n-\t\t\t\trightOperand = (ValueNode) getNodeFactory().getNode(\n-\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\trightOperand,\n-\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DOUBLE),\n-\t\t\t\t\tgetContextManager());\n-\t\t\t\t((CastNode) rightOperand).bindCastNodeOnly();\n-\t\t\t\trightTypeId = rightOperand.getTypeId();\n-\t\t\t}\n-\t\t}\n-\t\telse if (! rightTypeId.isStringTypeId() && leftTypeId.isStringTypeId())\n-\t\t{\n-\t\t\tif (rightTypeId.isBooleanTypeId() || rightTypeId.isDateTimeTimeStampTypeId()) {\n-\t\t\t\tleftOperand =  (ValueNode)\n-\t\t\t\t\t\tgetNodeFactory().getNode(\n-\t\t\t\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\t\t\t\tleftOperand,\n-\t\t\t\t\t\t\t\tnew DataTypeDescriptor(\n-\t\t\t\t\t\t\t\t\t\trightTypeId,\n-\t\t\t\t\t\t\t\t\t\ttrue,\n-\t\t\t\t\t\t\t\t\t\trightOperand.getTypeServices().getMaximumWidth()),\n-\t\t\t\t\t\t\t\tgetContextManager());\n-\t\t\t\t((CastNode) leftOperand).bindCastNodeOnly();\n-\t\t\t\tleftTypeId = leftOperand.getTypeId();\n-\t\t\t}\n-\t\t\telse if (rightTypeId.isNumericTypeId() &&\n-\t\t\t\t     leftTypeId.isCharOrVarChar()) {\n-\n-\t\t\t\tleftOperand = (ValueNode) getNodeFactory().getNode(\n-\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\tleftOperand,\n-\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DOUBLE),\n-\t\t\t\t\tgetContextManager());\n-\t\t\t\t((CastNode) leftOperand).bindCastNodeOnly();\n-\t\t\t\tleftTypeId = leftOperand.getTypeId();\n-\t\t\t}\n-\t\t}\n+        TypeId rightTypeId = rightOperand.getTypeId();\n+\n+        if (! leftTypeId.isStringTypeId() && rightTypeId.isStringTypeId())\n+        {\n+            rightOperand = addCastNodeForStringToNonStringComparison(leftOperand, rightOperand);\n+            rightTypeId = rightOperand.getTypeId();\n+        }\n+        else if (! rightTypeId.isStringTypeId() && leftTypeId.isStringTypeId())\n+        {\n+            leftOperand.addCastNodeForStringToNonStringComparison(rightOperand, leftOperand);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1MTU3MQ==", "bodyText": "We already checked this before calling this function, do you want it here too to emphasize it?", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533251571", "createdAt": "2020-12-01T09:54:51Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java", "diffHunk": "@@ -240,6 +240,20 @@ public ValueNode bindExpression(FromList fromList,\n         return this;\n     }\n \n+    private void addCastOnRightOperandForStringToNonStringComparison() throws StandardException {\n+        if (singleLeftOperand) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1NzE2Ng==", "bodyText": "ValueNodeList.comparable() is only used here, I'd rather make it always return a boolean and explicitly raise an exception here (instead of adding the extra boolean parameter), to me it's surprising that comparable() would raise an exception instead of returning true/false", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533257166", "createdAt": "2020-12-01T09:59:14Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java", "diffHunk": "@@ -252,8 +266,13 @@ public void bindComparisonOperator() throws StandardException{\n \n         /* Can the types be compared to each other? */\n         /* Multicolumn IN list cannot currently be constructed before bind time. */\n-        if (singleLeftOperand)\n-            rightOperandList.comparable(getLeftOperand());\n+        if (singleLeftOperand) {\n+            if (!rightOperandList.comparable(getLeftOperand(), false)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNzQ4NzMy", "url": "https://github.com/splicemachine/spliceengine/pull/4735#pullrequestreview-541748732", "createdAt": "2020-12-01T10:16:24Z", "commit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDoxNjoyNFrOH8kqRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDoxNjoyNFrOH8kqRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3NzI1Mw==", "bodyText": "Does it make sense to put this function in BinaryOperatorNode? It seems not used in any other context.", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533277253", "createdAt": "2020-12-01T10:16:24Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ValueNode.java", "diffHunk": "@@ -1622,6 +1624,46 @@ public boolean collectExpressions(Map<Integer, Set<ValueNode>> exprMap) {\n         return collectSingleExpression(exprMap);\n     }\n \n+    /*\n+     * Add a cast node to the rightOperand if it's of string type and need to be compared\n+     * to leftOperand\n+     * If we are comparing a non-string with a string type, then we\n+     * must prevent the non-string value from being used to probe into\n+     * an index on a string column. This is because the string types\n+     * are all of low precedence, so the comparison rules of the non-string\n+     * value are used, so it may not find values in a string index because\n+     * it will be in the wrong order. So, cast the string value to its\n+     * own type. This is easier than casting it to the non-string type,\n+     * because we would have to figure out the right length to cast it to.\n+     * @return the new rightOperand\n+     */\n+    protected ValueNode addCastNodeForStringToNonStringComparison(\n+            ValueNode leftOperand, ValueNode rightOperand) throws StandardException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNzU3ODI2", "url": "https://github.com/splicemachine/spliceengine/pull/4735#pullrequestreview-541757826", "createdAt": "2020-12-01T10:27:31Z", "commit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07ad5e53c4cf6efc64e1362e05badabe097c1e77", "author": {"user": {"login": "arnaud-splice", "name": "Arnaud Lacurie"}}, "url": "https://github.com/splicemachine/spliceengine/commit/07ad5e53c4cf6efc64e1362e05badabe097c1e77", "committedDate": "2020-12-01T10:53:56Z", "message": "DB-10914 Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db0cc47fe53024cb8195999c3d7176356ceb2d32", "author": {"user": {"login": "arnaud-splice", "name": "Arnaud Lacurie"}}, "url": "https://github.com/splicemachine/spliceengine/commit/db0cc47fe53024cb8195999c3d7176356ceb2d32", "committedDate": "2020-12-01T11:01:14Z", "message": "DB-10926 Support timestamp(LONG VARCHAR)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNzg1NTQ1", "url": "https://github.com/splicemachine/spliceengine/pull/4735#pullrequestreview-541785545", "createdAt": "2020-12-01T11:02:14Z", "commit": {"oid": "07ad5e53c4cf6efc64e1362e05badabe097c1e77"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNzg5NTgz", "url": "https://github.com/splicemachine/spliceengine/pull/4735#pullrequestreview-541789583", "createdAt": "2020-12-01T11:07:43Z", "commit": {"oid": "db0cc47fe53024cb8195999c3d7176356ceb2d32"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxOTg0Mjk4", "url": "https://github.com/splicemachine/spliceengine/pull/4735#pullrequestreview-541984298", "createdAt": "2020-12-01T14:58:19Z", "commit": {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1036, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}