{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4NDg2ODA0", "number": 3713, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjo0MjozOFrOEI1yLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwOTo0MToxMFrOEMAGiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzA1MjYxOnYy", "diffSide": "RIGHT", "path": "hbase_sql/src/main/java/com/splicemachine/mrio/api/core/AbstractSMInputFormat.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjo0MjozOFrOGpDCUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwOToxMjoxM1rOGt135A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY5NDU0Nw==", "bodyText": "Can you add a check for the scan start/stop keys? Making sure there's no gap between the scan start key and the first split, or between the last split and the scan stop key. This check should also be made when there's only one split.", "url": "https://github.com/splicemachine/spliceengine/pull/3713#discussion_r445694547", "createdAt": "2020-06-25T16:42:38Z", "author": {"login": "dgomezferro"}, "path": "hbase_sql/src/main/java/com/splicemachine/mrio/api/core/AbstractSMInputFormat.java", "diffHunk": "@@ -191,6 +192,39 @@\n         }\n     }\n \n+    /**\n+     * Checks the sequence of split rows. If any gap is found, the splitting has to be recalculated again.\n+     *\n+     * @param lss\n+     * @return\n+     */\n+    protected boolean isRefreshNeeded(List<InputSplit> lss) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb9a5206653174e6a72648e90fa2114e1e32d0f0"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcyMTc2NA==", "bodyText": "More checks are added.", "url": "https://github.com/splicemachine/spliceengine/pull/3713#discussion_r450721764", "createdAt": "2020-07-07T09:12:13Z", "author": {"login": "ipraznik-splice"}, "path": "hbase_sql/src/main/java/com/splicemachine/mrio/api/core/AbstractSMInputFormat.java", "diffHunk": "@@ -191,6 +192,39 @@\n         }\n     }\n \n+    /**\n+     * Checks the sequence of split rows. If any gap is found, the splitting has to be recalculated again.\n+     *\n+     * @param lss\n+     * @return\n+     */\n+    protected boolean isRefreshNeeded(List<InputSplit> lss) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY5NDU0Nw=="}, "originalCommit": {"oid": "fb9a5206653174e6a72648e90fa2114e1e32d0f0"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzA1NDQwOnYy", "diffSide": "RIGHT", "path": "hbase_sql/src/main/java/com/splicemachine/mrio/api/core/AbstractSMInputFormat.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjo0MzowOFrOGpDDdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwOToxMjo1MVrOGt15Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY5NDgzOQ==", "bodyText": "Do we ever get something other than SMSplit? Is it just defensive programming?", "url": "https://github.com/splicemachine/spliceengine/pull/3713#discussion_r445694839", "createdAt": "2020-06-25T16:43:08Z", "author": {"login": "dgomezferro"}, "path": "hbase_sql/src/main/java/com/splicemachine/mrio/api/core/AbstractSMInputFormat.java", "diffHunk": "@@ -191,6 +192,39 @@\n         }\n     }\n \n+    /**\n+     * Checks the sequence of split rows. If any gap is found, the splitting has to be recalculated again.\n+     *\n+     * @param lss\n+     * @return\n+     */\n+    protected boolean isRefreshNeeded(List<InputSplit> lss) {\n+        if (lss.size() < 2 || !lss.stream().allMatch(is -> (is instanceof SMSplit))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb9a5206653174e6a72648e90fa2114e1e32d0f0"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcyMjExOQ==", "bodyText": "I've changed it to assert the instanceof", "url": "https://github.com/splicemachine/spliceengine/pull/3713#discussion_r450722119", "createdAt": "2020-07-07T09:12:51Z", "author": {"login": "ipraznik-splice"}, "path": "hbase_sql/src/main/java/com/splicemachine/mrio/api/core/AbstractSMInputFormat.java", "diffHunk": "@@ -191,6 +192,39 @@\n         }\n     }\n \n+    /**\n+     * Checks the sequence of split rows. If any gap is found, the splitting has to be recalculated again.\n+     *\n+     * @param lss\n+     * @return\n+     */\n+    protected boolean isRefreshNeeded(List<InputSplit> lss) {\n+        if (lss.size() < 2 || !lss.stream().allMatch(is -> (is instanceof SMSplit))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY5NDgzOQ=="}, "originalCommit": {"oid": "fb9a5206653174e6a72648e90fa2114e1e32d0f0"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDIwMDQxOnYy", "diffSide": "RIGHT", "path": "hbase_sql/src/main/java/com/splicemachine/mrio/api/core/AbstractSMInputFormat.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwOTo0MToxMFrOGt27PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDoxNjozOVrOGt4Jrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDczOTAwNA==", "bodyText": "This check is not correct, we can have a scan with start key = 1000 and the first partition might have key = 500.\nWe have to check that firstSplit.split.getStartRow() <= scanStartRow and that lastSplit.split.getEndRow() >= scanStopRow (or lastSplit.split.getEndRow().isEmpty())", "url": "https://github.com/splicemachine/spliceengine/pull/3713#discussion_r450739004", "createdAt": "2020-07-07T09:41:10Z", "author": {"login": "dgomezferro"}, "path": "hbase_sql/src/main/java/com/splicemachine/mrio/api/core/AbstractSMInputFormat.java", "diffHunk": "@@ -191,6 +192,66 @@\n         }\n     }\n \n+    private int compareRows(byte[] left, byte[] right) {\n+        return org.apache.hadoop.hbase.util.Bytes.compareTo(left, right);\n+    }\n+\n+    private boolean splitContainsScan(SMSplit split, byte[] scanStartRow, byte[] scanStopRow) {\n+        if (scanStartRow.length == 0 && scanStopRow.length == 0) {\n+            return compareRows(split.split.getStartRow(), scanStartRow) == 0 &&\n+                    compareRows(split.split.getEndRow(), scanStopRow) == 0;\n+        } else {\n+            if (compareRows(split.split.getStartRow(), scanStartRow) < 1) {\n+                if (split.split.getEndRow().length == 0 || compareRows(split.split.getEndRow(), scanStopRow) >= 0) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Checks the sequence of split rows. If any gap between splits is found or start/stop row of scan does not\n+     * correspond to the generated splits, the splitting has to be recalculated again.\n+     *\n+     * @param inputSplits generated splits\n+     * @param scanStartRow\n+     * @param scanStopRow\n+     * @return\n+     */\n+    protected boolean isRefreshNeeded(List<InputSplit> inputSplits, byte[] scanStartRow, byte[] scanStopRow) {\n+        assert inputSplits.stream().allMatch(is -> (is instanceof SMSplit)) : \"items expected to be instanceof SMSplit\";\n+\n+        if (inputSplits.size() < 2) {\n+            return !splitContainsScan((SMSplit) inputSplits.get(0), scanStartRow, scanStopRow);\n+        } else {\n+            inputSplits.sort(new Comparator<InputSplit>() {\n+                @Override\n+                public int compare(InputSplit o1, InputSplit o2) {\n+                    SMSplit smSplit1 = (SMSplit) o1;\n+                    SMSplit smSplit2 = (SMSplit) o2;\n+\n+                    return compareRows(smSplit1.split.getStartRow(), smSplit2.split.getStartRow());\n+                }\n+            });\n+\n+            for (int i = 1; i < inputSplits.size(); i++) {\n+                byte currentStartRow[] = ((SMSplit) inputSplits.get(i)).split.getStartRow();\n+                byte prevEndRow[] = ((SMSplit) inputSplits.get(i - 1)).split.getEndRow();\n+                if (compareRows(currentStartRow, prevEndRow) != 0) {\n+                    LOG.warn(\"The gap in splits is found: current split [\" + inputSplits.get(i) + \"], previous split [\" + inputSplits.get(i - 1) + \"]\");\n+                    return true;\n+                }\n+            }\n+            SMSplit firstSplit = (SMSplit) inputSplits.get(0);\n+            SMSplit lastSplit = (SMSplit) inputSplits.get(inputSplits.size() - 1);\n+            if (compareRows(firstSplit.split.getStartRow(), scanStartRow) != 0 || compareRows(lastSplit.split.getEndRow(), scanStopRow) != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c5295a8d59634c3a54b68462f59110e383fef1d"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc1OTA4Nw==", "bodyText": "it has been corrected", "url": "https://github.com/splicemachine/spliceengine/pull/3713#discussion_r450759087", "createdAt": "2020-07-07T10:16:39Z", "author": {"login": "ipraznik-splice"}, "path": "hbase_sql/src/main/java/com/splicemachine/mrio/api/core/AbstractSMInputFormat.java", "diffHunk": "@@ -191,6 +192,66 @@\n         }\n     }\n \n+    private int compareRows(byte[] left, byte[] right) {\n+        return org.apache.hadoop.hbase.util.Bytes.compareTo(left, right);\n+    }\n+\n+    private boolean splitContainsScan(SMSplit split, byte[] scanStartRow, byte[] scanStopRow) {\n+        if (scanStartRow.length == 0 && scanStopRow.length == 0) {\n+            return compareRows(split.split.getStartRow(), scanStartRow) == 0 &&\n+                    compareRows(split.split.getEndRow(), scanStopRow) == 0;\n+        } else {\n+            if (compareRows(split.split.getStartRow(), scanStartRow) < 1) {\n+                if (split.split.getEndRow().length == 0 || compareRows(split.split.getEndRow(), scanStopRow) >= 0) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Checks the sequence of split rows. If any gap between splits is found or start/stop row of scan does not\n+     * correspond to the generated splits, the splitting has to be recalculated again.\n+     *\n+     * @param inputSplits generated splits\n+     * @param scanStartRow\n+     * @param scanStopRow\n+     * @return\n+     */\n+    protected boolean isRefreshNeeded(List<InputSplit> inputSplits, byte[] scanStartRow, byte[] scanStopRow) {\n+        assert inputSplits.stream().allMatch(is -> (is instanceof SMSplit)) : \"items expected to be instanceof SMSplit\";\n+\n+        if (inputSplits.size() < 2) {\n+            return !splitContainsScan((SMSplit) inputSplits.get(0), scanStartRow, scanStopRow);\n+        } else {\n+            inputSplits.sort(new Comparator<InputSplit>() {\n+                @Override\n+                public int compare(InputSplit o1, InputSplit o2) {\n+                    SMSplit smSplit1 = (SMSplit) o1;\n+                    SMSplit smSplit2 = (SMSplit) o2;\n+\n+                    return compareRows(smSplit1.split.getStartRow(), smSplit2.split.getStartRow());\n+                }\n+            });\n+\n+            for (int i = 1; i < inputSplits.size(); i++) {\n+                byte currentStartRow[] = ((SMSplit) inputSplits.get(i)).split.getStartRow();\n+                byte prevEndRow[] = ((SMSplit) inputSplits.get(i - 1)).split.getEndRow();\n+                if (compareRows(currentStartRow, prevEndRow) != 0) {\n+                    LOG.warn(\"The gap in splits is found: current split [\" + inputSplits.get(i) + \"], previous split [\" + inputSplits.get(i - 1) + \"]\");\n+                    return true;\n+                }\n+            }\n+            SMSplit firstSplit = (SMSplit) inputSplits.get(0);\n+            SMSplit lastSplit = (SMSplit) inputSplits.get(inputSplits.size() - 1);\n+            if (compareRows(firstSplit.split.getStartRow(), scanStartRow) != 0 || compareRows(lastSplit.split.getEndRow(), scanStopRow) != 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDczOTAwNA=="}, "originalCommit": {"oid": "5c5295a8d59634c3a54b68462f59110e383fef1d"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3144, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}