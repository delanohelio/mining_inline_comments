{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5MTIyNzA1", "number": 4853, "title": "DB-11019 Use the selectivity of only one join predicate per column set.", "bodyText": "Fixes join cardinality underestimation errors, which could lead to large poorly-performing nested loop joins in large multi-table queries.\nSimplified cardinality underestimation example:\n\ncreate table t1 ( a int, b int, c int, d int, e int );\ninsert into t1 values (1,1,1,1,1),(2,2,2,2,2),(3,3,3,3,3),(4,4,4,4,4),(5,5,5,5,5),(6,6,6,6,6),(7,7,7,7,7),(8,8,8,8,8),(9,9,9,9,9),(10,10,10,10,10);\nanalyze table t1;\n/* The following should have an outputRows estimate of 10, not 1. */\nexplain select * from t1 a, t1 b, t1 c where a.a = b.a and b.a = c.a;\nCursor(n=11,rows=1,updateMode=READ_ONLY (1),engine=OLTP (default))\n->  ScrollInsensitive(n=11,totalCost=32.552,outputRows=1,outputHeapSize=60 B,partitions=1,parallelTasks=1)\n->  BroadcastJoin(n=8,totalCost=20.249,outputRows=1,outputHeapSize=60 B,partitions=1,parallelTasks=1,preds=[(A.A[8:1] = C.A[8:11])])\n->  TableScan[T1(1680)](n=6,totalCost=4.012,scannedRows=10,outputRows=10,outputHeapSize=60 B,partitions=1,parallelTasks=1)\n->  BroadcastJoin(n=4,totalCost=12.135,outputRows=10,outputHeapSize=400 B,partitions=1,parallelTasks=1,preds=[(A.A[4:1] = B.A[4:6])])\n->  TableScan[T1(1680)](n=2,totalCost=4.012,scannedRows=10,outputRows=10,outputHeapSize=400 B,partitions=1,parallelTasks=1)\n->  TableScan[T1(1680)](n=0,totalCost=4.012,scannedRows=10,outputRows=10,outputHeapSize=200 B,partitions=1,parallelTasks=1)\n\n\n\nWhen there is more than one join predicate involving the same column on a table, either explicitly, or derived through transitive closure, the selectivity of the redundant term is applied.  The old formula for selectivity used only the join predicate with the lowest selectivity as the selectivity of the entire join.  The fix is to apply a similar rule.  Among a set of columns with overlapping column references, only use the predicate with lowest selectivit.  For example:  t1.a + t1.b > t2.a and t1.a = t2.a both involve column t1.a, so only one of these predicates contributes to the join selectivity.  Non-overlapping predicate selectivities will still be combined.\n\n\nThe formula for combining join predicate selectivities is a little too aggresive (pred1.selectivity * pred2.selectivity * pred3.selectivity...) and implies absolute independence of join column values.  This change was made by SPLICE-2289, as we only counted a single predicates selectivity before, which caused row count overestimation.  The formula is now updated to match the default scan selectivity formula, which used function computeSqrtLevel to take the square root of the combined selectivity successively, the same number of times as the number of join predicates.\n\n\nSometimes join predicates are applied to the scan selectivity.  This is done for nested loop join, because it applies the join predicates as scan predicates.  But this has the effect of applying a predicate's selectivity more than once when other types of joins are picked.  The solution is to only apply join predicates to the scan selectivity if the current access path uses nested loop join.\n\n\nTo handle part 1, new class ReferencedColumnsMap is added to map table number to column numbers, tracking the ColumnReferences present in each predicate.  Method categorize, which collects metadata about a predicate, is updated with ReferencedColumnsMap as a parameter and builds this map for each Predicate.\nFor part 2, a new SelectivityHolder, named JoinPredicateSelectivity, is added to facilitate the sorting of selectivities as is done for scan predicates.\nFor part 3, a new method is added to the SelectivityHolder API called shouldApplySelectivity() which checks the number of tables referenced in the predicate and current join strategy.", "createdAt": "2020-12-14T04:37:39Z", "url": "https://github.com/splicemachine/spliceengine/pull/4853", "merged": true, "mergeCommit": {"oid": "1cc00437927fbe3758d550e1a308f97c4b768096"}, "closed": true, "closedAt": "2020-12-17T10:57:11Z", "author": {"login": "msirek"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdl9nomAH2gAyNTM5MTIyNzA1OjJlNmIxZDViZWQyYzg5M2Y0Y2RmYmYyN2Q4ZjBlNzRkMWRjMTcwMzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdm8WVBgFqTU1NDI4MjUxMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2e6b1d5bed2c893f4cdfbf27d8f0e74d1dc17033", "author": {"user": {"login": "msirek", "name": "Mark Sirek"}}, "url": "https://github.com/splicemachine/spliceengine/commit/2e6b1d5bed2c893f4cdfbf27d8f0e74d1dc17033", "committedDate": "2020-12-14T03:59:56Z", "message": "DB-11019 Use the selectivity of only one join predicate per column set."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e81d78e88b8a6127c0ad3749a325e9d42b04c02f", "author": {"user": {"login": "msirek", "name": "Mark Sirek"}}, "url": "https://github.com/splicemachine/spliceengine/commit/e81d78e88b8a6127c0ad3749a325e9d42b04c02f", "committedDate": "2020-12-14T05:10:29Z", "message": "DB-11019 Fix Spotbugs."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5132bce5384d859a5265893143daea56c6bb062", "author": {"user": {"login": "msirek", "name": "Mark Sirek"}}, "url": "https://github.com/splicemachine/spliceengine/commit/a5132bce5384d859a5265893143daea56c6bb062", "committedDate": "2020-12-14T06:33:02Z", "message": "DB-11019 Fix ITs."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a22b4a7a471241c8effb13594e074947c9a75533", "author": {"user": {"login": "msirek", "name": "Mark Sirek"}}, "url": "https://github.com/splicemachine/spliceengine/commit/a22b4a7a471241c8effb13594e074947c9a75533", "committedDate": "2020-12-14T14:09:14Z", "message": "DB-11019 Fix ITs, part 2."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMjk5NTcy", "url": "https://github.com/splicemachine/spliceengine/pull/4853#pullrequestreview-552299572", "createdAt": "2020-12-15T10:16:59Z", "commit": {"oid": "a22b4a7a471241c8effb13594e074947c9a75533"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMDoxNjo1OVrOIGDUjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMDoxNjo1OVrOIGDUjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxNjc4Mw==", "bodyText": "very nice", "url": "https://github.com/splicemachine/spliceengine/pull/4853#discussion_r543216783", "createdAt": "2020-12-15T10:16:59Z", "author": {"login": "martinrupp"}, "path": "db-engine/src/test/java/com/splicemachine/db/impl/sql/compile/ReferencedColumnsMapTest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package com.splicemachine.db.iapi.types;\n+\n+import static junit.framework.TestCase.assertTrue;\n+import static org.junit.Assert.*;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.impl.sql.compile.ReferencedColumnsMap;\n+import org.junit.Test;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ *\n+ * Test Class for ReferencedColumnsMap\n+ *\n+ */\n+public class ReferencedColumnsMapTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22b4a7a471241c8effb13594e074947c9a75533"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMjcyMzkx", "url": "https://github.com/splicemachine/spliceengine/pull/4853#pullrequestreview-552272391", "createdAt": "2020-12-15T09:46:21Z", "commit": {"oid": "a22b4a7a471241c8effb13594e074947c9a75533"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwOTo0NjoyMVrOIGB9-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMDoyMDowNVrOIGDc_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5NDYxOQ==", "bodyText": "When would the case baseTable.getCurrentAccessPath() == null happen?", "url": "https://github.com/splicemachine/spliceengine/pull/4853#discussion_r543194619", "createdAt": "2020-12-15T09:46:21Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/DefaultPredicateSelectivity.java", "diffHunk": "@@ -57,4 +57,14 @@ public double getSelectivity() throws StandardException {\n         }\n         return selectivity;\n     }\n+\n+    @Override\n+    public boolean shouldApplySelectivity() {\n+        return\n+            getNumReferencedTables() < 2             ||\n+            baseTable.getCurrentAccessPath() == null ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22b4a7a471241c8effb13594e074947c9a75533"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIwODgzNA==", "bodyText": "Maybe a pair of curly braces for the if block, since it contains multiple lines.", "url": "https://github.com/splicemachine/spliceengine/pull/4853#discussion_r543208834", "createdAt": "2020-12-15T10:05:35Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SelectivityUtil.java", "diffHunk": "@@ -130,14 +132,73 @@ public static double estimateJoinSelectivity(Optimizable innerTable, Conglomerat\n             }\n         }\n         double selectivity = 1.d;\n+        List<JoinPredicateSelectivity> predSelectivities = new ArrayList<>();\n         if (predList != null) {\n             for (int i = 0; i < predList.size(); i++) {\n                 Predicate p = (Predicate) predList.getOptPredicate(i);\n                 if (!isTheRightJoinPredicate(p, predicateType))\n                     continue;\n \n-                selectivity *= p.joinSelectivity(innerTable, innerCD, innerRowCount, outerRowCount, selectivityJoinType);\n+                predSelectivities.add(new JoinPredicateSelectivity(p, innerTable, QualifierPhase.JOIN,\n+                                                           p.joinSelectivity(innerTable, innerCD, innerRowCount,\n+                                                                             outerRowCount, selectivityJoinType)));\n+            }\n+        }\n+        if (predSelectivities.size() == 1)\n+            selectivity = predSelectivities.get(0).getSelectivity();\n+        else {\n+            // Sort the selectivities and combine them using computeSqrtLevel\n+            // as is done in ScanCostFunction.\n+            Collections.sort(predSelectivities);\n+\n+            // Map from predicate number (in the order added to the map) to the\n+            // selectivity of the predicate.\n+            Map<Integer, JoinPredicateSelectivity> selectivityMap = new TreeMap<>();\n+\n+            // Map from column number to index into selectivityMap.\n+            // This double lookup is done so that the main data structure\n+            // holding selectivities has no duplicates.\n+            Map<Integer,Integer> selectivityIndexMap = new HashMap<>();\n+\n+            int index = 0;\n+            for (JoinPredicateSelectivity predicateSelectivity:predSelectivities) {\n+                Predicate p = predicateSelectivity.getPredicate();\n+                int tableNumber = innerTable.getTableNumber();\n+                Set<Integer> columnSet = p.getReferencedColumns().get(tableNumber);\n+                ReferencedColumnsMap referencedColumnsMap = p.getReferencedColumns();\n+\n+                Integer mapIndex = null;\n+                if (columnSet != null)\n+                    for (Integer I:columnSet) {\n+                        mapIndex = selectivityIndexMap.get(I);\n+                        if (mapIndex != null)\n+                            break;\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22b4a7a471241c8effb13594e074947c9a75533"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxODk0MA==", "bodyText": "One thing that could lead to some confusion later is that the JOIN phase newly added here is not used in addPredicate() in ScanCostFunction, but only used in estimateJoinSelectivity() in SelectivityUtil. For this reason, I wonder if it's necessary to have this phase. In estimateJoinSelectivity(), there is only one phase involved, so practically, phase doesn't really matter.", "url": "https://github.com/splicemachine/spliceengine/pull/4853#discussion_r543218940", "createdAt": "2020-12-15T10:20:05Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/QualifierPhase.java", "diffHunk": "@@ -38,8 +38,9 @@\n  * BASE - > Qualifier is going against a key value in a way where splice can perform partitioning.\n  * FILTER_BASE -> Qualifier for base table but does not restrict I/O from base scan.  This is evaluated prior to a possible lookup.\n  * FILTER_PROJECTION -> Qualifer applied after possible lookup in the projection node on top of the base conglomerate scan.\n+ * JOIN -> Join predicate used to adjust the join selectivity.\n  *\n  */\n public enum QualifierPhase {\n-    BASE,FILTER_BASE,FILTER_PROJECTION\n+    BASE,FILTER_BASE,FILTER_PROJECTION,JOIN", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22b4a7a471241c8effb13594e074947c9a75533"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMzQzMTEz", "url": "https://github.com/splicemachine/spliceengine/pull/4853#pullrequestreview-552343113", "createdAt": "2020-12-15T11:11:05Z", "commit": {"oid": "a22b4a7a471241c8effb13594e074947c9a75533"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea99e299eeb65a021a091f5e57243b703dd39d1f", "author": {"user": {"login": "msirek", "name": "Mark Sirek"}}, "url": "https://github.com/splicemachine/spliceengine/commit/ea99e299eeb65a021a091f5e57243b703dd39d1f", "committedDate": "2020-12-15T15:57:21Z", "message": "DB-11019 Address review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyODM1MzY4", "url": "https://github.com/splicemachine/spliceengine/pull/4853#pullrequestreview-552835368", "createdAt": "2020-12-15T20:19:15Z", "commit": {"oid": "ea99e299eeb65a021a091f5e57243b703dd39d1f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51f3ef6e52e89948df7dea5518a0c0c535964b1f", "author": {"user": {"login": "msirek", "name": "Mark Sirek"}}, "url": "https://github.com/splicemachine/spliceengine/commit/51f3ef6e52e89948df7dea5518a0c0c535964b1f", "committedDate": "2020-12-16T00:45:54Z", "message": "DB-11019 Remove dependency on cedarsoftware Deepequals."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46bac5c50a5d52acdebabf7c1f8998d64f43e038", "author": {"user": {"login": "msirek", "name": "Mark Sirek"}}, "url": "https://github.com/splicemachine/spliceengine/commit/46bac5c50a5d52acdebabf7c1f8998d64f43e038", "committedDate": "2020-12-16T05:27:33Z", "message": "DB-11019 Fix Spotbugs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MjgyNTEy", "url": "https://github.com/splicemachine/spliceengine/pull/4853#pullrequestreview-554282512", "createdAt": "2020-12-17T05:05:03Z", "commit": {"oid": "46bac5c50a5d52acdebabf7c1f8998d64f43e038"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 982, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}