{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyOTA4NTYx", "number": 3214, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNjoyODo1N1rODfPv7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODo1MDo0NVrODho6Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MDkwNDc4OnYy", "diffSide": "RIGHT", "path": "splice_machine/src/test/java/com/splicemachine/db/impl/sql/compile/PredicateTupleIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNjoyODo1N1rOFo1lAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMzoyNzo1OVrOFpCNJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM2NTE4NQ==", "bodyText": "You may use the expression case when 1=0 then 1 end to generate a null value.", "url": "https://github.com/splicemachine/spliceengine/pull/3214#discussion_r378365185", "createdAt": "2020-02-12T16:28:57Z", "author": {"login": "yxia92"}, "path": "splice_machine/src/test/java/com/splicemachine/db/impl/sql/compile/PredicateTupleIT.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.impl.sql.compile;\n+\n+\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceUnitTest;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import com.splicemachine.homeless.TestUtils;\n+import org.junit.*;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.spark_project.guava.collect.Lists;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLSyntaxErrorException;\n+import java.sql.Types;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import static org.junit.Assert.*;\n+import static org.hamcrest.Matchers.containsString;\n+\n+/**\n+ * Test predicate with tuples\n+ */\n+@RunWith(Parameterized.class)\n+public class PredicateTupleIT extends SpliceUnitTest {\n+\n+    private Boolean useSpark;\n+\n+    @Parameterized.Parameters\n+    public static Collection<Object[]> data() {\n+        Collection<Object[]> params = Lists.newArrayListWithCapacity(2);\n+        params.add(new Object[]{true});\n+        params.add(new Object[]{false});\n+        return params;\n+    }\n+    private static final String SCHEMA = PredicateTupleIT.class.getSimpleName();\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher schemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceWatcher classWatcher = new SpliceWatcher(SCHEMA);\n+\n+    @Rule\n+    public SpliceWatcher methodWatcher = new SpliceWatcher(SCHEMA);\n+\n+    @BeforeClass\n+    public static void createSharedTables() throws Exception {\n+        TestUtils.executeSqlFile(classWatcher.getOrCreateConnection(), \"subquery/PredSimplTestTables.sql\", \"\");\n+    }\n+\n+    @AfterClass\n+    public static void dropUDF() throws Exception {\n+        try {\n+            TestUtils.executeSqlFile(classWatcher.getOrCreateConnection(), \"subquery/PredSimplTestCleanup.sql\", \"\");\n+        }\n+        catch (Exception e) {\n+            // Don't error out if the UDF we want to drop does not exist.\n+        }\n+    }\n+\n+    public PredicateTupleIT(Boolean useSpark) {\n+        this.useSpark = useSpark;\n+    }\n+\n+\n+    private void testQuery(String sqlText, String expected) throws Exception {\n+        ResultSet rs = null;\n+        try {\n+            rs = methodWatcher.executeQuery(sqlText);\n+            assertEquals(\"\\n\" + sqlText + \"\\n\", expected, TestUtils.FormattedResult.ResultFactory.toStringUnsorted(rs));\n+        }\n+        finally {\n+            if (rs != null)\n+                rs.close();\n+        }\n+    }\n+\n+    @Test\n+    public void testSimpleTuple() throws Exception {\n+        String query = format(\"select * from A --SPLICE-PROPERTIES useSpark=%s\\n\" +\n+                \"where (a1, a2) = (1,10)\", useSpark);\n+        String expected = \"A1 |A2 |A3  |\\n\" +\n+                \"-------------\\n\" +\n+                \" 1 |10 |100 |\";\n+\n+        testQuery(query, expected);\n+    }\n+\n+    @Ignore(\"Find a way to pass nulls inside a tuple\")\n+    @Test\n+    public void testTupleWithNulls() throws Exception {\n+        String query = format(\"select count(*) from D --splice-properties useSpark=%s\\n\" +\n+                \"where (d1,d2,d3) = (null,null,null)\", useSpark);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8324ac362ee98f567de21e49f5f74b9d3d92ebe7"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU3MjA3MA==", "bodyText": "Removing this test as it does not make much sense to compare to null", "url": "https://github.com/splicemachine/spliceengine/pull/3214#discussion_r378572070", "createdAt": "2020-02-12T23:27:59Z", "author": {"login": "arnaud-splice"}, "path": "splice_machine/src/test/java/com/splicemachine/db/impl/sql/compile/PredicateTupleIT.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.impl.sql.compile;\n+\n+\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceUnitTest;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import com.splicemachine.homeless.TestUtils;\n+import org.junit.*;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.spark_project.guava.collect.Lists;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLSyntaxErrorException;\n+import java.sql.Types;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import static org.junit.Assert.*;\n+import static org.hamcrest.Matchers.containsString;\n+\n+/**\n+ * Test predicate with tuples\n+ */\n+@RunWith(Parameterized.class)\n+public class PredicateTupleIT extends SpliceUnitTest {\n+\n+    private Boolean useSpark;\n+\n+    @Parameterized.Parameters\n+    public static Collection<Object[]> data() {\n+        Collection<Object[]> params = Lists.newArrayListWithCapacity(2);\n+        params.add(new Object[]{true});\n+        params.add(new Object[]{false});\n+        return params;\n+    }\n+    private static final String SCHEMA = PredicateTupleIT.class.getSimpleName();\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher schemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceWatcher classWatcher = new SpliceWatcher(SCHEMA);\n+\n+    @Rule\n+    public SpliceWatcher methodWatcher = new SpliceWatcher(SCHEMA);\n+\n+    @BeforeClass\n+    public static void createSharedTables() throws Exception {\n+        TestUtils.executeSqlFile(classWatcher.getOrCreateConnection(), \"subquery/PredSimplTestTables.sql\", \"\");\n+    }\n+\n+    @AfterClass\n+    public static void dropUDF() throws Exception {\n+        try {\n+            TestUtils.executeSqlFile(classWatcher.getOrCreateConnection(), \"subquery/PredSimplTestCleanup.sql\", \"\");\n+        }\n+        catch (Exception e) {\n+            // Don't error out if the UDF we want to drop does not exist.\n+        }\n+    }\n+\n+    public PredicateTupleIT(Boolean useSpark) {\n+        this.useSpark = useSpark;\n+    }\n+\n+\n+    private void testQuery(String sqlText, String expected) throws Exception {\n+        ResultSet rs = null;\n+        try {\n+            rs = methodWatcher.executeQuery(sqlText);\n+            assertEquals(\"\\n\" + sqlText + \"\\n\", expected, TestUtils.FormattedResult.ResultFactory.toStringUnsorted(rs));\n+        }\n+        finally {\n+            if (rs != null)\n+                rs.close();\n+        }\n+    }\n+\n+    @Test\n+    public void testSimpleTuple() throws Exception {\n+        String query = format(\"select * from A --SPLICE-PROPERTIES useSpark=%s\\n\" +\n+                \"where (a1, a2) = (1,10)\", useSpark);\n+        String expected = \"A1 |A2 |A3  |\\n\" +\n+                \"-------------\\n\" +\n+                \" 1 |10 |100 |\";\n+\n+        testQuery(query, expected);\n+    }\n+\n+    @Ignore(\"Find a way to pass nulls inside a tuple\")\n+    @Test\n+    public void testTupleWithNulls() throws Exception {\n+        String query = format(\"select count(*) from D --splice-properties useSpark=%s\\n\" +\n+                \"where (d1,d2,d3) = (null,null,null)\", useSpark);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM2NTE4NQ=="}, "originalCommit": {"oid": "8324ac362ee98f567de21e49f5f74b9d3d92ebe7"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1OTc0NDY2OnYy", "diffSide": "LEFT", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxMTo1NjowMVrOFrlaDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMzoyNDo0NFrOFr7XgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI0NTk2Ng==", "bodyText": "I don't like changing all these return types from ValueNode to QueryTreeNode, I feel like a tuple should also be a ValueNode, either by making a ValueNodeList extend a ValueNode or by introducing another node type for tuples.", "url": "https://github.com/splicemachine/spliceengine/pull/3214#discussion_r381245966", "createdAt": "2020-02-19T11:56:01Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj", "diffHunk": "@@ -6821,13 +6890,14 @@ multiplicativeOperator() throws StandardException :\n /*\n  * <A NAME=\"unaryExpression\">unaryExpression</A>\n  */\n-ValueNode", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "817a62c944a3b625cafa34785c31d741891bbbe6"}, "originalPosition": 331}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwNTc2MA==", "bodyText": "Introduced ValueTupleNode that derives ValueNode", "url": "https://github.com/splicemachine/spliceengine/pull/3214#discussion_r381605760", "createdAt": "2020-02-19T23:24:44Z", "author": {"login": "arnaud-splice"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj", "diffHunk": "@@ -6821,13 +6890,14 @@ multiplicativeOperator() throws StandardException :\n /*\n  * <A NAME=\"unaryExpression\">unaryExpression</A>\n  */\n-ValueNode", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI0NTk2Ng=="}, "originalCommit": {"oid": "817a62c944a3b625cafa34785c31d741891bbbe6"}, "originalPosition": 331}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTk5ODgyOnYy", "diffSide": "RIGHT", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODo1MDo0NVrOFsfDXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxOToxOTo0N1rOFsf_-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5MDQyOA==", "bodyText": "@arnaud-splice Can you move the call of valueExpression() up. valueExpression() is part of the parser rule, although eventually it will be compiled into a function of the same name, I think it is better to keep it as a parser rule and put explicitly at the top as shown below, following the tradition of all other parser rules:\nValueTupleNode\nvalueTupleElement(ValueNode tupleOrFirstValue) throws StandardException:\n{\n    ValueTupleNode  valueTuple;\n    ValueNode       newValue;\n}\n{\n    newValue = valueExpression()\n    {\n        if (tupleOrFirstValue instanceof ValueTupleNode) {\n            valueTuple = (ValueTupleNode) tupleOrFirstValue;\n        } else {\n            valueTuple = (ValueTupleNode) nodeFactory.getNode(\n                                    C_NodeTypes.VALUE_TUPLE_NODE,\n                                    getContextManager());\n            valueTuple.addValueNode((ValueNode) tupleOrFirstValue);\n        }\n\n        if (newValue instanceof ValueTupleNode) {\n            throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,\n                \"Nested tuple not supported\");\n        }\n        valueTuple.addValueNode(newValue);\n        return valueTuple;\n    }\n}", "url": "https://github.com/splicemachine/spliceengine/pull/3214#discussion_r382190428", "createdAt": "2020-02-20T18:50:45Z", "author": {"login": "yxia92"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj", "diffHunk": "@@ -8003,6 +8063,35 @@ valueExpressionPrimary() throws StandardException :\n     }\n }\n \n+/*\n+ * <A NAME=\"valueTupleElement\">tupleValueElement</A>\n+ */\n+ValueTupleNode\n+valueTupleElement(ValueNode tupleOrFirstValue) throws StandardException:\n+{\n+    ValueTupleNode  valueTuple;\n+    ValueNode       newValue;\n+}\n+{\n+    {\n+        if (tupleOrFirstValue instanceof ValueTupleNode) {\n+            valueTuple = (ValueTupleNode) tupleOrFirstValue;\n+        } else {\n+            valueTuple = (ValueTupleNode) nodeFactory.getNode(\n+                                    C_NodeTypes.VALUE_TUPLE_NODE,\n+                                    getContextManager());\n+            valueTuple.addValueNode((ValueNode) tupleOrFirstValue);\n+        }\n+        newValue = valueExpression();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f88faddf2cfda2f73407da043dc8ab5436dc90ac"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIwNTk0NA==", "bodyText": "Sure, that's a good idea!", "url": "https://github.com/splicemachine/spliceengine/pull/3214#discussion_r382205944", "createdAt": "2020-02-20T19:19:47Z", "author": {"login": "arnaud-splice"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj", "diffHunk": "@@ -8003,6 +8063,35 @@ valueExpressionPrimary() throws StandardException :\n     }\n }\n \n+/*\n+ * <A NAME=\"valueTupleElement\">tupleValueElement</A>\n+ */\n+ValueTupleNode\n+valueTupleElement(ValueNode tupleOrFirstValue) throws StandardException:\n+{\n+    ValueTupleNode  valueTuple;\n+    ValueNode       newValue;\n+}\n+{\n+    {\n+        if (tupleOrFirstValue instanceof ValueTupleNode) {\n+            valueTuple = (ValueTupleNode) tupleOrFirstValue;\n+        } else {\n+            valueTuple = (ValueTupleNode) nodeFactory.getNode(\n+                                    C_NodeTypes.VALUE_TUPLE_NODE,\n+                                    getContextManager());\n+            valueTuple.addValueNode((ValueNode) tupleOrFirstValue);\n+        }\n+        newValue = valueExpression();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5MDQyOA=="}, "originalCommit": {"oid": "f88faddf2cfda2f73407da043dc8ab5436dc90ac"}, "originalPosition": 220}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3375, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}