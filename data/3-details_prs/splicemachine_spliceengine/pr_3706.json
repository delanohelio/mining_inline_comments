{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3OTA5NTU3", "number": 3706, "title": "DB-9455 Refactor TimestampOracle to expose three distinct functions", "bodyText": "", "createdAt": "2020-06-22T12:29:40Z", "url": "https://github.com/splicemachine/spliceengine/pull/3706", "merged": true, "mergeCommit": {"oid": "b277666af5ae75720757d2be5953d7ca5c78c6f6"}, "closed": true, "closedAt": "2020-08-21T02:59:42Z", "author": {"login": "arnaud-splice"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABctwBFTAH2gAyNDM3OTA5NTU3OjQzMjgxMjQ3OWI4MzA0YTc0NzIwNGFlNDFkMjBlYjFjMDkyZDZkMTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdA31EpgH2gAyNDM3OTA5NTU3OmExZjVkZDAyOGQyNDIxNGFkNWNhODdmMWFlMzAwN2M0YThmZGRkODU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "432812479b8304a747204ae41d20eb1c092d6d19", "author": {"user": {"login": "arnaud-splice", "name": "Arnaud Lacurie"}}, "url": "https://github.com/splicemachine/spliceengine/commit/432812479b8304a747204ae41d20eb1c092d6d19", "committedDate": "2020-06-22T12:29:18Z", "message": "DB-9455 Fix sync issue in TimestampOracle.getNextTimestamp"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1ODY4ODc1", "url": "https://github.com/splicemachine/spliceengine/pull/3706#pullrequestreview-435868875", "createdAt": "2020-06-23T14:55:36Z", "commit": {"oid": "432812479b8304a747204ae41d20eb1c092d6d19"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MDQ3NjM3", "url": "https://github.com/splicemachine/spliceengine/pull/3706#pullrequestreview-436047637", "createdAt": "2020-06-23T18:28:28Z", "commit": {"oid": "432812479b8304a747204ae41d20eb1c092d6d19"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODoyODoyOFrOGn1f1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODozODowNFrOGn1ziQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQyNDE0OA==", "bodyText": "synchronized does not address the issue described in the bug.", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r444424148", "createdAt": "2020-06-23T18:28:28Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,78 +29,89 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n+    public long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n+        if (refresh) {\n+            synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "432812479b8304a747204ae41d20eb1c092d6d19"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQyOTE5Mw==", "bodyText": "Recursion is not justified. A simple loop is clearer and can be used in the calling method:\nwhile (nextTimestamp  > _maxReservedTimestamp ) { reserveNextBlock(_maxReservedTimestamp); } \nI wouldn't worry about \"double volatile read\": it's not on the hot path and synchronization cost along with ZK read make its extra cost negligible.", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r444429193", "createdAt": "2020-06-23T18:38:04Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,78 +29,89 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n+    public long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n+        if (refresh) {\n+            synchronized (this) {\n+                _maxReservedTimestamp = timestampBlockManager.initialize();\n+                _timestampCounter.set(_maxReservedTimestamp);\n+            }\n+        }\n+\n+        long nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read\n+        reserveNextBlockIfNecessary(maxTS);\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private void reserveNextBlockIfNecessary(long nextTimestamp) throws TimestampIOException {\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read\n+        if (nextTimestamp > maxTS) {\n+            reserveNextBlock(maxTS);\n+        }\n+        // Check if reserving next block was enough\n+        if (nextTimestamp > _maxReservedTimestamp) {\n+            reserveNextBlockIfNecessary(nextTimestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "432812479b8304a747204ae41d20eb1c092d6d19"}, "originalPosition": 134}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MjA4MTc1", "url": "https://github.com/splicemachine/spliceengine/pull/3706#pullrequestreview-436208175", "createdAt": "2020-06-23T22:39:40Z", "commit": {"oid": "432812479b8304a747204ae41d20eb1c092d6d19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMjozOTo0MFrOGn8_qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMjozOTo0MFrOGn8_qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0Njk4Nw==", "bodyText": "nextTS ?", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r444546987", "createdAt": "2020-06-23T22:39:40Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,78 +29,89 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n+    public long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n+        if (refresh) {\n+            synchronized (this) {\n+                _maxReservedTimestamp = timestampBlockManager.initialize();\n+                _timestampCounter.set(_maxReservedTimestamp);\n+            }\n+        }\n+\n+        long nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read\n+        reserveNextBlockIfNecessary(maxTS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "432812479b8304a747204ae41d20eb1c092d6d19"}, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "110d9537b1ba0fdfe2e5af693c9ba1abfde580ed", "author": {"user": {"login": "arnaud-splice", "name": "Arnaud Lacurie"}}, "url": "https://github.com/splicemachine/spliceengine/commit/110d9537b1ba0fdfe2e5af693c9ba1abfde580ed", "committedDate": "2020-07-01T15:57:49Z", "message": "DB-9455 Refactor TimestampOracle to expose three distinct functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5e06fc79aa972b2aceac374b55c3710e6ef787e", "author": {"user": {"login": "arnaud-splice", "name": "Arnaud Lacurie"}}, "url": "https://github.com/splicemachine/spliceengine/commit/e5e06fc79aa972b2aceac374b55c3710e6ef787e", "committedDate": "2020-07-01T16:39:12Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9455"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46568d2120a3406063d0fd37f1831b7fda00d2b0", "author": {"user": {"login": "arnaud-splice", "name": "Arnaud Lacurie"}}, "url": "https://github.com/splicemachine/spliceengine/commit/46568d2120a3406063d0fd37f1831b7fda00d2b0", "committedDate": "2020-07-01T16:41:58Z", "message": "DB-9455 Update dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad", "author": {"user": {"login": "arnaud-splice", "name": "Arnaud Lacurie"}}, "url": "https://github.com/splicemachine/spliceengine/commit/8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad", "committedDate": "2020-07-01T17:48:01Z", "message": "DB-9455 Fix spotbugs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMzIzNjMw", "url": "https://github.com/splicemachine/spliceengine/pull/3706#pullrequestreview-443323630", "createdAt": "2020-07-06T18:44:10Z", "commit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxODo0NDoxMFrOGtjBGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxOToyMDo1NFrOGtkH_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQxMjgyNA==", "bodyText": "Use ${project.version}", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r450412824", "createdAt": "2020-07-06T18:44:10Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/pom.xml", "diffHunk": "@@ -40,5 +40,11 @@\n             <version>${spark.version}</version>\n             <scope>provided</scope>\n         </dependency>\n+        <dependency>\n+            <groupId>com.splicemachine</groupId>\n+            <artifactId>splice_protocol</artifactId>\n+            <version>3.1.0.1962-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyMjA0OQ==", "bodyText": "If nextTS is larger than _maxReservedTimestamp by several blockSize, we'll go to ZK several times.\nWhy do that when we can do the right thing in one take?", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r450422049", "createdAt": "2020-07-06T19:02:04Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;\n+            _timestampCounter.set(timestamp);\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read\n+        if (nextTS > maxTS) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyNDU0OA==", "bodyText": "Double volatile read is gone. Can get rid of maxTS.", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r450424548", "createdAt": "2020-07-06T19:07:19Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;\n+            _timestampCounter.set(timestamp);\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyOTk2Nw==", "bodyText": "By calling reserveNextBlock(timestamp) we have guaranteed that timestamp <= _maxReservedTimestamp. Reassigning _maxReservedTimestamp to  timestamp doesn't look right.", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r450429967", "createdAt": "2020-07-06T19:18:42Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQzMDk3NQ==", "bodyText": "synchronized doesn't guard _timestampCounter . I'd still like to see compareAndSet here.", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r450430975", "createdAt": "2020-07-06T19:20:54Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;\n+            _timestampCounter.set(timestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 124}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9734bf8368e69195b1028eb32f7cb59cac939749", "author": {"user": {"login": "arnaud-splice", "name": "Arnaud Lacurie"}}, "url": "https://github.com/splicemachine/spliceengine/commit/9734bf8368e69195b1028eb32f7cb59cac939749", "committedDate": "2020-07-13T14:42:56Z", "message": "DB-9455 Address first comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "926df4339771cf4377e7b404fd5c58d11128eb2d", "author": {"user": {"login": "arnaud-splice", "name": "Arnaud Lacurie"}}, "url": "https://github.com/splicemachine/spliceengine/commit/926df4339771cf4377e7b404fd5c58d11128eb2d", "committedDate": "2020-07-14T09:57:50Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9455"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MDYwMzUx", "url": "https://github.com/splicemachine/spliceengine/pull/3706#pullrequestreview-456060351", "createdAt": "2020-07-27T19:11:05Z", "commit": {"oid": "926df4339771cf4377e7b404fd5c58d11128eb2d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxOToxMTowNVrOG3v4xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxOToxNToxNFrOG3wBKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwOTQ0NA==", "bodyText": "blockCount is not computed right (can be zero or even negative).", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r461109444", "createdAt": "2020-07-27T19:11:05Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;\n+            _timestampCounter.set(timestamp);\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read\n+        if (nextTS > maxTS) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyMjA0OQ=="}, "originalCommit": {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwOTgxMw==", "bodyText": "Use addAndGet()", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r461109813", "createdAt": "2020-07-27T19:11:49Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,115 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n-            long nextMax = _maxReservedTimestamp + blockSize;\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        if (newTimestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(newTimestamp);\n+            _maxReservedTimestamp = newTimestamp;\n+            _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, newTimestamp));\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        if (nextTS > _maxReservedTimestamp) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {\n+            long blockCount = (_maxReservedTimestamp - nextTS) / blockSize + 1;\n+            long nextMax = _maxReservedTimestamp + blockSize * blockCount;\n             timestampBlockManager.reserveNextBlock(nextMax);\n             _maxReservedTimestamp = nextMax;\n-            _numBlocksReserved.incrementAndGet(); // JMX metric\n+            for (int i = 0; i < blockCount; ++i)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "926df4339771cf4377e7b404fd5c58d11128eb2d"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExMTU5Mw==", "bodyText": "reserveNextBlock assigns a new value to _maxReservedTimestamp, here it's overwritten.\nupdateAndGet ensures assignment (it has a loop), which is more than needed here; a simple compareAndSet with the value from the initial _timestampCounter.get() would suffice.", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r461111593", "createdAt": "2020-07-27T19:15:14Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,115 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n-            long nextMax = _maxReservedTimestamp + blockSize;\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        if (newTimestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(newTimestamp);\n+            _maxReservedTimestamp = newTimestamp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "926df4339771cf4377e7b404fd5c58d11128eb2d"}, "originalPosition": 124}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4ODQ2NTQ0", "url": "https://github.com/splicemachine/spliceengine/pull/3706#pullrequestreview-468846544", "createdAt": "2020-08-17T21:30:59Z", "commit": {"oid": "926df4339771cf4377e7b404fd5c58d11128eb2d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMTozMTowMFrOHB7jTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMTozMTowMFrOHB7jTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4NjMxNg==", "bodyText": "Change to nextTS  - _maxReservedTimestamp to make it positive? Just in case next Ts is much larger than _maxReservedTimestamp and blockCount becomes negative.", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r471786316", "createdAt": "2020-08-17T21:31:00Z", "author": {"login": "jyuanca"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,115 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n-            long nextMax = _maxReservedTimestamp + blockSize;\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        if (newTimestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(newTimestamp);\n+            _maxReservedTimestamp = newTimestamp;\n+            _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, newTimestamp));\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        if (nextTS > _maxReservedTimestamp) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {\n+            long blockCount = (_maxReservedTimestamp - nextTS) / blockSize + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "926df4339771cf4377e7b404fd5c58d11128eb2d"}, "originalPosition": 140}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7eadaa999062936bdf8cf6b15cf05511321cdd1b", "author": {"user": {"login": "arnaud-splice", "name": "Arnaud Lacurie"}}, "url": "https://github.com/splicemachine/spliceengine/commit/7eadaa999062936bdf8cf6b15cf05511321cdd1b", "committedDate": "2020-08-19T17:18:01Z", "message": "DB-9455 Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd01c0d07609a5458fdf208f5f43cbce76949a4e", "author": {"user": {"login": "arnaud-splice", "name": "Arnaud Lacurie"}}, "url": "https://github.com/splicemachine/spliceengine/commit/fd01c0d07609a5458fdf208f5f43cbce76949a4e", "committedDate": "2020-08-19T17:19:43Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9455"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwOTc0MTE0", "url": "https://github.com/splicemachine/spliceengine/pull/3706#pullrequestreview-470974114", "createdAt": "2020-08-19T21:21:49Z", "commit": {"oid": "fd01c0d07609a5458fdf208f5f43cbce76949a4e"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMToyMTo0OVrOHDZ_Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMTo0MDoyOFrOHDa93A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMzMzUwNg==", "bodyText": "\"while\" is redundant here, \"if\" would suffice", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r473333506", "createdAt": "2020-08-19T21:21:49Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,128 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n+    }\n+\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    private static long roundUp(long timestamp) {\n+        assert timestamp >= 0;\n+        long remainder = timestamp % TIMESTAMP_INCREMENT;\n+        if (remainder == 0) {\n+            return timestamp;\n+        }\n+        return timestamp - remainder + TIMESTAMP_INCREMENT;\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        newTimestamp = roundUp(newTimestamp);\n+        if (newTimestamp > _timestampCounter.get()) {\n+            if (newTimestamp> _maxReservedTimestamp) {\n+                reserveNextBlock(newTimestamp);\n+            }\n+            long currentTimestampCounter;\n+            while ((currentTimestampCounter = _timestampCounter.get()) < newTimestamp) {\n+                _timestampCounter.compareAndSet(currentTimestampCounter, newTimestamp);\n+            }\n+        }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n-            long nextMax = _maxReservedTimestamp + blockSize;\n-            timestampBlockManager.reserveNextBlock(nextMax);\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        if (nextTS > _maxReservedTimestamp) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd01c0d07609a5458fdf208f5f43cbce76949a4e"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM0OTU5Ng==", "bodyText": "compareAndSet returns true if successful, which also guarantees the condition is satisfied.\nConsider:\npublic synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n\tnewTimestamp = roundUp(newTimestamp);\n\tif (newTimestamp> _maxReservedTimestamp) {\n\t\treserveNextBlock(newTimestamp);\n\t}\n\tlong currentTimestampCounter;\n\twhile ((currentTimestampCounter = _timestampCounter.get()) < newTimestamp) {\n\t\tif (_timestampCounter.compareAndSet(currentTimestampCounter, newTimestamp)) break;\n\t}\n}", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r473349596", "createdAt": "2020-08-19T21:40:28Z", "author": {"login": "OlegMazurov"}, "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,128 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n+    }\n+\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    private static long roundUp(long timestamp) {\n+        assert timestamp >= 0;\n+        long remainder = timestamp % TIMESTAMP_INCREMENT;\n+        if (remainder == 0) {\n+            return timestamp;\n+        }\n+        return timestamp - remainder + TIMESTAMP_INCREMENT;\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        newTimestamp = roundUp(newTimestamp);\n+        if (newTimestamp > _timestampCounter.get()) {\n+            if (newTimestamp> _maxReservedTimestamp) {\n+                reserveNextBlock(newTimestamp);\n+            }\n+            long currentTimestampCounter;\n+            while ((currentTimestampCounter = _timestampCounter.get()) < newTimestamp) {\n+                _timestampCounter.compareAndSet(currentTimestampCounter, newTimestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd01c0d07609a5458fdf208f5f43cbce76949a4e"}, "originalPosition": 119}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d340d4a2a7ac773c387d1910838c17fae07dd0b", "author": {"user": {"login": "arnaud-splice", "name": "Arnaud Lacurie"}}, "url": "https://github.com/splicemachine/spliceengine/commit/5d340d4a2a7ac773c387d1910838c17fae07dd0b", "committedDate": "2020-08-20T09:16:26Z", "message": "DB-9455 Address more comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNzMwNjg4", "url": "https://github.com/splicemachine/spliceengine/pull/3706#pullrequestreview-471730688", "createdAt": "2020-08-20T15:27:22Z", "commit": {"oid": "5d340d4a2a7ac773c387d1910838c17fae07dd0b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNzM4NTEz", "url": "https://github.com/splicemachine/spliceengine/pull/3706#pullrequestreview-471738513", "createdAt": "2020-08-20T15:32:44Z", "commit": {"oid": "5d340d4a2a7ac773c387d1910838c17fae07dd0b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxOTg4NTUy", "url": "https://github.com/splicemachine/spliceengine/pull/3706#pullrequestreview-471988552", "createdAt": "2020-08-20T21:10:28Z", "commit": {"oid": "5d340d4a2a7ac773c387d1910838c17fae07dd0b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1f5dd028d24214ad5ca87f1ae3007c4a8fddd85", "author": {"user": {"login": "arnaud-splice", "name": "Arnaud Lacurie"}}, "url": "https://github.com/splicemachine/spliceengine/commit/a1f5dd028d24214ad5ca87f1ae3007c4a8fddd85", "committedDate": "2020-08-20T22:19:59Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9455"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1279, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}