{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwMDE2NTgz", "number": 4253, "title": "DB-9009 DB-10435 implement Foreign Key ON DELETE SET NULL", "bodyText": "", "createdAt": "2020-10-08T15:40:21Z", "url": "https://github.com/splicemachine/spliceengine/pull/4253", "merged": true, "mergeCommit": {"oid": "263face5a1dd45a4b58620d186c824b9a84115c1"}, "closed": true, "closedAt": "2020-10-15T14:06:00Z", "author": {"login": "hatyo"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQjbMMAH2gAyNTAwMDE2NTgzOjQ4OGQ0NDU4MjIyZGE5ZjIxYTA2N2M5NjY4YTc2MDE0ZmQ4MzkzZmI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdSR55lAFqTUwNzkxMzY2Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "488d4458222da9f21a067c9668a76014fd8393fb", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/488d4458222da9f21a067c9668a76014fd8393fb", "committedDate": "2020-10-08T15:36:24Z", "message": "DB-9009 implement FK ON DELETE SET NULL."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f113738d59d877946937c0988bf2b6d11715dec", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/8f113738d59d877946937c0988bf2b6d11715dec", "committedDate": "2020-10-08T15:37:02Z", "message": "DB-9009 refactoring and cleaning up."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bed852b3949b015f6ddea7f6d489b7c407957c7d", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/bed852b3949b015f6ddea7f6d489b7c407957c7d", "committedDate": "2020-10-08T17:04:42Z", "message": "DB-9009 address spotbugs issues."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9fa652767e34e1fe0a92ba8658619cb4819badd", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/d9fa652767e34e1fe0a92ba8658619cb4819badd", "committedDate": "2020-10-08T18:02:47Z", "message": "DB-9009 make FK tests green."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e868cbfa2c6bc8efd7a4b92901b22ab8185debcb", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/e868cbfa2c6bc8efd7a4b92901b22ab8185debcb", "committedDate": "2020-10-08T19:55:26Z", "message": "DB-9009 add tests and fixes.\n\n- add tests for ON DELETE SET NULL.\n- fix self-referencing FK with ON DELETE SET NULL.\n- other smaller fixes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be8ecb2293a12ebfaec9b4bf49bb0cc0729e47ea", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/be8ecb2293a12ebfaec9b4bf49bb0cc0729e47ea", "committedDate": "2020-10-08T19:57:16Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9009"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb96fc91fb918b8bef0c2a2a06073618ac3cd914", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/bb96fc91fb918b8bef0c2a2a06073618ac3cd914", "committedDate": "2020-10-08T20:15:10Z", "message": "DB-10435 Add test."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1NjIxNzE1", "url": "https://github.com/splicemachine/spliceengine/pull/4253#pullrequestreview-505621715", "createdAt": "2020-10-09T12:23:18Z", "commit": {"oid": "bb96fc91fb918b8bef0c2a2a06073618ac3cd914"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMjoyMzoxOFrOHfHbZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMjozMTo0NVrOHfHs3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4OTYwNA==", "bodyText": "Shouldn't we flush the rows that were written before the failure?", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r502389604", "createdAt": "2020-10-09T12:23:18Z", "author": {"login": "dgomezferro"}, "path": "splice_machine/src/main/java/com/splicemachine/pipeline/foreignkey/ForeignKeyParentInterceptWriteHandler.java", "diffHunk": "@@ -80,135 +79,68 @@ private boolean isForeignKeyInterceptNecessary(KVPair.Type type) {\n         return type == KVPair.Type.DELETE;\n     }\n \n-\n-    @Override\n-    public void flush(WriteContext ctx) throws IOException {\n-        try {\n-            // TODO Buffer with skip scan\n-            for (int k = 0; k<mutations.size();k++) {\n-                KVPair mutation = mutations.get(k);\n-                for (int i = 0; i < referencingIndexConglomerateIds.size(); i++) {\n-                    long indexConglomerateId = referencingIndexConglomerateIds.get(i);\n-                    Partition table = null;\n-                    if (childPartitions.containsKey(indexConglomerateId))\n-                        table = childPartitions.get(indexConglomerateId);\n-                    else {\n-                        table = SIDriver.driver().getTableFactory().getTable(Long.toString((indexConglomerateId)));\n-                        childPartitions.put(indexConglomerateId, table);\n-                    }\n-                    if (hasReferences(indexConglomerateId, table, mutation, ctx))\n-                        failRow(mutation, ctx, constraintInfos.get(i));\n-                    else\n-                        ctx.success(mutation);\n+    private void ensureBuffers(WriteContext context) throws Exception {\n+        if (shouldRefreshActions) {\n+            assert childBaseTableConglomerateIds.size() == constraintInfos.size()\n+                    && childBaseTableConglomerateIds.size() == referencingIndexConglomerateIds.size();\n+            for (int i = 0; i < childBaseTableConglomerateIds.size(); i++) {\n+                Pair<Long, Long> needle = new Pair<>(childBaseTableConglomerateIds.get(i), referencingIndexConglomerateIds.get(i));\n+                if(!actions.containsKey(needle)) {\n+                    actions.put(needle, ActionFactory.createAction(childBaseTableConglomerateIds.get(i),\n+                            referencingIndexConglomerateIds.get(i), constraintInfos.get(i), context,\n+                            parentTableName, txnOperationFactory, violationProcessor));\n                 }\n             }\n-        } catch (Exception e) {\n-            violationProcessor.failWrite(e, ctx);\n-        }\n-\n-    }\n-\n-    @Override\n-    public void close(WriteContext ctx) throws IOException {\n-        mutations.clear();\n-        for (Partition table:childPartitions.values()) {\n-            if (table != null)\n-                table.close();\n+            shouldRefreshActions = false;\n         }\n     }\n \n     @Override\n-    public String toString() {\n-        return getClass().getSimpleName();\n-    }\n-\n-            /*\n-         * The way prefix keys work is that longer keys sort after shorter keys. We\n-         * are already starting exactly where we want to be, and we want to end as soon\n-         * as we hit a record which is not this key.\n-         *\n-         * Historically, we did this by using an HBase PrefixFilter. We can do that again,\n-         * but it's a bit of a pain to make that work in an architecture-independent\n-         * way (we would need to implement a version of that for other architectures,\n-         * for example. It's much easier for us to just make use of row key sorting\n-         * to do the job for us.\n-         *\n-         * We start where we want, and we need to end as soon as we run off that. The\n-         * first key which is higher than the start key is the start key as a prefix followed\n-         * by 0x00 (in unsigned sort order). Therefore, we make the end key\n-         * [startKey | 0x00].\n-         */\n-\n-\n-        private boolean hasReferences(Long indexConglomerateId, Partition table, KVPair kvPair, WriteContext ctx) throws IOException {\n-        byte[] startKey = kvPair.getRowKey();\n-        //make sure this is a transactional scan\n-        DataScan scan = txnOperationFactory.newDataScan(null); // Non-Transactional, will resolve on this side\n-        scan =scan.startKey(startKey);\n-        byte[] endKey = Bytes.unsignedCopyAndIncrement(startKey);//new byte[startKey.length+1];\n-        scan = scan.stopKey(endKey);\n-\n-            SimpleTxnFilter readUncommittedFilter;\n-            SimpleTxnFilter readCommittedFilter;\n-            if (ctx.getTxn() instanceof ActiveWriteTxn) {\n-                readCommittedFilter = new SimpleTxnFilter(Long.toString(indexConglomerateId), ((ActiveWriteTxn) ctx.getTxn()).getReadCommittedActiveTxn(), NoOpReadResolver.INSTANCE, SIDriver.driver().getTxnStore());\n-                readUncommittedFilter = new SimpleTxnFilter(Long.toString(indexConglomerateId), ((ActiveWriteTxn) ctx.getTxn()).getReadUncommittedActiveTxn(), NoOpReadResolver.INSTANCE, SIDriver.driver().getTxnStore());\n-\n+    public void next(KVPair mutation, WriteContext ctx) {\n+        if (isForeignKeyInterceptNecessary(mutation.getType())) {\n+            if(failed) {\n+                ctx.notRun(mutation);\n+                return;\n             }\n-            else if (ctx.getTxn() instanceof WritableTxn) {\n-                readCommittedFilter = new SimpleTxnFilter(Long.toString(indexConglomerateId), ((WritableTxn) ctx.getTxn()).getReadCommittedActiveTxn(), NoOpReadResolver.INSTANCE, SIDriver.driver().getTxnStore());\n-                readUncommittedFilter = new SimpleTxnFilter(Long.toString(indexConglomerateId), ((WritableTxn) ctx.getTxn()).getReadUncommittedActiveTxn(), NoOpReadResolver.INSTANCE, SIDriver.driver().getTxnStore());\n+            try {\n+                ensureBuffers(ctx);\n+            } catch (Exception e) {\n+                ctx.failed(mutation, WriteResult.failed(e.getMessage()));\n+                return;\n             }\n-            else\n-                throw new IOException(\"invalidTxn\");\n-        try(DataScanner scanner = table.openScanner(scan)) {\n-            List<DataCell> next;\n-            while ((next = scanner.next(-1)) != null && !next.isEmpty()) {\n-                readCommittedFilter.reset();\n-                readUncommittedFilter.reset();\n-                if (hasData(next, readCommittedFilter) || hasData(next, readUncommittedFilter))\n-                    return true;\n+            for(Action action : actions.values()) {\n+                action.next(mutation, ctx);\n+                if(action.hasFailed()) {\n+                    failed = true;\n+                    ctx.failed(mutation, action.getWriteResult());\n+                    break;\n+                }\n             }\n-            return false;\n-        }catch (Exception e) {\n-            throw new IOException(e);\n+        }\n+        if(!failed) {\n+            ctx.success(mutation);\n+            ctx.sendUpstream(mutation);\n         }\n     }\n \n-    private boolean hasData(List<DataCell> next, SimpleTxnFilter txnFilter) throws IOException {\n-        int cellCount = next.size();\n-        for(DataCell dc:next){\n-            DataFilter.ReturnCode rC = txnFilter.filterCell(dc);\n-            switch(rC){\n-                case NEXT_ROW:\n-                    return false; //the entire row is filtered\n-                case SKIP:\n-                case NEXT_COL:\n-                case SEEK:\n-                    cellCount--; //the cell is filtered\n-                    break;\n-                case INCLUDE:\n-                case INCLUDE_AND_NEXT_COL: //the cell is included\n-                default:\n-                    break;\n+    @Override\n+    public void flush(WriteContext ctx) throws IOException {\n+        if(failed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb96fc91fb918b8bef0c2a2a06073618ac3cd914"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MDc2Mw==", "bodyText": "Should it be getFailedWriteResult() ?", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r502390763", "createdAt": "2020-10-09T12:25:27Z", "author": {"login": "dgomezferro"}, "path": "splice_machine/src/main/java/com/splicemachine/pipeline/foreignkey/actions/Action.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package com.splicemachine.pipeline.foreignkey.actions;\n+\n+import com.splicemachine.pipeline.client.WriteResult;\n+import com.splicemachine.pipeline.writehandler.WriteHandler;\n+\n+import java.util.Objects;\n+\n+public abstract class Action implements WriteHandler  {\n+\n+    protected final Long childBaseTableConglomId;\n+    protected final Long backingIndexConglomId;\n+    protected boolean failed;\n+    protected WriteResult writeResult;\n+\n+    protected Action(Long childBaseTableConglomId, Long backingIndexConglomId) {\n+        this.childBaseTableConglomId = childBaseTableConglomId;\n+        this.backingIndexConglomId = backingIndexConglomId;\n+        this.failed = false;\n+        this.writeResult = null;\n+    }\n+\n+    public boolean hasFailed() {\n+        return failed;\n+    }\n+\n+    public WriteResult getWriteResult() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb96fc91fb918b8bef0c2a2a06073618ac3cd914"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MTU4MA==", "bodyText": "Please handle properly", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r502391580", "createdAt": "2020-10-09T12:26:59Z", "author": {"login": "dgomezferro"}, "path": "splice_machine/src/main/java/com/splicemachine/pipeline/foreignkey/actions/OnDeleteSetNull.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.splicemachine.pipeline.foreignkey.actions;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.services.io.FormatableBitSet;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.impl.sql.execute.ValueRow;\n+import com.splicemachine.ddl.DDLMessage;\n+import com.splicemachine.derby.stream.output.WriteReadUtils;\n+import com.splicemachine.derby.stream.output.update.NonPkRowHash;\n+import com.splicemachine.derby.utils.marshall.EntryDataHash;\n+import com.splicemachine.derby.utils.marshall.dvd.DescriptorSerializer;\n+import com.splicemachine.derby.utils.marshall.dvd.VersionedSerializers;\n+import com.splicemachine.kvpair.KVPair;\n+import com.splicemachine.pipeline.client.WriteResult;\n+import com.splicemachine.pipeline.context.WriteContext;\n+import com.splicemachine.pipeline.foreignkey.ForeignKeyViolationProcessor;\n+import com.splicemachine.si.api.data.TxnOperationFactory;\n+\n+import java.util.Arrays;\n+\n+public class OnDeleteSetNull extends OnDeleteAbstractAction {\n+\n+    private final boolean isSelfReferencing;\n+\n+    public OnDeleteSetNull(Long childBaseTableConglomId,\n+                           Long backingIndexConglomId,\n+                           DDLMessage.FKConstraintInfo constraintInfo,\n+                           WriteContext writeContext,\n+                           TxnOperationFactory txnOperationFactory,\n+                           ForeignKeyViolationProcessor violationProcessor) throws Exception {\n+        super(childBaseTableConglomId, backingIndexConglomId, constraintInfo, writeContext, txnOperationFactory, violationProcessor);\n+        isSelfReferencing = childBaseTableConglomId == constraintInfo.getParentTableConglomerate();\n+    }\n+\n+    private KVPair constructUpdateToNull(byte[] rowId ) throws StandardException {\n+        int colCount = constraintInfo.getTable().getFormatIdsCount();\n+        int[] keyColumns = constraintInfo.getColumnIndicesList().stream().mapToInt(i -> i).toArray();\n+        int[] oneBased = new int[colCount + 1];\n+        for (int i = 0; i < colCount; ++i) {\n+            oneBased[i + 1] = i;\n+        }\n+        FormatableBitSet heapSet = new FormatableBitSet(oneBased.length);\n+        ExecRow execRow = WriteReadUtils.getExecRowFromTypeFormatIds(constraintInfo.getTable().getFormatIdsList().stream().mapToInt(i -> i).toArray());\n+        for (int keyColumn : keyColumns) {\n+            execRow.setColumn(keyColumn, execRow.getColumn(keyColumn).getNewNull());\n+            heapSet.set(keyColumn);\n+        }\n+        DescriptorSerializer[] serializers = VersionedSerializers.forVersion(constraintInfo.getTable().getTableVersion(), true).getSerializers(execRow);\n+        EntryDataHash entryEncoder = new NonPkRowHash(oneBased, null, serializers, heapSet);\n+        ValueRow rowToEncode = new ValueRow(execRow.getRowArray().length);\n+        rowToEncode.setRowArray(execRow.getRowArray());\n+        entryEncoder.setRow(rowToEncode);\n+        byte[] value = entryEncoder.encode();\n+        return new KVPair(rowId, value, KVPair.Type.UPDATE);\n+    }\n+\n+    @Override\n+    protected WriteResult handleExistingRow(byte[] indexRowId, byte[] sourceRowKey) throws Exception {\n+        byte[] baseTableRowId = new byte[0];\n+        try {\n+            baseTableRowId = toChildBaseRowId(indexRowId, constraintInfo);\n+        } catch (StandardException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb96fc91fb918b8bef0c2a2a06073618ac3cd914"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5NDA3OA==", "bodyText": "Can you test it with \"permissive\" imports? If we allow up to N badRecords and some records violate the FK constraint, we should log them but import the rest, does that work?", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r502394078", "createdAt": "2020-10-09T12:31:45Z", "author": {"login": "dgomezferro"}, "path": "splice_machine/src/test/java/com/splicemachine/foreignkeys/ForeignKeyActionIT.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.foreignkeys;\n+\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import com.splicemachine.derby.test.framework.TestConnection;\n+import com.splicemachine.test_dao.TableDAO;\n+import com.splicemachine.util.StatementUtils;\n+import org.junit.*;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Statement;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Foreign key tests for referential actions:\n+ *\n+ * ON DELETE NO ACTION\n+ * ON DELETE CASCADE\n+ * ON DELETE SET NULL\n+ * ON UPDATE NO ACTION\n+ */\n+public class ForeignKeyActionIT {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb96fc91fb918b8bef0c2a2a06073618ac3cd914"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f557ff1d7eb3edf6a99bccc527abcde6e30f203a", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/f557ff1d7eb3edf6a99bccc527abcde6e30f203a", "committedDate": "2020-10-12T07:00:07Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9009"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a112b13605964b374f99a0f71b4bf8358d639a9b", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/a112b13605964b374f99a0f71b4bf8358d639a9b", "committedDate": "2020-10-12T11:28:41Z", "message": "DB-9009 address comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a67c4e7532a033098c2dbe79e1c9cd3a756eebac", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/a67c4e7532a033098c2dbe79e1c9cd3a756eebac", "committedDate": "2020-10-12T11:36:23Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9009"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30c5d9c6f571c6a4af826e0a9e395b86504ce392", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/30c5d9c6f571c6a4af826e0a9e395b86504ce392", "committedDate": "2020-10-12T14:28:35Z", "message": "DB-9009 fix spotbugs issues."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MTg5NDY4", "url": "https://github.com/splicemachine/spliceengine/pull/4253#pullrequestreview-507189468", "createdAt": "2020-10-13T08:27:12Z", "commit": {"oid": "30c5d9c6f571c6a4af826e0a9e395b86504ce392"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MjY2OTY0", "url": "https://github.com/splicemachine/spliceengine/pull/4253#pullrequestreview-507266964", "createdAt": "2020-10-13T09:57:00Z", "commit": {"oid": "488d4458222da9f21a067c9668a76014fd8393fb"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwOTo1NzowMFrOHge5rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxMDoyNTowNlrOHgf6vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyMjc2NA==", "bodyText": "It seems the third argument can be built from the fourth. Is it possible to build it inside the function and make the signature cleaner?", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r503822764", "createdAt": "2020-10-13T09:57:00Z", "author": {"login": "ascend1"}, "path": "splice_machine/src/main/java/com/splicemachine/pipeline/foreignkey/FKWriteFactoryHolder.java", "diffHunk": "@@ -115,7 +117,8 @@ public void handleForeignKeyAdd(DDLChange ddlChange, long onConglomerateNumber)\n         TentativeFK tentativeFKAdd = ddlChange.getTentativeFK();\n         // We are configuring a write context on the PARENT base-table or unique-index.\n         if (onConglomerateNumber == tentativeFKAdd.getReferencedConglomerateNumber()) {\n-            addParentInterceptWriteFactory(tentativeFKAdd.getReferencedTableName(), ImmutableList.of(tentativeFKAdd.getReferencingConglomerateNumber()),ImmutableList.of(tentativeFKAdd.getFkConstraintInfo()));\n+            addParentInterceptWriteFactory(tentativeFKAdd.getReferencedTableName(), ImmutableList.of(tentativeFKAdd.getReferencingConglomerateNumber()),\n+                    ImmutableList.of(tentativeFKAdd.getFkConstraintInfo().getTable().getConglomerate()),ImmutableList.of(tentativeFKAdd.getFkConstraintInfo()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "488d4458222da9f21a067c9668a76014fd8393fb"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgzMTc3Ng==", "bodyText": "Maybe a bit more description about the special case?", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r503831776", "createdAt": "2020-10-13T10:12:01Z", "author": {"login": "ascend1"}, "path": "splice_machine/src/main/java/com/splicemachine/pipeline/foreignkey/ForeignKeyParentInterceptWriteHandler.java", "diffHunk": "@@ -42,35 +65,261 @@\n  */\n @NotThreadSafe\n public class ForeignKeyParentInterceptWriteHandler implements WriteHandler{\n+\n+    private boolean failed;\n+\n+    static class ChildBaseTableContext {\n+        public ChildBaseTableContext(Long conglomerateId,\n+                                     Long fkIndexConglomerateId,\n+                                     DDLMessage.FKConstraintInfo constraintInfo,\n+                                     WriteContext context) throws Exception {\n+            this.conglomerateId = conglomerateId;\n+            this.fkIndexConglomerateId = fkIndexConglomerateId;\n+            this.mutationBuffer = new ObjectObjectHashMap<>();\n+            this.pipelineBuffer = context.getSharedWriteBuffer(\n+                    DDLUtils.getIndexConglomBytes(conglomerateId),\n+                    this.mutationBuffer,\n+                    1000 * 2 + 10,\n+                    true,\n+                    context.getTxn(),\n+                    context.getToken());\n+            this.constraintInfo = constraintInfo;\n+        }\n+        public final Long conglomerateId;\n+        public final Long fkIndexConglomerateId;\n+        public final ObjectObjectHashMap<KVPair, KVPair> mutationBuffer;\n+        public final CallBuffer<KVPair> pipelineBuffer;\n+        public final DDLMessage.FKConstraintInfo constraintInfo;\n+    }\n+\n     private final List<Long> referencingIndexConglomerateIds;\n+    private List<Long> childBaseTableConglomerateIds;\n+    private boolean childContextsCreated = false;\n+    List<ChildBaseTableContext> childBaseTableContexts;\n     private final List<DDLMessage.FKConstraintInfo> constraintInfos;\n     private final ForeignKeyViolationProcessor violationProcessor;\n     private TxnOperationFactory txnOperationFactory;\n     private HashMap<Long,Partition> childPartitions = new HashMap<>();\n     private String parentTableName;\n+    private transient DataGet baseGet = null;\n     private ObjectArrayList<KVPair> mutations = new ObjectArrayList<>();\n \n \n     public ForeignKeyParentInterceptWriteHandler(String parentTableName,\n                                                  List<Long> referencingIndexConglomerateIds,\n-                                                 PipelineExceptionFactory exceptionFactory,\n-                                                 List<DDLMessage.FKConstraintInfo> constraintInfos\n+                                                 List<Long> childBaseTableConglomerateIds,\n+                                                 List<DDLMessage.FKConstraintInfo> constraintInfos,\n+                                                 PipelineExceptionFactory exceptionFactory\n                                                  ) {\n         this.referencingIndexConglomerateIds = referencingIndexConglomerateIds;\n+        this.childBaseTableConglomerateIds = childBaseTableConglomerateIds;\n+        this.childBaseTableContexts = new ArrayList<>();\n         this.violationProcessor = new ForeignKeyViolationProcessor(\n                 new ForeignKeyViolationProcessor.ParentFkConstraintContextProvider(parentTableName),exceptionFactory);\n         this.constraintInfos = constraintInfos;\n         this.txnOperationFactory = SIDriver.driver().getOperationFactory();\n         this.parentTableName = parentTableName;\n     }\n \n+    private boolean ensureBuffers(WriteContext context) {\n+        if (!childContextsCreated) {\n+            assert childBaseTableConglomerateIds.size() == constraintInfos.size();\n+            for (int i = 0; i < childBaseTableConglomerateIds.size(); i++) {\n+               if(constraintInfos.get(i).getDeleteRule() == StatementType.RA_SETNULL) {\n+                   try {\n+                       childBaseTableContexts.add(new ChildBaseTableContext(childBaseTableConglomerateIds.get(i),\n+                               referencingIndexConglomerateIds.get(i), constraintInfos.get(i), context));\n+                   } catch (Exception e) {\n+                       // todo improve this\n+                       return false;\n+                   }\n+               }\n+            }\n+            childContextsCreated = true;\n+        }\n+        return true;\n+    }\n+\n     @Override\n     public void next(KVPair mutation, WriteContext ctx) {\n+        if(failed) {\n+            ctx.notRun(mutation);\n+            return;\n+        }\n         if (isForeignKeyInterceptNecessary(mutation.getType())) {\n+            ensureBuffers(ctx); // todo handle failures properly\n             mutations.add(mutation);\n+            for(ChildBaseTableContext childBaseTableContext : childBaseTableContexts) {\n+                if(!checkReferencesAndUpdateChildBuffers(mutation, ctx, childBaseTableContext)) {\n+                    failed = true;\n+                    failRow(mutation, ctx, childBaseTableContext.constraintInfo);\n+                    break;\n+                }\n+            }\n+        }\n+        if(!failed) {\n+            ctx.success(mutation);\n+            ctx.sendUpstream(mutation);\n+        }\n+    }\n+\n+    /*\n+     * The way prefix keys work is that longer keys sort after shorter keys. We\n+     * are already starting exactly where we want to be, and we want to end as soon\n+     * as we hit a record which is not this key.\n+     *\n+     * Historically, we did this by using an HBase PrefixFilter. We can do that again,\n+     * but it's a bit of a pain to make that work in an architecture-independent\n+     * way (we would need to implement a version of that for other architectures,\n+     * for example. It's much easier for us to just make use of row key sorting\n+     * to do the job for us.\n+     *\n+     * We start where we want, and we need to end as soon as we run off that. The\n+     * first key which is higher than the start key is the start key as a prefix followed\n+     * by 0x00 (in unsigned sort order). Therefore, we make the end key\n+     * [startKey | 0x00].\n+     */\n+    private static DataScan prepareScan(TxnOperationFactory factory, TxnView txnView, KVPair needle) {\n+        byte[] startKey = needle.getRowKey();\n+        byte[] stopKey = Bytes.unsignedCopyAndIncrement(startKey); // +1 from startKey.\n+        DataScan scan = factory.newDataScan(txnView);\n+        return scan.startKey(startKey).stopKey(stopKey);\n+    }\n+\n+    private static Pair<SimpleTxnFilter, SimpleTxnFilter> prepareScanFilters(TxnView txnView, long indexConglomerateId) throws IOException {\n+        SimpleTxnFilter readUncommittedFilter, readCommittedFilter;\n+        if (txnView instanceof ActiveWriteTxn) {\n+            readCommittedFilter = new SimpleTxnFilter(Long.toString(indexConglomerateId), ((ActiveWriteTxn) txnView).getReadCommittedActiveTxn(), NoOpReadResolver.INSTANCE, SIDriver.driver().getTxnStore());\n+            readUncommittedFilter = new SimpleTxnFilter(Long.toString(indexConglomerateId), ((ActiveWriteTxn) txnView).getReadUncommittedActiveTxn(), NoOpReadResolver.INSTANCE, SIDriver.driver().getTxnStore());\n+\n+        } else if (txnView instanceof WritableTxn) {\n+            readCommittedFilter = new SimpleTxnFilter(Long.toString(indexConglomerateId), ((WritableTxn) txnView).getReadCommittedActiveTxn(), NoOpReadResolver.INSTANCE, SIDriver.driver().getTxnStore());\n+            readUncommittedFilter = new SimpleTxnFilter(Long.toString(indexConglomerateId), ((WritableTxn) txnView).getReadUncommittedActiveTxn(), NoOpReadResolver.INSTANCE, SIDriver.driver().getTxnStore());\n+        } else {\n+            throw new IOException(\"invalidTxn,\");\n         }\n-        ctx.sendUpstream(mutation);\n+        return Pair.newPair(readCommittedFilter, readUncommittedFilter);\n     }\n+\n+    private byte[] isVisible(List<DataCell> next, SimpleTxnFilter txnFilter) throws IOException {\n+        int cellCount = next.size();\n+        for(DataCell dc:next){\n+            DataFilter.ReturnCode rC = txnFilter.filterCell(dc);\n+            switch(rC){\n+                case NEXT_ROW:\n+                    return null; //the entire row is filtered\n+                case SKIP:\n+                case NEXT_COL:\n+                case SEEK:\n+                    cellCount--; //the cell is filtered\n+                    break;\n+                case INCLUDE:\n+                case INCLUDE_AND_NEXT_COL: //the cell is included\n+                default:\n+                    break;\n+            }\n+        }\n+        if(cellCount > 0) {\n+            return next.get(0).key();\n+        }\n+        return null;\n+    }\n+\n+    private static byte[] toChildBaseRowId(byte[] indexRowId, DDLMessage.FKConstraintInfo fkConstraintInfo) {\n+        // 1. determine the position\n+        MultiFieldDecoder multiFieldDecoder = MultiFieldDecoder.create();\n+        TypeProvider typeProvider = VersionedSerializers.typesForVersion(fkConstraintInfo.getParentTableVersion());\n+        int position = 0;\n+        multiFieldDecoder.set(indexRowId);\n+        for (int i = 0; i < fkConstraintInfo.getFormatIdsCount(); i++) {\n+            if (multiFieldDecoder.nextIsNull()) {\n+                return null;\n+            }\n+            if (fkConstraintInfo.getFormatIds(i) == StoredFormatIds.SQL_DOUBLE_ID) {\n+                position += multiFieldDecoder.skipDouble();\n+            } else if (fkConstraintInfo.getFormatIds(i) == StoredFormatIds.SQL_REAL_ID) {\n+                position += multiFieldDecoder.skipFloat();\n+            } else if (typeProvider.isScalar(fkConstraintInfo.getFormatIds(i))) {\n+                position += multiFieldDecoder.skipLong();\n+            } else {\n+                position += multiFieldDecoder.skip();\n+            }\n+        }\n+        int lastKeyIndex = position - 2;\n+\n+        if (lastKeyIndex == indexRowId.length - 1) {\n+            return null; // special case.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "488d4458222da9f21a067c9668a76014fd8393fb"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgzOTQyMw==", "bodyText": "What will happen if the foreign key column is not nullable? Do we have such a test case?\ncreate table SRT (a int primary key, b int not null, constraint fk foreign key (B) references SRT(a) on delete set null);\nProbably should throw already in binding phase since it's semantically conflicting.", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r503839423", "createdAt": "2020-10-13T10:25:06Z", "author": {"login": "ascend1"}, "path": "splice_machine/src/test/java/com/splicemachine/foreignkeys/ForeignKeyActionIT.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.foreignkeys;\n+\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import com.splicemachine.derby.test.framework.TestConnection;\n+import com.splicemachine.test_dao.TableDAO;\n+import com.splicemachine.util.StatementUtils;\n+import org.junit.*;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Statement;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Foreign key tests for referential actions:\n+ *\n+ * ON DELETE NO ACTION\n+ * ON DELETE CASCADE\n+ * ON DELETE SET NULL\n+ * ON UPDATE NO ACTION\n+ */\n+public class ForeignKeyActionIT {\n+\n+    private static final String SCHEMA = ForeignKeyActionIT.class.getSimpleName();\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    @Rule\n+    public SpliceWatcher methodWatcher = new SpliceWatcher(SCHEMA);\n+\n+    private TestConnection conn;\n+    @Before\n+    public void deleteTables() throws Exception {\n+        conn = methodWatcher.getOrCreateConnection();\n+        conn.setAutoCommit(false);\n+        new TableDAO(conn).drop(SCHEMA, \"SRT\", \"LC\", \"YAC\", \"AC\", \"AP\", \"C\", \"P\");\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception{\n+        conn.rollback();\n+        conn.reset();\n+    }\n+\n+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+    //\n+    // fk references unique index\n+    //\n+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+\n+    private static void createDatabaseObjects1(Statement s) throws SQLException {\n+        s.executeUpdate(\"create table P (a int unique, b int)\");\n+        s.executeUpdate(\"create table C (a int, b int, CONSTRAINT FK_1 FOREIGN KEY (a) REFERENCES P(a) ON DELETE NO ACTION)\");\n+        s.executeUpdate(\"insert into P values(1,10),(2,20),(3,30)\");\n+        s.executeUpdate(\"insert into C values(1,10),(1,15),(2,20),(2,20),(3,30),(3,35)\");\n+    }\n+\n+    @Test\n+    public void onDeleteNoAction() throws Exception {\n+        try(Statement s = conn.createStatement()){\n+            createDatabaseObjects1(s);\n+            assertQueryFail(s,\"delete from P where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+            assertQueryFail(s,\"update P set a=-1 where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+        }\n+    }\n+\n+    @Test\n+    public void onDeleteNoActionImplicit() throws Exception {\n+        try(Statement s = conn.createStatement()){\n+            createDatabaseObjects1(s);\n+\n+            assertQueryFail(s,\"delete from P where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+            assertQueryFail(s,\"update P set a=-1 where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+        }\n+    }\n+\n+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+    //\n+    // fk references primary key\n+    //\n+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+\n+    @Test\n+    public void onDeleteNoActionPrimaryKey() throws Exception {\n+        try(Statement s = conn.createStatement()){\n+            createDatabaseObjects1(s);\n+\n+            assertQueryFail(s,\"delete from P where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+            assertQueryFail(s,\"update P set a=-1 where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+        }\n+    }\n+\n+    /* Make sure FKs still work when we create the parent, write to it first, then create the child that actually has the FK */\n+    @Test\n+    public void onDeleteNoActionPrimaryKeyInitializeWriteContextOfParentFirst() throws Exception {\n+        try(Statement s = conn.createStatement()){\n+            s.executeUpdate(\"create table P (a int primary key, b int unique)\");\n+            s.executeUpdate(\"insert into P values(1,10),(2,20),(3,30),(4,40)\");\n+\n+            s.executeUpdate(\"create table C1 (a int, b int, CONSTRAINT FK_1 FOREIGN KEY (a) REFERENCES P(a))\");\n+            s.executeUpdate(\"insert into C1 values(1,10),(1,15),(2,20),(2,20),(3,30),(3,35)\");\n+\n+            assertQueryFail(s,\"delete from P where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+            assertQueryFail(s,\"update P set a=-1 where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+\n+            s.executeUpdate(\"create table C2 (a int, b int, CONSTRAINT FK_2 FOREIGN KEY (b) REFERENCES P(b))\");\n+            s.executeUpdate(\"insert into C2 values(4,40)\");\n+\n+            // verify NEW FK constraint works\n+            assertQueryFail(s,\"delete from P where a = 4\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_2' for key (B).  The statement has been rolled back.\");\n+            assertQueryFail(s,\"update P set b=-1 where a = 4\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_2' for key (B).  The statement has been rolled back.\");\n+\n+            // verify FIRST FK constraint STILL works\n+            assertQueryFail(s,\"delete from P where a = 1\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+            assertQueryFail(s,\"update P set a=-1 where a = 1\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+        }\n+    }\n+\n+    @Test\n+    public void onDeleteNoActionPrimaryKeySuccessAfterDeleteReference() throws Exception {\n+        try(Statement s = conn.createStatement()){\n+            createDatabaseObjects1(s);\n+\n+            assertQueryFail(s,\"delete from P where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+            assertQueryFail(s,\"update P set a=-1 where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+\n+            // delete references\n+            s.executeUpdate(\"delete from C where a=2\");\n+\n+            // now delete from parent should succeed\n+            assertEquals(4L,StatementUtils.onlyLong(s,\"select count(*) from C\"));\n+            assertEquals(1L,s.executeUpdate(\"delete from P where a = 2\"));\n+        }\n+    }\n+\n+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+    //\n+    // FK - ON DELETE SET NULL\n+    //\n+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e868cbfa2c6bc8efd7a4b92901b22ab8185debcb"}, "originalPosition": 160}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0e78c7485a1d769a625c91f05f63814e9e7b4f6", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/a0e78c7485a1d769a625c91f05f63814e9e7b4f6", "committedDate": "2020-10-13T19:07:34Z", "message": "DB-9009 address comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3ODExMDIz", "url": "https://github.com/splicemachine/spliceengine/pull/4253#pullrequestreview-507811023", "createdAt": "2020-10-13T20:39:20Z", "commit": {"oid": "a0e78c7485a1d769a625c91f05f63814e9e7b4f6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3OTEzNjYz", "url": "https://github.com/splicemachine/spliceengine/pull/4253#pullrequestreview-507913663", "createdAt": "2020-10-14T00:19:30Z", "commit": {"oid": "a0e78c7485a1d769a625c91f05f63814e9e7b4f6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1090, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}