{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg0MzE3ODIz", "number": 4110, "title": "DB-10175 Qualify expression-based indexes", "bodyText": "", "createdAt": "2020-09-10T20:52:27Z", "url": "https://github.com/splicemachine/spliceengine/pull/4110", "merged": true, "mergeCommit": {"oid": "cc273d938c94c5c1b32a05bef76b7e982a986096"}, "closed": true, "closedAt": "2020-11-04T00:35:00Z", "author": {"login": "ascend1"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdJwT8jgBqjM3Nzc3NTEzOTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZCo8-gFqTUyMjk2ODA5NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "25d6e882bbba3e707d773d8b7694512a409995b5", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/25d6e882bbba3e707d773d8b7694512a409995b5", "committedDate": "2020-09-10T20:47:50Z", "message": "DB-10175 Fix SpotBugs"}, "afterCommit": {"oid": "198a53e02ead69b95bf102b6df95704ea706d167", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/198a53e02ead69b95bf102b6df95704ea706d167", "committedDate": "2020-09-17T12:39:17Z", "message": "DB-10175 Fix SpotBugs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxMDU3MjUz", "url": "https://github.com/splicemachine/spliceengine/pull/4110#pullrequestreview-491057253", "createdAt": "2020-09-17T23:36:47Z", "commit": {"oid": "198a53e02ead69b95bf102b6df95704ea706d167"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMzozNjo0N1rOHT4_8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMzozNjo0N1rOHT4_8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYxODg2Nw==", "bodyText": "Here we set proper ordering to base table columns according to index column ordering. For expression-based indexes, however, I'm not sure what to do here since whether an index column is ascending or descending doesn't really mean anything to the ordering of base table columns.", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r490618867", "createdAt": "2020-09-17T23:36:47Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -436,18 +435,20 @@ public boolean nextAccessPath(Optimizer optimizer,\n                 boolean[] isAscending=irg.isAscending();\n \n                 for(int i=0;i<baseColumnPositions.length;i++){\n-                    int rowOrderDirection=isAscending[i]?RowOrdering.ASCENDING:RowOrdering.DESCENDING;\n-                    int pos = rowOrdering.orderedPositionForColumn(rowOrderDirection,getTableNumber(),baseColumnPositions[i]);\n-                    if (pos == -1) {\n-                        rowOrdering.nextOrderPosition(rowOrderDirection);\n-                        pos = rowOrdering.addOrderedColumn(rowOrderDirection,getTableNumber(),baseColumnPositions[i]);\n-                    }\n-                    // check if the column has a constant predicate like \"col=constant\" defined on it,\n-                    // if so, we can treat it as sorted as it has only one value\n-                    if (pos >=0 &&    /* a column ordering is added or exists */\n-                        hasConstantPredicate(getTableNumber(), baseColumnPositions[i], predList)) {\n-                        ColumnOrdering co = rowOrdering.getOrderedColumn(pos);\n-                        co.setBoundByConstant(true);\n+                    if (!irg.isOnExpression()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198a53e02ead69b95bf102b6df95704ea706d167"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxMDU4ODI4", "url": "https://github.com/splicemachine/spliceengine/pull/4110#pullrequestreview-491058828", "createdAt": "2020-09-17T23:41:26Z", "commit": {"oid": "198a53e02ead69b95bf102b6df95704ea706d167"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMzo0MToyNlrOHT5Fgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMzo0MToyNlrOHT5Fgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyMDI5MQ==", "bodyText": "For now, simply take all expression-based indexes as non-covering indexes. Doing so limits the scope of this change to a manageable size for code review. Treating an expression-based index as a covering index is DB-10236 and will have its own PR.", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r490620291", "createdAt": "2020-09-17T23:41:26Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -516,8 +517,11 @@ public boolean isCoveringIndex(ConglomerateDescriptor cd) throws StandardExcepti\n             return false;\n \n         IndexRowGenerator irg=cd.getIndexDescriptor();\n-        int[] baseCols=irg.baseColumnPositions();\n \n+        if (irg.isOnExpression())\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198a53e02ead69b95bf102b6df95704ea706d167"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxMDYwMjI3", "url": "https://github.com/splicemachine/spliceengine/pull/4110#pullrequestreview-491060227", "createdAt": "2020-09-17T23:45:38Z", "commit": {"oid": "198a53e02ead69b95bf102b6df95704ea706d167"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMzo0NTozOFrOHT5KpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMzo0NTozOFrOHT5KpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyMTYwNA==", "bodyText": "This comment is true only for this change because all expression-based indexes are non-covering indexes. In next step, to rewrite an index expression to a column reference, we do the following:\nrc.setIndexExpression(exprAst);\nrc.setReferenced();\nrc.setVirtualColumnId(i + 1);  // virtual column IDs are 1-based\nrc.setName(idxCD.getConglomerateName() + \"_col\" + rc.getColumnPosition());", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r490621604", "createdAt": "2020-09-17T23:45:38Z", "author": {"login": "ascend1"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -1952,43 +1980,61 @@ private ResultColumnList newResultColumns(\n             boolean cloneRCs)\n             throws StandardException{\n         IndexRowGenerator irg=idxCD.getIndexDescriptor();\n-        int[] baseCols=irg.baseColumnPositions();\n-        ResultColumnList newCols=\n-                (ResultColumnList)getNodeFactory().getNode(\n+        ResultColumnList newCols =\n+                (ResultColumnList) getNodeFactory().getNode(\n                         C_NodeTypes.RESULT_COLUMN_LIST,\n                         getContextManager());\n \n-        for(int basePosition : baseCols){\n-            ResultColumn oldCol=oldColumns.getResultColumn(basePosition);\n-            ResultColumn newCol;\n+        if (irg.isOnExpression()) {\n+            // When building new ResultColumn instances, we don't need to set expression\n+            // or virtual column number as they are not needed. In case of a scan on an\n+            // expression-based index, these are just placeholders. All we care about is\n+            // that they should all be referenced for now so that we can build the\n+            // template row, then we will clear reference status and set them properly.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198a53e02ead69b95bf102b6df95704ea706d167"}, "originalPosition": 150}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "198a53e02ead69b95bf102b6df95704ea706d167", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/198a53e02ead69b95bf102b6df95704ea706d167", "committedDate": "2020-09-17T12:39:17Z", "message": "DB-10175 Fix SpotBugs"}, "afterCommit": {"oid": "f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d", "committedDate": "2020-09-21T09:40:57Z", "message": "DB-10175 Fix SpotBugs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODg4MTk3", "url": "https://github.com/splicemachine/spliceengine/pull/4110#pullrequestreview-493888197", "createdAt": "2020-09-22T22:24:58Z", "commit": {"oid": "f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMjoyNDo1OFrOHWOdNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMDowMzo1NlrOHWQaKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NzU3NQ==", "bodyText": "This logic is not consistent with the original logic. When forIndexExpression is false, the logic will still set otherSide if left has more than one column reference, as long as the first column reference matches the input column reference. With the original logic, otherSide won't be set if there are more than one column references. Is this change intended?", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493067575", "createdAt": "2020-09-22T22:24:58Z", "author": {"login": "yxia92"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryRelationalOperatorNode.java", "diffHunk": "@@ -502,12 +523,27 @@ public boolean selfComparison(ColumnReference cr)\n         ** Figure out which side the given ColumnReference is on,\n         ** and look for the same table on the other side.\n         */\n-        if(lcr != null && lcr.size() == 1 && lcr.get(0) == cr){\n-            otherSide=rightOperand;\n-        }else {\n+        if(lcr != null && !lcr.isEmpty()){\n+            int bound = forIndexExpression ? lcr.size() : 1;\n+            for (int i = 0; i < bound; i++) {\n+                if (lcr.get(i) == cr) {\n+                    otherSide = rightOperand;\n+                    break;\n+                }\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA4Njc1MA==", "bodyText": "I think we are not leveraging the sortorder of the index on expression right now (which could be useful for qualifying merge join and to do orderby elimination), that is fine, but we should track this as a limitation or future enhancement.", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493086750", "createdAt": "2020-09-22T23:21:44Z", "author": {"login": "yxia92"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -436,18 +435,20 @@ public boolean nextAccessPath(Optimizer optimizer,\n                 boolean[] isAscending=irg.isAscending();\n \n                 for(int i=0;i<baseColumnPositions.length;i++){\n-                    int rowOrderDirection=isAscending[i]?RowOrdering.ASCENDING:RowOrdering.DESCENDING;\n-                    int pos = rowOrdering.orderedPositionForColumn(rowOrderDirection,getTableNumber(),baseColumnPositions[i]);\n-                    if (pos == -1) {\n-                        rowOrdering.nextOrderPosition(rowOrderDirection);\n-                        pos = rowOrdering.addOrderedColumn(rowOrderDirection,getTableNumber(),baseColumnPositions[i]);\n-                    }\n-                    // check if the column has a constant predicate like \"col=constant\" defined on it,\n-                    // if so, we can treat it as sorted as it has only one value\n-                    if (pos >=0 &&    /* a column ordering is added or exists */\n-                        hasConstantPredicate(getTableNumber(), baseColumnPositions[i], predList)) {\n-                        ColumnOrdering co = rowOrdering.getOrderedColumn(pos);\n-                        co.setBoundByConstant(true);\n+                    if (!irg.isOnExpression()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYxODg2Nw=="}, "originalCommit": {"oid": "198a53e02ead69b95bf102b6df95704ea706d167"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA4ODI2NA==", "bodyText": "It seems that usefulStartKey() calls BinaryRelationalOperatorNode.usefulStartKey() which relies on leftMatchIndexExpr and rightMatchIndexExpr, however, these two variables are only set in matchIndexExpression() which is called a few lines below.", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493088264", "createdAt": "2020-09-22T23:26:54Z", "author": {"login": "yxia92"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java", "diffHunk": "@@ -183,7 +200,7 @@ public boolean useful(Optimizable optTable,ConglomerateDescriptor cd) throws Sta\n             ** nor a useful stop key for this table, it is not useful\n             ** for limiting an index scan.\n             */\n-            if((!isIn) && (!relop.usefulStartKey(optTable)) && (!relop.usefulStopKey(optTable))){\n+            if((!isIn) && (!relop.usefulStartKey(optTable, id)) && (!relop.usefulStopKey(optTable, id))){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5Mzk2MA==", "bodyText": "Looking at the caller of matchIndexExpression(), the list of column references found does not seem to be really useful, would a boolean as returned value sufficient?", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493093960", "createdAt": "2020-09-22T23:44:51Z", "author": {"login": "yxia92"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java", "diffHunk": "@@ -564,6 +612,58 @@ public static Integer isIndexUseful(Predicate pred,\n         return indexPosition;\n     }\n \n+    // Return an empty list if relOp doesn't match index expression. This is OK because an index expression must\n+    // have at least one column reference. Also, since an index is defined on one table, an index expression\n+    // cannot have column references referencing different tables.\n+    private static List<ColumnReference> matchIndexExpression(RelationalOperator relOp, InListOperatorNode inNode,\n+                                                              boolean isIn, boolean isProbe,\n+                                                              ValueNode indexExprAst, Optimizable optTable)\n+            throws StandardException\n+    {\n+        CollectNodesVisitor cnv = new CollectNodesVisitor(ColumnReference.class);\n+        int tableNumber = optTable.getTableNumber();  // OK to be -1, will be checked when use\n+        if (isIn) {\n+            if (inNode.getLeftOperand().equals(indexExprAst)) {\n+                inNode.getLeftOperand().accept(cnv);\n+                if (isProbe) {\n+                    assert relOp instanceof BinaryOperatorNode;\n+                    BinaryOperatorNode binOp = (BinaryOperatorNode) relOp;\n+                    binOp.setMatchIndexExpr(tableNumber, true);\n+                }\n+            }\n+        } else {\n+            if (relOp instanceof BinaryOperatorNode) {\n+                BinaryOperatorNode binOp = (BinaryOperatorNode) relOp;\n+                if (binOp.getLeftOperand().equals(indexExprAst)) {\n+                    binOp.getLeftOperand().accept(cnv);\n+                    binOp.setMatchIndexExpr(tableNumber, true);\n+                } else if (binOp.getRightOperand().equals(indexExprAst)) {\n+                    binOp.getRightOperand().accept(cnv);\n+                    binOp.setMatchIndexExpr(tableNumber, false);\n+                }\n+            } else if (relOp instanceof IsNullNode) {\n+                IsNullNode isNull = (IsNullNode) relOp;\n+                if (isNull.getOperand().equals(indexExprAst)) {\n+                    isNull.getOperand().accept(cnv);\n+                    // No need to set any matchIndexExpr flag since it won't be used in code generation.\n+                }\n+            }\n+        }\n+        return cnv.getList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjI4Nw==", "bodyText": "Is it possible to cache the constructed AST tree? It seems expensive to re-construct the tree every time we evaluate the predicate list for an index. When there are N-way join and the number of join order permutations goes up, we could get here very frequently.", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493096287", "createdAt": "2020-09-22T23:52:51Z", "author": {"login": "yxia92"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java", "diffHunk": "@@ -522,21 +549,42 @@ public static Integer isIndexUseful(Predicate pred,\n             return null;\n \n         /* Look for an index column on one side of the relop */\n-        if (baseColumnPositions != null) {\n-            for (indexPosition = 0; indexPosition < baseColumnPositions.length; indexPosition++) {\n-                if (isIn) {\n-                    if (inNode.getLeftOperand() instanceof ColumnReference) {\n-                        indexCol = (ColumnReference) inNode.getLeftOperand();\n-                        if ((optTable.getTableNumber() != indexCol.getTableNumber())\n-                                || (indexCol.getColumnNumber() != baseColumnPositions[indexPosition])\n-                                || inNode.selfReference(indexCol))\n-                            indexCol = null;\n+        if (isIndexOnExpr) {\n+            LanguageConnectionContext lcc = pred.getLanguageConnectionContext();\n+            CompilerContext newCC = lcc.pushCompilerContext();\n+            Parser p = newCC.getParser();\n+\n+            String[] exprTexts = indexDescriptor.getExprTexts();\n+            for (indexPosition = 0; indexPosition < exprTexts.length; indexPosition++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5OTU2MQ==", "bodyText": "Can you reset the flag matchIndexExpression in clearScanFlags()?", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493099561", "createdAt": "2020-09-23T00:03:56Z", "author": {"login": "yxia92"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/Predicate.java", "diffHunk": "@@ -81,6 +81,8 @@\n     // getPredScopedForResultSet() method of this class for more.\n     private boolean scoped;\n \n+    private boolean matchIndexExpression;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d", "committedDate": "2020-09-21T09:40:57Z", "message": "DB-10175 Fix SpotBugs"}, "afterCommit": {"oid": "f2259ad89ece5e2bbbe977981c5511bb4becbc3a", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/f2259ad89ece5e2bbbe977981c5511bb4becbc3a", "committedDate": "2020-09-23T16:09:03Z", "message": "DB-10175 Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTA5OTcz", "url": "https://github.com/splicemachine/spliceengine/pull/4110#pullrequestreview-503509973", "createdAt": "2020-10-07T04:05:18Z", "commit": {"oid": "f2259ad89ece5e2bbbe977981c5511bb4becbc3a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c7e264195c5cd1059332c52d5307791bf296e95", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/5c7e264195c5cd1059332c52d5307791bf296e95", "committedDate": "2020-10-07T14:08:11Z", "message": "DB-10175 Expression-based index scan with relational operator preds"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e22d448f521f0b4e81a9edae44a00a40fbe90cfd", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/e22d448f521f0b4e81a9edae44a00a40fbe90cfd", "committedDate": "2020-10-07T14:08:11Z", "message": "DB-10175 Expression-based index scan with in-list predicates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57ce9e16fc3de1c64638575483938d57d6795e42", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/57ce9e16fc3de1c64638575483938d57d6795e42", "committedDate": "2020-10-07T14:08:11Z", "message": "DB-10175 Fix SpotBugs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44ec6f37735acf851ff4a82268c0d544693b4790", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/44ec6f37735acf851ff4a82268c0d544693b4790", "committedDate": "2020-10-07T14:08:11Z", "message": "DB-10175 Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f2259ad89ece5e2bbbe977981c5511bb4becbc3a", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/f2259ad89ece5e2bbbe977981c5511bb4becbc3a", "committedDate": "2020-09-23T16:09:03Z", "message": "DB-10175 Address comments"}, "afterCommit": {"oid": "44ec6f37735acf851ff4a82268c0d544693b4790", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/44ec6f37735acf851ff4a82268c0d544693b4790", "committedDate": "2020-10-07T14:08:11Z", "message": "DB-10175 Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b965fdf6ac44f431b541813d79344aec6776bde4", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/b965fdf6ac44f431b541813d79344aec6776bde4", "committedDate": "2020-10-15T11:22:30Z", "message": "Merge branch 'master' into DB-10175"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1516c436841f204c294d1ac4329eeea983ef3802", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/1516c436841f204c294d1ac4329eeea983ef3802", "committedDate": "2020-10-22T09:06:54Z", "message": "Merge branch 'master' into DB-10175"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5d12ed61478bccf565395f8029144a5314879b4", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/c5d12ed61478bccf565395f8029144a5314879b4", "committedDate": "2020-10-23T12:46:54Z", "message": "Merge branch 'master' into DB-10175"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c65948d27940e0e3567baa1adc0839afc56da45", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/4c65948d27940e0e3567baa1adc0839afc56da45", "committedDate": "2020-10-26T08:16:31Z", "message": "Merge branch 'master' into DB-10175"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MzUzNjgz", "url": "https://github.com/splicemachine/spliceengine/pull/4110#pullrequestreview-517353683", "createdAt": "2020-10-27T05:13:53Z", "commit": {"oid": "4c65948d27940e0e3567baa1adc0839afc56da45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwNToxMzo1NFrOHortFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwNToxMzo1NFrOHortFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQyMTE0MA==", "bodyText": "The variable declaration of cnv should be moved inside the for loop, otherwise, we won't be able to detect empty column references correctly for second element and upper.", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r512421140", "createdAt": "2020-10-27T05:13:54Z", "author": {"login": "yxia92"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java", "diffHunk": "@@ -110,9 +110,11 @@ public ValueNode getLeftOperand() {\n         return (ValueNode) (singleLeftOperand ? leftOperandList.elementAt(0) : null);\n     }\n     \n-    public boolean allLeftOperandsColumnReferences() {\n-        for (Object obj:leftOperandList) {\n-            if (!(obj instanceof  ColumnReference))\n+    public boolean allLeftOperandsContainColumnReferences() throws StandardException {\n+        CollectNodesVisitor cnv = new CollectNodesVisitor(ColumnReference.class);\n+        for (int i = 0; i < leftOperandList.size(); i++) {\n+            leftOperandList.elementAt(i).accept(cnv);\n+            if (cnv.getList().isEmpty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c65948d27940e0e3567baa1adc0839afc56da45"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MzUzOTY2", "url": "https://github.com/splicemachine/spliceengine/pull/4110#pullrequestreview-517353966", "createdAt": "2020-10-27T05:14:47Z", "commit": {"oid": "4c65948d27940e0e3567baa1adc0839afc56da45"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9f90256bb404ab2ad137a4fee677c2b0dc3a3d5", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/d9f90256bb404ab2ad137a4fee677c2b0dc3a3d5", "committedDate": "2020-10-27T15:47:00Z", "message": "Merge branch 'master' into DB-10175"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf9602776fbe57fac0d07cbe0dff0c086932f8e4", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/bf9602776fbe57fac0d07cbe0dff0c086932f8e4", "committedDate": "2020-10-27T15:56:25Z", "message": "DB-10175 Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3Nzk0MjQz", "url": "https://github.com/splicemachine/spliceengine/pull/4110#pullrequestreview-517794243", "createdAt": "2020-10-27T14:51:46Z", "commit": {"oid": "4c65948d27940e0e3567baa1adc0839afc56da45"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNDo1MTo0NlrOHpAYZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNzozNDozMVrOHpIdHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc1OTkxMA==", "bodyText": "Method keyColumnOnLeft should be updated to handle all types of expressions.  It relies on getHashableJoinColumnReference() to collect the columns in the expression, but it doesn't seem to be working.\nExample:\n\ncreate table t1 (a int, b int, primary key(a));\ncreate index t1_idx on t1(a+b);\nexplain select * from t1 where a+b = 1;\nERROR XJ001: DERBY SQL error: SQLCODE: -1, SQLSTATE: XJ001, SQLERRMC: java.lang.IllegalStateExceptionASSERT FAILED Key column not found on either side.XJ001.U", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r512759910", "createdAt": "2020-10-27T14:51:46Z", "author": {"login": "msirek"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryRelationalOperatorNode.java", "diffHunk": "@@ -527,19 +565,34 @@ public boolean selfComparison(ColumnReference cr)\n     /**\n      * @see RelationalOperator#usefulStartKey\n      */\n-    public boolean usefulStartKey(Optimizable optTable) {\n+    public boolean usefulStartKey(Optimizable optTable, IndexDescriptor id) {\n \n         BinaryRelationalOperatorNodeUtil.coerceDataTypeIfNecessary(this);\n \n         /*\n         ** Determine whether this operator is a useful start operator\n         ** with knowledge of whether the key column is on the left or right.\n         */\n-        int columnSide = columnOnOneSide(optTable);\n+        boolean isIndexOnExpr = id != null && id.isOnExpression();\n+        int columnSide = isIndexOnExpr ? indexExprOnOneSide(optTable) : columnOnOneSide(optTable);\n \n         return columnSide != NEITHER && usefulStartKey(columnSide == LEFT);\n     }\n \n+     /**\n+      * @see RelationalOperator#usefulStopKey\n+      */\n+     public boolean usefulStopKey(Optimizable optTable, IndexDescriptor id) {\n+         /*\n+          ** Determine whether this operator is a useful start operator\n+          ** with knowledge of whether the key column is on the left or right.\n+          */\n+         boolean isIndexOnExpr = id != null && id.isOnExpression();\n+         int columnSide = isIndexOnExpr ? indexExprOnOneSide(optTable) : columnOnOneSide(optTable);\n+\n+         return columnSide != NEITHER && usefulStopKey(columnSide == LEFT);\n+     }\n+\n     /**\n      * Return true if a key column for the given table is found on the\n      * left side of this operator, false if it is found on the right", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c65948d27940e0e3567baa1adc0839afc56da45"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5MjE5MQ==", "bodyText": "The equals method will only match 2 different JavaToSQLValueNodes if they are the exact same object:\n\nprotected boolean isEquivalent(ValueNode o)\n{\n    // anything in the java domain is not equiavlent.\n    return false;//this == o;\n}\n\n\nTherefore, if you have something like:\n\ncreate index t1_idx on t1(ln(a));\nexplain select * from t1 --splice-properties index=t1_idx\nwhere ln(a) > 1;\n\nIt cannot take advantage of the index.  It may be better to write a new method for comparing expressions, that defaults to using the equals method for all nodes, but then for JavaToSQLValueNode we could override the implementation and do the proper expression comparison.  Note that non-deterministic functions should not ever be considered the same expression.", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r512892191", "createdAt": "2020-10-27T17:34:31Z", "author": {"login": "msirek"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java", "diffHunk": "@@ -564,6 +613,53 @@ public static Integer isIndexUseful(Predicate pred,\n         return indexPosition;\n     }\n \n+    private static boolean matchIndexExpression(RelationalOperator relOp, InListOperatorNode inNode,\n+                                                boolean isIn, boolean isProbe,\n+                                                ValueNode indexExprAst, Optimizable optTable) {\n+        boolean match = false;\n+        int tableNumber = optTable.getTableNumber();  // OK to be -1, will be checked when use\n+        if (isIn) {\n+            if (inNode.getLeftOperand().equals(indexExprAst)) {\n+                match = true;\n+                if (isProbe) {\n+                    assert relOp instanceof BinaryOperatorNode;\n+                    BinaryOperatorNode binOp = (BinaryOperatorNode) relOp;\n+                    binOp.setMatchIndexExpr(tableNumber, true);\n+                }\n+            }\n+        } else {\n+            if (relOp instanceof BinaryOperatorNode) {\n+                BinaryOperatorNode binOp = (BinaryOperatorNode) relOp;\n+                if (binOp.getLeftOperand().equals(indexExprAst)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf9602776fbe57fac0d07cbe0dff0c086932f8e4"}, "originalPosition": 223}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4236cac5c473ac58a99061323b366d5edc70eda8", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/4236cac5c473ac58a99061323b366d5edc70eda8", "committedDate": "2020-10-28T14:38:13Z", "message": "Merge branch 'master' into DB-10175\n\nConflicts:\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/Predicate.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cf8db9f4c07e7ecbdf84a340c73c407a3ee70ca", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/2cf8db9f4c07e7ecbdf84a340c73c407a3ee70ca", "committedDate": "2020-10-29T20:24:59Z", "message": "DB-10175 Address comments / add semanticallyEquals()\n\nDB-10312 Cache index expression ASTs is partially applied here so that\nthe code binding index expressions is not duplicated everywhere."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83a20d4c2342308c196697fa55929e49e997c901", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/83a20d4c2342308c196697fa55929e49e997c901", "committedDate": "2020-10-29T20:26:10Z", "message": "Merge branch 'master' into DB-10175"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNDMxNzUz", "url": "https://github.com/splicemachine/spliceengine/pull/4110#pullrequestreview-520431753", "createdAt": "2020-10-30T07:40:15Z", "commit": {"oid": "2cf8db9f4c07e7ecbdf84a340c73c407a3ee70ca"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNzo0MDoxNlrOHrEEIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNzo0MDoxNlrOHrEEIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkxNzQwOQ==", "bodyText": "@ascend1 Could you check if IndexDescriptorImpl is cached as part of the TableDescriptor in dictionary cache? If so, it is shared among all the queries and the these code could cause the data structure to be modified concurrently, and that could be problematic.", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r514917409", "createdAt": "2020-10-30T07:40:16Z", "author": {"login": "yxia92"}, "path": "db-engine/src/main/java/com/splicemachine/db/catalog/types/IndexDescriptorImpl.java", "diffHunk": "@@ -553,10 +564,90 @@ public BaseExecutableIndexExpression getExecutableIndexExpression(int indexColum\n                 : \"index has expression but generated class name is unknown\";\n         LanguageConnectionContext lcc = (LanguageConnectionContext) ContextService.getContext\n                 (LanguageConnectionContext.CONTEXT_ID);\n+        assert lcc != null;\n         ClassFactory classFactory = lcc.getLanguageConnectionFactory().getClassFactory();\n         GeneratedClass gc = classFactory.loadGeneratedClass(\n                 generatedClassNames[indexColumnPosition], exprBytecode[indexColumnPosition]);\n         executableExprs[indexColumnPosition] = (BaseExecutableIndexExpression) gc.newInstance(lcc);\n         return executableExprs[indexColumnPosition];\n     }\n+\n+    /** @see IndexDescriptor#getParsedIndexExpressions */\n+    @Override\n+    public ValueNode[] getParsedIndexExpressions(LanguageConnectionContext context, Optimizable optTable)\n+            throws StandardException\n+    {\n+        LanguageConnectionContext lcc = context;\n+        if (lcc == null) {\n+            lcc = (LanguageConnectionContext) ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);\n+        }\n+        assert lcc != null;\n+\n+        if (exprAsts != null) {\n+            for (ValueNode ast : exprAsts) {\n+                setTableNumberToIndexExpr(ast, optTable);\n+                bindNecessaryNodesInIndexExpr(ast, optTable, lcc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cf8db9f4c07e7ecbdf84a340c73c407a3ee70ca"}, "originalPosition": 80}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35654b5f5111273d24a3a795f0ab4adcca2f8f70", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/35654b5f5111273d24a3a795f0ab4adcca2f8f70", "committedDate": "2020-10-30T10:09:08Z", "message": "DB-10175 Address comments / fix potential concurrent issue\n\nIndex expression ASTs should not be cached in IndexDescriptor because\nit is in turns cached in data dictionary cache, which is global to all\nqueries. For now, always return a copy of ASTs."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86df5f4b3bda233a95c8e656ae2508c3b8d9cb7a", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/86df5f4b3bda233a95c8e656ae2508c3b8d9cb7a", "committedDate": "2020-10-30T11:32:58Z", "message": "DB-10175 Fix Spotbugs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwOTYxMzkz", "url": "https://github.com/splicemachine/spliceengine/pull/4110#pullrequestreview-520961393", "createdAt": "2020-10-30T19:13:00Z", "commit": {"oid": "86df5f4b3bda233a95c8e656ae2508c3b8d9cb7a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMjM0NzMy", "url": "https://github.com/splicemachine/spliceengine/pull/4110#pullrequestreview-522234732", "createdAt": "2020-11-03T07:26:26Z", "commit": {"oid": "86df5f4b3bda233a95c8e656ae2508c3b8d9cb7a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd55b56d0814b85960768b2b73ba68ec42f8eb38", "author": {"user": {"login": "ascend1", "name": "Zhen Li"}}, "url": "https://github.com/splicemachine/spliceengine/commit/dd55b56d0814b85960768b2b73ba68ec42f8eb38", "committedDate": "2020-11-03T08:43:46Z", "message": "Merge branch 'master' into DB-10175"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTY4MDk1", "url": "https://github.com/splicemachine/spliceengine/pull/4110#pullrequestreview-522968095", "createdAt": "2020-11-04T00:29:53Z", "commit": {"oid": "dd55b56d0814b85960768b2b73ba68ec42f8eb38"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1161, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}