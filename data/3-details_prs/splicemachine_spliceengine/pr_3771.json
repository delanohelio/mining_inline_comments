{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0ODU3NTQ1", "number": 3771, "title": "DB-9715 AS OF should also accept a timestamp expression", "bodyText": "", "createdAt": "2020-07-06T15:45:26Z", "url": "https://github.com/splicemachine/spliceengine/pull/3771", "merged": true, "mergeCommit": {"oid": "4372c20df37ef7b12a2ba502c8053e22a61bb6af"}, "closed": true, "closedAt": "2020-08-07T12:28:57Z", "author": {"login": "hatyo"}, "timelineItems": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcsQCjOgH2gAyNDQ0ODU3NTQ1OjQ5ZWNiMGZkZTUyNmIxZjZiYWYxOTQ1MzQ2MmE2ZTI3NjBkYmU3YmQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc8Ta_egFqTQ2MjczNDc1NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "49ecb0fde526b1f6baf19453462a6e2760dbe7bd", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/49ecb0fde526b1f6baf19453462a6e2760dbe7bd", "committedDate": "2020-06-17T20:40:01Z", "message": "Support time travel SELECT statements with tx id.\n\n- add parser extensions to support AS OF clause.\n- only the tx id is supported.\n- propagate the transaction id down the execution tree to\n  TableScanOperation.\n- adapt code generation to pass the tx id to TableScanOperation\n  at runtime.\n- add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69c5064cfb517f637292c9a9198520b0667c49ff", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/69c5064cfb517f637292c9a9198520b0667c49ff", "committedDate": "2020-07-06T18:46:41Z", "message": "Addressed comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebae97a79a00a8a55d4c12047bc338909c2e06ec", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/ebae97a79a00a8a55d4c12047bc338909c2e06ec", "committedDate": "2020-07-06T18:47:54Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9714"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9c4480364623cc4fb382a64183e0d2ec70f18d0", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/d9c4480364623cc4fb382a64183e0d2ec70f18d0", "committedDate": "2020-07-06T20:14:46Z", "message": "Disallow time travel clause on external tables and views.\n\n- Add tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNzYyMjcw", "url": "https://github.com/splicemachine/spliceengine/pull/3771#pullrequestreview-443762270", "createdAt": "2020-07-07T10:27:06Z", "commit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDoyNzowNlrOGt4fcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDo1Mjo1MFrOGt5Rfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NDY1OA==", "bodyText": "@yxia92 @jyuanca do we need to do something here regarding upgrades?", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450764658", "createdAt": "2020-07-07T10:27:06Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/execute/ResultSetFactory.java", "diffHunk": "@@ -1012,7 +1013,8 @@ NoPutResultSet getTableScanResultSet(\n \t\t\t\t\t\t\t\tString location,\n \t\t\t\t\t\t\t\tint partitionByRefItem,\n \t\t\t\t\t\t\t\tGeneratedMethod defaultRowFunc,\n-\t\t\t\t\t\t\t\tint defaultValueMapItem\n+\t\t\t\t\t\t\t\tint defaultValueMapItem,\n+\t\t\t\t\t\t\t\tGeneratedMethod pastTxFunctor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NTA3Mg==", "bodyText": "I'm not a fan of the isBulkDeleteOrTxId parameter, would it be possible to add an extra parameter for the transaction id ?", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450765072", "createdAt": "2020-07-07T10:27:54Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -196,36 +196,30 @@\n     private AggregateNode aggrForSpecialMaxScan;\n \n     private boolean isBulkDelete = false;\n+\n+    private ValueNode pastTxIdExpression = null;\n+\n     @Override\n     public boolean isParallelizable(){\n         return false;\n     }\n \n     /**\n-     * Initializer for a table in a FROM list. Parameters are as follows:\n-     * <p/>\n-     * <ul>\n-     * <li>tableName            The name of the table</li>\n-     * <li>correlationName    The correlation name</li>\n-     * <li>derivedRCL        The derived column list</li>\n-     * <li>tableProperties    The Properties list associated with the table.</li>\n-     * </ul>\n-     * <p/>\n-     * <p>\n-     * - OR -\n-     * </p>\n-     * <p/>\n-     * <ul>\n-     * <li>tableName            The name of the table</li>\n-     * <li>correlationName    The correlation name</li>\n-     * <li>updateOrDelete    Table is being updated/deleted from. </li>\n-     * <li>derivedRCL        The derived column list</li>\n-     * </ul>\n+     * Initializer for a table in a FROM list.\n+     * @param tableName The name of the table\n+     * @param correlationName The correlation name\n+     * @param rclOrUD update/delete flag or result column list\n+     * @param propsOrRcl properties or result column list\n+     * @param isBulkDeleteOrTxId bulk delete flag or past tx id expression.\n      */\n     @Override\n-    public void init(Object tableName,Object correlationName,Object rclOrUD,Object propsOrRcl, Object isBulkDelete){\n+    public void init(Object tableName,Object correlationName,Object rclOrUD,Object propsOrRcl, Object isBulkDeleteOrTxId){\n+        if(isBulkDeleteOrTxId instanceof Boolean) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NTU2NQ==", "bodyText": "Remove comments", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450765565", "createdAt": "2020-07-07T10:28:56Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -3410,7 +3431,11 @@ private String getClassName(String niceIndexName) throws StandardException {\n         if(niceIndexName!=null){\n             cName = \"IndexScan[\"+niceIndexName+\"]\";\n         }else{\n-            cName = \"TableScan[\"+getPrettyTableName()+\"]\";\n+            cName = \"TableScan[\"+getPrettyTableName();\n+//            if(pastTxIdExpression >= 0){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NjA5NQ==", "bodyText": "Is it possible to remove the look ahead here?", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450766095", "createdAt": "2020-07-07T10:30:00Z", "author": {"login": "dgomezferro"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj", "diffHunk": "@@ -10914,28 +10915,45 @@ tableReferenceTypes(boolean nestedInParens) throws StandardException :\n Object[]\n optionalTableClauses() throws StandardException :\n {\n-    Object[]             otc = null;\n-    Properties            tableProperties = null;\n-    ResultColumnList    derivedRCL = null;\n-    String                correlationName = null;\n+    Object[]         otc = null;\n+    Properties       tableProperties = null;\n+    ResultColumnList derivedRCL = null;\n+    String           correlationName = null;\n+    ValueNode        txnIdExpression = null;\n }\n {\n     otc = optionalTableProperties()\n     {\n         otc[OPTIONAL_TABLE_CLAUSES_DERIVED_RCL] = derivedRCL;\n         otc[OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME] = correlationName;\n+        otc[OPTIONAL_TABLE_CLAUSES_TXN_ID] = txnIdExpression;\n         return otc;\n     }\n |\n+    LOOKAHEAD( { getToken(1).kind != AS || getToken(2).kind != OF })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDA0Ng==", "bodyText": "If I'm understanding this correctly, this is mapping the Txn begin timestamp to the instant when the transaction was last updated. This would be wrong for long running transactions:\n\ntxn1 is created at instant1\na long time passes\ntxn1 is committed at instant500\nthis function maps txnId 1 to instant 500 (it should map txnId 1 to instant 1)", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450770046", "createdAt": "2020-07-07T10:37:55Z", "author": {"login": "dgomezferro"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.hbase.CellUtils;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.Source;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.filter.PrefixFilter;\n+import org.apache.hadoop.hbase.regionserver.HRegion;\n+import org.apache.hadoop.hbase.regionserver.RegionScanner;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public class HBaseTxnFinder implements TxnFinder {\n+\n+    private HRegion region;\n+\n+    public HBaseTxnFinder(HRegion region) {\n+        this.region = region;\n+    }\n+\n+    private class ScanTimestampIterator implements Source<Pair<Long, Long>> {\n+        private final RegionScanner regionScanner;\n+        protected Pair<Long, Long> next;\n+        private List<Cell> currentResults;\n+\n+        protected Pair<Long, Long> decode(List<Cell> keyValues) throws IOException{\n+            if(keyValues.size()<=0) return null;\n+            Cell dataKv=null;\n+            long ts = 0;\n+\n+            for(Cell kv : keyValues){\n+                if(CellUtils.singleMatchingColumn(kv,V2TxnDecoder.FAMILY,V2TxnDecoder.DATA_QUALIFIER_BYTES)) {\n+                    dataKv=kv;\n+                }\n+                if(ts <  kv.getTimestamp()) {\n+                    ts = kv.getTimestamp(); // get last update\n+                }\n+            }\n+            if(dataKv==null) return null;\n+            long txnId= TxnUtils.txnIdFromRowKey(dataKv.getRowArray(),dataKv.getRowOffset(),dataKv.getRowLength());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDY4Nw==", "bodyText": "You can specify the column you are interested in directly in the scan, so you don't have to check for the right KV.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450770687", "createdAt": "2020-07-07T10:39:16Z", "author": {"login": "dgomezferro"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.hbase.CellUtils;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.Source;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.filter.PrefixFilter;\n+import org.apache.hadoop.hbase.regionserver.HRegion;\n+import org.apache.hadoop.hbase.regionserver.RegionScanner;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public class HBaseTxnFinder implements TxnFinder {\n+\n+    private HRegion region;\n+\n+    public HBaseTxnFinder(HRegion region) {\n+        this.region = region;\n+    }\n+\n+    private class ScanTimestampIterator implements Source<Pair<Long, Long>> {\n+        private final RegionScanner regionScanner;\n+        protected Pair<Long, Long> next;\n+        private List<Cell> currentResults;\n+\n+        protected Pair<Long, Long> decode(List<Cell> keyValues) throws IOException{\n+            if(keyValues.size()<=0) return null;\n+            Cell dataKv=null;\n+            long ts = 0;\n+\n+            for(Cell kv : keyValues){\n+                if(CellUtils.singleMatchingColumn(kv,V2TxnDecoder.FAMILY,V2TxnDecoder.DATA_QUALIFIER_BYTES)) {\n+                    dataKv=kv;\n+                }\n+                if(ts <  kv.getTimestamp()) {\n+                    ts = kv.getTimestamp(); // get last update\n+                }\n+            }\n+            if(dataKv==null) return null;\n+            long txnId= TxnUtils.txnIdFromRowKey(dataKv.getRowArray(),dataKv.getRowOffset(),dataKv.getRowLength());\n+            return new Pair<>(txnId, ts);\n+        }\n+\n+\n+        public ScanTimestampIterator(RegionScanner scanner){\n+            this.regionScanner=scanner;\n+        }\n+\n+        @Override\n+        public boolean hasNext() throws IOException{\n+            if(next!=null) return true;\n+            if(currentResults==null)\n+                currentResults=new ArrayList<>(10);\n+            boolean shouldContinue;\n+            do{\n+                shouldContinue=regionScanner.next(currentResults);\n+                if(currentResults.size()<=0) return false;\n+\n+                this.next = decode(currentResults);\n+                currentResults.clear();\n+            }while(next==null && shouldContinue);\n+\n+            return next!=null;\n+        }\n+\n+        @Override\n+        public Pair<Long, Long> next() throws IOException{\n+            if(!hasNext()) throw new NoSuchElementException();\n+            Pair<Long, Long> n=next;\n+            next=null;\n+            return n;\n+        }\n+\n+        @Override\n+        public void close() throws IOException{\n+            regionScanner.close();\n+        }\n+    }\n+\n+    @Override\n+    public Pair<Long, Long> find(byte bucket, byte[] begin, boolean reverse) throws IOException {\n+        Scan s = new Scan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NDQ2Nw==", "bodyText": "Recomment this", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450774467", "createdAt": "2020-07-07T10:46:56Z", "author": {"login": "dgomezferro"}, "path": "mem_sql/pom.xml", "diffHunk": "@@ -268,12 +268,10 @@\n                             <key>com.splicemachine.enableLegacyAsserts</key>\n                             <value>true</value>\n                         </systemProperty>\n-                     <!-- Uncomment the following to dump activation class files for mem platform to the mem_sql directory.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NDU5NQ==", "bodyText": "comment this by default", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450774595", "createdAt": "2020-07-07T10:47:10Z", "author": {"login": "dgomezferro"}, "path": "platform_it/pom.xml", "diffHunk": "@@ -1055,6 +1055,7 @@\n                                 <argument>-Dderby.language.updateSystemProcs=false</argument>\n                                 <!-- Setting the logStatementText option to true enables logging of all statements. -->\n                                 <argument>-Dderby.infolog.append=true</argument>\n+                                <argument>-Dderby.debug.true=DumpClassFile</argument>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NTY5Nw==", "bodyText": "Txn id 0 is used for the ROOT_TRANSACTION, which is a special transaction parent of all user level transactions. I don't think this is going to be problematic but I'd rather use a different transaction id other than 0, in case we think at some point this is actually the root transaction.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450775697", "createdAt": "2020-07-07T10:49:31Z", "author": {"login": "dgomezferro"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java", "diffHunk": "@@ -175,10 +190,34 @@ public TableScanOperation(long conglomId,\n         this.indexColItem=indexColItem;\n         this.indexName=indexName;\n         init();\n+        if(pastTxFunctor != null) {\n+            this.pastTx = MapToTxId((DataValueDescriptor)pastTxFunctor.invoke(activation));\n+            if(pastTx == -1) {\n+                pastTx = 0; // force going back to oldest transaction instead of ignoring it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NjAwMQ==", "bodyText": "Method names should start with lowercase", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450776001", "createdAt": "2020-07-07T10:50:05Z", "author": {"login": "dgomezferro"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java", "diffHunk": "@@ -175,10 +190,34 @@ public TableScanOperation(long conglomId,\n         this.indexColItem=indexColItem;\n         this.indexName=indexName;\n         init();\n+        if(pastTxFunctor != null) {\n+            this.pastTx = MapToTxId((DataValueDescriptor)pastTxFunctor.invoke(activation));\n+            if(pastTx == -1) {\n+                pastTx = 0; // force going back to oldest transaction instead of ignoring it.\n+            }\n+        } else {\n+            this.pastTx = -1; // nothing is set, go ahead and use latest transaction.\n+        }\n         if(LOG.isTraceEnabled())\n             SpliceLogUtils.trace(LOG,\"isTopResultSet=%s,optimizerEstimatedCost=%f,optimizerEstimatedRowCount=%f\",isTopResultSet,optimizerEstimatedCost,optimizerEstimatedRowCount);\n     }\n \n+    private long MapToTxId(DataValueDescriptor dataValue) throws StandardException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3Njg1MQ==", "bodyText": "Method names start lowercase", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450776851", "createdAt": "2020-07-07T10:51:40Z", "author": {"login": "dgomezferro"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3Njk2OA==", "bodyText": "ditto", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450776968", "createdAt": "2020-07-07T10:51:53Z", "author": {"login": "dgomezferro"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {\n+        long result = -1;\n+        ResultSet rs =  watcher.executeQuery(\"CALL SYSCS_UTIL.SYSCS_GET_CURRENT_TRANSACTION()\");\n+        Assert.assertTrue(rs.next());\n+        result = rs.getLong(1);\n+        Assert.assertFalse(rs.next());\n+        return result;\n+    }\n+\n+    static int counter = 0;\n+    private static String GenerateTableName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NzQ3MA==", "bodyText": "Remove", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450777470", "createdAt": "2020-07-07T10:52:50Z", "author": {"login": "dgomezferro"}, "path": "splice_si_api/src/main/java/com/splicemachine/si/impl/TxnUtils.java", "diffHunk": "@@ -30,10 +30,23 @@ private TxnUtils(){}\n \t\tlong beginTS = txnId & SIConstants.TRANSANCTION_ID_MASK;\n \t\tbyte[] rowKey = new byte[9];\n \t\trowKey[0] = (byte)((beginTS / SIConstants.TRASANCTION_INCREMENT) & (TRANSACTION_TABLE_BUCKET_COUNT-1));\n+\t\trowKey[0] = (byte)(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16e8ee799170ab2ef72aba0f4c7084085e8514e2", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/16e8ee799170ab2ef72aba0f4c7084085e8514e2", "committedDate": "2020-07-07T12:31:04Z", "message": "Fix SpotBug issues."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NDI5OTA2", "url": "https://github.com/splicemachine/spliceengine/pull/3771#pullrequestreview-444429906", "createdAt": "2020-07-08T05:48:50Z", "commit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNTo0ODo1MFrOGuZBWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjowNTo1N1rOGuZXog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5NzYyNg==", "bodyText": "we don't really have a code convention, but i think this could use a bit more spaces, e.g.\n} catch(Throwable throwable) {\n(same for other lines)\nI don't really need the spaces after (, but like around operators e.g. if(keyValues.size()<=0) -> if(keyValues.size() <= 0).", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451297626", "createdAt": "2020-07-08T05:48:50Z", "author": {"login": "martinrupp"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/CoprocessorTxnStore.java", "diffHunk": "@@ -268,6 +268,17 @@ public int compare(TxnView o1,TxnView o2){\n         }\n     }\n \n+    @Override\n+    public long getTxnAt(long ts) throws IOException {\n+        final TxnMessage.TxnAtRequest request=TxnMessage.TxnAtRequest.newBuilder().setTs(ts).build();\n+        try(TxnNetworkLayer table = tableFactory.accessTxnNetwork()){\n+            TxnMessage.TxnAtResponse result = table.getTxnAt(request);\n+            return result.getTxnId();\n+        }catch(Throwable throwable){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5OTM0NA==", "bodyText": "really LOG level, not TRACE? i'm not even sure we should have this here at all, even in trace level.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451299344", "createdAt": "2020-07-08T05:53:52Z", "author": {"login": "martinrupp"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+\n+public class TxnTimeTraveler {\n+    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n+\n+    private TxnFinder txnFinder;\n+\n+    public TxnTimeTraveler(TxnFinder txnFinder) {\n+        this.txnFinder = txnFinder;\n+    }\n+\n+    /// @return Pair<closest tx id, closest tx's ts>\n+    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n+                                     byte[] end, long endTS) throws IOException {\n+        if(LOG.isTraceEnabled())\n+            SpliceLogUtils.trace(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n+                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n+                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n+        byte[] left = begin, right = end, middle;\n+        long leftTS = beginTS, rightTS = endTS;\n+        boolean changed = true, reversed = false;\n+        while(changed) {\n+            if(Arrays.equals(left, right)) {\n+                if(leftTS < needleTS) {\n+                    return new Pair<>(txOf(left), leftTS);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            changed = false;\n+            middle = middle(left, right);\n+            Pair<Long, Long> middleTx;\n+            middleTx = txnFinder.find(bucket, middle, reversed);\n+            reversed = false;\n+            if(LOG.isTraceEnabled())\n+                SpliceLogUtils.trace(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5OTg3Mw==", "bodyText": "TRACE or DEBUG?", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451299873", "createdAt": "2020-07-08T05:55:22Z", "author": {"login": "martinrupp"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+\n+public class TxnTimeTraveler {\n+    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n+\n+    private TxnFinder txnFinder;\n+\n+    public TxnTimeTraveler(TxnFinder txnFinder) {\n+        this.txnFinder = txnFinder;\n+    }\n+\n+    /// @return Pair<closest tx id, closest tx's ts>\n+    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n+                                     byte[] end, long endTS) throws IOException {\n+        if(LOG.isTraceEnabled())\n+            SpliceLogUtils.trace(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n+                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n+                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n+        byte[] left = begin, right = end, middle;\n+        long leftTS = beginTS, rightTS = endTS;\n+        boolean changed = true, reversed = false;\n+        while(changed) {\n+            if(Arrays.equals(left, right)) {\n+                if(leftTS < needleTS) {\n+                    return new Pair<>(txOf(left), leftTS);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            changed = false;\n+            middle = middle(left, right);\n+            Pair<Long, Long> middleTx;\n+            middleTx = txnFinder.find(bucket, middle, reversed);\n+            reversed = false;\n+            if(LOG.isTraceEnabled())\n+                SpliceLogUtils.trace(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",\n+                        TxnUtils.rowKeytoHbaseEscaped(left), new Timestamp(leftTS).toString(), txOf(left),\n+                        TxnUtils.rowKeytoHbaseEscaped(right), new Timestamp(rightTS).toString(), txOf(right),\n+                        TxnUtils.rowKeytoHbaseEscaped(middle), new Timestamp(middleTx.getSecond()).toString(), middleTx.getFirst().toString());\n+            long middleTS = middleTx.getSecond();\n+            if(middleTS == needleTS) {\n+                return middleTx;\n+            } else if(needleTS < middleTS) {\n+                if(middleTS == rightTS)\n+                {\n+                    reversed = true;\n+                    changed = true;\n+                }\n+                else if(middleTS < rightTS)\n+                {\n+                    right = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                    rightTS = middleTS;\n+                    changed = true;\n+                }\n+            } else if(leftTS < middleTS) {\n+                left = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                leftTS = middleTS;\n+                changed = true;\n+            }\n+        }\n+        return new Pair<>(txOf(left), leftTS);\n+    }\n+\n+    private long txOf(byte[] rowKey) {\n+        return TxnUtils.txnIdFromRowKey(rowKey, 0, rowKey.length);\n+    }\n+\n+    private byte[] middle(byte[] left, byte[] right) {\n+        assert(left.length == 9); assert(right.length == 9);\n+        byte lBucket = left[0], rBucket = right[0];\n+        assert(lBucket == rBucket);\n+        long lTxnId = txOf(left), rTxnId = txOf(right), middleTxnId = (lTxnId + rTxnId) / 2;\n+        return toRowKeyWithBucket(middleTxnId, lBucket);\n+    }\n+\n+    private Pair<Long, Long> first(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,false);\n+    }\n+\n+    private Pair<Long, Long> last(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,true);\n+    }\n+\n+    private byte[] toRowKeyWithBucket(long txId, byte bucket) {\n+        byte[] result = TxnUtils.getRowKey(txId);\n+        assert result.length == 9 : \"unexpected rowKey format\";\n+        result[0] = bucket;\n+        return result;\n+    }\n+\n+    // When we use a past transaction P whose timestamp is T, we can read data which is committed before T\n+    // i.e. all data with time < T will be visible, therefore, to be able to read the data of the past\n+    // transaction itself, we slide to the next tx.\n+    private long slideToNextTx(long tx) throws IOException {\n+        if(tx == -1) { // special case for timestamp that happened before the first transaction.\n+            return -1;\n+        }\n+        return tx + SIConstants.TRASANCTION_INCREMENT;\n+    }\n+\n+    public Pair<Long, Long> getTxAt(long ts) throws IOException {\n+        long closestTS = Long.MAX_VALUE, closestTx = -1;\n+        Pair<Long, Long> before, after;\n+        for(byte i = 0; i < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT; ++i) {\n+            before = first(i);\n+            if(before == null /*|| before.getBeginTs() > ts*/) {\n+                continue; // region is empty, or the earliest tx in there happened after 'ts'\n+            }\n+            if(before.getSecond() > ts) {\n+                if(LOG.isTraceEnabled())\n+                    SpliceLogUtils.trace(LOG,\"in bucket %d the first txn [%s (TS: %s), id %s] happened after the needle (%s) exiting!\",\n+                            (int)i,\n+                            TxnUtils.rowKeytoHbaseEscaped(toRowKeyWithBucket(before.getFirst(), i)),\n+                            new Timestamp(before.getSecond()).toString(),\n+                            before.getFirst().toString(),\n+                            new Timestamp(ts).toString());\n+                    return new Pair<>(slideToNextTx(closestTx), closestTS); // nothing, needle is too early: <needle> ....... [before ...... after]\n+            }\n+            after = last(i);\n+            if(after.getSecond() < ts) {\n+                if(LOG.isTraceEnabled())\n+                    SpliceLogUtils.trace(LOG,\"in bucket %d the last txn [%s (TS: %s), id %s] happened before the needle (%s) exiting!\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwMzMzMA==", "bodyText": "SortedMap<Long, Long> m = txnTimeline.get(bucket); and if(m.size() == 0) { return null\ncan be done independent of if(begin == null) and if(reverse).\nI think you can add at the beginning of this function\nSortedMap<Long, Long> m = txnTimeline.get(bucket);\nif(m.size() == 0) {\n    return null;\n}\n\nand remove in other lines.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451303330", "createdAt": "2020-07-08T06:05:57Z", "author": {"login": "martinrupp"}, "path": "hbase_storage/src/test/java/com/splicemachine/si/impl/TimeTravelTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.splicemachine.si.impl;\n+\n+import com.splicemachine.primitives.Bytes;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.region.TxnFinder;\n+import com.splicemachine.si.impl.region.TxnTimeTraveler;\n+import com.splicemachine.utils.Pair;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+public class TimeTravelTest {\n+\n+    private static Long toTs(String s) throws ParseException {\n+        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss.SSS\");\n+        Date parsedDate = dateFormat.parse(s);\n+        Timestamp timestamp = new java.sql.Timestamp(parsedDate.getTime());\n+        return timestamp.getTime();\n+    }\n+\n+    class MockTxnFinder implements TxnFinder {\n+\n+\n+        List<SortedMap<Long, Long>> txnTimeline = new ArrayList<>();\n+\n+        MockTxnFinder() {\n+            for(int i = 0; i < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT; ++i) {\n+                txnTimeline.add(new TreeMap<>());\n+            }\n+        }\n+\n+        MockTxnFinder AddTxn(int bucket, long txnId, String ts) throws ParseException {\n+            assert bucket >= 0 && bucket < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT;\n+            txnTimeline.get(bucket).put(txnId, toTs(ts));\n+            return this;\n+        }\n+\n+        @Override\n+        public Pair<Long, Long> find(byte bucket, byte[] begin, boolean reverse) throws IOException {\n+            if(begin == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NDQwNDY1", "url": "https://github.com/splicemachine/spliceengine/pull/3771#pullrequestreview-444440465", "createdAt": "2020-07-08T06:15:45Z", "commit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjoxNTo0NVrOGuZklg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjoxNTo0NVrOGuZklg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwNjY0Ng==", "bodyText": "do we really need this? maybe sth like \"testTimeTravelWorksT\" would be more intuitive? the SpliceWatcher will drop these tables automatically, so you can run the test multiple times.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451306646", "createdAt": "2020-07-08T06:15:45Z", "author": {"login": "martinrupp"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {\n+        long result = -1;\n+        ResultSet rs =  watcher.executeQuery(\"CALL SYSCS_UTIL.SYSCS_GET_CURRENT_TRANSACTION()\");\n+        Assert.assertTrue(rs.next());\n+        result = rs.getLong(1);\n+        Assert.assertFalse(rs.next());\n+        return result;\n+    }\n+\n+    static int counter = 0;\n+    private static String GenerateTableName() {\n+        return \"T\" + counter++;\n+    }\n+\n+    @Test\n+    public void testTimeTravelWorks() throws Exception {\n+        String tbl = GenerateTableName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20abe7ca758cf03a863edc5c47ee7b9fe5c0bef6", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/20abe7ca758cf03a863edc5c47ee7b9fe5c0bef6", "committedDate": "2020-07-10T15:07:15Z", "message": "Add upgrade script to invalidate stored statements."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f544c86289748608ac77934e5bc1250f7fdfbae", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/2f544c86289748608ac77934e5bc1250f7fdfbae", "committedDate": "2020-07-10T15:12:03Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9714"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a84933d44be77758a4b1603cd9ce7b2e841f569c", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/a84933d44be77758a4b1603cd9ce7b2e841f569c", "committedDate": "2020-07-14T15:14:29Z", "message": "Addressed further comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2405dcb59774fecad245895185f80c6170108e7e", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/2405dcb59774fecad245895185f80c6170108e7e", "committedDate": "2020-07-14T15:15:31Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9714"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15aac492587e0e6b8aae0d2339332dcb9dcc16dd", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/15aac492587e0e6b8aae0d2339332dcb9dcc16dd", "committedDate": "2020-07-14T15:28:50Z", "message": "DB-9715 allow timestamp in AS OF clause.\n\n- accept a general expression which must evaluate to either\n  * numeric value that corresponds to txid\n  * timestamp value that corresponds to approximate time of\n    committing a transaction.\n- TODO: implement mapping function that maps timestamp to txid."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "361a907cd1bc01f845619e3e4ac6b7f0f595ae1d", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/361a907cd1bc01f845619e3e4ac6b7f0f595ae1d", "committedDate": "2020-07-14T15:28:50Z", "message": "DB-9715 Implement algorithm to map timestamp to nearest transaction.\n\n- implement a special version of binary search that efficiently\n  scans a bucket of txn in SPLICE_TXN looking for the nearest\n  transaction to a given timestamp.\n- implement a new endpoint API call to retrieven nearest tx of\n  a given timestamp.\n- add tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNDY0NzUy", "url": "https://github.com/splicemachine/spliceengine/pull/3771#pullrequestreview-450464752", "createdAt": "2020-07-17T08:20:57Z", "commit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoyMDo1N1rOGzJ9yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOTowNjowNFrOGzLb_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MzgzNA==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456293834", "createdAt": "2020-07-17T08:20:57Z", "author": {"login": "hatyo"}, "path": "mem_sql/pom.xml", "diffHunk": "@@ -268,12 +268,10 @@\n                             <key>com.splicemachine.enableLegacyAsserts</key>\n                             <value>true</value>\n                         </systemProperty>\n-                     <!-- Uncomment the following to dump activation class files for mem platform to the mem_sql directory.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NDQ2Nw=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NDUyMw==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456294523", "createdAt": "2020-07-17T08:22:15Z", "author": {"login": "hatyo"}, "path": "platform_it/pom.xml", "diffHunk": "@@ -1055,6 +1055,7 @@\n                                 <argument>-Dderby.language.updateSystemProcs=false</argument>\n                                 <!-- Setting the logStatementText option to true enables logging of all statements. -->\n                                 <argument>-Dderby.infolog.append=true</argument>\n+                                <argument>-Dderby.debug.true=DumpClassFile</argument>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NDU5NQ=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NDk5MA==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456294990", "createdAt": "2020-07-17T08:23:03Z", "author": {"login": "hatyo"}, "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java", "diffHunk": "@@ -175,10 +190,34 @@ public TableScanOperation(long conglomId,\n         this.indexColItem=indexColItem;\n         this.indexName=indexName;\n         init();\n+        if(pastTxFunctor != null) {\n+            this.pastTx = MapToTxId((DataValueDescriptor)pastTxFunctor.invoke(activation));\n+            if(pastTx == -1) {\n+                pastTx = 0; // force going back to oldest transaction instead of ignoring it.\n+            }\n+        } else {\n+            this.pastTx = -1; // nothing is set, go ahead and use latest transaction.\n+        }\n         if(LOG.isTraceEnabled())\n             SpliceLogUtils.trace(LOG,\"isTopResultSet=%s,optimizerEstimatedCost=%f,optimizerEstimatedRowCount=%f\",isTopResultSet,optimizerEstimatedCost,optimizerEstimatedRowCount);\n     }\n \n+    private long MapToTxId(DataValueDescriptor dataValue) throws StandardException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NjAwMQ=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NTU5OA==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456295598", "createdAt": "2020-07-17T08:24:08Z", "author": {"login": "hatyo"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3Njg1MQ=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NTY3NQ==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456295675", "createdAt": "2020-07-17T08:24:18Z", "author": {"login": "hatyo"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {\n+        long result = -1;\n+        ResultSet rs =  watcher.executeQuery(\"CALL SYSCS_UTIL.SYSCS_GET_CURRENT_TRANSACTION()\");\n+        Assert.assertTrue(rs.next());\n+        result = rs.getLong(1);\n+        Assert.assertFalse(rs.next());\n+        return result;\n+    }\n+\n+    static int counter = 0;\n+    private static String GenerateTableName() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3Njk2OA=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NzkxOA==", "bodyText": "I actually find this more elegant, I am already using a SpliceWatcher for the schema so I can repeat my tests since the schema (which is the same for all tests in this class) will be dropped and created again in the next run.\nI don't use a watcher for each table because it is just too cumbersome and unnecessary.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456297918", "createdAt": "2020-07-17T08:28:07Z", "author": {"login": "hatyo"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {\n+        long result = -1;\n+        ResultSet rs =  watcher.executeQuery(\"CALL SYSCS_UTIL.SYSCS_GET_CURRENT_TRANSACTION()\");\n+        Assert.assertTrue(rs.next());\n+        result = rs.getLong(1);\n+        Assert.assertFalse(rs.next());\n+        return result;\n+    }\n+\n+    static int counter = 0;\n+    private static String GenerateTableName() {\n+        return \"T\" + counter++;\n+    }\n+\n+    @Test\n+    public void testTimeTravelWorks() throws Exception {\n+        String tbl = GenerateTableName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwNjY0Ng=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5ODQ0OQ==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456298449", "createdAt": "2020-07-17T08:29:06Z", "author": {"login": "hatyo"}, "path": "splice_si_api/src/main/java/com/splicemachine/si/impl/TxnUtils.java", "diffHunk": "@@ -30,10 +30,23 @@ private TxnUtils(){}\n \t\tlong beginTS = txnId & SIConstants.TRANSANCTION_ID_MASK;\n \t\tbyte[] rowKey = new byte[9];\n \t\trowKey[0] = (byte)((beginTS / SIConstants.TRASANCTION_INCREMENT) & (TRANSACTION_TABLE_BUCKET_COUNT-1));\n+\t\trowKey[0] = (byte)(2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NzQ3MA=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNDYyMA==", "bodyText": "You're absolutely right! Thank you \ud83d\udc4d I fixed it.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456314620", "createdAt": "2020-07-17T08:59:31Z", "author": {"login": "hatyo"}, "path": "hbase_storage/src/test/java/com/splicemachine/si/impl/TimeTravelTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.splicemachine.si.impl;\n+\n+import com.splicemachine.primitives.Bytes;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.region.TxnFinder;\n+import com.splicemachine.si.impl.region.TxnTimeTraveler;\n+import com.splicemachine.utils.Pair;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+public class TimeTravelTest {\n+\n+    private static Long toTs(String s) throws ParseException {\n+        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss.SSS\");\n+        Date parsedDate = dateFormat.parse(s);\n+        Timestamp timestamp = new java.sql.Timestamp(parsedDate.getTime());\n+        return timestamp.getTime();\n+    }\n+\n+    class MockTxnFinder implements TxnFinder {\n+\n+\n+        List<SortedMap<Long, Long>> txnTimeline = new ArrayList<>();\n+\n+        MockTxnFinder() {\n+            for(int i = 0; i < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT; ++i) {\n+                txnTimeline.add(new TreeMap<>());\n+            }\n+        }\n+\n+        MockTxnFinder AddTxn(int bucket, long txnId, String ts) throws ParseException {\n+            assert bucket >= 0 && bucket < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT;\n+            txnTimeline.get(bucket).put(txnId, toTs(ts));\n+            return this;\n+        }\n+\n+        @Override\n+        public Pair<Long, Long> find(byte bucket, byte[] begin, boolean reverse) throws IOException {\n+            if(begin == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwMzMzMA=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNjM3MA==", "bodyText": "Right, I don't know why I chose TRACE and not DEBUG, I will change it on DEBUG level then.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456316370", "createdAt": "2020-07-17T09:03:02Z", "author": {"login": "hatyo"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+\n+public class TxnTimeTraveler {\n+    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n+\n+    private TxnFinder txnFinder;\n+\n+    public TxnTimeTraveler(TxnFinder txnFinder) {\n+        this.txnFinder = txnFinder;\n+    }\n+\n+    /// @return Pair<closest tx id, closest tx's ts>\n+    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n+                                     byte[] end, long endTS) throws IOException {\n+        if(LOG.isTraceEnabled())\n+            SpliceLogUtils.trace(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n+                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n+                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n+        byte[] left = begin, right = end, middle;\n+        long leftTS = beginTS, rightTS = endTS;\n+        boolean changed = true, reversed = false;\n+        while(changed) {\n+            if(Arrays.equals(left, right)) {\n+                if(leftTS < needleTS) {\n+                    return new Pair<>(txOf(left), leftTS);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            changed = false;\n+            middle = middle(left, right);\n+            Pair<Long, Long> middleTx;\n+            middleTx = txnFinder.find(bucket, middle, reversed);\n+            reversed = false;\n+            if(LOG.isTraceEnabled())\n+                SpliceLogUtils.trace(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",\n+                        TxnUtils.rowKeytoHbaseEscaped(left), new Timestamp(leftTS).toString(), txOf(left),\n+                        TxnUtils.rowKeytoHbaseEscaped(right), new Timestamp(rightTS).toString(), txOf(right),\n+                        TxnUtils.rowKeytoHbaseEscaped(middle), new Timestamp(middleTx.getSecond()).toString(), middleTx.getFirst().toString());\n+            long middleTS = middleTx.getSecond();\n+            if(middleTS == needleTS) {\n+                return middleTx;\n+            } else if(needleTS < middleTS) {\n+                if(middleTS == rightTS)\n+                {\n+                    reversed = true;\n+                    changed = true;\n+                }\n+                else if(middleTS < rightTS)\n+                {\n+                    right = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                    rightTS = middleTS;\n+                    changed = true;\n+                }\n+            } else if(leftTS < middleTS) {\n+                left = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                leftTS = middleTS;\n+                changed = true;\n+            }\n+        }\n+        return new Pair<>(txOf(left), leftTS);\n+    }\n+\n+    private long txOf(byte[] rowKey) {\n+        return TxnUtils.txnIdFromRowKey(rowKey, 0, rowKey.length);\n+    }\n+\n+    private byte[] middle(byte[] left, byte[] right) {\n+        assert(left.length == 9); assert(right.length == 9);\n+        byte lBucket = left[0], rBucket = right[0];\n+        assert(lBucket == rBucket);\n+        long lTxnId = txOf(left), rTxnId = txOf(right), middleTxnId = (lTxnId + rTxnId) / 2;\n+        return toRowKeyWithBucket(middleTxnId, lBucket);\n+    }\n+\n+    private Pair<Long, Long> first(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,false);\n+    }\n+\n+    private Pair<Long, Long> last(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,true);\n+    }\n+\n+    private byte[] toRowKeyWithBucket(long txId, byte bucket) {\n+        byte[] result = TxnUtils.getRowKey(txId);\n+        assert result.length == 9 : \"unexpected rowKey format\";\n+        result[0] = bucket;\n+        return result;\n+    }\n+\n+    // When we use a past transaction P whose timestamp is T, we can read data which is committed before T\n+    // i.e. all data with time < T will be visible, therefore, to be able to read the data of the past\n+    // transaction itself, we slide to the next tx.\n+    private long slideToNextTx(long tx) throws IOException {\n+        if(tx == -1) { // special case for timestamp that happened before the first transaction.\n+            return -1;\n+        }\n+        return tx + SIConstants.TRASANCTION_INCREMENT;\n+    }\n+\n+    public Pair<Long, Long> getTxAt(long ts) throws IOException {\n+        long closestTS = Long.MAX_VALUE, closestTx = -1;\n+        Pair<Long, Long> before, after;\n+        for(byte i = 0; i < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT; ++i) {\n+            before = first(i);\n+            if(before == null /*|| before.getBeginTs() > ts*/) {\n+                continue; // region is empty, or the earliest tx in there happened after 'ts'\n+            }\n+            if(before.getSecond() > ts) {\n+                if(LOG.isTraceEnabled())\n+                    SpliceLogUtils.trace(LOG,\"in bucket %d the first txn [%s (TS: %s), id %s] happened after the needle (%s) exiting!\",\n+                            (int)i,\n+                            TxnUtils.rowKeytoHbaseEscaped(toRowKeyWithBucket(before.getFirst(), i)),\n+                            new Timestamp(before.getSecond()).toString(),\n+                            before.getFirst().toString(),\n+                            new Timestamp(ts).toString());\n+                    return new Pair<>(slideToNextTx(closestTx), closestTS); // nothing, needle is too early: <needle> ....... [before ...... after]\n+            }\n+            after = last(i);\n+            if(after.getSecond() < ts) {\n+                if(LOG.isTraceEnabled())\n+                    SpliceLogUtils.trace(LOG,\"in bucket %d the last txn [%s (TS: %s), id %s] happened before the needle (%s) exiting!\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5OTg3Mw=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNzQzNA==", "bodyText": "Yeah, I changed all of them back to DEBUG.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456317434", "createdAt": "2020-07-17T09:05:06Z", "author": {"login": "hatyo"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+\n+public class TxnTimeTraveler {\n+    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n+\n+    private TxnFinder txnFinder;\n+\n+    public TxnTimeTraveler(TxnFinder txnFinder) {\n+        this.txnFinder = txnFinder;\n+    }\n+\n+    /// @return Pair<closest tx id, closest tx's ts>\n+    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n+                                     byte[] end, long endTS) throws IOException {\n+        if(LOG.isTraceEnabled())\n+            SpliceLogUtils.trace(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n+                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n+                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n+        byte[] left = begin, right = end, middle;\n+        long leftTS = beginTS, rightTS = endTS;\n+        boolean changed = true, reversed = false;\n+        while(changed) {\n+            if(Arrays.equals(left, right)) {\n+                if(leftTS < needleTS) {\n+                    return new Pair<>(txOf(left), leftTS);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            changed = false;\n+            middle = middle(left, right);\n+            Pair<Long, Long> middleTx;\n+            middleTx = txnFinder.find(bucket, middle, reversed);\n+            reversed = false;\n+            if(LOG.isTraceEnabled())\n+                SpliceLogUtils.trace(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5OTM0NA=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNzk0OQ==", "bodyText": "Done.", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456317949", "createdAt": "2020-07-17T09:06:04Z", "author": {"login": "hatyo"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/CoprocessorTxnStore.java", "diffHunk": "@@ -268,6 +268,17 @@ public int compare(TxnView o1,TxnView o2){\n         }\n     }\n \n+    @Override\n+    public long getTxnAt(long ts) throws IOException {\n+        final TxnMessage.TxnAtRequest request=TxnMessage.TxnAtRequest.newBuilder().setTs(ts).build();\n+        try(TxnNetworkLayer table = tableFactory.accessTxnNetwork()){\n+            TxnMessage.TxnAtResponse result = table.getTxnAt(request);\n+            return result.getTxnId();\n+        }catch(Throwable throwable){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5NzYyNg=="}, "originalCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a028264376428e88eecb8ff963ff4f6dba222fd7", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/a028264376428e88eecb8ff963ff4f6dba222fd7", "committedDate": "2020-07-23T12:48:54Z", "message": "DB-9715 Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1df95cc586347e02f45c22577b9c2a72e759ce38", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/1df95cc586347e02f45c22577b9c2a72e759ce38", "committedDate": "2020-07-23T13:17:58Z", "message": "Merge remote-tracking branch 'origin' into DB-9715"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f4d1710199a53ee85c22658026d123bd83b3b88b", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/f4d1710199a53ee85c22658026d123bd83b3b88b", "committedDate": "2020-07-06T15:30:01Z", "message": "DB-9715 Implement algorithm to map timestamp to nearest transaction.\n\n- implement a special version of binary search that efficiently\n  scans a bucket of txn in SPLICE_TXN looking for the nearest\n  transaction to a given timestamp.\n- implement a new endpoint API call to retrieven nearest tx of\n  a given timestamp.\n- add tests."}, "afterCommit": {"oid": "1df95cc586347e02f45c22577b9c2a72e759ce38", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/1df95cc586347e02f45c22577b9c2a72e759ce38", "committedDate": "2020-07-23T13:17:58Z", "message": "Merge remote-tracking branch 'origin' into DB-9715"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2716a5e98c6d1f16f3bfa68c6f2e6e91620712e8", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/2716a5e98c6d1f16f3bfa68c6f2e6e91620712e8", "committedDate": "2020-07-24T17:00:12Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9715"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1ODM1NDM0", "url": "https://github.com/splicemachine/spliceengine/pull/3771#pullrequestreview-455835434", "createdAt": "2020-07-27T14:27:37Z", "commit": {"oid": "2716a5e98c6d1f16f3bfa68c6f2e6e91620712e8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "625377de5f60745e7f8697f90fba10017d287380", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/625377de5f60745e7f8697f90fba10017d287380", "committedDate": "2020-08-04T14:45:09Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9715"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8070e6b063e11c0dfa62e0caf86365de8548d5cb", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/8070e6b063e11c0dfa62e0caf86365de8548d5cb", "committedDate": "2020-08-04T15:03:13Z", "message": "DB-9715 address spotbugs issues."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNTA3MTg0", "url": "https://github.com/splicemachine/spliceengine/pull/3771#pullrequestreview-461507184", "createdAt": "2020-08-05T09:46:50Z", "commit": {"oid": "8070e6b063e11c0dfa62e0caf86365de8548d5cb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af035906997bb6ffdeec0468b1ba102d84741011", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/af035906997bb6ffdeec0468b1ba102d84741011", "committedDate": "2020-08-06T10:54:12Z", "message": "Merge remote-tracking branch 'origin/master' into DB-9715"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb8b5ed9082f6d18a3865968cf5c63bac777c43a", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/eb8b5ed9082f6d18a3865968cf5c63bac777c43a", "committedDate": "2020-08-06T10:54:33Z", "message": "DB-9715 fix exception message."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNDE2MDE2", "url": "https://github.com/splicemachine/spliceengine/pull/3771#pullrequestreview-462416016", "createdAt": "2020-08-06T11:00:27Z", "commit": {"oid": "eb8b5ed9082f6d18a3865968cf5c63bac777c43a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzM0NzU0", "url": "https://github.com/splicemachine/spliceengine/pull/3771#pullrequestreview-462734754", "createdAt": "2020-08-06T17:33:24Z", "commit": {"oid": "eb8b5ed9082f6d18a3865968cf5c63bac777c43a"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzozMzoyNFrOG89fxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzozMzoyNFrOG89fxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3NTMwMQ==", "bodyText": "While  misspellings generally aren't noteworthy and this isn't a blocker for merging today, the literal here is spelled wrong. Could make searching for it harder in the future, so can we fix this in a future release?", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r466575301", "createdAt": "2020-08-06T17:33:24Z", "author": {"login": "carolp-503"}, "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+\n+public class TxnTimeTraveler {\n+    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n+\n+    private TxnFinder txnFinder;\n+\n+    public TxnTimeTraveler(TxnFinder txnFinder) {\n+        this.txnFinder = txnFinder;\n+    }\n+\n+    /// @return Pair<closest tx id, closest tx's ts>\n+    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n+                                     byte[] end, long endTS) throws IOException {\n+        if(LOG.isDebugEnabled())\n+            SpliceLogUtils.debug(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n+                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n+                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n+        byte[] left = begin, right = end, middle;\n+        long leftTS = beginTS, rightTS = endTS;\n+        boolean changed = true, reversed = false;\n+        while(changed) {\n+            if(Arrays.equals(left, right)) {\n+                if(leftTS < needleTS) {\n+                    return new Pair<>(txOf(left), leftTS);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            changed = false;\n+            middle = middle(left, right);\n+            Pair<Long, Long> middleTx;\n+            middleTx = txnFinder.find(bucket, middle, reversed);\n+            reversed = false;\n+            if(LOG.isDebugEnabled())\n+                SpliceLogUtils.debug(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",\n+                        TxnUtils.rowKeytoHbaseEscaped(left), new Timestamp(leftTS).toString(), txOf(left),\n+                        TxnUtils.rowKeytoHbaseEscaped(right), new Timestamp(rightTS).toString(), txOf(right),\n+                        TxnUtils.rowKeytoHbaseEscaped(middle), new Timestamp(middleTx.getSecond()).toString(), middleTx.getFirst().toString());\n+            long middleTS = middleTx.getSecond();\n+            if(middleTS == needleTS) {\n+                return middleTx;\n+            } else if(needleTS < middleTS) {\n+                if(middleTS == rightTS)\n+                {\n+                    reversed = true;\n+                    changed = true;\n+                }\n+                else if(middleTS < rightTS)\n+                {\n+                    right = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                    rightTS = middleTS;\n+                    changed = true;\n+                }\n+            } else if(leftTS < middleTS) {\n+                left = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                leftTS = middleTS;\n+                changed = true;\n+            }\n+        }\n+        return new Pair<>(txOf(left), leftTS);\n+    }\n+\n+    private long txOf(byte[] rowKey) {\n+        return TxnUtils.txnIdFromRowKey(rowKey, 0, rowKey.length);\n+    }\n+\n+    private byte[] middle(byte[] left, byte[] right) {\n+        assert(left.length == 9); assert(right.length == 9);\n+        byte lBucket = left[0], rBucket = right[0];\n+        assert(lBucket == rBucket);\n+        long lTxnId = txOf(left), rTxnId = txOf(right), middleTxnId = (lTxnId + rTxnId) / 2;\n+        return toRowKeyWithBucket(middleTxnId, lBucket);\n+    }\n+\n+    private Pair<Long, Long> first(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,false);\n+    }\n+\n+    private Pair<Long, Long> last(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,true);\n+    }\n+\n+    private byte[] toRowKeyWithBucket(long txId, byte bucket) {\n+        byte[] result = TxnUtils.getRowKey(txId);\n+        assert result.length == 9 : \"unexpected rowKey format\";\n+        result[0] = bucket;\n+        return result;\n+    }\n+\n+    // When we use a past transaction P whose timestamp is T, we can read data which is committed before T\n+    // i.e. all data with time < T will be visible, therefore, to be able to read the data of the past\n+    // transaction itself, we slide to the next tx.\n+    private long slideToNextTx(long tx) throws IOException {\n+        if(tx == -1) { // special case for timestamp that happened before the first transaction.\n+            return -1;\n+        }\n+        return tx + SIConstants.TRASANCTION_INCREMENT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb8b5ed9082f6d18a3865968cf5c63bac777c43a"}, "originalPosition": 109}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1293, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}