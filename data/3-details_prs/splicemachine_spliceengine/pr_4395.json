{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwODUxNzk2", "number": 4395, "title": "DB-10521 Allow SSQs with correlation on Group By column(s)", "bodyText": "In this PR we allow a subset of scalar sub-queries (SSQ) to appear in projection list of a group by query if all of their correlated columns are part of the group by columns.\nIn addition, we allow another subset of non-correlated SSQs with aggregations to appear in the projection list of a group by query.", "createdAt": "2020-10-27T15:40:31Z", "url": "https://github.com/splicemachine/spliceengine/pull/4395", "merged": true, "mergeCommit": {"oid": "677f08e3c7b4754c081834030d54c545490d3543"}, "closed": true, "closedAt": "2020-11-12T05:35:42Z", "author": {"login": "hatyo"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdWoaLfAH2gAyNTEwODUxNzk2OjYxN2Q0NWE2ODE1OTk4ZGZmNjUyMmY5Yzc4YzIyOTliNGI2YjEwYTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABda6Xw5gFqTUyNjYwODMwNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "617d45a6815998dff6522f9c78c2299b4b6b10a4", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/617d45a6815998dff6522f9c78c2299b4b6b10a4", "committedDate": "2020-10-27T12:48:22Z", "message": "DB-10521 allow SSQs with correlation on Group By column."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c936b057a06012cfa7b79d98b5a2375838b8ee99", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/c936b057a06012cfa7b79d98b5a2375838b8ee99", "committedDate": "2020-10-27T13:23:13Z", "message": "DB-10521 cleanup and refactoring."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9df7a8131d94febd2100ab521b981aab4eb7cb4b", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/9df7a8131d94febd2100ab521b981aab4eb7cb4b", "committedDate": "2020-10-27T15:37:17Z", "message": "DB-10521 Add tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3OTg4MTcz", "url": "https://github.com/splicemachine/spliceengine/pull/4395#pullrequestreview-517988173", "createdAt": "2020-10-27T17:50:52Z", "commit": {"oid": "9df7a8131d94febd2100ab521b981aab4eb7cb4b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNzo1MDo1M1rOHpJPlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNzo1NTo1MVrOHpJfMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwNTEwOA==", "bodyText": "I'm not sure why we cannot handle aggregate in the subquery, it seems perfectly fine for both scenarios below:\nselect a1, (select max(b2) from t2), count(*) from t1 group by a1;\nselect a1, (select max(b2) from t2 where a2=t1.a1), count(*) from t1 group by a1;\n\nCan you lift this restriction?", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r512905108", "createdAt": "2020-10-27T17:50:53Z", "author": {"login": "yxia92"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/VerifyAggregateExpressionsVisitor.java", "diffHunk": "@@ -36,137 +36,142 @@\n import com.splicemachine.db.iapi.sql.compile.Visitable;\n import com.splicemachine.db.iapi.sql.compile.Visitor;\n \n+import java.util.List;\n+\n /**\n  * If a RCL (SELECT list) contains an aggregate, then we must verify\n- * that the RCL (SELECT list) is valid.  \n+ * that the RCL (SELECT list) is valid.\n  * For ungrouped queries,\n  * the RCL must be composed entirely of valid aggregate expressions -\n  * in this case, no column references outside of an aggregate.\n  * For grouped aggregates,\n  * the RCL must be composed of grouping columns or valid aggregate\n  * expressions - in this case, the only column references allowed outside of\n- * an aggregate are grouping columns.\n- *\n+ * an aggregate are grouping columns and SSQs correlating on the grouping columns.\n  */\n-public class VerifyAggregateExpressionsVisitor implements Visitor\n-{\n-\tprivate GroupByList groupByList;\n-\n-\tpublic VerifyAggregateExpressionsVisitor(GroupByList groupByList)\n-\t{\n-\t\tthis.groupByList = groupByList;\n-\t}\n-\n-\n-\t////////////////////////////////////////////////\n-\t//\n-\t// VISITOR INTERFACE\n-\t//\n-\t////////////////////////////////////////////////\n-\n-\t/**\n-\t * Verify that this expression is ok\n-\t * for an aggregate query.  \n-\t *\n-\t * @param node \tthe node to process\n-\t *\n-\t * @return me\n-\t *\n-\t * @exception StandardException on ColumnReference not\n-\t * \tin group by list, ValueNode or\t\n-\t * \tJavaValueNode that isn't under an\n-\t * \taggregate\n-\t */\n+public class VerifyAggregateExpressionsVisitor implements Visitor {\n+    private GroupByList groupByList;\n+\n+    public VerifyAggregateExpressionsVisitor(GroupByList groupByList) {\n+        this.groupByList = groupByList;\n+    }\n+\n+\n+    ////////////////////////////////////////////////\n+    //\n+    // VISITOR INTERFACE\n+    //\n+    ////////////////////////////////////////////////\n+\n+    /**\n+     * Verify that this expression is ok\n+     * for an aggregate query.\n+     *\n+     * @param node the node to process\n+     * @throws StandardException on ColumnReference not in group by list,\n+     * ValueNode or JavaValueNode that isn't under an aggregate.\n+     */\n     @Override\n-\tpublic Visitable visit(Visitable node, QueryTreeNode parent) throws StandardException {\n-\t\tif (node instanceof ColumnReference)\n-\t\t{\n-\t\t\tColumnReference cr = (ColumnReference)node;\n-\t\t\n-\t\t\tif (groupByList == null)\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_INVALID_COL_REF_NON_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n-\t\t\t}\n-\n-\t\t\tif (groupByList.findGroupingColumn(cr) == null)\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_INVALID_COL_REF_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n-\t\t\t}\n-\t\t} \n-\t\t\n-\t\t/*\n-\t\t** Subqueries are only valid if they do not have\n-\t\t** correlations and are expression subqueries.  RESOLVE:\n-\t\t** this permits VARIANT expressions in the subquery --\n-\t\t** should this be allowed?  may be confusing to\n-\t\t** users to complain about:\n-\t\t**\n-\t\t**\tselect max(x), (select sum(y).toString() from y) from x\n-\t\t*/\n-\t\telse if (node instanceof SubqueryNode)\n-\t\t{\n-\t\t\tSubqueryNode subq = (SubqueryNode)node;\n-\t\t\n-\t\t\tif ((subq.getSubqueryType() != SubqueryNode.EXPRESSION_SUBQUERY) ||\n-\t\t\t\t subq.hasCorrelatedCRs())\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException( (groupByList == null) ?\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_NON_GROUPED_SELECT_LIST :\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n-\t\t\t}\n-\n-\t\t\t/*\n-\t\t\t** TEMPORARY RESTRICTION: we cannot handle an aggregate\n-\t\t\t** in the subquery \n-\t\t\t*/\n-\t\t\tHasNodeVisitor visitor = new HasNodeVisitor(AggregateNode.class);\n-\t\t\tsubq.accept(visitor);\n-\t\t\tif (visitor.hasNode())\n-\t\t\t{\t\n-\t\t\t\tthrow StandardException.newException( (groupByList == null) ?\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_NON_GROUPED_SELECT_LIST :\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n-\t\t\t}\n-\t\t} else if (node instanceof GroupingFunctionNode) {\n-\t\t\tif (groupByList == null || !groupByList.isRollup()) {\n-\t\t\t\tthrow StandardException.newException(com.splicemachine.db.shared.common.reference.SQLState.LANG_FUNCTION_NOT_ALLOWED,\n-\t\t\t\t\t\t\"GROUPING\",\n-\t\t\t\t\t\t\"Query without OLAP operations like rollup, cube, groupingsets\");\n-\t\t\t} else if (!((GroupingFunctionNode) node).isSingleColumnExpression()) {\n-\t\t\t\tthrow StandardException.newException(com.splicemachine.db.shared.common.reference.SQLState.LANG_INVALID_FUNCTION_ARGUMENT,\n-\t\t\t\t\t\tnode.toString(),\n-\t\t\t\t\t\t\"GROUPING\");\n-\t\t\t}\n-\t\t}\n-\t\treturn node;\n-\t}\n-\n-\t/**\n-\t * Don't visit children under an aggregate, subquery or any node which\n-\t * is equivalent to any of the group by expressions.\n-\t *\n-\t * @param node \tthe node to process\n-\t *\n-\t * @return true/false\n-\t * @throws StandardException \n-\t */\n-\tpublic boolean skipChildren(Visitable node) throws StandardException \n-\t{\n-\t\t// skip aggregate node but not window function node\n-\t\treturn ((node instanceof AggregateNode && !(node instanceof WindowFunctionNode)) ||\n-\t\t\t\t(node instanceof SubqueryNode) ||\n-\t\t\t\t(node instanceof ValueNode &&\n-\t\t\t\t\t\tgroupByList != null \n-\t\t\t\t\t\t&& groupByList.findGroupingColumn((ValueNode)node) != null));\n-\t}\n-\t\n-\tpublic boolean stopTraversal()\n-\t{\n-\t\treturn false;\n-\t}\n-\n-\tpublic boolean visitChildrenFirst(Visitable node)\n-\t{\n-\t\treturn false;\n-\t}\n+    public Visitable visit(Visitable node, QueryTreeNode parent) throws StandardException {\n+        if (node instanceof ColumnReference) {\n+            ColumnReference cr = (ColumnReference) node;\n+\n+            if (groupByList == null) {\n+                throw StandardException.newException(SQLState.LANG_INVALID_COL_REF_NON_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n+            }\n+\n+            if (groupByList.findGroupingColumn(cr) == null) {\n+                throw StandardException.newException(SQLState.LANG_INVALID_COL_REF_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n+            }\n+        }\n+\n+        /*\n+         ** Subqueries are only valid if they do not have\n+         ** correlations and are expression subqueries.  RESOLVE:\n+         ** this permits VARIANT expressions in the subquery --\n+         ** should this be allowed?  may be confusing to\n+         ** users to complain about:\n+         **\n+         ** select max(x), (select sum(y).toString() from y) from x\n+         */\n+        else if (node instanceof SubqueryNode) {\n+            SubqueryNode subquery = (SubqueryNode) node;\n+\n+            if ((subquery.getSubqueryType() != SubqueryNode.EXPRESSION_SUBQUERY) ||\n+                    subquery.hasCorrelatedCRs()) {\n+                if (groupByList != null) {\n+                    /*\n+                     ** Check if the SSQ's correlated columns are referencing the grouping columns, if so, allow it.\n+                     */\n+                    List<ValueNode> correlationCRs = subquery.getCorrelationCRs();\n+                    for (ValueNode correlationCR : correlationCRs) {\n+                        if (correlationCR instanceof ColumnReference) {\n+                            boolean included = false;\n+                            for (OrderedColumn column : groupByList.getNodes()) {\n+                                if (column.getValueNode().equals(correlationCR)) {\n+                                    included = true;\n+                                    break;\n+                                }\n+                            }\n+                            if (!included) {\n+                                throw StandardException.newException(SQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n+                            }\n+                        } else {\n+                            throw StandardException.newException(SQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n+                        }\n+                    }\n+                } else {\n+                    throw StandardException.newException(SQLState.LANG_INVALID_NON_GROUPED_SELECT_LIST);\n+                }\n+            }\n+\n+            if (!subquery.hasCorrelatedCRs()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df7a8131d94febd2100ab521b981aab4eb7cb4b"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwNjg5MA==", "bodyText": "Can you add an additional check subquery.getSubqueryType()==SubqueryNode.EXPRESSION_SUBQUERY) to ensure that we only allow Scalar subquery?", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r512906890", "createdAt": "2020-10-27T17:53:09Z", "author": {"login": "yxia92"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/VerifyAggregateExpressionsVisitor.java", "diffHunk": "@@ -36,137 +36,142 @@\n import com.splicemachine.db.iapi.sql.compile.Visitable;\n import com.splicemachine.db.iapi.sql.compile.Visitor;\n \n+import java.util.List;\n+\n /**\n  * If a RCL (SELECT list) contains an aggregate, then we must verify\n- * that the RCL (SELECT list) is valid.  \n+ * that the RCL (SELECT list) is valid.\n  * For ungrouped queries,\n  * the RCL must be composed entirely of valid aggregate expressions -\n  * in this case, no column references outside of an aggregate.\n  * For grouped aggregates,\n  * the RCL must be composed of grouping columns or valid aggregate\n  * expressions - in this case, the only column references allowed outside of\n- * an aggregate are grouping columns.\n- *\n+ * an aggregate are grouping columns and SSQs correlating on the grouping columns.\n  */\n-public class VerifyAggregateExpressionsVisitor implements Visitor\n-{\n-\tprivate GroupByList groupByList;\n-\n-\tpublic VerifyAggregateExpressionsVisitor(GroupByList groupByList)\n-\t{\n-\t\tthis.groupByList = groupByList;\n-\t}\n-\n-\n-\t////////////////////////////////////////////////\n-\t//\n-\t// VISITOR INTERFACE\n-\t//\n-\t////////////////////////////////////////////////\n-\n-\t/**\n-\t * Verify that this expression is ok\n-\t * for an aggregate query.  \n-\t *\n-\t * @param node \tthe node to process\n-\t *\n-\t * @return me\n-\t *\n-\t * @exception StandardException on ColumnReference not\n-\t * \tin group by list, ValueNode or\t\n-\t * \tJavaValueNode that isn't under an\n-\t * \taggregate\n-\t */\n+public class VerifyAggregateExpressionsVisitor implements Visitor {\n+    private GroupByList groupByList;\n+\n+    public VerifyAggregateExpressionsVisitor(GroupByList groupByList) {\n+        this.groupByList = groupByList;\n+    }\n+\n+\n+    ////////////////////////////////////////////////\n+    //\n+    // VISITOR INTERFACE\n+    //\n+    ////////////////////////////////////////////////\n+\n+    /**\n+     * Verify that this expression is ok\n+     * for an aggregate query.\n+     *\n+     * @param node the node to process\n+     * @throws StandardException on ColumnReference not in group by list,\n+     * ValueNode or JavaValueNode that isn't under an aggregate.\n+     */\n     @Override\n-\tpublic Visitable visit(Visitable node, QueryTreeNode parent) throws StandardException {\n-\t\tif (node instanceof ColumnReference)\n-\t\t{\n-\t\t\tColumnReference cr = (ColumnReference)node;\n-\t\t\n-\t\t\tif (groupByList == null)\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_INVALID_COL_REF_NON_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n-\t\t\t}\n-\n-\t\t\tif (groupByList.findGroupingColumn(cr) == null)\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_INVALID_COL_REF_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n-\t\t\t}\n-\t\t} \n-\t\t\n-\t\t/*\n-\t\t** Subqueries are only valid if they do not have\n-\t\t** correlations and are expression subqueries.  RESOLVE:\n-\t\t** this permits VARIANT expressions in the subquery --\n-\t\t** should this be allowed?  may be confusing to\n-\t\t** users to complain about:\n-\t\t**\n-\t\t**\tselect max(x), (select sum(y).toString() from y) from x\n-\t\t*/\n-\t\telse if (node instanceof SubqueryNode)\n-\t\t{\n-\t\t\tSubqueryNode subq = (SubqueryNode)node;\n-\t\t\n-\t\t\tif ((subq.getSubqueryType() != SubqueryNode.EXPRESSION_SUBQUERY) ||\n-\t\t\t\t subq.hasCorrelatedCRs())\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException( (groupByList == null) ?\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_NON_GROUPED_SELECT_LIST :\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n-\t\t\t}\n-\n-\t\t\t/*\n-\t\t\t** TEMPORARY RESTRICTION: we cannot handle an aggregate\n-\t\t\t** in the subquery \n-\t\t\t*/\n-\t\t\tHasNodeVisitor visitor = new HasNodeVisitor(AggregateNode.class);\n-\t\t\tsubq.accept(visitor);\n-\t\t\tif (visitor.hasNode())\n-\t\t\t{\t\n-\t\t\t\tthrow StandardException.newException( (groupByList == null) ?\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_NON_GROUPED_SELECT_LIST :\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n-\t\t\t}\n-\t\t} else if (node instanceof GroupingFunctionNode) {\n-\t\t\tif (groupByList == null || !groupByList.isRollup()) {\n-\t\t\t\tthrow StandardException.newException(com.splicemachine.db.shared.common.reference.SQLState.LANG_FUNCTION_NOT_ALLOWED,\n-\t\t\t\t\t\t\"GROUPING\",\n-\t\t\t\t\t\t\"Query without OLAP operations like rollup, cube, groupingsets\");\n-\t\t\t} else if (!((GroupingFunctionNode) node).isSingleColumnExpression()) {\n-\t\t\t\tthrow StandardException.newException(com.splicemachine.db.shared.common.reference.SQLState.LANG_INVALID_FUNCTION_ARGUMENT,\n-\t\t\t\t\t\tnode.toString(),\n-\t\t\t\t\t\t\"GROUPING\");\n-\t\t\t}\n-\t\t}\n-\t\treturn node;\n-\t}\n-\n-\t/**\n-\t * Don't visit children under an aggregate, subquery or any node which\n-\t * is equivalent to any of the group by expressions.\n-\t *\n-\t * @param node \tthe node to process\n-\t *\n-\t * @return true/false\n-\t * @throws StandardException \n-\t */\n-\tpublic boolean skipChildren(Visitable node) throws StandardException \n-\t{\n-\t\t// skip aggregate node but not window function node\n-\t\treturn ((node instanceof AggregateNode && !(node instanceof WindowFunctionNode)) ||\n-\t\t\t\t(node instanceof SubqueryNode) ||\n-\t\t\t\t(node instanceof ValueNode &&\n-\t\t\t\t\t\tgroupByList != null \n-\t\t\t\t\t\t&& groupByList.findGroupingColumn((ValueNode)node) != null));\n-\t}\n-\t\n-\tpublic boolean stopTraversal()\n-\t{\n-\t\treturn false;\n-\t}\n-\n-\tpublic boolean visitChildrenFirst(Visitable node)\n-\t{\n-\t\treturn false;\n-\t}\n+    public Visitable visit(Visitable node, QueryTreeNode parent) throws StandardException {\n+        if (node instanceof ColumnReference) {\n+            ColumnReference cr = (ColumnReference) node;\n+\n+            if (groupByList == null) {\n+                throw StandardException.newException(SQLState.LANG_INVALID_COL_REF_NON_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n+            }\n+\n+            if (groupByList.findGroupingColumn(cr) == null) {\n+                throw StandardException.newException(SQLState.LANG_INVALID_COL_REF_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n+            }\n+        }\n+\n+        /*\n+         ** Subqueries are only valid if they do not have\n+         ** correlations and are expression subqueries.  RESOLVE:\n+         ** this permits VARIANT expressions in the subquery --\n+         ** should this be allowed?  may be confusing to\n+         ** users to complain about:\n+         **\n+         ** select max(x), (select sum(y).toString() from y) from x\n+         */\n+        else if (node instanceof SubqueryNode) {\n+            SubqueryNode subquery = (SubqueryNode) node;\n+\n+            if ((subquery.getSubqueryType() != SubqueryNode.EXPRESSION_SUBQUERY) ||\n+                    subquery.hasCorrelatedCRs()) {\n+                if (groupByList != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df7a8131d94febd2100ab521b981aab4eb7cb4b"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwODA5Nw==", "bodyText": "Can you use groupByList.findGroupingColumn(cr) instead like we do above for ColumnReference?", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r512908097", "createdAt": "2020-10-27T17:54:37Z", "author": {"login": "yxia92"}, "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/VerifyAggregateExpressionsVisitor.java", "diffHunk": "@@ -36,137 +36,142 @@\n import com.splicemachine.db.iapi.sql.compile.Visitable;\n import com.splicemachine.db.iapi.sql.compile.Visitor;\n \n+import java.util.List;\n+\n /**\n  * If a RCL (SELECT list) contains an aggregate, then we must verify\n- * that the RCL (SELECT list) is valid.  \n+ * that the RCL (SELECT list) is valid.\n  * For ungrouped queries,\n  * the RCL must be composed entirely of valid aggregate expressions -\n  * in this case, no column references outside of an aggregate.\n  * For grouped aggregates,\n  * the RCL must be composed of grouping columns or valid aggregate\n  * expressions - in this case, the only column references allowed outside of\n- * an aggregate are grouping columns.\n- *\n+ * an aggregate are grouping columns and SSQs correlating on the grouping columns.\n  */\n-public class VerifyAggregateExpressionsVisitor implements Visitor\n-{\n-\tprivate GroupByList groupByList;\n-\n-\tpublic VerifyAggregateExpressionsVisitor(GroupByList groupByList)\n-\t{\n-\t\tthis.groupByList = groupByList;\n-\t}\n-\n-\n-\t////////////////////////////////////////////////\n-\t//\n-\t// VISITOR INTERFACE\n-\t//\n-\t////////////////////////////////////////////////\n-\n-\t/**\n-\t * Verify that this expression is ok\n-\t * for an aggregate query.  \n-\t *\n-\t * @param node \tthe node to process\n-\t *\n-\t * @return me\n-\t *\n-\t * @exception StandardException on ColumnReference not\n-\t * \tin group by list, ValueNode or\t\n-\t * \tJavaValueNode that isn't under an\n-\t * \taggregate\n-\t */\n+public class VerifyAggregateExpressionsVisitor implements Visitor {\n+    private GroupByList groupByList;\n+\n+    public VerifyAggregateExpressionsVisitor(GroupByList groupByList) {\n+        this.groupByList = groupByList;\n+    }\n+\n+\n+    ////////////////////////////////////////////////\n+    //\n+    // VISITOR INTERFACE\n+    //\n+    ////////////////////////////////////////////////\n+\n+    /**\n+     * Verify that this expression is ok\n+     * for an aggregate query.\n+     *\n+     * @param node the node to process\n+     * @throws StandardException on ColumnReference not in group by list,\n+     * ValueNode or JavaValueNode that isn't under an aggregate.\n+     */\n     @Override\n-\tpublic Visitable visit(Visitable node, QueryTreeNode parent) throws StandardException {\n-\t\tif (node instanceof ColumnReference)\n-\t\t{\n-\t\t\tColumnReference cr = (ColumnReference)node;\n-\t\t\n-\t\t\tif (groupByList == null)\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_INVALID_COL_REF_NON_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n-\t\t\t}\n-\n-\t\t\tif (groupByList.findGroupingColumn(cr) == null)\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_INVALID_COL_REF_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n-\t\t\t}\n-\t\t} \n-\t\t\n-\t\t/*\n-\t\t** Subqueries are only valid if they do not have\n-\t\t** correlations and are expression subqueries.  RESOLVE:\n-\t\t** this permits VARIANT expressions in the subquery --\n-\t\t** should this be allowed?  may be confusing to\n-\t\t** users to complain about:\n-\t\t**\n-\t\t**\tselect max(x), (select sum(y).toString() from y) from x\n-\t\t*/\n-\t\telse if (node instanceof SubqueryNode)\n-\t\t{\n-\t\t\tSubqueryNode subq = (SubqueryNode)node;\n-\t\t\n-\t\t\tif ((subq.getSubqueryType() != SubqueryNode.EXPRESSION_SUBQUERY) ||\n-\t\t\t\t subq.hasCorrelatedCRs())\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException( (groupByList == null) ?\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_NON_GROUPED_SELECT_LIST :\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n-\t\t\t}\n-\n-\t\t\t/*\n-\t\t\t** TEMPORARY RESTRICTION: we cannot handle an aggregate\n-\t\t\t** in the subquery \n-\t\t\t*/\n-\t\t\tHasNodeVisitor visitor = new HasNodeVisitor(AggregateNode.class);\n-\t\t\tsubq.accept(visitor);\n-\t\t\tif (visitor.hasNode())\n-\t\t\t{\t\n-\t\t\t\tthrow StandardException.newException( (groupByList == null) ?\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_NON_GROUPED_SELECT_LIST :\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n-\t\t\t}\n-\t\t} else if (node instanceof GroupingFunctionNode) {\n-\t\t\tif (groupByList == null || !groupByList.isRollup()) {\n-\t\t\t\tthrow StandardException.newException(com.splicemachine.db.shared.common.reference.SQLState.LANG_FUNCTION_NOT_ALLOWED,\n-\t\t\t\t\t\t\"GROUPING\",\n-\t\t\t\t\t\t\"Query without OLAP operations like rollup, cube, groupingsets\");\n-\t\t\t} else if (!((GroupingFunctionNode) node).isSingleColumnExpression()) {\n-\t\t\t\tthrow StandardException.newException(com.splicemachine.db.shared.common.reference.SQLState.LANG_INVALID_FUNCTION_ARGUMENT,\n-\t\t\t\t\t\tnode.toString(),\n-\t\t\t\t\t\t\"GROUPING\");\n-\t\t\t}\n-\t\t}\n-\t\treturn node;\n-\t}\n-\n-\t/**\n-\t * Don't visit children under an aggregate, subquery or any node which\n-\t * is equivalent to any of the group by expressions.\n-\t *\n-\t * @param node \tthe node to process\n-\t *\n-\t * @return true/false\n-\t * @throws StandardException \n-\t */\n-\tpublic boolean skipChildren(Visitable node) throws StandardException \n-\t{\n-\t\t// skip aggregate node but not window function node\n-\t\treturn ((node instanceof AggregateNode && !(node instanceof WindowFunctionNode)) ||\n-\t\t\t\t(node instanceof SubqueryNode) ||\n-\t\t\t\t(node instanceof ValueNode &&\n-\t\t\t\t\t\tgroupByList != null \n-\t\t\t\t\t\t&& groupByList.findGroupingColumn((ValueNode)node) != null));\n-\t}\n-\t\n-\tpublic boolean stopTraversal()\n-\t{\n-\t\treturn false;\n-\t}\n-\n-\tpublic boolean visitChildrenFirst(Visitable node)\n-\t{\n-\t\treturn false;\n-\t}\n+    public Visitable visit(Visitable node, QueryTreeNode parent) throws StandardException {\n+        if (node instanceof ColumnReference) {\n+            ColumnReference cr = (ColumnReference) node;\n+\n+            if (groupByList == null) {\n+                throw StandardException.newException(SQLState.LANG_INVALID_COL_REF_NON_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n+            }\n+\n+            if (groupByList.findGroupingColumn(cr) == null) {\n+                throw StandardException.newException(SQLState.LANG_INVALID_COL_REF_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n+            }\n+        }\n+\n+        /*\n+         ** Subqueries are only valid if they do not have\n+         ** correlations and are expression subqueries.  RESOLVE:\n+         ** this permits VARIANT expressions in the subquery --\n+         ** should this be allowed?  may be confusing to\n+         ** users to complain about:\n+         **\n+         ** select max(x), (select sum(y).toString() from y) from x\n+         */\n+        else if (node instanceof SubqueryNode) {\n+            SubqueryNode subquery = (SubqueryNode) node;\n+\n+            if ((subquery.getSubqueryType() != SubqueryNode.EXPRESSION_SUBQUERY) ||\n+                    subquery.hasCorrelatedCRs()) {\n+                if (groupByList != null) {\n+                    /*\n+                     ** Check if the SSQ's correlated columns are referencing the grouping columns, if so, allow it.\n+                     */\n+                    List<ValueNode> correlationCRs = subquery.getCorrelationCRs();\n+                    for (ValueNode correlationCR : correlationCRs) {\n+                        if (correlationCR instanceof ColumnReference) {\n+                            boolean included = false;\n+                            for (OrderedColumn column : groupByList.getNodes()) {\n+                                if (column.getValueNode().equals(correlationCR)) {\n+                                    included = true;\n+                                    break;\n+                                }\n+                            }\n+                            if (!included) {\n+                                throw StandardException.newException(SQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n+                            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df7a8131d94febd2100ab521b981aab4eb7cb4b"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwOTEwNA==", "bodyText": "In addition, could you test a non-correlated Scalar subquery case? Also a case where the Scalar subquery does not contain aggregation?", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r512909104", "createdAt": "2020-10-27T17:55:51Z", "author": {"login": "yxia92"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/GroupByCorreltionIT.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.SpliceDataWatcher;\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceTableWatcher;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import org.junit.Assert;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\n+public class GroupByCorreltionIT {\n+    protected static SpliceWatcher spliceClassWatcher = new SpliceWatcher();\n+    protected static SpliceSchemaWatcher schemaWatcher = new SpliceSchemaWatcher(GroupByOrderByIT.class.getSimpleName());\n+    protected static SpliceTableWatcher otWatcher = new SpliceTableWatcher(\"OUTER_TABLE\", schemaWatcher.schemaName, \"(oc1 VARCHAR(3), oc2 VARCHAR(3), oc3 INT)\");\n+    protected static SpliceTableWatcher itWatcher = new SpliceTableWatcher(\"INNER_TABLE\", schemaWatcher.schemaName, \"(ic1 INTEGER, ic2 VARCHAR(3))\");\n+    private static List<String> otValues = Arrays.asList(\n+            \"('E1','P1',40)\",\n+            \"('E1','P2',20)\",\n+            \"('E1','P3',80)\",\n+            \"('E1','P4',20)\",\n+            \"('E1','P5',12)\",\n+            \"('E1','P6',12)\",\n+            \"('E2','P1',40)\",\n+            \"('E2','P2',80)\",\n+            \"('E3','P2',20)\",\n+            \"('E4','P2',20)\",\n+            \"('E4','P4',40)\",\n+            \"('E4','P5',80)\");\n+    private static List<String> itValues = Arrays.asList(\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(4, 'E2')\",\n+            \"(4, 'E2')\",\n+            \"(4, 'E2')\",\n+            \"(4, 'E2')\",\n+            \"(4, 'E2')\",\n+            \"(5, 'E3')\");\n+    @ClassRule\n+    public static TestRule chain = RuleChain.outerRule(spliceClassWatcher)\n+            .around(schemaWatcher)\n+            .around(otWatcher)\n+            .around(itWatcher)\n+            .around(new SpliceDataWatcher() {\n+                @Override\n+                protected void starting(Description description) {\n+                    try {\n+                        //  load OUTER_TABLE\n+                        for (String rowVal : otValues) {\n+                            spliceClassWatcher.getStatement().executeUpdate(\"insert into \" + otWatcher.toString() + \" values \" + rowVal);\n+                        }\n+                        //  load INNER_TABLE\n+                        for (String rowVal : itValues) {\n+                            spliceClassWatcher.getStatement().executeUpdate(\"insert into \" + itWatcher.toString() + \" values \" + rowVal);\n+                        }\n+                    } catch (Exception e) {\n+                        throw new RuntimeException(e);\n+                    } finally {\n+                        spliceClassWatcher.closeAll();\n+                    }\n+                }\n+            });\n+\n+    @Rule\n+    public SpliceWatcher methodWatcher = new SpliceWatcher();\n+\n+    @Test\n+    public void ssqWithCorrelationOnGroupByColumnWorksCorrectly() throws Exception {\n+        try(ResultSet resultSet = methodWatcher.executeQuery(\"SELECT oc1, (SELECT MAX(ic1) FROM INNER_TABLE WHERE ic2 = outer_table.oc1) FROM OUTER_TABLE GROUP BY oc1 ORDER BY oc1 asc\")) {\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(2, resultSet.getInt(2));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E2\", resultSet.getString(1));Assert.assertEquals(4, resultSet.getInt(2));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E3\", resultSet.getString(1));Assert.assertEquals(5, resultSet.getInt(2));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E4\", resultSet.getString(1));resultSet.getInt(2); Assert.assertTrue(resultSet.wasNull());\n+            Assert.assertFalse(resultSet.next());\n+        }\n+        try(ResultSet resultSet = methodWatcher.executeQuery(\"SELECT oc1, oc2, (SELECT MAX(ic1) FROM INNER_TABLE WHERE ic2 = outer_table.oc1) FROM OUTER_TABLE GROUP BY oc1, oc2 order by oc1 asc, oc2 asc\")) {\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P1\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P2\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P3\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P4\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P5\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P6\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E2\", resultSet.getString(1));Assert.assertEquals(\"P1\", resultSet.getString(2));Assert.assertEquals(4, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E2\", resultSet.getString(1));Assert.assertEquals(\"P2\", resultSet.getString(2));Assert.assertEquals(4, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E3\", resultSet.getString(1));Assert.assertEquals(\"P2\", resultSet.getString(2));Assert.assertEquals(5, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E4\", resultSet.getString(1));Assert.assertEquals(\"P2\", resultSet.getString(2));resultSet.getInt(3); Assert.assertTrue(resultSet.wasNull());\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E4\", resultSet.getString(1));Assert.assertEquals(\"P4\", resultSet.getString(2));resultSet.getInt(3); Assert.assertTrue(resultSet.wasNull());\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E4\", resultSet.getString(1));Assert.assertEquals(\"P5\", resultSet.getString(2));resultSet.getInt(3); Assert.assertTrue(resultSet.wasNull());\n+            Assert.assertFalse(resultSet.next());\n+        }\n+    }\n+\n+    @Test\n+    public void ssqWithoutCorrelationOnGroupByColumnThrows() throws Exception {\n+        try(ResultSet resultSet = methodWatcher.executeQuery(\"SELECT oc1, (SELECT MAX(ic1) FROM INNER_TABLE WHERE ic2 = outer_table.oc2) FROM OUTER_TABLE GROUP BY oc1 order by oc1 asc\")) {\n+            Assert.fail(\"expected exception containing message: The SELECT list of a non-grouped query contains at least one invalid expression. When the SELECT list contains at least one \" +\n+                    \"aggregate then all entries must be valid aggregate expressions\");\n+        } catch(Exception se) {\n+            Assert.assertTrue(se instanceof SQLException);\n+            Assert.assertEquals(\"42Y29\", ((SQLException)se).getSQLState());\n+            Assert.assertTrue(se.getMessage().contains(\"The SELECT list of a non-grouped query contains at least one invalid expression. When the SELECT list contains at least one aggregate \" +\n+                    \"then all entries must be valid aggregate expressions\"));\n+        }\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df7a8131d94febd2100ab521b981aab4eb7cb4b"}, "originalPosition": 147}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5dda2d501e34cbc1d589ed03c4bcd740643459cc", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/5dda2d501e34cbc1d589ed03c4bcd740643459cc", "committedDate": "2020-11-04T10:15:05Z", "message": "DB-10521 group by tests cleanup.\n\n- correct GroupByCorreltionIT.java name to GroupByCorrelationIT.java\n- remove unnecessary System.out.println from GroupByOrderByIT.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "231060ca985a1572df90dfa84cac9477c6e4ee1c", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/231060ca985a1572df90dfa84cac9477c6e4ee1c", "committedDate": "2020-11-04T10:44:11Z", "message": "DB-10521 allow aggregations in non-correlated SSQ.\n\n- add test.\n- cleanup GroupByOrderByIT test suite."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85c0e4117559d94b7a97877ff8eb45ac94928707", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/85c0e4117559d94b7a97877ff8eb45ac94928707", "committedDate": "2020-11-04T11:12:41Z", "message": "DB-10521 address comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96efe884376814f8f163fc61d213d1f2e4415764", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/96efe884376814f8f163fc61d213d1f2e4415764", "committedDate": "2020-11-04T11:12:58Z", "message": "Merge remote-tracking branch 'origin/master' into DB-10521"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTIwMTc4", "url": "https://github.com/splicemachine/spliceengine/pull/4395#pullrequestreview-523520178", "createdAt": "2020-11-04T16:19:04Z", "commit": {"oid": "96efe884376814f8f163fc61d213d1f2e4415764"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjUzNDM5", "url": "https://github.com/splicemachine/spliceengine/pull/4395#pullrequestreview-523653439", "createdAt": "2020-11-04T19:03:13Z", "commit": {"oid": "96efe884376814f8f163fc61d213d1f2e4415764"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxOTowMzoxM1rOHtlySQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxOTowNDoxMFrOHtl0Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2NzA0OQ==", "bodyText": "This is a typo, use GroupByCorrelationIT.class.getSimpleName() instead.", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r517567049", "createdAt": "2020-11-04T19:03:13Z", "author": {"login": "yxia92"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/GroupByCorrelationIT.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.SpliceDataWatcher;\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceTableWatcher;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import org.junit.Assert;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class GroupByCorrelationIT {\n+    protected static SpliceWatcher spliceClassWatcher = new SpliceWatcher();\n+    protected static SpliceSchemaWatcher schemaWatcher = new SpliceSchemaWatcher(GroupByOrderByIT.class.getSimpleName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96efe884376814f8f163fc61d213d1f2e4415764"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2NzUzMA==", "bodyText": "I think c2 should be ic2, this way, we should expect the error message ERROR 21000: Scalar subquery is only allowed to return a single row. at runtime instead of c2 not found. Thanks!", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r517567530", "createdAt": "2020-11-04T19:04:10Z", "author": {"login": "yxia92"}, "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/GroupByCorrelationIT.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.SpliceDataWatcher;\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceTableWatcher;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import org.junit.Assert;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class GroupByCorrelationIT {\n+    protected static SpliceWatcher spliceClassWatcher = new SpliceWatcher();\n+    protected static SpliceSchemaWatcher schemaWatcher = new SpliceSchemaWatcher(GroupByOrderByIT.class.getSimpleName());\n+    protected static SpliceTableWatcher otWatcher = new SpliceTableWatcher(\"OUTER_TABLE\", schemaWatcher.schemaName, \"(oc1 VARCHAR(3), oc2 VARCHAR(3), oc3 INT)\");\n+    protected static SpliceTableWatcher itWatcher = new SpliceTableWatcher(\"INNER_TABLE\", schemaWatcher.schemaName, \"(ic1 INTEGER, ic2 VARCHAR(3))\");\n+    private static List<String> otValues = Arrays.asList(\n+            \"('E1','P1',40)\",\n+            \"('E1','P2',20)\",\n+            \"('E1','P3',80)\",\n+            \"('E1','P4',20)\",\n+            \"('E1','P5',12)\",\n+            \"('E1','P6',12)\",\n+            \"('E2','P1',40)\",\n+            \"('E2','P2',80)\",\n+            \"('E3','P2',20)\",\n+            \"('E4','P2',20)\",\n+            \"('E4','P4',40)\",\n+            \"('E4','P5',80)\");\n+    private static List<String> itValues = Arrays.asList(\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(4, 'E2')\",\n+            \"(4, 'E2')\",\n+            \"(4, 'E2')\",\n+            \"(4, 'E2')\",\n+            \"(4, 'E2')\",\n+            \"(5, 'E3')\");\n+    @ClassRule\n+    public static TestRule chain = RuleChain.outerRule(spliceClassWatcher)\n+            .around(schemaWatcher)\n+            .around(otWatcher)\n+            .around(itWatcher)\n+            .around(new SpliceDataWatcher() {\n+                @Override\n+                protected void starting(Description description) {\n+                    try {\n+                        // load OUTER_TABLE\n+                        for (String rowVal : otValues) {\n+                            spliceClassWatcher.getStatement().executeUpdate(\"insert into \" + otWatcher.toString() + \" values \" + rowVal);\n+                        }\n+                        // load INNER_TABLE\n+                        for (String rowVal : itValues) {\n+                            spliceClassWatcher.getStatement().executeUpdate(\"insert into \" + itWatcher.toString() + \" values \" + rowVal);\n+                        }\n+                    } catch (Exception e) {\n+                        throw new RuntimeException(e);\n+                    } finally {\n+                        spliceClassWatcher.closeAll();\n+                    }\n+                }\n+            });\n+\n+    @Rule\n+    public SpliceWatcher methodWatcher = new SpliceWatcher();\n+\n+    @Test\n+    public void ssqWithCorrelationOnGroupByColumnWorksCorrectly() throws Exception {\n+        try(ResultSet resultSet = methodWatcher.executeQuery(String.format(\"SELECT oc1, (SELECT MAX(ic1) FROM %s WHERE ic2 = %s.oc1) FROM %s GROUP BY oc1 ORDER BY oc1 asc\",\n+                                                                           itWatcher.toString(), otWatcher.toString(), otWatcher.toString()))) {\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(2, resultSet.getInt(2));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E2\", resultSet.getString(1));Assert.assertEquals(4, resultSet.getInt(2));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E3\", resultSet.getString(1));Assert.assertEquals(5, resultSet.getInt(2));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E4\", resultSet.getString(1));resultSet.getInt(2); Assert.assertTrue(resultSet.wasNull());\n+            Assert.assertFalse(resultSet.next());\n+        }\n+        try(ResultSet resultSet = methodWatcher.executeQuery(String.format(\"SELECT oc1, oc2, (SELECT MAX(ic1) FROM %s WHERE ic2 = %s.oc1) FROM %s GROUP BY oc1, oc2 order by oc1 asc, oc2 asc\",\n+                                                                           itWatcher.toString(), otWatcher.toString(), otWatcher.toString()))) {\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P1\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P2\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P3\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P4\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P5\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P6\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E2\", resultSet.getString(1));Assert.assertEquals(\"P1\", resultSet.getString(2));Assert.assertEquals(4, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E2\", resultSet.getString(1));Assert.assertEquals(\"P2\", resultSet.getString(2));Assert.assertEquals(4, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E3\", resultSet.getString(1));Assert.assertEquals(\"P2\", resultSet.getString(2));Assert.assertEquals(5, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E4\", resultSet.getString(1));Assert.assertEquals(\"P2\", resultSet.getString(2));resultSet.getInt(3); Assert.assertTrue(resultSet.wasNull());\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E4\", resultSet.getString(1));Assert.assertEquals(\"P4\", resultSet.getString(2));resultSet.getInt(3); Assert.assertTrue(resultSet.wasNull());\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E4\", resultSet.getString(1));Assert.assertEquals(\"P5\", resultSet.getString(2));resultSet.getInt(3); Assert.assertTrue(resultSet.wasNull());\n+            Assert.assertFalse(resultSet.next());\n+        }\n+    }\n+\n+    @Test\n+    public void ssqWithoutCorrelationOnGroupByColumnThrows() throws Exception {\n+        try(ResultSet resultSet = methodWatcher.executeQuery(String.format(\"SELECT oc1, (SELECT MAX(ic1) FROM %s WHERE ic2 = %s.oc2) FROM %s GROUP BY oc1 order by oc1 asc\",\n+                                                             itWatcher.toString(), otWatcher.toString(), otWatcher.toString()))) {\n+            Assert.fail(\"expected exception containing message: The SELECT list of a grouped query contains at least one invalid expression. \" +\n+                                \"If a SELECT list has a GROUP BY, the list may only contain valid grouping expressions and valid aggregate expressions.\");\n+        } catch(Exception se) {\n+            Assert.assertTrue(se instanceof SQLException);\n+            Assert.assertEquals(\"42Y30\", ((SQLException)se).getSQLState());\n+            Assert.assertTrue(se.getMessage().contains(\"The SELECT list of a grouped query contains at least one invalid expression. If a SELECT list has a GROUP BY, \" +\n+                                                               \"the list may only contain valid grouping expressions and valid aggregate expressions.\"));\n+        }\n+    }\n+\n+    @Test\n+    public void subqueryWithCorrelationOnGroupByColumnThrows() throws Exception {\n+        try(ResultSet resultSet = methodWatcher.executeQuery(String.format(\"SELECT oc1, (SELECT c2 FROM %s WHERE ic2 = %s.oc1) FROM %s GROUP BY oc1 order by oc1 asc\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96efe884376814f8f163fc61d213d1f2e4415764"}, "originalPosition": 152}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6613e3ad2dcdebd4e95e8516c43abfd7bf6772f", "author": {"user": {"login": "hatyo", "name": "Youssef Hatem"}}, "url": "https://github.com/splicemachine/spliceengine/commit/f6613e3ad2dcdebd4e95e8516c43abfd7bf6772f", "committedDate": "2020-11-05T15:52:22Z", "message": "DB-10521 address further comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NDI2MTg5", "url": "https://github.com/splicemachine/spliceengine/pull/4395#pullrequestreview-524426189", "createdAt": "2020-11-05T16:14:01Z", "commit": {"oid": "f6613e3ad2dcdebd4e95e8516c43abfd7bf6772f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NjA4MzA1", "url": "https://github.com/splicemachine/spliceengine/pull/4395#pullrequestreview-526608305", "createdAt": "2020-11-09T19:59:43Z", "commit": {"oid": "f6613e3ad2dcdebd4e95e8516c43abfd7bf6772f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1078, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}