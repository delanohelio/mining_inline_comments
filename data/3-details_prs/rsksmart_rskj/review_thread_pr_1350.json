{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyNDc4MTc1", "number": 1350, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoxOTowNFrOEzyd4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjo1ODoxMlrOE1pRnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzM5NjgyOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoxOTowNFrOHrOlLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoxOTozMFrOHrOmNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA4OTcxMA==", "bodyText": "Variable should be errorMessage", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515089710", "createdAt": "2020-10-30T13:19:04Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA4OTk3Mg==", "bodyText": "Line is too long, add new line", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515089972", "createdAt": "2020-10-30T13:19:30Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA4OTcxMA=="}, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQxNzQ5OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoyMzozOFrOHrOx1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoyMzozOFrOHrOx1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5Mjk0OA==", "bodyText": "Same typo, variable should beerrorMessage, and should add new line", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515092948", "createdAt": "2020-10-30T13:23:38Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n+\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQyNDQ4OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoyNToxN1rOHrO19g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoyNToxN1rOHrO19g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5NDAwNg==", "bodyText": "Condition here should be true, we are checking if derivation arguments hash was already used", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515094006", "createdAt": "2020-10-30T13:25:17Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n+\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMesage);\n+        }\n+\n+        if (!provider.isFastBridgeFederationDerivationHashUsed(derivationArgumentsHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already saved in BridgeStorageProvider \", btcTxHash);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQ1ODA4OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozMzozM1rOHrPK8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0ODoxMFrOHrPyEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5OTM3Ng==", "bodyText": "getSenderBtcAddress & getAmountToActiveFederation are duplicating existing code on processPegin. That method should be invoked from processPegin.", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515099376", "createdAt": "2020-10-30T13:33:33Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n+\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMesage);\n+        }\n+\n+        if (!provider.isFastBridgeFederationDerivationHashUsed(derivationArgumentsHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already saved in BridgeStorageProvider \", btcTxHash);\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract){\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False \", btcTxHash);\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(\n+                btcTx,\n+                this.getSenderBtcAddress(btcTx),\n+                totalAmount\n+        )) {\n+            generateRejectionRelease(btcTx, lpbtcAddress, rskTx, totalAmount, true);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    private Address getSenderBtcAddress(BtcTransaction btcTx) throws GetSenderBtcAddressSenderNotPresentException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwOTM5Mw==", "bodyText": "I think getSenderBtcAddress should be protected too, and both methods should be tested", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515109393", "createdAt": "2020-10-30T13:48:10Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n+\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMesage);\n+        }\n+\n+        if (!provider.isFastBridgeFederationDerivationHashUsed(derivationArgumentsHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already saved in BridgeStorageProvider \", btcTxHash);\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract){\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False \", btcTxHash);\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(\n+                btcTx,\n+                this.getSenderBtcAddress(btcTx),\n+                totalAmount\n+        )) {\n+            generateRejectionRelease(btcTx, lpbtcAddress, rskTx, totalAmount, true);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    private Address getSenderBtcAddress(BtcTransaction btcTx) throws GetSenderBtcAddressSenderNotPresentException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5OTM3Ng=="}, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQ2MDA4OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/GetSenderBtcAddressSenderNotPresentException.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozNDowMlrOHrPMJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozNDowMlrOHrPMJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5OTY4Nw==", "bodyText": "Missing new line.", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515099687", "createdAt": "2020-10-30T13:34:02Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/GetSenderBtcAddressSenderNotPresentException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class GetSenderBtcAddressSenderNotPresentException extends RegisterBtcTransferException{\n+    public GetSenderBtcAddressSenderNotPresentException(String message) {\n+        super(message);\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQ4MDAzOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferContractValidationException.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozODoxMFrOHrPYrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozODoxMFrOHrPYrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjg5NA==", "bodyText": "Missing new line.", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515102894", "createdAt": "2020-10-30T13:38:10Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferContractValidationException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class RegisterBtcTransferContractValidationException extends RegisterBtcTransferException {\n+    public RegisterBtcTransferContractValidationException(String message) {\n+        super(message);\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQ4MDM0OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferException.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozODoxOFrOHrPY4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozODoxOFrOHrPY4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjk0NQ==", "bodyText": "Missing new line.", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515102945", "createdAt": "2020-10-30T13:38:18Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class RegisterBtcTransferException extends Exception {\n+    public RegisterBtcTransferException(String message) {\n+        super(message);\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQ4MDkyOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferRegisterBtcTransValidationException.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozODoyN1rOHrPZOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozODoyN1rOHrPZOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMzAzNQ==", "bodyText": "Missing new line.", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515103035", "createdAt": "2020-10-30T13:38:27Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferRegisterBtcTransValidationException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class RegisterBtcTransferRegisterBtcTransValidationException extends RegisterBtcTransferException{\n+    public RegisterBtcTransferRegisterBtcTransValidationException(String message) {\n+        super(message);\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQ4ODg1OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0MDoxOFrOHrPePw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0MDoxOFrOHrPePw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNDMxOQ==", "bodyText": "log and exception should use the same string for error, and leave it on a variable", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515104319", "createdAt": "2020-10-30T13:40:18Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n+\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMesage);\n+        }\n+\n+        if (!provider.isFastBridgeFederationDerivationHashUsed(derivationArgumentsHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already saved in BridgeStorageProvider \", btcTxHash);\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract){\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False \", btcTxHash);\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(\n+                btcTx,\n+                this.getSenderBtcAddress(btcTx),\n+                totalAmount\n+        )) {\n+            generateRejectionRelease(btcTx, lpbtcAddress, rskTx, totalAmount, true);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    private Address getSenderBtcAddress(BtcTransaction btcTx) throws GetSenderBtcAddressSenderNotPresentException {\n+        Optional<BtcLockSender> btcLockSenderOptional = btcLockSenderProvider.tryGetBtcLockSender(btcTx);\n+        if (!btcLockSenderOptional.isPresent() ||\n+                !BridgeUtils.txIsProcessable(btcLockSenderOptional.get().getType(), activations)) {\n+            logger.warn(\"[getSenderBtcAddress] [btcTx:{}] Could not get BtcLockSender from Btc tx\", btcTx.getHash());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQ5ODA3OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0MjozNFrOHrPkLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0MjozNFrOHrPkLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNTgzNw==", "bodyText": "Before RSKIP 176 this method should not be allowed to be called.", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515105837", "createdAt": "2020-10-30T13:42:34Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4984,275 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+\n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_isNotcontract() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransactionReturnFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzUwMjAxOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0Mzo0NFrOHrPmxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0Mzo0NFrOHrPmxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNjUwMg==", "bodyText": "Unused variable hash", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515106502", "createdAt": "2020-10-30T13:43:44Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4984,275 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+\n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_isNotcontract() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransactionReturnFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(false);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        );\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                pmtSerialized,\n+                height,\n+                btcTxSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_providerFastBridgeFederationScriptHashReturnNotPresent() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzUwODk5OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0NToxOVrOHrPrEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0NToxOVrOHrPrEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNzYwMA==", "bodyText": "Line too long", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515107600", "createdAt": "2020-10-30T13:45:19Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4984,275 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+\n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_isNotcontract() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransactionReturnFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(false);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        );\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                pmtSerialized,\n+                height,\n+                btcTxSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_providerFastBridgeFederationScriptHashReturnNotPresent() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(BridgeEventLogger.class),\n+                new BtcLockSenderProvider(),\n+                mock(Repository.class),\n+                mock(Block.class),\n+                mock(Context.class),\n+                mock(FederationSupport.class),\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        ));\n+\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Coin.valueOf(1)).when(bridgeSupport).getAmountToActiveFederation(any());\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                pmtSerialized,\n+                height,\n+                btcTxSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_shouldTransferToContractFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzUxNDczOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0NjozOVrOHrPugg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0NjozOVrOHrPugg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwODQ4Mg==", "bodyText": "I think we should avoid using raw transactions", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515108482", "createdAt": "2020-10-30T13:46:39Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4984,275 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+\n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_isNotcontract() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransactionReturnFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(false);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        );\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                pmtSerialized,\n+                height,\n+                btcTxSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_providerFastBridgeFederationScriptHashReturnNotPresent() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(BridgeEventLogger.class),\n+                new BtcLockSenderProvider(),\n+                mock(Repository.class),\n+                mock(Block.class),\n+                mock(Context.class),\n+                mock(FederationSupport.class),\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        ));\n+\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Coin.valueOf(1)).when(bridgeSupport).getAmountToActiveFederation(any());\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                pmtSerialized,\n+                height,\n+                btcTxSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_shouldTransferToContractFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDA2MDY1OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDowMzoyNVrOHtnwEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDowMzoyNVrOHtnwEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU5OTI1MQ==", "bodyText": "Mark with Ok in the function name if the test is a successful one", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r517599251", "createdAt": "2020-11-04T20:03:25Z", "author": {"login": "pamgonzalez"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4985,467 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_is_not_contract()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransaction_returns_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeStorageProvider provider = mock(BridgeStorageProvider.class);\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+            bridgeConstants,\n+            provider,\n+            mock(Repository.class),\n+            mock(BridgeEventLogger.class),\n+            null,\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        );\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            mock(Address.class),\n+            mock(RskAddress.class),\n+            mock(Address.class),\n+            true);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_derivation_arguments_hash_already_used()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeStorageProvider provider = mock(BridgeStorageProvider.class);\n+        when(provider.isFastBridgeFederationDerivationHashUsed(any(Sha256Hash.class))).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+                bridgeConstants,\n+                provider,\n+                mock(BridgeEventLogger.class),\n+                new BtcLockSenderProvider(),\n+                mock(Repository.class),\n+                mock(Block.class),\n+                btcContext,\n+                mock(FederationSupport.class),\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                tx.bitcoinSerialize(),\n+                100,\n+                pmtSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                btcAddress,\n+                lbcAddress,\n+                btcAddress,\n+                true\n+        );\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_shouldTransferToContract_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            new BtcLockSenderProvider(),\n+            mock(Repository.class),\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            false\n+        );\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_verifyLockDoesNotSurpassLockingCap_returns_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+        when(activations.isActive(ConsensusRule.RSKIP134)).thenReturn(true);\n+\n+        BtcLockSender btcLockSender = mock(BtcLockSender.class);\n+        BtcLockSenderProvider btcLockSenderProvider = mock(BtcLockSenderProvider.class);\n+        when(btcLockSenderProvider.tryGetBtcLockSender(any())).thenReturn(Optional.of(btcLockSender));\n+\n+        Repository repository = mock(Repository.class);\n+        when(repository.getBalance(any())).thenReturn(co.rsk.core.Coin.valueOf(1));\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            btcLockSenderProvider,\n+            repository,\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Coin.COIN).when(bridgeSupport).getLockingCap();\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            true\n+        );\n+\n+        Assert.assertEquals(-2, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_OK()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            new BtcLockSenderProvider(),\n+            mock(Repository.class),\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            true\n+        );\n+\n+        Assert.assertEquals(1, result);\n+    }\n+\n+    @Test\n+    public void getUTXOsForAddress() {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(Repository.class),\n+            mock(BridgeEventLogger.class),\n+            null,\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        List<UTXO> utxoList = new ArrayList<>();\n+        UTXO utxo = new UTXO(tx.getHash(), 0, Coin.COIN, 0, false, fastBridgeP2SH);\n+        utxoList.add(utxo);\n+\n+        Assert.assertEquals(utxoList, bridgeSupport.getUTXOsForAddress(tx, fastBridgeFedAddress));\n+    }\n+\n+    @Test\n+    public void getUTXOsForAddress_no_utxos_for_address() {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(Repository.class),\n+            mock(BridgeEventLogger.class),\n+            null,\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        Assert.assertEquals(Collections.emptyList(), bridgeSupport.getUTXOsForAddress(tx, btcAddress));\n+    }\n+\n+    @Test\n+    public void getFastBridgeWallet() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f"}, "originalPosition": 467}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDA3MTkzOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDowNjo0MlrOHtn2tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDowNjo0MlrOHtn2tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwMDk0OQ==", "bodyText": "Mark with Ok in the function name if the test is a successful one", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r517600949", "createdAt": "2020-11-04T20:06:42Z", "author": {"login": "pamgonzalez"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4985,467 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_is_not_contract()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransaction_returns_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeStorageProvider provider = mock(BridgeStorageProvider.class);\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+            bridgeConstants,\n+            provider,\n+            mock(Repository.class),\n+            mock(BridgeEventLogger.class),\n+            null,\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        );\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            mock(Address.class),\n+            mock(RskAddress.class),\n+            mock(Address.class),\n+            true);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_derivation_arguments_hash_already_used()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeStorageProvider provider = mock(BridgeStorageProvider.class);\n+        when(provider.isFastBridgeFederationDerivationHashUsed(any(Sha256Hash.class))).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+                bridgeConstants,\n+                provider,\n+                mock(BridgeEventLogger.class),\n+                new BtcLockSenderProvider(),\n+                mock(Repository.class),\n+                mock(Block.class),\n+                btcContext,\n+                mock(FederationSupport.class),\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                tx.bitcoinSerialize(),\n+                100,\n+                pmtSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                btcAddress,\n+                lbcAddress,\n+                btcAddress,\n+                true\n+        );\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_shouldTransferToContract_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            new BtcLockSenderProvider(),\n+            mock(Repository.class),\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            false\n+        );\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_verifyLockDoesNotSurpassLockingCap_returns_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+        when(activations.isActive(ConsensusRule.RSKIP134)).thenReturn(true);\n+\n+        BtcLockSender btcLockSender = mock(BtcLockSender.class);\n+        BtcLockSenderProvider btcLockSenderProvider = mock(BtcLockSenderProvider.class);\n+        when(btcLockSenderProvider.tryGetBtcLockSender(any())).thenReturn(Optional.of(btcLockSender));\n+\n+        Repository repository = mock(Repository.class);\n+        when(repository.getBalance(any())).thenReturn(co.rsk.core.Coin.valueOf(1));\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            btcLockSenderProvider,\n+            repository,\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Coin.COIN).when(bridgeSupport).getLockingCap();\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            true\n+        );\n+\n+        Assert.assertEquals(-2, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_OK()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            new BtcLockSenderProvider(),\n+            mock(Repository.class),\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            true\n+        );\n+\n+        Assert.assertEquals(1, result);\n+    }\n+\n+    @Test\n+    public void getUTXOsForAddress() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f"}, "originalPosition": 406}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDA5NjQyOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoxNDoxOVrOHtoF6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyNDowNVrOHtoZfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwNDg0MA==", "bodyText": "why this function is protected?", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r517604840", "createdAt": "2020-11-04T20:14:19Z", "author": {"login": "pamgonzalez"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2072,12 +2081,203 @@ public int registerBtcTransfer(\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            Address lpBtcAddress,\n+            boolean shouldTransferToContract\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n+        }\n+\n+        Context.propagate(btcContext);\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(btcTx, null, totalAmount)) {\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, lpBtcAddress, rskTx, totalAmount, walletProvider);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    protected WalletProvider createWallet() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwOTg1Mw==", "bodyText": "Could be private agree", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r517609853", "createdAt": "2020-11-04T20:24:05Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2072,12 +2081,203 @@ public int registerBtcTransfer(\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            Address lpBtcAddress,\n+            boolean shouldTransferToContract\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n+        }\n+\n+        Context.propagate(btcContext);\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(btcTx, null, totalAmount)) {\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, lpBtcAddress, rskTx, totalAmount, walletProvider);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    protected WalletProvider createWallet() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwNDg0MA=="}, "originalCommit": {"oid": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDExODQ1OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyMTowMFrOHtoTYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyNDoxNVrOHtoZ2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwODI5MQ==", "bodyText": "I think it does not meet the code standards", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r517608291", "createdAt": "2020-11-04T20:21:00Z", "author": {"login": "pamgonzalez"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2222,8 +2462,8 @@ private boolean verifyLockDoesNotSurpassLockingCap(BtcTransaction btcTx, Address\n         return false;\n     }\n \n-    private Optional<ReleaseTransactionBuilder.BuildResult> getRefundingTransaction(BtcTransaction btcTx, Address senderBtcAddress, boolean isFastBridgeCompatible) throws IOException {\n-\n+    private Optional<ReleaseTransactionBuilder.BuildResult> getRefundingTransaction(\n+        BtcTransaction btcTx, Address refundingBtcAddress, boolean isFastBridgeCompatible) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwOTk0Ng==", "bodyText": "This method is no longer nedeed", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r517609946", "createdAt": "2020-11-04T20:24:15Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2222,8 +2462,8 @@ private boolean verifyLockDoesNotSurpassLockingCap(BtcTransaction btcTx, Address\n         return false;\n     }\n \n-    private Optional<ReleaseTransactionBuilder.BuildResult> getRefundingTransaction(BtcTransaction btcTx, Address senderBtcAddress, boolean isFastBridgeCompatible) throws IOException {\n-\n+    private Optional<ReleaseTransactionBuilder.BuildResult> getRefundingTransaction(\n+        BtcTransaction btcTx, Address refundingBtcAddress, boolean isFastBridgeCompatible) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwODI5MQ=="}, "originalCommit": {"oid": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f"}, "originalPosition": 360}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NjgxMTg1OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/Bridge.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjo0NDo0MVrOHuBm0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjo0NDo0MVrOHuBm0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAyMjg2NA==", "bodyText": "Bridge should not throw any of these errors. They should be catched and rethrow as RunTime (at most)...", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518022864", "createdAt": "2020-11-05T12:44:41Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/Bridge.java", "diffHunk": "@@ -1095,17 +1095,17 @@ public boolean hasBtcBlockCoinbaseTransactionInformation(Object[] args) {\n     }\n \n     public int registerBtcTransfer(Object[] args)\n-    {\n+        throws RegisterBtcTransferException, BlockStoreException, IOException, RegisterBtcTransactionException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0Njg0MzUxOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjo1MzoyNFrOHuB6Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMzozMDoyNFrOHuDUAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAyNzgxNA==", "bodyText": "The return code shouldn't be the same, we should probably review the usage of return codes in the RSKIP", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518027814", "createdAt": "2020-11-05T12:53:24Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2072,12 +2068,203 @@ public int registerBtcTransfer(\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            Address lpBtcAddress,\n+            boolean shouldTransferToContract\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n+        }\n+\n+        Context.propagate(btcContext);\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7c52562dc083831ee9b8827ad79706b27034c2e"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA1MDgxNw==", "bodyText": "Will be discussed on https://rsklabs.atlassian.net/browse/RFS-891", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518050817", "createdAt": "2020-11-05T13:30:24Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2072,12 +2068,203 @@ public int registerBtcTransfer(\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            Address lpBtcAddress,\n+            boolean shouldTransferToContract\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n+        }\n+\n+        Context.propagate(btcContext);\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAyNzgxNA=="}, "originalCommit": {"oid": "e7c52562dc083831ee9b8827ad79706b27034c2e"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0Njg0NjI1OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjo1NDoxMFrOHuB7zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjo1NDoxMFrOHuB7zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAyODIzNw==", "bodyText": "The method doesn't return a Wallet but a WalletProvider, and it creates a fast bridge wallet, please rename the method", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518028237", "createdAt": "2020-11-05T12:54:10Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2072,12 +2068,203 @@ public int registerBtcTransfer(\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            Address lpBtcAddress,\n+            boolean shouldTransferToContract\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n+        }\n+\n+        Context.propagate(btcContext);\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(btcTx, null, totalAmount)) {\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, lpBtcAddress, rskTx, totalAmount, walletProvider);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    private WalletProvider createWallet() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7c52562dc083831ee9b8827ad79706b27034c2e"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0Njg1NzE5OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjo1Njo0MlrOHuCCTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjo1Njo0MlrOHuCCTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAyOTkwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected Coin getAmountToActiveFederation(BtcTransaction btcTx) throws IOException{\n          \n          \n            \n                protected Coin getAmountToLiveFederations(BtcTransaction btcTx) throws IOException{", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518029902", "createdAt": "2020-11-05T12:56:42Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2072,12 +2068,203 @@ public int registerBtcTransfer(\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            Address lpBtcAddress,\n+            boolean shouldTransferToContract\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n+        }\n+\n+        Context.propagate(btcContext);\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(btcTx, null, totalAmount)) {\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, lpBtcAddress, rskTx, totalAmount, walletProvider);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    private WalletProvider createWallet() {\n+        return (BtcTransaction a, Address b) -> {\n+            List<UTXO> utxosList = getUTXOsForAddress(a, b);\n+            return getFastBridgeWallet(btcContext, utxosList);\n+        };\n+    }\n+\n+    protected List<UTXO> getUTXOsForAddress(BtcTransaction btcTx, Address btcAddress) {\n+        List<UTXO> utxosList = new ArrayList<>();\n+        for (TransactionOutput o : btcTx.getOutputs()) {\n+            if (o.getScriptPubKey().getToAddress(bridgeConstants.getBtcParams()).equals(btcAddress)) {\n+                utxosList.add(\n+                    new UTXO(\n+                        btcTx.getHash(),\n+                        o.getIndex(),\n+                        o.getValue(),\n+                        0,\n+                        btcTx.isCoinBase(),\n+                        o.getScriptPubKey()\n+                    )\n+                );\n+            }\n+        }\n+\n+        return utxosList;\n+    }\n+\n+    protected Wallet getFastBridgeWallet(Context btcContext, List<UTXO> utxos) {\n+        Wallet wallet = new Wallet(btcContext);\n+        RskUTXOProvider utxoProvider = new RskUTXOProvider(btcContext.getParams(), utxos);\n+        wallet.setUTXOProvider(utxoProvider);\n+        wallet.setCoinSelector(new RskAllowUnconfirmedCoinSelector());\n+        return wallet;\n+    }\n+\n+    protected Sha256Hash getFastBridgeDerivationHash(\n+        Sha256Hash derivationArgumentsHash,\n+        Address userRefundAddress,\n+        Address lpBtcAddress,\n+        RskAddress lbcAddress\n+    ) {\n+        byte[] fastBridgeDerivationHashData = derivationArgumentsHash.getBytes();\n+        byte[] userRefundAddressBytes = userRefundAddress.getHash160();\n+        byte[] lbcAddressBytes = lbcAddress.getBytes();\n+        byte[] lpBtcAddressBytes = lpBtcAddress.getHash160();\n+\n+        byte[] result = new byte[fastBridgeDerivationHashData.length +\n+            userRefundAddressBytes.length + lpBtcAddressBytes.length + lbcAddressBytes.length];\n+\n+        int dstPosition = 0;\n+\n+        System.arraycopy(\n+            fastBridgeDerivationHashData,\n+            0,\n+            result,\n+            dstPosition,\n+            fastBridgeDerivationHashData.length\n+        );\n+\n+        dstPosition += fastBridgeDerivationHashData.length;\n+\n+        System.arraycopy(\n+            userRefundAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            userRefundAddressBytes.length\n+        );\n+\n+        dstPosition += userRefundAddressBytes.length;\n+\n+        System.arraycopy(\n+            lbcAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            lbcAddressBytes.length\n+        );\n+\n+        dstPosition += lbcAddressBytes.length;\n+\n+        System.arraycopy(\n+            lpBtcAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            lpBtcAddressBytes.length\n+        );\n+\n+        return Sha256Hash.of(result);\n+    }\n+\n+    protected Coin getAmountToActiveFederation(BtcTransaction btcTx) throws IOException{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7c52562dc083831ee9b8827ad79706b27034c2e"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0Njg1ODkwOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/GetSenderBtcAddressSenderNotPresentException.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjo1NzoxMlrOHuCDbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjo1NzoxMlrOHuCDbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzMDE4OQ==", "bodyText": "not used?", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518030189", "createdAt": "2020-11-05T12:57:12Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/GetSenderBtcAddressSenderNotPresentException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class GetSenderBtcAddressSenderNotPresentException extends RegisterBtcTransferException{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7c52562dc083831ee9b8827ad79706b27034c2e"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0Njg2MjM3OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferRegisterBtcTransValidationException.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjo1ODoxMlrOHuCFww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjo1ODoxMlrOHuCFww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzMDc4Nw==", "bodyText": "the name of the exception is kind of confusing", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518030787", "createdAt": "2020-11-05T12:58:12Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferRegisterBtcTransValidationException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class RegisterBtcTransferRegisterBtcTransValidationException extends RegisterBtcTransferException{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7c52562dc083831ee9b8827ad79706b27034c2e"}, "originalPosition": 3}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4523, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}