{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1NTA1MDU3", "number": 1322, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxOToyNDo0NVrOEpmqiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxOToyNDo0NVrOEpmqiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDYwNTU1OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxOToyNDo0NVrOHbX93Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxOToyNDo0NVrOHbX93Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2NjI2OQ==", "bodyText": "I guess you could define RSKT_HEX with the result of this Hex.decode instead so you avoid parsing it all the time", "url": "https://github.com/rsksmart/rskj/pull/1322#discussion_r498466269", "createdAt": "2020-10-01T19:24:45Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -53,45 +55,49 @@\n         return Optional.of(peginInstructions);\n     }\n \n-    protected static byte[] extractOpReturnData(BtcTransaction btcTx)\n-        throws PeginInstructionsException {\n-        byte[] data = new byte[]{};\n-        int opReturnOccurrences = 0;\n-\n+    protected static byte[] extractOpReturnData(BtcTransaction btcTx) throws PeginInstructionsException {\n         logger.trace(\"[extractOpReturnData] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());\n \n-        for (int i=0; i<btcTx.getOutputs().size(); i++) {\n-            List<ScriptChunk> chunksByOutput = btcTx.getOutput(i).getScriptPubKey().getChunks();\n-            if (chunksByOutput.get(0).opcode == ScriptOpCodes.OP_RETURN) {\n-                if (chunksByOutput.size() > 1) {\n-                    data = btcTx.getOutput(i).getScriptPubKey().getChunks().get(1).data;\n-                    opReturnOccurrences++;\n-                } else {\n-                    // OP_RETURN exist but data is empty\n-                    opReturnOccurrences++;\n-                    data = null;\n-                }\n+        byte[] data = new byte[]{};\n+        int opReturnForRskOccurrences = 0;\n+\n+        for (int i = 0; i < btcTx.getOutputs().size(); i++) {\n+            TransactionOutput txOutput = btcTx.getOutput(i);\n+            if(hasOpReturnForRsk(txOutput)) {\n+                data = txOutput.getScriptPubKey().getChunks().get(1).data;\n+                opReturnForRskOccurrences++;\n             }\n         }\n \n-        if (opReturnOccurrences == 0) {\n+        if (opReturnForRskOccurrences == 0) {\n             String message = String.format(\"No OP_RETURN output found for tx %s\", btcTx.getHash());\n             throw new NoOpReturnException(message);\n         }\n \n-        if (opReturnOccurrences > 1) {\n-            String message = String.format(\"Only one output with OP_RETURN is allowed. Found %d\",\n-                opReturnOccurrences);\n+        if (opReturnForRskOccurrences > 1) {\n+            String message = String.format(\"Only one output with OP_RETURN for RSK is allowed. Found %d\",\n+                opReturnForRskOccurrences);\n             logger.debug(\"[extractOpReturnData] {}\", message);\n             throw new PeginInstructionsException(message);\n         }\n \n-        if (data == null) {\n-            String message = \"Empty OP_RETURN data found\";\n-            logger.debug(\"[extractOpReturnData] {}\", message);\n-            throw new PeginInstructionsException(message);\n+        return data;\n+    }\n+\n+    private static boolean hasOpReturnForRsk(TransactionOutput txOutput) {\n+        if(txOutput.getScriptPubKey().isOpReturn()) {\n+            // Check if it has data with `RSKT` prefix\n+            List<ScriptChunk> chunksByOutput = txOutput.getScriptPubKey().getChunks();\n+            if (chunksByOutput.size() > 1 &&\n+                chunksByOutput.get(1).data != null &&\n+                chunksByOutput.get(1).data.length >= 4) {\n+                byte[] prefix = Arrays.copyOfRange(chunksByOutput.get(1).data, 0, 4);\n+                if (Arrays.equals(prefix, Hex.decode(RSKT_HEX))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e72f3d5c3d148beacff01d855e9d9f1b3cdd927"}, "originalPosition": 84}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4489, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}