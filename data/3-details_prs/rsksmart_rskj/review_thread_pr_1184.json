{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0MzM1MTY3", "number": 1184, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzowNzowMVrOEAMcTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzoxNDo1OVrOEAMnZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjM5MzA4OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/net/light/LightPeer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzowNzowMVrOGbUv7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxOToyNTozMlrOGbZ_0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNDY4Ng==", "bodyText": "This seems to be for testing only, since the getBlocks() method is only called from test code, maybe it merits a comment or a TODO.", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431304686", "createdAt": "2020-05-27T17:07:01Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightPeer.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.net.MessageQueue;\n+import org.ethereum.net.message.Message;\n+import org.ethereum.net.message.ReasonCode;\n+import org.ethereum.net.server.Channel;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class LightPeer {\n+\n+    private final LinkedList<BlockHeader> blockHeaders;\n+    private Channel channel;\n+    private MessageQueue msgQueue;\n+\n+    public LightPeer(Channel channel, MessageQueue msgQueue) {\n+        this.channel = channel;\n+        this.msgQueue = msgQueue;\n+        this.blockHeaders = new LinkedList<>();\n+    }\n+\n+    public String getPeerIdShort() {\n+        return channel.getPeerIdShort();\n+    }\n+\n+    public void sendMessage(Message message) {\n+        msgQueue.sendMessage(message);\n+    }\n+\n+    public void disconnect(ReasonCode reasonCode) {\n+        msgQueue.disconnect(reasonCode);\n+    }\n+\n+    public void receivedBlock(BlockHeader blockHeader) {\n+        blockHeaders.add(blockHeader);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MDY3Mw==", "bodyText": "Received block headers will be stored in a header chain. These methods together with the block header list in each Light peer will disappear.", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431390673", "createdAt": "2020-05-27T19:25:32Z", "author": {"login": "julianlen"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightPeer.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.net.MessageQueue;\n+import org.ethereum.net.message.Message;\n+import org.ethereum.net.message.ReasonCode;\n+import org.ethereum.net.server.Channel;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class LightPeer {\n+\n+    private final LinkedList<BlockHeader> blockHeaders;\n+    private Channel channel;\n+    private MessageQueue msgQueue;\n+\n+    public LightPeer(Channel channel, MessageQueue msgQueue) {\n+        this.channel = channel;\n+        this.msgQueue = msgQueue;\n+        this.blockHeaders = new LinkedList<>();\n+    }\n+\n+    public String getPeerIdShort() {\n+        return channel.getPeerIdShort();\n+    }\n+\n+    public void sendMessage(Message message) {\n+        msgQueue.sendMessage(message);\n+    }\n+\n+    public void disconnect(ReasonCode reasonCode) {\n+        msgQueue.disconnect(reasonCode);\n+    }\n+\n+    public void receivedBlock(BlockHeader blockHeader) {\n+        blockHeaders.add(blockHeader);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNDY4Ng=="}, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjM5NDM5OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/net/light/MessageVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzowNzoyMVrOGbUwuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzowNzoyMVrOGbUwuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNDg4OQ==", "bodyText": "Since there is another MessageVisitor, even if it is on a different namespace, I'm tempted to change the name, (MessageVisitor isn't on itself very meaningful either), maybe to something like LightClientMessageVisitor?", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431304889", "createdAt": "2020-05-27T17:07:21Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/MessageVisitor.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2019 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.net.eth.LightClientHandler;\n+import co.rsk.net.light.message.*;\n+import io.netty.channel.ChannelHandlerContext;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/04/20.\n+ */\n+public class MessageVisitor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjM5NjM1OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/core/bc/BlockChainStatus.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzowNzo1M1rOGbUx_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxOTozMToxNFrOGbaL-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNTIxMg==", "bodyText": "Since the calling code that uses this method says \"this works only for testing purposes\", should this method have a similar comment? Or will it make sense later?", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431305212", "createdAt": "2020-05-27T17:07:53Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/core/bc/BlockChainStatus.java", "diffHunk": "@@ -50,4 +51,8 @@ public BlockDifficulty getTotalDifficulty() {\n     public boolean hasLowerTotalDifficultyThan(Status status) {\n         return this.totalDifficulty.compareTo(status.getTotalDifficulty()) < 0;\n     }\n+\n+    public boolean hasLowerDifficultyThan(LightStatus status) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5Mzc4Nw==", "bodyText": "That comment points to the \"hasTotalDifficulty\" variable. Not the whole method.", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431393787", "createdAt": "2020-05-27T19:31:14Z", "author": {"login": "julianlen"}, "path": "rskj-core/src/main/java/co/rsk/core/bc/BlockChainStatus.java", "diffHunk": "@@ -50,4 +51,8 @@ public BlockDifficulty getTotalDifficulty() {\n     public boolean hasLowerTotalDifficultyThan(Status status) {\n         return this.totalDifficulty.compareTo(status.getTotalDifficulty()) < 0;\n     }\n+\n+    public boolean hasLowerDifficultyThan(LightStatus status) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNTIxMg=="}, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjM5OTA3OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzowODo0MFrOGbUzwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMjozODo0OVrOGbzJ6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNTY2NQ==", "bodyText": "This comment seems off. That's not what the BlockStore does, or is it?", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431305665", "createdAt": "2020-05-27T17:08:40Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgwMjg1OQ==", "bodyText": "You're right, this seems to be an old comment, we should remove it, it makes no sense there", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431802859", "createdAt": "2020-05-28T12:38:49Z", "author": {"login": "smcsicardi"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNTY2NQ=="}, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjM5OTkwOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzowODo1NFrOGbU0Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxOTozNjoyMFrOGbaWkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNTgwNw==", "bodyText": "For this and all other methods, will this be the long term solution, to respond nothing? In https://openethereum.github.io/wiki/The-Parity-Light-Protocol-%28PIP%29 there is a mention of exclusion proofs, would that apply here? Alternatively, should we account for spam in some way?", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431305807", "createdAt": "2020-05-27T17:08:54Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.\n+    private final BlockStore blockStore;\n+    private final RepositoryLocator repositoryLocator;\n+    private final Blockchain blockchain;\n+\n+    public LightProcessor(@Nonnull final Blockchain blockchain,\n+                          @Nonnull final BlockStore blockStore,\n+                          @Nonnull final RepositoryLocator repositoryLocator) {\n+        this.blockchain = blockchain;\n+        this.blockStore = blockStore;\n+        this.repositoryLocator = repositoryLocator;\n+    }\n+    /**\n+     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n+     * @param requestId the id of the request\n+     * @param blockHash   the requested block hash.\n+     * @param lightPeer\n+     */\n+    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5NjQ5Ng==", "bodyText": "In the long term, a light client will have available an amount of \"credits\". Once these credits are finished, the light peer cannot request anything to the full node.", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431396496", "createdAt": "2020-05-27T19:36:20Z", "author": {"login": "julianlen"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.\n+    private final BlockStore blockStore;\n+    private final RepositoryLocator repositoryLocator;\n+    private final Blockchain blockchain;\n+\n+    public LightProcessor(@Nonnull final Blockchain blockchain,\n+                          @Nonnull final BlockStore blockStore,\n+                          @Nonnull final RepositoryLocator repositoryLocator) {\n+        this.blockchain = blockchain;\n+        this.blockStore = blockStore;\n+        this.repositoryLocator = repositoryLocator;\n+    }\n+    /**\n+     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n+     * @param requestId the id of the request\n+     * @param blockHash   the requested block hash.\n+     * @param lightPeer\n+     */\n+    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNTgwNw=="}, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjQwMDkxOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzowOTowOFrOGbU05w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDowNTo0OFrOGbbQqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNTk1OQ==", "bodyText": "Could this possibly return null?", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431305959", "createdAt": "2020-05-27T17:09:08Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.\n+    private final BlockStore blockStore;\n+    private final RepositoryLocator repositoryLocator;\n+    private final Blockchain blockchain;\n+\n+    public LightProcessor(@Nonnull final Blockchain blockchain,\n+                          @Nonnull final BlockStore blockStore,\n+                          @Nonnull final RepositoryLocator repositoryLocator) {\n+        this.blockchain = blockchain;\n+        this.blockStore = blockStore;\n+        this.repositoryLocator = repositoryLocator;\n+    }\n+    /**\n+     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n+     * @param requestId the id of the request\n+     * @param blockHash   the requested block hash.\n+     * @param lightPeer\n+     */\n+    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        List<TransactionReceipt> receipts = new LinkedList<>();\n+\n+        for (Transaction tx :  block.getTransactionsList()) {\n+            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxMTM2OQ==", "bodyText": "This is weird, all transactions return a receipt, it doesn't matter if the transaction was successful or not.", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431411369", "createdAt": "2020-05-27T20:05:48Z", "author": {"login": "julianlen"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.\n+    private final BlockStore blockStore;\n+    private final RepositoryLocator repositoryLocator;\n+    private final Blockchain blockchain;\n+\n+    public LightProcessor(@Nonnull final Blockchain blockchain,\n+                          @Nonnull final BlockStore blockStore,\n+                          @Nonnull final RepositoryLocator repositoryLocator) {\n+        this.blockchain = blockchain;\n+        this.blockStore = blockStore;\n+        this.repositoryLocator = repositoryLocator;\n+    }\n+    /**\n+     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n+     * @param requestId the id of the request\n+     * @param blockHash   the requested block hash.\n+     * @param lightPeer\n+     */\n+    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        List<TransactionReceipt> receipts = new LinkedList<>();\n+\n+        for (Transaction tx :  block.getTransactionsList()) {\n+            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNTk1OQ=="}, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjQwMTI2OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzowOToxNVrOGbU1Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzowOToxNVrOGbU1Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjAyMg==", "bodyText": "I would delete this and all the other methods that aren't supported. They don't belong together at all: One thing is to reply to LC queries as a full node, something very different is to consume replies to those queries as a light node. I would also rename the class to reflect this, maybe something like LightClientQueriesResolver (I didn't think this through).", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431306022", "createdAt": "2020-05-27T17:09:15Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.\n+    private final BlockStore blockStore;\n+    private final RepositoryLocator repositoryLocator;\n+    private final Blockchain blockchain;\n+\n+    public LightProcessor(@Nonnull final Blockchain blockchain,\n+                          @Nonnull final BlockStore blockStore,\n+                          @Nonnull final RepositoryLocator repositoryLocator) {\n+        this.blockchain = blockchain;\n+        this.blockStore = blockStore;\n+        this.repositoryLocator = repositoryLocator;\n+    }\n+    /**\n+     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n+     * @param requestId the id of the request\n+     * @param blockHash   the requested block hash.\n+     * @param lightPeer\n+     */\n+    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        List<TransactionReceipt> receipts = new LinkedList<>();\n+\n+        for (Transaction tx :  block.getTransactionsList()) {\n+            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());\n+            receipts.add(txInfo.getReceipt());\n+        }\n+\n+        Message responseMessage = new BlockReceiptsMessage(requestId, receipts);\n+        lightPeer.sendMessage(responseMessage);\n+    }\n+\n+    public void processBlockReceiptsMessage(long id, List<TransactionReceipt> blockReceipts, LightPeer lightPeer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjQwMjMwOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzowOTozM1rOGbU1zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMjo0MDoxNVrOGbzNSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjE4OQ==", "bodyText": "If this is modelled after https://openethereum.github.io/wiki/The-Parity-Light-Protocol-%28PIP%29 then shouldn't this be the bytecode rather than the code hash?", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431306189", "createdAt": "2020-05-27T17:09:33Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.\n+    private final BlockStore blockStore;\n+    private final RepositoryLocator repositoryLocator;\n+    private final Blockchain blockchain;\n+\n+    public LightProcessor(@Nonnull final Blockchain blockchain,\n+                          @Nonnull final BlockStore blockStore,\n+                          @Nonnull final RepositoryLocator repositoryLocator) {\n+        this.blockchain = blockchain;\n+        this.blockStore = blockStore;\n+        this.repositoryLocator = repositoryLocator;\n+    }\n+    /**\n+     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n+     * @param requestId the id of the request\n+     * @param blockHash   the requested block hash.\n+     * @param lightPeer\n+     */\n+    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        List<TransactionReceipt> receipts = new LinkedList<>();\n+\n+        for (Transaction tx :  block.getTransactionsList()) {\n+            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());\n+            receipts.add(txInfo.getReceipt());\n+        }\n+\n+        Message responseMessage = new BlockReceiptsMessage(requestId, receipts);\n+        lightPeer.sendMessage(responseMessage);\n+    }\n+\n+    public void processBlockReceiptsMessage(long id, List<TransactionReceipt> blockReceipts, LightPeer lightPeer) {\n+        throw new UnsupportedOperationException(\"Not supported BlockReceipt processing\");\n+    }\n+\n+    public void processGetTransactionIndex(long id, byte[] hash, LightPeer lightPeer) {\n+        logger.debug(\"Get Transaction Index Message Received\");\n+\n+        TransactionInfo txinfo = blockchain.getTransactionInfo(hash);\n+\n+        if (txinfo == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        byte[] blockHash = txinfo.getBlockHash();\n+        long blockNumber = blockchain.getBlockByHash(blockHash).getNumber();\n+        long txIndex = txinfo.getIndex();\n+\n+        TransactionIndexMessage response = new TransactionIndexMessage(id, blockNumber, blockHash, txIndex);\n+        lightPeer.sendMessage(response);\n+    }\n+\n+    public void processTransactionIndexMessage(long id, long blockNumber, byte[] blockHash, long txIndex, LightPeer lightPeer) {\n+        throw new UnsupportedOperationException(\"Not supported TransactionIndexMessage processing\");\n+    }\n+\n+    public void processGetCodeMessage(long requestId, byte[] blockHash, byte[] address, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        String addressLog = Hex.toHexString(address);\n+        logger.trace(\"Processing code request {} block {} code {}\", requestId, blockHashLog, addressLog);\n+\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n+        RskAddress addr = new RskAddress(address);\n+        Keccak256 codeHash = repositorySnapshot.getCodeHash(addr);\n+\n+        CodeMessage response = new CodeMessage(requestId, codeHash.getBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxNDk4Nw==", "bodyText": "@smcsicardi", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431414987", "createdAt": "2020-05-27T20:13:12Z", "author": {"login": "julianlen"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.\n+    private final BlockStore blockStore;\n+    private final RepositoryLocator repositoryLocator;\n+    private final Blockchain blockchain;\n+\n+    public LightProcessor(@Nonnull final Blockchain blockchain,\n+                          @Nonnull final BlockStore blockStore,\n+                          @Nonnull final RepositoryLocator repositoryLocator) {\n+        this.blockchain = blockchain;\n+        this.blockStore = blockStore;\n+        this.repositoryLocator = repositoryLocator;\n+    }\n+    /**\n+     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n+     * @param requestId the id of the request\n+     * @param blockHash   the requested block hash.\n+     * @param lightPeer\n+     */\n+    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        List<TransactionReceipt> receipts = new LinkedList<>();\n+\n+        for (Transaction tx :  block.getTransactionsList()) {\n+            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());\n+            receipts.add(txInfo.getReceipt());\n+        }\n+\n+        Message responseMessage = new BlockReceiptsMessage(requestId, receipts);\n+        lightPeer.sendMessage(responseMessage);\n+    }\n+\n+    public void processBlockReceiptsMessage(long id, List<TransactionReceipt> blockReceipts, LightPeer lightPeer) {\n+        throw new UnsupportedOperationException(\"Not supported BlockReceipt processing\");\n+    }\n+\n+    public void processGetTransactionIndex(long id, byte[] hash, LightPeer lightPeer) {\n+        logger.debug(\"Get Transaction Index Message Received\");\n+\n+        TransactionInfo txinfo = blockchain.getTransactionInfo(hash);\n+\n+        if (txinfo == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        byte[] blockHash = txinfo.getBlockHash();\n+        long blockNumber = blockchain.getBlockByHash(blockHash).getNumber();\n+        long txIndex = txinfo.getIndex();\n+\n+        TransactionIndexMessage response = new TransactionIndexMessage(id, blockNumber, blockHash, txIndex);\n+        lightPeer.sendMessage(response);\n+    }\n+\n+    public void processTransactionIndexMessage(long id, long blockNumber, byte[] blockHash, long txIndex, LightPeer lightPeer) {\n+        throw new UnsupportedOperationException(\"Not supported TransactionIndexMessage processing\");\n+    }\n+\n+    public void processGetCodeMessage(long requestId, byte[] blockHash, byte[] address, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        String addressLog = Hex.toHexString(address);\n+        logger.trace(\"Processing code request {} block {} code {}\", requestId, blockHashLog, addressLog);\n+\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n+        RskAddress addr = new RskAddress(address);\n+        Keccak256 codeHash = repositorySnapshot.getCodeHash(addr);\n+\n+        CodeMessage response = new CodeMessage(requestId, codeHash.getBytes());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjE4OQ=="}, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgwMzcyMw==", "bodyText": "Totally right! Clear mistake on my part, will change it now.", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431803723", "createdAt": "2020-05-28T12:40:15Z", "author": {"login": "smcsicardi"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.\n+    private final BlockStore blockStore;\n+    private final RepositoryLocator repositoryLocator;\n+    private final Blockchain blockchain;\n+\n+    public LightProcessor(@Nonnull final Blockchain blockchain,\n+                          @Nonnull final BlockStore blockStore,\n+                          @Nonnull final RepositoryLocator repositoryLocator) {\n+        this.blockchain = blockchain;\n+        this.blockStore = blockStore;\n+        this.repositoryLocator = repositoryLocator;\n+    }\n+    /**\n+     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n+     * @param requestId the id of the request\n+     * @param blockHash   the requested block hash.\n+     * @param lightPeer\n+     */\n+    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        List<TransactionReceipt> receipts = new LinkedList<>();\n+\n+        for (Transaction tx :  block.getTransactionsList()) {\n+            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());\n+            receipts.add(txInfo.getReceipt());\n+        }\n+\n+        Message responseMessage = new BlockReceiptsMessage(requestId, receipts);\n+        lightPeer.sendMessage(responseMessage);\n+    }\n+\n+    public void processBlockReceiptsMessage(long id, List<TransactionReceipt> blockReceipts, LightPeer lightPeer) {\n+        throw new UnsupportedOperationException(\"Not supported BlockReceipt processing\");\n+    }\n+\n+    public void processGetTransactionIndex(long id, byte[] hash, LightPeer lightPeer) {\n+        logger.debug(\"Get Transaction Index Message Received\");\n+\n+        TransactionInfo txinfo = blockchain.getTransactionInfo(hash);\n+\n+        if (txinfo == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        byte[] blockHash = txinfo.getBlockHash();\n+        long blockNumber = blockchain.getBlockByHash(blockHash).getNumber();\n+        long txIndex = txinfo.getIndex();\n+\n+        TransactionIndexMessage response = new TransactionIndexMessage(id, blockNumber, blockHash, txIndex);\n+        lightPeer.sendMessage(response);\n+    }\n+\n+    public void processTransactionIndexMessage(long id, long blockNumber, byte[] blockHash, long txIndex, LightPeer lightPeer) {\n+        throw new UnsupportedOperationException(\"Not supported TransactionIndexMessage processing\");\n+    }\n+\n+    public void processGetCodeMessage(long requestId, byte[] blockHash, byte[] address, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        String addressLog = Hex.toHexString(address);\n+        logger.trace(\"Processing code request {} block {} code {}\", requestId, blockHashLog, addressLog);\n+\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n+        RskAddress addr = new RskAddress(address);\n+        Keccak256 codeHash = repositorySnapshot.getCodeHash(addr);\n+\n+        CodeMessage response = new CodeMessage(requestId, codeHash.getBytes());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjE4OQ=="}, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjQwMzMzOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzowOTo1MFrOGbU2cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzowOTo1MFrOGbU2cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjM1NQ==", "bodyText": "I would add a TODO comment to mark that the merkle proof is yet to be implemented, and the same below", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431306355", "createdAt": "2020-05-27T17:09:50Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.\n+    private final BlockStore blockStore;\n+    private final RepositoryLocator repositoryLocator;\n+    private final Blockchain blockchain;\n+\n+    public LightProcessor(@Nonnull final Blockchain blockchain,\n+                          @Nonnull final BlockStore blockStore,\n+                          @Nonnull final RepositoryLocator repositoryLocator) {\n+        this.blockchain = blockchain;\n+        this.blockStore = blockStore;\n+        this.repositoryLocator = repositoryLocator;\n+    }\n+    /**\n+     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n+     * @param requestId the id of the request\n+     * @param blockHash   the requested block hash.\n+     * @param lightPeer\n+     */\n+    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        List<TransactionReceipt> receipts = new LinkedList<>();\n+\n+        for (Transaction tx :  block.getTransactionsList()) {\n+            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());\n+            receipts.add(txInfo.getReceipt());\n+        }\n+\n+        Message responseMessage = new BlockReceiptsMessage(requestId, receipts);\n+        lightPeer.sendMessage(responseMessage);\n+    }\n+\n+    public void processBlockReceiptsMessage(long id, List<TransactionReceipt> blockReceipts, LightPeer lightPeer) {\n+        throw new UnsupportedOperationException(\"Not supported BlockReceipt processing\");\n+    }\n+\n+    public void processGetTransactionIndex(long id, byte[] hash, LightPeer lightPeer) {\n+        logger.debug(\"Get Transaction Index Message Received\");\n+\n+        TransactionInfo txinfo = blockchain.getTransactionInfo(hash);\n+\n+        if (txinfo == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        byte[] blockHash = txinfo.getBlockHash();\n+        long blockNumber = blockchain.getBlockByHash(blockHash).getNumber();\n+        long txIndex = txinfo.getIndex();\n+\n+        TransactionIndexMessage response = new TransactionIndexMessage(id, blockNumber, blockHash, txIndex);\n+        lightPeer.sendMessage(response);\n+    }\n+\n+    public void processTransactionIndexMessage(long id, long blockNumber, byte[] blockHash, long txIndex, LightPeer lightPeer) {\n+        throw new UnsupportedOperationException(\"Not supported TransactionIndexMessage processing\");\n+    }\n+\n+    public void processGetCodeMessage(long requestId, byte[] blockHash, byte[] address, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        String addressLog = Hex.toHexString(address);\n+        logger.trace(\"Processing code request {} block {} code {}\", requestId, blockHashLog, addressLog);\n+\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n+        RskAddress addr = new RskAddress(address);\n+        Keccak256 codeHash = repositorySnapshot.getCodeHash(addr);\n+\n+        CodeMessage response = new CodeMessage(requestId, codeHash.getBytes());\n+        lightPeer.sendMessage(response);\n+    }\n+\n+    public void processCodeMessage(long id, byte[] codeHash, LightPeer lightPeer) {\n+        throw new UnsupportedOperationException(\"Not supported Code processing\");\n+    }\n+\n+    public void processGetAccountsMessage(long id, byte[] blockHash, byte[] addressHash, LightPeer lightPeer) {\n+        logger.debug(\"Get Accounts Message Received: id {}, blockhash: {}, addressHash {}\", id, blockHash, addressHash);\n+\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n+        RskAddress address = new RskAddress(addressHash);\n+        AccountState state = repositorySnapshot.getAccountState(address);\n+\n+        AccountsMessage response = new AccountsMessage(id, new byte[] {0x00}, state.getNonce().longValue(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjQwNTE4OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzoxMDoxOFrOGbU3qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNDoxODoxMVrOGb3RBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjY2Nw==", "bodyText": "This method encodes only the signature, which doesn't seem correct.", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431306667", "createdAt": "2020-05-27T17:10:18Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light.message;\n+\n+import co.rsk.net.light.MessageVisitor;\n+import org.bouncycastle.util.BigIntegers;\n+import org.ethereum.core.BlockFactory;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.ImmutableTransaction;\n+import org.ethereum.core.Transaction;\n+import org.ethereum.util.RLPList;\n+\n+import java.math.BigInteger;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n+import static org.ethereum.util.RLP.*;\n+\n+public class BlockBodyMessage extends LightClientMessage {\n+\n+    private final long id;\n+    private final List<Transaction> transactions;\n+    private final List<BlockHeader> uncles;\n+\n+    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n+        RLPList list = (RLPList) decode2(encoded).get(0);\n+        byte[] rlpId = list.get(0).getRLPData();\n+        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n+\n+        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n+\n+        List<Transaction> transactionList = new LinkedList<>();\n+        for (int k = 0; k < rlpTransactions.size(); k++) {\n+            byte[] rlpData = rlpTransactions.get(k).getRLPData();\n+            Transaction tx = new ImmutableTransaction(rlpData);\n+            transactionList.add(tx);\n+        }\n+\n+        RLPList rlpUncles = (RLPList) decode2(list.get(2).getRLPData()).get(0);\n+\n+        List<BlockHeader> uncleList = new LinkedList<>();\n+        for (int k = 0; k < rlpUncles.size(); k++) {\n+            byte[] rlpData = rlpUncles.get(k).getRLPData();\n+            BlockHeader uncle = blockFactory.decodeHeader(rlpData);\n+            uncleList.add(uncle);\n+        }\n+\n+        this.transactions = transactionList;\n+        this.uncles = uncleList;\n+        this.code = BLOCK_BODY.asByte();\n+    }\n+\n+    public BlockBodyMessage(long id, List<Transaction> transactionList, List<BlockHeader> uncleList) {\n+\n+        this.id = id;\n+        this.transactions = new LinkedList<>(transactionList);\n+        this.uncles = new LinkedList<>(uncleList);\n+\n+        this.code = BLOCK_BODY.asByte();\n+    }\n+\n+    @Override\n+    public byte[] getEncoded() {\n+        byte[] rlpId = encodeBigInteger(BigInteger.valueOf(getId()));\n+\n+        byte[][] rlpTransactions = getTransactions().stream()\n+                .map(Transaction::getEncoded)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgwNzMwOA==", "bodyText": "Actually the method uses another method which, given the signature, encodes the whole transaction\nLine it calls encoding method: \n  \n    \n      rskj/rskj-core/src/main/java/org/ethereum/core/Transaction.java\n    \n    \n         Line 482\n      in\n      9feb5a0\n    \n    \n    \n    \n\n        \n          \n           this.rlpEncoding = encode(v, r, s); \n        \n    \n  \n\n\nMethod itself: \n  \n    \n      rskj/rskj-core/src/main/java/org/ethereum/core/Transaction.java\n    \n    \n         Line 488\n      in\n      9feb5a0\n    \n    \n    \n    \n\n        \n          \n           private byte[] encode(byte[] v, byte[] r, byte[] s) {", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431807308", "createdAt": "2020-05-28T12:46:25Z", "author": {"login": "smcsicardi"}, "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light.message;\n+\n+import co.rsk.net.light.MessageVisitor;\n+import org.bouncycastle.util.BigIntegers;\n+import org.ethereum.core.BlockFactory;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.ImmutableTransaction;\n+import org.ethereum.core.Transaction;\n+import org.ethereum.util.RLPList;\n+\n+import java.math.BigInteger;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n+import static org.ethereum.util.RLP.*;\n+\n+public class BlockBodyMessage extends LightClientMessage {\n+\n+    private final long id;\n+    private final List<Transaction> transactions;\n+    private final List<BlockHeader> uncles;\n+\n+    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n+        RLPList list = (RLPList) decode2(encoded).get(0);\n+        byte[] rlpId = list.get(0).getRLPData();\n+        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n+\n+        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n+\n+        List<Transaction> transactionList = new LinkedList<>();\n+        for (int k = 0; k < rlpTransactions.size(); k++) {\n+            byte[] rlpData = rlpTransactions.get(k).getRLPData();\n+            Transaction tx = new ImmutableTransaction(rlpData);\n+            transactionList.add(tx);\n+        }\n+\n+        RLPList rlpUncles = (RLPList) decode2(list.get(2).getRLPData()).get(0);\n+\n+        List<BlockHeader> uncleList = new LinkedList<>();\n+        for (int k = 0; k < rlpUncles.size(); k++) {\n+            byte[] rlpData = rlpUncles.get(k).getRLPData();\n+            BlockHeader uncle = blockFactory.decodeHeader(rlpData);\n+            uncleList.add(uncle);\n+        }\n+\n+        this.transactions = transactionList;\n+        this.uncles = uncleList;\n+        this.code = BLOCK_BODY.asByte();\n+    }\n+\n+    public BlockBodyMessage(long id, List<Transaction> transactionList, List<BlockHeader> uncleList) {\n+\n+        this.id = id;\n+        this.transactions = new LinkedList<>(transactionList);\n+        this.uncles = new LinkedList<>(uncleList);\n+\n+        this.code = BLOCK_BODY.asByte();\n+    }\n+\n+    @Override\n+    public byte[] getEncoded() {\n+        byte[] rlpId = encodeBigInteger(BigInteger.valueOf(getId()));\n+\n+        byte[][] rlpTransactions = getTransactions().stream()\n+                .map(Transaction::getEncoded)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjY2Nw=="}, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg3MDIxNA==", "bodyText": "you're right!", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431870214", "createdAt": "2020-05-28T14:18:11Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light.message;\n+\n+import co.rsk.net.light.MessageVisitor;\n+import org.bouncycastle.util.BigIntegers;\n+import org.ethereum.core.BlockFactory;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.ImmutableTransaction;\n+import org.ethereum.core.Transaction;\n+import org.ethereum.util.RLPList;\n+\n+import java.math.BigInteger;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n+import static org.ethereum.util.RLP.*;\n+\n+public class BlockBodyMessage extends LightClientMessage {\n+\n+    private final long id;\n+    private final List<Transaction> transactions;\n+    private final List<BlockHeader> uncles;\n+\n+    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n+        RLPList list = (RLPList) decode2(encoded).get(0);\n+        byte[] rlpId = list.get(0).getRLPData();\n+        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n+\n+        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n+\n+        List<Transaction> transactionList = new LinkedList<>();\n+        for (int k = 0; k < rlpTransactions.size(); k++) {\n+            byte[] rlpData = rlpTransactions.get(k).getRLPData();\n+            Transaction tx = new ImmutableTransaction(rlpData);\n+            transactionList.add(tx);\n+        }\n+\n+        RLPList rlpUncles = (RLPList) decode2(list.get(2).getRLPData()).get(0);\n+\n+        List<BlockHeader> uncleList = new LinkedList<>();\n+        for (int k = 0; k < rlpUncles.size(); k++) {\n+            byte[] rlpData = rlpUncles.get(k).getRLPData();\n+            BlockHeader uncle = blockFactory.decodeHeader(rlpData);\n+            uncleList.add(uncle);\n+        }\n+\n+        this.transactions = transactionList;\n+        this.uncles = uncleList;\n+        this.code = BLOCK_BODY.asByte();\n+    }\n+\n+    public BlockBodyMessage(long id, List<Transaction> transactionList, List<BlockHeader> uncleList) {\n+\n+        this.id = id;\n+        this.transactions = new LinkedList<>(transactionList);\n+        this.uncles = new LinkedList<>(uncleList);\n+\n+        this.code = BLOCK_BODY.asByte();\n+    }\n+\n+    @Override\n+    public byte[] getEncoded() {\n+        byte[] rlpId = encodeBigInteger(BigInteger.valueOf(getId()));\n+\n+        byte[][] rlpTransactions = getTransactions().stream()\n+                .map(Transaction::getEncoded)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjY2Nw=="}, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjQwNTcyOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzoxMDoyN1rOGbU4DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNjoxMzoxN1rOGb8nDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjc2NQ==", "bodyText": "Why empty toString on this and the other messages?", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431306765", "createdAt": "2020-05-27T17:10:27Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light.message;\n+\n+import co.rsk.net.light.MessageVisitor;\n+import org.bouncycastle.util.BigIntegers;\n+import org.ethereum.core.BlockFactory;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.ImmutableTransaction;\n+import org.ethereum.core.Transaction;\n+import org.ethereum.util.RLPList;\n+\n+import java.math.BigInteger;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n+import static org.ethereum.util.RLP.*;\n+\n+public class BlockBodyMessage extends LightClientMessage {\n+\n+    private final long id;\n+    private final List<Transaction> transactions;\n+    private final List<BlockHeader> uncles;\n+\n+    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n+        RLPList list = (RLPList) decode2(encoded).get(0);\n+        byte[] rlpId = list.get(0).getRLPData();\n+        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n+\n+        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n+\n+        List<Transaction> transactionList = new LinkedList<>();\n+        for (int k = 0; k < rlpTransactions.size(); k++) {\n+            byte[] rlpData = rlpTransactions.get(k).getRLPData();\n+            Transaction tx = new ImmutableTransaction(rlpData);\n+            transactionList.add(tx);\n+        }\n+\n+        RLPList rlpUncles = (RLPList) decode2(list.get(2).getRLPData()).get(0);\n+\n+        List<BlockHeader> uncleList = new LinkedList<>();\n+        for (int k = 0; k < rlpUncles.size(); k++) {\n+            byte[] rlpData = rlpUncles.get(k).getRLPData();\n+            BlockHeader uncle = blockFactory.decodeHeader(rlpData);\n+            uncleList.add(uncle);\n+        }\n+\n+        this.transactions = transactionList;\n+        this.uncles = uncleList;\n+        this.code = BLOCK_BODY.asByte();\n+    }\n+\n+    public BlockBodyMessage(long id, List<Transaction> transactionList, List<BlockHeader> uncleList) {\n+\n+        this.id = id;\n+        this.transactions = new LinkedList<>(transactionList);\n+        this.uncles = new LinkedList<>(uncleList);\n+\n+        this.code = BLOCK_BODY.asByte();\n+    }\n+\n+    @Override\n+    public byte[] getEncoded() {\n+        byte[] rlpId = encodeBigInteger(BigInteger.valueOf(getId()));\n+\n+        byte[][] rlpTransactions = getTransactions().stream()\n+                .map(Transaction::getEncoded)\n+                .toArray(byte[][]::new);\n+\n+        byte[][] rlpUncles = getUncles().stream()\n+                .map(BlockHeader::getFullEncoded)\n+                .toArray(byte[][]::new);\n+\n+        return encodeList(rlpId, encodeList(rlpTransactions), encodeList(rlpUncles));\n+    }\n+\n+    @Override\n+    public Class<?> getAnswerMessage() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1Nzc3NQ==", "bodyText": "Ready", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431957775", "createdAt": "2020-05-28T16:13:17Z", "author": {"login": "julianlen"}, "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light.message;\n+\n+import co.rsk.net.light.MessageVisitor;\n+import org.bouncycastle.util.BigIntegers;\n+import org.ethereum.core.BlockFactory;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.ImmutableTransaction;\n+import org.ethereum.core.Transaction;\n+import org.ethereum.util.RLPList;\n+\n+import java.math.BigInteger;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n+import static org.ethereum.util.RLP.*;\n+\n+public class BlockBodyMessage extends LightClientMessage {\n+\n+    private final long id;\n+    private final List<Transaction> transactions;\n+    private final List<BlockHeader> uncles;\n+\n+    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n+        RLPList list = (RLPList) decode2(encoded).get(0);\n+        byte[] rlpId = list.get(0).getRLPData();\n+        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n+\n+        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n+\n+        List<Transaction> transactionList = new LinkedList<>();\n+        for (int k = 0; k < rlpTransactions.size(); k++) {\n+            byte[] rlpData = rlpTransactions.get(k).getRLPData();\n+            Transaction tx = new ImmutableTransaction(rlpData);\n+            transactionList.add(tx);\n+        }\n+\n+        RLPList rlpUncles = (RLPList) decode2(list.get(2).getRLPData()).get(0);\n+\n+        List<BlockHeader> uncleList = new LinkedList<>();\n+        for (int k = 0; k < rlpUncles.size(); k++) {\n+            byte[] rlpData = rlpUncles.get(k).getRLPData();\n+            BlockHeader uncle = blockFactory.decodeHeader(rlpData);\n+            uncleList.add(uncle);\n+        }\n+\n+        this.transactions = transactionList;\n+        this.uncles = uncleList;\n+        this.code = BLOCK_BODY.asByte();\n+    }\n+\n+    public BlockBodyMessage(long id, List<Transaction> transactionList, List<BlockHeader> uncleList) {\n+\n+        this.id = id;\n+        this.transactions = new LinkedList<>(transactionList);\n+        this.uncles = new LinkedList<>(uncleList);\n+\n+        this.code = BLOCK_BODY.asByte();\n+    }\n+\n+    @Override\n+    public byte[] getEncoded() {\n+        byte[] rlpId = encodeBigInteger(BigInteger.valueOf(getId()));\n+\n+        byte[][] rlpTransactions = getTransactions().stream()\n+                .map(Transaction::getEncoded)\n+                .toArray(byte[][]::new);\n+\n+        byte[][] rlpUncles = getUncles().stream()\n+                .map(BlockHeader::getFullEncoded)\n+                .toArray(byte[][]::new);\n+\n+        return encodeList(rlpId, encodeList(rlpTransactions), encodeList(rlpUncles));\n+    }\n+\n+    @Override\n+    public Class<?> getAnswerMessage() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjc2NQ=="}, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjQwNjQxOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzoxMDozOVrOGbU4fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzoxMDozOVrOGbU4fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjg3Nw==", "bodyText": "In this and other places, the usage of import static for enum can be a little hard to read. It is of course, a matter of personal preference.", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431306877", "createdAt": "2020-05-27T17:10:39Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light.message;\n+\n+import co.rsk.net.light.MessageVisitor;\n+import org.bouncycastle.util.BigIntegers;\n+import org.ethereum.core.BlockFactory;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.ImmutableTransaction;\n+import org.ethereum.core.Transaction;\n+import org.ethereum.util.RLPList;\n+\n+import java.math.BigInteger;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n+import static org.ethereum.util.RLP.*;\n+\n+public class BlockBodyMessage extends LightClientMessage {\n+\n+    private final long id;\n+    private final List<Transaction> transactions;\n+    private final List<BlockHeader> uncles;\n+\n+    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n+        RLPList list = (RLPList) decode2(encoded).get(0);\n+        byte[] rlpId = list.get(0).getRLPData();\n+        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n+\n+        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n+\n+        List<Transaction> transactionList = new LinkedList<>();\n+        for (int k = 0; k < rlpTransactions.size(); k++) {\n+            byte[] rlpData = rlpTransactions.get(k).getRLPData();\n+            Transaction tx = new ImmutableTransaction(rlpData);\n+            transactionList.add(tx);\n+        }\n+\n+        RLPList rlpUncles = (RLPList) decode2(list.get(2).getRLPData()).get(0);\n+\n+        List<BlockHeader> uncleList = new LinkedList<>();\n+        for (int k = 0; k < rlpUncles.size(); k++) {\n+            byte[] rlpData = rlpUncles.get(k).getRLPData();\n+            BlockHeader uncle = blockFactory.decodeHeader(rlpData);\n+            uncleList.add(uncle);\n+        }\n+\n+        this.transactions = transactionList;\n+        this.uncles = uncleList;\n+        this.code = BLOCK_BODY.asByte();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjQwOTAxOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzoxMToyNlrOGbU6Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODo0OTo0N1rOGcCKMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzMyNg==", "bodyText": "In this and other places, there is a repeated usage of an structure that could be abstracted away in a lambda, maybe as a static method on a utils package. Something like this:\npublic static <T> List<T> mapListRLP(RLPList inputList, Function<byte[], T> lambda) {\n    List<T> output = new LinkedList<>();\n    for (int k = 0; k < inputList.size(); k++) {\n        byte[] rlpData = inputList.get(k).getRLPData();\n        T outputElement = lambda.apply(rlpData);\n        output.add(outputElement);\n    }\n    return output;\n}\n\nAnd then you can replace this with simply\nList<Transaction> transactionList = mapListRLP(rlpTransactions, rlpData -> new ImmutableTransaction(rlpData));", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431307326", "createdAt": "2020-05-27T17:11:26Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light.message;\n+\n+import co.rsk.net.light.MessageVisitor;\n+import org.bouncycastle.util.BigIntegers;\n+import org.ethereum.core.BlockFactory;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.ImmutableTransaction;\n+import org.ethereum.core.Transaction;\n+import org.ethereum.util.RLPList;\n+\n+import java.math.BigInteger;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n+import static org.ethereum.util.RLP.*;\n+\n+public class BlockBodyMessage extends LightClientMessage {\n+\n+    private final long id;\n+    private final List<Transaction> transactions;\n+    private final List<BlockHeader> uncles;\n+\n+    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n+        RLPList list = (RLPList) decode2(encoded).get(0);\n+        byte[] rlpId = list.get(0).getRLPData();\n+        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n+\n+        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n+\n+        List<Transaction> transactionList = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgwOTM3OQ==", "bodyText": "I really like it, the RLP encoding is always cumbersome, we just didn't took the time to refactor it. We will organize with @julianlen for this and the other fixes.", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431809379", "createdAt": "2020-05-28T12:50:06Z", "author": {"login": "smcsicardi"}, "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light.message;\n+\n+import co.rsk.net.light.MessageVisitor;\n+import org.bouncycastle.util.BigIntegers;\n+import org.ethereum.core.BlockFactory;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.ImmutableTransaction;\n+import org.ethereum.core.Transaction;\n+import org.ethereum.util.RLPList;\n+\n+import java.math.BigInteger;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n+import static org.ethereum.util.RLP.*;\n+\n+public class BlockBodyMessage extends LightClientMessage {\n+\n+    private final long id;\n+    private final List<Transaction> transactions;\n+    private final List<BlockHeader> uncles;\n+\n+    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n+        RLPList list = (RLPList) decode2(encoded).get(0);\n+        byte[] rlpId = list.get(0).getRLPData();\n+        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n+\n+        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n+\n+        List<Transaction> transactionList = new LinkedList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzMyNg=="}, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0ODY5MA==", "bodyText": "Nice", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r432048690", "createdAt": "2020-05-28T18:49:47Z", "author": {"login": "julianlen"}, "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light.message;\n+\n+import co.rsk.net.light.MessageVisitor;\n+import org.bouncycastle.util.BigIntegers;\n+import org.ethereum.core.BlockFactory;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.ImmutableTransaction;\n+import org.ethereum.core.Transaction;\n+import org.ethereum.util.RLPList;\n+\n+import java.math.BigInteger;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n+import static org.ethereum.util.RLP.*;\n+\n+public class BlockBodyMessage extends LightClientMessage {\n+\n+    private final long id;\n+    private final List<Transaction> transactions;\n+    private final List<BlockHeader> uncles;\n+\n+    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n+        RLPList list = (RLPList) decode2(encoded).get(0);\n+        byte[] rlpId = list.get(0).getRLPData();\n+        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n+\n+        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n+\n+        List<Transaction> transactionList = new LinkedList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzMyNg=="}, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjQxMTMxOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzoxMjowNlrOGbU7tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzoxMjowNlrOGbU7tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzcwMg==", "bodyText": "This repeated code makes me think that you should have an auxiliary method that returns a disconnection code or null, and then you disconnect with that code.", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431307702", "createdAt": "2020-05-27T17:12:06Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.BlockDifficulty;\n+import co.rsk.core.bc.BlockChainStatus;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.eth.LightClientHandler;\n+import co.rsk.net.light.message.GetBlockHeaderMessage;\n+import co.rsk.net.light.message.StatusMessage;\n+import io.netty.channel.ChannelHandlerContext;\n+import org.ethereum.config.SystemProperties;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.Genesis;\n+import org.ethereum.crypto.HashUtil;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.net.message.ReasonCode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.*;\n+\n+\n+public class LightSyncProcessor {\n+\n+    private static final int MAX_PENDING_MESSAGES = 1;\n+    private static final int MAX_PEER_CONNECTIONS = 1;\n+    private SystemProperties config;\n+    private final Genesis genesis;\n+    private final BlockStore blockStore;\n+    private Blockchain blockchain;\n+    private final byte version;\n+    private static final Logger loggerNet = LoggerFactory.getLogger(\"lightnet\");\n+    private Map<LightPeer, LightStatus> peerStatuses = new HashMap<>();\n+    private Map<LightPeer, Boolean> txRelay = new HashMap<>();\n+    private long lastRequestedId;\n+    private final Map<Long, LightClientMessageCodes> pendingMessages;\n+\n+\n+    public LightSyncProcessor(SystemProperties config, Genesis genesis, BlockStore blockStore, Blockchain blockchain) {\n+        this.config = config;\n+        this.genesis = genesis;\n+        this.blockStore = blockStore;\n+        this.blockchain = blockchain;\n+        this.version = (byte) 0;\n+        this.pendingMessages = new LinkedHashMap<Long, LightClientMessageCodes>() {\n+            @Override\n+            protected boolean removeEldestEntry(Map.Entry<Long, LightClientMessageCodes> eldest) {\n+                boolean shouldDiscard = size() > MAX_PENDING_MESSAGES;\n+                if (shouldDiscard) {\n+                    loggerNet.trace(\"Pending {}@{} DISCARDED\", eldest.getValue(), eldest.getKey());\n+                }\n+                return shouldDiscard;\n+            }\n+        };\n+    }\n+\n+    public void processStatusMessage(StatusMessage msg, LightPeer lightPeer, ChannelHandlerContext ctx, LightClientHandler lightClientHandler) {\n+        LightStatus status = msg.getStatus();\n+        try {\n+            String bestHashLog = HashUtil.shortHash(status.getBestHash());\n+            loggerNet.debug(\"Receiving Status - block {} {}\", status.getBestNumber(), bestHashLog);\n+\n+            byte protocolVersion = status.getProtocolVersion();\n+            if (protocolVersion != version) {\n+                loggerNet.info(\"Removing LCHandler for {} due to protocol incompatibility\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Protocol version {} - message protocol version {}\",\n+                        version,\n+                        protocolVersion);\n+                lightPeer.disconnect(ReasonCode.INCOMPATIBLE_PROTOCOL);\n+                ctx.pipeline().remove(lightClientHandler); // Peer is not compatible for the 'lc' sub-protocol\n+                return;\n+            }\n+\n+            int networkId = config.networkId();\n+            int msgNetworkId = status.getNetworkId();\n+            if (msgNetworkId != networkId) {\n+                loggerNet.info(\"Removing LCHandler for {} due to invalid network\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Different network received: config network ID {} - message network ID {}\",\n+                        networkId, msgNetworkId);\n+                lightPeer.disconnect(ReasonCode.NULL_IDENTITY);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+\n+            Keccak256 genesisHash = genesis.getHash();\n+            Keccak256 msgGenesisHash = new Keccak256(status.getGenesisHash());\n+            if (!msgGenesisHash.equals(genesisHash)) {\n+                loggerNet.info(\"Removing LCHandler for {} due to unexpected genesis\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Config genesis hash {} - message genesis hash {}\",\n+                        genesisHash, msgGenesisHash);\n+                lightPeer.disconnect(ReasonCode.UNEXPECTED_GENESIS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjQxMTc1OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzoxMjoxNlrOGbU8AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODo0NjowNlrOGcCCQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzc3Ng==", "bodyText": "I don't understand this line nor the usage of the Map. Why use a Map for what essentially could be an int? why you don't disconnect in this case? Shouldn't there be a mechanism to account for disconnections?", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431307776", "createdAt": "2020-05-27T17:12:16Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.BlockDifficulty;\n+import co.rsk.core.bc.BlockChainStatus;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.eth.LightClientHandler;\n+import co.rsk.net.light.message.GetBlockHeaderMessage;\n+import co.rsk.net.light.message.StatusMessage;\n+import io.netty.channel.ChannelHandlerContext;\n+import org.ethereum.config.SystemProperties;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.Genesis;\n+import org.ethereum.crypto.HashUtil;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.net.message.ReasonCode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.*;\n+\n+\n+public class LightSyncProcessor {\n+\n+    private static final int MAX_PENDING_MESSAGES = 1;\n+    private static final int MAX_PEER_CONNECTIONS = 1;\n+    private SystemProperties config;\n+    private final Genesis genesis;\n+    private final BlockStore blockStore;\n+    private Blockchain blockchain;\n+    private final byte version;\n+    private static final Logger loggerNet = LoggerFactory.getLogger(\"lightnet\");\n+    private Map<LightPeer, LightStatus> peerStatuses = new HashMap<>();\n+    private Map<LightPeer, Boolean> txRelay = new HashMap<>();\n+    private long lastRequestedId;\n+    private final Map<Long, LightClientMessageCodes> pendingMessages;\n+\n+\n+    public LightSyncProcessor(SystemProperties config, Genesis genesis, BlockStore blockStore, Blockchain blockchain) {\n+        this.config = config;\n+        this.genesis = genesis;\n+        this.blockStore = blockStore;\n+        this.blockchain = blockchain;\n+        this.version = (byte) 0;\n+        this.pendingMessages = new LinkedHashMap<Long, LightClientMessageCodes>() {\n+            @Override\n+            protected boolean removeEldestEntry(Map.Entry<Long, LightClientMessageCodes> eldest) {\n+                boolean shouldDiscard = size() > MAX_PENDING_MESSAGES;\n+                if (shouldDiscard) {\n+                    loggerNet.trace(\"Pending {}@{} DISCARDED\", eldest.getValue(), eldest.getKey());\n+                }\n+                return shouldDiscard;\n+            }\n+        };\n+    }\n+\n+    public void processStatusMessage(StatusMessage msg, LightPeer lightPeer, ChannelHandlerContext ctx, LightClientHandler lightClientHandler) {\n+        LightStatus status = msg.getStatus();\n+        try {\n+            String bestHashLog = HashUtil.shortHash(status.getBestHash());\n+            loggerNet.debug(\"Receiving Status - block {} {}\", status.getBestNumber(), bestHashLog);\n+\n+            byte protocolVersion = status.getProtocolVersion();\n+            if (protocolVersion != version) {\n+                loggerNet.info(\"Removing LCHandler for {} due to protocol incompatibility\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Protocol version {} - message protocol version {}\",\n+                        version,\n+                        protocolVersion);\n+                lightPeer.disconnect(ReasonCode.INCOMPATIBLE_PROTOCOL);\n+                ctx.pipeline().remove(lightClientHandler); // Peer is not compatible for the 'lc' sub-protocol\n+                return;\n+            }\n+\n+            int networkId = config.networkId();\n+            int msgNetworkId = status.getNetworkId();\n+            if (msgNetworkId != networkId) {\n+                loggerNet.info(\"Removing LCHandler for {} due to invalid network\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Different network received: config network ID {} - message network ID {}\",\n+                        networkId, msgNetworkId);\n+                lightPeer.disconnect(ReasonCode.NULL_IDENTITY);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+\n+            Keccak256 genesisHash = genesis.getHash();\n+            Keccak256 msgGenesisHash = new Keccak256(status.getGenesisHash());\n+            if (!msgGenesisHash.equals(genesisHash)) {\n+                loggerNet.info(\"Removing LCHandler for {} due to unexpected genesis\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Config genesis hash {} - message genesis hash {}\",\n+                        genesisHash, msgGenesisHash);\n+                lightPeer.disconnect(ReasonCode.UNEXPECTED_GENESIS);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+        } catch (NoSuchElementException e) {\n+            loggerNet.debug(\"LCHandler already removed - exception: {}\", e.getMessage());\n+        }\n+\n+        if (peerStatuses.size() >= MAX_PEER_CONNECTIONS) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NjY1Nw==", "bodyText": "This is another case of \"dummy things\". The map is the basic approach to handle peers. For now, there is no something like \"PeerHandlers\". In the sync stage, peerStatuses is used to get the best peer, I mean, the peer with high total difficult and with the best block.\nThen, each node accepts a max quantity of peers.", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r432046657", "createdAt": "2020-05-28T18:46:06Z", "author": {"login": "julianlen"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.BlockDifficulty;\n+import co.rsk.core.bc.BlockChainStatus;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.eth.LightClientHandler;\n+import co.rsk.net.light.message.GetBlockHeaderMessage;\n+import co.rsk.net.light.message.StatusMessage;\n+import io.netty.channel.ChannelHandlerContext;\n+import org.ethereum.config.SystemProperties;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.Genesis;\n+import org.ethereum.crypto.HashUtil;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.net.message.ReasonCode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.*;\n+\n+\n+public class LightSyncProcessor {\n+\n+    private static final int MAX_PENDING_MESSAGES = 1;\n+    private static final int MAX_PEER_CONNECTIONS = 1;\n+    private SystemProperties config;\n+    private final Genesis genesis;\n+    private final BlockStore blockStore;\n+    private Blockchain blockchain;\n+    private final byte version;\n+    private static final Logger loggerNet = LoggerFactory.getLogger(\"lightnet\");\n+    private Map<LightPeer, LightStatus> peerStatuses = new HashMap<>();\n+    private Map<LightPeer, Boolean> txRelay = new HashMap<>();\n+    private long lastRequestedId;\n+    private final Map<Long, LightClientMessageCodes> pendingMessages;\n+\n+\n+    public LightSyncProcessor(SystemProperties config, Genesis genesis, BlockStore blockStore, Blockchain blockchain) {\n+        this.config = config;\n+        this.genesis = genesis;\n+        this.blockStore = blockStore;\n+        this.blockchain = blockchain;\n+        this.version = (byte) 0;\n+        this.pendingMessages = new LinkedHashMap<Long, LightClientMessageCodes>() {\n+            @Override\n+            protected boolean removeEldestEntry(Map.Entry<Long, LightClientMessageCodes> eldest) {\n+                boolean shouldDiscard = size() > MAX_PENDING_MESSAGES;\n+                if (shouldDiscard) {\n+                    loggerNet.trace(\"Pending {}@{} DISCARDED\", eldest.getValue(), eldest.getKey());\n+                }\n+                return shouldDiscard;\n+            }\n+        };\n+    }\n+\n+    public void processStatusMessage(StatusMessage msg, LightPeer lightPeer, ChannelHandlerContext ctx, LightClientHandler lightClientHandler) {\n+        LightStatus status = msg.getStatus();\n+        try {\n+            String bestHashLog = HashUtil.shortHash(status.getBestHash());\n+            loggerNet.debug(\"Receiving Status - block {} {}\", status.getBestNumber(), bestHashLog);\n+\n+            byte protocolVersion = status.getProtocolVersion();\n+            if (protocolVersion != version) {\n+                loggerNet.info(\"Removing LCHandler for {} due to protocol incompatibility\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Protocol version {} - message protocol version {}\",\n+                        version,\n+                        protocolVersion);\n+                lightPeer.disconnect(ReasonCode.INCOMPATIBLE_PROTOCOL);\n+                ctx.pipeline().remove(lightClientHandler); // Peer is not compatible for the 'lc' sub-protocol\n+                return;\n+            }\n+\n+            int networkId = config.networkId();\n+            int msgNetworkId = status.getNetworkId();\n+            if (msgNetworkId != networkId) {\n+                loggerNet.info(\"Removing LCHandler for {} due to invalid network\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Different network received: config network ID {} - message network ID {}\",\n+                        networkId, msgNetworkId);\n+                lightPeer.disconnect(ReasonCode.NULL_IDENTITY);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+\n+            Keccak256 genesisHash = genesis.getHash();\n+            Keccak256 msgGenesisHash = new Keccak256(status.getGenesisHash());\n+            if (!msgGenesisHash.equals(genesisHash)) {\n+                loggerNet.info(\"Removing LCHandler for {} due to unexpected genesis\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Config genesis hash {} - message genesis hash {}\",\n+                        genesisHash, msgGenesisHash);\n+                lightPeer.disconnect(ReasonCode.UNEXPECTED_GENESIS);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+        } catch (NoSuchElementException e) {\n+            loggerNet.debug(\"LCHandler already removed - exception: {}\", e.getMessage());\n+        }\n+\n+        if (peerStatuses.size() >= MAX_PEER_CONNECTIONS) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzc3Ng=="}, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjQxMjM2OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzoxMjoyN1rOGbU8aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOToxMzoxNFrOGcC8gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzg4Mw==", "bodyText": "This is always false, except on the unit tests. Right?", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431307883", "createdAt": "2020-05-27T17:12:27Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.BlockDifficulty;\n+import co.rsk.core.bc.BlockChainStatus;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.eth.LightClientHandler;\n+import co.rsk.net.light.message.GetBlockHeaderMessage;\n+import co.rsk.net.light.message.StatusMessage;\n+import io.netty.channel.ChannelHandlerContext;\n+import org.ethereum.config.SystemProperties;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.Genesis;\n+import org.ethereum.crypto.HashUtil;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.net.message.ReasonCode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.*;\n+\n+\n+public class LightSyncProcessor {\n+\n+    private static final int MAX_PENDING_MESSAGES = 1;\n+    private static final int MAX_PEER_CONNECTIONS = 1;\n+    private SystemProperties config;\n+    private final Genesis genesis;\n+    private final BlockStore blockStore;\n+    private Blockchain blockchain;\n+    private final byte version;\n+    private static final Logger loggerNet = LoggerFactory.getLogger(\"lightnet\");\n+    private Map<LightPeer, LightStatus> peerStatuses = new HashMap<>();\n+    private Map<LightPeer, Boolean> txRelay = new HashMap<>();\n+    private long lastRequestedId;\n+    private final Map<Long, LightClientMessageCodes> pendingMessages;\n+\n+\n+    public LightSyncProcessor(SystemProperties config, Genesis genesis, BlockStore blockStore, Blockchain blockchain) {\n+        this.config = config;\n+        this.genesis = genesis;\n+        this.blockStore = blockStore;\n+        this.blockchain = blockchain;\n+        this.version = (byte) 0;\n+        this.pendingMessages = new LinkedHashMap<Long, LightClientMessageCodes>() {\n+            @Override\n+            protected boolean removeEldestEntry(Map.Entry<Long, LightClientMessageCodes> eldest) {\n+                boolean shouldDiscard = size() > MAX_PENDING_MESSAGES;\n+                if (shouldDiscard) {\n+                    loggerNet.trace(\"Pending {}@{} DISCARDED\", eldest.getValue(), eldest.getKey());\n+                }\n+                return shouldDiscard;\n+            }\n+        };\n+    }\n+\n+    public void processStatusMessage(StatusMessage msg, LightPeer lightPeer, ChannelHandlerContext ctx, LightClientHandler lightClientHandler) {\n+        LightStatus status = msg.getStatus();\n+        try {\n+            String bestHashLog = HashUtil.shortHash(status.getBestHash());\n+            loggerNet.debug(\"Receiving Status - block {} {}\", status.getBestNumber(), bestHashLog);\n+\n+            byte protocolVersion = status.getProtocolVersion();\n+            if (protocolVersion != version) {\n+                loggerNet.info(\"Removing LCHandler for {} due to protocol incompatibility\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Protocol version {} - message protocol version {}\",\n+                        version,\n+                        protocolVersion);\n+                lightPeer.disconnect(ReasonCode.INCOMPATIBLE_PROTOCOL);\n+                ctx.pipeline().remove(lightClientHandler); // Peer is not compatible for the 'lc' sub-protocol\n+                return;\n+            }\n+\n+            int networkId = config.networkId();\n+            int msgNetworkId = status.getNetworkId();\n+            if (msgNetworkId != networkId) {\n+                loggerNet.info(\"Removing LCHandler for {} due to invalid network\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Different network received: config network ID {} - message network ID {}\",\n+                        networkId, msgNetworkId);\n+                lightPeer.disconnect(ReasonCode.NULL_IDENTITY);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+\n+            Keccak256 genesisHash = genesis.getHash();\n+            Keccak256 msgGenesisHash = new Keccak256(status.getGenesisHash());\n+            if (!msgGenesisHash.equals(genesisHash)) {\n+                loggerNet.info(\"Removing LCHandler for {} due to unexpected genesis\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Config genesis hash {} - message genesis hash {}\",\n+                        genesisHash, msgGenesisHash);\n+                lightPeer.disconnect(ReasonCode.UNEXPECTED_GENESIS);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+        } catch (NoSuchElementException e) {\n+            loggerNet.debug(\"LCHandler already removed - exception: {}\", e.getMessage());\n+        }\n+\n+        if (peerStatuses.size() >= MAX_PEER_CONNECTIONS) {\n+            return;\n+        }\n+\n+        if (!hasLowerDifficulty(status)) {\n+            return;\n+        }\n+\n+        peerStatuses.put(lightPeer, status);\n+\n+        if (msg.isTxRelay()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MTU2OQ==", "bodyText": "It's false by default", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r432061569", "createdAt": "2020-05-28T19:13:14Z", "author": {"login": "julianlen"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.BlockDifficulty;\n+import co.rsk.core.bc.BlockChainStatus;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.eth.LightClientHandler;\n+import co.rsk.net.light.message.GetBlockHeaderMessage;\n+import co.rsk.net.light.message.StatusMessage;\n+import io.netty.channel.ChannelHandlerContext;\n+import org.ethereum.config.SystemProperties;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.Genesis;\n+import org.ethereum.crypto.HashUtil;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.net.message.ReasonCode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.*;\n+\n+\n+public class LightSyncProcessor {\n+\n+    private static final int MAX_PENDING_MESSAGES = 1;\n+    private static final int MAX_PEER_CONNECTIONS = 1;\n+    private SystemProperties config;\n+    private final Genesis genesis;\n+    private final BlockStore blockStore;\n+    private Blockchain blockchain;\n+    private final byte version;\n+    private static final Logger loggerNet = LoggerFactory.getLogger(\"lightnet\");\n+    private Map<LightPeer, LightStatus> peerStatuses = new HashMap<>();\n+    private Map<LightPeer, Boolean> txRelay = new HashMap<>();\n+    private long lastRequestedId;\n+    private final Map<Long, LightClientMessageCodes> pendingMessages;\n+\n+\n+    public LightSyncProcessor(SystemProperties config, Genesis genesis, BlockStore blockStore, Blockchain blockchain) {\n+        this.config = config;\n+        this.genesis = genesis;\n+        this.blockStore = blockStore;\n+        this.blockchain = blockchain;\n+        this.version = (byte) 0;\n+        this.pendingMessages = new LinkedHashMap<Long, LightClientMessageCodes>() {\n+            @Override\n+            protected boolean removeEldestEntry(Map.Entry<Long, LightClientMessageCodes> eldest) {\n+                boolean shouldDiscard = size() > MAX_PENDING_MESSAGES;\n+                if (shouldDiscard) {\n+                    loggerNet.trace(\"Pending {}@{} DISCARDED\", eldest.getValue(), eldest.getKey());\n+                }\n+                return shouldDiscard;\n+            }\n+        };\n+    }\n+\n+    public void processStatusMessage(StatusMessage msg, LightPeer lightPeer, ChannelHandlerContext ctx, LightClientHandler lightClientHandler) {\n+        LightStatus status = msg.getStatus();\n+        try {\n+            String bestHashLog = HashUtil.shortHash(status.getBestHash());\n+            loggerNet.debug(\"Receiving Status - block {} {}\", status.getBestNumber(), bestHashLog);\n+\n+            byte protocolVersion = status.getProtocolVersion();\n+            if (protocolVersion != version) {\n+                loggerNet.info(\"Removing LCHandler for {} due to protocol incompatibility\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Protocol version {} - message protocol version {}\",\n+                        version,\n+                        protocolVersion);\n+                lightPeer.disconnect(ReasonCode.INCOMPATIBLE_PROTOCOL);\n+                ctx.pipeline().remove(lightClientHandler); // Peer is not compatible for the 'lc' sub-protocol\n+                return;\n+            }\n+\n+            int networkId = config.networkId();\n+            int msgNetworkId = status.getNetworkId();\n+            if (msgNetworkId != networkId) {\n+                loggerNet.info(\"Removing LCHandler for {} due to invalid network\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Different network received: config network ID {} - message network ID {}\",\n+                        networkId, msgNetworkId);\n+                lightPeer.disconnect(ReasonCode.NULL_IDENTITY);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+\n+            Keccak256 genesisHash = genesis.getHash();\n+            Keccak256 msgGenesisHash = new Keccak256(status.getGenesisHash());\n+            if (!msgGenesisHash.equals(genesisHash)) {\n+                loggerNet.info(\"Removing LCHandler for {} due to unexpected genesis\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Config genesis hash {} - message genesis hash {}\",\n+                        genesisHash, msgGenesisHash);\n+                lightPeer.disconnect(ReasonCode.UNEXPECTED_GENESIS);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+        } catch (NoSuchElementException e) {\n+            loggerNet.debug(\"LCHandler already removed - exception: {}\", e.getMessage());\n+        }\n+\n+        if (peerStatuses.size() >= MAX_PEER_CONNECTIONS) {\n+            return;\n+        }\n+\n+        if (!hasLowerDifficulty(status)) {\n+            return;\n+        }\n+\n+        peerStatuses.put(lightPeer, status);\n+\n+        if (msg.isTxRelay()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzg4Mw=="}, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjQxNDE5OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzoxMjo1MVrOGbU9hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOToxMzozNlrOGcC9OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwODE2NQ==", "bodyText": "hasTxRelay should have a @VisibleForTesting annotation, or similar. Because it is a method ONLY for testing", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431308165", "createdAt": "2020-05-27T17:12:51Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.BlockDifficulty;\n+import co.rsk.core.bc.BlockChainStatus;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.eth.LightClientHandler;\n+import co.rsk.net.light.message.GetBlockHeaderMessage;\n+import co.rsk.net.light.message.StatusMessage;\n+import io.netty.channel.ChannelHandlerContext;\n+import org.ethereum.config.SystemProperties;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.Genesis;\n+import org.ethereum.crypto.HashUtil;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.net.message.ReasonCode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.*;\n+\n+\n+public class LightSyncProcessor {\n+\n+    private static final int MAX_PENDING_MESSAGES = 1;\n+    private static final int MAX_PEER_CONNECTIONS = 1;\n+    private SystemProperties config;\n+    private final Genesis genesis;\n+    private final BlockStore blockStore;\n+    private Blockchain blockchain;\n+    private final byte version;\n+    private static final Logger loggerNet = LoggerFactory.getLogger(\"lightnet\");\n+    private Map<LightPeer, LightStatus> peerStatuses = new HashMap<>();\n+    private Map<LightPeer, Boolean> txRelay = new HashMap<>();\n+    private long lastRequestedId;\n+    private final Map<Long, LightClientMessageCodes> pendingMessages;\n+\n+\n+    public LightSyncProcessor(SystemProperties config, Genesis genesis, BlockStore blockStore, Blockchain blockchain) {\n+        this.config = config;\n+        this.genesis = genesis;\n+        this.blockStore = blockStore;\n+        this.blockchain = blockchain;\n+        this.version = (byte) 0;\n+        this.pendingMessages = new LinkedHashMap<Long, LightClientMessageCodes>() {\n+            @Override\n+            protected boolean removeEldestEntry(Map.Entry<Long, LightClientMessageCodes> eldest) {\n+                boolean shouldDiscard = size() > MAX_PENDING_MESSAGES;\n+                if (shouldDiscard) {\n+                    loggerNet.trace(\"Pending {}@{} DISCARDED\", eldest.getValue(), eldest.getKey());\n+                }\n+                return shouldDiscard;\n+            }\n+        };\n+    }\n+\n+    public void processStatusMessage(StatusMessage msg, LightPeer lightPeer, ChannelHandlerContext ctx, LightClientHandler lightClientHandler) {\n+        LightStatus status = msg.getStatus();\n+        try {\n+            String bestHashLog = HashUtil.shortHash(status.getBestHash());\n+            loggerNet.debug(\"Receiving Status - block {} {}\", status.getBestNumber(), bestHashLog);\n+\n+            byte protocolVersion = status.getProtocolVersion();\n+            if (protocolVersion != version) {\n+                loggerNet.info(\"Removing LCHandler for {} due to protocol incompatibility\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Protocol version {} - message protocol version {}\",\n+                        version,\n+                        protocolVersion);\n+                lightPeer.disconnect(ReasonCode.INCOMPATIBLE_PROTOCOL);\n+                ctx.pipeline().remove(lightClientHandler); // Peer is not compatible for the 'lc' sub-protocol\n+                return;\n+            }\n+\n+            int networkId = config.networkId();\n+            int msgNetworkId = status.getNetworkId();\n+            if (msgNetworkId != networkId) {\n+                loggerNet.info(\"Removing LCHandler for {} due to invalid network\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Different network received: config network ID {} - message network ID {}\",\n+                        networkId, msgNetworkId);\n+                lightPeer.disconnect(ReasonCode.NULL_IDENTITY);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+\n+            Keccak256 genesisHash = genesis.getHash();\n+            Keccak256 msgGenesisHash = new Keccak256(status.getGenesisHash());\n+            if (!msgGenesisHash.equals(genesisHash)) {\n+                loggerNet.info(\"Removing LCHandler for {} due to unexpected genesis\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Config genesis hash {} - message genesis hash {}\",\n+                        genesisHash, msgGenesisHash);\n+                lightPeer.disconnect(ReasonCode.UNEXPECTED_GENESIS);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+        } catch (NoSuchElementException e) {\n+            loggerNet.debug(\"LCHandler already removed - exception: {}\", e.getMessage());\n+        }\n+\n+        if (peerStatuses.size() >= MAX_PEER_CONNECTIONS) {\n+            return;\n+        }\n+\n+        if (!hasLowerDifficulty(status)) {\n+            return;\n+        }\n+\n+        peerStatuses.put(lightPeer, status);\n+\n+        if (msg.isTxRelay()) {\n+            txRelay.put(lightPeer, true);\n+        }\n+\n+        byte[] bestBlockHash = status.getBestHash();\n+        GetBlockHeaderMessage blockHeaderMessage = new GetBlockHeaderMessage(++lastRequestedId, bestBlockHash);\n+        pendingMessages.put(lastRequestedId, BLOCK_HEADER);\n+        lightPeer.sendMessage(blockHeaderMessage);\n+    }\n+\n+    public void sendStatusMessage(LightPeer lightPeer) {\n+        Block block = blockStore.getBestBlock();\n+        LightStatus status = getCurrentStatus(block);\n+        StatusMessage statusMessage = new StatusMessage(0L, status, false);\n+\n+        lightPeer.sendMessage(statusMessage);\n+\n+        loggerNet.trace(\"Sending status best block {} to {}\",\n+                block.getNumber(), lightPeer.getPeerIdShort());\n+    }\n+\n+    public void processBlockHeaderMessage(long id, BlockHeader blockHeader, LightPeer lightPeer) {\n+        if (!isPending(id, BLOCK_HEADER)) {\n+            return;\n+        }\n+\n+        pendingMessages.remove(id, BLOCK_HEADER);\n+        lightPeer.receivedBlock(blockHeader);\n+    }\n+\n+    public boolean hasTxRelay(LightPeer peer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MTc1Mw==", "bodyText": "At this moment, it should be visible for testing, right.", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r432061753", "createdAt": "2020-05-28T19:13:36Z", "author": {"login": "julianlen"}, "path": "rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.BlockDifficulty;\n+import co.rsk.core.bc.BlockChainStatus;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.eth.LightClientHandler;\n+import co.rsk.net.light.message.GetBlockHeaderMessage;\n+import co.rsk.net.light.message.StatusMessage;\n+import io.netty.channel.ChannelHandlerContext;\n+import org.ethereum.config.SystemProperties;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.Genesis;\n+import org.ethereum.crypto.HashUtil;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.net.message.ReasonCode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.*;\n+\n+\n+public class LightSyncProcessor {\n+\n+    private static final int MAX_PENDING_MESSAGES = 1;\n+    private static final int MAX_PEER_CONNECTIONS = 1;\n+    private SystemProperties config;\n+    private final Genesis genesis;\n+    private final BlockStore blockStore;\n+    private Blockchain blockchain;\n+    private final byte version;\n+    private static final Logger loggerNet = LoggerFactory.getLogger(\"lightnet\");\n+    private Map<LightPeer, LightStatus> peerStatuses = new HashMap<>();\n+    private Map<LightPeer, Boolean> txRelay = new HashMap<>();\n+    private long lastRequestedId;\n+    private final Map<Long, LightClientMessageCodes> pendingMessages;\n+\n+\n+    public LightSyncProcessor(SystemProperties config, Genesis genesis, BlockStore blockStore, Blockchain blockchain) {\n+        this.config = config;\n+        this.genesis = genesis;\n+        this.blockStore = blockStore;\n+        this.blockchain = blockchain;\n+        this.version = (byte) 0;\n+        this.pendingMessages = new LinkedHashMap<Long, LightClientMessageCodes>() {\n+            @Override\n+            protected boolean removeEldestEntry(Map.Entry<Long, LightClientMessageCodes> eldest) {\n+                boolean shouldDiscard = size() > MAX_PENDING_MESSAGES;\n+                if (shouldDiscard) {\n+                    loggerNet.trace(\"Pending {}@{} DISCARDED\", eldest.getValue(), eldest.getKey());\n+                }\n+                return shouldDiscard;\n+            }\n+        };\n+    }\n+\n+    public void processStatusMessage(StatusMessage msg, LightPeer lightPeer, ChannelHandlerContext ctx, LightClientHandler lightClientHandler) {\n+        LightStatus status = msg.getStatus();\n+        try {\n+            String bestHashLog = HashUtil.shortHash(status.getBestHash());\n+            loggerNet.debug(\"Receiving Status - block {} {}\", status.getBestNumber(), bestHashLog);\n+\n+            byte protocolVersion = status.getProtocolVersion();\n+            if (protocolVersion != version) {\n+                loggerNet.info(\"Removing LCHandler for {} due to protocol incompatibility\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Protocol version {} - message protocol version {}\",\n+                        version,\n+                        protocolVersion);\n+                lightPeer.disconnect(ReasonCode.INCOMPATIBLE_PROTOCOL);\n+                ctx.pipeline().remove(lightClientHandler); // Peer is not compatible for the 'lc' sub-protocol\n+                return;\n+            }\n+\n+            int networkId = config.networkId();\n+            int msgNetworkId = status.getNetworkId();\n+            if (msgNetworkId != networkId) {\n+                loggerNet.info(\"Removing LCHandler for {} due to invalid network\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Different network received: config network ID {} - message network ID {}\",\n+                        networkId, msgNetworkId);\n+                lightPeer.disconnect(ReasonCode.NULL_IDENTITY);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+\n+            Keccak256 genesisHash = genesis.getHash();\n+            Keccak256 msgGenesisHash = new Keccak256(status.getGenesisHash());\n+            if (!msgGenesisHash.equals(genesisHash)) {\n+                loggerNet.info(\"Removing LCHandler for {} due to unexpected genesis\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Config genesis hash {} - message genesis hash {}\",\n+                        genesisHash, msgGenesisHash);\n+                lightPeer.disconnect(ReasonCode.UNEXPECTED_GENESIS);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+        } catch (NoSuchElementException e) {\n+            loggerNet.debug(\"LCHandler already removed - exception: {}\", e.getMessage());\n+        }\n+\n+        if (peerStatuses.size() >= MAX_PEER_CONNECTIONS) {\n+            return;\n+        }\n+\n+        if (!hasLowerDifficulty(status)) {\n+            return;\n+        }\n+\n+        peerStatuses.put(lightPeer, status);\n+\n+        if (msg.isTxRelay()) {\n+            txRelay.put(lightPeer, true);\n+        }\n+\n+        byte[] bestBlockHash = status.getBestHash();\n+        GetBlockHeaderMessage blockHeaderMessage = new GetBlockHeaderMessage(++lastRequestedId, bestBlockHash);\n+        pendingMessages.put(lastRequestedId, BLOCK_HEADER);\n+        lightPeer.sendMessage(blockHeaderMessage);\n+    }\n+\n+    public void sendStatusMessage(LightPeer lightPeer) {\n+        Block block = blockStore.getBestBlock();\n+        LightStatus status = getCurrentStatus(block);\n+        StatusMessage statusMessage = new StatusMessage(0L, status, false);\n+\n+        lightPeer.sendMessage(statusMessage);\n+\n+        loggerNet.trace(\"Sending status best block {} to {}\",\n+                block.getNumber(), lightPeer.getPeerIdShort());\n+    }\n+\n+    public void processBlockHeaderMessage(long id, BlockHeader blockHeader, LightPeer lightPeer) {\n+        if (!isPending(id, BLOCK_HEADER)) {\n+            return;\n+        }\n+\n+        pendingMessages.remove(id, BLOCK_HEADER);\n+        lightPeer.receivedBlock(blockHeader);\n+    }\n+\n+    public boolean hasTxRelay(LightPeer peer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwODE2NQ=="}, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjQxNjY1OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/org/ethereum/config/SystemProperties.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzoxMzozM1rOGbU_Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMjo1NzoxNVrOGbz01A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwODU1OQ==", "bodyText": "To ask for the presence is a pattern that reoccurs through the code, but it is bad pattern: this should be set in reference.conf, that assures that the value can never be null. Besides that, lc should not be a default", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431308559", "createdAt": "2020-05-27T17:13:33Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/org/ethereum/config/SystemProperties.java", "diffHunk": "@@ -318,7 +318,7 @@ public String helloPhrase() {\n     }\n \n     public List<String> peerCapabilities() {\n-        return configFromFiles.hasPath(\"peer.capabilities\") ?  configFromFiles.getStringList(\"peer.capabilities\") : new ArrayList<>(Arrays.asList(\"rsk\"));\n+        return configFromFiles.hasPath(\"peer.capabilities\") ?  configFromFiles.getStringList(\"peer.capabilities\") : new ArrayList<>(Arrays.asList(\"rsk\",\"lc\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgxMzg0NA==", "bodyText": "We will check that (the pattern).\nOn the other hand, the Light Client capability should be a default. By default any full node should serve Light Clients, removing it will cause that no Full Node will serve them.\nI think the root of this problem is the bad way that defaults and config settings are handled in general in the code.", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431813844", "createdAt": "2020-05-28T12:57:15Z", "author": {"login": "smcsicardi"}, "path": "rskj-core/src/main/java/org/ethereum/config/SystemProperties.java", "diffHunk": "@@ -318,7 +318,7 @@ public String helloPhrase() {\n     }\n \n     public List<String> peerCapabilities() {\n-        return configFromFiles.hasPath(\"peer.capabilities\") ?  configFromFiles.getStringList(\"peer.capabilities\") : new ArrayList<>(Arrays.asList(\"rsk\"));\n+        return configFromFiles.hasPath(\"peer.capabilities\") ?  configFromFiles.getStringList(\"peer.capabilities\") : new ArrayList<>(Arrays.asList(\"rsk\",\"lc\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwODU1OQ=="}, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjQyMTQ4OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/net/LightProcessorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzoxNDo1OVrOGbVCNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzoxNDo1OVrOGbVCNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwOTM2NA==", "bodyText": "Like ajl says on his blog https://blogs.msmvps.com/lopez/2012/08/09/tdd-unit-tests-and-mocks/ it's undesirable to mock so much when testing. Ideally, we should have factories to build these objects for us, it is a strong smell to resort to mock all these classes, especially domain classes like Block and Transaction, since it's not exactly the external, unpredictable world the one we're mocking.\nThere is a BlockBuilder class for this, it might be a bit unwieldy for the purposes of this test, but I think it merits trying to make efforts in order to make non mocking tests easy to code.", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431309364", "createdAt": "2020-05-27T17:14:59Z", "author": {"login": "nicops"}, "path": "rskj-core/src/test/java/co/rsk/net/LightProcessorTest.java", "diffHunk": "@@ -0,0 +1,412 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.core.Coin;\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.net.light.LightPeer;\n+import co.rsk.net.light.LightProcessor;\n+import co.rsk.net.light.message.*;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.core.*;\n+import org.ethereum.crypto.HashUtil;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.net.MessageQueue;\n+import org.ethereum.net.server.Channel;\n+import org.ethereum.vm.DataWord;\n+import org.ethereum.vm.LogInfo;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static org.ethereum.TestUtils.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.mockito.ArgumentCaptor.forClass;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 20/10/19.\n+ */\n+public class LightProcessorTest {\n+\n+    private static final byte[] HASH_1 = HashUtil.sha256(new byte[]{1});\n+\n+    private Blockchain blockchain;\n+    private BlockStore blockStore;\n+    private LightProcessor lightProcessor;\n+    private MessageQueue msgQueue;\n+    private Keccak256 blockHash;\n+    private RepositoryLocator repositoryLocator;\n+    private LightPeer lightPeer;\n+\n+    @Before\n+    public void setup(){\n+        blockchain = mock(Blockchain.class);\n+        blockStore = mock(BlockStore.class);\n+        repositoryLocator = mock(RepositoryLocator.class);\n+        lightProcessor = new LightProcessor(blockchain, blockStore, repositoryLocator);\n+        msgQueue = spy(MessageQueue.class);\n+        blockHash = new Keccak256(HASH_1);\n+        lightPeer = new LightPeer(mock(Channel.class), msgQueue);\n+    }\n+\n+    @Test\n+    public void processGetBlockReceiptMessageAndShouldReturnsReceiptsCorrectly() {\n+        List<Transaction> txs = new LinkedList<>();\n+        long requestId = 0;\n+        List<TransactionReceipt> receipts = new LinkedList<>();\n+        TransactionReceipt receipt = createReceipt();\n+        receipts.add(receipt);\n+        final Block block = mock(Block.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9527f250d51cca20e951ef97762b428c2886d"}, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4573, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}