{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4Mjg0MTU5", "number": 1378, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNjoyNToxMFrOFGR8ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNjozMTozMVrOFGSJvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMTI5ODAyOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/PeginInformation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNjoyNToxMFrOIHN2wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNjoyNToxMFrOIHN2wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQzNzk1Mg==", "bodyText": "We might want to prevent addresses like the federation here. Not a big deal, but would just waste resources", "url": "https://github.com/rsksmart/rskj/pull/1378#discussion_r544437952", "createdAt": "2020-12-16T16:25:10Z", "author": {"login": "donequis"}, "path": "rskj-core/src/main/java/co/rsk/peg/PeginInformation.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package co.rsk.peg;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.core.RskAddress;\n+import co.rsk.peg.btcLockSender.BtcLockSender;\n+import co.rsk.peg.btcLockSender.BtcLockSender.TxSenderAddressType;\n+import co.rsk.peg.btcLockSender.BtcLockSenderProvider;\n+import co.rsk.peg.pegininstructions.PeginInstructions;\n+import co.rsk.peg.pegininstructions.PeginInstructionsException;\n+import co.rsk.peg.pegininstructions.PeginInstructionsProvider;\n+import co.rsk.peg.pegininstructions.PeginInstructionsVersion1;\n+import java.util.Optional;\n+import org.ethereum.config.blockchain.upgrades.ActivationConfig;\n+import org.ethereum.config.blockchain.upgrades.ConsensusRule;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInformation {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInformation.class);\n+\n+    private final BtcLockSenderProvider btcLockSenderProvider;\n+    private final PeginInstructionsProvider peginInstructionsProvider;\n+    private final ActivationConfig.ForBlock activations;\n+\n+    private int protocolVersion;\n+    private RskAddress rskDestinationAddress;\n+    private Address btcRefundAddress;\n+    private Address senderBtcAddress;\n+    private TxSenderAddressType senderBtcAddressType;\n+\n+    public PeginInformation(\n+        BtcLockSenderProvider btcLockSenderProvider,\n+        PeginInstructionsProvider peginInstructionsProvider,\n+        ActivationConfig.ForBlock activations) {\n+        this.btcLockSenderProvider = btcLockSenderProvider;\n+        this.peginInstructionsProvider = peginInstructionsProvider;\n+        this.activations = activations;\n+        this.protocolVersion = -1; // Set an invalid value by default\n+        this.senderBtcAddressType = TxSenderAddressType.UNKNOWN;\n+    }\n+\n+    public int getProtocolVersion() {\n+        return protocolVersion;\n+    }\n+\n+    public RskAddress getRskDestinationAddress() {\n+        return this.rskDestinationAddress;\n+    }\n+\n+    public Address getBtcRefundAddress() {\n+        return this.btcRefundAddress;\n+    }\n+\n+    public Address getSenderBtcAddress() {\n+        return this.senderBtcAddress;\n+    }\n+\n+    public TxSenderAddressType getSenderBtcAddressType() {\n+        return this.senderBtcAddressType;\n+    }\n+\n+    public void parse(BtcTransaction btcTx) throws PeginInstructionsException {\n+        logger.trace(\"[parse] Trying to parse peg-in information from btc tx {}\", btcTx.getHash());\n+\n+        // Get information from tx sender first\n+        Optional<BtcLockSender> btcLockSenderOptional = btcLockSenderProvider.tryGetBtcLockSender(btcTx);\n+        if (btcLockSenderOptional.isPresent()) {\n+            BtcLockSender btcLockSender = btcLockSenderOptional.get();\n+            parseFromBtcLockSender(btcLockSender);\n+        }\n+\n+        // If HF is active and peg-in instructions were provided then override the info obtained from BtcLockSender\n+        Optional<PeginInstructions> peginInstructionsOptional = Optional.empty();\n+        if (activations.isActive(ConsensusRule.RSKIP170)) {\n+            peginInstructionsOptional = peginInstructionsProvider.buildPeginInstructions(btcTx);\n+            if (peginInstructionsOptional.isPresent()) {\n+                PeginInstructions peginInstructions = peginInstructionsOptional.get();\n+                parseFromPeginInstructions(peginInstructions);\n+            }\n+        }\n+\n+        // If BtcLockSender could not be parsed and peg-in instructions were not provided, then this tx can't be processed\n+        if(!btcLockSenderOptional.isPresent() && !peginInstructionsOptional.isPresent()) {\n+            String message = String.format(\"Could not get peg-in information for tx %s\", btcTx.getHash());\n+            logger.warn(\"[parse] {}\", message);\n+            throw new PeginInstructionsException(message);\n+        }\n+    }\n+\n+    private void parseFromBtcLockSender(BtcLockSender btcLockSender) {\n+        this.protocolVersion = 0;\n+        this.rskDestinationAddress = btcLockSender.getRskAddress();\n+        this.btcRefundAddress = btcLockSender.getBTCAddress();\n+        this.senderBtcAddress = btcLockSender.getBTCAddress();\n+        this.senderBtcAddressType = btcLockSender.getTxSenderAddressType();\n+\n+        logger.trace(\"[parseFromBtcLockSender] Protocol version: {}\", this.protocolVersion);\n+        logger.trace(\"[parseFromBtcLockSender] RSK destination address: {}\", btcLockSender.getRskAddress());\n+        logger.trace(\"[parseFromBtcLockSender] BTC refund address: {}\", btcLockSender.getBTCAddress());\n+        logger.trace(\"[parseFromBtcLockSender] Sender BTC address: {}\", btcLockSender.getBTCAddress());\n+        logger.trace(\"[parseFromBtcLockSender] Sender BTC address type: {}\", btcLockSender.getTxSenderAddressType());\n+    }\n+\n+    private void parseFromPeginInstructions(PeginInstructions peginInstructions)  throws PeginInstructionsException {\n+        this.protocolVersion = peginInstructions.getProtocolVersion();\n+        this.rskDestinationAddress = peginInstructions.getRskDestinationAddress();\n+        logger.trace(\"[parseFromPeginInstructions] Protocol version: {}\", peginInstructions.getProtocolVersion());\n+        logger.trace(\"[parseFromPeginInstructions] RSK destination address: {}\", peginInstructions.getRskDestinationAddress());\n+\n+        switch (protocolVersion) {\n+            case 1:\n+                PeginInstructionsVersion1 peginInstructionsV1 = (PeginInstructionsVersion1) peginInstructions;\n+                parseFromPeginInstructionsVersion1(peginInstructionsV1);\n+                break;\n+            default:\n+                String message = String.format(\"Invalid protocol version: %d\", protocolVersion);\n+                logger.warn(\"[parseFromPeginInstructions] {}\", message);\n+                throw new PeginInstructionsException(message);\n+        }\n+    }\n+\n+    private void parseFromPeginInstructionsVersion1(PeginInstructionsVersion1 peginInstructions) {\n+        Optional<Address> btcRefundAddressOptional = peginInstructions.getBtcRefundAddress();\n+        if (btcRefundAddressOptional.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8acfdb2939fc035701a6158362dd64b5f597b097"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMTMyNzIzOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/PeginInformation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNjozMDozOFrOIHOHyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNjozMDozOFrOIHOHyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ0MjMxNQ==", "bodyText": "I could be wrong on this, but I feel that we have an unexpected change in consensus here.\nIf we send a transaction from a wp2pkh without presenting the witness, before the activation of the rskip170, it used to reject the transaction and send the money back because with no sender the transaction wouldn't be lockeable, but now it does not seem to send the money back. Or, in general, non lockeable transaction because there's no sending, before rskip170 used to generate a rejection release while it does not happen anymore.", "url": "https://github.com/rsksmart/rskj/pull/1378#discussion_r544442315", "createdAt": "2020-12-16T16:30:38Z", "author": {"login": "donequis"}, "path": "rskj-core/src/main/java/co/rsk/peg/PeginInformation.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package co.rsk.peg;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.core.RskAddress;\n+import co.rsk.peg.btcLockSender.BtcLockSender;\n+import co.rsk.peg.btcLockSender.BtcLockSender.TxSenderAddressType;\n+import co.rsk.peg.btcLockSender.BtcLockSenderProvider;\n+import co.rsk.peg.pegininstructions.PeginInstructions;\n+import co.rsk.peg.pegininstructions.PeginInstructionsException;\n+import co.rsk.peg.pegininstructions.PeginInstructionsProvider;\n+import co.rsk.peg.pegininstructions.PeginInstructionsVersion1;\n+import java.util.Optional;\n+import org.ethereum.config.blockchain.upgrades.ActivationConfig;\n+import org.ethereum.config.blockchain.upgrades.ConsensusRule;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInformation {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInformation.class);\n+\n+    private final BtcLockSenderProvider btcLockSenderProvider;\n+    private final PeginInstructionsProvider peginInstructionsProvider;\n+    private final ActivationConfig.ForBlock activations;\n+\n+    private int protocolVersion;\n+    private RskAddress rskDestinationAddress;\n+    private Address btcRefundAddress;\n+    private Address senderBtcAddress;\n+    private TxSenderAddressType senderBtcAddressType;\n+\n+    public PeginInformation(\n+        BtcLockSenderProvider btcLockSenderProvider,\n+        PeginInstructionsProvider peginInstructionsProvider,\n+        ActivationConfig.ForBlock activations) {\n+        this.btcLockSenderProvider = btcLockSenderProvider;\n+        this.peginInstructionsProvider = peginInstructionsProvider;\n+        this.activations = activations;\n+        this.protocolVersion = -1; // Set an invalid value by default\n+        this.senderBtcAddressType = TxSenderAddressType.UNKNOWN;\n+    }\n+\n+    public int getProtocolVersion() {\n+        return protocolVersion;\n+    }\n+\n+    public RskAddress getRskDestinationAddress() {\n+        return this.rskDestinationAddress;\n+    }\n+\n+    public Address getBtcRefundAddress() {\n+        return this.btcRefundAddress;\n+    }\n+\n+    public Address getSenderBtcAddress() {\n+        return this.senderBtcAddress;\n+    }\n+\n+    public TxSenderAddressType getSenderBtcAddressType() {\n+        return this.senderBtcAddressType;\n+    }\n+\n+    public void parse(BtcTransaction btcTx) throws PeginInstructionsException {\n+        logger.trace(\"[parse] Trying to parse peg-in information from btc tx {}\", btcTx.getHash());\n+\n+        // Get information from tx sender first\n+        Optional<BtcLockSender> btcLockSenderOptional = btcLockSenderProvider.tryGetBtcLockSender(btcTx);\n+        if (btcLockSenderOptional.isPresent()) {\n+            BtcLockSender btcLockSender = btcLockSenderOptional.get();\n+            parseFromBtcLockSender(btcLockSender);\n+        }\n+\n+        // If HF is active and peg-in instructions were provided then override the info obtained from BtcLockSender\n+        Optional<PeginInstructions> peginInstructionsOptional = Optional.empty();\n+        if (activations.isActive(ConsensusRule.RSKIP170)) {\n+            peginInstructionsOptional = peginInstructionsProvider.buildPeginInstructions(btcTx);\n+            if (peginInstructionsOptional.isPresent()) {\n+                PeginInstructions peginInstructions = peginInstructionsOptional.get();\n+                parseFromPeginInstructions(peginInstructions);\n+            }\n+        }\n+\n+        // If BtcLockSender could not be parsed and peg-in instructions were not provided, then this tx can't be processed\n+        if(!btcLockSenderOptional.isPresent() && !peginInstructionsOptional.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8acfdb2939fc035701a6158362dd64b5f597b097"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMTMzMTgzOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNjozMTozMVrOIHOKgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNjozMTozMVrOIHOKgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ0MzAxMQ==", "bodyText": "Here: refund is only created when there's a pegininstructionexception only after the rskip170 activation", "url": "https://github.com/rsksmart/rskj/pull/1378#discussion_r544443011", "createdAt": "2020-12-16T16:31:31Z", "author": {"login": "donequis"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -328,52 +338,148 @@ protected TxType getTransactionType(BtcTransaction btcTx) {\n         return TxType.UNKNOWN;\n     }\n \n-    protected void processPegIn(BtcTransaction btcTx, Transaction rskTx, int height, Sha256Hash btcTxHash)\n-            throws IOException, RegisterBtcTransactionException {\n+    protected void processPegIn(\n+        BtcTransaction btcTx,\n+        Transaction rskTx,\n+        int height,\n+        Sha256Hash btcTxHash) throws IOException, RegisterBtcTransactionException {\n+\n         logger.debug(\"[processPegIn] This is a lock tx {}\", btcTx);\n-        Optional<BtcLockSender> btcLockSenderOptional = btcLockSenderProvider.tryGetBtcLockSender(btcTx);\n-        if (!btcLockSenderOptional.isPresent() ||\n-                !BridgeUtils.txIsProcessable(btcLockSenderOptional.get().getType(), activations)) {\n-            logger.warn(\"[processPegIn] [btcTx:{}] Could not get BtcLockSender from Btc tx\", btcTx.getHash());\n-            throw new RegisterBtcTransactionException(\"Could not get BtcLockSender from Btc tx\");\n+\n+        Coin totalAmount = computeTotalAmountSent(btcTx);\n+\n+        PeginInformation peginInformation = new PeginInformation(\n+            btcLockSenderProvider,\n+            peginInstructionsProvider,\n+            activations\n+        );\n+        try {\n+            peginInformation.parse(btcTx);\n+        } catch (PeginInstructionsException e) {\n+            if (activations.isActive(ConsensusRule.RSKIP170)) {\n+                // If possible to get the sender address, refund\n+                refundTxSender(btcTx, rskTx, peginInformation, totalAmount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8acfdb2939fc035701a6158362dd64b5f597b097"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4400, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}