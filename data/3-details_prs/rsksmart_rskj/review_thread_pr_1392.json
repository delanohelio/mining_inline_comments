{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5NTk3MTE3", "number": 1392, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjo1MDo1NFrOFFkj7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDozMjo1OVrOFJyXFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMzg2MjIxOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/org/ethereum/config/blockchain/upgrades/ConsensusRule.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjo1MDo1NFrOIGJUEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxODozNzozOVrOIHTo8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMxNDk2MA==", "bodyText": "Could we write the improvement proposal?", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r543314960", "createdAt": "2020-12-15T12:50:54Z", "author": {"login": "ajlopezrsk"}, "path": "rskj-core/src/main/java/org/ethereum/config/blockchain/upgrades/ConsensusRule.java", "diffHunk": "@@ -55,7 +55,9 @@\n     RSKIP172(\"rskip172\"),\n     RSKIP174(\"rskip174\"),\n     RSKIP180(\"rskip180\"),\n-    RSKIPUMM(\"rskipUMM\");\n+    RSKIPUMM(\"rskipUMM\"),\n+    // TODO: change activation code RSKIPNEW.\n+    RSKIPNEW(\"rskipNEW\"); //Handle error in Precompile Contracts execution.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9d458623d4d381b3650f6681bf536f3485b8336"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUxOTgzMA==", "bodyText": "We are on it :)", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r543519830", "createdAt": "2020-12-15T16:59:34Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/org/ethereum/config/blockchain/upgrades/ConsensusRule.java", "diffHunk": "@@ -55,7 +55,9 @@\n     RSKIP172(\"rskip172\"),\n     RSKIP174(\"rskip174\"),\n     RSKIP180(\"rskip180\"),\n-    RSKIPUMM(\"rskipUMM\");\n+    RSKIPUMM(\"rskipUMM\"),\n+    // TODO: change activation code RSKIPNEW.\n+    RSKIPNEW(\"rskipNEW\"); //Handle error in Precompile Contracts execution.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMxNDk2MA=="}, "originalCommit": {"oid": "e9d458623d4d381b3650f6681bf536f3485b8336"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU2NTc1Mw==", "bodyText": "rsksmart/RSKIPs#197", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r543565753", "createdAt": "2020-12-15T18:01:15Z", "author": {"login": "fedejinich"}, "path": "rskj-core/src/main/java/org/ethereum/config/blockchain/upgrades/ConsensusRule.java", "diffHunk": "@@ -55,7 +55,9 @@\n     RSKIP172(\"rskip172\"),\n     RSKIP174(\"rskip174\"),\n     RSKIP180(\"rskip180\"),\n-    RSKIPUMM(\"rskipUMM\");\n+    RSKIPUMM(\"rskipUMM\"),\n+    // TODO: change activation code RSKIPNEW.\n+    RSKIPNEW(\"rskipNEW\"); //Handle error in Precompile Contracts execution.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMxNDk2MA=="}, "originalCommit": {"oid": "e9d458623d4d381b3650f6681bf536f3485b8336"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDUzMjcyMQ==", "bodyText": "11d5f36 renamed", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r544532721", "createdAt": "2020-12-16T18:37:39Z", "author": {"login": "fedejinich"}, "path": "rskj-core/src/main/java/org/ethereum/config/blockchain/upgrades/ConsensusRule.java", "diffHunk": "@@ -55,7 +55,9 @@\n     RSKIP172(\"rskip172\"),\n     RSKIP174(\"rskip174\"),\n     RSKIP180(\"rskip180\"),\n-    RSKIPUMM(\"rskipUMM\");\n+    RSKIPUMM(\"rskipUMM\"),\n+    // TODO: change activation code RSKIPNEW.\n+    RSKIPNEW(\"rskipNEW\"); //Handle error in Precompile Contracts execution.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMxNDk2MA=="}, "originalCommit": {"oid": "e9d458623d4d381b3650f6681bf536f3485b8336"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMzg4MDYzOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/org/ethereum/core/TransactionExecutor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjo1NDo1NVrOIGJepw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjo1NDo1NVrOIGJepw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMxNzY3MQ==", "bodyText": "Why not to process these exceptions in TWO catch? And instead of PrecompiledContractException catch ExecutionException or something similar. So we could manage RuntimeException ONLY when the fork is NOT yet activated. Maybe you consider the case as out of scope, but it could be nice to have the RuntimeException removed from execution.", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r543317671", "createdAt": "2020-12-15T12:54:55Z", "author": {"login": "ajlopezrsk"}, "path": "rskj-core/src/main/java/org/ethereum/core/TransactionExecutor.java", "diffHunk": "@@ -340,7 +341,7 @@ private void call() {\n                 } else if (!track.isContract(targetAddress)) {\n                     track.setupContract(targetAddress);\n                 }\n-            } catch (RuntimeException e) {\n+            } catch (PrecompiledContractException | RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9d458623d4d381b3650f6681bf536f3485b8336"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMzkxNDY2OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/org/ethereum/vm/program/Program.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMzowMjoyOFrOIGJyKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNzo1ODozN1rOIGYghA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMyMjY2Ng==", "bodyText": "No PrecompiledContractException throws? Why?", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r543322666", "createdAt": "2020-12-15T13:02:28Z", "author": {"login": "ajlopezrsk"}, "path": "rskj-core/src/main/java/org/ethereum/vm/program/Program.java", "diffHunk": "@@ -1351,7 +1349,7 @@ public int verifyBeginSub(DataWord nextPC) {\n         return ret;\n     }\n \n-    public void callToPrecompiledAddress(MessageCall msg, PrecompiledContract contract, ActivationConfig.ForBlock activations) {\n+    public void callToPrecompiledAddress(MessageCall msg, PrecompiledContract contract) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9d458623d4d381b3650f6681bf536f3485b8336"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU2MzkwOA==", "bodyText": "We wanted to keep consistency with the behaviour of \"callToAddress()\", which handles all the errors internally, it doesn't bubble up the error but push a Zero into the stack.", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r543563908", "createdAt": "2020-12-15T17:58:37Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/org/ethereum/vm/program/Program.java", "diffHunk": "@@ -1351,7 +1349,7 @@ public int verifyBeginSub(DataWord nextPC) {\n         return ret;\n     }\n \n-    public void callToPrecompiledAddress(MessageCall msg, PrecompiledContract contract, ActivationConfig.ForBlock activations) {\n+    public void callToPrecompiledAddress(MessageCall msg, PrecompiledContract contract) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMyMjY2Ng=="}, "originalCommit": {"oid": "e9d458623d4d381b3650f6681bf536f3485b8336"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMzkyMDgyOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/org/ethereum/vm/VM.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMzowMzo1NlrOIGJ1wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNzo1OTo0MlrOIGYjZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMyMzU4NQ==", "bodyText": "No treatment of PrecompiledContractException?", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r543323585", "createdAt": "2020-12-15T13:03:56Z", "author": {"login": "ajlopezrsk"}, "path": "rskj-core/src/main/java/org/ethereum/vm/VM.java", "diffHunk": "@@ -1490,9 +1490,9 @@ protected void doCALL(){\n         PrecompiledContracts.PrecompiledContract precompiledContract = precompiledContracts.getContractForAddress(activations, codeAddress);\n \n         if (precompiledContract != null) {\n-            program.callToPrecompiledAddress(msg, precompiledContract, activations);\n+            program.callToPrecompiledAddress(msg, precompiledContract);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9d458623d4d381b3650f6681bf536f3485b8336"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU2NDY0Ng==", "bodyText": "Idem as before. No need of handling here, it's made internally.", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r543564646", "createdAt": "2020-12-15T17:59:42Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/org/ethereum/vm/VM.java", "diffHunk": "@@ -1490,9 +1490,9 @@ protected void doCALL(){\n         PrecompiledContracts.PrecompiledContract precompiledContract = precompiledContracts.getContractForAddress(activations, codeAddress);\n \n         if (precompiledContract != null) {\n-            program.callToPrecompiledAddress(msg, precompiledContract, activations);\n+            program.callToPrecompiledAddress(msg, precompiledContract);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMyMzU4NQ=="}, "originalCommit": {"oid": "e9d458623d4d381b3650f6681bf536f3485b8336"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNzY5Njc5OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/performance/FederationChangeTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDoyMzowNVrOIIHWbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDoyMzowNVrOIIHWbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM3OTk1MA==", "bodyText": "?", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r545379950", "createdAt": "2020-12-17T20:23:05Z", "author": {"login": "donequis"}, "path": "rskj-core/src/test/java/co/rsk/peg/performance/FederationChangeTest.java", "diffHunk": "@@ -84,14 +87,15 @@ private void createFederation_winner(int times, ExecutionStats stats) {\n     }\n \n     @Test\n-    public void addFederatorPublicKey() {\n+    public void addFederatorPublicKey() throws VMException {\n         ExecutionStats stats = new ExecutionStats(\"addFederatorPublicKey\");\n         addFederatorPublicKey_noWinner(200, stats);\n         addFederatorPublicKey_winner(200, stats);\n         BridgePerformanceTest.addStats(stats);\n+        Assert.assertTrue(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "071b8844e895152133d68a7bffa49a46e846e396"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNzcwMDI5OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/performance/FederationChangeTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDoyMzo0OVrOIIHYiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDoyMzo0OVrOIIHYiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM4MDQ4OA==", "bodyText": "?", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r545380488", "createdAt": "2020-12-17T20:23:49Z", "author": {"login": "donequis"}, "path": "rskj-core/src/test/java/co/rsk/peg/performance/FederationChangeTest.java", "diffHunk": "@@ -119,14 +123,15 @@ private void addFederatorPublicKey_winner(int times, ExecutionStats stats) {\n     }\n \n     @Test\n-    public void commitFederation() {\n+    public void commitFederation() throws VMException {\n         ExecutionStats stats = new ExecutionStats(\"commitFederation\");\n         commitFederation_noWinner(200, stats);\n         commitFederation_winner(200, stats);\n         BridgePerformanceTest.addStats(stats);\n+        Assert.assertTrue(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "071b8844e895152133d68a7bffa49a46e846e396"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNzcwMDczOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/performance/FederationChangeTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDoyMzo1NlrOIIHYzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDoyMzo1NlrOIIHYzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM4MDU1Ng==", "bodyText": "?", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r545380556", "createdAt": "2020-12-17T20:23:56Z", "author": {"login": "donequis"}, "path": "rskj-core/src/test/java/co/rsk/peg/performance/FederationChangeTest.java", "diffHunk": "@@ -151,14 +156,15 @@ private void commitFederation_winner(int times, ExecutionStats stats) {\n     }\n \n     @Test\n-    public void rollbackFederation() {\n+    public void rollbackFederation() throws VMException {\n         ExecutionStats stats = new ExecutionStats(\"rollbackFederation\");\n         rollbackFederation_noWinner(200, stats);\n         rollbackFederation_winner(200, stats);\n         BridgePerformanceTest.addStats(stats);\n+        Assert.assertTrue(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "071b8844e895152133d68a7bffa49a46e846e396"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNzcwMzEyOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/performance/LockWhitelistTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDoyNDozNVrOIIHaRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDo0NjozN1rOIIIJHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM4MDkzMw==", "bodyText": "?", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r545380933", "createdAt": "2020-12-17T20:24:35Z", "author": {"login": "donequis"}, "path": "rskj-core/src/test/java/co/rsk/peg/performance/LockWhitelistTest.java", "diffHunk": "@@ -45,25 +47,27 @@\n     private static final ECKey authorizedWhitelistChanger = ECKey.fromPrivate(Hex.decode(\"3890187a3071327cee08467ba1b44ed4c13adb2da0d5ffcc0563c371fa88259c\"));\n \n     @Test\n-    public void getLockWhitelistSize() throws IOException {\n+    public void getLockWhitelistSize() throws IOException, VMException {\n         ExecutionStats stats = new ExecutionStats(\"getLockWhitelistSize\");\n         executeTestCase((int executionIndex) -> Bridge.GET_LOCK_WHITELIST_SIZE.encode(), \"getLockWhitelistSize\", 200, stats);\n         BridgePerformanceTest.addStats(stats);\n+        Assert.assertTrue(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "071b8844e895152133d68a7bffa49a46e846e396"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5MjkyNA==", "bodyText": "Was just for sonar not complaining... but I will change them to smthg with more sense.", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r545392924", "createdAt": "2020-12-17T20:46:37Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/test/java/co/rsk/peg/performance/LockWhitelistTest.java", "diffHunk": "@@ -45,25 +47,27 @@\n     private static final ECKey authorizedWhitelistChanger = ECKey.fromPrivate(Hex.decode(\"3890187a3071327cee08467ba1b44ed4c13adb2da0d5ffcc0563c371fa88259c\"));\n \n     @Test\n-    public void getLockWhitelistSize() throws IOException {\n+    public void getLockWhitelistSize() throws IOException, VMException {\n         ExecutionStats stats = new ExecutionStats(\"getLockWhitelistSize\");\n         executeTestCase((int executionIndex) -> Bridge.GET_LOCK_WHITELIST_SIZE.encode(), \"getLockWhitelistSize\", 200, stats);\n         BridgePerformanceTest.addStats(stats);\n+        Assert.assertTrue(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM4MDkzMw=="}, "originalCommit": {"oid": "071b8844e895152133d68a7bffa49a46e846e396"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjI5MDk2OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/org/ethereum/vm/program/Program.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDowMDoyMVrOIIxCKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxODoxMjowMVrOIJhWqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA2Mjg4OA==", "bodyText": "this if should always be true at this point, right?", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r546062888", "createdAt": "2020-12-18T20:00:21Z", "author": {"login": "fedejinich"}, "path": "rskj-core/src/main/java/org/ethereum/vm/program/Program.java", "diffHunk": "@@ -1424,28 +1425,73 @@ public void callToPrecompiledAddress(MessageCall msg, PrecompiledContract contra\n \n         long requiredGas = contract.getGasForData(data);\n         if (requiredGas > msg.getGas().longValue()) {\n-            this.refundGas(0, \"call pre-compiled\"); //matches cpp logic\n+            this.refundGas(0, CALL_PRECOMPILED_CAUSE); //matches cpp logic\n             this.stackPushZero();\n             track.rollback();\n-            this.cleanReturnDataBuffer(activations);\n+            this.cleanReturnDataBuffer();\n         } else {\n+            if (getActivations().isActive(ConsensusRule.RSKIP197)) {\n+                executePrecompiledAndHandleError(contract, msg, requiredGas, track, data);\n+            } else {\n+                executePrecompiled(contract, msg, requiredGas, track, data);\n+            }\n+        }\n+    }\n \n-            this.refundGas(msg.getGas().longValue() - requiredGas, \"call pre-compiled\");\n-\n+    /**\n+     * This is for compatibility before RSKIP197, no error handling was implemented when calling to precompiled contracts.\n+     *\n+     * This method shouldn't be modified, all new changes should go to executePrecompiledAndHandleError() method\n+     */\n+    @Deprecated\n+    private void executePrecompiled(PrecompiledContract contract, MessageCall msg, long requiredGas, Repository track, byte[] data) {\n+        try {\n+            this.refundGas(msg.getGas().longValue() - requiredGas, CALL_PRECOMPILED_CAUSE);\n             byte[] out = contract.execute(data);\n             if (getActivations().isActive(ConsensusRule.RSKIP90)) {\n                 this.returnDataBuffer = out;\n             }\n+            saveOutAfterExecution(msg, out);\n+            this.stackPushOne();\n+            track.commit();\n+        } catch (VMException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n \n-            // Avoid saving null returns to memory and limit the memory it can use.\n-            // If we're behind RSK150 activation, don't care about the null return, just save.\n-            if (getActivations().isActive(ConsensusRule.RSKIP150) && out != null) {\n-                this.memorySaveLimited(msg.getOutDataOffs().intValue(), out, msg.getOutDataSize().intValue());\n-            } else if (!getActivations().isActive(ConsensusRule.RSKIP150)) {\n-                this.memorySave(msg.getOutDataOffs().intValue(), out);\n+    /**\n+     * This is after RSKIP197, where we fix the way in which error is handled after a precompiled execution.\n+     */\n+    private void executePrecompiledAndHandleError(PrecompiledContract contract, MessageCall msg, long requiredGas, Repository track, byte[] data) {\n+        try {\n+            logger.trace(\"Executing Precompiled contract...\");\n+            byte[] out = contract.execute(data);\n+            if (getActivations().isActive(ConsensusRule.RSKIP90)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d46adbbf98326158e854c7f80388c739abf4b1"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg0NjI3Ng==", "bodyText": "Nice catch", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r546846276", "createdAt": "2020-12-21T17:53:36Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/org/ethereum/vm/program/Program.java", "diffHunk": "@@ -1424,28 +1425,73 @@ public void callToPrecompiledAddress(MessageCall msg, PrecompiledContract contra\n \n         long requiredGas = contract.getGasForData(data);\n         if (requiredGas > msg.getGas().longValue()) {\n-            this.refundGas(0, \"call pre-compiled\"); //matches cpp logic\n+            this.refundGas(0, CALL_PRECOMPILED_CAUSE); //matches cpp logic\n             this.stackPushZero();\n             track.rollback();\n-            this.cleanReturnDataBuffer(activations);\n+            this.cleanReturnDataBuffer();\n         } else {\n+            if (getActivations().isActive(ConsensusRule.RSKIP197)) {\n+                executePrecompiledAndHandleError(contract, msg, requiredGas, track, data);\n+            } else {\n+                executePrecompiled(contract, msg, requiredGas, track, data);\n+            }\n+        }\n+    }\n \n-            this.refundGas(msg.getGas().longValue() - requiredGas, \"call pre-compiled\");\n-\n+    /**\n+     * This is for compatibility before RSKIP197, no error handling was implemented when calling to precompiled contracts.\n+     *\n+     * This method shouldn't be modified, all new changes should go to executePrecompiledAndHandleError() method\n+     */\n+    @Deprecated\n+    private void executePrecompiled(PrecompiledContract contract, MessageCall msg, long requiredGas, Repository track, byte[] data) {\n+        try {\n+            this.refundGas(msg.getGas().longValue() - requiredGas, CALL_PRECOMPILED_CAUSE);\n             byte[] out = contract.execute(data);\n             if (getActivations().isActive(ConsensusRule.RSKIP90)) {\n                 this.returnDataBuffer = out;\n             }\n+            saveOutAfterExecution(msg, out);\n+            this.stackPushOne();\n+            track.commit();\n+        } catch (VMException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n \n-            // Avoid saving null returns to memory and limit the memory it can use.\n-            // If we're behind RSK150 activation, don't care about the null return, just save.\n-            if (getActivations().isActive(ConsensusRule.RSKIP150) && out != null) {\n-                this.memorySaveLimited(msg.getOutDataOffs().intValue(), out, msg.getOutDataSize().intValue());\n-            } else if (!getActivations().isActive(ConsensusRule.RSKIP150)) {\n-                this.memorySave(msg.getOutDataOffs().intValue(), out);\n+    /**\n+     * This is after RSKIP197, where we fix the way in which error is handled after a precompiled execution.\n+     */\n+    private void executePrecompiledAndHandleError(PrecompiledContract contract, MessageCall msg, long requiredGas, Repository track, byte[] data) {\n+        try {\n+            logger.trace(\"Executing Precompiled contract...\");\n+            byte[] out = contract.execute(data);\n+            if (getActivations().isActive(ConsensusRule.RSKIP90)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA2Mjg4OA=="}, "originalCommit": {"oid": "76d46adbbf98326158e854c7f80388c739abf4b1"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg1NDU3MQ==", "bodyText": "Theoretically you could have a regtest where it is false, but that doesn't make much sense really.", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r546854571", "createdAt": "2020-12-21T18:12:01Z", "author": {"login": "donequis"}, "path": "rskj-core/src/main/java/org/ethereum/vm/program/Program.java", "diffHunk": "@@ -1424,28 +1425,73 @@ public void callToPrecompiledAddress(MessageCall msg, PrecompiledContract contra\n \n         long requiredGas = contract.getGasForData(data);\n         if (requiredGas > msg.getGas().longValue()) {\n-            this.refundGas(0, \"call pre-compiled\"); //matches cpp logic\n+            this.refundGas(0, CALL_PRECOMPILED_CAUSE); //matches cpp logic\n             this.stackPushZero();\n             track.rollback();\n-            this.cleanReturnDataBuffer(activations);\n+            this.cleanReturnDataBuffer();\n         } else {\n+            if (getActivations().isActive(ConsensusRule.RSKIP197)) {\n+                executePrecompiledAndHandleError(contract, msg, requiredGas, track, data);\n+            } else {\n+                executePrecompiled(contract, msg, requiredGas, track, data);\n+            }\n+        }\n+    }\n \n-            this.refundGas(msg.getGas().longValue() - requiredGas, \"call pre-compiled\");\n-\n+    /**\n+     * This is for compatibility before RSKIP197, no error handling was implemented when calling to precompiled contracts.\n+     *\n+     * This method shouldn't be modified, all new changes should go to executePrecompiledAndHandleError() method\n+     */\n+    @Deprecated\n+    private void executePrecompiled(PrecompiledContract contract, MessageCall msg, long requiredGas, Repository track, byte[] data) {\n+        try {\n+            this.refundGas(msg.getGas().longValue() - requiredGas, CALL_PRECOMPILED_CAUSE);\n             byte[] out = contract.execute(data);\n             if (getActivations().isActive(ConsensusRule.RSKIP90)) {\n                 this.returnDataBuffer = out;\n             }\n+            saveOutAfterExecution(msg, out);\n+            this.stackPushOne();\n+            track.commit();\n+        } catch (VMException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n \n-            // Avoid saving null returns to memory and limit the memory it can use.\n-            // If we're behind RSK150 activation, don't care about the null return, just save.\n-            if (getActivations().isActive(ConsensusRule.RSKIP150) && out != null) {\n-                this.memorySaveLimited(msg.getOutDataOffs().intValue(), out, msg.getOutDataSize().intValue());\n-            } else if (!getActivations().isActive(ConsensusRule.RSKIP150)) {\n-                this.memorySave(msg.getOutDataOffs().intValue(), out);\n+    /**\n+     * This is after RSKIP197, where we fix the way in which error is handled after a precompiled execution.\n+     */\n+    private void executePrecompiledAndHandleError(PrecompiledContract contract, MessageCall msg, long requiredGas, Repository track, byte[] data) {\n+        try {\n+            logger.trace(\"Executing Precompiled contract...\");\n+            byte[] out = contract.execute(data);\n+            if (getActivations().isActive(ConsensusRule.RSKIP90)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA2Mjg4OA=="}, "originalCommit": {"oid": "76d46adbbf98326158e854c7f80388c739abf4b1"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1ODA1MTEwOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDoyNjoyMVrOIMQehA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxNDo0OToxOFrOIMuwrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyMzc4MA==", "bodyText": "Why not add the try catch internally in ensureBtcBlockStore?", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r549723780", "createdAt": "2020-12-29T14:26:21Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -1992,9 +1993,14 @@ public boolean increaseLockingCap(Transaction tx, Coin newCap) {\n         return true;\n     }\n \n-    public void registerBtcCoinbaseTransaction(byte[] btcTxSerialized, Sha256Hash blockHash, byte[] pmtSerialized, Sha256Hash witnessMerkleRoot, byte[] witnessReservedValue) throws IOException, BlockStoreException {\n+    public void registerBtcCoinbaseTransaction(byte[] btcTxSerialized, Sha256Hash blockHash, byte[] pmtSerialized, Sha256Hash witnessMerkleRoot, byte[] witnessReservedValue) throws VMException {\n         Context.propagate(btcContext);\n-        this.ensureBtcBlockStore();\n+        try{\n+            this.ensureBtcBlockStore();\n+        }catch (BlockStoreException | IOException e) {\n+            logger.warn(\"Exception in registerBtcCoinbaseTransaction\", e);\n+            throw new VMException(\"Exception in registerBtcCoinbaseTransaction\", e);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7d2ea1cd86419e01de0502b6a7bcac93f03c1c2"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDIxOTk1MQ==", "bodyText": "Not sure if catching inside, could break the behaviour of other methods like \"getBtcTransactionConfirmationsGetCost\". So, I thought that the safest way was this one, apart from out of scope. Let me know your thoughts.", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r550219951", "createdAt": "2020-12-30T14:49:18Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -1992,9 +1993,14 @@ public boolean increaseLockingCap(Transaction tx, Coin newCap) {\n         return true;\n     }\n \n-    public void registerBtcCoinbaseTransaction(byte[] btcTxSerialized, Sha256Hash blockHash, byte[] pmtSerialized, Sha256Hash witnessMerkleRoot, byte[] witnessReservedValue) throws IOException, BlockStoreException {\n+    public void registerBtcCoinbaseTransaction(byte[] btcTxSerialized, Sha256Hash blockHash, byte[] pmtSerialized, Sha256Hash witnessMerkleRoot, byte[] witnessReservedValue) throws VMException {\n         Context.propagate(btcContext);\n-        this.ensureBtcBlockStore();\n+        try{\n+            this.ensureBtcBlockStore();\n+        }catch (BlockStoreException | IOException e) {\n+            logger.warn(\"Exception in registerBtcCoinbaseTransaction\", e);\n+            throw new VMException(\"Exception in registerBtcCoinbaseTransaction\", e);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyMzc4MA=="}, "originalCommit": {"oid": "a7d2ea1cd86419e01de0502b6a7bcac93f03c1c2"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1ODA2NjEyOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/performance/ActiveFederationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDozMjo1OVrOIMQnGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDozMjo1OVrOIMQnGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNTk3OQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/rsksmart/rskj/pull/1392#discussion_r549725979", "createdAt": "2020-12-29T14:32:59Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/test/java/co/rsk/peg/performance/ActiveFederationTest.java", "diffHunk": "@@ -49,51 +51,53 @@\n     private Federation federation;\n \n     @Test\n-    public void getFederationAddress() throws IOException {\n+    public void getFederationAddress() throws IOException, VMException {\n         executeTestCase(Bridge.GET_FEDERATION_ADDRESS);\n     }\n \n     @Test\n-    public void getFederationSize() throws IOException {\n+    public void getFederationSize() throws IOException, VMException {\n         executeTestCase(Bridge.GET_FEDERATION_SIZE);\n     }\n \n     @Test\n-    public void getFederationThreshold() throws IOException {\n+    public void getFederationThreshold() throws IOException, VMException {\n         executeTestCase(Bridge.GET_FEDERATION_THRESHOLD);\n     }\n \n     @Test\n-    public void getFederationCreationTime() throws IOException {\n+    public void getFederationCreationTime() throws IOException, VMException {\n         executeTestCase(Bridge.GET_FEDERATION_CREATION_TIME);\n     }\n \n     @Test\n-    public void getFederationCreationBlockNumber() throws IOException {\n+    public void getFederationCreationBlockNumber() throws IOException, VMException {\n         executeTestCase(Bridge.GET_FEDERATION_CREATION_BLOCK_NUMBER);\n     }\n \n     @Test\n-    public void getFederatorPublicKey() throws IOException {\n+    public void getFederatorPublicKey() throws IOException, VMException {\n         ExecutionStats stats = new ExecutionStats(\"getFederatorPublicKey\");\n         ABIEncoder abiEncoder = (int executionIndex) -> Bridge.GET_FEDERATOR_PUBLIC_KEY.encode(new Object[]{Helper.randomInRange(0, federation.getBtcPublicKeys().size()-1)});\n         executeTestCaseSection(abiEncoder, \"getFederatorPublicKey\", true,50, stats);\n         executeTestCaseSection(abiEncoder, \"getFederatorPublicKey\", false,500, stats);\n-        BridgePerformanceTest.addStats(stats);\n+\n+        Assert.assertTrue(BridgePerformanceTest.addStats(stats));\n     }\n \n-    private void executeTestCase(CallTransaction.Function fn) {\n+    private void executeTestCase(CallTransaction.Function fn) throws VMException {\n         ExecutionStats stats = new ExecutionStats(fn.name);\n         executeTestCaseSection(fn,true,50, stats);\n         executeTestCaseSection(fn,false,500, stats);\n-        BridgePerformanceTest.addStats(stats);\n+\n+        Assert.assertTrue(BridgePerformanceTest.addStats(stats));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7d2ea1cd86419e01de0502b6a7bcac93f03c1c2"}, "originalPosition": 61}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4410, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}