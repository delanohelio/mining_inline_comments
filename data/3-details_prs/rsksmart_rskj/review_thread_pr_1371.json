{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0MjM4MDgw", "number": 1371, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMjozNTozNFrOE8s6RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMjozNjoyOVrOE8s7sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMDg1ODI4OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMjozNTozNFrOH4-2aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMjozNTozNFrOH4-2aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxMjA0MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"The transaction sender should be the Liquidity Bridge Contract address {}\", lbcAddress);\n          \n          \n            \n                        logger.warn(\"Expected sender to be the same as lbcAddress. (sender: {}) (lbcAddress:{}){}\", rskTx.getSender(), lbcAddress);", "url": "https://github.com/rsksmart/rskj/pull/1371#discussion_r529512041", "createdAt": "2020-11-24T12:35:34Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2062,136 +2062,121 @@ public boolean hasBtcBlockCoinbaseTransactionInformation(Sha256Hash blockHash) {\n     }\n \n     public long registerFastBridgeBtcTransaction(\n-            Transaction rskTx,\n-            byte[] btcTxSerialized,\n-            int height,\n-            byte[] pmtSerialized,\n-            Sha256Hash derivationArgumentsHash,\n-            Address userRefundAddress,\n-            RskAddress lbcAddress,\n-            Address lpBtcAddress,\n-            boolean shouldTransferToContract\n+        Transaction rskTx,\n+        byte[] btcTxSerialized,\n+        int height,\n+        byte[] pmtSerialized,\n+        Sha256Hash derivationArgumentsHash,\n+        Address userRefundAddress,\n+        RskAddress lbcAddress,\n+        Address lpBtcAddress,\n+        boolean shouldTransferToContract\n     )\n-        throws BlockStoreException, RegisterFastBridgeBtcTransactionException, IOException {\n+        throws BlockStoreException, IOException {\n+        // Error codes unprocessable\n         if (!BridgeUtils.isContractTx(rskTx)) {\n             String errorMessage = String.format(\n                 \"[registerFastBridgeBtcTransaction] [rskTx:%s] Transaction not a contract\",\n                 ByteUtil.toHexString(rskTx.getHash().getBytes())\n             );\n             logger.debug(errorMessage);\n-            throw new RegisterFastBridgeBtcTransactionContractValidationException(errorMessage);\n+            // TODO: return proper error code\n+            return -13;\n         }\n \n-        // TODO: validateTxSender: tx sender should be equal to lbcAddress\n-        // TODO: get fastBridgeFedAddress (to do this need instantiate fastBridgeFederationInformation)\n-        //  & getAmountSentToAddress. Validate if (totalAmount == Coin.ZERO)\n+        // Error codes unprocessable\n+        if (!rskTx.getSender().equals(lbcAddress)) {\n+            logger.warn(\"The transaction sender should be the Liquidity Bridge Contract address {}\", lbcAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3a7efe3f95d95ca2e25fcbdad253b119a148069"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMDg2MTk0OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMjozNjoyOVrOH4-4fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMjozNjoyOVrOH4-4fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxMjU3NQ==", "bodyText": "btcTxHashWithSegwit is wrong, this hash is actually without witness", "url": "https://github.com/rsksmart/rskj/pull/1371#discussion_r529512575", "createdAt": "2020-11-24T12:36:29Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2062,136 +2062,121 @@ public boolean hasBtcBlockCoinbaseTransactionInformation(Sha256Hash blockHash) {\n     }\n \n     public long registerFastBridgeBtcTransaction(\n-            Transaction rskTx,\n-            byte[] btcTxSerialized,\n-            int height,\n-            byte[] pmtSerialized,\n-            Sha256Hash derivationArgumentsHash,\n-            Address userRefundAddress,\n-            RskAddress lbcAddress,\n-            Address lpBtcAddress,\n-            boolean shouldTransferToContract\n+        Transaction rskTx,\n+        byte[] btcTxSerialized,\n+        int height,\n+        byte[] pmtSerialized,\n+        Sha256Hash derivationArgumentsHash,\n+        Address userRefundAddress,\n+        RskAddress lbcAddress,\n+        Address lpBtcAddress,\n+        boolean shouldTransferToContract\n     )\n-        throws BlockStoreException, RegisterFastBridgeBtcTransactionException, IOException {\n+        throws BlockStoreException, IOException {\n+        // Error codes unprocessable\n         if (!BridgeUtils.isContractTx(rskTx)) {\n             String errorMessage = String.format(\n                 \"[registerFastBridgeBtcTransaction] [rskTx:%s] Transaction not a contract\",\n                 ByteUtil.toHexString(rskTx.getHash().getBytes())\n             );\n             logger.debug(errorMessage);\n-            throw new RegisterFastBridgeBtcTransactionContractValidationException(errorMessage);\n+            // TODO: return proper error code\n+            return -13;\n         }\n \n-        // TODO: validateTxSender: tx sender should be equal to lbcAddress\n-        // TODO: get fastBridgeFedAddress (to do this need instantiate fastBridgeFederationInformation)\n-        //  & getAmountSentToAddress. Validate if (totalAmount == Coin.ZERO)\n+        // Error codes unprocessable\n+        if (!rskTx.getSender().equals(lbcAddress)) {\n+            logger.warn(\"The transaction sender should be the Liquidity Bridge Contract address {}\", lbcAddress);\n+            // TODO: return proper error code\n+            return -11;\n+        }\n \n         Context.propagate(btcContext);\n         Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n \n         //TODO : this validation is no longer needed. In stead,\n         // check in storage FastBridgeHashUsedInBtcTx\n         if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n-            throw new RegisterFastBridgeBtcTransactionException(\"Transaction already processed\");\n+            // TODO: return proper error code for alreadyProcessed\n+            return -111;\n         }\n \n+        // Error codes unprocessable\n         if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n             String errorMessage = String.format(\n                 \"[registerFastBridgeBtcTransaction] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n                 ByteUtil.toHexString(btcTxHash.getBytes())\n             );\n             logger.debug(errorMessage);\n-            throw new RegisterFastBridgeBtcTransactionValidationException(errorMessage);\n+            // TODO: return proper error code for alreadyProcessed\n+            return -112;\n         }\n \n         BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n         btcTx.verify();\n \n-        //TODO : this validation is no longer needed. In stead,\n-        // check again in storage FastBridgeHashUsedInBtcTx, only if btcTx.getHash(false) != btcTxHash\n-        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n-        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n-            throw new RegisterFastBridgeBtcTransactionException(\"Transaction already processed\");\n-        }\n-\n-        //TODO: remove createFastBridgeFederationData. Will be replaced by fastBridgeFederationInformation\n-        FastBridgeFederationData fastBridgeFederationData = createFastBridgeFederationData(\n-                derivationArgumentsHash,\n-                userRefundAddress,\n-                lpBtcAddress,\n-                lbcAddress\n+        //TODO: check again in storage FastBridgeHashUsedInBtcTx\n+        Sha256Hash btcTxHashWithSegwit = btcTx.getHash(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3a7efe3f95d95ca2e25fcbdad253b119a148069"}, "originalPosition": 87}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4549, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}