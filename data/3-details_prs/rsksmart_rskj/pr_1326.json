{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3OTcwMjI3", "number": 1326, "title": "Implemented block propagation enhancements", "bodyText": "This pull request is a first step in attempting to improve block propagation process\nDescription\nPhase 1 of block propagation improvements\nMotivation and Context\nRSK node currently processes all the blocks it receives. In a context of many sibling blocks, this results in a significant processing times and usage of node resources.\nThis change should decouple block receiving/propagation from its execution (which usually takes significant portion of time).\nNote: node should propagate a received block only after passing necessary validations.\nHow Has This Been Tested?\n\n\n\nTypes of changes\n\n\n Bug fix (non-breaking change which fixes an issue)\n New feature (non-breaking change which adds functionality)\n Breaking change (fix or feature that would cause existing functionality to not work as expected)\n\nChecklist:\n\n\n\n My code follows the code style of this project.\n My change requires a change to the documentation.\n I have updated the documentation accordingly.\n Tests for the changes have been added (for bug fixes / features)\n Requires Activation Code (Hard Fork)\n\n\nOther information:", "createdAt": "2020-10-05T16:21:34Z", "url": "https://github.com/rsksmart/rskj/pull/1326", "merged": true, "mergeCommit": {"oid": "5a102cb531beb2189d585466cd51a6101ebb3d6a"}, "closed": true, "closedAt": "2021-01-20T22:22:26Z", "author": {"login": "Vovchyk"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQhmHBgFqTUwNDc3OTY3NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdxvawKgFqTU3MTUyMDAzOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0Nzc5Njc1", "url": "https://github.com/rsksmart/rskj/pull/1326#pullrequestreview-504779675", "createdAt": "2020-10-08T13:26:11Z", "commit": {"oid": "786ddc7e597a6a7e02bdc857d24e855b5e17f314"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzoyNjoxMlrOHeeesQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzoyODoyNVrOHeek3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcxODcwNQ==", "bodyText": "AFAIK, this method is only used for testing. Maybe we could move this implementation to test packages", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r501718705", "createdAt": "2020-10-08T13:26:12Z", "author": {"login": "ajlopezrsk"}, "path": "rskj-core/src/test/java/co/rsk/net/utils/AsyncNodeBlockProcessorListener.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package co.rsk.net.utils;\n+\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.AsyncNodeBlockProcessor;\n+import co.rsk.net.BlockProcessResult;\n+import co.rsk.net.Peer;\n+import org.ethereum.core.Block;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * Utility class that allows to wait for some particular block to be processed.\n+ */\n+public class AsyncNodeBlockProcessorListener implements AsyncNodeBlockProcessor.Listener {\n+\n+    private final BlockingQueue<Block> processedBlocks = new LinkedBlockingQueue<>();\n+\n+    @Override\n+    public void onBlockProcessed(@Nonnull AsyncNodeBlockProcessor blockProcessor,\n+                                 @Nullable Peer sender, @Nonnull Block block,\n+                                 @Nonnull BlockProcessResult blockProcessResult) {\n+        processedBlocks.add(block);\n+    }\n+\n+    public void waitForBlock(@Nonnull Keccak256 hash) throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "786ddc7e597a6a7e02bdc857d24e855b5e17f314"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyMDI4Nw==", "bodyText": "Processing the block, connecting to a chain, OK. Any second relay of this block? AFAIR geth implementation sends a second relay after the full process of the block", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r501720287", "createdAt": "2020-10-08T13:28:25Z", "author": {"login": "ajlopezrsk"}, "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.net.sync.SyncConfiguration;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<PeerBlockPair> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.listener = listener;\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        // TODO: add block validation\n+\n+        BlockProcessResult blockProcessResult = blockSyncService.processBlock(block, sender, false, false);\n+        if (blockProcessResult.isScheduledForProcessing()) {\n+            blocksToProcess.offer(new PeerBlockPair(sender, block));\n+        }\n+\n+        return blockProcessResult;\n+    }\n+\n+    @Override\n+    public void start() {\n+        thread.start();\n+    }\n+\n+    @Override\n+    public void stop() {\n+        stop(0L);\n+    }\n+\n+    /**\n+     * Stop the service and wait until a working thread is stopped for {@code waitMillis} milliseconds,\n+     * if {@code waitMillis} greater than zero. If {@code waitMillis} is zero, then immediately returns.\n+     */\n+    public void stop(long waitMillis) {\n+        stopped = true;\n+\n+        try {\n+            thread.interrupt();\n+            if (waitMillis > 0L) {\n+                thread.join(waitMillis);\n+            }\n+        } catch (InterruptedException e) {\n+            logger.error(\"Failed to join the thread\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (!stopped) {\n+            Peer sender = null;\n+            Block block = null;\n+\n+            try {\n+                logger.trace(\"Get peer/block pair\");\n+\n+                PeerBlockPair pair = blocksToProcess.take();\n+\n+                sender = pair.peer;\n+                block = pair.block;\n+\n+                logger.trace(\"Start block processing\");\n+                BlockProcessResult blockProcessResult = blockSyncService.processBlock(block, sender, false, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "786ddc7e597a6a7e02bdc857d24e855b5e17f314"}, "originalPosition": 114}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a6b60afbc70ede32fbf0127a2a032a5591a28094", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/a6b60afbc70ede32fbf0127a2a032a5591a28094", "committedDate": "2020-10-15T07:04:12Z", "message": "Added block validation logic"}, "afterCommit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/b7e58e7f26656e906d64078c59fba3d778cb75c2", "committedDate": "2020-10-15T07:53:55Z", "message": "Added block validation logic"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MDQ3NTg2", "url": "https://github.com/rsksmart/rskj/pull/1326#pullrequestreview-514047586", "createdAt": "2020-10-21T18:14:04Z", "commit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODoxNDowNVrOHl79Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODoxNDowNVrOHl79Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU0MTYzOA==", "bodyText": "Why not to check if the block is ALREADY in the \"net store\"? Maybe it could avoid the process of duplicated blocks that arrives from different peers to this node, but are not yet added to any chain because they are still in the to process queue", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r509541638", "createdAt": "2020-10-21T18:14:05Z", "author": {"login": "ajlopezrsk"}, "path": "rskj-core/src/main/java/co/rsk/net/BlockSyncService.java", "diffHunk": "@@ -69,21 +70,19 @@ public BlockSyncService(\n         this.config = config;\n     }\n \n-    public BlockProcessResult processBlock(@Nonnull Block block, Peer sender, boolean ignoreMissingHashes) {\n-        Instant start = Instant.now();\n-        long bestBlockNumber = this.getBestBlockNumber();\n-        long blockNumber = block.getNumber();\n+    protected boolean preprocessBlock(@Nonnull Block block, Peer sender, boolean ignoreMissingHashes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MTg2Mzg1", "url": "https://github.com/rsksmart/rskj/pull/1326#pullrequestreview-514186385", "createdAt": "2020-10-21T21:07:17Z", "commit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMTowNzoxN1rOHmFdJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMzowNjozN1rOHmgzgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5NzMxNw==", "bodyText": "Can we add here a summary of the Validator classes applied in this validator?", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r509697317", "createdAt": "2020-10-21T21:07:17Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/co/rsk/core/bc/BlockRelayValidatorImpl.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.core.bc;\n+\n+import co.rsk.validators.*;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.db.BlockStore;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * Validates a block if it is good enough to be propagated.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5OTU5Mw==", "bodyText": "listener is only for testing?\nif thats the case, I would spec a diff constructor adding the listener, and a comment that its only for testing.\nthis allow us to avoid a \"null\" in RskContext construction and a clear knowledge that its not used in real scenario.", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r509699593", "createdAt": "2020-10-21T21:10:04Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<PeerBlockPair> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockRelayValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcyOTMyOA==", "bodyText": "Shouldn't we validate header and block, before preprocessing?\nThis is a more open/complex question.\nThe issue that i see, is that if block header (e.g.) is invalid, we'll be trying to get parents when not necessary.", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r509729328", "createdAt": "2020-10-21T21:48:42Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<PeerBlockPair> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockRelayValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockRelayValidator, @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.listener = listener;\n+        this.blockRelayValidator = blockRelayValidator;\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        final Instant start = Instant.now();\n+\n+        boolean looksGood = blockSyncService.preprocessBlock(block, sender, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczMTcyMw==", "bodyText": "No limit queue could bring issues?", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r509731723", "createdAt": "2020-10-21T21:52:05Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<PeerBlockPair> blocksToProcess = new LinkedBlockingQueue<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczMzM2NA==", "bodyText": "you could extract this to a method, to make it more readable.", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r509733364", "createdAt": "2020-10-21T21:54:23Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<PeerBlockPair> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockRelayValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockRelayValidator, @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.listener = listener;\n+        this.blockRelayValidator = blockRelayValidator;\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        final Instant start = Instant.now();\n+\n+        boolean looksGood = blockSyncService.preprocessBlock(block, sender, false);\n+        if (looksGood) {\n+            if (isValid(block)) {\n+                boolean offer = blocksToProcess.offer(new PeerBlockPair(sender, block));\n+                if (!offer) {\n+                    logger.warn(\"Cannot add a block for processing into the queue\");\n+                }\n+\n+                return new BlockProcessResult(true, null, block.getPrintableHash(),\n+                        Duration.between(start, Instant.now()));\n+            }\n+\n+            logger.warn(\"Invalid block with number {} {} from {} \", block.getNumber(), block.getPrintableHash(),\n+                    sender != null ? sender.getPeerNodeID().toString() : \"N/A\");\n+            Map<Keccak256, ImportResult> result = Collections.singletonMap(block.getHash(), ImportResult.INVALID_BLOCK);\n+            return new BlockProcessResult(false, result, block.getPrintableHash(),\n+                    Duration.between(start, Instant.now()));\n+        }\n+\n+        return new BlockProcessResult(false, null, block.getPrintableHash(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczNDIyNg==", "bodyText": "this could be extracted outside the log line, to make it more readable.", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r509734226", "createdAt": "2020-10-21T21:55:23Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<PeerBlockPair> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockRelayValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockRelayValidator, @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.listener = listener;\n+        this.blockRelayValidator = blockRelayValidator;\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        final Instant start = Instant.now();\n+\n+        boolean looksGood = blockSyncService.preprocessBlock(block, sender, false);\n+        if (looksGood) {\n+            if (isValid(block)) {\n+                boolean offer = blocksToProcess.offer(new PeerBlockPair(sender, block));\n+                if (!offer) {\n+                    logger.warn(\"Cannot add a block for processing into the queue\");\n+                }\n+\n+                return new BlockProcessResult(true, null, block.getPrintableHash(),\n+                        Duration.between(start, Instant.now()));\n+            }\n+\n+            logger.warn(\"Invalid block with number {} {} from {} \", block.getNumber(), block.getPrintableHash(),\n+                    sender != null ? sender.getPeerNodeID().toString() : \"N/A\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE0NTQxMA==", "bodyText": "make sense to add block hash/number?", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r510145410", "createdAt": "2020-10-22T13:06:37Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<PeerBlockPair> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockRelayValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockRelayValidator, @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.listener = listener;\n+        this.blockRelayValidator = blockRelayValidator;\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        final Instant start = Instant.now();\n+\n+        boolean looksGood = blockSyncService.preprocessBlock(block, sender, false);\n+        if (looksGood) {\n+            if (isValid(block)) {\n+                boolean offer = blocksToProcess.offer(new PeerBlockPair(sender, block));\n+                if (!offer) {\n+                    logger.warn(\"Cannot add a block for processing into the queue\");\n+                }\n+\n+                return new BlockProcessResult(true, null, block.getPrintableHash(),\n+                        Duration.between(start, Instant.now()));\n+            }\n+\n+            logger.warn(\"Invalid block with number {} {} from {} \", block.getNumber(), block.getPrintableHash(),\n+                    sender != null ? sender.getPeerNodeID().toString() : \"N/A\");\n+            Map<Keccak256, ImportResult> result = Collections.singletonMap(block.getHash(), ImportResult.INVALID_BLOCK);\n+            return new BlockProcessResult(false, result, block.getPrintableHash(),\n+                    Duration.between(start, Instant.now()));\n+        }\n+\n+        return new BlockProcessResult(false, null, block.getPrintableHash(),\n+                Duration.between(start, Instant.now()));\n+    }\n+\n+    @Override\n+    public void start() {\n+        thread.start();\n+    }\n+\n+    @Override\n+    public void stop() {\n+        stopThread();\n+    }\n+\n+    /**\n+     * Stop the service and wait until a working thread is stopped for {@code waitMillis} milliseconds,\n+     * if {@code waitMillis} greater than zero. If {@code waitMillis} is zero, then immediately returns.\n+     */\n+    public void stopAndWait(long waitMillis) throws InterruptedException {\n+        stopThread();\n+\n+        if (waitMillis > 0L) {\n+            thread.join(waitMillis);\n+        }\n+    }\n+\n+    private void stopThread() {\n+        stopped = true;\n+        thread.interrupt();\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (!stopped) {\n+            Peer sender = null;\n+            Block block = null;\n+\n+            try {\n+                logger.trace(\"Get peer/block pair\");\n+\n+                PeerBlockPair pair = blocksToProcess.take();\n+\n+                sender = pair.peer;\n+                block = pair.block;\n+\n+                logger.trace(\"Start block processing\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0ODQzNDMw", "url": "https://github.com/rsksmart/rskj/pull/1326#pullrequestreview-514843430", "createdAt": "2020-10-22T15:17:42Z", "commit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNToxNzo0MlrOHmm_Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNTo0NjozOVrOHmoU6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI0NjcxMQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r510246711", "createdAt": "2020-10-22T15:17:42Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/co/rsk/net/messages/MessageVisitor.java", "diffHunk": "@@ -112,11 +112,7 @@ public void apply(BlockMessage message) {\n \n         tryRelayBlock(block, result);\n \n-        if (result.isBest()) {\n-            sender.imported(true);\n-        } else {\n-            sender.imported(false);\n-        }\n+        sender.imported(result.isBest());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI2ODY0OQ==", "bodyText": "\"preprocess\" is executed twice? first time when you put in the queue and this is the second time when you actually process it?", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r510268649", "createdAt": "2020-10-22T15:46:39Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/co/rsk/net/BlockSyncService.java", "diffHunk": "@@ -105,6 +103,17 @@ public BlockProcessResult processBlock(@Nonnull Block block, Peer sender, boolea\n                 logger.trace(\"Missing hashes for block in process {} {}\", blockNumber, block.getPrintableHash());\n                 requestMissingHashes(sender, unknownHashes);\n             }\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    public BlockProcessResult processBlock(@Nonnull Block block, Peer sender, boolean ignoreMissingHashes) {\n+        final Instant start = Instant.now();\n+\n+        boolean looksGood = preprocessBlock(block, sender, ignoreMissingHashes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0OTk1NzE4", "url": "https://github.com/rsksmart/rskj/pull/1326#pullrequestreview-514995718", "createdAt": "2020-10-22T18:12:56Z", "commit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxODoxMjo1NlrOHmuDRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOToxMTo0OVrOHmwGlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM2MjQzOQ==", "bodyText": "be careful here... if it happens to fail, it won't stop. Is there anyway to put a timeout here?", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r510362439", "createdAt": "2020-10-22T18:12:56Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/test/java/co/rsk/net/AsyncNodeBlockProcessorTest.java", "diffHunk": "@@ -0,0 +1,1030 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.blockchain.utils.BlockGenerator;\n+import co.rsk.config.TestSystemProperties;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.messages.*;\n+import co.rsk.net.simples.SimplePeer;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.net.utils.AsyncNodeBlockProcessorListener;\n+import co.rsk.test.builders.BlockChainBuilder;\n+import co.rsk.validators.BlockValidator;\n+import co.rsk.validators.DummyBlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockIdentifier;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.crypto.HashUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import static org.mockito.Mockito.*;\n+\n+public class AsyncNodeBlockProcessorTest {\n+\n+    private static final long WAIT_TIME = Long.MAX_VALUE;\n+    \n+    @Test\n+    public void processBlockSavingInStore() {\n+        final NetBlockStore store = new NetBlockStore();\n+        final Peer sender = new SimplePeer();\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final BlockGenerator blockGenerator = new BlockGenerator();\n+        final Block parent = blockGenerator.createChildBlock(blockGenerator.getGenesisBlock());\n+        final Block orphan = blockGenerator.createChildBlock(parent);\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        processor.processBlock(sender, orphan);\n+\n+        Assert.assertEquals(1, processor.getNodeInformation().getNodesByBlock(orphan.getHash().getBytes()).size());\n+\n+        Assert.assertTrue(store.hasBlock(orphan));\n+        Assert.assertEquals(1, store.size());\n+    }\n+\n+    @Test\n+    public void processBlockWithTooMuchHeight() {\n+        final NetBlockStore store = new NetBlockStore();\n+        final Peer sender = new SimplePeer();\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final Block orphan = new BlockGenerator().createBlock(1000, 0);\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        processor.processBlock(sender, orphan);\n+\n+        Assert.assertNotEquals(1, processor.getNodeInformation().getNodesByBlock(orphan.getHash().getBytes()).size());\n+        Assert.assertFalse(store.hasBlock(orphan));\n+        Assert.assertEquals(0, store.size());\n+    }\n+\n+    @Test\n+    public void advancedBlock() {\n+        final NetBlockStore store = new NetBlockStore();\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final long advancedBlockNumber = syncConfiguration.getChunkSize() * syncConfiguration.getMaxSkeletonChunks() + blockchain.getBestBlock().getNumber() + 1;\n+\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        Assert.assertTrue(processor.isAdvancedBlock(advancedBlockNumber));\n+        Assert.assertFalse(processor.isAdvancedBlock(advancedBlockNumber - 1));\n+    }\n+\n+    @Test\n+    public void canBeIgnoredForUncles() {\n+        final NetBlockStore store = new NetBlockStore();\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(15);\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final int uncleGenerationLimit = config.getNetworkConstants().getUncleGenerationLimit();\n+        final long blockNumberThatCanBeIgnored = blockchain.getBestBlock().getNumber() - 1 - uncleGenerationLimit;\n+\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        Assert.assertTrue(processor.canBeIgnoredForUnclesRewards(blockNumberThatCanBeIgnored));\n+        Assert.assertFalse(processor.canBeIgnoredForUnclesRewards(blockNumberThatCanBeIgnored + 1));\n+    }\n+\n+    @Test\n+    public void processBlockAddingToBlockchain() throws InterruptedException {\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(10);\n+\n+        Assert.assertEquals(10, blockchain.getBestBlock().getNumber());\n+\n+        final NetBlockStore store = new NetBlockStore();\n+        final Block genesis = blockchain.getBlockByNumber(0);\n+        store.saveBlock(genesis);\n+\n+        final Block block = new BlockGenerator().createChildBlock(blockchain.getBlockByNumber(10));\n+\n+        Assert.assertEquals(11, block.getNumber());\n+        Assert.assertArrayEquals(blockchain.getBestBlockHash(), block.getParentHash().getBytes());\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessorListener listener = new AsyncNodeBlockProcessorListener();\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), listener);\n+        processor.start();\n+\n+        BlockProcessResult blockProcessResult = processor.processBlock(null, block);\n+        if (blockProcessResult.isScheduledForProcessing()) {\n+            listener.waitForBlock(block.getHash());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM2MjY3MQ==", "bodyText": "why wait time so high?", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r510362671", "createdAt": "2020-10-22T18:13:20Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/test/java/co/rsk/net/AsyncNodeBlockProcessorTest.java", "diffHunk": "@@ -0,0 +1,1030 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.blockchain.utils.BlockGenerator;\n+import co.rsk.config.TestSystemProperties;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.messages.*;\n+import co.rsk.net.simples.SimplePeer;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.net.utils.AsyncNodeBlockProcessorListener;\n+import co.rsk.test.builders.BlockChainBuilder;\n+import co.rsk.validators.BlockValidator;\n+import co.rsk.validators.DummyBlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockIdentifier;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.crypto.HashUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import static org.mockito.Mockito.*;\n+\n+public class AsyncNodeBlockProcessorTest {\n+\n+    private static final long WAIT_TIME = Long.MAX_VALUE;\n+    \n+    @Test\n+    public void processBlockSavingInStore() {\n+        final NetBlockStore store = new NetBlockStore();\n+        final Peer sender = new SimplePeer();\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final BlockGenerator blockGenerator = new BlockGenerator();\n+        final Block parent = blockGenerator.createChildBlock(blockGenerator.getGenesisBlock());\n+        final Block orphan = blockGenerator.createChildBlock(parent);\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        processor.processBlock(sender, orphan);\n+\n+        Assert.assertEquals(1, processor.getNodeInformation().getNodesByBlock(orphan.getHash().getBytes()).size());\n+\n+        Assert.assertTrue(store.hasBlock(orphan));\n+        Assert.assertEquals(1, store.size());\n+    }\n+\n+    @Test\n+    public void processBlockWithTooMuchHeight() {\n+        final NetBlockStore store = new NetBlockStore();\n+        final Peer sender = new SimplePeer();\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final Block orphan = new BlockGenerator().createBlock(1000, 0);\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        processor.processBlock(sender, orphan);\n+\n+        Assert.assertNotEquals(1, processor.getNodeInformation().getNodesByBlock(orphan.getHash().getBytes()).size());\n+        Assert.assertFalse(store.hasBlock(orphan));\n+        Assert.assertEquals(0, store.size());\n+    }\n+\n+    @Test\n+    public void advancedBlock() {\n+        final NetBlockStore store = new NetBlockStore();\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final long advancedBlockNumber = syncConfiguration.getChunkSize() * syncConfiguration.getMaxSkeletonChunks() + blockchain.getBestBlock().getNumber() + 1;\n+\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        Assert.assertTrue(processor.isAdvancedBlock(advancedBlockNumber));\n+        Assert.assertFalse(processor.isAdvancedBlock(advancedBlockNumber - 1));\n+    }\n+\n+    @Test\n+    public void canBeIgnoredForUncles() {\n+        final NetBlockStore store = new NetBlockStore();\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(15);\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final int uncleGenerationLimit = config.getNetworkConstants().getUncleGenerationLimit();\n+        final long blockNumberThatCanBeIgnored = blockchain.getBestBlock().getNumber() - 1 - uncleGenerationLimit;\n+\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        Assert.assertTrue(processor.canBeIgnoredForUnclesRewards(blockNumberThatCanBeIgnored));\n+        Assert.assertFalse(processor.canBeIgnoredForUnclesRewards(blockNumberThatCanBeIgnored + 1));\n+    }\n+\n+    @Test\n+    public void processBlockAddingToBlockchain() throws InterruptedException {\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(10);\n+\n+        Assert.assertEquals(10, blockchain.getBestBlock().getNumber());\n+\n+        final NetBlockStore store = new NetBlockStore();\n+        final Block genesis = blockchain.getBlockByNumber(0);\n+        store.saveBlock(genesis);\n+\n+        final Block block = new BlockGenerator().createChildBlock(blockchain.getBlockByNumber(10));\n+\n+        Assert.assertEquals(11, block.getNumber());\n+        Assert.assertArrayEquals(blockchain.getBestBlockHash(), block.getParentHash().getBytes());\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessorListener listener = new AsyncNodeBlockProcessorListener();\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), listener);\n+        processor.start();\n+\n+        BlockProcessResult blockProcessResult = processor.processBlock(null, block);\n+        if (blockProcessResult.isScheduledForProcessing()) {\n+            listener.waitForBlock(block.getHash());\n+        }\n+\n+        Assert.assertFalse(store.hasBlock(block));\n+        Assert.assertEquals(11, blockchain.getBestBlock().getNumber());\n+        Assert.assertArrayEquals(block.getHash().getBytes(), blockchain.getBestBlockHash());\n+        Assert.assertEquals(1, store.size());\n+\n+        processor.stopAndWait(WAIT_TIME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM3NjQwNg==", "bodyText": "why dont you save the last result and ask only for the last one outside the loop?", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r510376406", "createdAt": "2020-10-22T18:37:21Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/test/java/co/rsk/net/AsyncNodeBlockProcessorTest.java", "diffHunk": "@@ -0,0 +1,1030 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.blockchain.utils.BlockGenerator;\n+import co.rsk.config.TestSystemProperties;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.messages.*;\n+import co.rsk.net.simples.SimplePeer;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.net.utils.AsyncNodeBlockProcessorListener;\n+import co.rsk.test.builders.BlockChainBuilder;\n+import co.rsk.validators.BlockValidator;\n+import co.rsk.validators.DummyBlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockIdentifier;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.crypto.HashUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import static org.mockito.Mockito.*;\n+\n+public class AsyncNodeBlockProcessorTest {\n+\n+    private static final long WAIT_TIME = Long.MAX_VALUE;\n+    \n+    @Test\n+    public void processBlockSavingInStore() {\n+        final NetBlockStore store = new NetBlockStore();\n+        final Peer sender = new SimplePeer();\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final BlockGenerator blockGenerator = new BlockGenerator();\n+        final Block parent = blockGenerator.createChildBlock(blockGenerator.getGenesisBlock());\n+        final Block orphan = blockGenerator.createChildBlock(parent);\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        processor.processBlock(sender, orphan);\n+\n+        Assert.assertEquals(1, processor.getNodeInformation().getNodesByBlock(orphan.getHash().getBytes()).size());\n+\n+        Assert.assertTrue(store.hasBlock(orphan));\n+        Assert.assertEquals(1, store.size());\n+    }\n+\n+    @Test\n+    public void processBlockWithTooMuchHeight() {\n+        final NetBlockStore store = new NetBlockStore();\n+        final Peer sender = new SimplePeer();\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final Block orphan = new BlockGenerator().createBlock(1000, 0);\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        processor.processBlock(sender, orphan);\n+\n+        Assert.assertNotEquals(1, processor.getNodeInformation().getNodesByBlock(orphan.getHash().getBytes()).size());\n+        Assert.assertFalse(store.hasBlock(orphan));\n+        Assert.assertEquals(0, store.size());\n+    }\n+\n+    @Test\n+    public void advancedBlock() {\n+        final NetBlockStore store = new NetBlockStore();\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final long advancedBlockNumber = syncConfiguration.getChunkSize() * syncConfiguration.getMaxSkeletonChunks() + blockchain.getBestBlock().getNumber() + 1;\n+\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        Assert.assertTrue(processor.isAdvancedBlock(advancedBlockNumber));\n+        Assert.assertFalse(processor.isAdvancedBlock(advancedBlockNumber - 1));\n+    }\n+\n+    @Test\n+    public void canBeIgnoredForUncles() {\n+        final NetBlockStore store = new NetBlockStore();\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(15);\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final int uncleGenerationLimit = config.getNetworkConstants().getUncleGenerationLimit();\n+        final long blockNumberThatCanBeIgnored = blockchain.getBestBlock().getNumber() - 1 - uncleGenerationLimit;\n+\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        Assert.assertTrue(processor.canBeIgnoredForUnclesRewards(blockNumberThatCanBeIgnored));\n+        Assert.assertFalse(processor.canBeIgnoredForUnclesRewards(blockNumberThatCanBeIgnored + 1));\n+    }\n+\n+    @Test\n+    public void processBlockAddingToBlockchain() throws InterruptedException {\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(10);\n+\n+        Assert.assertEquals(10, blockchain.getBestBlock().getNumber());\n+\n+        final NetBlockStore store = new NetBlockStore();\n+        final Block genesis = blockchain.getBlockByNumber(0);\n+        store.saveBlock(genesis);\n+\n+        final Block block = new BlockGenerator().createChildBlock(blockchain.getBlockByNumber(10));\n+\n+        Assert.assertEquals(11, block.getNumber());\n+        Assert.assertArrayEquals(blockchain.getBestBlockHash(), block.getParentHash().getBytes());\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessorListener listener = new AsyncNodeBlockProcessorListener();\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), listener);\n+        processor.start();\n+\n+        BlockProcessResult blockProcessResult = processor.processBlock(null, block);\n+        if (blockProcessResult.isScheduledForProcessing()) {\n+            listener.waitForBlock(block.getHash());\n+        }\n+\n+        Assert.assertFalse(store.hasBlock(block));\n+        Assert.assertEquals(11, blockchain.getBestBlock().getNumber());\n+        Assert.assertArrayEquals(block.getHash().getBytes(), blockchain.getBestBlockHash());\n+        Assert.assertEquals(1, store.size());\n+\n+        processor.stopAndWait(WAIT_TIME);\n+    }\n+\n+    @Test\n+    public void processTenBlocksAddingToBlockchain() throws InterruptedException {\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final NetBlockStore store = new NetBlockStore();\n+        final Block genesis = blockchain.getBestBlock();\n+\n+        final List<Block> blocks = new BlockGenerator().getBlockChain(genesis, 10);\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessorListener listener = new AsyncNodeBlockProcessorListener();\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), listener);\n+        processor.start();\n+\n+        BlockProcessResult blockProcessResult = processor.processBlock(null, genesis);\n+        if (blockProcessResult.isScheduledForProcessing()) {\n+            listener.waitForBlock(genesis.getHash());\n+        }\n+\n+        Assert.assertEquals(0, store.size());\n+\n+        Block blockToWait = null;\n+        for (Block b : blocks) {\n+            BlockProcessResult result = processor.processBlock(null, b);\n+            if (result.isScheduledForProcessing()) {\n+                blockToWait = b;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5NjA1Mg==", "bodyText": "I liked these before/after, cant we do sthg similar with the other test class?", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r510396052", "createdAt": "2020-10-22T19:11:49Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/test/java/co/rsk/net/AsyncNodeBlockProcessorUnclesTest.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.TestSystemProperties;\n+import co.rsk.core.bc.BlockChainImpl;\n+import co.rsk.net.simples.SimplePeer;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.net.utils.AsyncNodeBlockProcessorListener;\n+import co.rsk.test.builders.BlockBuilder;\n+import co.rsk.test.builders.BlockChainBuilder;\n+import co.rsk.validators.BlockValidator;\n+import co.rsk.validators.DummyBlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class AsyncNodeBlockProcessorUnclesTest {\n+\n+    private static final long WAIT_TIME = Long.MAX_VALUE;\n+\n+    private BlockChainBuilder blockChainBuilder;\n+    private BlockChainImpl blockChain;\n+    private AsyncNodeBlockProcessor processor;\n+    private AsyncNodeBlockProcessorListener listener;\n+\n+    @Before\n+    public void setUp() {\n+        blockChainBuilder = new BlockChainBuilder();\n+        blockChain = blockChainBuilder.build();\n+        listener = new AsyncNodeBlockProcessorListener();\n+        processor = createAsyncNodeBlockProcessor(blockChain, listener);\n+        processor.start();\n+    }\n+\n+    @After\n+    public void tearDown() throws InterruptedException {\n+        processor.stopAndWait(WAIT_TIME);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5OTk5ODE3", "url": "https://github.com/rsksmart/rskj/pull/1326#pullrequestreview-519999817", "createdAt": "2020-10-29T19:22:37Z", "commit": {"oid": "36c31e5c5556c51905012be2d6d3a5ecef129204"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxOToyMjozN1rOHqrJFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxOToyMjozN1rOHqrJFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUwOTA3Ng==", "bodyText": "The PoW rule should be validated before this.\nIt would be easy to DoS the nodes in the current state: RSKIP92 allows the creation of a block with the same hash but with invalid PoW, and the current code would allow it to reach the store actually forcing the valid block to be rejected.", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r514509076", "createdAt": "2020-10-29T19:22:37Z", "author": {"login": "donequis"}, "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<BlockInfo> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockRelayValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockRelayValidator, @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.listener = listener;\n+        this.blockRelayValidator = blockRelayValidator;\n+    }\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockRelayValidator) {\n+        this(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, blockRelayValidator, null);\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        final Instant start = Instant.now();\n+\n+        final long blockNumber = block.getNumber();\n+        final String blockHash = block.getPrintableHash();\n+        final String peer = sender != null ? sender.getPeerNodeID().toString() : \"N/A\";\n+\n+        if (store.hasBlock(block)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36c31e5c5556c51905012be2d6d3a5ecef129204"}, "originalPosition": 84}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "36c31e5c5556c51905012be2d6d3a5ecef129204", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/36c31e5c5556c51905012be2d6d3a5ecef129204", "committedDate": "2020-10-28T17:05:05Z", "message": "Added test for a case when block is invalid"}, "afterCommit": {"oid": "d335ae977381f662e78049c4d9dbf23cc964c498", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/d335ae977381f662e78049c4d9dbf23cc964c498", "committedDate": "2020-11-03T12:47:12Z", "message": "Added prior block header validation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMzUyNjE1", "url": "https://github.com/rsksmart/rskj/pull/1326#pullrequestreview-533352615", "createdAt": "2020-11-18T11:29:26Z", "commit": {"oid": "d335ae977381f662e78049c4d9dbf23cc964c498"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMToyOToyNlrOH1pZJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMTozNDoxNVrOH1pkEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNDc1Ng==", "bodyText": "Why not to delegate this logic to a block processor getter? Or is there a situation when even having fast block propagation enable, we should need the direct block processor instead of async one?", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r526014756", "createdAt": "2020-11-18T11:29:26Z", "author": {"login": "ajlopezrsk"}, "path": "rskj-core/src/main/java/co/rsk/RskContext.java", "diffHunk": "@@ -1558,9 +1626,14 @@ private TransactionGateway getTransactionGateway() {\n \n     private NodeMessageHandler getNodeMessageHandler() {\n         if (nodeMessageHandler == null) {\n+            RskSystemProperties rskSystemProperties = getRskSystemProperties();\n+            BlockProcessor blockProcessor = rskSystemProperties.fastBlockPropagation()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d335ae977381f662e78049c4d9dbf23cc964c498"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNzU1Mw==", "bodyText": "I didn't follow all the discussion, but I think we should do all the validations that NOT involves access to disk or memory caches, FIRST.", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r526017553", "createdAt": "2020-11-18T11:34:15Z", "author": {"login": "ajlopezrsk"}, "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<PeerBlockPair> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockRelayValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockRelayValidator, @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.listener = listener;\n+        this.blockRelayValidator = blockRelayValidator;\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        final Instant start = Instant.now();\n+\n+        boolean looksGood = blockSyncService.preprocessBlock(block, sender, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcyOTMyOA=="}, "originalCommit": {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2"}, "originalPosition": 74}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d335ae977381f662e78049c4d9dbf23cc964c498", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/d335ae977381f662e78049c4d9dbf23cc964c498", "committedDate": "2020-11-03T12:47:12Z", "message": "Added prior block header validation"}, "afterCommit": {"oid": "aa364423c02c53f40b5cb4ed6f306d30e5c25cbc", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/aa364423c02c53f40b5cb4ed6f306d30e5c25cbc", "committedDate": "2020-11-19T12:15:02Z", "message": "Moved AsyncNodeBlockProcessor creation to getNodeBlockProcessor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aa364423c02c53f40b5cb4ed6f306d30e5c25cbc", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/aa364423c02c53f40b5cb4ed6f306d30e5c25cbc", "committedDate": "2020-11-19T12:15:02Z", "message": "Moved AsyncNodeBlockProcessor creation to getNodeBlockProcessor"}, "afterCommit": {"oid": "5af06a3308a55ea137dfee148f12842afd3a88b8", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/5af06a3308a55ea137dfee148f12842afd3a88b8", "committedDate": "2020-11-19T14:20:33Z", "message": "Moved AsyncNodeBlockProcessor creation to getNodeBlockProcessor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4ODAyODI4", "url": "https://github.com/rsksmart/rskj/pull/1326#pullrequestreview-538802828", "createdAt": "2020-11-25T19:45:10Z", "commit": {"oid": "5af06a3308a55ea137dfee148f12842afd3a88b8"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MzMyMzc5", "url": "https://github.com/rsksmart/rskj/pull/1326#pullrequestreview-539332379", "createdAt": "2020-11-26T13:52:08Z", "commit": {"oid": "5af06a3308a55ea137dfee148f12842afd3a88b8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzo1MjowOFrOH6cS_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzo1MjowOFrOH6cS_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA0MzA3MQ==", "bodyText": "Can we default to false for this validators? There's no need to relay a genesis block", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r531043071", "createdAt": "2020-11-26T13:52:08Z", "author": {"login": "donequis"}, "path": "rskj-core/src/main/java/co/rsk/core/bc/BlockHeaderRelayValidatorImpl.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.core.bc;\n+\n+import co.rsk.validators.BlockHeaderValidationRule;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * Validates a block header if it is good enough to be propagated.\n+ *\n+ * The validation includes:\n+ * - validation of the header data of the block\n+ */\n+public class BlockHeaderRelayValidatorImpl implements BlockValidator {\n+\n+    private final BlockHeaderValidationRule blockHeaderValidator;\n+\n+    public BlockHeaderRelayValidatorImpl(@Nonnull BlockHeaderValidationRule blockHeaderValidator) {\n+        this.blockHeaderValidator = blockHeaderValidator;\n+    }\n+\n+    /**\n+     * Checks if a block header is valid.\n+     *\n+     * @param block Block to validate\n+     * @return true if the block is valid, otherwise - false.\n+     */\n+    @Override\n+    public boolean isValid(@Nonnull Block block) {\n+        if (block.isGenesis()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5af06a3308a55ea137dfee148f12842afd3a88b8"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MzQwODc1", "url": "https://github.com/rsksmart/rskj/pull/1326#pullrequestreview-539340875", "createdAt": "2020-11-26T14:03:15Z", "commit": {"oid": "5af06a3308a55ea137dfee148f12842afd3a88b8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNDowMzoxNVrOH6csug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNDowMzoxNVrOH6csug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA0OTY1OA==", "bodyText": "We could add the relay headers validations here, so we prevent accessing the disk before PoW check", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r531049658", "createdAt": "2020-11-26T14:03:15Z", "author": {"login": "donequis"}, "path": "rskj-core/src/main/java/co/rsk/net/BlockSyncService.java", "diffHunk": "@@ -102,18 +102,28 @@ public BlockProcessResult processBlock(@Nonnull Block block, Peer sender, boolea\n                 logger.trace(\"Missing hashes for block in process {} {}\", blockNumber, block.getPrintableHash());\n                 requestMissingHashes(sender, unknownHashes);\n             }\n-            return BlockProcessResult.invalidBlock(block, start);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    public BlockProcessResult processBlock(@Nonnull Block block, Peer sender, boolean ignoreMissingHashes) {\n+        final Instant start = Instant.now();\n+\n+        boolean readyForProcessing = preprocessBlock(block, sender, ignoreMissingHashes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5af06a3308a55ea137dfee148f12842afd3a88b8"}, "originalPosition": 68}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5af06a3308a55ea137dfee148f12842afd3a88b8", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/5af06a3308a55ea137dfee148f12842afd3a88b8", "committedDate": "2020-11-19T14:20:33Z", "message": "Moved AsyncNodeBlockProcessor creation to getNodeBlockProcessor"}, "afterCommit": {"oid": "2db0d6e6f1d60a415b0456338f54c34e673879f8", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/2db0d6e6f1d60a415b0456338f54c34e673879f8", "committedDate": "2020-11-26T17:28:29Z", "message": "Added validation of block header in BlockSyncService"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5NTAxOTU5", "url": "https://github.com/rsksmart/rskj/pull/1326#pullrequestreview-539501959", "createdAt": "2020-11-26T18:21:14Z", "commit": {"oid": "2db0d6e6f1d60a415b0456338f54c34e673879f8"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0OTY0NTY1", "url": "https://github.com/rsksmart/rskj/pull/1326#pullrequestreview-554964565", "createdAt": "2020-12-17T20:30:59Z", "commit": {"oid": "2db0d6e6f1d60a415b0456338f54c34e673879f8"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDozMDo1OVrOIIHolg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDozMzozM1rOIIHuMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM4NDU5OA==", "bodyText": "stopped = true? Could be an undesired stop, right?", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r545384598", "createdAt": "2020-12-17T20:30:59Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<BlockInfo> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockHeaderValidator;\n+\n+    private final BlockValidator blockValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockHeaderValidator, @Nonnull BlockValidator blockValidator,\n+                                   @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.blockHeaderValidator = blockHeaderValidator;\n+        this.blockValidator = blockValidator;\n+        this.listener = listener;\n+    }\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockHeaderValidator, @Nonnull BlockValidator blockValidator) {\n+        this(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, blockHeaderValidator, blockValidator, null);\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        final Instant start = Instant.now();\n+\n+        final long blockNumber = block.getNumber();\n+        final String blockHash = block.getPrintableHash();\n+        final String peer = sender != null ? sender.getPeerNodeID().toString() : \"N/A\";\n+\n+        // Validate block header first to see if its PoW is valid at all\n+        if (!isBlockHeaderValid(block)) {\n+            logger.warn(\"Invalid block with number {} {} from {} \", blockNumber, blockHash, peer);\n+            return invalidBlockResult(block, start);\n+        }\n+\n+        // Check if block is already in the queue\n+        if (store.hasBlock(block)) {\n+            logger.trace(\"Ignored block with number {} and hash {} from {} as it's already in the queue\", blockNumber, blockHash, peer);\n+            return ignoreBlockResult(block, start);\n+        }\n+\n+        // Check if block is ready for processing - if the block is not too advanced, its parent block is in place etc.\n+        boolean readyForProcessing = blockSyncService.preprocessBlock(block, sender, false);\n+        if (readyForProcessing) {\n+            // Validate block if it can be added to the queue for processing\n+            if (isBlockValid(block)) {\n+                boolean offer = blocksToProcess.offer(new BlockInfo(sender, block));\n+                if (offer) {\n+                    logger.trace(\"Added block with number {} and hash {} from {} to the queue\", blockNumber, blockHash, peer);\n+                } else {\n+                    // This should not happen as the queue is unbounded\n+                    logger.warn(\"Cannot add block for processing into the queue with number {} {} from {}\", blockNumber, blockHash, peer);\n+                }\n+\n+                return scheduledForProcessingResult(block, start);\n+            }\n+\n+            logger.warn(\"Invalid block with number {} {} from {} \", blockNumber, blockHash, peer);\n+            return invalidBlockResult(block, start);\n+        }\n+\n+        logger.trace(\"Ignored block with number {} and hash {} from {} as it's not ready for processing yet\", blockNumber, blockHash, peer);\n+        return ignoreBlockResult(block, start);\n+    }\n+\n+    @Override\n+    public void start() {\n+        thread.start();\n+    }\n+\n+    @Override\n+    public void stop() {\n+        stopThread();\n+    }\n+\n+    /**\n+     * Stop the service and wait until a working thread is stopped for {@code waitMillis} milliseconds,\n+     * if {@code waitMillis} greater than zero. If {@code waitMillis} is zero, then immediately returns.\n+     */\n+    public void stopAndWait(long waitMillis) throws InterruptedException {\n+        stopThread();\n+\n+        if (waitMillis > 0L) {\n+            thread.join(waitMillis);\n+        }\n+    }\n+\n+    private void stopThread() {\n+        stopped = true;\n+        thread.interrupt();\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (!stopped) {\n+            Peer sender = null;\n+            Block block = null;\n+\n+            try {\n+                logger.trace(\"Awaiting block for processing from the queue...\");\n+\n+                BlockInfo blockInfo = blocksToProcess.take();\n+\n+                sender = blockInfo.peer;\n+                block = blockInfo.block;\n+\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"Start block processing with number {} and hash {} from {}\", block.getNumber(), block.getPrintableHash(), sender);\n+                }\n+\n+                BlockProcessResult blockProcessResult = blockSyncService.processBlock(block, sender, false);\n+                logger.trace(\"Finished block processing\");\n+\n+                if (listener != null) {\n+                    listener.onBlockProcessed(this, sender, block, blockProcessResult);\n+                }\n+            } catch (InterruptedException e) {\n+                logger.trace(\"Thread has been interrupted\");\n+\n+                Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2db0d6e6f1d60a415b0456338f54c34e673879f8"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM4NjAzNQ==", "bodyText": "I would separate the logic of \"adding to the queue\" in another method, and check for \"stopped\" flag.\nThen you could decide to log(that it is stopped) or log/stop the node(?)", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r545386035", "createdAt": "2020-12-17T20:33:33Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<BlockInfo> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockHeaderValidator;\n+\n+    private final BlockValidator blockValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockHeaderValidator, @Nonnull BlockValidator blockValidator,\n+                                   @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.blockHeaderValidator = blockHeaderValidator;\n+        this.blockValidator = blockValidator;\n+        this.listener = listener;\n+    }\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockHeaderValidator, @Nonnull BlockValidator blockValidator) {\n+        this(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, blockHeaderValidator, blockValidator, null);\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        final Instant start = Instant.now();\n+\n+        final long blockNumber = block.getNumber();\n+        final String blockHash = block.getPrintableHash();\n+        final String peer = sender != null ? sender.getPeerNodeID().toString() : \"N/A\";\n+\n+        // Validate block header first to see if its PoW is valid at all\n+        if (!isBlockHeaderValid(block)) {\n+            logger.warn(\"Invalid block with number {} {} from {} \", blockNumber, blockHash, peer);\n+            return invalidBlockResult(block, start);\n+        }\n+\n+        // Check if block is already in the queue\n+        if (store.hasBlock(block)) {\n+            logger.trace(\"Ignored block with number {} and hash {} from {} as it's already in the queue\", blockNumber, blockHash, peer);\n+            return ignoreBlockResult(block, start);\n+        }\n+\n+        // Check if block is ready for processing - if the block is not too advanced, its parent block is in place etc.\n+        boolean readyForProcessing = blockSyncService.preprocessBlock(block, sender, false);\n+        if (readyForProcessing) {\n+            // Validate block if it can be added to the queue for processing\n+            if (isBlockValid(block)) {\n+                boolean offer = blocksToProcess.offer(new BlockInfo(sender, block));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2db0d6e6f1d60a415b0456338f54c34e673879f8"}, "originalPosition": 104}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2db0d6e6f1d60a415b0456338f54c34e673879f8", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/2db0d6e6f1d60a415b0456338f54c34e673879f8", "committedDate": "2020-11-26T17:28:29Z", "message": "Added validation of block header in BlockSyncService"}, "afterCommit": {"oid": "36f76228f35dad42be9496b2a28c8bee850ade5f", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/36f76228f35dad42be9496b2a28c8bee850ade5f", "committedDate": "2020-12-21T13:28:01Z", "message": "Extracted adding block to queue into separate method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NDY3NTI0", "url": "https://github.com/rsksmart/rskj/pull/1326#pullrequestreview-556467524", "createdAt": "2020-12-21T15:35:54Z", "commit": {"oid": "36f76228f35dad42be9496b2a28c8bee850ade5f"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "36f76228f35dad42be9496b2a28c8bee850ade5f", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/36f76228f35dad42be9496b2a28c8bee850ade5f", "committedDate": "2020-12-21T13:28:01Z", "message": "Extracted adding block to queue into separate method"}, "afterCommit": {"oid": "20740f831fd5b0b1f6b70068f409360ea7e20642", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/20740f831fd5b0b1f6b70068f409360ea7e20642", "committedDate": "2021-01-18T13:20:19Z", "message": "Extracted adding block to queue into separate method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6dfaacb30a4cfef5098686fb9c4e866f86b5657", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/c6dfaacb30a4cfef5098686fb9c4e866f86b5657", "committedDate": "2021-01-19T17:05:47Z", "message": "Implemented block propagation enhancements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14d34abd39f6cf4ffc64856f8adff8be2b7f37b8", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/14d34abd39f6cf4ffc64856f8adff8be2b7f37b8", "committedDate": "2021-01-19T17:05:47Z", "message": "Added block validation logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9740378bf8ab7c3a078ee51f25a82694ed08d1af", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/9740378bf8ab7c3a078ee51f25a82694ed08d1af", "committedDate": "2021-01-19T17:05:47Z", "message": "Added check if block is already in net store; Minor refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef3684c87d8f7f3ee55aa5a3cf4438c8ce6cbcdd", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/ef3684c87d8f7f3ee55aa5a3cf4438c8ce6cbcdd", "committedDate": "2021-01-19T17:05:48Z", "message": "Added test for a case when block is invalid"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f78cd7e6e73a7cdc5f6b1c550201236ac990f63", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/4f78cd7e6e73a7cdc5f6b1c550201236ac990f63", "committedDate": "2021-01-19T17:05:48Z", "message": "Added prior block header validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f0dca3cc67866455b317383b84ff521062021f9", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/2f0dca3cc67866455b317383b84ff521062021f9", "committedDate": "2021-01-19T17:05:48Z", "message": "Used BlockProcessResult's factory methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a4184a3699928c243b65a1b30c27062b3ed70bf", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/3a4184a3699928c243b65a1b30c27062b3ed70bf", "committedDate": "2021-01-19T17:05:48Z", "message": "Moved AsyncNodeBlockProcessor creation to getNodeBlockProcessor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6afe2097287088d0d4142bf4bd2645e42911147e", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/6afe2097287088d0d4142bf4bd2645e42911147e", "committedDate": "2021-01-19T17:05:48Z", "message": "Return false for genesis block in relay validators"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e4d0fb770dd63448c62dd05843daed90baca553", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/7e4d0fb770dd63448c62dd05843daed90baca553", "committedDate": "2021-01-19T17:05:48Z", "message": "Added validation of block header in BlockSyncService"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3ff9f1d5199aafb98bca2b2e68515248d843ac8", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/f3ff9f1d5199aafb98bca2b2e68515248d843ac8", "committedDate": "2021-01-19T17:05:48Z", "message": "Extracted adding block to queue into separate method"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "20740f831fd5b0b1f6b70068f409360ea7e20642", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/20740f831fd5b0b1f6b70068f409360ea7e20642", "committedDate": "2021-01-18T13:20:19Z", "message": "Extracted adding block to queue into separate method"}, "afterCommit": {"oid": "f3ff9f1d5199aafb98bca2b2e68515248d843ac8", "author": {"user": {"login": "Vovchyk", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/f3ff9f1d5199aafb98bca2b2e68515248d843ac8", "committedDate": "2021-01-19T17:05:48Z", "message": "Extracted adding block to queue into separate method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcxNTIwMDM5", "url": "https://github.com/rsksmart/rskj/pull/1326#pullrequestreview-571520039", "createdAt": "2021-01-19T18:14:17Z", "commit": {"oid": "f3ff9f1d5199aafb98bca2b2e68515248d843ac8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 574, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}