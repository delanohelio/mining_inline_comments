{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2NDk4MTE4", "number": 1258, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjoyMToyM1rOEHjDlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNToyMTo0NFrOExQHtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzQ5ODQ0OnYy", "diffSide": "RIGHT", "path": "rskj-core/build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjoyMToyM1rOGm-N8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMzoyMjoxNVrOGnAWUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxODQ1MA==", "bodyText": "could you explain a bit more why we need this? Does it mean that the final jar will contain test classes?", "url": "https://github.com/rsksmart/rskj/pull/1258#discussion_r443518450", "createdAt": "2020-06-22T12:21:23Z", "author": {"login": "Vovchyk"}, "path": "rskj-core/build.gradle", "diffHunk": "@@ -217,6 +219,7 @@ task jar(type:Jar, overwrite: true, dependsOn: generateResources) {\n     }\n     from sourceSets.main.output.classesDirs\n     from sourceSets.main.output.resourcesDir\n+    from sourceSets.test.output.classesDirs //Just for TestSystemProperties", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9934370ea1076574bced91f013e729757e8b16a0"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU1MzM2Mw==", "bodyText": "Nice catch! Forgot to remove it, i added it when playing with benchmarking tool.", "url": "https://github.com/rsksmart/rskj/pull/1258#discussion_r443553363", "createdAt": "2020-06-22T13:22:15Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/build.gradle", "diffHunk": "@@ -217,6 +219,7 @@ task jar(type:Jar, overwrite: true, dependsOn: generateResources) {\n     }\n     from sourceSets.main.output.classesDirs\n     from sourceSets.main.output.resourcesDir\n+    from sourceSets.test.output.classesDirs //Just for TestSystemProperties", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxODQ1MA=="}, "originalCommit": {"oid": "9934370ea1076574bced91f013e729757e8b16a0"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5Njk1ODMwOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/remasc/RemascTransaction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNjoyMzo1MlrOHJMyYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODo0NjozNFrOHJQ-tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQwODczOA==", "bodyText": "synchronized seems off here", "url": "https://github.com/rsksmart/rskj/pull/1258#discussion_r479408738", "createdAt": "2020-08-28T16:23:52Z", "author": {"login": "nicops"}, "path": "rskj-core/src/main/java/co/rsk/remasc/RemascTransaction.java", "diffHunk": "@@ -73,7 +74,7 @@ public long transactionCost(Constants constants, ActivationConfig.ForBlock activ\n     }\n \n     @Override\n-    public RskAddress getSender() {\n+    public synchronized RskAddress getSender(ActivationConfig.ForBlock activations, SignatureCache signatureCache) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16bed9721d142d0a57237d80b8ea9a360368f808"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3NzQzMA==", "bodyText": "It's definitely off for me too. In both remasc and normal transactions", "url": "https://github.com/rsksmart/rskj/pull/1258#discussion_r479477430", "createdAt": "2020-08-28T18:46:34Z", "author": {"login": "donequis"}, "path": "rskj-core/src/main/java/co/rsk/remasc/RemascTransaction.java", "diffHunk": "@@ -73,7 +74,7 @@ public long transactionCost(Constants constants, ActivationConfig.ForBlock activ\n     }\n \n     @Override\n-    public RskAddress getSender() {\n+    public synchronized RskAddress getSender(ActivationConfig.ForBlock activations, SignatureCache signatureCache) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQwODczOA=="}, "originalCommit": {"oid": "16bed9721d142d0a57237d80b8ea9a360368f808"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDc5Nzk2OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/org/ethereum/crypto/signature/Secp256k1ServiceNative.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNToyMTo0NFrOHnSfHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNDo0NzoyMlrOHyxKiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk1OTM4OA==", "bodyText": "This method is ugly when r and s are longer than 32 bytes. If we prepend garbage before the real r and s values, those bytes will be ignored. This does not happen with the BC implementation.\nThere's no immediate issue with that because the Transaction class does an extra validation on the r and s components, but those are not the only places where the recover from signature is used, causing some ugly cases there.\nI think that we should fail quickly here. If r or s are too big.", "url": "https://github.com/rsksmart/rskj/pull/1258#discussion_r510959388", "createdAt": "2020-10-23T15:21:44Z", "author": {"login": "donequis"}, "path": "rskj-core/src/main/java/org/ethereum/crypto/signature/Secp256k1ServiceNative.java", "diffHunk": "@@ -19,10 +19,88 @@\n \n package org.ethereum.crypto.signature;\n \n+import org.bitcoin.NativeSecp256k1;\n+import org.bitcoin.NativeSecp256k1Exception;\n+import org.ethereum.crypto.ECKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+\n+import static java.lang.System.arraycopy;\n+\n /**\n  * Implementation of SignatureService with Native library.\n- * TODO: once integrated native implementation, should implement all methods.\n  */\n public class Secp256k1ServiceNative extends Secp256k1ServiceBC {\n \n+    private static final Logger logger = LoggerFactory.getLogger(Secp256k1ServiceNative.class);\n+    private static final byte[] ZERO_PUB = {0};\n+\n+    @Nullable\n+    @Override\n+    public ECKey recoverFromSignature(int recId, ECDSASignature sig, byte[] messageHash, boolean compressed) {\n+        check(recId >= 0, \"recId must be positive\");\n+        check(sig.getR().signum() >= 0, \"r must be positive\");\n+        check(sig.getS().signum() >= 0, \"s must be positive\");\n+        check(messageHash != null, \"messageHash must not be null\");\n+        byte[] pbKey;\n+        try {\n+            byte[] sigBytes = concatenate(sig);\n+            logger.trace(\"Recovering key from signature: comporessed[{}] - recId[{}] - sig[{}] - msgHash[{}].\", compressed, recId, sigBytes, messageHash);\n+            try {\n+                pbKey = NativeSecp256k1.ecdsaRecover(sigBytes, messageHash, recId, compressed);\n+            } catch (NativeSecp256k1Exception e) {\n+                if (NativeSecp256k1.isInfinity(sigBytes, messageHash, recId)) {\n+                    return ECKey.fromPublicOnly(ZERO_PUB);\n+                }\n+                throw e;\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Couldnt recover key from signature.\", e);\n+            return null;\n+        }\n+        return ECKey.fromPublicOnly(pbKey);\n+    }\n+\n+    /**\n+     * Returns a (r.length + s.length) bytes array long\n+     *\n+     * Note: we take 32 bytes from \"r\" and 32 bytes from \"s\".\n+     *\n+     * @param sig {r,s}\n+     * @return r + s (64 length byte array)\n+     */\n+    byte[] concatenate(ECDSASignature sig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1261187901cc452b35032d861288bf89c934d850"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk5NjM2Mw==", "bodyText": "fixed.", "url": "https://github.com/rsksmart/rskj/pull/1258#discussion_r522996363", "createdAt": "2020-11-13T14:47:22Z", "author": {"login": "patogallaiovlabs"}, "path": "rskj-core/src/main/java/org/ethereum/crypto/signature/Secp256k1ServiceNative.java", "diffHunk": "@@ -19,10 +19,88 @@\n \n package org.ethereum.crypto.signature;\n \n+import org.bitcoin.NativeSecp256k1;\n+import org.bitcoin.NativeSecp256k1Exception;\n+import org.ethereum.crypto.ECKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+\n+import static java.lang.System.arraycopy;\n+\n /**\n  * Implementation of SignatureService with Native library.\n- * TODO: once integrated native implementation, should implement all methods.\n  */\n public class Secp256k1ServiceNative extends Secp256k1ServiceBC {\n \n+    private static final Logger logger = LoggerFactory.getLogger(Secp256k1ServiceNative.class);\n+    private static final byte[] ZERO_PUB = {0};\n+\n+    @Nullable\n+    @Override\n+    public ECKey recoverFromSignature(int recId, ECDSASignature sig, byte[] messageHash, boolean compressed) {\n+        check(recId >= 0, \"recId must be positive\");\n+        check(sig.getR().signum() >= 0, \"r must be positive\");\n+        check(sig.getS().signum() >= 0, \"s must be positive\");\n+        check(messageHash != null, \"messageHash must not be null\");\n+        byte[] pbKey;\n+        try {\n+            byte[] sigBytes = concatenate(sig);\n+            logger.trace(\"Recovering key from signature: comporessed[{}] - recId[{}] - sig[{}] - msgHash[{}].\", compressed, recId, sigBytes, messageHash);\n+            try {\n+                pbKey = NativeSecp256k1.ecdsaRecover(sigBytes, messageHash, recId, compressed);\n+            } catch (NativeSecp256k1Exception e) {\n+                if (NativeSecp256k1.isInfinity(sigBytes, messageHash, recId)) {\n+                    return ECKey.fromPublicOnly(ZERO_PUB);\n+                }\n+                throw e;\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Couldnt recover key from signature.\", e);\n+            return null;\n+        }\n+        return ECKey.fromPublicOnly(pbKey);\n+    }\n+\n+    /**\n+     * Returns a (r.length + s.length) bytes array long\n+     *\n+     * Note: we take 32 bytes from \"r\" and 32 bytes from \"s\".\n+     *\n+     * @param sig {r,s}\n+     * @return r + s (64 length byte array)\n+     */\n+    byte[] concatenate(ECDSASignature sig) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk1OTM4OA=="}, "originalCommit": {"oid": "1261187901cc452b35032d861288bf89c934d850"}, "originalPosition": 57}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4426, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}