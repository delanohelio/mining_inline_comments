{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyNDc4MTc1", "number": 1350, "title": "Create pre-validations for the RegisterBtcTransfer function", "bodyText": "This commit is only based on creating the previous validations for this function. It does not include the logic of the functionality itself.", "createdAt": "2020-10-29T18:32:42Z", "url": "https://github.com/rsksmart/rskj/pull/1350", "merged": true, "mergeCommit": {"oid": "7832ef18fb663a6351f8636c9b52ac751bfcdac2"}, "closed": true, "closedAt": "2020-11-05T16:24:58Z", "author": {"login": "pamgonzalez"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdXYx6cABqjM5Mzg0NTczMDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZkVS1gFqTUyNDM5Njk3MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "26eefc912701bfc49a98cf891e7e2fa72f3e0cb7", "author": {"user": null}, "url": "https://github.com/rsksmart/rskj/commit/26eefc912701bfc49a98cf891e7e2fa72f3e0cb7", "committedDate": "2020-10-29T14:14:54Z", "message": "Create pre-validations for the RegisterBtcTransfer function\n\nThis commit is only based on creating the previous validations for this function. It does not include the logic of the functionality itself."}, "afterCommit": {"oid": "965855cc39d1dd237891b58262f24eebb3b47fb1", "author": {"user": null}, "url": "https://github.com/rsksmart/rskj/commit/965855cc39d1dd237891b58262f24eebb3b47fb1", "committedDate": "2020-10-29T21:05:53Z", "message": "Create pre-validations for the RegisterBtcTransfer function\n\nThis commit is only based on creating the previous validations for this function. It does not include the logic of the functionality itself."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "author": {"user": null}, "url": "https://github.com/rsksmart/rskj/commit/a963d710cc14b9a01dbd69124f5fd9122baa06b0", "committedDate": "2020-10-30T13:12:07Z", "message": "Create pre-validations for the RegisterBtcTransfer function\n\nThis commit is only based on creating the previous validations for this function. It does not include the logic of the functionality itself."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "965855cc39d1dd237891b58262f24eebb3b47fb1", "author": {"user": null}, "url": "https://github.com/rsksmart/rskj/commit/965855cc39d1dd237891b58262f24eebb3b47fb1", "committedDate": "2020-10-29T21:05:53Z", "message": "Create pre-validations for the RegisterBtcTransfer function\n\nThis commit is only based on creating the previous validations for this function. It does not include the logic of the functionality itself."}, "afterCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "author": {"user": null}, "url": "https://github.com/rsksmart/rskj/commit/a963d710cc14b9a01dbd69124f5fd9122baa06b0", "committedDate": "2020-10-30T13:12:07Z", "message": "Create pre-validations for the RegisterBtcTransfer function\n\nThis commit is only based on creating the previous validations for this function. It does not include the logic of the functionality itself."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNjU3MzQ1", "url": "https://github.com/rsksmart/rskj/pull/1350#pullrequestreview-520657345", "createdAt": "2020-10-30T13:19:04Z", "commit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoxOTowNFrOHrOlLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoxOTowNFrOHrOlLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA4OTcxMA==", "bodyText": "Variable should be errorMessage", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515089710", "createdAt": "2020-10-30T13:19:04Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNjYxNjAx", "url": "https://github.com/rsksmart/rskj/pull/1350#pullrequestreview-520661601", "createdAt": "2020-10-30T13:23:38Z", "commit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoyMzozOFrOHrOx1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoyMzozOFrOHrOx1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5Mjk0OA==", "bodyText": "Same typo, variable should beerrorMessage, and should add new line", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515092948", "createdAt": "2020-10-30T13:23:38Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n+\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNjYzMTEw", "url": "https://github.com/rsksmart/rskj/pull/1350#pullrequestreview-520663110", "createdAt": "2020-10-30T13:25:17Z", "commit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoyNToxN1rOHrO19g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoyNToxN1rOHrO19g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5NDAwNg==", "bodyText": "Condition here should be true, we are checking if derivation arguments hash was already used", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515094006", "createdAt": "2020-10-30T13:25:17Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n+\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMesage);\n+        }\n+\n+        if (!provider.isFastBridgeFederationDerivationHashUsed(derivationArgumentsHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already saved in BridgeStorageProvider \", btcTxHash);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNjcwNDMx", "url": "https://github.com/rsksmart/rskj/pull/1350#pullrequestreview-520670431", "createdAt": "2020-10-30T13:33:33Z", "commit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozMzozM1rOHrPK8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozMzozM1rOHrPK8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5OTM3Ng==", "bodyText": "getSenderBtcAddress & getAmountToActiveFederation are duplicating existing code on processPegin. That method should be invoked from processPegin.", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515099376", "createdAt": "2020-10-30T13:33:33Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n+\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMesage);\n+        }\n+\n+        if (!provider.isFastBridgeFederationDerivationHashUsed(derivationArgumentsHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already saved in BridgeStorageProvider \", btcTxHash);\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract){\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False \", btcTxHash);\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(\n+                btcTx,\n+                this.getSenderBtcAddress(btcTx),\n+                totalAmount\n+        )) {\n+            generateRejectionRelease(btcTx, lpbtcAddress, rskTx, totalAmount, true);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    private Address getSenderBtcAddress(BtcTransaction btcTx) throws GetSenderBtcAddressSenderNotPresentException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNjcxMTEx", "url": "https://github.com/rsksmart/rskj/pull/1350#pullrequestreview-520671111", "createdAt": "2020-10-30T13:34:02Z", "commit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozNDowMlrOHrPMJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozNDowMlrOHrPMJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5OTY4Nw==", "bodyText": "Missing new line.", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515099687", "createdAt": "2020-10-30T13:34:02Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/GetSenderBtcAddressSenderNotPresentException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class GetSenderBtcAddressSenderNotPresentException extends RegisterBtcTransferException{\n+    public GetSenderBtcAddressSenderNotPresentException(String message) {\n+        super(message);\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNjc0Njk3", "url": "https://github.com/rsksmart/rskj/pull/1350#pullrequestreview-520674697", "createdAt": "2020-10-30T13:38:10Z", "commit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozODoxMFrOHrPYrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozODoxMFrOHrPYrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjg5NA==", "bodyText": "Missing new line.", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515102894", "createdAt": "2020-10-30T13:38:10Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferContractValidationException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class RegisterBtcTransferContractValidationException extends RegisterBtcTransferException {\n+    public RegisterBtcTransferContractValidationException(String message) {\n+        super(message);\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNjc0Nzgy", "url": "https://github.com/rsksmart/rskj/pull/1350#pullrequestreview-520674782", "createdAt": "2020-10-30T13:38:18Z", "commit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozODoxOFrOHrPY4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozODoxOFrOHrPY4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjk0NQ==", "bodyText": "Missing new line.", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515102945", "createdAt": "2020-10-30T13:38:18Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class RegisterBtcTransferException extends Exception {\n+    public RegisterBtcTransferException(String message) {\n+        super(message);\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNjc0ODk5", "url": "https://github.com/rsksmart/rskj/pull/1350#pullrequestreview-520674899", "createdAt": "2020-10-30T13:38:27Z", "commit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozODoyN1rOHrPZOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozODoyN1rOHrPZOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMzAzNQ==", "bodyText": "Missing new line.", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515103035", "createdAt": "2020-10-30T13:38:27Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferRegisterBtcTransValidationException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class RegisterBtcTransferRegisterBtcTransValidationException extends RegisterBtcTransferException{\n+    public RegisterBtcTransferRegisterBtcTransValidationException(String message) {\n+        super(message);\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNjc2NjUy", "url": "https://github.com/rsksmart/rskj/pull/1350#pullrequestreview-520676652", "createdAt": "2020-10-30T13:40:18Z", "commit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0MDoxOFrOHrPePw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0MDoxOFrOHrPePw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNDMxOQ==", "bodyText": "log and exception should use the same string for error, and leave it on a variable", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515104319", "createdAt": "2020-10-30T13:40:18Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n+\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMesage);\n+        }\n+\n+        if (!provider.isFastBridgeFederationDerivationHashUsed(derivationArgumentsHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already saved in BridgeStorageProvider \", btcTxHash);\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract){\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False \", btcTxHash);\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(\n+                btcTx,\n+                this.getSenderBtcAddress(btcTx),\n+                totalAmount\n+        )) {\n+            generateRejectionRelease(btcTx, lpbtcAddress, rskTx, totalAmount, true);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    private Address getSenderBtcAddress(BtcTransaction btcTx) throws GetSenderBtcAddressSenderNotPresentException {\n+        Optional<BtcLockSender> btcLockSenderOptional = btcLockSenderProvider.tryGetBtcLockSender(btcTx);\n+        if (!btcLockSenderOptional.isPresent() ||\n+                !BridgeUtils.txIsProcessable(btcLockSenderOptional.get().getType(), activations)) {\n+            logger.warn(\"[getSenderBtcAddress] [btcTx:{}] Could not get BtcLockSender from Btc tx\", btcTx.getHash());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNjc4NTUz", "url": "https://github.com/rsksmart/rskj/pull/1350#pullrequestreview-520678553", "createdAt": "2020-10-30T13:42:34Z", "commit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0MjozNFrOHrPkLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0MjozNFrOHrPkLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNTgzNw==", "bodyText": "Before RSKIP 176 this method should not be allowed to be called.", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515105837", "createdAt": "2020-10-30T13:42:34Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4984,275 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+\n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_isNotcontract() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransactionReturnFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNjc5NTE3", "url": "https://github.com/rsksmart/rskj/pull/1350#pullrequestreview-520679517", "createdAt": "2020-10-30T13:43:44Z", "commit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0Mzo0NFrOHrPmxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0Mzo0NFrOHrPmxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNjUwMg==", "bodyText": "Unused variable hash", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515106502", "createdAt": "2020-10-30T13:43:44Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4984,275 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+\n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_isNotcontract() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransactionReturnFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(false);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        );\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                pmtSerialized,\n+                height,\n+                btcTxSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_providerFastBridgeFederationScriptHashReturnNotPresent() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNjgxMDA3", "url": "https://github.com/rsksmart/rskj/pull/1350#pullrequestreview-520681007", "createdAt": "2020-10-30T13:45:19Z", "commit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0NToxOVrOHrPrEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0NToxOVrOHrPrEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNzYwMA==", "bodyText": "Line too long", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515107600", "createdAt": "2020-10-30T13:45:19Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4984,275 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+\n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_isNotcontract() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransactionReturnFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(false);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        );\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                pmtSerialized,\n+                height,\n+                btcTxSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_providerFastBridgeFederationScriptHashReturnNotPresent() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(BridgeEventLogger.class),\n+                new BtcLockSenderProvider(),\n+                mock(Repository.class),\n+                mock(Block.class),\n+                mock(Context.class),\n+                mock(FederationSupport.class),\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        ));\n+\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Coin.valueOf(1)).when(bridgeSupport).getAmountToActiveFederation(any());\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                pmtSerialized,\n+                height,\n+                btcTxSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_shouldTransferToContractFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 120}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNjgyMTkx", "url": "https://github.com/rsksmart/rskj/pull/1350#pullrequestreview-520682191", "createdAt": "2020-10-30T13:46:38Z", "commit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0NjozOVrOHrPugg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0NjozOVrOHrPugg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwODQ4Mg==", "bodyText": "I think we should avoid using raw transactions", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515108482", "createdAt": "2020-10-30T13:46:39Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4984,275 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+\n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_isNotcontract() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransactionReturnFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(false);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        );\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                pmtSerialized,\n+                height,\n+                btcTxSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_providerFastBridgeFederationScriptHashReturnNotPresent() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(BridgeEventLogger.class),\n+                new BtcLockSenderProvider(),\n+                mock(Repository.class),\n+                mock(Block.class),\n+                mock(Context.class),\n+                mock(FederationSupport.class),\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        ));\n+\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Coin.valueOf(1)).when(bridgeSupport).getAmountToActiveFederation(any());\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                pmtSerialized,\n+                height,\n+                btcTxSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_shouldTransferToContractFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0"}, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2875daea8888eccb681f837dc68ed932caf4315", "author": {"user": {"login": "guidohernan93", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/f2875daea8888eccb681f837dc68ed932caf4315", "committedDate": "2020-11-04T19:06:16Z", "message": "Update registerBtcTransfer signature\n\n- Update BridgeMethods and Bridge classes to cast BTC addresses as bytes\n- Update tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjk0NDM5", "url": "https://github.com/rsksmart/rskj/pull/1350#pullrequestreview-523694439", "createdAt": "2020-11-04T20:03:24Z", "commit": {"oid": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDowMzoyNVrOHtnwEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyMTowMFrOHtoTYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU5OTI1MQ==", "bodyText": "Mark with Ok in the function name if the test is a successful one", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r517599251", "createdAt": "2020-11-04T20:03:25Z", "author": {"login": "pamgonzalez"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4985,467 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_is_not_contract()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransaction_returns_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeStorageProvider provider = mock(BridgeStorageProvider.class);\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+            bridgeConstants,\n+            provider,\n+            mock(Repository.class),\n+            mock(BridgeEventLogger.class),\n+            null,\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        );\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            mock(Address.class),\n+            mock(RskAddress.class),\n+            mock(Address.class),\n+            true);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_derivation_arguments_hash_already_used()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeStorageProvider provider = mock(BridgeStorageProvider.class);\n+        when(provider.isFastBridgeFederationDerivationHashUsed(any(Sha256Hash.class))).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+                bridgeConstants,\n+                provider,\n+                mock(BridgeEventLogger.class),\n+                new BtcLockSenderProvider(),\n+                mock(Repository.class),\n+                mock(Block.class),\n+                btcContext,\n+                mock(FederationSupport.class),\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                tx.bitcoinSerialize(),\n+                100,\n+                pmtSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                btcAddress,\n+                lbcAddress,\n+                btcAddress,\n+                true\n+        );\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_shouldTransferToContract_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            new BtcLockSenderProvider(),\n+            mock(Repository.class),\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            false\n+        );\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_verifyLockDoesNotSurpassLockingCap_returns_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+        when(activations.isActive(ConsensusRule.RSKIP134)).thenReturn(true);\n+\n+        BtcLockSender btcLockSender = mock(BtcLockSender.class);\n+        BtcLockSenderProvider btcLockSenderProvider = mock(BtcLockSenderProvider.class);\n+        when(btcLockSenderProvider.tryGetBtcLockSender(any())).thenReturn(Optional.of(btcLockSender));\n+\n+        Repository repository = mock(Repository.class);\n+        when(repository.getBalance(any())).thenReturn(co.rsk.core.Coin.valueOf(1));\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            btcLockSenderProvider,\n+            repository,\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Coin.COIN).when(bridgeSupport).getLockingCap();\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            true\n+        );\n+\n+        Assert.assertEquals(-2, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_OK()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            new BtcLockSenderProvider(),\n+            mock(Repository.class),\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            true\n+        );\n+\n+        Assert.assertEquals(1, result);\n+    }\n+\n+    @Test\n+    public void getUTXOsForAddress() {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(Repository.class),\n+            mock(BridgeEventLogger.class),\n+            null,\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        List<UTXO> utxoList = new ArrayList<>();\n+        UTXO utxo = new UTXO(tx.getHash(), 0, Coin.COIN, 0, false, fastBridgeP2SH);\n+        utxoList.add(utxo);\n+\n+        Assert.assertEquals(utxoList, bridgeSupport.getUTXOsForAddress(tx, fastBridgeFedAddress));\n+    }\n+\n+    @Test\n+    public void getUTXOsForAddress_no_utxos_for_address() {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(Repository.class),\n+            mock(BridgeEventLogger.class),\n+            null,\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        Assert.assertEquals(Collections.emptyList(), bridgeSupport.getUTXOsForAddress(tx, btcAddress));\n+    }\n+\n+    @Test\n+    public void getFastBridgeWallet() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f"}, "originalPosition": 467}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwMDk0OQ==", "bodyText": "Mark with Ok in the function name if the test is a successful one", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r517600949", "createdAt": "2020-11-04T20:06:42Z", "author": {"login": "pamgonzalez"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4985,467 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_is_not_contract()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransaction_returns_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeStorageProvider provider = mock(BridgeStorageProvider.class);\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+            bridgeConstants,\n+            provider,\n+            mock(Repository.class),\n+            mock(BridgeEventLogger.class),\n+            null,\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        );\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            mock(Address.class),\n+            mock(RskAddress.class),\n+            mock(Address.class),\n+            true);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_derivation_arguments_hash_already_used()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeStorageProvider provider = mock(BridgeStorageProvider.class);\n+        when(provider.isFastBridgeFederationDerivationHashUsed(any(Sha256Hash.class))).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+                bridgeConstants,\n+                provider,\n+                mock(BridgeEventLogger.class),\n+                new BtcLockSenderProvider(),\n+                mock(Repository.class),\n+                mock(Block.class),\n+                btcContext,\n+                mock(FederationSupport.class),\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                tx.bitcoinSerialize(),\n+                100,\n+                pmtSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                btcAddress,\n+                lbcAddress,\n+                btcAddress,\n+                true\n+        );\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_shouldTransferToContract_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            new BtcLockSenderProvider(),\n+            mock(Repository.class),\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            false\n+        );\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_verifyLockDoesNotSurpassLockingCap_returns_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+        when(activations.isActive(ConsensusRule.RSKIP134)).thenReturn(true);\n+\n+        BtcLockSender btcLockSender = mock(BtcLockSender.class);\n+        BtcLockSenderProvider btcLockSenderProvider = mock(BtcLockSenderProvider.class);\n+        when(btcLockSenderProvider.tryGetBtcLockSender(any())).thenReturn(Optional.of(btcLockSender));\n+\n+        Repository repository = mock(Repository.class);\n+        when(repository.getBalance(any())).thenReturn(co.rsk.core.Coin.valueOf(1));\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            btcLockSenderProvider,\n+            repository,\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Coin.COIN).when(bridgeSupport).getLockingCap();\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            true\n+        );\n+\n+        Assert.assertEquals(-2, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_OK()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            new BtcLockSenderProvider(),\n+            mock(Repository.class),\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            true\n+        );\n+\n+        Assert.assertEquals(1, result);\n+    }\n+\n+    @Test\n+    public void getUTXOsForAddress() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f"}, "originalPosition": 406}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwNDg0MA==", "bodyText": "why this function is protected?", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r517604840", "createdAt": "2020-11-04T20:14:19Z", "author": {"login": "pamgonzalez"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2072,12 +2081,203 @@ public int registerBtcTransfer(\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            Address lpBtcAddress,\n+            boolean shouldTransferToContract\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n+        }\n+\n+        Context.propagate(btcContext);\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(btcTx, null, totalAmount)) {\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, lpBtcAddress, rskTx, totalAmount, walletProvider);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    protected WalletProvider createWallet() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwODI5MQ==", "bodyText": "I think it does not meet the code standards", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r517608291", "createdAt": "2020-11-04T20:21:00Z", "author": {"login": "pamgonzalez"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2222,8 +2462,8 @@ private boolean verifyLockDoesNotSurpassLockingCap(BtcTransaction btcTx, Address\n         return false;\n     }\n \n-    private Optional<ReleaseTransactionBuilder.BuildResult> getRefundingTransaction(BtcTransaction btcTx, Address senderBtcAddress, boolean isFastBridgeCompatible) throws IOException {\n-\n+    private Optional<ReleaseTransactionBuilder.BuildResult> getRefundingTransaction(\n+        BtcTransaction btcTx, Address refundingBtcAddress, boolean isFastBridgeCompatible) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f"}, "originalPosition": 360}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f", "author": {"user": {"login": "guidohernan93", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f", "committedDate": "2020-11-04T19:07:14Z", "message": "Fixes on method registerBtcTransfer\n\n- Refactor generateRejectionRelease to receive a lambda function for creating Wallet\n- Add method to create fast bridge wallet\n- Add method to get list of utxos for a given BTC address\n- Update unit tests"}, "afterCommit": {"oid": "e7c52562dc083831ee9b8827ad79706b27034c2e", "author": {"user": {"login": "guidohernan93", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/e7c52562dc083831ee9b8827ad79706b27034c2e", "committedDate": "2020-11-05T12:45:27Z", "message": "Fixes on method registerBtcTransfer\n\n- Refactor generateRejectionRelease to receive a lambda function for creating Wallet\n- Add method to create fast bridge wallet\n- Add method to get list of utxos for a given BTC address\n- Update unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MjIzNDE5", "url": "https://github.com/rsksmart/rskj/pull/1350#pullrequestreview-524223419", "createdAt": "2020-11-05T12:44:41Z", "commit": {"oid": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjo0NDo0MVrOHuBm0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjo1ODoxMlrOHuCFww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAyMjg2NA==", "bodyText": "Bridge should not throw any of these errors. They should be catched and rethrow as RunTime (at most)...", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518022864", "createdAt": "2020-11-05T12:44:41Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/Bridge.java", "diffHunk": "@@ -1095,17 +1095,17 @@ public boolean hasBtcBlockCoinbaseTransactionInformation(Object[] args) {\n     }\n \n     public int registerBtcTransfer(Object[] args)\n-    {\n+        throws RegisterBtcTransferException, BlockStoreException, IOException, RegisterBtcTransactionException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAyNzgxNA==", "bodyText": "The return code shouldn't be the same, we should probably review the usage of return codes in the RSKIP", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518027814", "createdAt": "2020-11-05T12:53:24Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2072,12 +2068,203 @@ public int registerBtcTransfer(\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            Address lpBtcAddress,\n+            boolean shouldTransferToContract\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n+        }\n+\n+        Context.propagate(btcContext);\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7c52562dc083831ee9b8827ad79706b27034c2e"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAyODIzNw==", "bodyText": "The method doesn't return a Wallet but a WalletProvider, and it creates a fast bridge wallet, please rename the method", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518028237", "createdAt": "2020-11-05T12:54:10Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2072,12 +2068,203 @@ public int registerBtcTransfer(\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            Address lpBtcAddress,\n+            boolean shouldTransferToContract\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n+        }\n+\n+        Context.propagate(btcContext);\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(btcTx, null, totalAmount)) {\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, lpBtcAddress, rskTx, totalAmount, walletProvider);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    private WalletProvider createWallet() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7c52562dc083831ee9b8827ad79706b27034c2e"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAyOTkwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected Coin getAmountToActiveFederation(BtcTransaction btcTx) throws IOException{\n          \n          \n            \n                protected Coin getAmountToLiveFederations(BtcTransaction btcTx) throws IOException{", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518029902", "createdAt": "2020-11-05T12:56:42Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2072,12 +2068,203 @@ public int registerBtcTransfer(\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            Address lpBtcAddress,\n+            boolean shouldTransferToContract\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n+        }\n+\n+        Context.propagate(btcContext);\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(btcTx, null, totalAmount)) {\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, lpBtcAddress, rskTx, totalAmount, walletProvider);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    private WalletProvider createWallet() {\n+        return (BtcTransaction a, Address b) -> {\n+            List<UTXO> utxosList = getUTXOsForAddress(a, b);\n+            return getFastBridgeWallet(btcContext, utxosList);\n+        };\n+    }\n+\n+    protected List<UTXO> getUTXOsForAddress(BtcTransaction btcTx, Address btcAddress) {\n+        List<UTXO> utxosList = new ArrayList<>();\n+        for (TransactionOutput o : btcTx.getOutputs()) {\n+            if (o.getScriptPubKey().getToAddress(bridgeConstants.getBtcParams()).equals(btcAddress)) {\n+                utxosList.add(\n+                    new UTXO(\n+                        btcTx.getHash(),\n+                        o.getIndex(),\n+                        o.getValue(),\n+                        0,\n+                        btcTx.isCoinBase(),\n+                        o.getScriptPubKey()\n+                    )\n+                );\n+            }\n+        }\n+\n+        return utxosList;\n+    }\n+\n+    protected Wallet getFastBridgeWallet(Context btcContext, List<UTXO> utxos) {\n+        Wallet wallet = new Wallet(btcContext);\n+        RskUTXOProvider utxoProvider = new RskUTXOProvider(btcContext.getParams(), utxos);\n+        wallet.setUTXOProvider(utxoProvider);\n+        wallet.setCoinSelector(new RskAllowUnconfirmedCoinSelector());\n+        return wallet;\n+    }\n+\n+    protected Sha256Hash getFastBridgeDerivationHash(\n+        Sha256Hash derivationArgumentsHash,\n+        Address userRefundAddress,\n+        Address lpBtcAddress,\n+        RskAddress lbcAddress\n+    ) {\n+        byte[] fastBridgeDerivationHashData = derivationArgumentsHash.getBytes();\n+        byte[] userRefundAddressBytes = userRefundAddress.getHash160();\n+        byte[] lbcAddressBytes = lbcAddress.getBytes();\n+        byte[] lpBtcAddressBytes = lpBtcAddress.getHash160();\n+\n+        byte[] result = new byte[fastBridgeDerivationHashData.length +\n+            userRefundAddressBytes.length + lpBtcAddressBytes.length + lbcAddressBytes.length];\n+\n+        int dstPosition = 0;\n+\n+        System.arraycopy(\n+            fastBridgeDerivationHashData,\n+            0,\n+            result,\n+            dstPosition,\n+            fastBridgeDerivationHashData.length\n+        );\n+\n+        dstPosition += fastBridgeDerivationHashData.length;\n+\n+        System.arraycopy(\n+            userRefundAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            userRefundAddressBytes.length\n+        );\n+\n+        dstPosition += userRefundAddressBytes.length;\n+\n+        System.arraycopy(\n+            lbcAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            lbcAddressBytes.length\n+        );\n+\n+        dstPosition += lbcAddressBytes.length;\n+\n+        System.arraycopy(\n+            lpBtcAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            lpBtcAddressBytes.length\n+        );\n+\n+        return Sha256Hash.of(result);\n+    }\n+\n+    protected Coin getAmountToActiveFederation(BtcTransaction btcTx) throws IOException{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7c52562dc083831ee9b8827ad79706b27034c2e"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzMDE4OQ==", "bodyText": "not used?", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518030189", "createdAt": "2020-11-05T12:57:12Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/GetSenderBtcAddressSenderNotPresentException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class GetSenderBtcAddressSenderNotPresentException extends RegisterBtcTransferException{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7c52562dc083831ee9b8827ad79706b27034c2e"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzMDc4Nw==", "bodyText": "the name of the exception is kind of confusing", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518030787", "createdAt": "2020-11-05T12:58:12Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferRegisterBtcTransValidationException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class RegisterBtcTransferRegisterBtcTransValidationException extends RegisterBtcTransferException{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7c52562dc083831ee9b8827ad79706b27034c2e"}, "originalPosition": 3}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e7c52562dc083831ee9b8827ad79706b27034c2e", "author": {"user": {"login": "guidohernan93", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/e7c52562dc083831ee9b8827ad79706b27034c2e", "committedDate": "2020-11-05T12:45:27Z", "message": "Fixes on method registerBtcTransfer\n\n- Refactor generateRejectionRelease to receive a lambda function for creating Wallet\n- Add method to create fast bridge wallet\n- Add method to get list of utxos for a given BTC address\n- Update unit tests"}, "afterCommit": {"oid": "922e1987c8211b9196f02eb17955c0fb97e58170", "author": {"user": {"login": "guidohernan93", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/922e1987c8211b9196f02eb17955c0fb97e58170", "committedDate": "2020-11-05T13:30:46Z", "message": "Fixes on method registerBtcTransfer\n\n- Refactor generateRejectionRelease to receive a lambda function for creating Wallet\n- Add method to create fast bridge wallet\n- Add method to get list of utxos for a given BTC address\n- Update unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ba9d46dbd0afb3cbaa59d249cdc0755610d54a3", "author": {"user": {"login": "guidohernan93", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/3ba9d46dbd0afb3cbaa59d249cdc0755610d54a3", "committedDate": "2020-11-05T15:39:20Z", "message": "Fixes on method registerBtcTransfer\n\n- Refactor generateRejectionRelease to receive a lambda function for creating Wallet\n- Add method to create fast bridge wallet\n- Add method to get list of utxos for a given BTC address\n- Update unit tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "922e1987c8211b9196f02eb17955c0fb97e58170", "author": {"user": {"login": "guidohernan93", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/922e1987c8211b9196f02eb17955c0fb97e58170", "committedDate": "2020-11-05T13:30:46Z", "message": "Fixes on method registerBtcTransfer\n\n- Refactor generateRejectionRelease to receive a lambda function for creating Wallet\n- Add method to create fast bridge wallet\n- Add method to get list of utxos for a given BTC address\n- Update unit tests"}, "afterCommit": {"oid": "3ba9d46dbd0afb3cbaa59d249cdc0755610d54a3", "author": {"user": {"login": "guidohernan93", "name": null}}, "url": "https://github.com/rsksmart/rskj/commit/3ba9d46dbd0afb3cbaa59d249cdc0755610d54a3", "committedDate": "2020-11-05T15:39:20Z", "message": "Fixes on method registerBtcTransfer\n\n- Refactor generateRejectionRelease to receive a lambda function for creating Wallet\n- Add method to create fast bridge wallet\n- Add method to get list of utxos for a given BTC address\n- Update unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0Mzk2OTcw", "url": "https://github.com/rsksmart/rskj/pull/1350#pullrequestreview-524396970", "createdAt": "2020-11-05T15:45:11Z", "commit": {"oid": "3ba9d46dbd0afb3cbaa59d249cdc0755610d54a3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 610, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}