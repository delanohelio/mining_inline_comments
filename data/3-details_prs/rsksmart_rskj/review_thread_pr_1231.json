{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzNzQzMTEw", "number": 1231, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNjoyNToyNVrOD6U1gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzozNzoyNlrOEEfkug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNDg1Mzc2OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeUtils.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNjoyNToyNVrOGSGeag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDoxNTozOFrOGlH2pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYzMzY0Mg==", "bodyText": "Maybe it would be better to throw a custom exception", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r421633642", "createdAt": "2020-05-07T16:25:25Z", "author": {"login": "marcos-iov"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeUtils.java", "diffHunk": "@@ -243,4 +241,49 @@ private static boolean isFromFeePerKbChangeAuthorizedSender(org.ethereum.core.Tr\n         AddressBasedAuthorizer authorizer = bridgeConfiguration.getFeePerKbChangeAuthorizer();\n         return authorizer.isAuthorized(rskTx);\n     }\n+\n+    public static boolean validateHeightAndConfirmations(int height, int btcBestChainHeight, int acceptableConfirmationsAmount, Sha256Hash btcTxHash) throws Exception {\n+        // Check there are at least N blocks on top of the supplied height\n+        if (height < 0) {\n+            throw new Exception();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY0OTAyNQ==", "bodyText": "It could be a VerificationException maybe", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r421649025", "createdAt": "2020-05-07T16:50:08Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeUtils.java", "diffHunk": "@@ -243,4 +241,49 @@ private static boolean isFromFeePerKbChangeAuthorizedSender(org.ethereum.core.Tr\n         AddressBasedAuthorizer authorizer = bridgeConfiguration.getFeePerKbChangeAuthorizer();\n         return authorizer.isAuthorized(rskTx);\n     }\n+\n+    public static boolean validateHeightAndConfirmations(int height, int btcBestChainHeight, int acceptableConfirmationsAmount, Sha256Hash btcTxHash) throws Exception {\n+        // Check there are at least N blocks on top of the supplied height\n+        if (height < 0) {\n+            throw new Exception();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYzMzY0Mg=="}, "originalCommit": {"oid": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NzU4Nw==", "bodyText": "Yes, we should throw meaningful exceptions. Typed and/or with a message to help the log reader grasp what happened.\nAlthough in this case you could just log and return false. No need to throw an exception I think.", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438457587", "createdAt": "2020-06-10T23:15:43Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeUtils.java", "diffHunk": "@@ -243,4 +241,49 @@ private static boolean isFromFeePerKbChangeAuthorizedSender(org.ethereum.core.Tr\n         AddressBasedAuthorizer authorizer = bridgeConfiguration.getFeePerKbChangeAuthorizer();\n         return authorizer.isAuthorized(rskTx);\n     }\n+\n+    public static boolean validateHeightAndConfirmations(int height, int btcBestChainHeight, int acceptableConfirmationsAmount, Sha256Hash btcTxHash) throws Exception {\n+        // Check there are at least N blocks on top of the supplied height\n+        if (height < 0) {\n+            throw new Exception();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYzMzY0Mg=="}, "originalCommit": {"oid": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU3OTE3NA==", "bodyText": "Throws exception with message now, as it was throwing exception originally. In case we prefer to log and return false, we should remove the try/catch block on the call.", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r441579174", "createdAt": "2020-06-17T14:15:38Z", "author": {"login": "guidohernan93"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeUtils.java", "diffHunk": "@@ -243,4 +241,49 @@ private static boolean isFromFeePerKbChangeAuthorizedSender(org.ethereum.core.Tr\n         AddressBasedAuthorizer authorizer = bridgeConfiguration.getFeePerKbChangeAuthorizer();\n         return authorizer.isAuthorized(rskTx);\n     }\n+\n+    public static boolean validateHeightAndConfirmations(int height, int btcBestChainHeight, int acceptableConfirmationsAmount, Sha256Hash btcTxHash) throws Exception {\n+        // Check there are at least N blocks on top of the supplied height\n+        if (height < 0) {\n+            throw new Exception();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYzMzY0Mg=="}, "originalCommit": {"oid": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQyNTE3OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoxMjoyOFrOGiJRFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoxMjoyOFrOGiJRFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NjU5OQ==", "bodyText": "Funny name\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean isAlreadyBtcTxHashProcessedHeight(Sha256Hash btcTxHash) throws IOException {\n          \n          \n            \n                public boolean isAlreadyBtcTxHashProcessed(Sha256Hash btcTxHash) throws IOException {", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438456599", "createdAt": "2020-06-10T23:12:28Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -1219,6 +1157,21 @@ public Long getBtcTxHashProcessedHeight(Sha256Hash btcTxHash) throws IOException\n         return provider.getHeightIfBtcTxhashIsAlreadyProcessed(btcTxHash).orElse(-1L);\n     }\n \n+    /**\n+     * Returns if tx was already processed by the bridge\n+     * @param btcTxHash the btc tx hash for which to retrieve the height.\n+     * @return true or false according\n+     * @throws  IOException\n+     * */\n+    public boolean isAlreadyBtcTxHashProcessedHeight(Sha256Hash btcTxHash) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQ0NjA5OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyMzo1MVrOGiJeZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyMzo1MVrOGiJeZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDAwNQ==", "bodyText": "the argument for the block height doesn't match the height you are setting in the stored block", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438460005", "createdAt": "2020-06-10T23:23:51Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4147,6 +4143,303 @@ public void hasBtcCoinbaseTransaction_fails_with_null_coinbase_information_after\n         Assert.assertFalse(bridgeSupport.hasBtcBlockCoinbaseTransactionInformation(Sha256Hash.ZERO_HASH));\n     }\n \n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_true() throws IOException {\n+        Repository repository = createRepository();\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+\n+        provider.setHeightBtcTxhashAlreadyProcessed(btcTransaction.getHash(), 1L);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        Assert.assertTrue(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_false() throws IOException {\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+\n+        Assert.assertFalse(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_negative_height() throws BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), -1, data, data));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_insufficient_confirmations() throws IOException, BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = new RepositoryBtcBlockStoreWithCache.Factory(bridgeConstants.getBtcParams());\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider, repository, mock(BtcLockSenderProvider.class), mock(Block.class), btcBlockStoreFactory);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), 100, data, data));\n+    }\n+\n+    @Test(expected = BridgeIllegalArgumentException.class)\n+    public void validationsForRegisterBtcTransaction_invalid_pmt() throws IOException, BlockStoreException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        String pmtSerializedEncoded = \"030000000279e7c0da739df8a00f12c0bff55e5438f530aa5859ff9874258cd7bad3fe709746aff89\" +\n+                \"7e6a851faa80120d6ae99db30883699ac0428fc7192d6c3fec0ca64010d\";\n+        byte[] pmtSerialized = Hex.decode(pmtSerializedEncoded);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), btcTxHeight, pmtSerialized, btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_hash_not_in_pmt() throws BlockStoreException, AddressFormatException, IOException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(PegTestUtils.createHash(0));\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQ0ODgwOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyNToyMVrOGiJgMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyNTozM1rOGiJgag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDQ2NQ==", "bodyText": "I'm a bit confused. Regardles of the rskip, we would never accept tx without inputs.", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438460465", "createdAt": "2020-06-10T23:25:21Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4147,6 +4143,303 @@ public void hasBtcCoinbaseTransaction_fails_with_null_coinbase_information_after\n         Assert.assertFalse(bridgeSupport.hasBtcBlockCoinbaseTransactionInformation(Sha256Hash.ZERO_HASH));\n     }\n \n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_true() throws IOException {\n+        Repository repository = createRepository();\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+\n+        provider.setHeightBtcTxhashAlreadyProcessed(btcTransaction.getHash(), 1L);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        Assert.assertTrue(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_false() throws IOException {\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+\n+        Assert.assertFalse(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_negative_height() throws BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), -1, data, data));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_insufficient_confirmations() throws IOException, BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = new RepositoryBtcBlockStoreWithCache.Factory(bridgeConstants.getBtcParams());\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider, repository, mock(BtcLockSenderProvider.class), mock(Block.class), btcBlockStoreFactory);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), 100, data, data));\n+    }\n+\n+    @Test(expected = BridgeIllegalArgumentException.class)\n+    public void validationsForRegisterBtcTransaction_invalid_pmt() throws IOException, BlockStoreException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        String pmtSerializedEncoded = \"030000000279e7c0da739df8a00f12c0bff55e5438f530aa5859ff9874258cd7bad3fe709746aff89\" +\n+                \"7e6a851faa80120d6ae99db30883699ac0428fc7192d6c3fec0ca64010d\";\n+        byte[] pmtSerialized = Hex.decode(pmtSerializedEncoded);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), btcTxHeight, pmtSerialized, btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_hash_not_in_pmt() throws BlockStoreException, AddressFormatException, IOException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(PegTestUtils.createHash(0));\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize()));\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void validationsForRegisterBtcTransaction_tx_without_inputs_before_rskip() throws IOException, BlockStoreException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDUyMg==", "bodyText": "and please specify the rskip in the test name", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438460522", "createdAt": "2020-06-10T23:25:33Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4147,6 +4143,303 @@ public void hasBtcCoinbaseTransaction_fails_with_null_coinbase_information_after\n         Assert.assertFalse(bridgeSupport.hasBtcBlockCoinbaseTransactionInformation(Sha256Hash.ZERO_HASH));\n     }\n \n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_true() throws IOException {\n+        Repository repository = createRepository();\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+\n+        provider.setHeightBtcTxhashAlreadyProcessed(btcTransaction.getHash(), 1L);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        Assert.assertTrue(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_false() throws IOException {\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+\n+        Assert.assertFalse(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_negative_height() throws BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), -1, data, data));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_insufficient_confirmations() throws IOException, BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = new RepositoryBtcBlockStoreWithCache.Factory(bridgeConstants.getBtcParams());\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider, repository, mock(BtcLockSenderProvider.class), mock(Block.class), btcBlockStoreFactory);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), 100, data, data));\n+    }\n+\n+    @Test(expected = BridgeIllegalArgumentException.class)\n+    public void validationsForRegisterBtcTransaction_invalid_pmt() throws IOException, BlockStoreException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        String pmtSerializedEncoded = \"030000000279e7c0da739df8a00f12c0bff55e5438f530aa5859ff9874258cd7bad3fe709746aff89\" +\n+                \"7e6a851faa80120d6ae99db30883699ac0428fc7192d6c3fec0ca64010d\";\n+        byte[] pmtSerialized = Hex.decode(pmtSerializedEncoded);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), btcTxHeight, pmtSerialized, btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_hash_not_in_pmt() throws BlockStoreException, AddressFormatException, IOException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(PegTestUtils.createHash(0));\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize()));\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void validationsForRegisterBtcTransaction_tx_without_inputs_before_rskip() throws IOException, BlockStoreException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDQ2NQ=="}, "originalCommit": {"oid": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQ0OTk5OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyNTo1N1rOGiJg6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyNTo1N1rOGiJg6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDY1MQ==", "bodyText": "Same comment", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438460651", "createdAt": "2020-06-10T23:25:57Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4147,6 +4143,303 @@ public void hasBtcCoinbaseTransaction_fails_with_null_coinbase_information_after\n         Assert.assertFalse(bridgeSupport.hasBtcBlockCoinbaseTransactionInformation(Sha256Hash.ZERO_HASH));\n     }\n \n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_true() throws IOException {\n+        Repository repository = createRepository();\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+\n+        provider.setHeightBtcTxhashAlreadyProcessed(btcTransaction.getHash(), 1L);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        Assert.assertTrue(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_false() throws IOException {\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+\n+        Assert.assertFalse(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_negative_height() throws BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), -1, data, data));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_insufficient_confirmations() throws IOException, BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = new RepositoryBtcBlockStoreWithCache.Factory(bridgeConstants.getBtcParams());\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider, repository, mock(BtcLockSenderProvider.class), mock(Block.class), btcBlockStoreFactory);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), 100, data, data));\n+    }\n+\n+    @Test(expected = BridgeIllegalArgumentException.class)\n+    public void validationsForRegisterBtcTransaction_invalid_pmt() throws IOException, BlockStoreException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        String pmtSerializedEncoded = \"030000000279e7c0da739df8a00f12c0bff55e5438f530aa5859ff9874258cd7bad3fe709746aff89\" +\n+                \"7e6a851faa80120d6ae99db30883699ac0428fc7192d6c3fec0ca64010d\";\n+        byte[] pmtSerialized = Hex.decode(pmtSerializedEncoded);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), btcTxHeight, pmtSerialized, btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_hash_not_in_pmt() throws BlockStoreException, AddressFormatException, IOException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(PegTestUtils.createHash(0));\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize()));\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void validationsForRegisterBtcTransaction_tx_without_inputs_before_rskip() throws IOException, BlockStoreException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP143)).thenReturn(false);\n+\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(btcTx.getHash());\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory,\n+                activations\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void validationsForRegisterBtcTransaction_tx_without_inputs_after_rskip() throws IOException, BlockStoreException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQ1NjY3OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyOTo1M1rOGiJlSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyOTo1M1rOGiJlSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MTc3MA==", "bodyText": "A comment here could help understand the test.\nI understand we are creating a tx and a PMT on one hand, and a block which has no relation with said tx and PMT on the other hand; therefore the transaction will be rejected because the merkle block won't match.\nIs that right?", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438461770", "createdAt": "2020-06-10T23:29:53Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4147,6 +4143,303 @@ public void hasBtcCoinbaseTransaction_fails_with_null_coinbase_information_after\n         Assert.assertFalse(bridgeSupport.hasBtcBlockCoinbaseTransactionInformation(Sha256Hash.ZERO_HASH));\n     }\n \n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_true() throws IOException {\n+        Repository repository = createRepository();\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+\n+        provider.setHeightBtcTxhashAlreadyProcessed(btcTransaction.getHash(), 1L);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        Assert.assertTrue(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_false() throws IOException {\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+\n+        Assert.assertFalse(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_negative_height() throws BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), -1, data, data));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_insufficient_confirmations() throws IOException, BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = new RepositoryBtcBlockStoreWithCache.Factory(bridgeConstants.getBtcParams());\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider, repository, mock(BtcLockSenderProvider.class), mock(Block.class), btcBlockStoreFactory);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), 100, data, data));\n+    }\n+\n+    @Test(expected = BridgeIllegalArgumentException.class)\n+    public void validationsForRegisterBtcTransaction_invalid_pmt() throws IOException, BlockStoreException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        String pmtSerializedEncoded = \"030000000279e7c0da739df8a00f12c0bff55e5438f530aa5859ff9874258cd7bad3fe709746aff89\" +\n+                \"7e6a851faa80120d6ae99db30883699ac0428fc7192d6c3fec0ca64010d\";\n+        byte[] pmtSerialized = Hex.decode(pmtSerializedEncoded);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), btcTxHeight, pmtSerialized, btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_hash_not_in_pmt() throws BlockStoreException, AddressFormatException, IOException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(PegTestUtils.createHash(0));\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize()));\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void validationsForRegisterBtcTransaction_tx_without_inputs_before_rskip() throws IOException, BlockStoreException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP143)).thenReturn(false);\n+\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(btcTx.getHash());\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory,\n+                activations\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void validationsForRegisterBtcTransaction_tx_without_inputs_after_rskip() throws IOException, BlockStoreException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP143)).thenReturn(true);\n+\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(btcTx.getHash());\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory,\n+                activations\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), Hex.decode(\"00000000000100\"));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_invalid_block_merkle_root() throws IOException, BlockStoreException {\n+        BridgeStorageProvider mockBridgeStorageProvider = mock(BridgeStorageProvider.class);\n+        when(mockBridgeStorageProvider.getHeightIfBtcTxhashIsAlreadyProcessed(any(Sha256Hash.class))).thenReturn(Optional.empty());\n+\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        when(btcBlockStoreFactory.newInstance(any(Repository.class))).thenReturn(btcBlockStore);\n+\n+        // Create transaction\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        // Create header and PMT\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x3f;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(tx.getHash());\n+        PartialMerkleTree pmt = new PartialMerkleTree(bridgeConstants.getBtcParams(), bits, hashes, 1);\n+        co.rsk.bitcoinj.core.BtcBlock btcBlock =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414"}, "originalPosition": 320}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQ2MDYzOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzozMTozOVrOGiJneA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzozMTozOVrOGiJneA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MjMyOA==", "bodyText": "A comment in the test would help reviewers.\nIn this test, the block includes a valid merkleRoot that you calculate from the PMT you craft.\nGood test!", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438462328", "createdAt": "2020-06-10T23:31:39Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4147,6 +4143,303 @@ public void hasBtcCoinbaseTransaction_fails_with_null_coinbase_information_after\n         Assert.assertFalse(bridgeSupport.hasBtcBlockCoinbaseTransactionInformation(Sha256Hash.ZERO_HASH));\n     }\n \n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_true() throws IOException {\n+        Repository repository = createRepository();\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+\n+        provider.setHeightBtcTxhashAlreadyProcessed(btcTransaction.getHash(), 1L);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        Assert.assertTrue(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_false() throws IOException {\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+\n+        Assert.assertFalse(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_negative_height() throws BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), -1, data, data));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_insufficient_confirmations() throws IOException, BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = new RepositoryBtcBlockStoreWithCache.Factory(bridgeConstants.getBtcParams());\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider, repository, mock(BtcLockSenderProvider.class), mock(Block.class), btcBlockStoreFactory);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), 100, data, data));\n+    }\n+\n+    @Test(expected = BridgeIllegalArgumentException.class)\n+    public void validationsForRegisterBtcTransaction_invalid_pmt() throws IOException, BlockStoreException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        String pmtSerializedEncoded = \"030000000279e7c0da739df8a00f12c0bff55e5438f530aa5859ff9874258cd7bad3fe709746aff89\" +\n+                \"7e6a851faa80120d6ae99db30883699ac0428fc7192d6c3fec0ca64010d\";\n+        byte[] pmtSerialized = Hex.decode(pmtSerializedEncoded);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), btcTxHeight, pmtSerialized, btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_hash_not_in_pmt() throws BlockStoreException, AddressFormatException, IOException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(PegTestUtils.createHash(0));\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize()));\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void validationsForRegisterBtcTransaction_tx_without_inputs_before_rskip() throws IOException, BlockStoreException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP143)).thenReturn(false);\n+\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(btcTx.getHash());\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory,\n+                activations\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void validationsForRegisterBtcTransaction_tx_without_inputs_after_rskip() throws IOException, BlockStoreException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP143)).thenReturn(true);\n+\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(btcTx.getHash());\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory,\n+                activations\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), Hex.decode(\"00000000000100\"));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_invalid_block_merkle_root() throws IOException, BlockStoreException {\n+        BridgeStorageProvider mockBridgeStorageProvider = mock(BridgeStorageProvider.class);\n+        when(mockBridgeStorageProvider.getHeightIfBtcTxhashIsAlreadyProcessed(any(Sha256Hash.class))).thenReturn(Optional.empty());\n+\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        when(btcBlockStoreFactory.newInstance(any(Repository.class))).thenReturn(btcBlockStore);\n+\n+        // Create transaction\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        // Create header and PMT\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x3f;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(tx.getHash());\n+        PartialMerkleTree pmt = new PartialMerkleTree(bridgeConstants.getBtcParams(), bits, hashes, 1);\n+        co.rsk.bitcoinj.core.BtcBlock btcBlock =\n+                new co.rsk.bitcoinj.core.BtcBlock(bridgeConstants.getBtcParams(), 1, PegTestUtils.createHash(), Sha256Hash.ZERO_HASH,\n+                        1, 1, 1, new ArrayList<>());\n+\n+        int height = 1;\n+\n+        mockChainOfStoredBlocks(btcBlockStore, btcBlock, height + bridgeConstants.getBtc2RskMinimumAcceptableConfirmations(), height);\n+\n+        BridgeSupport bridgeSupport = new BridgeSupport(\n+                bridgeConstants,\n+                mockBridgeStorageProvider,\n+                mock(BridgeEventLogger.class),\n+                new BtcLockSenderProvider(),\n+                mock(Repository.class),\n+                mock(Block.class),\n+                mock(Context.class),\n+                mock(FederationSupport.class),\n+                btcBlockStoreFactory,\n+                mock(ActivationConfig.ForBlock.class)\n+        );\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), height, pmt.bitcoinSerialize(), tx.bitcoinSerialize()));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_successful() throws IOException, BlockStoreException {\n+        BridgeStorageProvider mockBridgeStorageProvider = mock(BridgeStorageProvider.class);\n+        when(mockBridgeStorageProvider.getHeightIfBtcTxhashIsAlreadyProcessed(any(Sha256Hash.class))).thenReturn(Optional.empty());\n+\n+        when(mockBridgeStorageProvider.getNewFederation()).thenReturn(bridgeConstants.getGenesisFederation());\n+\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        when(btcBlockStoreFactory.newInstance(any(Repository.class))).thenReturn(btcBlockStore);\n+\n+        // Create transaction\n+        Coin lockValue = Coin.COIN;\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(lockValue, mockBridgeStorageProvider.getNewFederation().getAddress());\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        // Create header and PMT\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x3f;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(tx.getHash());\n+        PartialMerkleTree pmt = new PartialMerkleTree(bridgeConstants.getBtcParams(), bits, hashes, 1);\n+        Sha256Hash merkleRoot = pmt.getTxnHashAndMerkleRoot(new ArrayList<>());\n+        co.rsk.bitcoinj.core.BtcBlock btcBlock =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414"}, "originalPosition": 370}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQ2MTI3OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeUtilsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzozMjowNFrOGiJn5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzozMjowNFrOGiJn5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MjQzNw==", "bodyText": "This dependency is truly used?!", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438462437", "createdAt": "2020-06-10T23:32:04Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeUtilsTest.java", "diffHunk": "@@ -48,8 +50,10 @@\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n+import sun.nio.ch.Net;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQ2NTUzOnYy", "diffSide": "RIGHT", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeUtilsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzozNDoxNlrOGiJqbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzozNDoxNlrOGiJqbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MzA4NA==", "bodyText": "Be careful sending a mock in this way, plus expecting Exception. The method could be failing with an NPE if internally depends on any value from the mocked NetworkParameters.", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438463084", "createdAt": "2020-06-10T23:34:16Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/test/java/co/rsk/peg/BridgeUtilsTest.java", "diffHunk": "@@ -511,6 +515,79 @@ public void getCoinFromBigInteger() {\n         Assert.assertEquals(Coin.COIN, BridgeUtils.getCoinFromBigInteger(BigInteger.valueOf(Coin.COIN.getValue())));\n     }\n \n+    @Test(expected = Exception.class)\n+    public void validateHeightAndConfirmations_invalid_height() throws Exception {\n+        BridgeUtils.validateHeightAndConfirmations(-1, 0, 0, null);\n+    }\n+\n+    @Test\n+    public void validateHeightAndConfirmation_insufficient_confirmations() throws Exception {\n+        Assert.assertFalse(BridgeUtils.validateHeightAndConfirmations(2, 5, 10, Sha256Hash.of(Hex.decode(\"ab\"))));\n+    }\n+\n+    @Test\n+    public void validateHeightAndConfirmation_enough_confirmations() throws Exception {\n+        Assert.assertTrue(BridgeUtils.validateHeightAndConfirmations(2, 5, 3, Sha256Hash.of(Hex.decode(\"ab\"))));\n+    }\n+\n+    @Test(expected = Exception.class)\n+    public void calculateMerkleRoot_invalid_pmt() {\n+        BridgeUtils.calculateMerkleRoot(mock(NetworkParameters.class), Hex.decode(\"ab\"), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQ3MDY2OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzozNzoyNlrOGiJtxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzozNzoyNlrOGiJtxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2Mzk0Mg==", "bodyText": "You could probably remove hash parameter as it doesn't have an actual usage internally, and instead, logging in the callers directly.", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438463942", "createdAt": "2020-06-10T23:37:26Z", "author": {"login": "josedahlquist"}, "path": "rskj-core/src/main/java/co/rsk/peg/BridgeUtils.java", "diffHunk": "@@ -243,4 +241,49 @@ private static boolean isFromFeePerKbChangeAuthorizedSender(org.ethereum.core.Tr\n         AddressBasedAuthorizer authorizer = bridgeConfiguration.getFeePerKbChangeAuthorizer();\n         return authorizer.isAuthorized(rskTx);\n     }\n+\n+    public static boolean validateHeightAndConfirmations(int height, int btcBestChainHeight, int acceptableConfirmationsAmount, Sha256Hash btcTxHash) throws Exception {\n+        // Check there are at least N blocks on top of the supplied height\n+        if (height < 0) {\n+            throw new Exception();\n+        }\n+        int confirmations = btcBestChainHeight - height + 1;\n+        if (confirmations < acceptableConfirmationsAmount) {\n+            logger.warn(\n+                    \"Btc Tx {} at least {} confirmations are required, but there are only {} confirmations\",\n+                    btcTxHash,\n+                    acceptableConfirmationsAmount,\n+                    confirmations\n+            );\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public static Sha256Hash calculateMerkleRoot(NetworkParameters networkParameters, byte[] pmtSerialized, Sha256Hash btcTxHash) throws VerificationException{\n+        PartialMerkleTree pmt = new PartialMerkleTree(networkParameters, pmtSerialized, 0);\n+        List<Sha256Hash> hashesInPmt = new ArrayList<>();\n+        Sha256Hash merkleRoot = pmt.getTxnHashAndMerkleRoot(hashesInPmt);\n+        if (!hashesInPmt.contains(btcTxHash)) {\n+            logger.warn(\"Supplied Btc Tx {} is not in the supplied partial merkle tree\", btcTxHash);\n+            return null;\n+        }\n+        return merkleRoot;\n+    }\n+\n+    public static void validateInputsCount(byte[] btcTxSerialized, boolean isActiveRskip, Sha256Hash btcTxHash) throws VerificationException.EmptyInputsOrOutputs {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414"}, "originalPosition": 54}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4609, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}