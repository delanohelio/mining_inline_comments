{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzMDM3NzEy", "number": 1285, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxMDoxNjowMFrOEVxHSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyNTozMVrOEZpQ3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMjYwMjM0OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/org/ethereum/core/BlockHeader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxMDoxNjowMFrOG8taOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNToyMTowMFrOG84WSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMxMTczOA==", "bodyText": "Could we use UMM_LEAVES_LENGTH instead of magic number 20?", "url": "https://github.com/rsksmart/rskj/pull/1285#discussion_r466311738", "createdAt": "2020-08-06T10:16:00Z", "author": {"login": "ajlopezrsk"}, "path": "rskj-core/src/main/java/org/ethereum/core/BlockHeader.java", "diffHunk": "@@ -570,6 +560,24 @@ public String getParentShortHash() {\n         return new byte[0];\n     }\n \n+    /**\n+     * Compute the base hash for merged mining, taking into account whether the block is a umm block.\n+     * This base hash is later modified to include the forkdetectiondata in its last 12 bytes\n+     *\n+     * @return The computed hash for merged mining\n+     */\n+    private byte[] getBaseHashForMergedMining() {\n+        byte[] encodedBlock = getEncoded(false, false);\n+        byte[] hashForMergedMining = HashUtil.keccak256(encodedBlock);\n+\n+        if (isUMMBlock()) {\n+            byte[] leftHash = Arrays.copyOfRange(hashForMergedMining, 0, 20);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420cb2fe41d874b6874cd96de112c261b0fab950"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ5MDk1Mw==", "bodyText": "Done", "url": "https://github.com/rsksmart/rskj/pull/1285#discussion_r466490953", "createdAt": "2020-08-06T15:21:00Z", "author": {"login": "M-Picco"}, "path": "rskj-core/src/main/java/org/ethereum/core/BlockHeader.java", "diffHunk": "@@ -570,6 +560,24 @@ public String getParentShortHash() {\n         return new byte[0];\n     }\n \n+    /**\n+     * Compute the base hash for merged mining, taking into account whether the block is a umm block.\n+     * This base hash is later modified to include the forkdetectiondata in its last 12 bytes\n+     *\n+     * @return The computed hash for merged mining\n+     */\n+    private byte[] getBaseHashForMergedMining() {\n+        byte[] encodedBlock = getEncoded(false, false);\n+        byte[] hashForMergedMining = HashUtil.keccak256(encodedBlock);\n+\n+        if (isUMMBlock()) {\n+            byte[] leftHash = Arrays.copyOfRange(hashForMergedMining, 0, 20);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMxMTczOA=="}, "originalCommit": {"oid": "420cb2fe41d874b6874cd96de112c261b0fab950"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjU4NTI0OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/org/ethereum/core/BlockHeader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMTo1MTo0NFrOHBEQzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNDozNDo1N1rOHCXivQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4MDQ2MQ==", "bodyText": "I think we should definitely validate that the fork detection data in the coinbase transaction is always 12 bytes and avoid these potentially consensus threatening blocks.", "url": "https://github.com/rsksmart/rskj/pull/1285#discussion_r470880461", "createdAt": "2020-08-14T21:51:44Z", "author": {"login": "amendelzon"}, "path": "rskj-core/src/main/java/org/ethereum/core/BlockHeader.java", "diffHunk": "@@ -539,28 +533,24 @@ public String getParentShortHash() {\n     public byte[] getMiningForkDetectionData() {\n         if(includeForkDetectionData) {\n             if (hasMiningFields() && miningForkDetectionData.length == 0) {\n-                byte[] encodedBlock = getEncoded(false, false);\n-                byte[] hashForMergedMining = HashUtil.keccak256(encodedBlock);\n-\n-                byte[] hashForMergedMiningPrefix = Arrays.copyOfRange(\n-                        hashForMergedMining,\n-                        0,\n-                        HASH_FOR_MERGED_MINING_PREFIX_LENGTH\n-                );\n+                byte[] hashForMergedMining = getBaseHashForMergedMining();\n+\n                 byte[] coinbaseTransaction = getBitcoinMergedMiningCoinbaseTransaction();\n \n-                List<Byte> hashForMergedMiningPrefixAsList = Arrays.asList(ArrayUtils.toObject(hashForMergedMiningPrefix));\n-                List<Byte> coinbaseAsList = Arrays.asList(ArrayUtils.toObject(coinbaseTransaction));\n+                byte[] mergeMiningTagPrefix = Arrays.copyOf(RskMiningConstants.RSK_TAG, RskMiningConstants.RSK_TAG.length + HASH_FOR_MERGED_MINING_PREFIX_LENGTH);\n+                arraycopy(hashForMergedMining, 0, mergeMiningTagPrefix, RskMiningConstants.RSK_TAG.length, HASH_FOR_MERGED_MINING_PREFIX_LENGTH);\n \n-                int position = Collections.lastIndexOfSubList(coinbaseAsList, hashForMergedMiningPrefixAsList);\n+                int position = ListArrayUtil.lastIndexOfSubList(coinbaseTransaction, mergeMiningTagPrefix);\n                 if (position == -1) {\n                     throw new IllegalStateException(\n                             String.format(\"Mining fork detection data could not be found. Header: %s\", getShortHash())\n                     );\n                 }\n \n-                int from = position + HASH_FOR_MERGED_MINING_PREFIX_LENGTH;\n+                int from = position + RskMiningConstants.RSK_TAG.length + HASH_FOR_MERGED_MINING_PREFIX_LENGTH;\n                 int to = from + FORK_DETECTION_DATA_LENGTH;\n+\n+                // should the fork detection data in the coinbase be under 12 bytes, copyOfRange pads with zeros", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef1cb6234ed0eeed8da50f42bb22474db1e049be"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI0NDkyNQ==", "bodyText": "Done", "url": "https://github.com/rsksmart/rskj/pull/1285#discussion_r472244925", "createdAt": "2020-08-18T14:34:57Z", "author": {"login": "M-Picco"}, "path": "rskj-core/src/main/java/org/ethereum/core/BlockHeader.java", "diffHunk": "@@ -539,28 +533,24 @@ public String getParentShortHash() {\n     public byte[] getMiningForkDetectionData() {\n         if(includeForkDetectionData) {\n             if (hasMiningFields() && miningForkDetectionData.length == 0) {\n-                byte[] encodedBlock = getEncoded(false, false);\n-                byte[] hashForMergedMining = HashUtil.keccak256(encodedBlock);\n-\n-                byte[] hashForMergedMiningPrefix = Arrays.copyOfRange(\n-                        hashForMergedMining,\n-                        0,\n-                        HASH_FOR_MERGED_MINING_PREFIX_LENGTH\n-                );\n+                byte[] hashForMergedMining = getBaseHashForMergedMining();\n+\n                 byte[] coinbaseTransaction = getBitcoinMergedMiningCoinbaseTransaction();\n \n-                List<Byte> hashForMergedMiningPrefixAsList = Arrays.asList(ArrayUtils.toObject(hashForMergedMiningPrefix));\n-                List<Byte> coinbaseAsList = Arrays.asList(ArrayUtils.toObject(coinbaseTransaction));\n+                byte[] mergeMiningTagPrefix = Arrays.copyOf(RskMiningConstants.RSK_TAG, RskMiningConstants.RSK_TAG.length + HASH_FOR_MERGED_MINING_PREFIX_LENGTH);\n+                arraycopy(hashForMergedMining, 0, mergeMiningTagPrefix, RskMiningConstants.RSK_TAG.length, HASH_FOR_MERGED_MINING_PREFIX_LENGTH);\n \n-                int position = Collections.lastIndexOfSubList(coinbaseAsList, hashForMergedMiningPrefixAsList);\n+                int position = ListArrayUtil.lastIndexOfSubList(coinbaseTransaction, mergeMiningTagPrefix);\n                 if (position == -1) {\n                     throw new IllegalStateException(\n                             String.format(\"Mining fork detection data could not be found. Header: %s\", getShortHash())\n                     );\n                 }\n \n-                int from = position + HASH_FOR_MERGED_MINING_PREFIX_LENGTH;\n+                int from = position + RskMiningConstants.RSK_TAG.length + HASH_FOR_MERGED_MINING_PREFIX_LENGTH;\n                 int to = from + FORK_DETECTION_DATA_LENGTH;\n+\n+                // should the fork detection data in the coinbase be under 12 bytes, copyOfRange pads with zeros", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4MDQ2MQ=="}, "originalCommit": {"oid": "ef1cb6234ed0eeed8da50f42bb22474db1e049be"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzI1OTE5OnYy", "diffSide": "RIGHT", "path": "rskj-core/src/main/java/org/ethereum/core/BlockHeader.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyNTozMVrOHClKjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMTowNjo1OVrOHCmtCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2ODExMQ==", "bodyText": "Shouldn't FORK_DETECTION_DATA_LENGTH - (to - coinbaseTransaction.length) (the Got: %d bit) be coinbaseTransaction.length - from - 1?", "url": "https://github.com/rsksmart/rskj/pull/1285#discussion_r472468111", "createdAt": "2020-08-18T20:25:31Z", "author": {"login": "amendelzon"}, "path": "rskj-core/src/main/java/org/ethereum/core/BlockHeader.java", "diffHunk": "@@ -539,28 +533,29 @@ public String getParentPrintableHash() {\n     public byte[] getMiningForkDetectionData() {\n         if(includeForkDetectionData) {\n             if (hasMiningFields() && miningForkDetectionData.length == 0) {\n-                byte[] encodedBlock = getEncoded(false, false);\n-                byte[] hashForMergedMining = HashUtil.keccak256(encodedBlock);\n-\n-                byte[] hashForMergedMiningPrefix = Arrays.copyOfRange(\n-                        hashForMergedMining,\n-                        0,\n-                        HASH_FOR_MERGED_MINING_PREFIX_LENGTH\n-                );\n+                byte[] hashForMergedMining = getBaseHashForMergedMining();\n+\n                 byte[] coinbaseTransaction = getBitcoinMergedMiningCoinbaseTransaction();\n \n-                List<Byte> hashForMergedMiningPrefixAsList = Arrays.asList(ArrayUtils.toObject(hashForMergedMiningPrefix));\n-                List<Byte> coinbaseAsList = Arrays.asList(ArrayUtils.toObject(coinbaseTransaction));\n+                byte[] mergeMiningTagPrefix = Arrays.copyOf(RskMiningConstants.RSK_TAG, RskMiningConstants.RSK_TAG.length + HASH_FOR_MERGED_MINING_PREFIX_LENGTH);\n+                arraycopy(hashForMergedMining, 0, mergeMiningTagPrefix, RskMiningConstants.RSK_TAG.length, HASH_FOR_MERGED_MINING_PREFIX_LENGTH);\n \n-                int position = Collections.lastIndexOfSubList(coinbaseAsList, hashForMergedMiningPrefixAsList);\n+                int position = ListArrayUtil.lastIndexOfSubList(coinbaseTransaction, mergeMiningTagPrefix);\n                 if (position == -1) {\n                     throw new IllegalStateException(\n                             String.format(\"Mining fork detection data could not be found. Header: %s\", getPrintableHash())\n                     );\n                 }\n \n-                int from = position + HASH_FOR_MERGED_MINING_PREFIX_LENGTH;\n+                int from = position + RskMiningConstants.RSK_TAG.length + HASH_FOR_MERGED_MINING_PREFIX_LENGTH;\n                 int to = from + FORK_DETECTION_DATA_LENGTH;\n+\n+                if (coinbaseTransaction.length < to) {\n+                    throw new IllegalStateException(\n+                            String.format(\"Invalid fork detection data length. Expected: %d. Got: %d. Header: %s\", FORK_DETECTION_DATA_LENGTH, FORK_DETECTION_DATA_LENGTH - (to - coinbaseTransaction.length), getPrintableHash())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35cafce5d298b54655cd51c061bf4934c023a32d"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5MTUwMQ==", "bodyText": "Results are the same. However, the other way (length - from) is clearer, so I'll change it to that.", "url": "https://github.com/rsksmart/rskj/pull/1285#discussion_r472491501", "createdAt": "2020-08-18T21:03:03Z", "author": {"login": "M-Picco"}, "path": "rskj-core/src/main/java/org/ethereum/core/BlockHeader.java", "diffHunk": "@@ -539,28 +533,29 @@ public String getParentPrintableHash() {\n     public byte[] getMiningForkDetectionData() {\n         if(includeForkDetectionData) {\n             if (hasMiningFields() && miningForkDetectionData.length == 0) {\n-                byte[] encodedBlock = getEncoded(false, false);\n-                byte[] hashForMergedMining = HashUtil.keccak256(encodedBlock);\n-\n-                byte[] hashForMergedMiningPrefix = Arrays.copyOfRange(\n-                        hashForMergedMining,\n-                        0,\n-                        HASH_FOR_MERGED_MINING_PREFIX_LENGTH\n-                );\n+                byte[] hashForMergedMining = getBaseHashForMergedMining();\n+\n                 byte[] coinbaseTransaction = getBitcoinMergedMiningCoinbaseTransaction();\n \n-                List<Byte> hashForMergedMiningPrefixAsList = Arrays.asList(ArrayUtils.toObject(hashForMergedMiningPrefix));\n-                List<Byte> coinbaseAsList = Arrays.asList(ArrayUtils.toObject(coinbaseTransaction));\n+                byte[] mergeMiningTagPrefix = Arrays.copyOf(RskMiningConstants.RSK_TAG, RskMiningConstants.RSK_TAG.length + HASH_FOR_MERGED_MINING_PREFIX_LENGTH);\n+                arraycopy(hashForMergedMining, 0, mergeMiningTagPrefix, RskMiningConstants.RSK_TAG.length, HASH_FOR_MERGED_MINING_PREFIX_LENGTH);\n \n-                int position = Collections.lastIndexOfSubList(coinbaseAsList, hashForMergedMiningPrefixAsList);\n+                int position = ListArrayUtil.lastIndexOfSubList(coinbaseTransaction, mergeMiningTagPrefix);\n                 if (position == -1) {\n                     throw new IllegalStateException(\n                             String.format(\"Mining fork detection data could not be found. Header: %s\", getPrintableHash())\n                     );\n                 }\n \n-                int from = position + HASH_FOR_MERGED_MINING_PREFIX_LENGTH;\n+                int from = position + RskMiningConstants.RSK_TAG.length + HASH_FOR_MERGED_MINING_PREFIX_LENGTH;\n                 int to = from + FORK_DETECTION_DATA_LENGTH;\n+\n+                if (coinbaseTransaction.length < to) {\n+                    throw new IllegalStateException(\n+                            String.format(\"Invalid fork detection data length. Expected: %d. Got: %d. Header: %s\", FORK_DETECTION_DATA_LENGTH, FORK_DETECTION_DATA_LENGTH - (to - coinbaseTransaction.length), getPrintableHash())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2ODExMQ=="}, "originalCommit": {"oid": "35cafce5d298b54655cd51c061bf4934c023a32d"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5MzMyMw==", "bodyText": "Thanks", "url": "https://github.com/rsksmart/rskj/pull/1285#discussion_r472493323", "createdAt": "2020-08-18T21:06:59Z", "author": {"login": "amendelzon"}, "path": "rskj-core/src/main/java/org/ethereum/core/BlockHeader.java", "diffHunk": "@@ -539,28 +533,29 @@ public String getParentPrintableHash() {\n     public byte[] getMiningForkDetectionData() {\n         if(includeForkDetectionData) {\n             if (hasMiningFields() && miningForkDetectionData.length == 0) {\n-                byte[] encodedBlock = getEncoded(false, false);\n-                byte[] hashForMergedMining = HashUtil.keccak256(encodedBlock);\n-\n-                byte[] hashForMergedMiningPrefix = Arrays.copyOfRange(\n-                        hashForMergedMining,\n-                        0,\n-                        HASH_FOR_MERGED_MINING_PREFIX_LENGTH\n-                );\n+                byte[] hashForMergedMining = getBaseHashForMergedMining();\n+\n                 byte[] coinbaseTransaction = getBitcoinMergedMiningCoinbaseTransaction();\n \n-                List<Byte> hashForMergedMiningPrefixAsList = Arrays.asList(ArrayUtils.toObject(hashForMergedMiningPrefix));\n-                List<Byte> coinbaseAsList = Arrays.asList(ArrayUtils.toObject(coinbaseTransaction));\n+                byte[] mergeMiningTagPrefix = Arrays.copyOf(RskMiningConstants.RSK_TAG, RskMiningConstants.RSK_TAG.length + HASH_FOR_MERGED_MINING_PREFIX_LENGTH);\n+                arraycopy(hashForMergedMining, 0, mergeMiningTagPrefix, RskMiningConstants.RSK_TAG.length, HASH_FOR_MERGED_MINING_PREFIX_LENGTH);\n \n-                int position = Collections.lastIndexOfSubList(coinbaseAsList, hashForMergedMiningPrefixAsList);\n+                int position = ListArrayUtil.lastIndexOfSubList(coinbaseTransaction, mergeMiningTagPrefix);\n                 if (position == -1) {\n                     throw new IllegalStateException(\n                             String.format(\"Mining fork detection data could not be found. Header: %s\", getPrintableHash())\n                     );\n                 }\n \n-                int from = position + HASH_FOR_MERGED_MINING_PREFIX_LENGTH;\n+                int from = position + RskMiningConstants.RSK_TAG.length + HASH_FOR_MERGED_MINING_PREFIX_LENGTH;\n                 int to = from + FORK_DETECTION_DATA_LENGTH;\n+\n+                if (coinbaseTransaction.length < to) {\n+                    throw new IllegalStateException(\n+                            String.format(\"Invalid fork detection data length. Expected: %d. Got: %d. Header: %s\", FORK_DETECTION_DATA_LENGTH, FORK_DETECTION_DATA_LENGTH - (to - coinbaseTransaction.length), getPrintableHash())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2ODExMQ=="}, "originalCommit": {"oid": "35cafce5d298b54655cd51c061bf4934c023a32d"}, "originalPosition": 74}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4452, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}