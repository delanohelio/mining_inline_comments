{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyNjg3MDYx", "number": 3065, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODowMDo0M1rODltT5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQxNToyMjo0MFrODzagtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODY2Mjc3OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODowMDo0M1rOFyv9Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOFQxMjo1Mzo0OVrOFzVDxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1ODc5OQ==", "bodyText": "deleteItem(playlist_item) probably crashes because it has to be called on the main thread (not sure though).", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r388758799", "createdAt": "2020-03-06T08:00:43Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -300,6 +316,20 @@ public void onComplete() {}\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                //Solution, Scorched Earth, Copy non duplicates, clear playlist, then copy back over\n+                //Other options didn't work as intended, or crashed. Like deleteItem(playlist_item) crashes when called in this function.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27af9a9c4bded24583fe7242350364fde38540b1"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgzNjQ4OA==", "bodyText": "Converting the AsyncTask to ReactiveX.\nEdit: Tested and does work.\nAdded\nprivate Disposable removeWatchedWorker;\nonOptionsItemSelected Looks like\nRemoveWatchedStreams remover = new RemoveWatchedStreams();\n// It's the same class, just without extending AsyncTask.\n\nremover.onPreExecute();\nremoveWatchedWorker = Flowable.just(playlistManager.getPlaylistStreams(playlistId).blockingFirst())\n    .subscribeOn(Schedulers.newThread())\n    .filter((@NonNull List<PlaylistStreamEntry> playlist) -> {\n        remover.doInBackground(playlist);\n        return true;\n    }\n).observeOn(AndroidSchedulers.mainThread())\n    .subscribe(playlist -> {\n    remover.onPostExecute();\n}, (@io.reactivex.annotations.NonNull Throwable throwable) -> {\n    onError(throwable);\n});\n\nIt still uses the scorched earth method.\nI still haven't figured out how to get the deleteItem() to not crash.\nDue to the below, I think it's the better method.\nWith the scorched earth method.\n\nThere are less calls to the itemListAdapter\nif the app crashed, goes wrong, etc, it doesn't effect anything, it only writes once everything is done, and it's quite fast.\nless function calls, calling deleteItem will call multiple functions that aren't needed until the end.\nFor example updateThumbnailUrl() doesn't need to be called each time, only at the end.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r388836488", "createdAt": "2020-03-06T10:50:53Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -300,6 +316,20 @@ public void onComplete() {}\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                //Solution, Scorched Earth, Copy non duplicates, clear playlist, then copy back over\n+                //Other options didn't work as intended, or crashed. Like deleteItem(playlist_item) crashes when called in this function.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1ODc5OQ=="}, "originalCommit": {"oid": "27af9a9c4bded24583fe7242350364fde38540b1"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM2NjcyNA==", "bodyText": "Switched it over to ReactiveX in commit fb193ce\nNo problem!\nI really have enjoyed NewPipe, and really thank you, and everyone else who has worked hard to make NewPipe happen!", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r389366724", "createdAt": "2020-03-08T12:53:49Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -300,6 +316,20 @@ public void onComplete() {}\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                //Solution, Scorched Earth, Copy non duplicates, clear playlist, then copy back over\n+                //Other options didn't work as intended, or crashed. Like deleteItem(playlist_item) crashes when called in this function.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1ODc5OQ=="}, "originalCommit": {"oid": "27af9a9c4bded24583fe7242350364fde38540b1"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODY2NzAzOnYy", "diffSide": "RIGHT", "path": "app/src/main/res/layout/local_playlist_header.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODowMjo0OFrOFyv_sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOFQxMjo1NTo1MFrOFzVESg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1OTQ3Mw==", "bodyText": "Since the local playlist controls have been reset to the old ones, you should revert this change and remove the file app/src/main/res/layout/local_playlist_control.xml", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r388759473", "createdAt": "2020-03-06T08:02:48Z", "author": {"login": "Stypox"}, "path": "app/src/main/res/layout/local_playlist_header.xml", "diffHunk": "@@ -50,7 +50,7 @@\n         android:layout_height=\"wrap_content\"\n         android:layout_below=\"@id/playlist_stream_count\">\n \n-        <include layout=\"@layout/playlist_control\"/>\n+        <include layout=\"@layout/local_playlist_control\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27af9a9c4bded24583fe7242350364fde38540b1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM2Njg1OA==", "bodyText": "I should've caught that.\nThanks for pointing it out.\nI have fixed it in commit fb193ce", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r389366858", "createdAt": "2020-03-08T12:55:50Z", "author": {"login": "GradyClark"}, "path": "app/src/main/res/layout/local_playlist_header.xml", "diffHunk": "@@ -50,7 +50,7 @@\n         android:layout_height=\"wrap_content\"\n         android:layout_below=\"@id/playlist_stream_count\">\n \n-        <include layout=\"@layout/playlist_control\"/>\n+        <include layout=\"@layout/local_playlist_control\" />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1OTQ3Mw=="}, "originalCommit": {"oid": "27af9a9c4bded24583fe7242350364fde38540b1"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODY3MzI2OnYy", "diffSide": "RIGHT", "path": "app/src/main/res/menu/menu_local_playlist.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODowNTo0NVrOFywDqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODozMzozOFrOFyws6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MDQ4OQ==", "bodyText": "What about adding an icon, and making this line app:showAsAction=\"ifRoom\"? The user would then be able to access the option in only one click, if there is enough space. A delete-multiple icon exists in Android Studio's library, which is the same as the Material Design icon library", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r388760489", "createdAt": "2020-03-06T08:05:45Z", "author": {"login": "Stypox"}, "path": "app/src/main/res/menu/menu_local_playlist.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n+    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n+    xmlns:tools=\"http://schemas.android.com/tools\">\n+\n+    <item\n+        android:id=\"@+id/menu_item_removeWatched\"\n+        android:title=\"@string/remove_watched\"\n+        app:showAsAction=\"never\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27af9a9c4bded24583fe7242350364fde38540b1"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2OTc5OQ==", "bodyText": "I like the idea, but If you accidentally click that button, there is no going back.\nWith the three dot menu, it's an extra click away, reducing the chance of accidentally removing videos you wanted to keep.\nFor that reason I would suggest keeping it behind the three dot menu, or at least a 'confirm action' dialog.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r388769799", "createdAt": "2020-03-06T08:30:40Z", "author": {"login": "GradyClark"}, "path": "app/src/main/res/menu/menu_local_playlist.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n+    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n+    xmlns:tools=\"http://schemas.android.com/tools\">\n+\n+    <item\n+        android:id=\"@+id/menu_item_removeWatched\"\n+        android:title=\"@string/remove_watched\"\n+        app:showAsAction=\"never\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MDQ4OQ=="}, "originalCommit": {"oid": "27af9a9c4bded24583fe7242350364fde38540b1"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc3MTA0OQ==", "bodyText": "Oh, there you have a point, then it is ok to keep it behind the three-dot menu", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r388771049", "createdAt": "2020-03-06T08:33:38Z", "author": {"login": "Stypox"}, "path": "app/src/main/res/menu/menu_local_playlist.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n+    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n+    xmlns:tools=\"http://schemas.android.com/tools\">\n+\n+    <item\n+        android:id=\"@+id/menu_item_removeWatched\"\n+        android:title=\"@string/remove_watched\"\n+        app:showAsAction=\"never\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MDQ4OQ=="}, "originalCommit": {"oid": "27af9a9c4bded24583fe7242350364fde38540b1"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODY3Mzg0OnYy", "diffSide": "RIGHT", "path": "app/src/main/res/values/strings.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODowNTo1NlrOFywD-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOFQxMjo1Njo1MlrOFzVEwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MDU3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                <string name=\"remove_watched\">Remove Watched</string>\n          \n          \n            \n                <string name=\"remove_watched\">Remove watched</string>", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r388760571", "createdAt": "2020-03-06T08:05:56Z", "author": {"login": "Stypox"}, "path": "app/src/main/res/values/strings.xml", "diffHunk": "@@ -592,6 +592,7 @@\n     <string name=\"choose_instance_prompt\">Choose an instance</string>\n     <string name=\"app_language_title\">App language</string>\n     <string name=\"systems_language\">System default</string>\n+    <string name=\"remove_watched\">Remove Watched</string>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27af9a9c4bded24583fe7242350364fde38540b1"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM2Njk3Ng==", "bodyText": "Fixed in commit fb193ce", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r389366976", "createdAt": "2020-03-08T12:56:52Z", "author": {"login": "GradyClark"}, "path": "app/src/main/res/values/strings.xml", "diffHunk": "@@ -592,6 +592,7 @@\n     <string name=\"choose_instance_prompt\">Choose an instance</string>\n     <string name=\"app_language_title\">App language</string>\n     <string name=\"systems_language\">System default</string>\n+    <string name=\"remove_watched\">Remove Watched</string>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MDU3MQ=="}, "originalCommit": {"oid": "27af9a9c4bded24583fe7242350364fde38540b1"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNDc3Nzg1OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMDo0MTo1MFrOF1IXyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMToxNjoxOFrOF3GC9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI1NjAxMA==", "bodyText": "Before this line you should add this code to dispose removeWatchedWorker if it is not null:\nif (removeWatchedWorker != null) {\n    removeWatchedWorker.dispose();\n}", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r391256010", "createdAt": "2020-03-11T20:41:50Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -300,6 +321,32 @@ public void onComplete() {}\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                RemoveWatchedStreams remover = new RemoveWatchedStreams();\n+\n+                remover.onPreExecute();\n+                removeWatchedWorker = Flowable.just(playlistManager.getPlaylistStreams(playlistId).blockingFirst())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb193ce3622f34b212bff6a645887f98940eb63c"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxNTA2MQ==", "bodyText": "Fixed in commit 81bcac5", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r393315061", "createdAt": "2020-03-16T21:16:18Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -300,6 +321,32 @@ public void onComplete() {}\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                RemoveWatchedStreams remover = new RemoveWatchedStreams();\n+\n+                remover.onPreExecute();\n+                removeWatchedWorker = Flowable.just(playlistManager.getPlaylistStreams(playlistId).blockingFirst())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI1NjAxMA=="}, "originalCommit": {"oid": "fb193ce3622f34b212bff6a645887f98940eb63c"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNDc4NDU0OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMDo0NDoxM1rOF1IcRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMToxODoyOVrOF3GGew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI1NzE1Ng==", "bodyText": "I'm not sure this should be done inside a nested class. You could do the same things in three functions without nesting things (at least, that's how I have seen it done in other places in the repository)", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r391257156", "createdAt": "2020-03-11T20:44:13Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -616,5 +663,75 @@ private PlayQueue getPlayQueue(final int index) {\n         }\n         return new SinglePlayQueue(streamInfoItems, index);\n     }\n+\n+    private class RemoveWatchedStreams{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb193ce3622f34b212bff6a645887f98940eb63c"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxNTk2Mw==", "bodyText": "Removed the class in commit 81bcac5", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r393315963", "createdAt": "2020-03-16T21:18:29Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -616,5 +663,75 @@ private PlayQueue getPlayQueue(final int index) {\n         }\n         return new SinglePlayQueue(streamInfoItems, index);\n     }\n+\n+    private class RemoveWatchedStreams{", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI1NzE1Ng=="}, "originalCommit": {"oid": "fb193ce3622f34b212bff6a645887f98940eb63c"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNDc4NjUyOnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMDo0NTowM1rOF1Idkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMToxOTozMVrOF3GIRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI1NzQ5MQ==", "bodyText": "Match the style of the repo: } else {\nAlso below: spaces between if and (: if (", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r391257491", "createdAt": "2020-03-11T20:45:03Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -616,5 +663,75 @@ private PlayQueue getPlayQueue(final int index) {\n         }\n         return new SinglePlayQueue(streamInfoItems, index);\n     }\n+\n+    private class RemoveWatchedStreams{\n+        List<PlaylistStreamEntry> localItems = new ArrayList<>();\n+        Long RemovedItemCount = 0l;\n+        boolean thumbnailVideoRemoved = false;\n+\n+        // Do this in the main thread\n+        protected void onPreExecute() {\n+            showLoading();\n+        }\n+\n+        // Do not do this in the main thread\n+        protected Long doInBackground(List<PlaylistStreamEntry> playlist) {\n+\n+            HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+            Iterator<StreamHistoryEntry> it_history;\n+            StreamHistoryEntry history_item;\n+\n+            Iterator<PlaylistStreamEntry> it_playlist = playlist.iterator();\n+            PlaylistStreamEntry playlist_item = null;\n+\n+            boolean isNonDuplicate;\n+\n+            while (it_playlist.hasNext()) {\n+                playlist_item = it_playlist.next();\n+\n+                it_history = recordManager.getStreamHistory().blockingFirst().iterator();\n+\n+                isNonDuplicate = true;\n+                while (it_history.hasNext()) {\n+                    history_item = it_history.next();\n+                    if (history_item.streamId == playlist_item.streamId) {\n+                        isNonDuplicate = false;\n+                        break;\n+                    }\n+                }\n+                if (isNonDuplicate) {\n+                    localItems.add(playlist_item);\n+                }\n+                else\n+                {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb193ce3622f34b212bff6a645887f98940eb63c"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxNjQyMQ==", "bodyText": "Fixed in commit 81bcac5", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r393316421", "createdAt": "2020-03-16T21:19:31Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -616,5 +663,75 @@ private PlayQueue getPlayQueue(final int index) {\n         }\n         return new SinglePlayQueue(streamInfoItems, index);\n     }\n+\n+    private class RemoveWatchedStreams{\n+        List<PlaylistStreamEntry> localItems = new ArrayList<>();\n+        Long RemovedItemCount = 0l;\n+        boolean thumbnailVideoRemoved = false;\n+\n+        // Do this in the main thread\n+        protected void onPreExecute() {\n+            showLoading();\n+        }\n+\n+        // Do not do this in the main thread\n+        protected Long doInBackground(List<PlaylistStreamEntry> playlist) {\n+\n+            HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+            Iterator<StreamHistoryEntry> it_history;\n+            StreamHistoryEntry history_item;\n+\n+            Iterator<PlaylistStreamEntry> it_playlist = playlist.iterator();\n+            PlaylistStreamEntry playlist_item = null;\n+\n+            boolean isNonDuplicate;\n+\n+            while (it_playlist.hasNext()) {\n+                playlist_item = it_playlist.next();\n+\n+                it_history = recordManager.getStreamHistory().blockingFirst().iterator();\n+\n+                isNonDuplicate = true;\n+                while (it_history.hasNext()) {\n+                    history_item = it_history.next();\n+                    if (history_item.streamId == playlist_item.streamId) {\n+                        isNonDuplicate = false;\n+                        break;\n+                    }\n+                }\n+                if (isNonDuplicate) {\n+                    localItems.add(playlist_item);\n+                }\n+                else\n+                {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI1NzQ5MQ=="}, "originalCommit": {"oid": "fb193ce3622f34b212bff6a645887f98940eb63c"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTA0NjIzOnYy", "diffSide": "RIGHT", "path": "app/src/main/res/values/strings.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzoxODoxMlrOF3QQag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNzowNDo1MlrOF34Ydw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MjM0Ng==", "bodyText": "Why was this added?", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r393482346", "createdAt": "2020-03-17T07:18:12Z", "author": {"login": "Stypox"}, "path": "app/src/main/res/values/strings.xml", "diffHunk": "@@ -593,6 +593,8 @@\n     <string name=\"choose_instance_prompt\">Choose an instance</string>\n     <string name=\"app_language_title\">App language</string>\n     <string name=\"systems_language\">System default</string>\n+    <string name=\"remove_watched\">Remove watched</string>\n+    <string name=\"dynamic_seek_duration_description\">%s seconds</string>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff255a01d3a38c0cabe8a84dda1ccd4ec7042db7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzOTc2Nw==", "bodyText": "That was a mistake.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r394139767", "createdAt": "2020-03-18T07:04:52Z", "author": {"login": "GradyClark"}, "path": "app/src/main/res/values/strings.xml", "diffHunk": "@@ -593,6 +593,8 @@\n     <string name=\"choose_instance_prompt\">Choose an instance</string>\n     <string name=\"app_language_title\">App language</string>\n     <string name=\"systems_language\">System default</string>\n+    <string name=\"remove_watched\">Remove watched</string>\n+    <string name=\"dynamic_seek_duration_description\">%s seconds</string>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MjM0Ng=="}, "originalCommit": {"oid": "ff255a01d3a38c0cabe8a84dda1ccd4ec7042db7"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTEyNjM1OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzo1MTozMFrOF3RBLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNzowNToxMFrOF34Y2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5NDgzMQ==", "bodyText": "As you can see above, the same thing is being done with other disposables. So reorder code to make it uniform.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                    if (removeWatchedWorker != null) removeWatchedWorker.dispose();\n          \n          \n            \n                    removeWatchedWorker = null;\n          \n          \n            \n            \n          \n          \n            \n                    debouncedSaveSignal = null;\n          \n          \n            \n                    playlistManager = null;\n          \n          \n            \n                    disposables = null;\n          \n          \n            \n                    if (removeWatchedWorker != null) removeWatchedWorker.dispose();\n          \n          \n            \n            \n          \n          \n            \n                    debouncedSaveSignal = null;\n          \n          \n            \n                    playlistManager = null;\n          \n          \n            \n                    disposables = null;\n          \n          \n            \n                    removeWatchedWorker = null;", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r393494831", "createdAt": "2020-03-17T07:51:30Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -255,6 +273,9 @@ public void onDestroy() {\n         if (debouncedSaveSignal != null) debouncedSaveSignal.onComplete();\n         if (disposables != null) disposables.dispose();\n \n+        if (removeWatchedWorker != null) removeWatchedWorker.dispose();\n+        removeWatchedWorker = null;\n+\n         debouncedSaveSignal = null;\n         playlistManager = null;\n         disposables = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff255a01d3a38c0cabe8a84dda1ccd4ec7042db7"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzOTg2Nw==", "bodyText": "fixed in 6223c36", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r394139867", "createdAt": "2020-03-18T07:05:10Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -255,6 +273,9 @@ public void onDestroy() {\n         if (debouncedSaveSignal != null) debouncedSaveSignal.onComplete();\n         if (disposables != null) disposables.dispose();\n \n+        if (removeWatchedWorker != null) removeWatchedWorker.dispose();\n+        removeWatchedWorker = null;\n+\n         debouncedSaveSignal = null;\n         playlistManager = null;\n         disposables = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5NDgzMQ=="}, "originalCommit": {"oid": "ff255a01d3a38c0cabe8a84dda1ccd4ec7042db7"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTEzMzQ5OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzo1NDoxM1rOF3RFfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNzowNTo0N1rOF34ZoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5NTkzNA==", "bodyText": "Rename to removeWatchedDisposable", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r393495934", "createdAt": "2020-03-17T07:54:13Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -67,6 +75,8 @@\n     private View headerPopupButton;\n     private View headerBackgroundButton;\n \n+    private Disposable removeWatchedWorker;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff255a01d3a38c0cabe8a84dda1ccd4ec7042db7"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE0MDA2NQ==", "bodyText": "Refactored in 6223c36", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r394140065", "createdAt": "2020-03-18T07:05:47Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -67,6 +75,8 @@\n     private View headerPopupButton;\n     private View headerBackgroundButton;\n \n+    private Disposable removeWatchedWorker;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5NTkzNA=="}, "originalCommit": {"oid": "ff255a01d3a38c0cabe8a84dda1ccd4ec7042db7"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzAyNzQyOnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzozNDo1MVrOGFtVzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxODowNTozNFrOGGxLwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzODkyNQ==", "bodyText": "Declare variables right where you first use them. Redeclaring a variable every cycle of the while loop does not slow down anything, since declaring is just telling the compiler \"I need to have this memory at this point\", so memory is really allocated only once.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r408638925", "createdAt": "2020-04-15T07:34:51Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,\n+                playlistManager.getPlaylistStreams(playlistId).blockingFirst()))\n+                .subscribeOn(Schedulers.io())\n+                .map(flow -> {\n+                    boolean localRemovePartiallyWatched = (boolean) flow.blockingFirst();\n+                    List<PlaylistStreamEntry> playlist\n+                            = (List<PlaylistStreamEntry>) flow.blockingLast();\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!localRemovePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)\n+                                .blockingGet().iterator();\n+                    }\n+\n+                    // already sorted by ^ getStreamHistorySortedById(), binary search can be used\n+                    ArrayList<Long> historyStreamIds = new ArrayList<>();\n+                    while (historyIter.hasNext()) {\n+                        historyStreamIds.add(historyIter.next().getStreamId());\n+                    }\n+\n+                    if (localRemovePartiallyWatched) {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            if (indexInHistory < 0) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    } else {\n+                        boolean hasState = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc1MDQ2Ng==", "bodyText": "Fixed in db335d5", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409750466", "createdAt": "2020-04-16T18:05:34Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,\n+                playlistManager.getPlaylistStreams(playlistId).blockingFirst()))\n+                .subscribeOn(Schedulers.io())\n+                .map(flow -> {\n+                    boolean localRemovePartiallyWatched = (boolean) flow.blockingFirst();\n+                    List<PlaylistStreamEntry> playlist\n+                            = (List<PlaylistStreamEntry>) flow.blockingLast();\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!localRemovePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)\n+                                .blockingGet().iterator();\n+                    }\n+\n+                    // already sorted by ^ getStreamHistorySortedById(), binary search can be used\n+                    ArrayList<Long> historyStreamIds = new ArrayList<>();\n+                    while (historyIter.hasNext()) {\n+                        historyStreamIds.add(historyIter.next().getStreamId());\n+                    }\n+\n+                    if (localRemovePartiallyWatched) {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            if (indexInHistory < 0) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    } else {\n+                        boolean hasState = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzODkyNQ=="}, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzAzMDc4OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzozNTo1MFrOGFtX7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMTowOTozMVrOGGgRkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzOTQ2OA==", "bodyText": "Anyway, I don't think here another variable is needed, you could just go with\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        hasState = streamStatesIter.next() != null;\n          \n          \n            \n                                        if (indexInHistory < 0 ||  hasState) {\n          \n          \n            \n                                        if (indexInHistory < 0 || streamStatesIter.next() != null) {", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r408639468", "createdAt": "2020-04-15T07:35:50Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,\n+                playlistManager.getPlaylistStreams(playlistId).blockingFirst()))\n+                .subscribeOn(Schedulers.io())\n+                .map(flow -> {\n+                    boolean localRemovePartiallyWatched = (boolean) flow.blockingFirst();\n+                    List<PlaylistStreamEntry> playlist\n+                            = (List<PlaylistStreamEntry>) flow.blockingLast();\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!localRemovePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)\n+                                .blockingGet().iterator();\n+                    }\n+\n+                    // already sorted by ^ getStreamHistorySortedById(), binary search can be used\n+                    ArrayList<Long> historyStreamIds = new ArrayList<>();\n+                    while (historyIter.hasNext()) {\n+                        historyStreamIds.add(historyIter.next().getStreamId());\n+                    }\n+\n+                    if (localRemovePartiallyWatched) {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            if (indexInHistory < 0) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    } else {\n+                        boolean hasState = false;\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            hasState = streamStatesIter.next() != null;\n+                            if (indexInHistory < 0 ||  hasState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwNDk1Ng==", "bodyText": "streamStatesIter Has to be incremented each time to keep up with the playlistIter\nstreamStatesIter.next() Doesn't always get called in the \"OR\" conditional, thus would make them increasingly out of sync, each time indexInHistory >= 0", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409204956", "createdAt": "2020-04-16T00:09:05Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,\n+                playlistManager.getPlaylistStreams(playlistId).blockingFirst()))\n+                .subscribeOn(Schedulers.io())\n+                .map(flow -> {\n+                    boolean localRemovePartiallyWatched = (boolean) flow.blockingFirst();\n+                    List<PlaylistStreamEntry> playlist\n+                            = (List<PlaylistStreamEntry>) flow.blockingLast();\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!localRemovePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)\n+                                .blockingGet().iterator();\n+                    }\n+\n+                    // already sorted by ^ getStreamHistorySortedById(), binary search can be used\n+                    ArrayList<Long> historyStreamIds = new ArrayList<>();\n+                    while (historyIter.hasNext()) {\n+                        historyStreamIds.add(historyIter.next().getStreamId());\n+                    }\n+\n+                    if (localRemovePartiallyWatched) {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            if (indexInHistory < 0) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    } else {\n+                        boolean hasState = false;\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            hasState = streamStatesIter.next() != null;\n+                            if (indexInHistory < 0 ||  hasState) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzOTQ2OA=="}, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ3MzQyNQ==", "bodyText": "Oh, I see, you are right", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409473425", "createdAt": "2020-04-16T11:09:31Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,\n+                playlistManager.getPlaylistStreams(playlistId).blockingFirst()))\n+                .subscribeOn(Schedulers.io())\n+                .map(flow -> {\n+                    boolean localRemovePartiallyWatched = (boolean) flow.blockingFirst();\n+                    List<PlaylistStreamEntry> playlist\n+                            = (List<PlaylistStreamEntry>) flow.blockingLast();\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!localRemovePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)\n+                                .blockingGet().iterator();\n+                    }\n+\n+                    // already sorted by ^ getStreamHistorySortedById(), binary search can be used\n+                    ArrayList<Long> historyStreamIds = new ArrayList<>();\n+                    while (historyIter.hasNext()) {\n+                        historyStreamIds.add(historyIter.next().getStreamId());\n+                    }\n+\n+                    if (localRemovePartiallyWatched) {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            if (indexInHistory < 0) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    } else {\n+                        boolean hasState = false;\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            hasState = streamStatesIter.next() != null;\n+                            if (indexInHistory < 0 ||  hasState) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzOTQ2OA=="}, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzAzOTY0OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzozODoyOFrOGFtddA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxODowNToyM1rOGGxLWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MDg4NA==", "bodyText": "Do you really need to pass removePartiallyWatched to the Flowable? I think you can access it just as normal inside the lambda body below", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r408640884", "createdAt": "2020-04-15T07:38:28Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwNTQwNQ==", "bodyText": "I'm really new with ReactiveX, I did that just to make sure that there would be no chance of a weird issue occurring, do you think I should change it?", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409205405", "createdAt": "2020-04-16T00:10:36Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MDg4NA=="}, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ3Mjg2Nw==", "bodyText": "Yes, nothing strange should happen, as removePartiallyWatched is declared as final", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409472867", "createdAt": "2020-04-16T11:08:30Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MDg4NA=="}, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc0NDkyMQ==", "bodyText": "I tried using that just now, and it causes the removeWatchedDisposable to never dispose.\nSo you can only use the 'remove watched' ability once, then you have to shut down and reopen the app.\nI found a way around it, by force disposing it.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409744921", "createdAt": "2020-04-16T17:56:23Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MDg4NA=="}, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc1MDM2MA==", "bodyText": "Fixed in db335d5", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409750360", "createdAt": "2020-04-16T18:05:23Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MDg4NA=="}, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzA1MDg0OnYy", "diffSide": "RIGHT", "path": "app/src/main/res/values/strings.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0MTozMFrOGFtj7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxODowNToxMFrOGGxK1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MjU0MA==", "bodyText": "You shouldn't add two new strings: \"Yes\" and \"Cancel\" either already exist in strings.xml (search with CTRL+F if that's the case) or even are in the default android system strings.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r408642540", "createdAt": "2020-04-15T07:41:30Z", "author": {"login": "Stypox"}, "path": "app/src/main/res/values/strings.xml", "diffHunk": "@@ -601,6 +601,12 @@\n     <string name=\"choose_instance_prompt\">Choose an instance</string>\n     <string name=\"app_language_title\">App language</string>\n     <string name=\"systems_language\">System default</string>\n+    <string name=\"remove_watched\">Remove watched</string>\n+    <string name=\"remove_watched_popup_title\">Remove watched videos?</string>\n+    <string name=\"remove_watched_popup_warning\">\"Videos that have been watched\\nbefore and after being added to the playlist will be removed.\\nAre you sure? This cannot be undone!</string>\n+    <string name=\"remove_watched_popup_yes\">Yes</string>\n+    <string name=\"remove_watched_popup_cancel\">Cancel</string>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgzOTcyOQ==", "bodyText": "There is a reason why we've created these strings (yes no cancel ok\u2026) and we've not been using android ones: Android isn't translated to all languages, I can think of Esperanto specifically.\n(And there is maybe another reason because I didn't created them, it was already existing for two years, but I removed all the android.R.strings in january because of that).", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r408839729", "createdAt": "2020-04-15T13:27:00Z", "author": {"login": "B0pol"}, "path": "app/src/main/res/values/strings.xml", "diffHunk": "@@ -601,6 +601,12 @@\n     <string name=\"choose_instance_prompt\">Choose an instance</string>\n     <string name=\"app_language_title\">App language</string>\n     <string name=\"systems_language\">System default</string>\n+    <string name=\"remove_watched\">Remove watched</string>\n+    <string name=\"remove_watched_popup_title\">Remove watched videos?</string>\n+    <string name=\"remove_watched_popup_warning\">\"Videos that have been watched\\nbefore and after being added to the playlist will be removed.\\nAre you sure? This cannot be undone!</string>\n+    <string name=\"remove_watched_popup_yes\">Yes</string>\n+    <string name=\"remove_watched_popup_cancel\">Cancel</string>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MjU0MA=="}, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc1MDIyOQ==", "bodyText": "Fixed in db335d5", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409750229", "createdAt": "2020-04-16T18:05:10Z", "author": {"login": "GradyClark"}, "path": "app/src/main/res/values/strings.xml", "diffHunk": "@@ -601,6 +601,12 @@\n     <string name=\"choose_instance_prompt\">Choose an instance</string>\n     <string name=\"app_language_title\">App language</string>\n     <string name=\"systems_language\">System default</string>\n+    <string name=\"remove_watched\">Remove watched</string>\n+    <string name=\"remove_watched_popup_title\">Remove watched videos?</string>\n+    <string name=\"remove_watched_popup_warning\">\"Videos that have been watched\\nbefore and after being added to the playlist will be removed.\\nAre you sure? This cannot be undone!</string>\n+    <string name=\"remove_watched_popup_yes\">Yes</string>\n+    <string name=\"remove_watched_popup_cancel\">Cancel</string>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MjU0MA=="}, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzA2MjI2OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0NDozMFrOGFtqtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxODowNDo1OFrOGGxKRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NDI3OA==", "bodyText": "In my opinion it is difficult to read all of these declarations here, maybe they should be distributed right befor the places in code where they are being used (e.g. streamStatesIter would be moved on line 405, before the if (!localRemovePartiallyWatched) branch where it is used). But I'm not sure if it's the same for others. ;-)", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r408644278", "createdAt": "2020-04-15T07:44:30Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,\n+                playlistManager.getPlaylistStreams(playlistId).blockingFirst()))\n+                .subscribeOn(Schedulers.io())\n+                .map(flow -> {\n+                    boolean localRemovePartiallyWatched = (boolean) flow.blockingFirst();\n+                    List<PlaylistStreamEntry> playlist\n+                            = (List<PlaylistStreamEntry>) flow.blockingLast();\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+                    boolean thumbnailVideoRemoved = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwODUzMw==", "bodyText": "How does this look?", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409208533", "createdAt": "2020-04-16T00:21:06Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,\n+                playlistManager.getPlaylistStreams(playlistId).blockingFirst()))\n+                .subscribeOn(Schedulers.io())\n+                .map(flow -> {\n+                    boolean localRemovePartiallyWatched = (boolean) flow.blockingFirst();\n+                    List<PlaylistStreamEntry> playlist\n+                            = (List<PlaylistStreamEntry>) flow.blockingLast();\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+                    boolean thumbnailVideoRemoved = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NDI3OA=="}, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ3NDAxMQ==", "bodyText": "Looks better, thanks :-D", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409474011", "createdAt": "2020-04-16T11:10:45Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,\n+                playlistManager.getPlaylistStreams(playlistId).blockingFirst()))\n+                .subscribeOn(Schedulers.io())\n+                .map(flow -> {\n+                    boolean localRemovePartiallyWatched = (boolean) flow.blockingFirst();\n+                    List<PlaylistStreamEntry> playlist\n+                            = (List<PlaylistStreamEntry>) flow.blockingLast();\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+                    boolean thumbnailVideoRemoved = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NDI3OA=="}, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc1MDA4NQ==", "bodyText": "Fixed in db335d5", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409750085", "createdAt": "2020-04-16T18:04:58Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,\n+                playlistManager.getPlaylistStreams(playlistId).blockingFirst()))\n+                .subscribeOn(Schedulers.io())\n+                .map(flow -> {\n+                    boolean localRemovePartiallyWatched = (boolean) flow.blockingFirst();\n+                    List<PlaylistStreamEntry> playlist\n+                            = (List<PlaylistStreamEntry>) flow.blockingLast();\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+                    boolean thumbnailVideoRemoved = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NDI3OA=="}, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzA3MzA1OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0NzozM1rOGFtxQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxODowNDo0N1rOGGxJ5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NTk1NQ==", "bodyText": "Usually a \"Builder\" variable is never saved, since it is needed exactly once. Also, why can't you use AlertDialog directly without the full path specification?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            android.app.AlertDialog.Builder builder =\n          \n          \n            \n                            new android.app.AlertDialog.Builder(getActivity());\n          \n          \n            \n                            builder.setMessage(R.string.remove_watched_popup_warning)\n          \n          \n            \n                                    .setTitle(R.string.remove_watched_popup_title)\n          \n          \n            \n                                    .setPositiveButton(R.string.remove_watched_popup_yes,\n          \n          \n            \n                                            (DialogInterface d, int id) -> removeWatchedStreams(false))\n          \n          \n            \n                                    .setNeutralButton(\n          \n          \n            \n                                            R.string.remove_watched_popup_yes_and_partially_watched_videos,\n          \n          \n            \n                                            (DialogInterface d, int id) -> removeWatchedStreams(true))\n          \n          \n            \n                                    .setNegativeButton(R.string.remove_watched_popup_cancel,\n          \n          \n            \n                                            (DialogInterface d, int id) -> d.cancel());\n          \n          \n            \n                            builder.create().show();\n          \n          \n            \n                            new AlertDialog.Builder(getActivity())\n          \n          \n            \n                                    .setMessage(R.string.remove_watched_popup_warning)\n          \n          \n            \n                                    .setTitle(R.string.remove_watched_popup_title)\n          \n          \n            \n                                    .setPositiveButton(R.string.remove_watched_popup_yes,\n          \n          \n            \n                                            (DialogInterface d, int id) -> removeWatchedStreams(false))\n          \n          \n            \n                                    .setNeutralButton(\n          \n          \n            \n                                            R.string.remove_watched_popup_yes_and_partially_watched_videos,\n          \n          \n            \n                                            (DialogInterface d, int id) -> removeWatchedStreams(true))\n          \n          \n            \n                                    .setNegativeButton(R.string.remove_watched_popup_cancel,\n          \n          \n            \n                                            (DialogInterface d, int id) -> d.cancel());\n          \n          \n            \n                                    .create()\n          \n          \n            \n                                    .show();", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r408645955", "createdAt": "2020-04-15T07:47:33Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc0OTk5MQ==", "bodyText": "Fixed in db335d5", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409749991", "createdAt": "2020-04-16T18:04:47Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NTk1NQ=="}, "originalCommit": {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MjM2ODM3OnYy", "diffSide": "RIGHT", "path": "app/src/main/res/menu/menu_local_playlist.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQxNToxMzo1MlrOGH48tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNjoxMzo0OVrOGI0RmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNjI2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    android:id=\"@+id/menu_item_removeWatched\"\n          \n          \n            \n                    android:id=\"@+id/menu_item_remove_watched\"", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r410926260", "createdAt": "2020-04-19T15:13:52Z", "author": {"login": "wb9688"}, "path": "app/src/main/res/menu/menu_local_playlist.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n+    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n+    xmlns:tools=\"http://schemas.android.com/tools\">\n+\n+    <item\n+        android:id=\"@+id/menu_item_removeWatched\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5ODI2NQ==", "bodyText": "Fixed in 776dddd", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411898265", "createdAt": "2020-04-21T06:13:49Z", "author": {"login": "GradyClark"}, "path": "app/src/main/res/menu/menu_local_playlist.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n+    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n+    xmlns:tools=\"http://schemas.android.com/tools\">\n+\n+    <item\n+        android:id=\"@+id/menu_item_removeWatched\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNjI2MA=="}, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MjM2OTQ5OnYy", "diffSide": "RIGHT", "path": "app/src/main/res/values/strings.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQxNToxNDo0M1rOGH49Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNjoxMzo1NlrOGI0R0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNjM4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                <string name=\"remove_watched_popup_warning\">\"Videos that have been watched\\nbefore and after being added to the playlist will be removed.\\nAre you sure? This cannot be undone!</string>\n          \n          \n            \n                <string name=\"remove_watched_popup_warning\">\"Videos that have been watched before and after being added to the playlist will be removed.\\nAre you sure? This cannot be undone!</string>", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r410926387", "createdAt": "2020-04-19T15:14:43Z", "author": {"login": "wb9688"}, "path": "app/src/main/res/values/strings.xml", "diffHunk": "@@ -601,6 +601,10 @@\n     <string name=\"choose_instance_prompt\">Choose an instance</string>\n     <string name=\"app_language_title\">App language</string>\n     <string name=\"systems_language\">System default</string>\n+    <string name=\"remove_watched\">Remove watched</string>\n+    <string name=\"remove_watched_popup_title\">Remove watched videos?</string>\n+    <string name=\"remove_watched_popup_warning\">\"Videos that have been watched\\nbefore and after being added to the playlist will be removed.\\nAre you sure? This cannot be undone!</string>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5ODMyMA==", "bodyText": "Fixed in 776dddd", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411898320", "createdAt": "2020-04-21T06:13:56Z", "author": {"login": "GradyClark"}, "path": "app/src/main/res/values/strings.xml", "diffHunk": "@@ -601,6 +601,10 @@\n     <string name=\"choose_instance_prompt\">Choose an instance</string>\n     <string name=\"app_language_title\">App language</string>\n     <string name=\"systems_language\">System default</string>\n+    <string name=\"remove_watched\">Remove watched</string>\n+    <string name=\"remove_watched_popup_title\">Remove watched videos?</string>\n+    <string name=\"remove_watched_popup_warning\">\"Videos that have been watched\\nbefore and after being added to the playlist will be removed.\\nAre you sure? This cannot be undone!</string>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNjM4Nw=="}, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MjM3MTA1OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQxNToxNTo0MlrOGH497Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMjo1MzozMFrOGKnv_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNjU3Mw==", "bodyText": "They should all have a space after //. Also, there probably is a proper way of solving this.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r410926573", "createdAt": "2020-04-19T15:15:42Z", "author": {"login": "wb9688"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = playlistManager.getPlaylistStreams(playlistId)\n+                .subscribeOn(Schedulers.io())\n+                .map((List<PlaylistStreamEntry> playlist) -> {\n+                    //Playlist data\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+\n+                    //History data\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+\n+                    //Remove Watched, Functionality data\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!removePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)\n+                                .blockingGet().iterator();\n+                    }\n+\n+                    // already sorted by ^ getStreamHistorySortedById(), binary search can be used\n+                    ArrayList<Long> historyStreamIds = new ArrayList<>();\n+                    while (historyIter.hasNext()) {\n+                        historyStreamIds.add(historyIter.next().getStreamId());\n+                    }\n+\n+                    if (removePartiallyWatched) {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            if (indexInHistory < 0) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    } else {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            boolean hasState = streamStatesIter.next() != null;\n+                            if (indexInHistory < 0 ||  hasState) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    }\n+\n+                    return Flowable.just(notWatchedItems, thumbnailVideoRemoved);\n+                })\n+                .observeOn(AndroidSchedulers.mainThread())\n+                .subscribe(flow -> {\n+                    List<PlaylistStreamEntry> notWatchedItems =\n+                            (List<PlaylistStreamEntry>) flow.blockingFirst();\n+                    boolean thumbnailVideoRemoved = (Boolean) flow.blockingLast();\n+\n+                    itemListAdapter.clearStreamItemList();\n+                    itemListAdapter.addItems(notWatchedItems);\n+                    saveChanges();\n+\n+\n+                    if (thumbnailVideoRemoved) {\n+                        updateThumbnailUrl();\n+                    }\n+\n+                    long videoCount = itemListAdapter.getItemsList().size();\n+                    setVideoCount(videoCount);\n+                    if (videoCount == 0) {\n+                        showEmptyState();\n+                    }\n+\n+                    hideLoading();\n+\n+                    //If this is not done, 'removeWatchedDisposable', will never be disposed of.\n+                    //Why: Because using the 'removePartiallyWatched' in this functions parms,\n+                    // prevents it from disposing. Exact reason for this behavior is unknown", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5MTgwNQ==", "bodyText": "I have looked around, and I'm not sure what the solution would be.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411891805", "createdAt": "2020-04-21T05:58:58Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = playlistManager.getPlaylistStreams(playlistId)\n+                .subscribeOn(Schedulers.io())\n+                .map((List<PlaylistStreamEntry> playlist) -> {\n+                    //Playlist data\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+\n+                    //History data\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+\n+                    //Remove Watched, Functionality data\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!removePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)\n+                                .blockingGet().iterator();\n+                    }\n+\n+                    // already sorted by ^ getStreamHistorySortedById(), binary search can be used\n+                    ArrayList<Long> historyStreamIds = new ArrayList<>();\n+                    while (historyIter.hasNext()) {\n+                        historyStreamIds.add(historyIter.next().getStreamId());\n+                    }\n+\n+                    if (removePartiallyWatched) {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            if (indexInHistory < 0) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    } else {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            boolean hasState = streamStatesIter.next() != null;\n+                            if (indexInHistory < 0 ||  hasState) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    }\n+\n+                    return Flowable.just(notWatchedItems, thumbnailVideoRemoved);\n+                })\n+                .observeOn(AndroidSchedulers.mainThread())\n+                .subscribe(flow -> {\n+                    List<PlaylistStreamEntry> notWatchedItems =\n+                            (List<PlaylistStreamEntry>) flow.blockingFirst();\n+                    boolean thumbnailVideoRemoved = (Boolean) flow.blockingLast();\n+\n+                    itemListAdapter.clearStreamItemList();\n+                    itemListAdapter.addItems(notWatchedItems);\n+                    saveChanges();\n+\n+\n+                    if (thumbnailVideoRemoved) {\n+                        updateThumbnailUrl();\n+                    }\n+\n+                    long videoCount = itemListAdapter.getItemsList().size();\n+                    setVideoCount(videoCount);\n+                    if (videoCount == 0) {\n+                        showEmptyState();\n+                    }\n+\n+                    hideLoading();\n+\n+                    //If this is not done, 'removeWatchedDisposable', will never be disposed of.\n+                    //Why: Because using the 'removePartiallyWatched' in this functions parms,\n+                    // prevents it from disposing. Exact reason for this behavior is unknown", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNjU3Mw=="}, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5ODQ0MQ==", "bodyText": "Fixed '// ' issue in 776dddd", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411898441", "createdAt": "2020-04-21T06:14:12Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = playlistManager.getPlaylistStreams(playlistId)\n+                .subscribeOn(Schedulers.io())\n+                .map((List<PlaylistStreamEntry> playlist) -> {\n+                    //Playlist data\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+\n+                    //History data\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+\n+                    //Remove Watched, Functionality data\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!removePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)\n+                                .blockingGet().iterator();\n+                    }\n+\n+                    // already sorted by ^ getStreamHistorySortedById(), binary search can be used\n+                    ArrayList<Long> historyStreamIds = new ArrayList<>();\n+                    while (historyIter.hasNext()) {\n+                        historyStreamIds.add(historyIter.next().getStreamId());\n+                    }\n+\n+                    if (removePartiallyWatched) {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            if (indexInHistory < 0) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    } else {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            boolean hasState = streamStatesIter.next() != null;\n+                            if (indexInHistory < 0 ||  hasState) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    }\n+\n+                    return Flowable.just(notWatchedItems, thumbnailVideoRemoved);\n+                })\n+                .observeOn(AndroidSchedulers.mainThread())\n+                .subscribe(flow -> {\n+                    List<PlaylistStreamEntry> notWatchedItems =\n+                            (List<PlaylistStreamEntry>) flow.blockingFirst();\n+                    boolean thumbnailVideoRemoved = (Boolean) flow.blockingLast();\n+\n+                    itemListAdapter.clearStreamItemList();\n+                    itemListAdapter.addItems(notWatchedItems);\n+                    saveChanges();\n+\n+\n+                    if (thumbnailVideoRemoved) {\n+                        updateThumbnailUrl();\n+                    }\n+\n+                    long videoCount = itemListAdapter.getItemsList().size();\n+                    setVideoCount(videoCount);\n+                    if (videoCount == 0) {\n+                        showEmptyState();\n+                    }\n+\n+                    hideLoading();\n+\n+                    //If this is not done, 'removeWatchedDisposable', will never be disposed of.\n+                    //Why: Because using the 'removePartiallyWatched' in this functions parms,\n+                    // prevents it from disposing. Exact reason for this behavior is unknown", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNjU3Mw=="}, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3ODg3MQ==", "bodyText": "@GradyClark: I think you should just add this thing to the already existing CompositeDisposable in this class (i.e. disposables) and not do this stuff here at all, see e.g. here.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r412278871", "createdAt": "2020-04-21T15:19:13Z", "author": {"login": "wb9688"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = playlistManager.getPlaylistStreams(playlistId)\n+                .subscribeOn(Schedulers.io())\n+                .map((List<PlaylistStreamEntry> playlist) -> {\n+                    //Playlist data\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+\n+                    //History data\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+\n+                    //Remove Watched, Functionality data\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!removePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)\n+                                .blockingGet().iterator();\n+                    }\n+\n+                    // already sorted by ^ getStreamHistorySortedById(), binary search can be used\n+                    ArrayList<Long> historyStreamIds = new ArrayList<>();\n+                    while (historyIter.hasNext()) {\n+                        historyStreamIds.add(historyIter.next().getStreamId());\n+                    }\n+\n+                    if (removePartiallyWatched) {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            if (indexInHistory < 0) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    } else {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            boolean hasState = streamStatesIter.next() != null;\n+                            if (indexInHistory < 0 ||  hasState) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    }\n+\n+                    return Flowable.just(notWatchedItems, thumbnailVideoRemoved);\n+                })\n+                .observeOn(AndroidSchedulers.mainThread())\n+                .subscribe(flow -> {\n+                    List<PlaylistStreamEntry> notWatchedItems =\n+                            (List<PlaylistStreamEntry>) flow.blockingFirst();\n+                    boolean thumbnailVideoRemoved = (Boolean) flow.blockingLast();\n+\n+                    itemListAdapter.clearStreamItemList();\n+                    itemListAdapter.addItems(notWatchedItems);\n+                    saveChanges();\n+\n+\n+                    if (thumbnailVideoRemoved) {\n+                        updateThumbnailUrl();\n+                    }\n+\n+                    long videoCount = itemListAdapter.getItemsList().size();\n+                    setVideoCount(videoCount);\n+                    if (videoCount == 0) {\n+                        showEmptyState();\n+                    }\n+\n+                    hideLoading();\n+\n+                    //If this is not done, 'removeWatchedDisposable', will never be disposed of.\n+                    //Why: Because using the 'removePartiallyWatched' in this functions parms,\n+                    // prevents it from disposing. Exact reason for this behavior is unknown", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNjU3Mw=="}, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc4MTgzMw==", "bodyText": "@wb9688 but then how can he check if the removal is already going on, and in that case do nothing? See line 385", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r413781833", "createdAt": "2020-04-23T12:41:43Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = playlistManager.getPlaylistStreams(playlistId)\n+                .subscribeOn(Schedulers.io())\n+                .map((List<PlaylistStreamEntry> playlist) -> {\n+                    //Playlist data\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+\n+                    //History data\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+\n+                    //Remove Watched, Functionality data\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!removePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)\n+                                .blockingGet().iterator();\n+                    }\n+\n+                    // already sorted by ^ getStreamHistorySortedById(), binary search can be used\n+                    ArrayList<Long> historyStreamIds = new ArrayList<>();\n+                    while (historyIter.hasNext()) {\n+                        historyStreamIds.add(historyIter.next().getStreamId());\n+                    }\n+\n+                    if (removePartiallyWatched) {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            if (indexInHistory < 0) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    } else {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            boolean hasState = streamStatesIter.next() != null;\n+                            if (indexInHistory < 0 ||  hasState) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    }\n+\n+                    return Flowable.just(notWatchedItems, thumbnailVideoRemoved);\n+                })\n+                .observeOn(AndroidSchedulers.mainThread())\n+                .subscribe(flow -> {\n+                    List<PlaylistStreamEntry> notWatchedItems =\n+                            (List<PlaylistStreamEntry>) flow.blockingFirst();\n+                    boolean thumbnailVideoRemoved = (Boolean) flow.blockingLast();\n+\n+                    itemListAdapter.clearStreamItemList();\n+                    itemListAdapter.addItems(notWatchedItems);\n+                    saveChanges();\n+\n+\n+                    if (thumbnailVideoRemoved) {\n+                        updateThumbnailUrl();\n+                    }\n+\n+                    long videoCount = itemListAdapter.getItemsList().size();\n+                    setVideoCount(videoCount);\n+                    if (videoCount == 0) {\n+                        showEmptyState();\n+                    }\n+\n+                    hideLoading();\n+\n+                    //If this is not done, 'removeWatchedDisposable', will never be disposed of.\n+                    //Why: Because using the 'removePartiallyWatched' in this functions parms,\n+                    // prevents it from disposing. Exact reason for this behavior is unknown", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNjU3Mw=="}, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5MDIwNQ==", "bodyText": "@Stypox: Can't you create e.g. a private boolean isRemovingWatched for that?", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r413790205", "createdAt": "2020-04-23T12:53:30Z", "author": {"login": "wb9688"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = playlistManager.getPlaylistStreams(playlistId)\n+                .subscribeOn(Schedulers.io())\n+                .map((List<PlaylistStreamEntry> playlist) -> {\n+                    //Playlist data\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+\n+                    //History data\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+\n+                    //Remove Watched, Functionality data\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!removePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)\n+                                .blockingGet().iterator();\n+                    }\n+\n+                    // already sorted by ^ getStreamHistorySortedById(), binary search can be used\n+                    ArrayList<Long> historyStreamIds = new ArrayList<>();\n+                    while (historyIter.hasNext()) {\n+                        historyStreamIds.add(historyIter.next().getStreamId());\n+                    }\n+\n+                    if (removePartiallyWatched) {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            if (indexInHistory < 0) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    } else {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            boolean hasState = streamStatesIter.next() != null;\n+                            if (indexInHistory < 0 ||  hasState) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    }\n+\n+                    return Flowable.just(notWatchedItems, thumbnailVideoRemoved);\n+                })\n+                .observeOn(AndroidSchedulers.mainThread())\n+                .subscribe(flow -> {\n+                    List<PlaylistStreamEntry> notWatchedItems =\n+                            (List<PlaylistStreamEntry>) flow.blockingFirst();\n+                    boolean thumbnailVideoRemoved = (Boolean) flow.blockingLast();\n+\n+                    itemListAdapter.clearStreamItemList();\n+                    itemListAdapter.addItems(notWatchedItems);\n+                    saveChanges();\n+\n+\n+                    if (thumbnailVideoRemoved) {\n+                        updateThumbnailUrl();\n+                    }\n+\n+                    long videoCount = itemListAdapter.getItemsList().size();\n+                    setVideoCount(videoCount);\n+                    if (videoCount == 0) {\n+                        showEmptyState();\n+                    }\n+\n+                    hideLoading();\n+\n+                    //If this is not done, 'removeWatchedDisposable', will never be disposed of.\n+                    //Why: Because using the 'removePartiallyWatched' in this functions parms,\n+                    // prevents it from disposing. Exact reason for this behavior is unknown", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNjU3Mw=="}, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MjM3NDkwOnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQxNToxNzo1OFrOGH4_tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNjoxNDoyM1rOGI0SkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNzAyOQ==", "bodyText": "I'd personally prefer formatting it something like:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Log.d(TAG, \"onCreateOptionsMenu() called with: menu = [\" + menu\n          \n          \n            \n                                + \"], inflater = [\" + inflater + \"]\");\n          \n          \n            \n                        Log.d(TAG, \"onCreateOptionsMenu() called with: \"\n          \n          \n            \n                                + \"menu = [\" + menu + \"], inflater = [\" + inflater + \"]\");", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r410927029", "createdAt": "2020-04-19T15:17:58Z", "author": {"login": "wb9688"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -244,6 +256,16 @@ public void onPause() {\n         saveImmediate();\n     }\n \n+    @Override\n+    public void onCreateOptionsMenu(final Menu menu, final MenuInflater inflater) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"onCreateOptionsMenu() called with: menu = [\" + menu\n+                    + \"], inflater = [\" + inflater + \"]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5ODUxMg==", "bodyText": "Fixed in 776dddd", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411898512", "createdAt": "2020-04-21T06:14:23Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -244,6 +256,16 @@ public void onPause() {\n         saveImmediate();\n     }\n \n+    @Override\n+    public void onCreateOptionsMenu(final Menu menu, final MenuInflater inflater) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"onCreateOptionsMenu() called with: menu = [\" + menu\n+                    + \"], inflater = [\" + inflater + \"]\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNzAyOQ=="}, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MjM3ODU1OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQxNToxOTo0OVrOGH5BYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNjo1OTozN1rOGI1vNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNzQ1Ng==", "bodyText": "A lot of variables in this function could be final", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r410927456", "createdAt": "2020-04-19T15:19:49Z", "author": {"login": "wb9688"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4OTYwMA==", "bodyText": "I don't think that is necessary", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411889600", "createdAt": "2020-04-21T05:53:54Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNzQ1Ng=="}, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxMTE0OA==", "bodyText": "It is not necessary, but it is a good idea to do so, @wb9688 is right", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411911148", "createdAt": "2020-04-21T06:39:42Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNzQ1Ng=="}, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkyMjIzMA==", "bodyText": "Fixed in 7361100", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411922230", "createdAt": "2020-04-21T06:59:37Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNzQ1Ng=="}, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MjM4MzI0OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQxNToyMjo0MFrOGH5Dlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNjo1NToxM1rOGI1lhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyODAyMg==", "bodyText": "This could be moved down I think", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r410928022", "createdAt": "2020-04-19T15:22:40Z", "author": {"login": "wb9688"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = playlistManager.getPlaylistStreams(playlistId)\n+                .subscribeOn(Schedulers.io())\n+                .map((List<PlaylistStreamEntry> playlist) -> {\n+                    //Playlist data\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+\n+                    //History data\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+\n+                    //Remove Watched, Functionality data\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!removePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4ODU1MQ==", "bodyText": "The space is to separate the variables, and the functions", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411888551", "createdAt": "2020-04-21T05:51:15Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = playlistManager.getPlaylistStreams(playlistId)\n+                .subscribeOn(Schedulers.io())\n+                .map((List<PlaylistStreamEntry> playlist) -> {\n+                    //Playlist data\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+\n+                    //History data\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+\n+                    //Remove Watched, Functionality data\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!removePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyODAyMg=="}, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxMjUzNw==", "bodyText": "I think he meant to move the\nstreamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)\n                                .blockingGet().iterator();\n\nblock under the } else { branch below (where removePartiallyWatched == false), i.e. after line 432, so that a check is removed and also less space is used.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411912537", "createdAt": "2020-04-21T06:42:17Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = playlistManager.getPlaylistStreams(playlistId)\n+                .subscribeOn(Schedulers.io())\n+                .map((List<PlaylistStreamEntry> playlist) -> {\n+                    //Playlist data\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+\n+                    //History data\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+\n+                    //Remove Watched, Functionality data\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!removePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyODAyMg=="}, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxNjcwNA==", "bodyText": "Yes, and its initial declaration as well", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411916704", "createdAt": "2020-04-21T06:49:55Z", "author": {"login": "wb9688"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = playlistManager.getPlaylistStreams(playlistId)\n+                .subscribeOn(Schedulers.io())\n+                .map((List<PlaylistStreamEntry> playlist) -> {\n+                    //Playlist data\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+\n+                    //History data\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+\n+                    //Remove Watched, Functionality data\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!removePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyODAyMg=="}, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxOTc0OQ==", "bodyText": "Ah, I'll fix it in the next commit. 7361100", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411919749", "createdAt": "2020-04-21T06:55:13Z", "author": {"login": "GradyClark"}, "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = playlistManager.getPlaylistStreams(playlistId)\n+                .subscribeOn(Schedulers.io())\n+                .map((List<PlaylistStreamEntry> playlist) -> {\n+                    //Playlist data\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+\n+                    //History data\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+\n+                    //Remove Watched, Functionality data\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!removePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyODAyMg=="}, "originalCommit": {"oid": "db335d5cec3b77be37d897279973f1fbf94537af"}, "originalPosition": 149}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3266, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}