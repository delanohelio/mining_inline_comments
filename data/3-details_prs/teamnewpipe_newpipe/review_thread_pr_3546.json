{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0MzA3ODk0", "number": 3546, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwNzo1OTo1M1rOD615kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xN1QyMTowMjoyOFrOFnOeEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMDI3MDg4OnYy", "diffSide": "RIGHT", "path": "app/src/main/res/values/settings_keys.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwNzo1OTo1M1rOGS5UiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwOTozODowNlrOGS53mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NjY5Ng==", "bodyText": "Why change this? For all of them, it's whatever_key without changes in whatever. We couldn't change the whatever either, as then a previously set setting would be back to its default.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3546#discussion_r422466696", "createdAt": "2020-05-09T07:59:53Z", "author": {"login": "wb9688"}, "path": "app/src/main/res/values/settings_keys.xml", "diffHunk": "@@ -158,7 +158,7 @@\n     <string name=\"caption_user_set_key\" translatable=\"false\">caption_user_set_key</string>\n \n     <!-- Content & History -->\n-    <string name=\"show_search_suggestions_key\" translatable=\"false\">show_search_suggestions</string>\n+    <string name=\"show_remote_search_suggestions_key\" translatable=\"false\">show_search_suggestions</string>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac5ea76168f0026fc9180edbf7d1c5ddff8cd940"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ3NTY3NA==", "bodyText": "Yeah, I only changed the string name to make it more clear that the option only refers to remote suggestions, but I left the value as it was before as not to reset settings", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3546#discussion_r422475674", "createdAt": "2020-05-09T09:38:06Z", "author": {"login": "Stypox"}, "path": "app/src/main/res/values/settings_keys.xml", "diffHunk": "@@ -158,7 +158,7 @@\n     <string name=\"caption_user_set_key\" translatable=\"false\">caption_user_set_key</string>\n \n     <!-- Content & History -->\n-    <string name=\"show_search_suggestions_key\" translatable=\"false\">show_search_suggestions</string>\n+    <string name=\"show_remote_search_suggestions_key\" translatable=\"false\">show_search_suggestions</string>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NjY5Ng=="}, "originalCommit": {"oid": "ac5ea76168f0026fc9180edbf7d1c5ddff8cd940"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjAwNDg3OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/settings/NewPipeSettings.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMDoxNzowM1rOGr0ANQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMDoxNzowM1rOGr0ANQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU5Mzk3Mw==", "bodyText": "I think we should do the migration process a little different. First of all, it is good to store the last used/started NewPipe version (or better version code). That should also help us when creating a welcome tour and showing changelogs in future versions, too.\nDepending on the last used version, we could do something like this:\nint lastStartedVersionCode = preferences.getInt(context.getString(R.string.last_started_newpipe_version_code), -1);\nif (lastStartedVersionCode < 951) { // version code for 0.19.6\n    // do migration here or call a method\n}\n// register later migrations here\nThe only thing we should figure out is how to differentiate between a new installation and a user updating. Both have not set last_started_newpipe_version_code, but a new installation does not need to run migrations. @wb9688 @B0pol @Stypox Any thoughts on this or suggestions for a different structure of the migration process?\nWe should update the last used version code if necessary at the end of \n  \n    \n      NewPipe/app/src/main/java/org/schabi/newpipe/App.java\n    \n    \n         Line 85\n      in\n      049c8f7\n    \n    \n    \n    \n\n        \n          \n           public void onCreate() {", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3546#discussion_r448593973", "createdAt": "2020-07-01T20:17:03Z", "author": {"login": "TobiGr"}, "path": "app/src/main/java/org/schabi/newpipe/settings/NewPipeSettings.java", "diffHunk": "@@ -50,6 +55,32 @@ public static void initSettings(final Context context) {\n         getAudioDownloadFolder(context);\n     }\n \n+    /**\n+     * Backward-compatibility: convert boolean search suggestions value to new multi-select list.\n+     * @param context the context to use to get shared preferences\n+     */\n+    private static void migrateSearchSuggestionsIfNeeded(final Context context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "add872b77563aa7b2be0682ee3af513abb39d081"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc2NjczODI3OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/fragments/list/search/SearchFragment.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xN1QyMDo1NzoyM1rOI4v9Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xN1QyMDo1NzoyM1rOI4v9Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjM3Njg1NA==", "bodyText": "For better readability:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    return Observable.zip(getLocalSuggestionsObservable(query, 3),\n          \n          \n            \n                                            getRemoteSuggestionsObservable(query),\n          \n          \n            \n                                    return Observable.zip(\n          \n          \n            \n                                            getLocalSuggestionsObservable(query, 3),\n          \n          \n            \n                                            getRemoteSuggestionsObservable(query),", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3546#discussion_r596376854", "createdAt": "2021-03-17T20:57:23Z", "author": {"login": "TobiGr"}, "path": "app/src/main/java/org/schabi/newpipe/fragments/list/search/SearchFragment.java", "diffHunk": "@@ -723,69 +745,44 @@ private void initSuggestionObserver() {\n \n         suggestionDisposable = suggestionPublisher\n                 .debounce(SUGGESTIONS_DEBOUNCE, TimeUnit.MILLISECONDS)\n-                .startWithItem(searchString != null\n-                        ? searchString\n-                        : \"\")\n-                .filter(ss -> isSuggestionsEnabled)\n+                .startWithItem(searchString == null ? \"\" : searchString)\n                 .switchMap(query -> {\n-                    final Flowable<List<SearchHistoryEntry>> flowable = historyRecordManager\n-                            .getRelatedSearches(query, 3, 25);\n-                    final Observable<List<SuggestionItem>> local = flowable.toObservable()\n-                            .map(searchHistoryEntries -> {\n-                                final List<SuggestionItem> result = new ArrayList<>();\n-                                for (final SearchHistoryEntry entry : searchHistoryEntries) {\n-                                    result.add(new SuggestionItem(true, entry.getSearch()));\n-                                }\n-                                return result;\n-                            });\n-\n-                    if (query.length() < THRESHOLD_NETWORK_SUGGESTION) {\n-                        // Only pass through if the query length\n-                        // is equal or greater than THRESHOLD_NETWORK_SUGGESTION\n-                        return local.materialize();\n+                    // Only show remote suggestions if they are enabled in settings and\n+                    // the query length is at least THRESHOLD_NETWORK_SUGGESTION\n+                    final boolean shallShowRemoteSuggestionsNow = showRemoteSuggestions\n+                            && query.length() >= THRESHOLD_NETWORK_SUGGESTION;\n+\n+                    if (showLocalSuggestions && shallShowRemoteSuggestionsNow) {\n+                        return Observable.zip(getLocalSuggestionsObservable(query, 3),\n+                                getRemoteSuggestionsObservable(query),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "464d29e16f730933c63f0c99c5c31868fa43a8bb"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc2Njc1ODU4OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/fragments/list/search/SearchFragment.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xN1QyMTowMjoyOFrOI4wJdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xN1QyMTowMjoyOFrOI4wJdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjM4MDAyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                } else if (listNotification.isOnError() && listNotification.getError() != null\n          \n          \n            \n                                        && !ExceptionUtils.isInterruptedCaused(listNotification.getError())) {\n          \n          \n            \n                                } else if (listNotification.isOnError()\n          \n          \n            \n                                        && listNotification.getError() != null\n          \n          \n            \n                                        && !ExceptionUtils.isInterruptedCaused(listNotification.getError())) {", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3546#discussion_r596380023", "createdAt": "2021-03-17T21:02:28Z", "author": {"login": "TobiGr"}, "path": "app/src/main/java/org/schabi/newpipe/fragments/list/search/SearchFragment.java", "diffHunk": "@@ -723,70 +745,45 @@ private void initSuggestionObserver() {\n \n         suggestionDisposable = suggestionPublisher\n                 .debounce(SUGGESTIONS_DEBOUNCE, TimeUnit.MILLISECONDS)\n-                .startWithItem(searchString != null\n-                        ? searchString\n-                        : \"\")\n-                .filter(ss -> isSuggestionsEnabled)\n+                .startWithItem(searchString == null ? \"\" : searchString)\n                 .switchMap(query -> {\n-                    final Flowable<List<SearchHistoryEntry>> flowable = historyRecordManager\n-                            .getRelatedSearches(query, 3, 25);\n-                    final Observable<List<SuggestionItem>> local = flowable.toObservable()\n-                            .map(searchHistoryEntries -> {\n-                                final List<SuggestionItem> result = new ArrayList<>();\n-                                for (final SearchHistoryEntry entry : searchHistoryEntries) {\n-                                    result.add(new SuggestionItem(true, entry.getSearch()));\n-                                }\n-                                return result;\n-                            });\n-\n-                    if (query.length() < THRESHOLD_NETWORK_SUGGESTION) {\n-                        // Only pass through if the query length\n-                        // is equal or greater than THRESHOLD_NETWORK_SUGGESTION\n-                        return local.materialize();\n+                    // Only show remote suggestions if they are enabled in settings and\n+                    // the query length is at least THRESHOLD_NETWORK_SUGGESTION\n+                    final boolean shallShowRemoteSuggestionsNow = showRemoteSuggestions\n+                            && query.length() >= THRESHOLD_NETWORK_SUGGESTION;\n+\n+                    if (showLocalSuggestions && shallShowRemoteSuggestionsNow) {\n+                        return Observable.zip(getLocalSuggestionsObservable(query, 3),\n+                                getRemoteSuggestionsObservable(query),\n+                                (local, remote) -> {\n+                                    remote.removeIf(remoteItem -> local.stream().anyMatch(\n+                                            localItem -> localItem.equals(remoteItem)));\n+                                    local.addAll(remote);\n+                                    return local;\n+                                })\n+                                .materialize();\n+                    } else if (showLocalSuggestions) {\n+                        return getLocalSuggestionsObservable(query, 25)\n+                                .materialize();\n+                    } else if (shallShowRemoteSuggestionsNow) {\n+                        return getRemoteSuggestionsObservable(query)\n+                                .materialize();\n+                    } else {\n+                        return Single.fromCallable(Collections::<SuggestionItem>emptyList)\n+                                .toObservable()\n+                                .materialize();\n                     }\n-\n-                    final Observable<List<SuggestionItem>> network = ExtractorHelper\n-                            .suggestionsFor(serviceId, query)\n-                            .onErrorReturn(throwable -> {\n-                                if (!ExceptionUtils.isNetworkRelated(throwable)) {\n-                                    showSnackBarError(new ErrorInfo(throwable,\n-                                            UserAction.GET_SUGGESTIONS, searchString, serviceId));\n-                                }\n-                                return new ArrayList<>();\n-                            })\n-                            .toObservable()\n-                            .map(strings -> {\n-                                final List<SuggestionItem> result = new ArrayList<>();\n-                                for (final String entry : strings) {\n-                                    result.add(new SuggestionItem(false, entry));\n-                                }\n-                                return result;\n-                            });\n-\n-                    return Observable.zip(local, network, (localResult, networkResult) -> {\n-                        final List<SuggestionItem> result = new ArrayList<>();\n-                        if (localResult.size() > 0) {\n-                            result.addAll(localResult);\n-                        }\n-\n-                        // Remove duplicates\n-                        networkResult.removeIf(networkItem ->\n-                                localResult.stream().anyMatch(localItem ->\n-                                        localItem.query.equals(networkItem.query)));\n-\n-                        if (networkResult.size() > 0) {\n-                            result.addAll(networkResult);\n-                        }\n-                        return result;\n-                    }).materialize();\n                 })\n                 .subscribeOn(Schedulers.io())\n                 .observeOn(AndroidSchedulers.mainThread())\n                 .subscribe(listNotification -> {\n                     if (listNotification.isOnNext()) {\n-                        handleSuggestions(listNotification.getValue());\n-                    } else if (listNotification.isOnError()) {\n-                        showError(new ErrorInfo(listNotification.getError(),\n+                        if (listNotification.getValue() != null) {\n+                            handleSuggestions(listNotification.getValue());\n+                        }\n+                    } else if (listNotification.isOnError() && listNotification.getError() != null\n+                            && !ExceptionUtils.isInterruptedCaused(listNotification.getError())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e039ac869b2445ee0a9ef5fa2598ee5ef195a36"}, "originalPosition": 222}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3186, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}