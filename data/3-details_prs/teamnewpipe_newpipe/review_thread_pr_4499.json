{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxMzczODA5", "number": 4499, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxOToyNDoxNFrOEswFuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOTo1NTo1NlrOE0TmHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzYwNjk3OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/CheckForNewAppVersion.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxOToyNDoxNFrOHgKhgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxOToyNDoxNFrOHgKhgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4ODg5Nw==", "bodyText": "Can be combined into only one", "url": "https://github.com/TeamNewPipe/NewPipe/pull/4499#discussion_r503488897", "createdAt": "2020-10-12T19:24:14Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/CheckForNewAppVersion.kt", "diffHunk": "@@ -0,0 +1,193 @@\n+@file:JvmName(\"CheckForNewAppVersion\")\n+\n+package org.schabi.newpipe\n+\n+import android.app.PendingIntent\n+import android.content.Intent\n+import android.content.pm.PackageInfo\n+import android.content.pm.PackageManager\n+import android.net.ConnectivityManager\n+import android.util.Log\n+import androidx.core.app.NotificationCompat\n+import androidx.core.app.NotificationManagerCompat\n+import androidx.core.content.getSystemService\n+import androidx.core.net.toUri\n+import androidx.preference.PreferenceManager\n+import com.grack.nanojson.JsonObject\n+import com.grack.nanojson.JsonParser\n+import com.grack.nanojson.JsonParserException\n+import io.reactivex.Observable\n+import io.reactivex.android.schedulers.AndroidSchedulers\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.schedulers.Schedulers\n+import java.io.IOException\n+import java.security.MessageDigest\n+import java.security.NoSuchAlgorithmException\n+import java.security.cert.CertificateEncodingException\n+import java.security.cert.CertificateException\n+import java.security.cert.CertificateFactory\n+import java.security.cert.X509Certificate\n+import java.util.Locale\n+import org.schabi.newpipe.extractor.exceptions.ReCaptchaException\n+import org.schabi.newpipe.report.ErrorActivity\n+import org.schabi.newpipe.report.UserAction\n+\n+private const val TAG = \"CheckForNewAppVersion\"\n+private const val GITHUB_APK_SHA1 = \"B0:2E:90:7C:1C:D6:FC:57:C3:35:F0:88:D0:8F:50:5F:94:E4:D2:15\"\n+private const val NEWPIPE_API_URL = \"https://newpipe.schabi.org/api/data.json\"\n+\n+private val APP = App.getApp()\n+private val DEBUG = MainActivity.DEBUG\n+\n+/**\n+ * Property to get the apk's SHA1 key. See https://stackoverflow.com/questions/9293019/#22506133.\n+ *\n+ * @return String with the apk's SHA1 fingerprint in hexadecimal\n+ */\n+private val certificateSHA1Fingerprint: String?\n+    get() {\n+        val pm = APP.packageManager\n+        val packageName = APP.packageName\n+        val flags = PackageManager.GET_SIGNATURES\n+        var packageInfo: PackageInfo? = null\n+        try {\n+            packageInfo = pm.getPackageInfo(packageName, flags)\n+        } catch (e: PackageManager.NameNotFoundException) {\n+            ErrorActivity.reportError(APP, e, null, null,\n+                    ErrorActivity.ErrorInfo.make(UserAction.SOMETHING_ELSE, \"none\",\n+                            \"Could not find package info\", R.string.app_ui_crash))\n+        }\n+        val signatures = packageInfo!!.signatures\n+        val input = signatures[0].toByteArray().inputStream()\n+        var c: X509Certificate? = null\n+        try {\n+            val cf = CertificateFactory.getInstance(\"X509\")\n+            c = cf.generateCertificate(input) as X509Certificate\n+        } catch (e: CertificateException) {\n+            ErrorActivity.reportError(APP, e, null, null,\n+                    ErrorActivity.ErrorInfo.make(UserAction.SOMETHING_ELSE, \"none\",\n+                            \"Certificate error\", R.string.app_ui_crash))\n+        }\n+        var hexString: String? = null\n+        try {\n+            val md = MessageDigest.getInstance(\"SHA1\")\n+            val publicKey = md.digest(c!!.encoded)\n+            hexString = byte2HexFormatted(publicKey)\n+        } catch (e: NoSuchAlgorithmException) {\n+            ErrorActivity.reportError(APP, e, null, null,\n+                    ErrorActivity.ErrorInfo.make(UserAction.SOMETHING_ELSE, \"none\",\n+                            \"Could not retrieve SHA1 key\", R.string.app_ui_crash))\n+        } catch (e: CertificateEncodingException) {\n+            ErrorActivity.reportError(APP, e, null, null,\n+                    ErrorActivity.ErrorInfo.make(UserAction.SOMETHING_ELSE, \"none\",\n+                            \"Could not retrieve SHA1 key\", R.string.app_ui_crash))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e2c67d88317aeb4220edbeaa3eafd42da31f7b2"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzYxMzQ0OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/CheckForNewAppVersion.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxOToyNjoxMlrOHgKlFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwMDoyNzowM1rOHgRbnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4OTgxMg==", "bodyText": "I know this is not the purpose of this PR, but while you are at it could you remove APP = App.getApp() and have this method take the app as an argument? This is also like how all other utility classes do\nAlso for isGithubApk", "url": "https://github.com/TeamNewPipe/NewPipe/pull/4499#discussion_r503489812", "createdAt": "2020-10-12T19:26:12Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/CheckForNewAppVersion.kt", "diffHunk": "@@ -0,0 +1,193 @@\n+@file:JvmName(\"CheckForNewAppVersion\")\n+\n+package org.schabi.newpipe\n+\n+import android.app.PendingIntent\n+import android.content.Intent\n+import android.content.pm.PackageInfo\n+import android.content.pm.PackageManager\n+import android.net.ConnectivityManager\n+import android.util.Log\n+import androidx.core.app.NotificationCompat\n+import androidx.core.app.NotificationManagerCompat\n+import androidx.core.content.getSystemService\n+import androidx.core.net.toUri\n+import androidx.preference.PreferenceManager\n+import com.grack.nanojson.JsonObject\n+import com.grack.nanojson.JsonParser\n+import com.grack.nanojson.JsonParserException\n+import io.reactivex.Observable\n+import io.reactivex.android.schedulers.AndroidSchedulers\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.schedulers.Schedulers\n+import java.io.IOException\n+import java.security.MessageDigest\n+import java.security.NoSuchAlgorithmException\n+import java.security.cert.CertificateEncodingException\n+import java.security.cert.CertificateException\n+import java.security.cert.CertificateFactory\n+import java.security.cert.X509Certificate\n+import java.util.Locale\n+import org.schabi.newpipe.extractor.exceptions.ReCaptchaException\n+import org.schabi.newpipe.report.ErrorActivity\n+import org.schabi.newpipe.report.UserAction\n+\n+private const val TAG = \"CheckForNewAppVersion\"\n+private const val GITHUB_APK_SHA1 = \"B0:2E:90:7C:1C:D6:FC:57:C3:35:F0:88:D0:8F:50:5F:94:E4:D2:15\"\n+private const val NEWPIPE_API_URL = \"https://newpipe.schabi.org/api/data.json\"\n+\n+private val APP = App.getApp()\n+private val DEBUG = MainActivity.DEBUG\n+\n+/**\n+ * Property to get the apk's SHA1 key. See https://stackoverflow.com/questions/9293019/#22506133.\n+ *\n+ * @return String with the apk's SHA1 fingerprint in hexadecimal\n+ */\n+private val certificateSHA1Fingerprint: String?\n+    get() {\n+        val pm = APP.packageManager\n+        val packageName = APP.packageName\n+        val flags = PackageManager.GET_SIGNATURES\n+        var packageInfo: PackageInfo? = null\n+        try {\n+            packageInfo = pm.getPackageInfo(packageName, flags)\n+        } catch (e: PackageManager.NameNotFoundException) {\n+            ErrorActivity.reportError(APP, e, null, null,\n+                    ErrorActivity.ErrorInfo.make(UserAction.SOMETHING_ELSE, \"none\",\n+                            \"Could not find package info\", R.string.app_ui_crash))\n+        }\n+        val signatures = packageInfo!!.signatures\n+        val input = signatures[0].toByteArray().inputStream()\n+        var c: X509Certificate? = null\n+        try {\n+            val cf = CertificateFactory.getInstance(\"X509\")\n+            c = cf.generateCertificate(input) as X509Certificate\n+        } catch (e: CertificateException) {\n+            ErrorActivity.reportError(APP, e, null, null,\n+                    ErrorActivity.ErrorInfo.make(UserAction.SOMETHING_ELSE, \"none\",\n+                            \"Certificate error\", R.string.app_ui_crash))\n+        }\n+        var hexString: String? = null\n+        try {\n+            val md = MessageDigest.getInstance(\"SHA1\")\n+            val publicKey = md.digest(c!!.encoded)\n+            hexString = byte2HexFormatted(publicKey)\n+        } catch (e: NoSuchAlgorithmException) {\n+            ErrorActivity.reportError(APP, e, null, null,\n+                    ErrorActivity.ErrorInfo.make(UserAction.SOMETHING_ELSE, \"none\",\n+                            \"Could not retrieve SHA1 key\", R.string.app_ui_crash))\n+        } catch (e: CertificateEncodingException) {\n+            ErrorActivity.reportError(APP, e, null, null,\n+                    ErrorActivity.ErrorInfo.make(UserAction.SOMETHING_ELSE, \"none\",\n+                            \"Could not retrieve SHA1 key\", R.string.app_ui_crash))\n+        }\n+        return hexString\n+    }\n+\n+private val isConnected: Boolean\n+    get() = APP.getSystemService<ConnectivityManager>()?.activeNetworkInfo?.isConnected == true\n+\n+private var disposable: Disposable? = null\n+\n+val isGithubApk: Boolean\n+    get() = certificateSHA1Fingerprint == GITHUB_APK_SHA1\n+\n+private fun byte2HexFormatted(arr: ByteArray): String {\n+    val str = StringBuilder(arr.size * 2)\n+    for (i in arr.indices) {\n+        var h = Integer.toHexString(arr[i].toInt())\n+        val l = h.length\n+        if (l == 1) {\n+            h = \"0$h\"\n+        }\n+        if (l > 2) {\n+            h = h.substring(l - 2, l)\n+        }\n+        str.append(h.toUpperCase(Locale.ROOT))\n+        if (i < arr.size - 1) {\n+            str.append(':')\n+        }\n+    }\n+    return str.toString()\n+}\n+\n+/**\n+ * Method to compare the current and latest available app version.\n+ * If a newer version is available, we show the update notification.\n+ *\n+ * @param versionName Name of new version\n+ * @param apkLocationUrl Url with the new apk\n+ * @param versionCode Code of new version\n+ */\n+private fun compareAppVersionAndShowNotification(versionName: String, apkLocationUrl: String, versionCode: Int) {\n+    val notificationId = 2000\n+    if (BuildConfig.VERSION_CODE < versionCode) {\n+\n+        // A pending intent to open the apk location url in the browser.\n+        val intent = Intent(Intent.ACTION_VIEW, apkLocationUrl.toUri())\n+        val pendingIntent = PendingIntent.getActivity(APP, 0, intent, 0)\n+        val notificationBuilder = NotificationCompat.Builder(APP, APP.getString(R.string.app_update_notification_channel_id))\n+                .setSmallIcon(R.drawable.ic_newpipe_update)\n+                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n+                .setContentIntent(pendingIntent)\n+                .setAutoCancel(true)\n+                .setContentTitle(APP.getString(R.string.app_update_notification_content_title))\n+                .setContentText(APP.getString(R.string.app_update_notification_content_text) + \" \" + versionName)\n+        val notificationManager = NotificationManagerCompat.from(APP)\n+        notificationManager.notify(notificationId, notificationBuilder.build())\n+    }\n+}\n+\n+fun checkNewVersion() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e2c67d88317aeb4220edbeaa3eafd42da31f7b2"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYwMjA3Nw==", "bodyText": "Sure.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/4499#discussion_r503602077", "createdAt": "2020-10-13T00:27:03Z", "author": {"login": "Isira-Seneviratne"}, "path": "app/src/main/java/org/schabi/newpipe/CheckForNewAppVersion.kt", "diffHunk": "@@ -0,0 +1,193 @@\n+@file:JvmName(\"CheckForNewAppVersion\")\n+\n+package org.schabi.newpipe\n+\n+import android.app.PendingIntent\n+import android.content.Intent\n+import android.content.pm.PackageInfo\n+import android.content.pm.PackageManager\n+import android.net.ConnectivityManager\n+import android.util.Log\n+import androidx.core.app.NotificationCompat\n+import androidx.core.app.NotificationManagerCompat\n+import androidx.core.content.getSystemService\n+import androidx.core.net.toUri\n+import androidx.preference.PreferenceManager\n+import com.grack.nanojson.JsonObject\n+import com.grack.nanojson.JsonParser\n+import com.grack.nanojson.JsonParserException\n+import io.reactivex.Observable\n+import io.reactivex.android.schedulers.AndroidSchedulers\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.schedulers.Schedulers\n+import java.io.IOException\n+import java.security.MessageDigest\n+import java.security.NoSuchAlgorithmException\n+import java.security.cert.CertificateEncodingException\n+import java.security.cert.CertificateException\n+import java.security.cert.CertificateFactory\n+import java.security.cert.X509Certificate\n+import java.util.Locale\n+import org.schabi.newpipe.extractor.exceptions.ReCaptchaException\n+import org.schabi.newpipe.report.ErrorActivity\n+import org.schabi.newpipe.report.UserAction\n+\n+private const val TAG = \"CheckForNewAppVersion\"\n+private const val GITHUB_APK_SHA1 = \"B0:2E:90:7C:1C:D6:FC:57:C3:35:F0:88:D0:8F:50:5F:94:E4:D2:15\"\n+private const val NEWPIPE_API_URL = \"https://newpipe.schabi.org/api/data.json\"\n+\n+private val APP = App.getApp()\n+private val DEBUG = MainActivity.DEBUG\n+\n+/**\n+ * Property to get the apk's SHA1 key. See https://stackoverflow.com/questions/9293019/#22506133.\n+ *\n+ * @return String with the apk's SHA1 fingerprint in hexadecimal\n+ */\n+private val certificateSHA1Fingerprint: String?\n+    get() {\n+        val pm = APP.packageManager\n+        val packageName = APP.packageName\n+        val flags = PackageManager.GET_SIGNATURES\n+        var packageInfo: PackageInfo? = null\n+        try {\n+            packageInfo = pm.getPackageInfo(packageName, flags)\n+        } catch (e: PackageManager.NameNotFoundException) {\n+            ErrorActivity.reportError(APP, e, null, null,\n+                    ErrorActivity.ErrorInfo.make(UserAction.SOMETHING_ELSE, \"none\",\n+                            \"Could not find package info\", R.string.app_ui_crash))\n+        }\n+        val signatures = packageInfo!!.signatures\n+        val input = signatures[0].toByteArray().inputStream()\n+        var c: X509Certificate? = null\n+        try {\n+            val cf = CertificateFactory.getInstance(\"X509\")\n+            c = cf.generateCertificate(input) as X509Certificate\n+        } catch (e: CertificateException) {\n+            ErrorActivity.reportError(APP, e, null, null,\n+                    ErrorActivity.ErrorInfo.make(UserAction.SOMETHING_ELSE, \"none\",\n+                            \"Certificate error\", R.string.app_ui_crash))\n+        }\n+        var hexString: String? = null\n+        try {\n+            val md = MessageDigest.getInstance(\"SHA1\")\n+            val publicKey = md.digest(c!!.encoded)\n+            hexString = byte2HexFormatted(publicKey)\n+        } catch (e: NoSuchAlgorithmException) {\n+            ErrorActivity.reportError(APP, e, null, null,\n+                    ErrorActivity.ErrorInfo.make(UserAction.SOMETHING_ELSE, \"none\",\n+                            \"Could not retrieve SHA1 key\", R.string.app_ui_crash))\n+        } catch (e: CertificateEncodingException) {\n+            ErrorActivity.reportError(APP, e, null, null,\n+                    ErrorActivity.ErrorInfo.make(UserAction.SOMETHING_ELSE, \"none\",\n+                            \"Could not retrieve SHA1 key\", R.string.app_ui_crash))\n+        }\n+        return hexString\n+    }\n+\n+private val isConnected: Boolean\n+    get() = APP.getSystemService<ConnectivityManager>()?.activeNetworkInfo?.isConnected == true\n+\n+private var disposable: Disposable? = null\n+\n+val isGithubApk: Boolean\n+    get() = certificateSHA1Fingerprint == GITHUB_APK_SHA1\n+\n+private fun byte2HexFormatted(arr: ByteArray): String {\n+    val str = StringBuilder(arr.size * 2)\n+    for (i in arr.indices) {\n+        var h = Integer.toHexString(arr[i].toInt())\n+        val l = h.length\n+        if (l == 1) {\n+            h = \"0$h\"\n+        }\n+        if (l > 2) {\n+            h = h.substring(l - 2, l)\n+        }\n+        str.append(h.toUpperCase(Locale.ROOT))\n+        if (i < arr.size - 1) {\n+            str.append(':')\n+        }\n+    }\n+    return str.toString()\n+}\n+\n+/**\n+ * Method to compare the current and latest available app version.\n+ * If a newer version is available, we show the update notification.\n+ *\n+ * @param versionName Name of new version\n+ * @param apkLocationUrl Url with the new apk\n+ * @param versionCode Code of new version\n+ */\n+private fun compareAppVersionAndShowNotification(versionName: String, apkLocationUrl: String, versionCode: Int) {\n+    val notificationId = 2000\n+    if (BuildConfig.VERSION_CODE < versionCode) {\n+\n+        // A pending intent to open the apk location url in the browser.\n+        val intent = Intent(Intent.ACTION_VIEW, apkLocationUrl.toUri())\n+        val pendingIntent = PendingIntent.getActivity(APP, 0, intent, 0)\n+        val notificationBuilder = NotificationCompat.Builder(APP, APP.getString(R.string.app_update_notification_channel_id))\n+                .setSmallIcon(R.drawable.ic_newpipe_update)\n+                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n+                .setContentIntent(pendingIntent)\n+                .setAutoCancel(true)\n+                .setContentTitle(APP.getString(R.string.app_update_notification_content_title))\n+                .setContentText(APP.getString(R.string.app_update_notification_content_text) + \" \" + versionName)\n+        val notificationManager = NotificationManagerCompat.from(APP)\n+        notificationManager.notify(notificationId, notificationBuilder.build())\n+    }\n+}\n+\n+fun checkNewVersion() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4OTgxMg=="}, "originalCommit": {"oid": "5e2c67d88317aeb4220edbeaa3eafd42da31f7b2"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODk2MTE2OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/CheckForNewAppVersion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODoyMDo1OFrOHocrog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMzowNzo0OFrOHpUNUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3NTAxMA==", "bodyText": "Why this?", "url": "https://github.com/TeamNewPipe/NewPipe/pull/4499#discussion_r512175010", "createdAt": "2020-10-26T18:20:58Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/CheckForNewAppVersion.java", "diffHunk": "@@ -118,104 +122,110 @@ private static String byte2HexFormatted(final byte[] arr) {\n         return str.toString();\n     }\n \n-    public static boolean isGithubApk() {\n-        return getCertificateSHA1Fingerprint().equals(GITHUB_APK_SHA1);\n-    }\n-\n-    @Override\n-    protected void onPreExecute() {\n-        final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(APP);\n-\n-        // Check if user has enabled/disabled update checking\n-        // and if the current apk is a github one or not.\n-        if (!prefs.getBoolean(APP.getString(R.string.update_app_key), true) || !isGithubApk()) {\n-            this.cancel(true);\n-        }\n-    }\n-\n-    @Override\n-    protected String doInBackground(final Void... voids) {\n-        if (isCancelled() || !isConnected()) {\n-            return null;\n-        }\n-\n-        // Make a network request to get latest NewPipe data.\n-        try {\n-            return DownloaderImpl.getInstance().get(NEWPIPE_API_URL).responseBody();\n-        } catch (IOException | ReCaptchaException e) {\n-            // connectivity problems, do not alarm user and fail silently\n-            if (DEBUG) {\n-                Log.w(TAG, Log.getStackTraceString(e));\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    @Override\n-    protected void onPostExecute(final String response) {\n-        // Parse the json from the response.\n-        if (response != null) {\n-\n-            try {\n-                final JsonObject githubStableObject = JsonParser.object().from(response)\n-                        .getObject(\"flavors\").getObject(\"github\").getObject(\"stable\");\n-\n-                final String versionName = githubStableObject.getString(\"version\");\n-                final int versionCode = githubStableObject.getInt(\"version_code\");\n-                final String apkLocationUrl = githubStableObject.getString(\"apk\");\n-\n-                compareAppVersionAndShowNotification(versionName, apkLocationUrl, versionCode);\n-\n-            } catch (final JsonParserException e) {\n-                // connectivity problems, do not alarm user and fail silently\n-                if (DEBUG) {\n-                    Log.w(TAG, Log.getStackTraceString(e));\n-                }\n-            }\n-        }\n-    }\n-\n     /**\n      * Method to compare the current and latest available app version.\n      * If a newer version is available, we show the update notification.\n      *\n+     * @param application    The application\n      * @param versionName    Name of new version\n      * @param apkLocationUrl Url with the new apk\n      * @param versionCode    Code of new version\n      */\n-    private void compareAppVersionAndShowNotification(final String versionName,\n-                                                      final String apkLocationUrl,\n-                                                      final int versionCode) {\n+    private static void compareAppVersionAndShowNotification(@NonNull final Application application,\n+                                                             final String versionName,\n+                                                             final String apkLocationUrl,\n+                                                             final int versionCode) {\n         final int notificationId = 2000;\n \n         if (BuildConfig.VERSION_CODE < versionCode) {\n-\n             // A pending intent to open the apk location url in the browser.\n             final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(apkLocationUrl));\n             final PendingIntent pendingIntent\n-                    = PendingIntent.getActivity(APP, 0, intent, 0);\n+                    = PendingIntent.getActivity(application, 0, intent, 0);\n \n-            final NotificationCompat.Builder notificationBuilder = new NotificationCompat\n-                    .Builder(APP, APP.getString(R.string.app_update_notification_channel_id))\n+            final String channelId = application\n+                    .getString(R.string.app_update_notification_channel_id);\n+            final NotificationCompat.Builder notificationBuilder\n+                    = new NotificationCompat.Builder(application, channelId)\n                     .setSmallIcon(R.drawable.ic_newpipe_update)\n                     .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n                     .setContentIntent(pendingIntent)\n                     .setAutoCancel(true)\n-                    .setContentTitle(APP.getString(R.string.app_update_notification_content_title))\n-                    .setContentText(APP.getString(R.string.app_update_notification_content_text)\n+                    .setContentTitle(application\n+                            .getString(R.string.app_update_notification_content_title))\n+                    .setContentText(application\n+                            .getString(R.string.app_update_notification_content_text)\n                             + \" \" + versionName);\n \n             final NotificationManagerCompat notificationManager\n-                    = NotificationManagerCompat.from(APP);\n+                    = NotificationManagerCompat.from(application);\n             notificationManager.notify(notificationId, notificationBuilder.build());\n         }\n     }\n \n-    private boolean isConnected() {\n-        final ConnectivityManager cm = ContextCompat.getSystemService(APP,\n+    private static boolean isConnected(@NonNull final App app) {\n+        final ConnectivityManager cm = ContextCompat.getSystemService(app,\n                 ConnectivityManager.class);\n         return cm.getActiveNetworkInfo() != null\n                 && cm.getActiveNetworkInfo().isConnected();\n     }\n+\n+    public static boolean isGithubApk(@NonNull final App app) {\n+        return getCertificateSHA1Fingerprint(app).equals(GITHUB_APK_SHA1);\n+    }\n+\n+    public static void checkNewVersion(@NonNull final App app) {\n+        final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(app);\n+\n+        // Check if user has enabled/disabled update checking\n+        // and if the current apk is a github one or not.\n+        if (!prefs.getBoolean(app.getString(R.string.update_app_key), true)\n+                || !isGithubApk(app)) {\n+            if (disposable != null) {\n+                disposable.dispose();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f08ac8a45387eaa105e10c202c194dcf78ba99bc"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDc1Mw==", "bodyText": "I was trying to keep it as close to the original code as possible.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/4499#discussion_r513084753", "createdAt": "2020-10-27T23:07:48Z", "author": {"login": "Isira-Seneviratne"}, "path": "app/src/main/java/org/schabi/newpipe/CheckForNewAppVersion.java", "diffHunk": "@@ -118,104 +122,110 @@ private static String byte2HexFormatted(final byte[] arr) {\n         return str.toString();\n     }\n \n-    public static boolean isGithubApk() {\n-        return getCertificateSHA1Fingerprint().equals(GITHUB_APK_SHA1);\n-    }\n-\n-    @Override\n-    protected void onPreExecute() {\n-        final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(APP);\n-\n-        // Check if user has enabled/disabled update checking\n-        // and if the current apk is a github one or not.\n-        if (!prefs.getBoolean(APP.getString(R.string.update_app_key), true) || !isGithubApk()) {\n-            this.cancel(true);\n-        }\n-    }\n-\n-    @Override\n-    protected String doInBackground(final Void... voids) {\n-        if (isCancelled() || !isConnected()) {\n-            return null;\n-        }\n-\n-        // Make a network request to get latest NewPipe data.\n-        try {\n-            return DownloaderImpl.getInstance().get(NEWPIPE_API_URL).responseBody();\n-        } catch (IOException | ReCaptchaException e) {\n-            // connectivity problems, do not alarm user and fail silently\n-            if (DEBUG) {\n-                Log.w(TAG, Log.getStackTraceString(e));\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    @Override\n-    protected void onPostExecute(final String response) {\n-        // Parse the json from the response.\n-        if (response != null) {\n-\n-            try {\n-                final JsonObject githubStableObject = JsonParser.object().from(response)\n-                        .getObject(\"flavors\").getObject(\"github\").getObject(\"stable\");\n-\n-                final String versionName = githubStableObject.getString(\"version\");\n-                final int versionCode = githubStableObject.getInt(\"version_code\");\n-                final String apkLocationUrl = githubStableObject.getString(\"apk\");\n-\n-                compareAppVersionAndShowNotification(versionName, apkLocationUrl, versionCode);\n-\n-            } catch (final JsonParserException e) {\n-                // connectivity problems, do not alarm user and fail silently\n-                if (DEBUG) {\n-                    Log.w(TAG, Log.getStackTraceString(e));\n-                }\n-            }\n-        }\n-    }\n-\n     /**\n      * Method to compare the current and latest available app version.\n      * If a newer version is available, we show the update notification.\n      *\n+     * @param application    The application\n      * @param versionName    Name of new version\n      * @param apkLocationUrl Url with the new apk\n      * @param versionCode    Code of new version\n      */\n-    private void compareAppVersionAndShowNotification(final String versionName,\n-                                                      final String apkLocationUrl,\n-                                                      final int versionCode) {\n+    private static void compareAppVersionAndShowNotification(@NonNull final Application application,\n+                                                             final String versionName,\n+                                                             final String apkLocationUrl,\n+                                                             final int versionCode) {\n         final int notificationId = 2000;\n \n         if (BuildConfig.VERSION_CODE < versionCode) {\n-\n             // A pending intent to open the apk location url in the browser.\n             final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(apkLocationUrl));\n             final PendingIntent pendingIntent\n-                    = PendingIntent.getActivity(APP, 0, intent, 0);\n+                    = PendingIntent.getActivity(application, 0, intent, 0);\n \n-            final NotificationCompat.Builder notificationBuilder = new NotificationCompat\n-                    .Builder(APP, APP.getString(R.string.app_update_notification_channel_id))\n+            final String channelId = application\n+                    .getString(R.string.app_update_notification_channel_id);\n+            final NotificationCompat.Builder notificationBuilder\n+                    = new NotificationCompat.Builder(application, channelId)\n                     .setSmallIcon(R.drawable.ic_newpipe_update)\n                     .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n                     .setContentIntent(pendingIntent)\n                     .setAutoCancel(true)\n-                    .setContentTitle(APP.getString(R.string.app_update_notification_content_title))\n-                    .setContentText(APP.getString(R.string.app_update_notification_content_text)\n+                    .setContentTitle(application\n+                            .getString(R.string.app_update_notification_content_title))\n+                    .setContentText(application\n+                            .getString(R.string.app_update_notification_content_text)\n                             + \" \" + versionName);\n \n             final NotificationManagerCompat notificationManager\n-                    = NotificationManagerCompat.from(APP);\n+                    = NotificationManagerCompat.from(application);\n             notificationManager.notify(notificationId, notificationBuilder.build());\n         }\n     }\n \n-    private boolean isConnected() {\n-        final ConnectivityManager cm = ContextCompat.getSystemService(APP,\n+    private static boolean isConnected(@NonNull final App app) {\n+        final ConnectivityManager cm = ContextCompat.getSystemService(app,\n                 ConnectivityManager.class);\n         return cm.getActiveNetworkInfo() != null\n                 && cm.getActiveNetworkInfo().isConnected();\n     }\n+\n+    public static boolean isGithubApk(@NonNull final App app) {\n+        return getCertificateSHA1Fingerprint(app).equals(GITHUB_APK_SHA1);\n+    }\n+\n+    public static void checkNewVersion(@NonNull final App app) {\n+        final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(app);\n+\n+        // Check if user has enabled/disabled update checking\n+        // and if the current apk is a github one or not.\n+        if (!prefs.getBoolean(app.getString(R.string.update_app_key), true)\n+                || !isGithubApk(app)) {\n+            if (disposable != null) {\n+                disposable.dispose();\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3NTAxMA=="}, "originalCommit": {"oid": "f08ac8a45387eaa105e10c202c194dcf78ba99bc"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODk3MDYzOnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/CheckForNewAppVersion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODoyMzoyNFrOHocxhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMzowMzowNFrOHpUHAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3NjUxNg==", "bodyText": "Instead of saving the disposable to a static variable, which would actually create a leak, return it and, in the App class save it as a field to be dispose()d in the App's onDestroy()", "url": "https://github.com/TeamNewPipe/NewPipe/pull/4499#discussion_r512176516", "createdAt": "2020-10-26T18:23:24Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/CheckForNewAppVersion.java", "diffHunk": "@@ -118,104 +122,110 @@ private static String byte2HexFormatted(final byte[] arr) {\n         return str.toString();\n     }\n \n-    public static boolean isGithubApk() {\n-        return getCertificateSHA1Fingerprint().equals(GITHUB_APK_SHA1);\n-    }\n-\n-    @Override\n-    protected void onPreExecute() {\n-        final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(APP);\n-\n-        // Check if user has enabled/disabled update checking\n-        // and if the current apk is a github one or not.\n-        if (!prefs.getBoolean(APP.getString(R.string.update_app_key), true) || !isGithubApk()) {\n-            this.cancel(true);\n-        }\n-    }\n-\n-    @Override\n-    protected String doInBackground(final Void... voids) {\n-        if (isCancelled() || !isConnected()) {\n-            return null;\n-        }\n-\n-        // Make a network request to get latest NewPipe data.\n-        try {\n-            return DownloaderImpl.getInstance().get(NEWPIPE_API_URL).responseBody();\n-        } catch (IOException | ReCaptchaException e) {\n-            // connectivity problems, do not alarm user and fail silently\n-            if (DEBUG) {\n-                Log.w(TAG, Log.getStackTraceString(e));\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    @Override\n-    protected void onPostExecute(final String response) {\n-        // Parse the json from the response.\n-        if (response != null) {\n-\n-            try {\n-                final JsonObject githubStableObject = JsonParser.object().from(response)\n-                        .getObject(\"flavors\").getObject(\"github\").getObject(\"stable\");\n-\n-                final String versionName = githubStableObject.getString(\"version\");\n-                final int versionCode = githubStableObject.getInt(\"version_code\");\n-                final String apkLocationUrl = githubStableObject.getString(\"apk\");\n-\n-                compareAppVersionAndShowNotification(versionName, apkLocationUrl, versionCode);\n-\n-            } catch (final JsonParserException e) {\n-                // connectivity problems, do not alarm user and fail silently\n-                if (DEBUG) {\n-                    Log.w(TAG, Log.getStackTraceString(e));\n-                }\n-            }\n-        }\n-    }\n-\n     /**\n      * Method to compare the current and latest available app version.\n      * If a newer version is available, we show the update notification.\n      *\n+     * @param application    The application\n      * @param versionName    Name of new version\n      * @param apkLocationUrl Url with the new apk\n      * @param versionCode    Code of new version\n      */\n-    private void compareAppVersionAndShowNotification(final String versionName,\n-                                                      final String apkLocationUrl,\n-                                                      final int versionCode) {\n+    private static void compareAppVersionAndShowNotification(@NonNull final Application application,\n+                                                             final String versionName,\n+                                                             final String apkLocationUrl,\n+                                                             final int versionCode) {\n         final int notificationId = 2000;\n \n         if (BuildConfig.VERSION_CODE < versionCode) {\n-\n             // A pending intent to open the apk location url in the browser.\n             final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(apkLocationUrl));\n             final PendingIntent pendingIntent\n-                    = PendingIntent.getActivity(APP, 0, intent, 0);\n+                    = PendingIntent.getActivity(application, 0, intent, 0);\n \n-            final NotificationCompat.Builder notificationBuilder = new NotificationCompat\n-                    .Builder(APP, APP.getString(R.string.app_update_notification_channel_id))\n+            final String channelId = application\n+                    .getString(R.string.app_update_notification_channel_id);\n+            final NotificationCompat.Builder notificationBuilder\n+                    = new NotificationCompat.Builder(application, channelId)\n                     .setSmallIcon(R.drawable.ic_newpipe_update)\n                     .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n                     .setContentIntent(pendingIntent)\n                     .setAutoCancel(true)\n-                    .setContentTitle(APP.getString(R.string.app_update_notification_content_title))\n-                    .setContentText(APP.getString(R.string.app_update_notification_content_text)\n+                    .setContentTitle(application\n+                            .getString(R.string.app_update_notification_content_title))\n+                    .setContentText(application\n+                            .getString(R.string.app_update_notification_content_text)\n                             + \" \" + versionName);\n \n             final NotificationManagerCompat notificationManager\n-                    = NotificationManagerCompat.from(APP);\n+                    = NotificationManagerCompat.from(application);\n             notificationManager.notify(notificationId, notificationBuilder.build());\n         }\n     }\n \n-    private boolean isConnected() {\n-        final ConnectivityManager cm = ContextCompat.getSystemService(APP,\n+    private static boolean isConnected(@NonNull final App app) {\n+        final ConnectivityManager cm = ContextCompat.getSystemService(app,\n                 ConnectivityManager.class);\n         return cm.getActiveNetworkInfo() != null\n                 && cm.getActiveNetworkInfo().isConnected();\n     }\n+\n+    public static boolean isGithubApk(@NonNull final App app) {\n+        return getCertificateSHA1Fingerprint(app).equals(GITHUB_APK_SHA1);\n+    }\n+\n+    public static void checkNewVersion(@NonNull final App app) {\n+        final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(app);\n+\n+        // Check if user has enabled/disabled update checking\n+        // and if the current apk is a github one or not.\n+        if (!prefs.getBoolean(app.getString(R.string.update_app_key), true)\n+                || !isGithubApk(app)) {\n+            if (disposable != null) {\n+                disposable.dispose();\n+            }\n+            return;\n+        }\n+\n+        disposable = Observable.fromCallable(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f08ac8a45387eaa105e10c202c194dcf78ba99bc"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MzEzOA==", "bodyText": "Right, my bad. Thanks!", "url": "https://github.com/TeamNewPipe/NewPipe/pull/4499#discussion_r513083138", "createdAt": "2020-10-27T23:03:04Z", "author": {"login": "Isira-Seneviratne"}, "path": "app/src/main/java/org/schabi/newpipe/CheckForNewAppVersion.java", "diffHunk": "@@ -118,104 +122,110 @@ private static String byte2HexFormatted(final byte[] arr) {\n         return str.toString();\n     }\n \n-    public static boolean isGithubApk() {\n-        return getCertificateSHA1Fingerprint().equals(GITHUB_APK_SHA1);\n-    }\n-\n-    @Override\n-    protected void onPreExecute() {\n-        final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(APP);\n-\n-        // Check if user has enabled/disabled update checking\n-        // and if the current apk is a github one or not.\n-        if (!prefs.getBoolean(APP.getString(R.string.update_app_key), true) || !isGithubApk()) {\n-            this.cancel(true);\n-        }\n-    }\n-\n-    @Override\n-    protected String doInBackground(final Void... voids) {\n-        if (isCancelled() || !isConnected()) {\n-            return null;\n-        }\n-\n-        // Make a network request to get latest NewPipe data.\n-        try {\n-            return DownloaderImpl.getInstance().get(NEWPIPE_API_URL).responseBody();\n-        } catch (IOException | ReCaptchaException e) {\n-            // connectivity problems, do not alarm user and fail silently\n-            if (DEBUG) {\n-                Log.w(TAG, Log.getStackTraceString(e));\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    @Override\n-    protected void onPostExecute(final String response) {\n-        // Parse the json from the response.\n-        if (response != null) {\n-\n-            try {\n-                final JsonObject githubStableObject = JsonParser.object().from(response)\n-                        .getObject(\"flavors\").getObject(\"github\").getObject(\"stable\");\n-\n-                final String versionName = githubStableObject.getString(\"version\");\n-                final int versionCode = githubStableObject.getInt(\"version_code\");\n-                final String apkLocationUrl = githubStableObject.getString(\"apk\");\n-\n-                compareAppVersionAndShowNotification(versionName, apkLocationUrl, versionCode);\n-\n-            } catch (final JsonParserException e) {\n-                // connectivity problems, do not alarm user and fail silently\n-                if (DEBUG) {\n-                    Log.w(TAG, Log.getStackTraceString(e));\n-                }\n-            }\n-        }\n-    }\n-\n     /**\n      * Method to compare the current and latest available app version.\n      * If a newer version is available, we show the update notification.\n      *\n+     * @param application    The application\n      * @param versionName    Name of new version\n      * @param apkLocationUrl Url with the new apk\n      * @param versionCode    Code of new version\n      */\n-    private void compareAppVersionAndShowNotification(final String versionName,\n-                                                      final String apkLocationUrl,\n-                                                      final int versionCode) {\n+    private static void compareAppVersionAndShowNotification(@NonNull final Application application,\n+                                                             final String versionName,\n+                                                             final String apkLocationUrl,\n+                                                             final int versionCode) {\n         final int notificationId = 2000;\n \n         if (BuildConfig.VERSION_CODE < versionCode) {\n-\n             // A pending intent to open the apk location url in the browser.\n             final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(apkLocationUrl));\n             final PendingIntent pendingIntent\n-                    = PendingIntent.getActivity(APP, 0, intent, 0);\n+                    = PendingIntent.getActivity(application, 0, intent, 0);\n \n-            final NotificationCompat.Builder notificationBuilder = new NotificationCompat\n-                    .Builder(APP, APP.getString(R.string.app_update_notification_channel_id))\n+            final String channelId = application\n+                    .getString(R.string.app_update_notification_channel_id);\n+            final NotificationCompat.Builder notificationBuilder\n+                    = new NotificationCompat.Builder(application, channelId)\n                     .setSmallIcon(R.drawable.ic_newpipe_update)\n                     .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n                     .setContentIntent(pendingIntent)\n                     .setAutoCancel(true)\n-                    .setContentTitle(APP.getString(R.string.app_update_notification_content_title))\n-                    .setContentText(APP.getString(R.string.app_update_notification_content_text)\n+                    .setContentTitle(application\n+                            .getString(R.string.app_update_notification_content_title))\n+                    .setContentText(application\n+                            .getString(R.string.app_update_notification_content_text)\n                             + \" \" + versionName);\n \n             final NotificationManagerCompat notificationManager\n-                    = NotificationManagerCompat.from(APP);\n+                    = NotificationManagerCompat.from(application);\n             notificationManager.notify(notificationId, notificationBuilder.build());\n         }\n     }\n \n-    private boolean isConnected() {\n-        final ConnectivityManager cm = ContextCompat.getSystemService(APP,\n+    private static boolean isConnected(@NonNull final App app) {\n+        final ConnectivityManager cm = ContextCompat.getSystemService(app,\n                 ConnectivityManager.class);\n         return cm.getActiveNetworkInfo() != null\n                 && cm.getActiveNetworkInfo().isConnected();\n     }\n+\n+    public static boolean isGithubApk(@NonNull final App app) {\n+        return getCertificateSHA1Fingerprint(app).equals(GITHUB_APK_SHA1);\n+    }\n+\n+    public static void checkNewVersion(@NonNull final App app) {\n+        final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(app);\n+\n+        // Check if user has enabled/disabled update checking\n+        // and if the current apk is a github one or not.\n+        if (!prefs.getBoolean(app.getString(R.string.update_app_key), true)\n+                || !isGithubApk(app)) {\n+            if (disposable != null) {\n+                disposable.dispose();\n+            }\n+            return;\n+        }\n+\n+        disposable = Observable.fromCallable(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3NjUxNg=="}, "originalCommit": {"oid": "f08ac8a45387eaa105e10c202c194dcf78ba99bc"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODk4MTY5OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/us/shandian/giga/ui/adapter/MissionAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODoyNjoxNFrOHoc4RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODoyNjoxNFrOHoc4RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3ODI0NA==", "bodyText": "This also needs to be saved somewhere and be disposed on close", "url": "https://github.com/TeamNewPipe/NewPipe/pull/4499#discussion_r512178244", "createdAt": "2020-10-26T18:26:14Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/us/shandian/giga/ui/adapter/MissionAdapter.java", "diffHunk": "@@ -676,7 +675,27 @@ private boolean handlePopupItem(@NonNull ViewHolderItem h, @NonNull MenuItem opt\n                 return true;\n             case R.id.md5:\n             case R.id.sha1:\n-                new ChecksumTask(mContext).execute(h.item.mission.storage, ALGORITHMS.get(id));\n+                ProgressDialog progressDialog = null;\n+                if (mContext != null) {\n+                    // Create dialog\n+                    progressDialog = new ProgressDialog(mContext);\n+                    progressDialog.setCancelable(false);\n+                    progressDialog.setMessage(mContext.getString(R.string.msg_wait));\n+                    progressDialog.show();\n+                }\n+                final ProgressDialog finalProgressDialog = progressDialog;\n+                final StoredFileHelper storage = h.item.mission.storage;\n+                Observable.fromCallable(() -> Utility.checksum(storage, ALGORITHMS.get(id)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f08ac8a45387eaa105e10c202c194dcf78ba99bc"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjgyMDk0OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/App.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOTo1NTowMlrOHr9Vrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOTo1NTowMlrOHr9Vrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg1NTc5MQ==", "bodyText": "Make private Disposable disposable = null and add a null check here, just to be sure.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/4499#discussion_r515855791", "createdAt": "2020-11-02T09:55:02Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/App.java", "diffHunk": "@@ -100,7 +104,13 @@ public void onCreate() {\n         configureRxJavaErrorHandler();\n \n         // Check for new version\n-        new CheckForNewAppVersionTask().execute();\n+        disposable = CheckForNewAppVersion.checkNewVersion(App.getApp());\n+    }\n+\n+    @Override\n+    public void onTerminate() {\n+        disposable.dispose();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb629ca0c47da3fffbdc2f9999016a2930cd46c5"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjgyNDYzOnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/about/LicenseFragmentHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOTo1NTo1NlrOHr9X4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOTo1NTo1NlrOHr9X4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg1NjM1Mg==", "bodyText": "Please also return this as a Disposable and add a CompositeDisposable in LicenseFragment", "url": "https://github.com/TeamNewPipe/NewPipe/pull/4499#discussion_r515856352", "createdAt": "2020-11-02T09:55:56Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/about/LicenseFragmentHelper.java", "diffHunk": "@@ -84,45 +80,31 @@ private static String getLicenseStylesheet(final Context context) {\n      * @param color   the color number from R.color\n      * @return a six characters long String with hexadecimal RGB values\n      */\n-    private static String getHexRGBColor(final Context context, final int color) {\n+    private static String getHexRGBColor(@NonNull final Context context, final int color) {\n         return context.getResources().getString(color).substring(3);\n     }\n \n-    @Nullable\n-    private Activity getActivity() {\n-        final Activity activity = weakReference.get();\n-\n-        if (activity != null && activity.isFinishing()) {\n-            return null;\n-        } else {\n-            return activity;\n-        }\n-    }\n-\n-    @Override\n-    protected Integer doInBackground(final Object... objects) {\n-        license = (License) objects[0];\n-        return 1;\n-    }\n-\n-    @Override\n-    protected void onPostExecute(final Integer result) {\n-        final Activity activity = getActivity();\n-        if (activity == null) {\n+    static void showLicense(@Nullable final Context context, @NonNull final License license) {\n+        if (context == null) {\n             return;\n         }\n \n-        final String webViewData = Base64.encodeToString(getFormattedLicense(activity, license)\n-                .getBytes(StandardCharsets.UTF_8), Base64.NO_PADDING);\n-        final WebView webView = new WebView(activity);\n-        webView.loadData(webViewData, \"text/html; charset=UTF-8\", \"base64\");\n-\n-        final AlertDialog.Builder alert = new AlertDialog.Builder(activity);\n-        alert.setTitle(license.getName());\n-        alert.setView(webView);\n-        assureCorrectAppLanguage(activity);\n-        alert.setNegativeButton(activity.getString(R.string.finish),\n-                (dialog, which) -> dialog.dismiss());\n-        alert.show();\n+        Observable.fromCallable(() -> getFormattedLicense(context, license))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb629ca0c47da3fffbdc2f9999016a2930cd46c5"}, "originalPosition": 90}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2964, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}