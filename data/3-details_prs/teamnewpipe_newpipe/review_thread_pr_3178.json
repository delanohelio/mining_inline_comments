{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyNjc2MjU1", "number": 3178, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNzo1NDo1NFrOEh_wIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjozNToxMlrOElv7aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MDgyOTc4OnYy", "diffSide": "LEFT", "path": "app/src/main/java/org/schabi/newpipe/player/helper/MediaSessionManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNzo1NDo1NFrOHPnjdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxODowNTowMVrOHQor9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEzODc0Mg==", "bodyText": "Just a question. Was this the reason for the missing metadata? Because it was overwritten here?", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r486138742", "createdAt": "2020-09-10T07:54:54Z", "author": {"login": "Redirion"}, "path": "app/src/main/java/org/schabi/newpipe/player/helper/MediaSessionManager.java", "diffHunk": "@@ -49,46 +63,82 @@ public KeyEvent handleMediaButtonIntent(final Intent intent) {\n         return MediaButtonReceiver.handleIntent(mediaSession, intent);\n     }\n \n-    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n-    public void setLockScreenArt(final NotificationCompat.Builder builder,\n-                                 @Nullable final Bitmap thumbnailBitmap) {\n-        if (thumbnailBitmap == null || !mediaSession.isActive()) {\n+    public MediaSessionCompat.Token getSessionToken() {\n+        return mediaSession.getSessionToken();\n+    }\n+\n+    public void setMetadata(final String title,\n+                            final String artist,\n+                            final Bitmap albumArt,\n+                            final long duration) {\n+        if (albumArt == null || !mediaSession.isActive()) {\n             return;\n         }\n \n-        mediaSession.setMetadata(\n-                new MediaMetadataCompat.Builder()\n-                        .putBitmap(MediaMetadata.METADATA_KEY_ALBUM_ART, thumbnailBitmap)\n-                        .build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be73e9c249ca49d95309f9ed7a0fa168fec46f81"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwNTg3Ng==", "bodyText": "I can't help you with this, as this part was done by @cool-student. But I think you are right, and the issue was about inconsistent metadata updates not containing every piece of information", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r487205876", "createdAt": "2020-09-11T18:05:01Z", "author": {"login": "Stypox"}, "path": "app/src/main/java/org/schabi/newpipe/player/helper/MediaSessionManager.java", "diffHunk": "@@ -49,46 +63,82 @@ public KeyEvent handleMediaButtonIntent(final Intent intent) {\n         return MediaButtonReceiver.handleIntent(mediaSession, intent);\n     }\n \n-    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n-    public void setLockScreenArt(final NotificationCompat.Builder builder,\n-                                 @Nullable final Bitmap thumbnailBitmap) {\n-        if (thumbnailBitmap == null || !mediaSession.isActive()) {\n+    public MediaSessionCompat.Token getSessionToken() {\n+        return mediaSession.getSessionToken();\n+    }\n+\n+    public void setMetadata(final String title,\n+                            final String artist,\n+                            final Bitmap albumArt,\n+                            final long duration) {\n+        if (albumArt == null || !mediaSession.isActive()) {\n             return;\n         }\n \n-        mediaSession.setMetadata(\n-                new MediaMetadataCompat.Builder()\n-                        .putBitmap(MediaMetadata.METADATA_KEY_ALBUM_ART, thumbnailBitmap)\n-                        .build()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEzODc0Mg=="}, "originalCommit": {"oid": "be73e9c249ca49d95309f9ed7a0fa168fec46f81"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MTU0MDI1OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/player/BasePlayer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMTowMzo1OVrOHPuZMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMTowMzo1OVrOHPuZMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI1MDgwMw==", "bodyText": "Is this done to prevent negative positions when using rewind? If this is the case, please add a comment in the code to clarify why the check is necessary.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r486250803", "createdAt": "2020-09-10T11:03:59Z", "author": {"login": "TobiGr"}, "path": "app/src/main/java/org/schabi/newpipe/player/BasePlayer.java", "diffHunk": "@@ -1239,7 +1242,14 @@ public void seekTo(final long positionMillis) {\n             Log.d(TAG, \"seekBy() called with: position = [\" + positionMillis + \"]\");\n         }\n         if (simpleExoPlayer != null) {\n-            simpleExoPlayer.seekTo(positionMillis);\n+            long normalizedPositionMillis = positionMillis;\n+            if (normalizedPositionMillis < 0) {\n+                normalizedPositionMillis = 0;\n+            } else if (normalizedPositionMillis > simpleExoPlayer.getDuration()) {\n+                normalizedPositionMillis = simpleExoPlayer.getDuration();\n+            }\n+\n+            simpleExoPlayer.seekTo(normalizedPositionMillis);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be73e9c249ca49d95309f9ed7a0fa168fec46f81"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MTU4MjAxOnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/player/helper/MediaSessionManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMToxNjo0OFrOHPuyeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMToxNjo0OFrOHPuyeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI1NzI3Mw==", "bodyText": "Just use the MainActivity.DEBUG instead of doing the same check again.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r486257273", "createdAt": "2020-09-10T11:16:48Z", "author": {"login": "TobiGr"}, "path": "app/src/main/java/org/schabi/newpipe/player/helper/MediaSessionManager.java", "diffHunk": "@@ -3,44 +3,58 @@\n import android.content.Context;\n import android.content.Intent;\n import android.graphics.Bitmap;\n-import android.media.MediaMetadata;\n-import android.os.Build;\n import android.support.v4.media.MediaMetadataCompat;\n import android.support.v4.media.session.MediaSessionCompat;\n+import android.support.v4.media.session.PlaybackStateCompat;\n+import android.util.Log;\n import android.view.KeyEvent;\n \n import androidx.annotation.NonNull;\n import androidx.annotation.Nullable;\n-import androidx.annotation.RequiresApi;\n-import androidx.core.app.NotificationCompat;\n-import androidx.media.app.NotificationCompat.MediaStyle;\n import androidx.media.session.MediaButtonReceiver;\n \n import com.google.android.exoplayer2.Player;\n import com.google.android.exoplayer2.ext.mediasession.MediaSessionConnector;\n \n+import org.schabi.newpipe.BuildConfig;\n import org.schabi.newpipe.player.mediasession.MediaSessionCallback;\n import org.schabi.newpipe.player.mediasession.PlayQueueNavigator;\n import org.schabi.newpipe.player.mediasession.PlayQueuePlaybackController;\n \n public class MediaSessionManager {\n     private static final String TAG = \"MediaSessionManager\";\n+    public static final boolean DEBUG = !BuildConfig.BUILD_TYPE.equals(\"release\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be73e9c249ca49d95309f9ed7a0fa168fec46f81"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjI0MTAwOnYy", "diffSide": "RIGHT", "path": "app/src/main/AndroidManifest.xml", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMTo1MDoyOFrOHQbtNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjozMTo0MFrOHQc53w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5MzIwNQ==", "bodyText": "The documentation doesn't say what effect this has. Are you just future-proofing the code?", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r486993205", "createdAt": "2020-09-11T11:50:28Z", "author": {"login": "opusforlife2"}, "path": "app/src/main/AndroidManifest.xml", "diffHunk": "@@ -44,8 +44,9 @@\n         </receiver>\n \n         <service\n-                android:name=\".player.MainPlayer\"\n-                android:exported=\"false\">\n+            android:name=\".player.MainPlayer\"\n+            android:exported=\"false\"\n+            android:foregroundServiceType=\"mediaPlayback\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2017e6a3e31d2a03a399c82f712001a8e3c01a05"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwMTc3NQ==", "bodyText": "Obviously yes, as I want to make 0.20.0 as unstable as I possibly can without anyone knowing... just joking ;-)\nThis line is needed due to this line in NotificationUtil: basically, on newer android versions, when starting a foreground service you can tell the system what its purpose is, so I did just that (also, on newer android versions, starting a foreground service without providing the type is deprecated). But in order to have a service of a specific type, it has to be declared as such in the manifest.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r487001775", "createdAt": "2020-09-11T12:09:07Z", "author": {"login": "Stypox"}, "path": "app/src/main/AndroidManifest.xml", "diffHunk": "@@ -44,8 +44,9 @@\n         </receiver>\n \n         <service\n-                android:name=\".player.MainPlayer\"\n-                android:exported=\"false\">\n+            android:name=\".player.MainPlayer\"\n+            android:exported=\"false\"\n+            android:foregroundServiceType=\"mediaPlayback\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5MzIwNQ=="}, "originalCommit": {"oid": "2017e6a3e31d2a03a399c82f712001a8e3c01a05"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwNzQwOA==", "bodyText": "you can tell the system what its purpose is\n\nDoes this have any effect yet, though? Or is this something Android will use in the future so they simply introduced it now?", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r487007408", "createdAt": "2020-09-11T12:20:51Z", "author": {"login": "opusforlife2"}, "path": "app/src/main/AndroidManifest.xml", "diffHunk": "@@ -44,8 +44,9 @@\n         </receiver>\n \n         <service\n-                android:name=\".player.MainPlayer\"\n-                android:exported=\"false\">\n+            android:name=\".player.MainPlayer\"\n+            android:exported=\"false\"\n+            android:foregroundServiceType=\"mediaPlayback\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5MzIwNQ=="}, "originalCommit": {"oid": "2017e6a3e31d2a03a399c82f712001a8e3c01a05"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAxMjgzMQ==", "bodyText": "For other types of foreground services it has effects (e.g. storage can't be accessed in a foreground service without a storage service type, and other permission related things). For media playback I don't think it has, but it is still a flag that can be used by the system to optimize resource allocation, I think.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r487012831", "createdAt": "2020-09-11T12:31:40Z", "author": {"login": "Stypox"}, "path": "app/src/main/AndroidManifest.xml", "diffHunk": "@@ -44,8 +44,9 @@\n         </receiver>\n \n         <service\n-                android:name=\".player.MainPlayer\"\n-                android:exported=\"false\">\n+            android:name=\".player.MainPlayer\"\n+            android:exported=\"false\"\n+            android:foregroundServiceType=\"mediaPlayback\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5MzIwNQ=="}, "originalCommit": {"oid": "2017e6a3e31d2a03a399c82f712001a8e3c01a05"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDE3NjMwOnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/player/NotificationUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjozNDoxNVrOHVZSNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjozNDoxNVrOHVZSNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5NjQwNw==", "bodyText": "The action titles need to be localized for better accessibility.", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r492196407", "createdAt": "2020-09-21T16:34:15Z", "author": {"login": "TobiGr"}, "path": "app/src/main/java/org/schabi/newpipe/player/NotificationUtil.java", "diffHunk": "@@ -0,0 +1,368 @@\n+package org.schabi.newpipe.player;\n+\n+import android.annotation.SuppressLint;\n+import android.app.PendingIntent;\n+import android.app.Service;\n+import android.content.Intent;\n+import android.content.pm.ServiceInfo;\n+import android.graphics.Bitmap;\n+import android.graphics.Matrix;\n+import android.os.Build;\n+import android.util.Log;\n+\n+import androidx.annotation.DrawableRes;\n+import androidx.annotation.Nullable;\n+import androidx.core.app.NotificationCompat;\n+import androidx.core.app.NotificationManagerCompat;\n+import androidx.core.content.ContextCompat;\n+\n+import org.schabi.newpipe.MainActivity;\n+import org.schabi.newpipe.R;\n+import org.schabi.newpipe.util.NavigationHelper;\n+\n+import java.util.List;\n+\n+import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;\n+import static com.google.android.exoplayer2.Player.REPEAT_MODE_ALL;\n+import static com.google.android.exoplayer2.Player.REPEAT_MODE_ONE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_BUFFERING;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_CLOSE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_FAST_FORWARD;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_FAST_REWIND;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_NEXT;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_PAUSE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_PREVIOUS;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_REPEAT;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_SHUFFLE;\n+\n+/**\n+ * This is a utility class for player notifications.\n+ *\n+ * @author cool-student\n+ */\n+public final class NotificationUtil {\n+    private static final String TAG = NotificationUtil.class.getSimpleName();\n+    private static final boolean DEBUG = BasePlayer.DEBUG;\n+    private static final int NOTIFICATION_ID = 123789;\n+\n+    @Nullable private static NotificationUtil instance = null;\n+\n+    @NotificationConstants.Action\n+    private int[] notificationSlots = NotificationConstants.SLOT_DEFAULTS.clone();\n+\n+    private NotificationManagerCompat notificationManager;\n+    private NotificationCompat.Builder notificationBuilder;\n+\n+    private NotificationUtil() {\n+    }\n+\n+    public static NotificationUtil getInstance() {\n+        if (instance == null) {\n+            instance = new NotificationUtil();\n+        }\n+        return instance;\n+    }\n+\n+\n+    /////////////////////////////////////////////////////\n+    // NOTIFICATION\n+    /////////////////////////////////////////////////////\n+\n+    /**\n+     * Creates the notification if it does not exist already and recreates it if forceRecreate is\n+     * true. Updates the notification with the data in the player.\n+     * @param player the player currently open, to take data from\n+     * @param forceRecreate whether to force the recreation of the notification even if it already\n+     *                      exists\n+     */\n+    synchronized void createNotificationIfNeededAndUpdate(final VideoPlayerImpl player,\n+                                                          final boolean forceRecreate) {\n+        if (forceRecreate || notificationBuilder == null) {\n+            notificationBuilder = createNotification(player);\n+        }\n+        updateNotification(player);\n+        notificationManager.notify(NOTIFICATION_ID, notificationBuilder.build());\n+    }\n+\n+    private synchronized NotificationCompat.Builder createNotification(\n+            final VideoPlayerImpl player) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"createNotification()\");\n+        }\n+        notificationManager = NotificationManagerCompat.from(player.context);\n+        final NotificationCompat.Builder builder = new NotificationCompat.Builder(player.context,\n+                player.context.getString(R.string.notification_channel_id));\n+\n+        initializeNotificationSlots(player);\n+\n+        // count the number of real slots, to make sure compact slots indices are not out of bound\n+        int nonNothingSlotCount = 5;\n+        if (notificationSlots[3] == NotificationConstants.NOTHING) {\n+            --nonNothingSlotCount;\n+        }\n+        if (notificationSlots[4] == NotificationConstants.NOTHING) {\n+            --nonNothingSlotCount;\n+        }\n+\n+        // build the compact slot indices array (need code to convert from Integer... because Java)\n+        final List<Integer> compactSlotList = NotificationConstants.getCompactSlotsFromPreferences(\n+                player.context, player.sharedPreferences, nonNothingSlotCount);\n+        final int[] compactSlots = new int[compactSlotList.size()];\n+        for (int i = 0; i < compactSlotList.size(); i++) {\n+            compactSlots[i] = compactSlotList.get(i);\n+        }\n+\n+        builder.setStyle(new androidx.media.app.NotificationCompat.MediaStyle()\n+                    .setMediaSession(player.mediaSessionManager.getSessionToken())\n+                    .setShowActionsInCompactView(compactSlots))\n+                .setPriority(NotificationCompat.PRIORITY_HIGH)\n+                .setSmallIcon(R.drawable.ic_newpipe_triangle_white)\n+                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n+                .setColor(ContextCompat.getColor(player.context, R.color.gray))\n+                .setCategory(NotificationCompat.CATEGORY_TRANSPORT)\n+                .setDeleteIntent(PendingIntent.getBroadcast(player.context, NOTIFICATION_ID,\n+                        new Intent(ACTION_CLOSE), FLAG_UPDATE_CURRENT));\n+\n+        return builder;\n+    }\n+\n+    /**\n+     * Updates the notification builder and the button icons depending on the playback state.\n+     * @param player the player currently open, to take data from\n+     */\n+    private synchronized void updateNotification(final VideoPlayerImpl player) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"updateNotification()\");\n+        }\n+\n+        // also update content intent, in case the user switched players\n+        notificationBuilder.setContentIntent(PendingIntent.getActivity(player.context,\n+                NOTIFICATION_ID, getIntentForNotification(player), FLAG_UPDATE_CURRENT));\n+        notificationBuilder.setContentTitle(player.getVideoTitle());\n+        notificationBuilder.setContentText(player.getUploaderName());\n+        notificationBuilder.setTicker(player.getVideoTitle());\n+        updateActions(notificationBuilder, player);\n+        setLargeIcon(notificationBuilder, player);\n+    }\n+\n+\n+    boolean hasSlotWithBuffering() {\n+        return notificationSlots[1] == NotificationConstants.PLAY_PAUSE_BUFFERING\n+                || notificationSlots[2] == NotificationConstants.PLAY_PAUSE_BUFFERING;\n+    }\n+\n+\n+    void createNotificationAndStartForeground(final VideoPlayerImpl player, final Service service) {\n+        if (notificationBuilder == null) {\n+            notificationBuilder = createNotification(player);\n+        }\n+        updateNotification(player);\n+\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n+            service.startForeground(NOTIFICATION_ID, notificationBuilder.build(),\n+                    ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK);\n+        } else {\n+            service.startForeground(NOTIFICATION_ID, notificationBuilder.build());\n+        }\n+    }\n+\n+    void cancelNotificationAndStopForeground(final Service service) {\n+        service.stopForeground(true);\n+\n+        if (notificationManager != null) {\n+            notificationManager.cancel(NOTIFICATION_ID);\n+        }\n+        notificationManager = null;\n+        notificationBuilder = null;\n+    }\n+\n+\n+    /////////////////////////////////////////////////////\n+    // ACTIONS\n+    /////////////////////////////////////////////////////\n+\n+    private void initializeNotificationSlots(final VideoPlayerImpl player) {\n+        for (int i = 0; i < 5; ++i) {\n+            notificationSlots[i] = player.sharedPreferences.getInt(\n+                    player.context.getString(NotificationConstants.SLOT_PREF_KEYS[i]),\n+                    NotificationConstants.SLOT_DEFAULTS[i]);\n+        }\n+    }\n+\n+    @SuppressLint(\"RestrictedApi\")\n+    private void updateActions(final NotificationCompat.Builder builder,\n+                               final VideoPlayerImpl player) {\n+        builder.mActions.clear();\n+        for (int i = 0; i < 5; ++i) {\n+            addAction(builder, player, notificationSlots[i]);\n+        }\n+    }\n+\n+    private void addAction(final NotificationCompat.Builder builder,\n+                           final VideoPlayerImpl player,\n+                           @NotificationConstants.Action final int slot) {\n+        final NotificationCompat.Action action = getAction(player, slot);\n+        if (action != null) {\n+            builder.addAction(action);\n+        }\n+    }\n+\n+    @Nullable\n+    private NotificationCompat.Action getAction(\n+            final VideoPlayerImpl player,\n+            @NotificationConstants.Action final int selectedAction) {\n+        final int baseActionIcon = NotificationConstants.ACTION_ICONS[selectedAction];\n+        switch (selectedAction) {\n+            case NotificationConstants.PREVIOUS:\n+                return getAction(player, baseActionIcon, \"Previous\", ACTION_PLAY_PREVIOUS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7317737e90ef096fd72b3d1df1e16d04ff2d1d06"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDE3NzI5OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/player/NotificationUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjozNDozMlrOHVZS4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjozNDozMlrOHVZS4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5NjU3Ng==", "bodyText": "Same here", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r492196576", "createdAt": "2020-09-21T16:34:32Z", "author": {"login": "TobiGr"}, "path": "app/src/main/java/org/schabi/newpipe/player/NotificationUtil.java", "diffHunk": "@@ -0,0 +1,368 @@\n+package org.schabi.newpipe.player;\n+\n+import android.annotation.SuppressLint;\n+import android.app.PendingIntent;\n+import android.app.Service;\n+import android.content.Intent;\n+import android.content.pm.ServiceInfo;\n+import android.graphics.Bitmap;\n+import android.graphics.Matrix;\n+import android.os.Build;\n+import android.util.Log;\n+\n+import androidx.annotation.DrawableRes;\n+import androidx.annotation.Nullable;\n+import androidx.core.app.NotificationCompat;\n+import androidx.core.app.NotificationManagerCompat;\n+import androidx.core.content.ContextCompat;\n+\n+import org.schabi.newpipe.MainActivity;\n+import org.schabi.newpipe.R;\n+import org.schabi.newpipe.util.NavigationHelper;\n+\n+import java.util.List;\n+\n+import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;\n+import static com.google.android.exoplayer2.Player.REPEAT_MODE_ALL;\n+import static com.google.android.exoplayer2.Player.REPEAT_MODE_ONE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_BUFFERING;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_CLOSE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_FAST_FORWARD;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_FAST_REWIND;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_NEXT;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_PAUSE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_PREVIOUS;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_REPEAT;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_SHUFFLE;\n+\n+/**\n+ * This is a utility class for player notifications.\n+ *\n+ * @author cool-student\n+ */\n+public final class NotificationUtil {\n+    private static final String TAG = NotificationUtil.class.getSimpleName();\n+    private static final boolean DEBUG = BasePlayer.DEBUG;\n+    private static final int NOTIFICATION_ID = 123789;\n+\n+    @Nullable private static NotificationUtil instance = null;\n+\n+    @NotificationConstants.Action\n+    private int[] notificationSlots = NotificationConstants.SLOT_DEFAULTS.clone();\n+\n+    private NotificationManagerCompat notificationManager;\n+    private NotificationCompat.Builder notificationBuilder;\n+\n+    private NotificationUtil() {\n+    }\n+\n+    public static NotificationUtil getInstance() {\n+        if (instance == null) {\n+            instance = new NotificationUtil();\n+        }\n+        return instance;\n+    }\n+\n+\n+    /////////////////////////////////////////////////////\n+    // NOTIFICATION\n+    /////////////////////////////////////////////////////\n+\n+    /**\n+     * Creates the notification if it does not exist already and recreates it if forceRecreate is\n+     * true. Updates the notification with the data in the player.\n+     * @param player the player currently open, to take data from\n+     * @param forceRecreate whether to force the recreation of the notification even if it already\n+     *                      exists\n+     */\n+    synchronized void createNotificationIfNeededAndUpdate(final VideoPlayerImpl player,\n+                                                          final boolean forceRecreate) {\n+        if (forceRecreate || notificationBuilder == null) {\n+            notificationBuilder = createNotification(player);\n+        }\n+        updateNotification(player);\n+        notificationManager.notify(NOTIFICATION_ID, notificationBuilder.build());\n+    }\n+\n+    private synchronized NotificationCompat.Builder createNotification(\n+            final VideoPlayerImpl player) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"createNotification()\");\n+        }\n+        notificationManager = NotificationManagerCompat.from(player.context);\n+        final NotificationCompat.Builder builder = new NotificationCompat.Builder(player.context,\n+                player.context.getString(R.string.notification_channel_id));\n+\n+        initializeNotificationSlots(player);\n+\n+        // count the number of real slots, to make sure compact slots indices are not out of bound\n+        int nonNothingSlotCount = 5;\n+        if (notificationSlots[3] == NotificationConstants.NOTHING) {\n+            --nonNothingSlotCount;\n+        }\n+        if (notificationSlots[4] == NotificationConstants.NOTHING) {\n+            --nonNothingSlotCount;\n+        }\n+\n+        // build the compact slot indices array (need code to convert from Integer... because Java)\n+        final List<Integer> compactSlotList = NotificationConstants.getCompactSlotsFromPreferences(\n+                player.context, player.sharedPreferences, nonNothingSlotCount);\n+        final int[] compactSlots = new int[compactSlotList.size()];\n+        for (int i = 0; i < compactSlotList.size(); i++) {\n+            compactSlots[i] = compactSlotList.get(i);\n+        }\n+\n+        builder.setStyle(new androidx.media.app.NotificationCompat.MediaStyle()\n+                    .setMediaSession(player.mediaSessionManager.getSessionToken())\n+                    .setShowActionsInCompactView(compactSlots))\n+                .setPriority(NotificationCompat.PRIORITY_HIGH)\n+                .setSmallIcon(R.drawable.ic_newpipe_triangle_white)\n+                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n+                .setColor(ContextCompat.getColor(player.context, R.color.gray))\n+                .setCategory(NotificationCompat.CATEGORY_TRANSPORT)\n+                .setDeleteIntent(PendingIntent.getBroadcast(player.context, NOTIFICATION_ID,\n+                        new Intent(ACTION_CLOSE), FLAG_UPDATE_CURRENT));\n+\n+        return builder;\n+    }\n+\n+    /**\n+     * Updates the notification builder and the button icons depending on the playback state.\n+     * @param player the player currently open, to take data from\n+     */\n+    private synchronized void updateNotification(final VideoPlayerImpl player) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"updateNotification()\");\n+        }\n+\n+        // also update content intent, in case the user switched players\n+        notificationBuilder.setContentIntent(PendingIntent.getActivity(player.context,\n+                NOTIFICATION_ID, getIntentForNotification(player), FLAG_UPDATE_CURRENT));\n+        notificationBuilder.setContentTitle(player.getVideoTitle());\n+        notificationBuilder.setContentText(player.getUploaderName());\n+        notificationBuilder.setTicker(player.getVideoTitle());\n+        updateActions(notificationBuilder, player);\n+        setLargeIcon(notificationBuilder, player);\n+    }\n+\n+\n+    boolean hasSlotWithBuffering() {\n+        return notificationSlots[1] == NotificationConstants.PLAY_PAUSE_BUFFERING\n+                || notificationSlots[2] == NotificationConstants.PLAY_PAUSE_BUFFERING;\n+    }\n+\n+\n+    void createNotificationAndStartForeground(final VideoPlayerImpl player, final Service service) {\n+        if (notificationBuilder == null) {\n+            notificationBuilder = createNotification(player);\n+        }\n+        updateNotification(player);\n+\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n+            service.startForeground(NOTIFICATION_ID, notificationBuilder.build(),\n+                    ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK);\n+        } else {\n+            service.startForeground(NOTIFICATION_ID, notificationBuilder.build());\n+        }\n+    }\n+\n+    void cancelNotificationAndStopForeground(final Service service) {\n+        service.stopForeground(true);\n+\n+        if (notificationManager != null) {\n+            notificationManager.cancel(NOTIFICATION_ID);\n+        }\n+        notificationManager = null;\n+        notificationBuilder = null;\n+    }\n+\n+\n+    /////////////////////////////////////////////////////\n+    // ACTIONS\n+    /////////////////////////////////////////////////////\n+\n+    private void initializeNotificationSlots(final VideoPlayerImpl player) {\n+        for (int i = 0; i < 5; ++i) {\n+            notificationSlots[i] = player.sharedPreferences.getInt(\n+                    player.context.getString(NotificationConstants.SLOT_PREF_KEYS[i]),\n+                    NotificationConstants.SLOT_DEFAULTS[i]);\n+        }\n+    }\n+\n+    @SuppressLint(\"RestrictedApi\")\n+    private void updateActions(final NotificationCompat.Builder builder,\n+                               final VideoPlayerImpl player) {\n+        builder.mActions.clear();\n+        for (int i = 0; i < 5; ++i) {\n+            addAction(builder, player, notificationSlots[i]);\n+        }\n+    }\n+\n+    private void addAction(final NotificationCompat.Builder builder,\n+                           final VideoPlayerImpl player,\n+                           @NotificationConstants.Action final int slot) {\n+        final NotificationCompat.Action action = getAction(player, slot);\n+        if (action != null) {\n+            builder.addAction(action);\n+        }\n+    }\n+\n+    @Nullable\n+    private NotificationCompat.Action getAction(\n+            final VideoPlayerImpl player,\n+            @NotificationConstants.Action final int selectedAction) {\n+        final int baseActionIcon = NotificationConstants.ACTION_ICONS[selectedAction];\n+        switch (selectedAction) {\n+            case NotificationConstants.PREVIOUS:\n+                return getAction(player, baseActionIcon, \"Previous\", ACTION_PLAY_PREVIOUS);\n+\n+            case NotificationConstants.NEXT:\n+                return getAction(player, baseActionIcon, \"Next\", ACTION_PLAY_NEXT);\n+\n+            case NotificationConstants.REWIND:\n+                return getAction(player, baseActionIcon, \"Rewind\", ACTION_FAST_REWIND);\n+\n+            case NotificationConstants.FORWARD:\n+                return getAction(player, baseActionIcon, \"Forward\", ACTION_FAST_FORWARD);\n+\n+            case NotificationConstants.SMART_REWIND_PREVIOUS:\n+                if (player.playQueue != null && player.playQueue.size() > 1) {\n+                    return getAction(player, R.drawable.exo_notification_previous,\n+                            \"Previous\", ACTION_PLAY_PREVIOUS);\n+                } else {\n+                    return getAction(player, R.drawable.exo_controls_rewind,\n+                            \"Rewind\", ACTION_FAST_REWIND);\n+                }\n+\n+            case NotificationConstants.SMART_FORWARD_NEXT:\n+                if (player.playQueue != null && player.playQueue.size() > 1) {\n+                    return getAction(player, R.drawable.exo_notification_next,\n+                            \"Next\", ACTION_PLAY_NEXT);\n+                } else {\n+                    return getAction(player, R.drawable.exo_controls_fastforward,\n+                            \"Forward\", ACTION_FAST_FORWARD);\n+                }\n+\n+            case NotificationConstants.PLAY_PAUSE:\n+                final boolean pauseOrPlay = player.isPlaying()\n+                        || player.getCurrentState() == BasePlayer.STATE_PREFLIGHT\n+                        || player.getCurrentState() == BasePlayer.STATE_BLOCKED\n+                        || player.getCurrentState() == BasePlayer.STATE_BUFFERING;\n+                return getAction(player,\n+                        pauseOrPlay ? R.drawable.exo_notification_pause\n+                                : R.drawable.exo_notification_play,\n+                        pauseOrPlay ? \"Pause\" : \"Play\",\n+                        ACTION_PLAY_PAUSE);\n+\n+            case NotificationConstants.PLAY_PAUSE_BUFFERING:\n+                if (player.getCurrentState() == BasePlayer.STATE_PREFLIGHT\n+                        || player.getCurrentState() == BasePlayer.STATE_BLOCKED\n+                        || player.getCurrentState() == BasePlayer.STATE_BUFFERING) {\n+                    return getAction(player, R.drawable.ic_hourglass_top_white_24dp_png,\n+                            \"Buffering\", ACTION_BUFFERING);\n+                } else {\n+                    return getAction(player,\n+                            player.isPlaying() ? R.drawable.exo_notification_pause\n+                                    : R.drawable.exo_notification_play,\n+                            player.isPlaying() ? \"Pause\" : \"Play\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7317737e90ef096fd72b3d1df1e16d04ff2d1d06"}, "originalPosition": 267}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDE4MDI3OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/schabi/newpipe/player/NotificationUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjozNToxMlrOHVZUng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjozNToxMlrOHVZUng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5NzAyMg==", "bodyText": "See above", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r492197022", "createdAt": "2020-09-21T16:35:12Z", "author": {"login": "TobiGr"}, "path": "app/src/main/java/org/schabi/newpipe/player/NotificationUtil.java", "diffHunk": "@@ -0,0 +1,368 @@\n+package org.schabi.newpipe.player;\n+\n+import android.annotation.SuppressLint;\n+import android.app.PendingIntent;\n+import android.app.Service;\n+import android.content.Intent;\n+import android.content.pm.ServiceInfo;\n+import android.graphics.Bitmap;\n+import android.graphics.Matrix;\n+import android.os.Build;\n+import android.util.Log;\n+\n+import androidx.annotation.DrawableRes;\n+import androidx.annotation.Nullable;\n+import androidx.core.app.NotificationCompat;\n+import androidx.core.app.NotificationManagerCompat;\n+import androidx.core.content.ContextCompat;\n+\n+import org.schabi.newpipe.MainActivity;\n+import org.schabi.newpipe.R;\n+import org.schabi.newpipe.util.NavigationHelper;\n+\n+import java.util.List;\n+\n+import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;\n+import static com.google.android.exoplayer2.Player.REPEAT_MODE_ALL;\n+import static com.google.android.exoplayer2.Player.REPEAT_MODE_ONE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_BUFFERING;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_CLOSE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_FAST_FORWARD;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_FAST_REWIND;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_NEXT;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_PAUSE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_PREVIOUS;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_REPEAT;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_SHUFFLE;\n+\n+/**\n+ * This is a utility class for player notifications.\n+ *\n+ * @author cool-student\n+ */\n+public final class NotificationUtil {\n+    private static final String TAG = NotificationUtil.class.getSimpleName();\n+    private static final boolean DEBUG = BasePlayer.DEBUG;\n+    private static final int NOTIFICATION_ID = 123789;\n+\n+    @Nullable private static NotificationUtil instance = null;\n+\n+    @NotificationConstants.Action\n+    private int[] notificationSlots = NotificationConstants.SLOT_DEFAULTS.clone();\n+\n+    private NotificationManagerCompat notificationManager;\n+    private NotificationCompat.Builder notificationBuilder;\n+\n+    private NotificationUtil() {\n+    }\n+\n+    public static NotificationUtil getInstance() {\n+        if (instance == null) {\n+            instance = new NotificationUtil();\n+        }\n+        return instance;\n+    }\n+\n+\n+    /////////////////////////////////////////////////////\n+    // NOTIFICATION\n+    /////////////////////////////////////////////////////\n+\n+    /**\n+     * Creates the notification if it does not exist already and recreates it if forceRecreate is\n+     * true. Updates the notification with the data in the player.\n+     * @param player the player currently open, to take data from\n+     * @param forceRecreate whether to force the recreation of the notification even if it already\n+     *                      exists\n+     */\n+    synchronized void createNotificationIfNeededAndUpdate(final VideoPlayerImpl player,\n+                                                          final boolean forceRecreate) {\n+        if (forceRecreate || notificationBuilder == null) {\n+            notificationBuilder = createNotification(player);\n+        }\n+        updateNotification(player);\n+        notificationManager.notify(NOTIFICATION_ID, notificationBuilder.build());\n+    }\n+\n+    private synchronized NotificationCompat.Builder createNotification(\n+            final VideoPlayerImpl player) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"createNotification()\");\n+        }\n+        notificationManager = NotificationManagerCompat.from(player.context);\n+        final NotificationCompat.Builder builder = new NotificationCompat.Builder(player.context,\n+                player.context.getString(R.string.notification_channel_id));\n+\n+        initializeNotificationSlots(player);\n+\n+        // count the number of real slots, to make sure compact slots indices are not out of bound\n+        int nonNothingSlotCount = 5;\n+        if (notificationSlots[3] == NotificationConstants.NOTHING) {\n+            --nonNothingSlotCount;\n+        }\n+        if (notificationSlots[4] == NotificationConstants.NOTHING) {\n+            --nonNothingSlotCount;\n+        }\n+\n+        // build the compact slot indices array (need code to convert from Integer... because Java)\n+        final List<Integer> compactSlotList = NotificationConstants.getCompactSlotsFromPreferences(\n+                player.context, player.sharedPreferences, nonNothingSlotCount);\n+        final int[] compactSlots = new int[compactSlotList.size()];\n+        for (int i = 0; i < compactSlotList.size(); i++) {\n+            compactSlots[i] = compactSlotList.get(i);\n+        }\n+\n+        builder.setStyle(new androidx.media.app.NotificationCompat.MediaStyle()\n+                    .setMediaSession(player.mediaSessionManager.getSessionToken())\n+                    .setShowActionsInCompactView(compactSlots))\n+                .setPriority(NotificationCompat.PRIORITY_HIGH)\n+                .setSmallIcon(R.drawable.ic_newpipe_triangle_white)\n+                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n+                .setColor(ContextCompat.getColor(player.context, R.color.gray))\n+                .setCategory(NotificationCompat.CATEGORY_TRANSPORT)\n+                .setDeleteIntent(PendingIntent.getBroadcast(player.context, NOTIFICATION_ID,\n+                        new Intent(ACTION_CLOSE), FLAG_UPDATE_CURRENT));\n+\n+        return builder;\n+    }\n+\n+    /**\n+     * Updates the notification builder and the button icons depending on the playback state.\n+     * @param player the player currently open, to take data from\n+     */\n+    private synchronized void updateNotification(final VideoPlayerImpl player) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"updateNotification()\");\n+        }\n+\n+        // also update content intent, in case the user switched players\n+        notificationBuilder.setContentIntent(PendingIntent.getActivity(player.context,\n+                NOTIFICATION_ID, getIntentForNotification(player), FLAG_UPDATE_CURRENT));\n+        notificationBuilder.setContentTitle(player.getVideoTitle());\n+        notificationBuilder.setContentText(player.getUploaderName());\n+        notificationBuilder.setTicker(player.getVideoTitle());\n+        updateActions(notificationBuilder, player);\n+        setLargeIcon(notificationBuilder, player);\n+    }\n+\n+\n+    boolean hasSlotWithBuffering() {\n+        return notificationSlots[1] == NotificationConstants.PLAY_PAUSE_BUFFERING\n+                || notificationSlots[2] == NotificationConstants.PLAY_PAUSE_BUFFERING;\n+    }\n+\n+\n+    void createNotificationAndStartForeground(final VideoPlayerImpl player, final Service service) {\n+        if (notificationBuilder == null) {\n+            notificationBuilder = createNotification(player);\n+        }\n+        updateNotification(player);\n+\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n+            service.startForeground(NOTIFICATION_ID, notificationBuilder.build(),\n+                    ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK);\n+        } else {\n+            service.startForeground(NOTIFICATION_ID, notificationBuilder.build());\n+        }\n+    }\n+\n+    void cancelNotificationAndStopForeground(final Service service) {\n+        service.stopForeground(true);\n+\n+        if (notificationManager != null) {\n+            notificationManager.cancel(NOTIFICATION_ID);\n+        }\n+        notificationManager = null;\n+        notificationBuilder = null;\n+    }\n+\n+\n+    /////////////////////////////////////////////////////\n+    // ACTIONS\n+    /////////////////////////////////////////////////////\n+\n+    private void initializeNotificationSlots(final VideoPlayerImpl player) {\n+        for (int i = 0; i < 5; ++i) {\n+            notificationSlots[i] = player.sharedPreferences.getInt(\n+                    player.context.getString(NotificationConstants.SLOT_PREF_KEYS[i]),\n+                    NotificationConstants.SLOT_DEFAULTS[i]);\n+        }\n+    }\n+\n+    @SuppressLint(\"RestrictedApi\")\n+    private void updateActions(final NotificationCompat.Builder builder,\n+                               final VideoPlayerImpl player) {\n+        builder.mActions.clear();\n+        for (int i = 0; i < 5; ++i) {\n+            addAction(builder, player, notificationSlots[i]);\n+        }\n+    }\n+\n+    private void addAction(final NotificationCompat.Builder builder,\n+                           final VideoPlayerImpl player,\n+                           @NotificationConstants.Action final int slot) {\n+        final NotificationCompat.Action action = getAction(player, slot);\n+        if (action != null) {\n+            builder.addAction(action);\n+        }\n+    }\n+\n+    @Nullable\n+    private NotificationCompat.Action getAction(\n+            final VideoPlayerImpl player,\n+            @NotificationConstants.Action final int selectedAction) {\n+        final int baseActionIcon = NotificationConstants.ACTION_ICONS[selectedAction];\n+        switch (selectedAction) {\n+            case NotificationConstants.PREVIOUS:\n+                return getAction(player, baseActionIcon, \"Previous\", ACTION_PLAY_PREVIOUS);\n+\n+            case NotificationConstants.NEXT:\n+                return getAction(player, baseActionIcon, \"Next\", ACTION_PLAY_NEXT);\n+\n+            case NotificationConstants.REWIND:\n+                return getAction(player, baseActionIcon, \"Rewind\", ACTION_FAST_REWIND);\n+\n+            case NotificationConstants.FORWARD:\n+                return getAction(player, baseActionIcon, \"Forward\", ACTION_FAST_FORWARD);\n+\n+            case NotificationConstants.SMART_REWIND_PREVIOUS:\n+                if (player.playQueue != null && player.playQueue.size() > 1) {\n+                    return getAction(player, R.drawable.exo_notification_previous,\n+                            \"Previous\", ACTION_PLAY_PREVIOUS);\n+                } else {\n+                    return getAction(player, R.drawable.exo_controls_rewind,\n+                            \"Rewind\", ACTION_FAST_REWIND);\n+                }\n+\n+            case NotificationConstants.SMART_FORWARD_NEXT:\n+                if (player.playQueue != null && player.playQueue.size() > 1) {\n+                    return getAction(player, R.drawable.exo_notification_next,\n+                            \"Next\", ACTION_PLAY_NEXT);\n+                } else {\n+                    return getAction(player, R.drawable.exo_controls_fastforward,\n+                            \"Forward\", ACTION_FAST_FORWARD);\n+                }\n+\n+            case NotificationConstants.PLAY_PAUSE:\n+                final boolean pauseOrPlay = player.isPlaying()\n+                        || player.getCurrentState() == BasePlayer.STATE_PREFLIGHT\n+                        || player.getCurrentState() == BasePlayer.STATE_BLOCKED\n+                        || player.getCurrentState() == BasePlayer.STATE_BUFFERING;\n+                return getAction(player,\n+                        pauseOrPlay ? R.drawable.exo_notification_pause\n+                                : R.drawable.exo_notification_play,\n+                        pauseOrPlay ? \"Pause\" : \"Play\",\n+                        ACTION_PLAY_PAUSE);\n+\n+            case NotificationConstants.PLAY_PAUSE_BUFFERING:\n+                if (player.getCurrentState() == BasePlayer.STATE_PREFLIGHT\n+                        || player.getCurrentState() == BasePlayer.STATE_BLOCKED\n+                        || player.getCurrentState() == BasePlayer.STATE_BUFFERING) {\n+                    return getAction(player, R.drawable.ic_hourglass_top_white_24dp_png,\n+                            \"Buffering\", ACTION_BUFFERING);\n+                } else {\n+                    return getAction(player,\n+                            player.isPlaying() ? R.drawable.exo_notification_pause\n+                                    : R.drawable.exo_notification_play,\n+                            player.isPlaying() ? \"Pause\" : \"Play\",\n+                            ACTION_PLAY_PAUSE);\n+                }\n+\n+            case NotificationConstants.REPEAT:\n+                return getAction(player, getRepeatModeDrawable(player.getRepeatMode()),\n+                        getRepeatModeTitle(player.getRepeatMode()), ACTION_REPEAT);\n+\n+            case NotificationConstants.SHUFFLE:\n+                final boolean shuffled = player.playQueue != null && player.playQueue.isShuffled();\n+                return getAction(player,\n+                        shuffled ? R.drawable.exo_controls_shuffle_on\n+                                : R.drawable.exo_controls_shuffle_off,\n+                        shuffled ? \"ShuffleOn\" : \"ShuffleOff\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7317737e90ef096fd72b3d1df1e16d04ff2d1d06"}, "originalPosition": 280}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3316, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}