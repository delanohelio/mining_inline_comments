{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzODU5ODAz", "number": 1607, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOTowNjo1M1rOEDL0UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxOToxNzoxNFrOEE0OlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzc0ODAxOnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/api/AttributeMapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOTowNjo1M1rOGgFMbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMToyNjozMVrOGkW-1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MjcxOA==", "bodyText": "Wouldn't the exception end up in the log anyway and make the complete error message unnecessary?", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436292718", "createdAt": "2020-06-06T19:06:53Z", "author": {"login": "lkiesow"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/api/AttributeMapper.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai.api;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.expression.Expression;\n+import org.springframework.expression.ExpressionParser;\n+import org.springframework.expression.spel.standard.SpelExpressionParser;\n+import org.springframework.util.Assert;\n+import org.springframework.util.CollectionUtils;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.servlet.http.HttpServletRequest;\n+/**\n+ * Generic AAI Attribute mapper using Spring Expression language mappings.\n+ *\n+ */\n+public class AttributeMapper implements InitializingBean {\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory\n+      .getLogger(AttributeMapper.class);\n+\n+  /** List of all attributes that should be fetched */\n+  private List<String> aaiAttributes;\n+\n+  /**\n+   * Map of List of expressions. Key is a mapping name, value a list of\n+   * expressions\n+   */\n+  private Map<String, List<String>> attributeMap;\n+\n+  /** Use HTTP Header or environment attributes */\n+  private boolean useHeader = true;\n+\n+  /** The delimiter for multivalue attributes */\n+  private String multiValueDelimiter = \";\";\n+\n+  public void afterPropertiesSet() throws Exception {\n+    Assert.notNull(attributeMap, \"attributeMap must be set\");\n+  }\n+\n+  /**\n+   * Apply all expressions on the sourceAttributes\n+   *\n+   * @param sourceAttributes\n+   *    Key is attribute name, value a list of split AAI attribute values\n+   * @param mappingId\n+   *    The mapping list to use\n+   * @return\n+   */\n+  public List<String> getMappedAttributes(\n+      Map<String, List<String>> sourceAttributes, String mappingId) {\n+    Set<String> mappedAttributes = new LinkedHashSet<String>();\n+    ExpressionParser parser = new SpelExpressionParser();\n+\n+    List<String> expressions = attributeMap.get(mappingId);\n+\n+    if (expressions == null) {\n+      logger.error(\"No mapping for \\\"\" + mappingId\n+          + \"\\\" specified. Did you forget to configure a <util:map id=\\\"\"\n+          + mappingId + \"\\\" ...?\");\n+      throw new IllegalArgumentException(\"No mapping for \\\"\" + mappingId\n+          + \"\\\" specified. Did you forget to configure a <util:map id=\\\"\"\n+          + mappingId + \"\\\" ...?\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc3ODQ1NA==", "bodyText": "Fix", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r440778454", "createdAt": "2020-06-16T11:26:31Z", "author": {"login": "jchssystems"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/api/AttributeMapper.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai.api;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.expression.Expression;\n+import org.springframework.expression.ExpressionParser;\n+import org.springframework.expression.spel.standard.SpelExpressionParser;\n+import org.springframework.util.Assert;\n+import org.springframework.util.CollectionUtils;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.servlet.http.HttpServletRequest;\n+/**\n+ * Generic AAI Attribute mapper using Spring Expression language mappings.\n+ *\n+ */\n+public class AttributeMapper implements InitializingBean {\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory\n+      .getLogger(AttributeMapper.class);\n+\n+  /** List of all attributes that should be fetched */\n+  private List<String> aaiAttributes;\n+\n+  /**\n+   * Map of List of expressions. Key is a mapping name, value a list of\n+   * expressions\n+   */\n+  private Map<String, List<String>> attributeMap;\n+\n+  /** Use HTTP Header or environment attributes */\n+  private boolean useHeader = true;\n+\n+  /** The delimiter for multivalue attributes */\n+  private String multiValueDelimiter = \";\";\n+\n+  public void afterPropertiesSet() throws Exception {\n+    Assert.notNull(attributeMap, \"attributeMap must be set\");\n+  }\n+\n+  /**\n+   * Apply all expressions on the sourceAttributes\n+   *\n+   * @param sourceAttributes\n+   *    Key is attribute name, value a list of split AAI attribute values\n+   * @param mappingId\n+   *    The mapping list to use\n+   * @return\n+   */\n+  public List<String> getMappedAttributes(\n+      Map<String, List<String>> sourceAttributes, String mappingId) {\n+    Set<String> mappedAttributes = new LinkedHashSet<String>();\n+    ExpressionParser parser = new SpelExpressionParser();\n+\n+    List<String> expressions = attributeMap.get(mappingId);\n+\n+    if (expressions == null) {\n+      logger.error(\"No mapping for \\\"\" + mappingId\n+          + \"\\\" specified. Did you forget to configure a <util:map id=\\\"\"\n+          + mappingId + \"\\\" ...?\");\n+      throw new IllegalArgumentException(\"No mapping for \\\"\" + mappingId\n+          + \"\\\" specified. Did you forget to configure a <util:map id=\\\"\"\n+          + mappingId + \"\\\" ...?\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MjcxOA=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzc0OTExOnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/api/AttributeMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOTowOToxMFrOGgFM9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOTowOToxMFrOGgFM9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Mjg1Mg==", "bodyText": "This kind of change applies to a number of log messages in this patch:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Mapping \" + exp.getExpressionString() + \" -> \" + res);\n          \n          \n            \n                    logger.debug(\"Mapping {} to {}\", exp.getExpressionString(), res);", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436292852", "createdAt": "2020-06-06T19:09:10Z", "author": {"login": "lkiesow"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/api/AttributeMapper.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai.api;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.expression.Expression;\n+import org.springframework.expression.ExpressionParser;\n+import org.springframework.expression.spel.standard.SpelExpressionParser;\n+import org.springframework.util.Assert;\n+import org.springframework.util.CollectionUtils;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.servlet.http.HttpServletRequest;\n+/**\n+ * Generic AAI Attribute mapper using Spring Expression language mappings.\n+ *\n+ */\n+public class AttributeMapper implements InitializingBean {\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory\n+      .getLogger(AttributeMapper.class);\n+\n+  /** List of all attributes that should be fetched */\n+  private List<String> aaiAttributes;\n+\n+  /**\n+   * Map of List of expressions. Key is a mapping name, value a list of\n+   * expressions\n+   */\n+  private Map<String, List<String>> attributeMap;\n+\n+  /** Use HTTP Header or environment attributes */\n+  private boolean useHeader = true;\n+\n+  /** The delimiter for multivalue attributes */\n+  private String multiValueDelimiter = \";\";\n+\n+  public void afterPropertiesSet() throws Exception {\n+    Assert.notNull(attributeMap, \"attributeMap must be set\");\n+  }\n+\n+  /**\n+   * Apply all expressions on the sourceAttributes\n+   *\n+   * @param sourceAttributes\n+   *    Key is attribute name, value a list of split AAI attribute values\n+   * @param mappingId\n+   *    The mapping list to use\n+   * @return\n+   */\n+  public List<String> getMappedAttributes(\n+      Map<String, List<String>> sourceAttributes, String mappingId) {\n+    Set<String> mappedAttributes = new LinkedHashSet<String>();\n+    ExpressionParser parser = new SpelExpressionParser();\n+\n+    List<String> expressions = attributeMap.get(mappingId);\n+\n+    if (expressions == null) {\n+      logger.error(\"No mapping for \\\"\" + mappingId\n+          + \"\\\" specified. Did you forget to configure a <util:map id=\\\"\"\n+          + mappingId + \"\\\" ...?\");\n+      throw new IllegalArgumentException(\"No mapping for \\\"\" + mappingId\n+          + \"\\\" specified. Did you forget to configure a <util:map id=\\\"\"\n+          + mappingId + \"\\\" ...?\");\n+    }\n+\n+    for (String expression : expressions) {\n+      Expression exp = null;\n+      try {\n+        exp = parser.parseExpression(expression);\n+        String res = (String) exp.getValue(sourceAttributes);\n+        logger.debug(\"Mapping \" + exp.getExpressionString() + \" -> \" + res);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzc1ODUyOnYy", "diffSide": "RIGHT", "path": "modules/userdirectory/src/main/java/org/opencastproject/userdirectory/JpaGroupRoleProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOToyNDoxMFrOGgFRvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOToyNDoxMFrOGgFRvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NDA3Ng==", "bodyText": "Maybe something like:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (prefix != null && !\"\".equals(prefix) && !group.getRole().startsWith(prefix)) {\n          \n          \n            \n                  if (StringUtils.isNotBlank(prefix) && !group.getRole().startsWith(prefix)) {", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436294076", "createdAt": "2020-06-06T19:24:10Z", "author": {"login": "lkiesow"}, "path": "modules/userdirectory/src/main/java/org/opencastproject/userdirectory/JpaGroupRoleProvider.java", "diffHunk": "@@ -275,6 +303,10 @@ public void updateGroupMembershipFromRoles(String userName, String orgId, List<S\n     // List of the user's groups\n     List<JpaGroup> membership = UserDirectoryPersistenceUtil.findGroupsByUser(userName, orgId, emf);\n     for (JpaGroup group : membership) {\n+      if (prefix != null && !\"\".equals(prefix) && !group.getRole().startsWith(prefix)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzc1OTI3OnYy", "diffSide": "RIGHT", "path": "modules/userdirectory/src/main/java/org/opencastproject/userdirectory/JpaGroupRoleProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOToyNTozOFrOGgFSHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOToyNTozOFrOGgFSHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NDE3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"Unable to add user {} to group {} - unauthorized: {}\", userName, group.getRole(),e.getMessage(),e);\n          \n          \n            \n                        e.printStackTrace();\n          \n          \n            \n                        logger.warn(\"Unauthorized to add user {} to group {}\", userName, group.getRole(), e);", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436294175", "createdAt": "2020-06-06T19:25:38Z", "author": {"login": "lkiesow"}, "path": "modules/userdirectory/src/main/java/org/opencastproject/userdirectory/JpaGroupRoleProvider.java", "diffHunk": "@@ -303,7 +335,8 @@ public void updateGroupMembershipFromRoles(String userName, String orgId, List<S\n             logger.warn(\"Cannot add user {} to group {} - no group found with that role\", userName, rolename);\n           }\n         } catch (UnauthorizedException e) {\n-          logger.warn(\"Unable to add user {} to group {} - unauthorized\", userName, group.getRole());\n+            logger.warn(\"Unable to add user {} to group {} - unauthorized: {}\", userName, group.getRole(),e.getMessage(),e);\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzc2MDcwOnYy", "diffSide": "RIGHT", "path": "modules/userdirectory/src/main/java/org/opencastproject/userdirectory/JpaUserReferenceProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOToyODoyN1rOGgFS1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOToyODoyN1rOGgFS1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NDM1OQ==", "bodyText": "Easier to swap this (less nesting):\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (roleProvider == null) {\n          \n          \n            \n                if (roleProvider != null) {\n          \n          \n            \n                  return roleProvider.getRolesForUser(userName);\n          \n          \n            \n                }", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436294359", "createdAt": "2020-06-06T19:28:27Z", "author": {"login": "lkiesow"}, "path": "modules/userdirectory/src/main/java/org/opencastproject/userdirectory/JpaUserReferenceProvider.java", "diffHunk": "@@ -159,11 +177,14 @@ public String toString() {\n    */\n   @Override\n   public List<Role> getRolesForUser(String userName) {\n-    ArrayList<Role> roles = new ArrayList<Role>();\n-    User user = loadUser(userName);\n-    if (user != null)\n-      roles.addAll(user.getRoles());\n-    return roles;\n+    if (roleProvider == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzc2MjYxOnYy", "diffSide": "RIGHT", "path": "modules/userdirectory/src/main/java/org/opencastproject/userdirectory/api/GroupRoleProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOTozMTo0N1rOGgFTvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTozMTozMFrOGiZSoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NDU5MQ==", "bodyText": "Comment to myself: Not entirely sure what the GroupRoleProvider is for. Need to investigate\u2026", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436294591", "createdAt": "2020-06-06T19:31:47Z", "author": {"login": "lkiesow"}, "path": "modules/userdirectory/src/main/java/org/opencastproject/userdirectory/api/GroupRoleProvider.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.opencastproject.userdirectory.api;\n+\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.GroupProvider;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.RoleProvider;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.util.NotFoundException;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+public interface GroupRoleProvider extends GroupProvider, RoleProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxOTEzNw==", "bodyText": "With the interface we avoid cglib proxies.. that can cause weired problems with spring..", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r438719137", "createdAt": "2020-06-11T11:31:30Z", "author": {"login": "hsssystems"}, "path": "modules/userdirectory/src/main/java/org/opencastproject/userdirectory/api/GroupRoleProvider.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.opencastproject.userdirectory.api;\n+\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.GroupProvider;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.RoleProvider;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.util.NotFoundException;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+public interface GroupRoleProvider extends GroupProvider, RoleProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NDU5MQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzc2OTg4OnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/api/AttributeMapper.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOTo0Mzo1NlrOGgFXQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxODozMzo0OFrOGnMbqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NTQ4OQ==", "bodyText": "Just wondering what the expected behavior is when an attribute appears twice?", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436295489", "createdAt": "2020-06-06T19:43:56Z", "author": {"login": "lkiesow"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/api/AttributeMapper.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai.api;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.expression.Expression;\n+import org.springframework.expression.ExpressionParser;\n+import org.springframework.expression.spel.standard.SpelExpressionParser;\n+import org.springframework.util.Assert;\n+import org.springframework.util.CollectionUtils;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.servlet.http.HttpServletRequest;\n+/**\n+ * Generic AAI Attribute mapper using Spring Expression language mappings.\n+ *\n+ */\n+public class AttributeMapper implements InitializingBean {\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory\n+      .getLogger(AttributeMapper.class);\n+\n+  /** List of all attributes that should be fetched */\n+  private List<String> aaiAttributes;\n+\n+  /**\n+   * Map of List of expressions. Key is a mapping name, value a list of\n+   * expressions\n+   */\n+  private Map<String, List<String>> attributeMap;\n+\n+  /** Use HTTP Header or environment attributes */\n+  private boolean useHeader = true;\n+\n+  /** The delimiter for multivalue attributes */\n+  private String multiValueDelimiter = \";\";\n+\n+  public void afterPropertiesSet() throws Exception {\n+    Assert.notNull(attributeMap, \"attributeMap must be set\");\n+  }\n+\n+  /**\n+   * Apply all expressions on the sourceAttributes\n+   *\n+   * @param sourceAttributes\n+   *    Key is attribute name, value a list of split AAI attribute values\n+   * @param mappingId\n+   *    The mapping list to use\n+   * @return\n+   */\n+  public List<String> getMappedAttributes(\n+      Map<String, List<String>> sourceAttributes, String mappingId) {\n+    Set<String> mappedAttributes = new LinkedHashSet<String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxMzg4OA==", "bodyText": "The First one will be taken. We could add a test...", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r438713888", "createdAt": "2020-06-11T11:19:48Z", "author": {"login": "hsssystems"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/api/AttributeMapper.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai.api;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.expression.Expression;\n+import org.springframework.expression.ExpressionParser;\n+import org.springframework.expression.spel.standard.SpelExpressionParser;\n+import org.springframework.util.Assert;\n+import org.springframework.util.CollectionUtils;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.servlet.http.HttpServletRequest;\n+/**\n+ * Generic AAI Attribute mapper using Spring Expression language mappings.\n+ *\n+ */\n+public class AttributeMapper implements InitializingBean {\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory\n+      .getLogger(AttributeMapper.class);\n+\n+  /** List of all attributes that should be fetched */\n+  private List<String> aaiAttributes;\n+\n+  /**\n+   * Map of List of expressions. Key is a mapping name, value a list of\n+   * expressions\n+   */\n+  private Map<String, List<String>> attributeMap;\n+\n+  /** Use HTTP Header or environment attributes */\n+  private boolean useHeader = true;\n+\n+  /** The delimiter for multivalue attributes */\n+  private String multiValueDelimiter = \";\";\n+\n+  public void afterPropertiesSet() throws Exception {\n+    Assert.notNull(attributeMap, \"attributeMap must be set\");\n+  }\n+\n+  /**\n+   * Apply all expressions on the sourceAttributes\n+   *\n+   * @param sourceAttributes\n+   *    Key is attribute name, value a list of split AAI attribute values\n+   * @param mappingId\n+   *    The mapping list to use\n+   * @return\n+   */\n+  public List<String> getMappedAttributes(\n+      Map<String, List<String>> sourceAttributes, String mappingId) {\n+    Set<String> mappedAttributes = new LinkedHashSet<String>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NTQ4OQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc1MTMzOA==", "bodyText": "We have a Test for a duplicate attribute", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r443751338", "createdAt": "2020-06-22T18:33:48Z", "author": {"login": "jchssystems"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/api/AttributeMapper.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai.api;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.expression.Expression;\n+import org.springframework.expression.ExpressionParser;\n+import org.springframework.expression.spel.standard.SpelExpressionParser;\n+import org.springframework.util.Assert;\n+import org.springframework.util.CollectionUtils;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.servlet.http.HttpServletRequest;\n+/**\n+ * Generic AAI Attribute mapper using Spring Expression language mappings.\n+ *\n+ */\n+public class AttributeMapper implements InitializingBean {\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory\n+      .getLogger(AttributeMapper.class);\n+\n+  /** List of all attributes that should be fetched */\n+  private List<String> aaiAttributes;\n+\n+  /**\n+   * Map of List of expressions. Key is a mapping name, value a list of\n+   * expressions\n+   */\n+  private Map<String, List<String>> attributeMap;\n+\n+  /** Use HTTP Header or environment attributes */\n+  private boolean useHeader = true;\n+\n+  /** The delimiter for multivalue attributes */\n+  private String multiValueDelimiter = \";\";\n+\n+  public void afterPropertiesSet() throws Exception {\n+    Assert.notNull(attributeMap, \"attributeMap must be set\");\n+  }\n+\n+  /**\n+   * Apply all expressions on the sourceAttributes\n+   *\n+   * @param sourceAttributes\n+   *    Key is attribute name, value a list of split AAI attribute values\n+   * @param mappingId\n+   *    The mapping list to use\n+   * @return\n+   */\n+  public List<String> getMappedAttributes(\n+      Map<String, List<String>> sourceAttributes, String mappingId) {\n+    Set<String> mappedAttributes = new LinkedHashSet<String>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NTQ4OQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzc3MTA0OnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOTo0NjoyNFrOGgFX2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOTo0NjoyNFrOGgFX2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NTY0MA==", "bodyText": "Should this be deleted?", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436295640", "createdAt": "2020-06-06T19:46:24Z", "author": {"login": "lkiesow"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzc3MjI5OnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOTo0OTozNlrOGgFYhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOTo0OTozNlrOGgFYhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NTgxMg==", "bodyText": "Why register a managed service if you don't handle any configuration?", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436295812", "createdAt": "2020-06-06T19:49:36Z", "author": {"login": "lkiesow"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzc3MzM3OnYy", "diffSide": "RIGHT", "path": "modules/security-aai/pom.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOTo1MToxN1rOGgFZCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxODozNjo0NFrOGnMhAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NTk0Nw==", "bodyText": "Add exceptions if necessary but don't just uncomment this\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  <!--\n          \n          \n            \n                  <plugin>\n          \n          \n            \n                    <groupId>org.apache.maven.plugins</groupId>\n          \n          \n            \n                    <artifactId>maven-dependency-plugin</artifactId>\n          \n          \n            \n                  </plugin>\n          \n          \n            \n                  -->\n          \n          \n            \n                  <plugin>\n          \n          \n            \n                    <groupId>org.apache.maven.plugins</groupId>\n          \n          \n            \n                    <artifactId>maven-dependency-plugin</artifactId>\n          \n          \n            \n                  </plugin>", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436295947", "createdAt": "2020-06-06T19:51:17Z", "author": {"login": "lkiesow"}, "path": "modules/security-aai/pom.xml", "diffHunk": "@@ -59,10 +70,12 @@\n   </dependencies>\n   <build>\n     <plugins>\n+      <!--\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-dependency-plugin</artifactId>\n       </plugin>\n+      -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc1MjcwNg==", "bodyText": "Exceptions were added.", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r443752706", "createdAt": "2020-06-22T18:36:44Z", "author": {"login": "jchssystems"}, "path": "modules/security-aai/pom.xml", "diffHunk": "@@ -59,10 +70,12 @@\n   </dependencies>\n   <build>\n     <plugins>\n+      <!--\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-dependency-plugin</artifactId>\n       </plugin>\n+      -->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NTk0Nw=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzc3NTM2OnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOTo1NTozM1rOGgFaIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOTo1NTozM1rOGgFaIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NjIyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (displayName != null && !\"\".equals(displayName)) {\n          \n          \n            \n                if (StringUtils.isNotBlank(displayName)) {", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436296226", "createdAt": "2020-06-06T19:55:33Z", "author": {"login": "lkiesow"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzc3NzA2OnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxOTo1ODo0N1rOGgFa9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxODoxNDo1MlrOGnL1mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NjQzOQ==", "bodyText": "Is the input guaranteed to be ISO_8859_1?", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436296439", "createdAt": "2020-06-06T19:58:47Z", "author": {"login": "lkiesow"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NjcyMQ==", "bodyText": "And if givenNameValue is blank wouldn't new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),                      StandardCharsets.UTF_8); still be a blank string?", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436296721", "createdAt": "2020-06-06T20:03:35Z", "author": {"login": "lkiesow"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NjQzOQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcwOTI4Mg==", "bodyText": "Wenn givenNameValue is blank, givenName is Blank (\"\"), otherwise not. Same code in ConfigurableLoginHandler and for the other attributes. Should be OK.\nThe whole building of the displayName is only a fallback since it's also possible to configure the building of the displayName in SPeL configuration...", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r438709282", "createdAt": "2020-06-11T11:09:19Z", "author": {"login": "hsssystems"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NjQzOQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc0MTU5NA==", "bodyText": "It seems that ISO_8859_1 is guaranteed:\nhttps://issues.shibboleth.net/jira/projects/SSPCPP/issues/SSPCPP-2?filter=allopenissues\nbut the code here is unnecesary", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r443741594", "createdAt": "2020-06-22T18:14:52Z", "author": {"login": "jchssystems"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NjQzOQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzc3ODMzOnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQyMDowMToxMFrOGgFbkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQyMDowMToxMFrOGgFbkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NjU5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } else {\n          \n          \n            \n                  return null;\n          \n          \n            \n                }\n          \n          \n            \n                }\n          \n          \n            \n                return null;", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436296592", "createdAt": "2020-06-06T20:01:10Z", "author": {"login": "lkiesow"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    List<String> surnames = attributeMapper.getMappedAttributes(request, \"sn\");\n+    String sn = \"\";\n+    if (surnames.size() > 0) {\n+      String surnameValue = surnames.get(0);\n+      sn = StringUtils.isBlank(surnameValue) ? \"\"\n+              : new String(surnameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    return StringUtils.join(new String[] { givenName, sn }, \" \");\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractEmail(HttpServletRequest request) {\n+    List<String> mailAdresses = attributeMapper.getMappedAttributes(request, \"mail\");\n+    if (mailAdresses.size() > 0) {\n+      String mailValue = mailAdresses.get(0);\n+      String mail = StringUtils.isBlank(mailValue) ? \"\"\n+              : new String(mailValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return mail;\n+    } else {\n+      return null;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 255}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzc4MTEyOnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "isResolved": true, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQyMDowNjo0MFrOGgFc9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxODoyMTowMlrOGnMCHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Njk0OQ==", "bodyText": "What's the rule for assigning the global admin role here?", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436296949", "createdAt": "2020-06-06T20:06:40Z", "author": {"login": "lkiesow"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    List<String> surnames = attributeMapper.getMappedAttributes(request, \"sn\");\n+    String sn = \"\";\n+    if (surnames.size() > 0) {\n+      String surnameValue = surnames.get(0);\n+      sn = StringUtils.isBlank(surnameValue) ? \"\"\n+              : new String(surnameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    return StringUtils.join(new String[] { givenName, sn }, \" \");\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractEmail(HttpServletRequest request) {\n+    List<String> mailAdresses = attributeMapper.getMappedAttributes(request, \"mail\");\n+    if (mailAdresses.size() > 0) {\n+      String mailValue = mailAdresses.get(0);\n+      String mail = StringUtils.isBlank(mailValue) ? \"\"\n+              : new String(mailValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return mail;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractDisplayName(HttpServletRequest request) {\n+    List<String> displayNames = attributeMapper.getMappedAttributes(request, \"displayName\");\n+    if (displayNames.size() > 0) {\n+      String displayNameValue = displayNames.get(0);\n+      String displayName = StringUtils.isBlank(displayNameValue) ? \"\"\n+              : new String(displayNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return displayName;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the roles from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the roles\n+   */\n+  private Set<JpaRole> extractRoles(String id, HttpServletRequest request) {\n+    List<String> aaiRoles = attributeMapper.getMappedAttributes(request, \"roles\");\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+    Set<JpaRole> roles = new HashSet<JpaRole>();\n+    if (aaiRoles != null) {\n+      for (String aaiRole : aaiRoles) {\n+        roles.add(new JpaRole(aaiRole, organization));\n+      }\n+    }\n+    roles.add(new JpaRole(organization.getAnonymousRole(), organization));\n+    if (StringUtils.equals(id, bootstrapUserId)) {\n+      roles.add(new JpaRole(GLOBAL_ADMIN_ROLE, organization));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzMzIxMg==", "bodyText": "Hi @lkiesow, long time no see... As I originally wrote this code, I can give some comments here.\nTo answer your question: https://github.com/opencast/opencast/blob/develop/etc/org.opencastproject.security.aai.ConfigurableLoginHandler.cfg#L12\n@jchssystems Assuming that the DynamicLoginHanlder replaces the ConfigurableLoginHandler, the bootstrap user logic is obsolete as you can configure a bootstrap user directly in the security configuration.\nBut the following changes seem missing to me:\n\nDelete ConfigurableLoginHandler.java\nDelete the configuration file of the ConfigurableLoginHandler (https://github.com/opencast/opencast/blob/develop/etc/org.opencastproject.security.aai.ConfigurableLoginHandler.cfg)\n\nAlso, please properly adjust the documentation (https://github.com/opencast/opencast/blob/develop/docs/guides/admin/docs/configuration/security.aai.md).\n\nStep 1 and 2 need to be revised quite a bit\nDon't forget to mention which are the mandatory headers that need to be configured in the \"new way\" in the security configuration to make Opencast work at all and which ones are optional\nPlease explain how bootstrapping works (even if the example in the security configuration makes this obvious to me)\n\n@JulianKniephoff This change should be mentioned in https://docs.opencast.org/develop/admin/#upgrade/#_top (Upgrading 8.x to 9.x) as it is not obvious that adaptors which use Shibboleth need to adapt their configuration quite a bit.", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436933212", "createdAt": "2020-06-08T19:08:33Z", "author": {"login": "staubesv"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    List<String> surnames = attributeMapper.getMappedAttributes(request, \"sn\");\n+    String sn = \"\";\n+    if (surnames.size() > 0) {\n+      String surnameValue = surnames.get(0);\n+      sn = StringUtils.isBlank(surnameValue) ? \"\"\n+              : new String(surnameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    return StringUtils.join(new String[] { givenName, sn }, \" \");\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractEmail(HttpServletRequest request) {\n+    List<String> mailAdresses = attributeMapper.getMappedAttributes(request, \"mail\");\n+    if (mailAdresses.size() > 0) {\n+      String mailValue = mailAdresses.get(0);\n+      String mail = StringUtils.isBlank(mailValue) ? \"\"\n+              : new String(mailValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return mail;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractDisplayName(HttpServletRequest request) {\n+    List<String> displayNames = attributeMapper.getMappedAttributes(request, \"displayName\");\n+    if (displayNames.size() > 0) {\n+      String displayNameValue = displayNames.get(0);\n+      String displayName = StringUtils.isBlank(displayNameValue) ? \"\"\n+              : new String(displayNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return displayName;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the roles from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the roles\n+   */\n+  private Set<JpaRole> extractRoles(String id, HttpServletRequest request) {\n+    List<String> aaiRoles = attributeMapper.getMappedAttributes(request, \"roles\");\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+    Set<JpaRole> roles = new HashSet<JpaRole>();\n+    if (aaiRoles != null) {\n+      for (String aaiRole : aaiRoles) {\n+        roles.add(new JpaRole(aaiRole, organization));\n+      }\n+    }\n+    roles.add(new JpaRole(organization.getAnonymousRole(), organization));\n+    if (StringUtils.equals(id, bootstrapUserId)) {\n+      roles.add(new JpaRole(GLOBAL_ADMIN_ROLE, organization));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Njk0OQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE3NDYzNA==", "bodyText": "@staubesv good to hear from you again, and thanks for the heads up. \ud83d\ude04 Will do when/if this is merged.", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r437174634", "createdAt": "2020-06-09T06:50:19Z", "author": {"login": "JulianKniephoff"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    List<String> surnames = attributeMapper.getMappedAttributes(request, \"sn\");\n+    String sn = \"\";\n+    if (surnames.size() > 0) {\n+      String surnameValue = surnames.get(0);\n+      sn = StringUtils.isBlank(surnameValue) ? \"\"\n+              : new String(surnameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    return StringUtils.join(new String[] { givenName, sn }, \" \");\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractEmail(HttpServletRequest request) {\n+    List<String> mailAdresses = attributeMapper.getMappedAttributes(request, \"mail\");\n+    if (mailAdresses.size() > 0) {\n+      String mailValue = mailAdresses.get(0);\n+      String mail = StringUtils.isBlank(mailValue) ? \"\"\n+              : new String(mailValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return mail;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractDisplayName(HttpServletRequest request) {\n+    List<String> displayNames = attributeMapper.getMappedAttributes(request, \"displayName\");\n+    if (displayNames.size() > 0) {\n+      String displayNameValue = displayNames.get(0);\n+      String displayName = StringUtils.isBlank(displayNameValue) ? \"\"\n+              : new String(displayNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return displayName;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the roles from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the roles\n+   */\n+  private Set<JpaRole> extractRoles(String id, HttpServletRequest request) {\n+    List<String> aaiRoles = attributeMapper.getMappedAttributes(request, \"roles\");\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+    Set<JpaRole> roles = new HashSet<JpaRole>();\n+    if (aaiRoles != null) {\n+      for (String aaiRole : aaiRoles) {\n+        roles.add(new JpaRole(aaiRole, organization));\n+      }\n+    }\n+    roles.add(new JpaRole(organization.getAnonymousRole(), organization));\n+    if (StringUtils.equals(id, bootstrapUserId)) {\n+      roles.add(new JpaRole(GLOBAL_ADMIN_ROLE, organization));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Njk0OQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxMDczNw==", "bodyText": "What's the rule for assigning the global admin role here?\n\nBackward compatibility. However it is also possible to assign this ROLE in the SpEL configuration, so we will remove bootstrapUserId", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r438710737", "createdAt": "2020-06-11T11:12:31Z", "author": {"login": "hsssystems"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    List<String> surnames = attributeMapper.getMappedAttributes(request, \"sn\");\n+    String sn = \"\";\n+    if (surnames.size() > 0) {\n+      String surnameValue = surnames.get(0);\n+      sn = StringUtils.isBlank(surnameValue) ? \"\"\n+              : new String(surnameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    return StringUtils.join(new String[] { givenName, sn }, \" \");\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractEmail(HttpServletRequest request) {\n+    List<String> mailAdresses = attributeMapper.getMappedAttributes(request, \"mail\");\n+    if (mailAdresses.size() > 0) {\n+      String mailValue = mailAdresses.get(0);\n+      String mail = StringUtils.isBlank(mailValue) ? \"\"\n+              : new String(mailValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return mail;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractDisplayName(HttpServletRequest request) {\n+    List<String> displayNames = attributeMapper.getMappedAttributes(request, \"displayName\");\n+    if (displayNames.size() > 0) {\n+      String displayNameValue = displayNames.get(0);\n+      String displayName = StringUtils.isBlank(displayNameValue) ? \"\"\n+              : new String(displayNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return displayName;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the roles from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the roles\n+   */\n+  private Set<JpaRole> extractRoles(String id, HttpServletRequest request) {\n+    List<String> aaiRoles = attributeMapper.getMappedAttributes(request, \"roles\");\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+    Set<JpaRole> roles = new HashSet<JpaRole>();\n+    if (aaiRoles != null) {\n+      for (String aaiRole : aaiRoles) {\n+        roles.add(new JpaRole(aaiRole, organization));\n+      }\n+    }\n+    roles.add(new JpaRole(organization.getAnonymousRole(), organization));\n+    if (StringUtils.equals(id, bootstrapUserId)) {\n+      roles.add(new JpaRole(GLOBAL_ADMIN_ROLE, organization));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Njk0OQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxMTg1Ng==", "bodyText": "Delete ConfigurableLoginHandler.java\n\n\nDelete the configuration file of the ConfigurableLoginHandler (https://github.com/opencast/opencast/blob/develop/etc/org.opencastproject.security.aai.ConfigurableLoginHandler.cfg)\n\n\n\nIt is still possible to use the old ConfigurableLoginHandler. Our intention was a new / additional LoginHandler, not to replace the old one.", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r438711856", "createdAt": "2020-06-11T11:15:13Z", "author": {"login": "hsssystems"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    List<String> surnames = attributeMapper.getMappedAttributes(request, \"sn\");\n+    String sn = \"\";\n+    if (surnames.size() > 0) {\n+      String surnameValue = surnames.get(0);\n+      sn = StringUtils.isBlank(surnameValue) ? \"\"\n+              : new String(surnameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    return StringUtils.join(new String[] { givenName, sn }, \" \");\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractEmail(HttpServletRequest request) {\n+    List<String> mailAdresses = attributeMapper.getMappedAttributes(request, \"mail\");\n+    if (mailAdresses.size() > 0) {\n+      String mailValue = mailAdresses.get(0);\n+      String mail = StringUtils.isBlank(mailValue) ? \"\"\n+              : new String(mailValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return mail;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractDisplayName(HttpServletRequest request) {\n+    List<String> displayNames = attributeMapper.getMappedAttributes(request, \"displayName\");\n+    if (displayNames.size() > 0) {\n+      String displayNameValue = displayNames.get(0);\n+      String displayName = StringUtils.isBlank(displayNameValue) ? \"\"\n+              : new String(displayNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return displayName;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the roles from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the roles\n+   */\n+  private Set<JpaRole> extractRoles(String id, HttpServletRequest request) {\n+    List<String> aaiRoles = attributeMapper.getMappedAttributes(request, \"roles\");\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+    Set<JpaRole> roles = new HashSet<JpaRole>();\n+    if (aaiRoles != null) {\n+      for (String aaiRole : aaiRoles) {\n+        roles.add(new JpaRole(aaiRole, organization));\n+      }\n+    }\n+    roles.add(new JpaRole(organization.getAnonymousRole(), organization));\n+    if (StringUtils.equals(id, bootstrapUserId)) {\n+      roles.add(new JpaRole(GLOBAL_ADMIN_ROLE, organization));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Njk0OQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0ODYwMw==", "bodyText": "@jchssystems As far as I understand, the DynamicLoginHandler offers a superset of the functionality of the ConfigureableLoginHandler. Why should Opencast include both the ConfigurableLoginHandler and the DynamicLoginHandler? That is just more code with no added value...", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r438848603", "createdAt": "2020-06-11T14:57:08Z", "author": {"login": "staubesv"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    List<String> surnames = attributeMapper.getMappedAttributes(request, \"sn\");\n+    String sn = \"\";\n+    if (surnames.size() > 0) {\n+      String surnameValue = surnames.get(0);\n+      sn = StringUtils.isBlank(surnameValue) ? \"\"\n+              : new String(surnameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    return StringUtils.join(new String[] { givenName, sn }, \" \");\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractEmail(HttpServletRequest request) {\n+    List<String> mailAdresses = attributeMapper.getMappedAttributes(request, \"mail\");\n+    if (mailAdresses.size() > 0) {\n+      String mailValue = mailAdresses.get(0);\n+      String mail = StringUtils.isBlank(mailValue) ? \"\"\n+              : new String(mailValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return mail;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractDisplayName(HttpServletRequest request) {\n+    List<String> displayNames = attributeMapper.getMappedAttributes(request, \"displayName\");\n+    if (displayNames.size() > 0) {\n+      String displayNameValue = displayNames.get(0);\n+      String displayName = StringUtils.isBlank(displayNameValue) ? \"\"\n+              : new String(displayNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return displayName;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the roles from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the roles\n+   */\n+  private Set<JpaRole> extractRoles(String id, HttpServletRequest request) {\n+    List<String> aaiRoles = attributeMapper.getMappedAttributes(request, \"roles\");\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+    Set<JpaRole> roles = new HashSet<JpaRole>();\n+    if (aaiRoles != null) {\n+      for (String aaiRole : aaiRoles) {\n+        roles.add(new JpaRole(aaiRole, organization));\n+      }\n+    }\n+    roles.add(new JpaRole(organization.getAnonymousRole(), organization));\n+    if (StringUtils.equals(id, bootstrapUserId)) {\n+      roles.add(new JpaRole(GLOBAL_ADMIN_ROLE, organization));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Njk0OQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg4MDAwMg==", "bodyText": "@staubesv we did not want to break existing configurations for backward compatibility, not every adopter needs this functionality. My proposal: we continue with both handlers, first writing a dedicated documentation for the DynamicLoginHandler, fixing all issues and finally make a new PR to remove the ConfigurableLoginHandler", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r438880002", "createdAt": "2020-06-11T15:37:44Z", "author": {"login": "hsssystems"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    List<String> surnames = attributeMapper.getMappedAttributes(request, \"sn\");\n+    String sn = \"\";\n+    if (surnames.size() > 0) {\n+      String surnameValue = surnames.get(0);\n+      sn = StringUtils.isBlank(surnameValue) ? \"\"\n+              : new String(surnameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    return StringUtils.join(new String[] { givenName, sn }, \" \");\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractEmail(HttpServletRequest request) {\n+    List<String> mailAdresses = attributeMapper.getMappedAttributes(request, \"mail\");\n+    if (mailAdresses.size() > 0) {\n+      String mailValue = mailAdresses.get(0);\n+      String mail = StringUtils.isBlank(mailValue) ? \"\"\n+              : new String(mailValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return mail;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractDisplayName(HttpServletRequest request) {\n+    List<String> displayNames = attributeMapper.getMappedAttributes(request, \"displayName\");\n+    if (displayNames.size() > 0) {\n+      String displayNameValue = displayNames.get(0);\n+      String displayName = StringUtils.isBlank(displayNameValue) ? \"\"\n+              : new String(displayNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return displayName;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the roles from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the roles\n+   */\n+  private Set<JpaRole> extractRoles(String id, HttpServletRequest request) {\n+    List<String> aaiRoles = attributeMapper.getMappedAttributes(request, \"roles\");\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+    Set<JpaRole> roles = new HashSet<JpaRole>();\n+    if (aaiRoles != null) {\n+      for (String aaiRole : aaiRoles) {\n+        roles.add(new JpaRole(aaiRole, organization));\n+      }\n+    }\n+    roles.add(new JpaRole(organization.getAnonymousRole(), organization));\n+    if (StringUtils.equals(id, bootstrapUserId)) {\n+      roles.add(new JpaRole(GLOBAL_ADMIN_ROLE, organization));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Njk0OQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNDMzNw==", "bodyText": "@jchssystems No strong opinion, but you could expect adopters to change the configuration. Note, however, that \"fixing all issues\" should be done before merging ;-)", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r439014337", "createdAt": "2020-06-11T19:18:39Z", "author": {"login": "staubesv"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    List<String> surnames = attributeMapper.getMappedAttributes(request, \"sn\");\n+    String sn = \"\";\n+    if (surnames.size() > 0) {\n+      String surnameValue = surnames.get(0);\n+      sn = StringUtils.isBlank(surnameValue) ? \"\"\n+              : new String(surnameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    return StringUtils.join(new String[] { givenName, sn }, \" \");\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractEmail(HttpServletRequest request) {\n+    List<String> mailAdresses = attributeMapper.getMappedAttributes(request, \"mail\");\n+    if (mailAdresses.size() > 0) {\n+      String mailValue = mailAdresses.get(0);\n+      String mail = StringUtils.isBlank(mailValue) ? \"\"\n+              : new String(mailValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return mail;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractDisplayName(HttpServletRequest request) {\n+    List<String> displayNames = attributeMapper.getMappedAttributes(request, \"displayName\");\n+    if (displayNames.size() > 0) {\n+      String displayNameValue = displayNames.get(0);\n+      String displayName = StringUtils.isBlank(displayNameValue) ? \"\"\n+              : new String(displayNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return displayName;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the roles from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the roles\n+   */\n+  private Set<JpaRole> extractRoles(String id, HttpServletRequest request) {\n+    List<String> aaiRoles = attributeMapper.getMappedAttributes(request, \"roles\");\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+    Set<JpaRole> roles = new HashSet<JpaRole>();\n+    if (aaiRoles != null) {\n+      for (String aaiRole : aaiRoles) {\n+        roles.add(new JpaRole(aaiRole, organization));\n+      }\n+    }\n+    roles.add(new JpaRole(organization.getAnonymousRole(), organization));\n+    if (StringUtils.equals(id, bootstrapUserId)) {\n+      roles.add(new JpaRole(GLOBAL_ADMIN_ROLE, organization));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Njk0OQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzczOTIxNA==", "bodyText": "bootstrapUserId was removed.\nA new independent documentation will be made when all the code be fixed.", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r443739214", "createdAt": "2020-06-22T18:10:07Z", "author": {"login": "jchssystems"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    List<String> surnames = attributeMapper.getMappedAttributes(request, \"sn\");\n+    String sn = \"\";\n+    if (surnames.size() > 0) {\n+      String surnameValue = surnames.get(0);\n+      sn = StringUtils.isBlank(surnameValue) ? \"\"\n+              : new String(surnameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    return StringUtils.join(new String[] { givenName, sn }, \" \");\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractEmail(HttpServletRequest request) {\n+    List<String> mailAdresses = attributeMapper.getMappedAttributes(request, \"mail\");\n+    if (mailAdresses.size() > 0) {\n+      String mailValue = mailAdresses.get(0);\n+      String mail = StringUtils.isBlank(mailValue) ? \"\"\n+              : new String(mailValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return mail;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractDisplayName(HttpServletRequest request) {\n+    List<String> displayNames = attributeMapper.getMappedAttributes(request, \"displayName\");\n+    if (displayNames.size() > 0) {\n+      String displayNameValue = displayNames.get(0);\n+      String displayName = StringUtils.isBlank(displayNameValue) ? \"\"\n+              : new String(displayNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return displayName;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the roles from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the roles\n+   */\n+  private Set<JpaRole> extractRoles(String id, HttpServletRequest request) {\n+    List<String> aaiRoles = attributeMapper.getMappedAttributes(request, \"roles\");\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+    Set<JpaRole> roles = new HashSet<JpaRole>();\n+    if (aaiRoles != null) {\n+      for (String aaiRole : aaiRoles) {\n+        roles.add(new JpaRole(aaiRole, organization));\n+      }\n+    }\n+    roles.add(new JpaRole(organization.getAnonymousRole(), organization));\n+    if (StringUtils.equals(id, bootstrapUserId)) {\n+      roles.add(new JpaRole(GLOBAL_ADMIN_ROLE, organization));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Njk0OQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc0NDc5OQ==", "bodyText": "In my opinion you should not force to use one or another login handler (or a third in the future).", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r443744799", "createdAt": "2020-06-22T18:21:02Z", "author": {"login": "jchssystems"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    List<String> surnames = attributeMapper.getMappedAttributes(request, \"sn\");\n+    String sn = \"\";\n+    if (surnames.size() > 0) {\n+      String surnameValue = surnames.get(0);\n+      sn = StringUtils.isBlank(surnameValue) ? \"\"\n+              : new String(surnameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    return StringUtils.join(new String[] { givenName, sn }, \" \");\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractEmail(HttpServletRequest request) {\n+    List<String> mailAdresses = attributeMapper.getMappedAttributes(request, \"mail\");\n+    if (mailAdresses.size() > 0) {\n+      String mailValue = mailAdresses.get(0);\n+      String mail = StringUtils.isBlank(mailValue) ? \"\"\n+              : new String(mailValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return mail;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractDisplayName(HttpServletRequest request) {\n+    List<String> displayNames = attributeMapper.getMappedAttributes(request, \"displayName\");\n+    if (displayNames.size() > 0) {\n+      String displayNameValue = displayNames.get(0);\n+      String displayName = StringUtils.isBlank(displayNameValue) ? \"\"\n+              : new String(displayNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return displayName;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the roles from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the roles\n+   */\n+  private Set<JpaRole> extractRoles(String id, HttpServletRequest request) {\n+    List<String> aaiRoles = attributeMapper.getMappedAttributes(request, \"roles\");\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+    Set<JpaRole> roles = new HashSet<JpaRole>();\n+    if (aaiRoles != null) {\n+      for (String aaiRole : aaiRoles) {\n+        roles.add(new JpaRole(aaiRole, organization));\n+      }\n+    }\n+    roles.add(new JpaRole(organization.getAnonymousRole(), organization));\n+    if (StringUtils.equals(id, bootstrapUserId)) {\n+      roles.add(new JpaRole(GLOBAL_ADMIN_ROLE, organization));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Njk0OQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 297}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzc4MTM0OnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQyMDowNzoxNVrOGgFdDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQyMDowNzoxNVrOGgFdDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Njk3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } else {\n          \n          \n            \n                  return new JpaOrganization(org.getId(), org.getName(), org.getServers(), org.getAdminRole(),\n          \n          \n            \n                       org.getAnonymousRole(), org.getProperties());\n          \n          \n            \n                }\n          \n          \n            \n                }\n          \n          \n            \n                return new JpaOrganization(org.getId(), org.getName(), org.getServers(), org.getAdminRole(),\n          \n          \n            \n                     org.getAnonymousRole(), org.getProperties());", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436296975", "createdAt": "2020-06-06T20:07:15Z", "author": {"login": "lkiesow"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    List<String> surnames = attributeMapper.getMappedAttributes(request, \"sn\");\n+    String sn = \"\";\n+    if (surnames.size() > 0) {\n+      String surnameValue = surnames.get(0);\n+      sn = StringUtils.isBlank(surnameValue) ? \"\"\n+              : new String(surnameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    return StringUtils.join(new String[] { givenName, sn }, \" \");\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractEmail(HttpServletRequest request) {\n+    List<String> mailAdresses = attributeMapper.getMappedAttributes(request, \"mail\");\n+    if (mailAdresses.size() > 0) {\n+      String mailValue = mailAdresses.get(0);\n+      String mail = StringUtils.isBlank(mailValue) ? \"\"\n+              : new String(mailValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return mail;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractDisplayName(HttpServletRequest request) {\n+    List<String> displayNames = attributeMapper.getMappedAttributes(request, \"displayName\");\n+    if (displayNames.size() > 0) {\n+      String displayNameValue = displayNames.get(0);\n+      String displayName = StringUtils.isBlank(displayNameValue) ? \"\"\n+              : new String(displayNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return displayName;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the roles from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the roles\n+   */\n+  private Set<JpaRole> extractRoles(String id, HttpServletRequest request) {\n+    List<String> aaiRoles = attributeMapper.getMappedAttributes(request, \"roles\");\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+    Set<JpaRole> roles = new HashSet<JpaRole>();\n+    if (aaiRoles != null) {\n+      for (String aaiRole : aaiRoles) {\n+        roles.add(new JpaRole(aaiRole, organization));\n+      }\n+    }\n+    roles.add(new JpaRole(organization.getAnonymousRole(), organization));\n+    if (StringUtils.equals(id, bootstrapUserId)) {\n+      roles.add(new JpaRole(GLOBAL_ADMIN_ROLE, organization));\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Creates a JpaOrganization from an organization\n+   *\n+   * @param org\n+   *          the organization\n+   */\n+  private JpaOrganization fromOrganization(Organization org) {\n+    if (org instanceof JpaOrganization) {\n+      return (JpaOrganization) org;\n+    } else {\n+      return new JpaOrganization(org.getId(), org.getName(), org.getServers(), org.getAdminRole(),\n+           org.getAnonymousRole(), org.getProperties());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 313}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzc4MzI5OnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQyMDoxMToxM1rOGgFeFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxODo0MTo0M1rOGnMqxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NzIzOA==", "bodyText": "There are a lot of to-dos", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436297238", "createdAt": "2020-06-06T20:11:13Z", "author": {"login": "lkiesow"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    List<String> surnames = attributeMapper.getMappedAttributes(request, \"sn\");\n+    String sn = \"\";\n+    if (surnames.size() > 0) {\n+      String surnameValue = surnames.get(0);\n+      sn = StringUtils.isBlank(surnameValue) ? \"\"\n+              : new String(surnameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    return StringUtils.join(new String[] { givenName, sn }, \" \");\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractEmail(HttpServletRequest request) {\n+    List<String> mailAdresses = attributeMapper.getMappedAttributes(request, \"mail\");\n+    if (mailAdresses.size() > 0) {\n+      String mailValue = mailAdresses.get(0);\n+      String mail = StringUtils.isBlank(mailValue) ? \"\"\n+              : new String(mailValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return mail;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractDisplayName(HttpServletRequest request) {\n+    List<String> displayNames = attributeMapper.getMappedAttributes(request, \"displayName\");\n+    if (displayNames.size() > 0) {\n+      String displayNameValue = displayNames.get(0);\n+      String displayName = StringUtils.isBlank(displayNameValue) ? \"\"\n+              : new String(displayNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return displayName;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the roles from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the roles\n+   */\n+  private Set<JpaRole> extractRoles(String id, HttpServletRequest request) {\n+    List<String> aaiRoles = attributeMapper.getMappedAttributes(request, \"roles\");\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+    Set<JpaRole> roles = new HashSet<JpaRole>();\n+    if (aaiRoles != null) {\n+      for (String aaiRole : aaiRoles) {\n+        roles.add(new JpaRole(aaiRole, organization));\n+      }\n+    }\n+    roles.add(new JpaRole(organization.getAnonymousRole(), organization));\n+    if (StringUtils.equals(id, bootstrapUserId)) {\n+      roles.add(new JpaRole(GLOBAL_ADMIN_ROLE, organization));\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Creates a JpaOrganization from an organization\n+   *\n+   * @param org\n+   *          the organization\n+   */\n+  private JpaOrganization fromOrganization(Organization org) {\n+    if (org instanceof JpaOrganization) {\n+      return (JpaOrganization) org;\n+    } else {\n+      return new JpaOrganization(org.getId(), org.getName(), org.getServers(), org.getAdminRole(),\n+           org.getAnonymousRole(), org.getProperties());\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.userdirectory.api.GroupRoleProvider#getRoles()\n+   */\n+  @Override\n+  public Iterator<Role> getRoles() {\n+    JaxbOrganization organization = JaxbOrganization.fromOrganization(securityService.getOrganization());\n+    HashSet<Role> roles = new HashSet<Role>();\n+    roles.add(new JaxbRole(roleFederationMember, organization));\n+    roles.add(new JaxbRole(organization.getAnonymousRole(), organization));\n+    roles.addAll(securityService.getUser().getRoles());\n+    return roles.iterator();\n+  }\n+\n+  /**\n+   * @see org.opencastproject.security.api.RoleProvider#getRolesForUser(String)\n+   */\n+  @Override\n+  public List<Role> getRolesForUser(String userName) {\n+      ArrayList<Role> roles = new ArrayList<Role>();\n+      User user = userReferenceProvider.loadUser(userName);\n+      if (user != null)\n+        roles.addAll(user.getRoles());\n+      return roles;\n+  }\n+\n+  /**\n+   * @see org.opencastproject.security.api.RoleProvider#getOrganization()\n+   */\n+  @Override\n+  public String getOrganization() {\n+    return UserProvider.ALL_ORGANIZATIONS;\n+  }\n+\n+  /**\n+   * @see org.opencastproject.security.api.RoleProvider#findRoles(String, Role.Target, int, int)\n+   */\n+  @Override\n+  public Iterator<Role> findRoles(String query, Role.Target target, int offset, int limit) {\n+    if (query == null)\n+      throw new IllegalArgumentException(\"Query must be set\");\n+    HashSet<Role> foundRoles = new HashSet<Role>();\n+    for (Iterator<Role> it = getRoles(); it.hasNext();) {\n+      Role role = it.next();\n+      if (like(role.getName(), query) || like(role.getDescription(), query))\n+        foundRoles.add(role);\n+    }\n+    return offsetLimitCollection(offset, limit, foundRoles).iterator();\n+  }\n+\n+  private <T> HashSet<T> offsetLimitCollection(int offset, int limit, HashSet<T> entries) {\n+    HashSet<T> result = new HashSet<T>();\n+    int i = 0;\n+    for (T entry : entries) {\n+      if (limit != 0 && result.size() >= limit)\n+        break;\n+      if (i >= offset)\n+        result.add(entry);\n+      i++;\n+    }\n+    return result;\n+  }\n+\n+  private boolean like(String string, final String query) {\n+    String regex = query.replace(\"_\", \".\").replace(\"%\", \".*?\");\n+    Pattern p = Pattern.compile(regex, Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n+    return p.matcher(string).matches();\n+  }\n+\n+  @Override\n+  public void afterPropertiesSet() throws Exception {\n+    this.userReferenceProvider.setRoleProvider(this);\n+  }\n+\n+  public AttributeMapper getAttributeMapper() {\n+    return attributeMapper;\n+  }\n+\n+  public void setAttributeMapper(AttributeMapper attributeMapper) {\n+    this.attributeMapper = attributeMapper;\n+  }\n+\n+  @Override\n+  public List<Role> getRolesForGroup(String groupName) {\n+    // TODO Auto-generated method stub\n+    return null;\n+  }\n+\n+  @Override\n+  public void updateGroupMembershipFromRoles(String userName, String orgId, List<String> roleList) {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  @Override\n+  public void addGroup(JpaGroup group) throws UnauthorizedException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  @Override\n+  public Iterator<Group> getGroups() {\n+    // TODO Auto-generated method stub\n+    return null;\n+  }\n+\n+  @Override\n+  public void createGroup(String name, String description, String roles, String users)\n+         throws IllegalArgumentException, UnauthorizedException, ConflictException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  @Override\n+  public void updateGroup(String groupId, String name, String description, String roles, String users)\n+         throws NotFoundException, UnauthorizedException {\n+    // TODO Auto-generated method stub\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 431}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc1NTIwNw==", "bodyText": "Fix", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r443755207", "createdAt": "2020-06-22T18:41:43Z", "author": {"login": "jchssystems"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    List<String> surnames = attributeMapper.getMappedAttributes(request, \"sn\");\n+    String sn = \"\";\n+    if (surnames.size() > 0) {\n+      String surnameValue = surnames.get(0);\n+      sn = StringUtils.isBlank(surnameValue) ? \"\"\n+              : new String(surnameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    return StringUtils.join(new String[] { givenName, sn }, \" \");\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractEmail(HttpServletRequest request) {\n+    List<String> mailAdresses = attributeMapper.getMappedAttributes(request, \"mail\");\n+    if (mailAdresses.size() > 0) {\n+      String mailValue = mailAdresses.get(0);\n+      String mail = StringUtils.isBlank(mailValue) ? \"\"\n+              : new String(mailValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return mail;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractDisplayName(HttpServletRequest request) {\n+    List<String> displayNames = attributeMapper.getMappedAttributes(request, \"displayName\");\n+    if (displayNames.size() > 0) {\n+      String displayNameValue = displayNames.get(0);\n+      String displayName = StringUtils.isBlank(displayNameValue) ? \"\"\n+              : new String(displayNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return displayName;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the roles from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the roles\n+   */\n+  private Set<JpaRole> extractRoles(String id, HttpServletRequest request) {\n+    List<String> aaiRoles = attributeMapper.getMappedAttributes(request, \"roles\");\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+    Set<JpaRole> roles = new HashSet<JpaRole>();\n+    if (aaiRoles != null) {\n+      for (String aaiRole : aaiRoles) {\n+        roles.add(new JpaRole(aaiRole, organization));\n+      }\n+    }\n+    roles.add(new JpaRole(organization.getAnonymousRole(), organization));\n+    if (StringUtils.equals(id, bootstrapUserId)) {\n+      roles.add(new JpaRole(GLOBAL_ADMIN_ROLE, organization));\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Creates a JpaOrganization from an organization\n+   *\n+   * @param org\n+   *          the organization\n+   */\n+  private JpaOrganization fromOrganization(Organization org) {\n+    if (org instanceof JpaOrganization) {\n+      return (JpaOrganization) org;\n+    } else {\n+      return new JpaOrganization(org.getId(), org.getName(), org.getServers(), org.getAdminRole(),\n+           org.getAnonymousRole(), org.getProperties());\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.userdirectory.api.GroupRoleProvider#getRoles()\n+   */\n+  @Override\n+  public Iterator<Role> getRoles() {\n+    JaxbOrganization organization = JaxbOrganization.fromOrganization(securityService.getOrganization());\n+    HashSet<Role> roles = new HashSet<Role>();\n+    roles.add(new JaxbRole(roleFederationMember, organization));\n+    roles.add(new JaxbRole(organization.getAnonymousRole(), organization));\n+    roles.addAll(securityService.getUser().getRoles());\n+    return roles.iterator();\n+  }\n+\n+  /**\n+   * @see org.opencastproject.security.api.RoleProvider#getRolesForUser(String)\n+   */\n+  @Override\n+  public List<Role> getRolesForUser(String userName) {\n+      ArrayList<Role> roles = new ArrayList<Role>();\n+      User user = userReferenceProvider.loadUser(userName);\n+      if (user != null)\n+        roles.addAll(user.getRoles());\n+      return roles;\n+  }\n+\n+  /**\n+   * @see org.opencastproject.security.api.RoleProvider#getOrganization()\n+   */\n+  @Override\n+  public String getOrganization() {\n+    return UserProvider.ALL_ORGANIZATIONS;\n+  }\n+\n+  /**\n+   * @see org.opencastproject.security.api.RoleProvider#findRoles(String, Role.Target, int, int)\n+   */\n+  @Override\n+  public Iterator<Role> findRoles(String query, Role.Target target, int offset, int limit) {\n+    if (query == null)\n+      throw new IllegalArgumentException(\"Query must be set\");\n+    HashSet<Role> foundRoles = new HashSet<Role>();\n+    for (Iterator<Role> it = getRoles(); it.hasNext();) {\n+      Role role = it.next();\n+      if (like(role.getName(), query) || like(role.getDescription(), query))\n+        foundRoles.add(role);\n+    }\n+    return offsetLimitCollection(offset, limit, foundRoles).iterator();\n+  }\n+\n+  private <T> HashSet<T> offsetLimitCollection(int offset, int limit, HashSet<T> entries) {\n+    HashSet<T> result = new HashSet<T>();\n+    int i = 0;\n+    for (T entry : entries) {\n+      if (limit != 0 && result.size() >= limit)\n+        break;\n+      if (i >= offset)\n+        result.add(entry);\n+      i++;\n+    }\n+    return result;\n+  }\n+\n+  private boolean like(String string, final String query) {\n+    String regex = query.replace(\"_\", \".\").replace(\"%\", \".*?\");\n+    Pattern p = Pattern.compile(regex, Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n+    return p.matcher(string).matches();\n+  }\n+\n+  @Override\n+  public void afterPropertiesSet() throws Exception {\n+    this.userReferenceProvider.setRoleProvider(this);\n+  }\n+\n+  public AttributeMapper getAttributeMapper() {\n+    return attributeMapper;\n+  }\n+\n+  public void setAttributeMapper(AttributeMapper attributeMapper) {\n+    this.attributeMapper = attributeMapper;\n+  }\n+\n+  @Override\n+  public List<Role> getRolesForGroup(String groupName) {\n+    // TODO Auto-generated method stub\n+    return null;\n+  }\n+\n+  @Override\n+  public void updateGroupMembershipFromRoles(String userName, String orgId, List<String> roleList) {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  @Override\n+  public void addGroup(JpaGroup group) throws UnauthorizedException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  @Override\n+  public Iterator<Group> getGroups() {\n+    // TODO Auto-generated method stub\n+    return null;\n+  }\n+\n+  @Override\n+  public void createGroup(String name, String description, String roles, String users)\n+         throws IllegalArgumentException, UnauthorizedException, ConflictException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  @Override\n+  public void updateGroup(String groupId, String name, String description, String roles, String users)\n+         throws NotFoundException, UnauthorizedException {\n+    // TODO Auto-generated method stub\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NzIzOA=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 431}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjAyNjA4OnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOToxNjoyMVrOGgs0ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxODo0MjoyMlrOGnMr8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0MTkzMA==", "bodyText": "Obsolete if removing bootstrap user", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436941930", "createdAt": "2020-06-08T19:16:21Z", "author": {"login": "staubesv"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc1NTUwNg==", "bodyText": "Removed", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r443755506", "createdAt": "2020-06-22T18:42:22Z", "author": {"login": "jchssystems"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0MTkzMA=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjAyODc3OnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOToxNjo0MlrOGgs2JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxODoyMTozMlrOGnMDJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0MjM3Mg==", "bodyText": "Leftover from old code", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436942372", "createdAt": "2020-06-08T19:16:42Z", "author": {"login": "staubesv"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc0NTA2MA==", "bodyText": "CFG_ROLE_FEDERATION_DEFAULT was removed", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r443745060", "createdAt": "2020-06-22T18:21:32Z", "author": {"login": "jchssystems"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0MjM3Mg=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjAzMTM1OnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOToxNzowMVrOGgs3kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxODoyMTo1M1rOGnMD1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0MjczOQ==", "bodyText": "Obsolete when removing boot strap user", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436942739", "createdAt": "2020-06-08T19:17:01Z", "author": {"login": "staubesv"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzczOTQxMw==", "bodyText": "bootstrapUserId was removed.", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r443739413", "createdAt": "2020-06-22T18:10:30Z", "author": {"login": "jchssystems"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0MjczOQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc0NTIzOQ==", "bodyText": "bootstrapUserId was also removed", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r443745239", "createdAt": "2020-06-22T18:21:53Z", "author": {"login": "jchssystems"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0MjczOQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjAzMjU1OnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOToxNzoxMlrOGgs4Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxODoxMTowMVrOGnLuMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0MjkxNQ==", "bodyText": "Leftover from old version", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436942915", "createdAt": "2020-06-08T19:17:12Z", "author": {"login": "staubesv"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzczOTY5Ng==", "bodyText": "CFG_ROLE_FEDERATION_DEFAULT was also removed", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r443739696", "createdAt": "2020-06-22T18:11:01Z", "author": {"login": "jchssystems"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0MjkxNQ=="}, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjAzNjM1OnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOToxNzo0M1rOGgs6lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOToxNzo0M1rOGgs6lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0MzUwOA==", "bodyText": "DynamicLoginHandler", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r436943508", "createdAt": "2020-06-08T19:17:43Z", "author": {"login": "staubesv"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzA1MzY4OnYy", "diffSide": "RIGHT", "path": "modules/userdirectory/src/main/java/org/opencastproject/userdirectory/JpaGroupRoleProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMToyOToyOVrOGiZPSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMToyOToyOVrOGiZPSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxODI4MA==", "bodyText": "Isn't it sufficient to implement only GroupRoleProvider?", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r438718280", "createdAt": "2020-06-11T11:29:29Z", "author": {"login": "hsssystems"}, "path": "modules/userdirectory/src/main/java/org/opencastproject/userdirectory/JpaGroupRoleProvider.java", "diffHunk": "@@ -81,7 +82,7 @@\n   immediate = true,\n   service = { RoleProvider.class, JpaGroupRoleProvider.class }\n )\n-public class JpaGroupRoleProvider extends AbstractIndexProducer implements RoleProvider, GroupProvider {\n+public class JpaGroupRoleProvider extends AbstractIndexProducer implements RoleProvider, GroupProvider, GroupRoleProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDg1NDYwOnYy", "diffSide": "RIGHT", "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxOToxNzoxNFrOGirRPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxOToxNzoxNFrOGirRPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxMzY5NA==", "bodyText": "\u00a0@jchssystems bootstrapUserId is loaded from the configuration file in the original ConfigurableLoginHandler. As you don't it in DynamicLoginHandler, bootstrapUserId will always be null. But since you can configure a bootstrap user in the security configuration, it is safe to just omit those lines here.", "url": "https://github.com/opencast/opencast/pull/1607#discussion_r439013694", "createdAt": "2020-06-11T19:17:14Z", "author": {"login": "staubesv"}, "path": "modules/security-aai/src/main/java/org/opencastproject/security/aai/DynamicLoginHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.security.aai;\n+\n+import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n+\n+import org.opencastproject.security.aai.api.AttributeMapper;\n+import org.opencastproject.security.api.Group;\n+import org.opencastproject.security.api.JaxbOrganization;\n+import org.opencastproject.security.api.JaxbRole;\n+import org.opencastproject.security.api.Organization;\n+import org.opencastproject.security.api.Role;\n+import org.opencastproject.security.api.SecurityService;\n+import org.opencastproject.security.api.UnauthorizedException;\n+import org.opencastproject.security.api.User;\n+import org.opencastproject.security.api.UserProvider;\n+import org.opencastproject.security.impl.jpa.JpaGroup;\n+import org.opencastproject.security.impl.jpa.JpaOrganization;\n+import org.opencastproject.security.impl.jpa.JpaRole;\n+import org.opencastproject.security.impl.jpa.JpaUserReference;\n+import org.opencastproject.security.shibboleth.ShibbolethLoginHandler;\n+import org.opencastproject.userdirectory.ConflictException;\n+import org.opencastproject.userdirectory.api.GroupRoleProvider;\n+import org.opencastproject.userdirectory.api.UserReferenceProvider;\n+import org.opencastproject.util.NotFoundException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * This configurable implementation of the ShibbolethLoginHandler uses the UserReferenceProvider interface to create\n+ * and update Opencast reference users provided and authenticated by an external identity provider.\n+ * Note that this configurable implementation aims at requiring the minimum number of Shibboleth attributes\n+ * to make Opencast work with most Shibboleth-based Authentication and Authorization Infrastractures (AAI).\n+ */\n+//public class DynamicLoginHandler implements ShibbolethLoginHandler, RoleProvider, ManagedService, InitializingBean {\n+public class DynamicLoginHandler implements ShibbolethLoginHandler, GroupRoleProvider, ManagedService, InitializingBean {\n+\n+  /** Default value of the configuration property CFG_ROLE_FEDERATION_KEY */\n+  private static final String CFG_ROLE_FEDERATION_DEFAULT = \"ROLE_AAI_USER\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);\n+\n+  /** The user reference provider */\n+  private UserReferenceProvider userReferenceProvider = null;\n+\n+  /** The security service */\n+  private SecurityService securityService = null;\n+\n+  /** The security service */\n+  private AttributeMapper attributeMapper = null;\n+\n+  /** The ID of the bootstrap user if configured */\n+  private String bootstrapUserId = null;\n+\n+  /** Role assigned to all Shibboleth authenticated users */\n+  private String roleFederationMember = CFG_ROLE_FEDERATION_DEFAULT;\n+\n+  /*\n+   * It is the bundle matterhorn-kernel what will need to instantiate the ConfigurableLoginHandler\n+   * since it is wired using Spring Security.\n+   * Since Shibboleth support is supposed to be an optional extension of the bundle matterhorn-kernel,\n+   * we implement this as fragment bundle.\n+   * The use of the Service Component Runtime (SCR) would require us to declare this bundle as service\n+   * component in matterhorn-kernel which we don't want since it is optional.\n+   * To make us visible to the config admin and take advantage of the ManagedService mechanism, we\n+   * register us as ManagedService in the constructor.\n+   * An alternative solution would be to include the manifest of all fragments in matterhorn-kernel, i.e.\n+   * by specifying OSGI-INF/*.xml as service component in matterhorn-kernel.\n+   */\n+  public DynamicLoginHandler() {\n+    BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  protected DynamicLoginHandler(BundleContext bundleContext) {\n+    registerAsManagedService(bundleContext);\n+  }\n+\n+  private void registerAsManagedService(BundleContext bundleContext) {\n+    Dictionary<String, String> properties = new Hashtable<String, String>();\n+    properties.put(\"service.pid\", this.getClass().getName());\n+    bundleContext.registerService(ManagedService.class.getName(), this, properties);\n+  }\n+\n+  @Override\n+  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n+    // TODO Auto-generated method stub\n+  }\n+\n+  /**\n+   * Handle a new user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void newUserLogin(String id, HttpServletRequest request) {\n+    String name = extractName(request);\n+    String email = extractEmail(request);\n+    Date loginDate = new Date();\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+\n+    // Compile the list of roles\n+    Set<JpaRole> roles = extractRoles(id, request);\n+\n+    // Create the user reference\n+    JpaUserReference userReference = new JpaUserReference(id, name, email, MECH_SHIBBOLETH, loginDate, organization,\n+            roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in for the first time\", id);\n+    userReferenceProvider.addUserReference(userReference, MECH_SHIBBOLETH);\n+  }\n+\n+  /**\n+   * Handle an existing user login.\n+   *\n+   * @param id\n+   *          The identity of the user, ideally the Shibboleth persistent unique identifier\n+   * @param request\n+   *          The request, for accessing any other Shibboleth variables\n+   */\n+  @Override\n+  public void existingUserLogin(String id, HttpServletRequest request) {\n+    Organization organization = securityService.getOrganization();\n+\n+    // Load the user reference\n+    JpaUserReference userReference = userReferenceProvider.findUserReference(id, organization.getId());\n+    if (userReference == null) {\n+      //Triggers creation of user reference\n+      //Possible problem: if there is user (not reference) with that id, we will get conflicts\n+      throw new UsernameNotFoundException(\"User reference '\" + id + \"' was not found\");\n+    }\n+\n+    // Update the reference\n+    userReference.setName(extractName(request));\n+    userReference.setEmail(extractEmail(request));\n+    userReference.setLastLogin(new Date());\n+    Set<JpaRole> roles = extractRoles(id, request);\n+    userReference.setRoles(roles);\n+\n+    logger.debug(\"Shibboleth user '{}' logged in\", id);\n+    userReferenceProvider.updateUserReference(userReference);\n+  }\n+\n+  /**\n+   * Sets the security service.\n+   *\n+   * @param securityService\n+   *          the security service\n+   */\n+  public void setSecurityService(SecurityService securityService) {\n+    this.securityService = securityService;\n+  }\n+\n+  /**\n+   * Sets the user reference provider.\n+   *\n+   * @param userReferenceProvider\n+   *          the user reference provider\n+   */\n+  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {\n+    this.userReferenceProvider = userReferenceProvider;\n+  }\n+\n+  /**\n+   * Extracts the name from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the name\n+   */\n+  private String extractName(HttpServletRequest request) {\n+    String displayName = extractDisplayName(request);\n+    if (displayName != null && !\"\".equals(displayName)) {\n+      return displayName;\n+    }\n+    List<String> givenNames = attributeMapper.getMappedAttributes(request, \"givenName\");\n+    String givenName = \"\";\n+    if (givenNames.size() > 0) {\n+      String givenNameValue = givenNames.get(0);\n+      givenName = StringUtils.isBlank(givenNameValue) ? \"\"\n+              : new String(givenNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    List<String> surnames = attributeMapper.getMappedAttributes(request, \"sn\");\n+    String sn = \"\";\n+    if (surnames.size() > 0) {\n+      String surnameValue = surnames.get(0);\n+      sn = StringUtils.isBlank(surnameValue) ? \"\"\n+              : new String(surnameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+    }\n+    return StringUtils.join(new String[] { givenName, sn }, \" \");\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractEmail(HttpServletRequest request) {\n+    List<String> mailAdresses = attributeMapper.getMappedAttributes(request, \"mail\");\n+    if (mailAdresses.size() > 0) {\n+      String mailValue = mailAdresses.get(0);\n+      String mail = StringUtils.isBlank(mailValue) ? \"\"\n+              : new String(mailValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return mail;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the e-mail from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the e-mail address\n+   */\n+  private String extractDisplayName(HttpServletRequest request) {\n+    List<String> displayNames = attributeMapper.getMappedAttributes(request, \"displayName\");\n+    if (displayNames.size() > 0) {\n+      String displayNameValue = displayNames.get(0);\n+      String displayName = StringUtils.isBlank(displayNameValue) ? \"\"\n+              : new String(displayNameValue.getBytes(StandardCharsets.ISO_8859_1),\n+                      StandardCharsets.UTF_8);\n+      return displayName;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the roles from the request.\n+   *\n+   * @param request\n+   *          the request\n+   * @return the roles\n+   */\n+  private Set<JpaRole> extractRoles(String id, HttpServletRequest request) {\n+    List<String> aaiRoles = attributeMapper.getMappedAttributes(request, \"roles\");\n+    JpaOrganization organization = fromOrganization(securityService.getOrganization());\n+    Set<JpaRole> roles = new HashSet<JpaRole>();\n+    if (aaiRoles != null) {\n+      for (String aaiRole : aaiRoles) {\n+        roles.add(new JpaRole(aaiRole, organization));\n+      }\n+    }\n+    roles.add(new JpaRole(organization.getAnonymousRole(), organization));\n+    if (StringUtils.equals(id, bootstrapUserId)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66e404f99afa38ee81c79ffbb23169d8dff5c69"}, "originalPosition": 295}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3248, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}