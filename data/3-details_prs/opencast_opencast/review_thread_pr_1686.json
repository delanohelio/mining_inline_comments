{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2MDM2NTIz", "number": 1686, "reviewThreads": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTo0NDo1N1rOEOpcKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxODozOTozMVrOFOSJ9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzk0NDcyOnYy", "diffSide": "RIGHT", "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTo0NDo1N1rOGx6Xzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODozODowNFrOGzKiYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk4OTc3NQ==", "bodyText": "Naming this configuration key source-smil-flavor is confusing. Based on this name I would expect a smil file, which is xml. However, you expect a JSON with the cut marks from BBB. Therefore I suggest to name it source-json-flavor and to amend the description with the information that these are the cut marks from BBB.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r454989775", "createdAt": "2020-07-15T11:44:57Z", "author": {"login": "ebbertd"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,66 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the \n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the \n+given presentation and presenter flavors. \n+\n+## Parameter Table\n+\n+|configuration keys         |example                |description                                                    |\n+|------------------         |-----------            |---------------------------------------------------------------|\n+|source-presenter-flavor    |`presenter/prepared`   |The flavor of the presenter video track. Must contain exactly one file.                   |\n+|source-presentation-flavor |`presentation/prepared`|The flavor of the presentation video track. Must contain exactly one file.                  |\n+|source-smil-flavor         |`smil/times`           |The flavor of the JSON. Must contain exactly one file.|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da003feccf9d4004a8060800ad27c066dc131439"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwMzIwMg==", "bodyText": "Yup, that makes sense.\nI would like to keep BBB out of the description, because I wouldn't want people to think that this WHO can only be used with BBB.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r456303202", "createdAt": "2020-07-17T08:38:04Z", "author": {"login": "Arnei"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,66 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the \n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the \n+given presentation and presenter flavors. \n+\n+## Parameter Table\n+\n+|configuration keys         |example                |description                                                    |\n+|------------------         |-----------            |---------------------------------------------------------------|\n+|source-presenter-flavor    |`presenter/prepared`   |The flavor of the presenter video track. Must contain exactly one file.                   |\n+|source-presentation-flavor |`presentation/prepared`|The flavor of the presentation video track. Must contain exactly one file.                  |\n+|source-smil-flavor         |`smil/times`           |The flavor of the JSON. Must contain exactly one file.|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk4OTc3NQ=="}, "originalCommit": {"oid": "da003feccf9d4004a8060800ad27c066dc131439"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzYwNjczOnYy", "diffSide": "RIGHT", "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozMDo0M1rOG2NSEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwNzoxOTo1NlrOG3Wa2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5MzkwNw==", "bodyText": "Can we not hard-code presentation and presenter but just use source-flavors where you can define a list of flavors in the form a/x,b/x or a wildcard like */source? That should be negligently harder to do and makes this far more flexible.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459493907", "createdAt": "2020-07-23T14:30:43Z", "author": {"login": "lkiesow"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,66 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the \n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the \n+given presentation and presenter flavors. \n+\n+## Parameter Table\n+\n+|configuration keys         |example                |description                                                    |\n+|------------------         |-----------            |---------------------------------------------------------------|\n+|source-presenter-flavor    |`presenter/prepared`   |The flavor of the presenter video track. Must contain exactly one file.                   |\n+|source-presentation-flavor |`presentation/prepared`|The flavor of the presentation video track. Must contain exactly one file.                  |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY5MjE4NQ==", "bodyText": "I changed it to support a list of flavors (a/x,b/x). Does not support wildcards, because I could not figure out how to derive a list of flavors from them. Which I would like to do to check for the amount of tracks in each flavor, because the WHO does not know how it should handle multiple tracks per flavor.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r460692185", "createdAt": "2020-07-27T07:19:56Z", "author": {"login": "Arnei"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,66 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the \n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the \n+given presentation and presenter flavors. \n+\n+## Parameter Table\n+\n+|configuration keys         |example                |description                                                    |\n+|------------------         |-----------            |---------------------------------------------------------------|\n+|source-presenter-flavor    |`presenter/prepared`   |The flavor of the presenter video track. Must contain exactly one file.                   |\n+|source-presentation-flavor |`presentation/prepared`|The flavor of the presentation video track. Must contain exactly one file.                  |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5MzkwNw=="}, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzYxNzQwOnYy", "diffSide": "RIGHT", "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozMzowOVrOG2NY8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozMzowOVrOG2NY8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5NTY2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            *begin* marks the start of a segment, *duration* its duration. Times are in milliseconds.\n          \n          \n            \n            The JSON structure specifies all segments which should be kept after cutting.\n          \n          \n            \n            The property `begin` marks the start of a segmen while `duration` its duration.\n          \n          \n            \n            The values are specified in milliseconds.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459495665", "createdAt": "2020-07-23T14:33:09Z", "author": {"login": "lkiesow"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,66 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the \n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the \n+given presentation and presenter flavors. \n+\n+## Parameter Table\n+\n+|configuration keys         |example                |description                                                    |\n+|------------------         |-----------            |---------------------------------------------------------------|\n+|source-presenter-flavor    |`presenter/prepared`   |The flavor of the presenter video track. Must contain exactly one file.                   |\n+|source-presentation-flavor |`presentation/prepared`|The flavor of the presentation video track. Must contain exactly one file.                  |\n+|source-json-flavor         |`smil/times`           |The flavor of the JSON. Must contain exactly one file.|\n+|target-smil-flavor         |`smil/cutmarks`        |The flavor of the resulting SMIL.|\n+\n+## JSON Format\n+*begin* marks the start of a segment, *duration* its duration. Times are in milliseconds.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzYzNTU4OnYy", "diffSide": "RIGHT", "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozNzowM1rOG2Nkbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozNzowM1rOG2Nkbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5ODYwNg==", "bodyText": "Keep the example as simple as possible\nDirectly generate smil/cutting\nUse an XML code block\n\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    <operation\n          \n          \n            \n                        id=\"cut-marks-to-smil\"\n          \n          \n            \n                        description=\"Process ingested cutmarks by applying them to current tracks\"\n          \n          \n            \n                        fail-on-error=\"true\"\n          \n          \n            \n                        exception-handler-workflow=\"partial-error\">\n          \n          \n            \n                      <configurations>\n          \n          \n            \n                        <configuration key=\"source-presenter-flavor\">presenter/prepared</configuration>\n          \n          \n            \n                        <configuration key=\"source-presentation-flavor\">presentation/prepared</configuration>\n          \n          \n            \n                        <configuration key=\"source-json-flavor\">smil/times</configuration>\n          \n          \n            \n                        <configuration key=\"target-smil-flavor\">smil/cutmarks</configuration>\n          \n          \n            \n                      </configurations>\n          \n          \n            \n                    </operation>\n          \n          \n            \n            ```xml\n          \n          \n            \n            <operation\n          \n          \n            \n                id=\"cut-marks-to-smil\"\n          \n          \n            \n                description=\"Process ingested cutmarks by applying them to current tracks\">\n          \n          \n            \n              <configurations>\n          \n          \n            \n                <configuration key=\"source-presenter-flavor\">presenter/prepared</configuration>\n          \n          \n            \n                <configuration key=\"source-presentation-flavor\">presentation/prepared</configuration>\n          \n          \n            \n                <configuration key=\"source-json-flavor\">smil/times</configuration>\n          \n          \n            \n                <configuration key=\"target-smil-flavor\">smil/cutting</configuration>\n          \n          \n            \n              </configurations>\n          \n          \n            \n            </operation>", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459498606", "createdAt": "2020-07-23T14:37:03Z", "author": {"login": "lkiesow"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,66 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the \n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the \n+given presentation and presenter flavors. \n+\n+## Parameter Table\n+\n+|configuration keys         |example                |description                                                    |\n+|------------------         |-----------            |---------------------------------------------------------------|\n+|source-presenter-flavor    |`presenter/prepared`   |The flavor of the presenter video track. Must contain exactly one file.                   |\n+|source-presentation-flavor |`presentation/prepared`|The flavor of the presentation video track. Must contain exactly one file.                  |\n+|source-json-flavor         |`smil/times`           |The flavor of the JSON. Must contain exactly one file.|\n+|target-smil-flavor         |`smil/cutmarks`        |The flavor of the resulting SMIL.|\n+\n+## JSON Format\n+*begin* marks the start of a segment, *duration* its duration. Times are in milliseconds.\n+\n+    [\n+      {\n+        \"begin\": 1672,\n+        \"duration\": 7199\n+      }\n+    ]\n+\n+## Operation Example\n+\n+        <operation\n+            id=\"cut-marks-to-smil\"\n+            description=\"Process ingested cutmarks by applying them to current tracks\"\n+            fail-on-error=\"true\"\n+            exception-handler-workflow=\"partial-error\">\n+          <configurations>\n+            <configuration key=\"source-presenter-flavor\">presenter/prepared</configuration>\n+            <configuration key=\"source-presentation-flavor\">presentation/prepared</configuration>\n+            <configuration key=\"source-json-flavor\">smil/times</configuration>\n+            <configuration key=\"target-smil-flavor\">smil/cutmarks</configuration>\n+          </configurations>\n+        </operation>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzY0MzM0OnYy", "diffSide": "RIGHT", "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozODozN1rOG2NpLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozODozN1rOG2NpLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5OTgyMw==", "bodyText": "Not sure if we need half a workflow here\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                    <operation\n          \n          \n            \n                        id=\"clone\"\n          \n          \n            \n                        exception-handler-workflow=\"partial-error\">\n          \n          \n            \n                      <configurations>\n          \n          \n            \n                        <configuration key=\"source-flavor\">smil/cutmarks</configuration>\n          \n          \n            \n                        <configuration key=\"target-flavor\">smil/cutting</configuration>\n          \n          \n            \n                      </configurations>\n          \n          \n            \n                    </operation>\n          \n          \n            \n            \n          \n          \n            \n                    <operation\n          \n          \n            \n                        id=\"editor\"\n          \n          \n            \n                        fail-on-error=\"true\"\n          \n          \n            \n                        exception-handler-workflow=\"error\"\n          \n          \n            \n                        description=\"Waiting for user to review / video edit recording\">\n          \n          \n            \n                      <configurations>\n          \n          \n            \n                        <configuration key=\"source-flavors\">*/prepared</configuration>\n          \n          \n            \n                        <configuration key=\"skipped-flavors\">*/prepared</configuration>\n          \n          \n            \n                        <configuration key=\"smil-flavors\">smil/cutting</configuration>\n          \n          \n            \n                        <configuration key=\"target-smil-flavor\">smil/cutting</configuration>\n          \n          \n            \n                        <configuration key=\"target-flavor-subtype\">trimmed</configuration>\n          \n          \n            \n                      </configurations>\n          \n          \n            \n                    </operation>", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459499823", "createdAt": "2020-07-23T14:38:37Z", "author": {"login": "lkiesow"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,66 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the \n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the \n+given presentation and presenter flavors. \n+\n+## Parameter Table\n+\n+|configuration keys         |example                |description                                                    |\n+|------------------         |-----------            |---------------------------------------------------------------|\n+|source-presenter-flavor    |`presenter/prepared`   |The flavor of the presenter video track. Must contain exactly one file.                   |\n+|source-presentation-flavor |`presentation/prepared`|The flavor of the presentation video track. Must contain exactly one file.                  |\n+|source-json-flavor         |`smil/times`           |The flavor of the JSON. Must contain exactly one file.|\n+|target-smil-flavor         |`smil/cutmarks`        |The flavor of the resulting SMIL.|\n+\n+## JSON Format\n+*begin* marks the start of a segment, *duration* its duration. Times are in milliseconds.\n+\n+    [\n+      {\n+        \"begin\": 1672,\n+        \"duration\": 7199\n+      }\n+    ]\n+\n+## Operation Example\n+\n+        <operation\n+            id=\"cut-marks-to-smil\"\n+            description=\"Process ingested cutmarks by applying them to current tracks\"\n+            fail-on-error=\"true\"\n+            exception-handler-workflow=\"partial-error\">\n+          <configurations>\n+            <configuration key=\"source-presenter-flavor\">presenter/prepared</configuration>\n+            <configuration key=\"source-presentation-flavor\">presentation/prepared</configuration>\n+            <configuration key=\"source-json-flavor\">smil/times</configuration>\n+            <configuration key=\"target-smil-flavor\">smil/cutmarks</configuration>\n+          </configurations>\n+        </operation>\n+\n+        <operation\n+            id=\"clone\"\n+            exception-handler-workflow=\"partial-error\">\n+          <configurations>\n+            <configuration key=\"source-flavor\">smil/cutmarks</configuration>\n+            <configuration key=\"target-flavor\">smil/cutting</configuration>\n+          </configurations>\n+        </operation>\n+\n+        <operation\n+            id=\"editor\"\n+            fail-on-error=\"true\"\n+            exception-handler-workflow=\"error\"\n+            description=\"Waiting for user to review / video edit recording\">\n+          <configurations>\n+            <configuration key=\"source-flavors\">*/prepared</configuration>\n+            <configuration key=\"skipped-flavors\">*/prepared</configuration>\n+            <configuration key=\"smil-flavors\">smil/cutting</configuration>\n+            <configuration key=\"target-smil-flavor\">smil/cutting</configuration>\n+            <configuration key=\"target-flavor-subtype\">trimmed</configuration>\n+          </configurations>\n+        </operation>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzY1MTg2OnYy", "diffSide": "RIGHT", "path": "etc/workflows/bbb-upload.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo0MDoyNFrOG2NucQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwNzozNDowNVrOG2lxnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwMTE2OQ==", "bodyText": "This probably belongs not in here but in the BBB integration documentation at https://github.com/elan-ev/opencast-bigbluebutton-integration/tree/master/post-archive\nThough with no or a sensible description ;p", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459501169", "createdAt": "2020-07-23T14:40:24Z", "author": {"login": "lkiesow"}, "path": "etc/workflows/bbb-upload.xml", "diffHunk": "@@ -0,0 +1,291 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n+<definition xmlns=\"http://workflow.opencastproject.org\">\n+\n+  <id>bbb-upload</id>\n+  <title>BigBlueButton Upload</title>\n+  <tags>\n+  </tags>\n+  <displayOrder>1000</displayOrder>\n+  <description>\n+    Knock! Knock! Who's there? Candice. Candice who? Candice door open, or am I stuck out here?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg5NTE5Ng==", "bodyText": "Agreed, the workflow was not intended as part of the merge request, but for potential testers to have a workflow at the ready. I'll remove it then and replace it with a link to the repo you mentioned.\n...and add an actual description.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459895196", "createdAt": "2020-07-24T07:34:05Z", "author": {"login": "Arnei"}, "path": "etc/workflows/bbb-upload.xml", "diffHunk": "@@ -0,0 +1,291 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n+<definition xmlns=\"http://workflow.opencastproject.org\">\n+\n+  <id>bbb-upload</id>\n+  <title>BigBlueButton Upload</title>\n+  <tags>\n+  </tags>\n+  <displayOrder>1000</displayOrder>\n+  <description>\n+    Knock! Knock! Who's there? Candice. Candice who? Candice door open, or am I stuck out here?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwMTE2OQ=="}, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzY1ODg1OnYy", "diffSide": "RIGHT", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo0MjowMVrOG2Ny4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo0MjowMVrOG2Ny4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwMjMwNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      logger.warn(\"Unable to delete element {}: {}\", elem, e);\n          \n          \n            \n                      logger.warn(\"Unable to delete element {}\", elem, e);", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459502304", "createdAt": "2020-07-23T14:42:01Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzY3MDE5OnYy", "diffSide": "RIGHT", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo0NDozMVrOG2N58g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwNzo0ODoyOFrOG2mI-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwNDExNA==", "bodyText": "I tend to think we should rather fail here.\nOtherwise, we might accidentally publish uncut material without anyone notiving", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459504114", "createdAt": "2020-07-23T14:44:31Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkwMTE3Nw==", "bodyText": "The choice to skip instead of fail if no (or too many) catalogs are provided was made to be consistent with the behaviour of the VideoEditor WHO, which also does not fail if no cataloge is provided. Therefore I'd rather not fail here, although maybe it would be better to fail if there >1 cataloges.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459901177", "createdAt": "2020-07-24T07:48:28Z", "author": {"login": "Arnei"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwNDExNA=="}, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzY3MzA0OnYy", "diffSide": "RIGHT", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo0NTowOFrOG2N7yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo0NTowOFrOG2N7yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwNDU4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n          \n          \n            \n                  logger.debug(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459504587", "createdAt": "2020-07-23T14:45:08Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzY4NzQyOnYy", "diffSide": "RIGHT", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo0ODowNlrOG2OEvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo0ODowNlrOG2OEvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwNjg3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  logger.info(\"Done Adding tracks\");\n          \n          \n            \n                  logger.info(\"Done adding tracks\");", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459506877", "createdAt": "2020-07-23T14:48:06Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    /** Create the new SMIL document **/\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    List<Track> videosPresenter = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presenterFlavor).toFn()).toList();\n+    List<Track> videosPresentation = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presentationFlavor).toFn()).toList();\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Handle more than exactly one track per flavor\n+    if (videosPresenter.size() != 1 || videosPresentation.size() != 1) {\n+      for (Track track : videosPresenter) {\n+        logger.info(\"VideosPresenter track: {}\", track);\n+      }\n+      for (Track track : videosPresentation) {\n+        logger.info(\"VideosPresentation track: {}\", track);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor must be exactly one.\");\n+    }\n+\n+    Track presenterTrack = videosPresenter.get(0);\n+    Track presentationTrack = videosPresentation.get(0);\n+    logger.info(\"PresenterTrack duration: {}, PresentationTrack duration {}\", presenterTrack.getDuration(),\n+            presentationTrack.getDuration());\n+\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        // add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      Smil smil = smilResponse.getSmil();\n+      logger.info(\"Done Adding tracks\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzY5NTg2OnYy", "diffSide": "RIGHT", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo0OTo1NFrOG2OKCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo0OTo1NFrOG2OKCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwODIzNA==", "bodyText": "Maybe use Java's try-with-resources statement", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459508234", "createdAt": "2020-07-23T14:49:54Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    /** Create the new SMIL document **/\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    List<Track> videosPresenter = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presenterFlavor).toFn()).toList();\n+    List<Track> videosPresentation = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presentationFlavor).toFn()).toList();\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Handle more than exactly one track per flavor\n+    if (videosPresenter.size() != 1 || videosPresentation.size() != 1) {\n+      for (Track track : videosPresenter) {\n+        logger.info(\"VideosPresenter track: {}\", track);\n+      }\n+      for (Track track : videosPresentation) {\n+        logger.info(\"VideosPresentation track: {}\", track);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor must be exactly one.\");\n+    }\n+\n+    Track presenterTrack = videosPresenter.get(0);\n+    Track presentationTrack = videosPresentation.get(0);\n+    logger.info(\"PresenterTrack duration: {}, PresentationTrack duration {}\", presenterTrack.getDuration(),\n+            presentationTrack.getDuration());\n+\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        // add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      Smil smil = smilResponse.getSmil();\n+      logger.info(\"Done Adding tracks\");\n+      InputStream is = null;\n+      try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzcxNTY0OnYy", "diffSide": "RIGHT", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo1Mzo1OFrOG2OV8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo1Mzo1OFrOG2OV8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxMTI4Mg==", "bodyText": "Why re-define skip as continue? That seems wrong.\nI dont' actually see the purpose of this method at all.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459511282", "createdAt": "2020-07-23T14:53:58Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    /** Create the new SMIL document **/\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    List<Track> videosPresenter = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presenterFlavor).toFn()).toList();\n+    List<Track> videosPresentation = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presentationFlavor).toFn()).toList();\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Handle more than exactly one track per flavor\n+    if (videosPresenter.size() != 1 || videosPresentation.size() != 1) {\n+      for (Track track : videosPresenter) {\n+        logger.info(\"VideosPresenter track: {}\", track);\n+      }\n+      for (Track track : videosPresentation) {\n+        logger.info(\"VideosPresentation track: {}\", track);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor must be exactly one.\");\n+    }\n+\n+    Track presenterTrack = videosPresenter.get(0);\n+    Track presentationTrack = videosPresentation.get(0);\n+    logger.info(\"PresenterTrack duration: {}, PresentationTrack duration {}\", presenterTrack.getDuration(),\n+            presentationTrack.getDuration());\n+\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        // add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      Smil smil = smilResponse.getSmil();\n+      logger.info(\"Done Adding tracks\");\n+      InputStream is = null;\n+      try {\n+        // Put new SMIL into workspace and add to mediapackage\n+        is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\");\n+        URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+        MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+        Catalog catalog = (Catalog) mpeBuilder\n+                .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+        catalog.setIdentifier(smil.getId());\n+        mediaPackage.add(catalog);\n+      } finally {\n+        IOUtils.closeQuietly(is);\n+      }\n+    } catch (Exception ex) {\n+      throw new WorkflowOperationException(\n+              format(\"Failed to create SMIL catalog for mediapackage %s\", mediaPackage.getIdentifier().toString()), ex);\n+    }\n+\n+    return skip(mediaPackage);\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.AbstractWorkflowOperationHandler#skip(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  private WorkflowOperationResult skip(MediaPackage mediaPackage) {\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Partial import operation completed\");\n+    return result;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzczNzAyOnYy", "diffSide": "RIGHT", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo1ODoyMVrOG2OjYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo1ODoyMVrOG2OjYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNDcyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } catch (NotFoundException e) {\n          \n          \n            \n                  throw new WorkflowOperationException(\n          \n          \n            \n                          \"Error finding the media file in the workspace\", e);\n          \n          \n            \n                } catch (IOException e) {\n          \n          \n            \n                } catch (NotFoundException | IOException e) {", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459514722", "createdAt": "2020-07-23T14:58:21Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    /** Create the new SMIL document **/\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    List<Track> videosPresenter = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presenterFlavor).toFn()).toList();\n+    List<Track> videosPresentation = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presentationFlavor).toFn()).toList();\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Handle more than exactly one track per flavor\n+    if (videosPresenter.size() != 1 || videosPresentation.size() != 1) {\n+      for (Track track : videosPresenter) {\n+        logger.info(\"VideosPresenter track: {}\", track);\n+      }\n+      for (Track track : videosPresentation) {\n+        logger.info(\"VideosPresentation track: {}\", track);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor must be exactly one.\");\n+    }\n+\n+    Track presenterTrack = videosPresenter.get(0);\n+    Track presentationTrack = videosPresentation.get(0);\n+    logger.info(\"PresenterTrack duration: {}, PresentationTrack duration {}\", presenterTrack.getDuration(),\n+            presentationTrack.getDuration());\n+\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        // add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      Smil smil = smilResponse.getSmil();\n+      logger.info(\"Done Adding tracks\");\n+      InputStream is = null;\n+      try {\n+        // Put new SMIL into workspace and add to mediapackage\n+        is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\");\n+        URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+        MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+        Catalog catalog = (Catalog) mpeBuilder\n+                .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+        catalog.setIdentifier(smil.getId());\n+        mediaPackage.add(catalog);\n+      } finally {\n+        IOUtils.closeQuietly(is);\n+      }\n+    } catch (Exception ex) {\n+      throw new WorkflowOperationException(\n+              format(\"Failed to create SMIL catalog for mediapackage %s\", mediaPackage.getIdentifier().toString()), ex);\n+    }\n+\n+    return skip(mediaPackage);\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.AbstractWorkflowOperationHandler#skip(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  private WorkflowOperationResult skip(MediaPackage mediaPackage) {\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Partial import operation completed\");\n+    return result;\n+  }\n+\n+  /**\n+   * @param flavorType\n+   *          either \"presenter\" or \"presentation\", just for error messages\n+   */\n+  private MediaPackageElementFlavor parseTargetFlavor(String flavor, String flavorType)\n+          throws WorkflowOperationException {\n+    final MediaPackageElementFlavor targetFlavor;\n+    try {\n+      targetFlavor = MediaPackageElementFlavor.parseFlavor(flavor);\n+      if (\"*\".equals(targetFlavor.getType()) || \"*\".equals(targetFlavor.getSubtype())) {\n+        throw new WorkflowOperationException(format(\n+                \"Target %s flavor must have a type and a subtype, '*' are not allowed!\", flavorType));\n+      }\n+    } catch (IllegalArgumentException e) {\n+      throw new WorkflowOperationException(format(\"Target %s flavor '%s' is malformed\", flavorType, flavor));\n+    }\n+    return targetFlavor;\n+  }\n+\n+  private String getMediaPackageElementPath(MediaPackageElement mpe) throws WorkflowOperationException {\n+    File mediaFile;\n+    try {\n+      mediaFile = workspace.get(mpe.getURI());\n+    } catch (NotFoundException e) {\n+      throw new WorkflowOperationException(\n+              \"Error finding the media file in the workspace\", e);\n+    } catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 318}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzczOTIxOnYy", "diffSide": "RIGHT", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo1ODo0OVrOG2OkyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo1ODo0OVrOG2OkyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNTA4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                String filePath = mediaFile.getAbsolutePath();\n          \n          \n            \n                return filePath;\n          \n          \n            \n                return mediaFile.getAbsolutePath();", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459515080", "createdAt": "2020-07-23T14:58:49Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    /** Create the new SMIL document **/\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    List<Track> videosPresenter = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presenterFlavor).toFn()).toList();\n+    List<Track> videosPresentation = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presentationFlavor).toFn()).toList();\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Handle more than exactly one track per flavor\n+    if (videosPresenter.size() != 1 || videosPresentation.size() != 1) {\n+      for (Track track : videosPresenter) {\n+        logger.info(\"VideosPresenter track: {}\", track);\n+      }\n+      for (Track track : videosPresentation) {\n+        logger.info(\"VideosPresentation track: {}\", track);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor must be exactly one.\");\n+    }\n+\n+    Track presenterTrack = videosPresenter.get(0);\n+    Track presentationTrack = videosPresentation.get(0);\n+    logger.info(\"PresenterTrack duration: {}, PresentationTrack duration {}\", presenterTrack.getDuration(),\n+            presentationTrack.getDuration());\n+\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        // add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      Smil smil = smilResponse.getSmil();\n+      logger.info(\"Done Adding tracks\");\n+      InputStream is = null;\n+      try {\n+        // Put new SMIL into workspace and add to mediapackage\n+        is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\");\n+        URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+        MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+        Catalog catalog = (Catalog) mpeBuilder\n+                .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+        catalog.setIdentifier(smil.getId());\n+        mediaPackage.add(catalog);\n+      } finally {\n+        IOUtils.closeQuietly(is);\n+      }\n+    } catch (Exception ex) {\n+      throw new WorkflowOperationException(\n+              format(\"Failed to create SMIL catalog for mediapackage %s\", mediaPackage.getIdentifier().toString()), ex);\n+    }\n+\n+    return skip(mediaPackage);\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.AbstractWorkflowOperationHandler#skip(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  private WorkflowOperationResult skip(MediaPackage mediaPackage) {\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Partial import operation completed\");\n+    return result;\n+  }\n+\n+  /**\n+   * @param flavorType\n+   *          either \"presenter\" or \"presentation\", just for error messages\n+   */\n+  private MediaPackageElementFlavor parseTargetFlavor(String flavor, String flavorType)\n+          throws WorkflowOperationException {\n+    final MediaPackageElementFlavor targetFlavor;\n+    try {\n+      targetFlavor = MediaPackageElementFlavor.parseFlavor(flavor);\n+      if (\"*\".equals(targetFlavor.getType()) || \"*\".equals(targetFlavor.getSubtype())) {\n+        throw new WorkflowOperationException(format(\n+                \"Target %s flavor must have a type and a subtype, '*' are not allowed!\", flavorType));\n+      }\n+    } catch (IllegalArgumentException e) {\n+      throw new WorkflowOperationException(format(\"Target %s flavor '%s' is malformed\", flavorType, flavor));\n+    }\n+    return targetFlavor;\n+  }\n+\n+  private String getMediaPackageElementPath(MediaPackageElement mpe) throws WorkflowOperationException {\n+    File mediaFile;\n+    try {\n+      mediaFile = workspace.get(mpe.getURI());\n+    } catch (NotFoundException e) {\n+      throw new WorkflowOperationException(\n+              \"Error finding the media file in the workspace\", e);\n+    } catch (IOException e) {\n+      throw new WorkflowOperationException(\n+              \"Error reading the media file in the workspace\", e);\n+    }\n+\n+    String filePath = mediaFile.getAbsolutePath();\n+    return filePath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Nzc0OTk5OnYy", "diffSide": "RIGHT", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNTowMTowOFrOG2Orrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMzo1NzoxNVrOG2wXEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNjg0Nw==", "bodyText": "We passed a rule that we won't accept new code using the Entwine Functional Library unless it really can't be avoided. For this pull request, you can easily use other means to archive the same goal.\nPlease avoid it.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459516847", "createdAt": "2020-07-23T15:01:08Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA2ODYyNw==", "bodyText": "Understood, thanks for the heads up.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r460068627", "createdAt": "2020-07-24T13:57:15Z", "author": {"login": "Arnei"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNjg0Nw=="}, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODQ4MjA5OnYy", "diffSide": "RIGHT", "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDozMDowNVrOHQxDyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDozMDowNVrOHQxDyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MzA0OA==", "bodyText": "This is missing from the list of workflow operation handlers", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487343048", "createdAt": "2020-09-12T00:30:05Z", "author": {"login": "lkiesow"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,44 @@\n+CutMarksToSmilWorkflowOperationHandler", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODQ4NDY1OnYy", "diffSide": "RIGHT", "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDozMTo0OVrOHQxFEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDozMTo0OVrOHQxFEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MzM3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                [\n          \n          \n            \n                  {\n          \n          \n            \n                    \"begin\": 1672,\n          \n          \n            \n                    \"duration\": 7199\n          \n          \n            \n                  }\n          \n          \n            \n                ]\n          \n          \n            \n            ```json\n          \n          \n            \n            [\n          \n          \n            \n              {\n          \n          \n            \n                \"begin\": 1672,\n          \n          \n            \n                \"duration\": 7199\n          \n          \n            \n              }\n          \n          \n            \n            ]", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487343377", "createdAt": "2020-09-12T00:31:49Z", "author": {"login": "lkiesow"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,44 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the \n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the \n+given presentation and presenter flavors. \n+\n+## Parameter Table\n+\n+|configuration keys         |example                |description                                                    |\n+|------------------         |-----------            |---------------------------------------------------------------|\n+|source-media-flavors       |`presenter/prepared`   |The flavors containing the video tracks. Each flavor must contain at most one file.                   \n+|source-json-flavor         |`smil/times`           |The flavor of the JSON. Must contain exactly one file.|\n+|target-smil-flavor         |`smil/cutmarks`        |The flavor of the resulting SMIL.|\n+|target-tags                |`archive`              |(Optional) Tags to add to the resulting SMIL. Default is `null`|\n+\n+## JSON Format\n+The JSON structure specifies all segments which should be kept after cutting.\n+The property `begin` marks the start of a segment while `duration` its duration.\n+The values are specified in milliseconds.\n+\n+    [\n+      {\n+        \"begin\": 1672,\n+        \"duration\": 7199\n+      }\n+    ]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODQ5MDA1OnYy", "diffSide": "RIGHT", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDozNzoxMFrOHQxILA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjozODozNlrOHRRvYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDE3Mg==", "bodyText": "Skipping this if there is none may be fine but skipping it if there are multiple catalogs is weird and unexpected. I would expect that they are both converted or that there is an error.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487344172", "createdAt": "2020-09-12T00:37:10Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3ODQ5Nw==", "bodyText": "Right, that makes sense. I'll have it throw an error in that case for now, since processing multiple catalogs seems non-trivial (e.g. what if there are overlapping cutmarks).", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487878497", "createdAt": "2020-09-14T12:38:36Z", "author": {"login": "Arnei"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDE3Mg=="}, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODQ5MTI5OnYy", "diffSide": "RIGHT", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDozODo0N1rOHQxI5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDozODo0N1rOHQxI5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDM1Ng==", "bodyText": "Use the cause argument of exception constructors:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n          \n          \n            \n                  throw new WorkflowOperationException(\"Could not read JSON\", e);", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487344356", "createdAt": "2020-09-12T00:38:47Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODQ5MjgxOnYy", "diffSide": "RIGHT", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0MDoxM1rOHQxJsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0MDoxM1rOHQxJsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDU2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new WorkflowOperationException(\"Times cannot be negative!\");\n          \n          \n            \n                    throw new WorkflowOperationException(\"Times may not be negative.\");", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487344560", "createdAt": "2020-09-12T00:40:13Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODQ5MzU5OnYy", "diffSide": "RIGHT", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0MDo1MFrOHQxKEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0MDo1MFrOHQxKEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDY1OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                logger.info(\"Get Tracks from Mediapackage\");\n          \n          \n            \n                logger.info(\"Get tracks from media package\");", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487344658", "createdAt": "2020-09-12T00:40:50Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get Tracks from Mediapackage\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODQ5NzI1OnYy", "diffSide": "RIGHT", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0NDoxOVrOHQxL5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0NDoxOVrOHQxL5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTEyNw==", "bodyText": "A flavor is no collection. It's an attribute:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Track {} in flavor {}\", track, flavor);\n          \n          \n            \n                    logger.info(\"Track {} with flavor {}\", track, flavor);", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487345127", "createdAt": "2020-09-12T00:44:19Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Track from Flavor {}\", flavor);\n+      Optional<Track> track = getTrackFromFlavor(flavor, mediaPackage);\n+      if (track.isPresent()) {\n+        tracksFromFlavors.add(track.get());\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        logger.debug(\"Segment begin: {}; Segment duration: {}\", mark.begin, mark.duration);\n+        // Add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        tracksFromFlavors.toArray(new Track[tracksFromFlavors.size()]), //new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      smil = smilResponse.getSmil();\n+      logger.info(\"Done adding tracks\");\n+    } catch (SmilException e) {\n+      throw new WorkflowOperationException(\"Failed to create SMIL Catalog\", e);\n+    }\n+\n+    // Put new SMIL into workspace and add it to mediapackage\n+    try (InputStream is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\")) {\n+      URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+      MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+      Catalog catalog = (Catalog) mpeBuilder\n+              .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+      catalog.setIdentifier(smil.getId());\n+      for (String tag : targetTags) {\n+        catalog.addTag(tag);\n+      }\n+      mediaPackage.add(catalog);\n+    } catch (JAXBException | SAXException | IOException e) {\n+      throw new WorkflowOperationException(\"Failed to parse crated SMIL Catalog\", e);\n+    }\n+\n+\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Cut marks to smil operation completed\");\n+    return result;\n+  }\n+\n+  private Optional<Track> getTrackFromFlavor(MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n+          throws WorkflowOperationException {\n+    Optional<Track> result = Optional.empty();\n+\n+    // Get tracks from flavor\n+    TrackSelector trackSelector = new TrackSelector();\n+    trackSelector.addFlavor(flavor);\n+    Collection<Track> tracks = trackSelector.select(mediaPackage, false);\n+\n+    // Get only videos\n+    ArrayList<Track> videos = new ArrayList<Track>();\n+    for (Track video : tracks) {\n+      if (video.hasVideo()) {\n+        videos.add((video));\n+      }\n+    }\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Can we handle more than one track per flavor?\n+    if (videos.isEmpty())\n+      return result;\n+    if (videos.size() > 1) {\n+      for (Track track : videos) {\n+        logger.info(\"Track {} in flavor {}\", track, flavor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 289}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODQ5ODc4OnYy", "diffSide": "RIGHT", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0NToyN1rOHQxMqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMzoyNDo1NVrOHY9i7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTMyMw==", "bodyText": "Is there a reason why there can be only one video with a given flavor in this operation?", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487345323", "createdAt": "2020-09-12T00:45:27Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Track from Flavor {}\", flavor);\n+      Optional<Track> track = getTrackFromFlavor(flavor, mediaPackage);\n+      if (track.isPresent()) {\n+        tracksFromFlavors.add(track.get());\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        logger.debug(\"Segment begin: {}; Segment duration: {}\", mark.begin, mark.duration);\n+        // Add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        tracksFromFlavors.toArray(new Track[tracksFromFlavors.size()]), //new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      smil = smilResponse.getSmil();\n+      logger.info(\"Done adding tracks\");\n+    } catch (SmilException e) {\n+      throw new WorkflowOperationException(\"Failed to create SMIL Catalog\", e);\n+    }\n+\n+    // Put new SMIL into workspace and add it to mediapackage\n+    try (InputStream is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\")) {\n+      URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+      MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+      Catalog catalog = (Catalog) mpeBuilder\n+              .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+      catalog.setIdentifier(smil.getId());\n+      for (String tag : targetTags) {\n+        catalog.addTag(tag);\n+      }\n+      mediaPackage.add(catalog);\n+    } catch (JAXBException | SAXException | IOException e) {\n+      throw new WorkflowOperationException(\"Failed to parse crated SMIL Catalog\", e);\n+    }\n+\n+\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Cut marks to smil operation completed\");\n+    return result;\n+  }\n+\n+  private Optional<Track> getTrackFromFlavor(MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n+          throws WorkflowOperationException {\n+    Optional<Track> result = Optional.empty();\n+\n+    // Get tracks from flavor\n+    TrackSelector trackSelector = new TrackSelector();\n+    trackSelector.addFlavor(flavor);\n+    Collection<Track> tracks = trackSelector.select(mediaPackage, false);\n+\n+    // Get only videos\n+    ArrayList<Track> videos = new ArrayList<Track>();\n+    for (Track video : tracks) {\n+      if (video.hasVideo()) {\n+        videos.add((video));\n+      }\n+    }\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Can we handle more than one track per flavor?\n+    if (videos.isEmpty())\n+      return result;\n+    if (videos.size() > 1) {\n+      for (Track track : videos) {\n+        logger.info(\"Track {} in flavor {}\", track, flavor);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor cannot be more than one.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5NDQ4NA==", "bodyText": "Iirc the reason for that was that the behaviour for multiple tracks in the same flavor is undefined in the editor. So this basically acts as an early error check.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487894484", "createdAt": "2020-09-14T13:03:05Z", "author": {"login": "Arnei"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Track from Flavor {}\", flavor);\n+      Optional<Track> track = getTrackFromFlavor(flavor, mediaPackage);\n+      if (track.isPresent()) {\n+        tracksFromFlavors.add(track.get());\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        logger.debug(\"Segment begin: {}; Segment duration: {}\", mark.begin, mark.duration);\n+        // Add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        tracksFromFlavors.toArray(new Track[tracksFromFlavors.size()]), //new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      smil = smilResponse.getSmil();\n+      logger.info(\"Done adding tracks\");\n+    } catch (SmilException e) {\n+      throw new WorkflowOperationException(\"Failed to create SMIL Catalog\", e);\n+    }\n+\n+    // Put new SMIL into workspace and add it to mediapackage\n+    try (InputStream is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\")) {\n+      URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+      MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+      Catalog catalog = (Catalog) mpeBuilder\n+              .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+      catalog.setIdentifier(smil.getId());\n+      for (String tag : targetTags) {\n+        catalog.addTag(tag);\n+      }\n+      mediaPackage.add(catalog);\n+    } catch (JAXBException | SAXException | IOException e) {\n+      throw new WorkflowOperationException(\"Failed to parse crated SMIL Catalog\", e);\n+    }\n+\n+\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Cut marks to smil operation completed\");\n+    return result;\n+  }\n+\n+  private Optional<Track> getTrackFromFlavor(MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n+          throws WorkflowOperationException {\n+    Optional<Track> result = Optional.empty();\n+\n+    // Get tracks from flavor\n+    TrackSelector trackSelector = new TrackSelector();\n+    trackSelector.addFlavor(flavor);\n+    Collection<Track> tracks = trackSelector.select(mediaPackage, false);\n+\n+    // Get only videos\n+    ArrayList<Track> videos = new ArrayList<Track>();\n+    for (Track video : tracks) {\n+      if (video.hasVideo()) {\n+        videos.add((video));\n+      }\n+    }\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Can we handle more than one track per flavor?\n+    if (videos.isEmpty())\n+      return result;\n+    if (videos.size() > 1) {\n+      for (Track track : videos) {\n+        logger.info(\"Track {} in flavor {}\", track, flavor);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor cannot be more than one.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTMyMw=="}, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE1OTMxNg==", "bodyText": "That sounds like a bug in the editor. For some operations, you actually need multiple tracks with identical flavors. Letting it break here and kind of building more bugs doesn't sound right ;-)", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r488159316", "createdAt": "2020-09-14T19:08:48Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Track from Flavor {}\", flavor);\n+      Optional<Track> track = getTrackFromFlavor(flavor, mediaPackage);\n+      if (track.isPresent()) {\n+        tracksFromFlavors.add(track.get());\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        logger.debug(\"Segment begin: {}; Segment duration: {}\", mark.begin, mark.duration);\n+        // Add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        tracksFromFlavors.toArray(new Track[tracksFromFlavors.size()]), //new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      smil = smilResponse.getSmil();\n+      logger.info(\"Done adding tracks\");\n+    } catch (SmilException e) {\n+      throw new WorkflowOperationException(\"Failed to create SMIL Catalog\", e);\n+    }\n+\n+    // Put new SMIL into workspace and add it to mediapackage\n+    try (InputStream is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\")) {\n+      URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+      MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+      Catalog catalog = (Catalog) mpeBuilder\n+              .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+      catalog.setIdentifier(smil.getId());\n+      for (String tag : targetTags) {\n+        catalog.addTag(tag);\n+      }\n+      mediaPackage.add(catalog);\n+    } catch (JAXBException | SAXException | IOException e) {\n+      throw new WorkflowOperationException(\"Failed to parse crated SMIL Catalog\", e);\n+    }\n+\n+\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Cut marks to smil operation completed\");\n+    return result;\n+  }\n+\n+  private Optional<Track> getTrackFromFlavor(MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n+          throws WorkflowOperationException {\n+    Optional<Track> result = Optional.empty();\n+\n+    // Get tracks from flavor\n+    TrackSelector trackSelector = new TrackSelector();\n+    trackSelector.addFlavor(flavor);\n+    Collection<Track> tracks = trackSelector.select(mediaPackage, false);\n+\n+    // Get only videos\n+    ArrayList<Track> videos = new ArrayList<Track>();\n+    for (Track video : tracks) {\n+      if (video.hasVideo()) {\n+        videos.add((video));\n+      }\n+    }\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Can we handle more than one track per flavor?\n+    if (videos.isEmpty())\n+      return result;\n+    if (videos.size() > 1) {\n+      for (Track track : videos) {\n+        logger.info(\"Track {} in flavor {}\", track, flavor);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor cannot be more than one.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTMyMw=="}, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzNjIzNw==", "bodyText": "That does make sense. I just did some testing on the matter and having multiple videos in one flavor seems to work just fine. Applied your suggest change with commit 6e9702c .", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r495936237", "createdAt": "2020-09-28T13:24:55Z", "author": {"login": "Arnei"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Track from Flavor {}\", flavor);\n+      Optional<Track> track = getTrackFromFlavor(flavor, mediaPackage);\n+      if (track.isPresent()) {\n+        tracksFromFlavors.add(track.get());\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        logger.debug(\"Segment begin: {}; Segment duration: {}\", mark.begin, mark.duration);\n+        // Add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        tracksFromFlavors.toArray(new Track[tracksFromFlavors.size()]), //new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      smil = smilResponse.getSmil();\n+      logger.info(\"Done adding tracks\");\n+    } catch (SmilException e) {\n+      throw new WorkflowOperationException(\"Failed to create SMIL Catalog\", e);\n+    }\n+\n+    // Put new SMIL into workspace and add it to mediapackage\n+    try (InputStream is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\")) {\n+      URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+      MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+      Catalog catalog = (Catalog) mpeBuilder\n+              .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+      catalog.setIdentifier(smil.getId());\n+      for (String tag : targetTags) {\n+        catalog.addTag(tag);\n+      }\n+      mediaPackage.add(catalog);\n+    } catch (JAXBException | SAXException | IOException e) {\n+      throw new WorkflowOperationException(\"Failed to parse crated SMIL Catalog\", e);\n+    }\n+\n+\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Cut marks to smil operation completed\");\n+    return result;\n+  }\n+\n+  private Optional<Track> getTrackFromFlavor(MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n+          throws WorkflowOperationException {\n+    Optional<Track> result = Optional.empty();\n+\n+    // Get tracks from flavor\n+    TrackSelector trackSelector = new TrackSelector();\n+    trackSelector.addFlavor(flavor);\n+    Collection<Track> tracks = trackSelector.select(mediaPackage, false);\n+\n+    // Get only videos\n+    ArrayList<Track> videos = new ArrayList<Track>();\n+    for (Track video : tracks) {\n+      if (video.hasVideo()) {\n+        videos.add((video));\n+      }\n+    }\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Can we handle more than one track per flavor?\n+    if (videos.isEmpty())\n+      return result;\n+    if (videos.size() > 1) {\n+      for (Track track : videos) {\n+        logger.info(\"Track {} in flavor {}\", track, flavor);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor cannot be more than one.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTMyMw=="}, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 291}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODUwMDU2OnYy", "diffSide": "RIGHT", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0NzowNFrOHQxNlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0NzowNFrOHQxNlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTU1OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  logger.info(\"Start Adding tracks\");\n          \n          \n            \n                  logger.info(\"Start adding tracks\");", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487345558", "createdAt": "2020-09-12T00:47:04Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Track from Flavor {}\", flavor);\n+      Optional<Track> track = getTrackFromFlavor(flavor, mediaPackage);\n+      if (track.isPresent()) {\n+        tracksFromFlavors.add(track.get());\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTE5OTgwOnYy", "diffSide": "RIGHT", "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxODozNDo0NVrOIS89Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxODoyMzo0OVrOIYD_qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc0Mzk1MQ==", "bodyText": "I'm wondering if something like cut-marks/json wouldn't be a better default name.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r556743951", "createdAt": "2021-01-13T18:34:45Z", "author": {"login": "lkiesow"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,57 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the\n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the\n+given presentation and presenter flavors.\n+\n+Tracks are assumed to start at 0. Likewise, cut marks are assumed to be specified relative to the beginning\n+of the tracks.\n+\n+\n+Parameter Table\n+---------------\n+\n+|Configuration Keys    |Example              |Description                                                    |\n+|----------------------|---------------------|---------------------------------------------------------------|\n+|source-media-flavors  |`presenter/prepared` |The flavors containing the video tracks.                       |\n+|source-json-flavor    |`smil/times`         |The flavor of the JSON. Must contain exactly one file.         |\n+|target-smil-flavor    |`smil/cutmarks`      |The flavor of the resulting SMIL.                              |\n+|target-tags           |`archive`            |(Optional) Tags to add to the resulting SMIL. Default is `null`|\n+\n+\n+JSON Format\n+-----------\n+\n+The JSON structure specifies all segments which should be kept after cutting.\n+The property `begin` marks the start of a segment while `duration` its duration.\n+The values are specified in milliseconds.\n+\n+```json\n+[\n+  {\n+    \"begin\": 1672,\n+    \"duration\": 7199\n+  }\n+]\n+```\n+\n+Operation Example\n+-----------------\n+\n+```xml\n+<operation\n+    id=\"cut-marks-to-smil\"\n+    description=\"Process ingested cutmarks by applying them to current tracks\"\n+    fail-on-error=\"true\"\n+    exception-handler-workflow=\"partial-error\">\n+  <configurations>\n+    <configuration key=\"source-media-flavors\">presenter/prepared,presentation/prepared</configuration>\n+    <configuration key=\"source-json-flavor\">json/times</configuration>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46fa471a935f853b73ac3311fa7089c8c6429118"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzI3MTY2Nw==", "bodyText": "\"cut-marks\" instead of \"times\" seems more specific and therefore clearer to understand, so +1 for that. As for the order, I put the file type first to be consistent with naming of SMIL catalogue flavors (e.g. smil/source+partial), but I got no hard opinion on this.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r557271667", "createdAt": "2021-01-14T09:54:44Z", "author": {"login": "Arnei"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,57 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the\n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the\n+given presentation and presenter flavors.\n+\n+Tracks are assumed to start at 0. Likewise, cut marks are assumed to be specified relative to the beginning\n+of the tracks.\n+\n+\n+Parameter Table\n+---------------\n+\n+|Configuration Keys    |Example              |Description                                                    |\n+|----------------------|---------------------|---------------------------------------------------------------|\n+|source-media-flavors  |`presenter/prepared` |The flavors containing the video tracks.                       |\n+|source-json-flavor    |`smil/times`         |The flavor of the JSON. Must contain exactly one file.         |\n+|target-smil-flavor    |`smil/cutmarks`      |The flavor of the resulting SMIL.                              |\n+|target-tags           |`archive`            |(Optional) Tags to add to the resulting SMIL. Default is `null`|\n+\n+\n+JSON Format\n+-----------\n+\n+The JSON structure specifies all segments which should be kept after cutting.\n+The property `begin` marks the start of a segment while `duration` its duration.\n+The values are specified in milliseconds.\n+\n+```json\n+[\n+  {\n+    \"begin\": 1672,\n+    \"duration\": 7199\n+  }\n+]\n+```\n+\n+Operation Example\n+-----------------\n+\n+```xml\n+<operation\n+    id=\"cut-marks-to-smil\"\n+    description=\"Process ingested cutmarks by applying them to current tracks\"\n+    fail-on-error=\"true\"\n+    exception-handler-workflow=\"partial-error\">\n+  <configurations>\n+    <configuration key=\"source-media-flavors\">presenter/prepared,presentation/prepared</configuration>\n+    <configuration key=\"source-json-flavor\">json/times</configuration>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc0Mzk1MQ=="}, "originalCommit": {"oid": "46fa471a935f853b73ac3311fa7089c8c6429118"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEwMjE4Nw==", "bodyText": "I decided to try cut-marks/json. The smil/* is a good argument, but I don't think that smil is really meant as a file type here since it's something specific and not a general purpose file type like JSON. That would make the main type otherwise very unspecific and a wildcard like json/* could catch all kinds of things.\nAt the same time, we also have other favors with file format as sub-type:\n\nsecurity/xacml(+\u2026)\ncaptions/google-speech-json\ncaptions/ibm-watson-json\n\nIn the end, it's just the documentation, and you can pick whatever you want anyway. Take a look, and we can still change it if you want to. I'm not that fixed on this. I will push the update shortly.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r562102187", "createdAt": "2021-01-21T18:23:49Z", "author": {"login": "lkiesow"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,57 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the\n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the\n+given presentation and presenter flavors.\n+\n+Tracks are assumed to start at 0. Likewise, cut marks are assumed to be specified relative to the beginning\n+of the tracks.\n+\n+\n+Parameter Table\n+---------------\n+\n+|Configuration Keys    |Example              |Description                                                    |\n+|----------------------|---------------------|---------------------------------------------------------------|\n+|source-media-flavors  |`presenter/prepared` |The flavors containing the video tracks.                       |\n+|source-json-flavor    |`smil/times`         |The flavor of the JSON. Must contain exactly one file.         |\n+|target-smil-flavor    |`smil/cutmarks`      |The flavor of the resulting SMIL.                              |\n+|target-tags           |`archive`            |(Optional) Tags to add to the resulting SMIL. Default is `null`|\n+\n+\n+JSON Format\n+-----------\n+\n+The JSON structure specifies all segments which should be kept after cutting.\n+The property `begin` marks the start of a segment while `duration` its duration.\n+The values are specified in milliseconds.\n+\n+```json\n+[\n+  {\n+    \"begin\": 1672,\n+    \"duration\": 7199\n+  }\n+]\n+```\n+\n+Operation Example\n+-----------------\n+\n+```xml\n+<operation\n+    id=\"cut-marks-to-smil\"\n+    description=\"Process ingested cutmarks by applying them to current tracks\"\n+    fail-on-error=\"true\"\n+    exception-handler-workflow=\"partial-error\">\n+  <configurations>\n+    <configuration key=\"source-media-flavors\">presenter/prepared,presentation/prepared</configuration>\n+    <configuration key=\"source-json-flavor\">json/times</configuration>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc0Mzk1MQ=="}, "originalCommit": {"oid": "46fa471a935f853b73ac3311fa7089c8c6429118"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTIwOTk2OnYy", "diffSide": "RIGHT", "path": "modules/smil-workflowoperation/src/main/java/org/opencastproject/workflow/handler/smil/CutMarksToSmilWorkflowOperationHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxODozNzoxN1rOIS9DHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxODowNDo1OFrOIYDPcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc0NTUwMQ==", "bodyText": "I'm wondering if there is a specific reason to require video streams to be present. This would mean that we cannot cut audio and also that we need to make sure that we run inspect on the media package before we run this operation.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r556745501", "createdAt": "2021-01-13T18:37:17Z", "author": {"login": "lkiesow"}, "path": "modules/smil-workflowoperation/src/main/java/org/opencastproject/workflow/handler/smil/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.smil;\n+\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Type;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(CutMarksToSmilWorkflowOperationHandler.class);\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+  private static final Type timesListType = new TypeToken<List<Times>>() { }.getType();\n+\n+  /** Stores information read from JSON */\n+  static class Times {\n+    private Long begin;\n+    private Long duration;\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length < 1) {\n+      logger.warn(\"No catalogs in the source flavor. Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    } else if (catalogs.length > 1) {\n+      throw new WorkflowOperationException(\"More than one catalog in the source flavor! Make sure there is only catalog.\");\n+    }\n+\n+    // Parse JSON\n+    List<Times> cutMarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutMarks = gson.fromJson(bufferedReader, timesListType);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON\", e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutMarks.size() < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutMarks) {\n+      logger.debug(\"Entry begin={}, duration={}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times may not be negative.\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get tracks from media package\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Tracks from Flavor {}\", flavor);\n+      List<Track> tracks = getTracksFromFlavor(flavor, mediaPackage);\n+      logger.debug(\"Found {} tracks in flavor {}\", tracks.size(), flavor);\n+      if (tracks.size() > 0) {\n+        tracksFromFlavors.addAll(tracks);\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Check for cut marks that would lead to errors with the given tracks and remove them\n+    // Possible TODO: Instead of removing, only apply cut marks to tracks with a long enough duration?\n+    // Get the shortest duration of all tracks\n+    long shortestDuration = Long.MAX_VALUE;\n+    for (Track track : tracksFromFlavors) {\n+      if (track.getDuration() < shortestDuration) {\n+        shortestDuration = track.getDuration();\n+      }\n+    }\n+    // Remove all timestamps that begin after the shortest duration\n+    ListIterator<Times> iter = cutMarks.listIterator();\n+    while (iter.hasNext()) {\n+      long begin = iter.next().begin;\n+      if (begin > shortestDuration) {\n+        logger.info(\"Skipped mark with begin: {}, \", begin);\n+        iter.remove();\n+      }\n+    }\n+    // If the timestamp list is now empty, give up\n+    if (cutMarks.size() < 1) {\n+      logger.warn(\"No timestamps are valid for the given tracks! Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start adding tracks\");\n+      for (Times mark : cutMarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        logger.debug(\"Segment begin: {}; Segment duration: {}\", mark.begin, mark.duration);\n+        // Add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        tracksFromFlavors.toArray(new Track[0]),\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      smil = smilResponse.getSmil();\n+      logger.info(\"Done adding tracks\");\n+    } catch (SmilException e) {\n+      throw new WorkflowOperationException(\"Failed to create SMIL Catalog\", e);\n+    }\n+\n+    // Put new SMIL into workspace and add it to media package\n+    try (InputStream is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\")) {\n+      URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+      MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+      Catalog catalog = (Catalog) mpeBuilder\n+              .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+      catalog.setIdentifier(smil.getId());\n+      for (String tag : targetTags) {\n+        catalog.addTag(tag);\n+      }\n+      mediaPackage.add(catalog);\n+    } catch (JAXBException | SAXException | IOException e) {\n+      throw new WorkflowOperationException(\"Failed to parse crated SMIL Catalog\", e);\n+    }\n+\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Cut marks to smil operation completed\");\n+    return result;\n+  }\n+\n+  private List<Track> getTracksFromFlavor(MediaPackageElementFlavor flavor, MediaPackage mediaPackage) {\n+    // Get tracks from flavor\n+    TrackSelector trackSelector = new TrackSelector();\n+    trackSelector.addFlavor(flavor);\n+    Collection<Track> tracks = trackSelector.select(mediaPackage, false);\n+\n+    // Get only videos\n+    ArrayList<Track> videos = new ArrayList<>();\n+    for (Track video : tracks) {\n+      if (video.hasVideo()) {\n+        videos.add((video));\n+      } else {\n+        logger.debug(\"Skipping track {} since it does not seem to have a vide track.\", video);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46fa471a935f853b73ac3311fa7089c8c6429118"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzI3NTE0Mg==", "bodyText": "I honestly do not remember why only video tracks were allowed (should've commented on that, arg). I'll try and see if I can't figure it out.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r557275142", "createdAt": "2021-01-14T09:59:44Z", "author": {"login": "Arnei"}, "path": "modules/smil-workflowoperation/src/main/java/org/opencastproject/workflow/handler/smil/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.smil;\n+\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Type;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(CutMarksToSmilWorkflowOperationHandler.class);\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+  private static final Type timesListType = new TypeToken<List<Times>>() { }.getType();\n+\n+  /** Stores information read from JSON */\n+  static class Times {\n+    private Long begin;\n+    private Long duration;\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length < 1) {\n+      logger.warn(\"No catalogs in the source flavor. Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    } else if (catalogs.length > 1) {\n+      throw new WorkflowOperationException(\"More than one catalog in the source flavor! Make sure there is only catalog.\");\n+    }\n+\n+    // Parse JSON\n+    List<Times> cutMarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutMarks = gson.fromJson(bufferedReader, timesListType);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON\", e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutMarks.size() < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutMarks) {\n+      logger.debug(\"Entry begin={}, duration={}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times may not be negative.\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get tracks from media package\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Tracks from Flavor {}\", flavor);\n+      List<Track> tracks = getTracksFromFlavor(flavor, mediaPackage);\n+      logger.debug(\"Found {} tracks in flavor {}\", tracks.size(), flavor);\n+      if (tracks.size() > 0) {\n+        tracksFromFlavors.addAll(tracks);\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Check for cut marks that would lead to errors with the given tracks and remove them\n+    // Possible TODO: Instead of removing, only apply cut marks to tracks with a long enough duration?\n+    // Get the shortest duration of all tracks\n+    long shortestDuration = Long.MAX_VALUE;\n+    for (Track track : tracksFromFlavors) {\n+      if (track.getDuration() < shortestDuration) {\n+        shortestDuration = track.getDuration();\n+      }\n+    }\n+    // Remove all timestamps that begin after the shortest duration\n+    ListIterator<Times> iter = cutMarks.listIterator();\n+    while (iter.hasNext()) {\n+      long begin = iter.next().begin;\n+      if (begin > shortestDuration) {\n+        logger.info(\"Skipped mark with begin: {}, \", begin);\n+        iter.remove();\n+      }\n+    }\n+    // If the timestamp list is now empty, give up\n+    if (cutMarks.size() < 1) {\n+      logger.warn(\"No timestamps are valid for the given tracks! Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start adding tracks\");\n+      for (Times mark : cutMarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        logger.debug(\"Segment begin: {}; Segment duration: {}\", mark.begin, mark.duration);\n+        // Add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        tracksFromFlavors.toArray(new Track[0]),\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      smil = smilResponse.getSmil();\n+      logger.info(\"Done adding tracks\");\n+    } catch (SmilException e) {\n+      throw new WorkflowOperationException(\"Failed to create SMIL Catalog\", e);\n+    }\n+\n+    // Put new SMIL into workspace and add it to media package\n+    try (InputStream is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\")) {\n+      URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+      MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+      Catalog catalog = (Catalog) mpeBuilder\n+              .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+      catalog.setIdentifier(smil.getId());\n+      for (String tag : targetTags) {\n+        catalog.addTag(tag);\n+      }\n+      mediaPackage.add(catalog);\n+    } catch (JAXBException | SAXException | IOException e) {\n+      throw new WorkflowOperationException(\"Failed to parse crated SMIL Catalog\", e);\n+    }\n+\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Cut marks to smil operation completed\");\n+    return result;\n+  }\n+\n+  private List<Track> getTracksFromFlavor(MediaPackageElementFlavor flavor, MediaPackage mediaPackage) {\n+    // Get tracks from flavor\n+    TrackSelector trackSelector = new TrackSelector();\n+    trackSelector.addFlavor(flavor);\n+    Collection<Track> tracks = trackSelector.select(mediaPackage, false);\n+\n+    // Get only videos\n+    ArrayList<Track> videos = new ArrayList<>();\n+    for (Track video : tracks) {\n+      if (video.hasVideo()) {\n+        videos.add((video));\n+      } else {\n+        logger.debug(\"Skipping track {} since it does not seem to have a vide track.\", video);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc0NTUwMQ=="}, "originalCommit": {"oid": "46fa471a935f853b73ac3311fa7089c8c6429118"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzI4NzA5OQ==", "bodyText": "Whatever the reason was that I originally implemented this, it seems to have vanished.  So I suppose this code snippet could be removed.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r557287099", "createdAt": "2021-01-14T10:18:40Z", "author": {"login": "Arnei"}, "path": "modules/smil-workflowoperation/src/main/java/org/opencastproject/workflow/handler/smil/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.smil;\n+\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Type;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(CutMarksToSmilWorkflowOperationHandler.class);\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+  private static final Type timesListType = new TypeToken<List<Times>>() { }.getType();\n+\n+  /** Stores information read from JSON */\n+  static class Times {\n+    private Long begin;\n+    private Long duration;\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length < 1) {\n+      logger.warn(\"No catalogs in the source flavor. Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    } else if (catalogs.length > 1) {\n+      throw new WorkflowOperationException(\"More than one catalog in the source flavor! Make sure there is only catalog.\");\n+    }\n+\n+    // Parse JSON\n+    List<Times> cutMarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutMarks = gson.fromJson(bufferedReader, timesListType);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON\", e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutMarks.size() < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutMarks) {\n+      logger.debug(\"Entry begin={}, duration={}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times may not be negative.\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get tracks from media package\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Tracks from Flavor {}\", flavor);\n+      List<Track> tracks = getTracksFromFlavor(flavor, mediaPackage);\n+      logger.debug(\"Found {} tracks in flavor {}\", tracks.size(), flavor);\n+      if (tracks.size() > 0) {\n+        tracksFromFlavors.addAll(tracks);\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Check for cut marks that would lead to errors with the given tracks and remove them\n+    // Possible TODO: Instead of removing, only apply cut marks to tracks with a long enough duration?\n+    // Get the shortest duration of all tracks\n+    long shortestDuration = Long.MAX_VALUE;\n+    for (Track track : tracksFromFlavors) {\n+      if (track.getDuration() < shortestDuration) {\n+        shortestDuration = track.getDuration();\n+      }\n+    }\n+    // Remove all timestamps that begin after the shortest duration\n+    ListIterator<Times> iter = cutMarks.listIterator();\n+    while (iter.hasNext()) {\n+      long begin = iter.next().begin;\n+      if (begin > shortestDuration) {\n+        logger.info(\"Skipped mark with begin: {}, \", begin);\n+        iter.remove();\n+      }\n+    }\n+    // If the timestamp list is now empty, give up\n+    if (cutMarks.size() < 1) {\n+      logger.warn(\"No timestamps are valid for the given tracks! Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start adding tracks\");\n+      for (Times mark : cutMarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        logger.debug(\"Segment begin: {}; Segment duration: {}\", mark.begin, mark.duration);\n+        // Add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        tracksFromFlavors.toArray(new Track[0]),\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      smil = smilResponse.getSmil();\n+      logger.info(\"Done adding tracks\");\n+    } catch (SmilException e) {\n+      throw new WorkflowOperationException(\"Failed to create SMIL Catalog\", e);\n+    }\n+\n+    // Put new SMIL into workspace and add it to media package\n+    try (InputStream is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\")) {\n+      URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+      MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+      Catalog catalog = (Catalog) mpeBuilder\n+              .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+      catalog.setIdentifier(smil.getId());\n+      for (String tag : targetTags) {\n+        catalog.addTag(tag);\n+      }\n+      mediaPackage.add(catalog);\n+    } catch (JAXBException | SAXException | IOException e) {\n+      throw new WorkflowOperationException(\"Failed to parse crated SMIL Catalog\", e);\n+    }\n+\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Cut marks to smil operation completed\");\n+    return result;\n+  }\n+\n+  private List<Track> getTracksFromFlavor(MediaPackageElementFlavor flavor, MediaPackage mediaPackage) {\n+    // Get tracks from flavor\n+    TrackSelector trackSelector = new TrackSelector();\n+    trackSelector.addFlavor(flavor);\n+    Collection<Track> tracks = trackSelector.select(mediaPackage, false);\n+\n+    // Get only videos\n+    ArrayList<Track> videos = new ArrayList<>();\n+    for (Track video : tracks) {\n+      if (video.hasVideo()) {\n+        videos.add((video));\n+      } else {\n+        logger.debug(\"Skipping track {} since it does not seem to have a vide track.\", video);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc0NTUwMQ=="}, "originalCommit": {"oid": "46fa471a935f853b73ac3311fa7089c8c6429118"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjA4OTg0MQ==", "bodyText": "Removed the filter. Now it's just the track selector.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r562089841", "createdAt": "2021-01-21T18:04:58Z", "author": {"login": "lkiesow"}, "path": "modules/smil-workflowoperation/src/main/java/org/opencastproject/workflow/handler/smil/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.smil;\n+\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Type;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(CutMarksToSmilWorkflowOperationHandler.class);\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+  private static final Type timesListType = new TypeToken<List<Times>>() { }.getType();\n+\n+  /** Stores information read from JSON */\n+  static class Times {\n+    private Long begin;\n+    private Long duration;\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length < 1) {\n+      logger.warn(\"No catalogs in the source flavor. Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    } else if (catalogs.length > 1) {\n+      throw new WorkflowOperationException(\"More than one catalog in the source flavor! Make sure there is only catalog.\");\n+    }\n+\n+    // Parse JSON\n+    List<Times> cutMarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutMarks = gson.fromJson(bufferedReader, timesListType);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON\", e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutMarks.size() < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutMarks) {\n+      logger.debug(\"Entry begin={}, duration={}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times may not be negative.\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get tracks from media package\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Tracks from Flavor {}\", flavor);\n+      List<Track> tracks = getTracksFromFlavor(flavor, mediaPackage);\n+      logger.debug(\"Found {} tracks in flavor {}\", tracks.size(), flavor);\n+      if (tracks.size() > 0) {\n+        tracksFromFlavors.addAll(tracks);\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Check for cut marks that would lead to errors with the given tracks and remove them\n+    // Possible TODO: Instead of removing, only apply cut marks to tracks with a long enough duration?\n+    // Get the shortest duration of all tracks\n+    long shortestDuration = Long.MAX_VALUE;\n+    for (Track track : tracksFromFlavors) {\n+      if (track.getDuration() < shortestDuration) {\n+        shortestDuration = track.getDuration();\n+      }\n+    }\n+    // Remove all timestamps that begin after the shortest duration\n+    ListIterator<Times> iter = cutMarks.listIterator();\n+    while (iter.hasNext()) {\n+      long begin = iter.next().begin;\n+      if (begin > shortestDuration) {\n+        logger.info(\"Skipped mark with begin: {}, \", begin);\n+        iter.remove();\n+      }\n+    }\n+    // If the timestamp list is now empty, give up\n+    if (cutMarks.size() < 1) {\n+      logger.warn(\"No timestamps are valid for the given tracks! Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start adding tracks\");\n+      for (Times mark : cutMarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        logger.debug(\"Segment begin: {}; Segment duration: {}\", mark.begin, mark.duration);\n+        // Add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        tracksFromFlavors.toArray(new Track[0]),\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      smil = smilResponse.getSmil();\n+      logger.info(\"Done adding tracks\");\n+    } catch (SmilException e) {\n+      throw new WorkflowOperationException(\"Failed to create SMIL Catalog\", e);\n+    }\n+\n+    // Put new SMIL into workspace and add it to media package\n+    try (InputStream is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\")) {\n+      URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+      MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+      Catalog catalog = (Catalog) mpeBuilder\n+              .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+      catalog.setIdentifier(smil.getId());\n+      for (String tag : targetTags) {\n+        catalog.addTag(tag);\n+      }\n+      mediaPackage.add(catalog);\n+    } catch (JAXBException | SAXException | IOException e) {\n+      throw new WorkflowOperationException(\"Failed to parse crated SMIL Catalog\", e);\n+    }\n+\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Cut marks to smil operation completed\");\n+    return result;\n+  }\n+\n+  private List<Track> getTracksFromFlavor(MediaPackageElementFlavor flavor, MediaPackage mediaPackage) {\n+    // Get tracks from flavor\n+    TrackSelector trackSelector = new TrackSelector();\n+    trackSelector.addFlavor(flavor);\n+    Collection<Track> tracks = trackSelector.select(mediaPackage, false);\n+\n+    // Get only videos\n+    ArrayList<Track> videos = new ArrayList<>();\n+    for (Track video : tracks) {\n+      if (video.hasVideo()) {\n+        videos.add((video));\n+      } else {\n+        logger.debug(\"Skipping track {} since it does not seem to have a vide track.\", video);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc0NTUwMQ=="}, "originalCommit": {"oid": "46fa471a935f853b73ac3311fa7089c8c6429118"}, "originalPosition": 279}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTIxODQ3OnYy", "diffSide": "RIGHT", "path": "modules/smil-workflowoperation/src/main/resources/OSGI-INF/operations/cut-marks-to-smil.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxODozOTozMVrOIS9Ihg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxODozOTozMVrOIS9Ihg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc0Njg4Ng==", "bodyText": "If anyone else is wondering: It would be nice to not specify this in XML but unfortunately, some methods are contained in the parent class which means we would probably need to change all the operation handlers at once.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r556746886", "createdAt": "2021-01-13T18:39:31Z", "author": {"login": "lkiesow"}, "path": "modules/smil-workflowoperation/src/main/resources/OSGI-INF/operations/cut-marks-to-smil.xml", "diffHunk": "@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<scr:component xmlns:scr=\"http://www.osgi.org/xmlns/scr/v1.1.0\"\n+               name=\"org.opencastproject.workflow.handler.smil.CutMarksToSmilWorkflowOperationHandler\"\n+               immediate=\"true\">\n+  <implementation class=\"org.opencastproject.workflow.handler.smil.CutMarksToSmilWorkflowOperationHandler\"/>\n+  <property name=\"service.description\" value=\"Cut Marks To Smil Operation Handler\"/>\n+  <property name=\"workflow.operation\" value=\"cut-marks-to-smil\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46fa471a935f853b73ac3311fa7089c8c6429118"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3208, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}