{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5MTgwNDUz", "number": 1430, "title": "#1429 rewrite ServiceRegistryJpaImplTest to reduce TravisCI failures", "bodyText": "Your pull request should\u2026\n\n have a concise title\n close an accompanying issue if one exists\n be against the correct branch (features can only go into develop)\n include migration scripts and documentation, if appropriate\n pass automated testing\n have a clean commit history\n have proper commit messages (title and body) for all commits\n have appropriate tags applied\n\nThis pull reduces setup and teardown overhead of the ServiceRegistryJpaImplTest junit tests. The goal is to remove the Travis CI proclivity towards random assert errors that cannot be duplicated in any other testing environment.", "createdAt": "2020-02-24T19:36:17Z", "url": "https://github.com/opencast/opencast/pull/1430", "merged": true, "mergeCommit": {"oid": "c4f96a776445a495670472e7eac0aafcbbad096b"}, "closed": true, "closedAt": "2020-03-10T21:46:41Z", "author": {"login": "karendolan"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIIU71gH2gAyMzc5MTgwNDUzOjE4YjdkY2VlYmEyMWQ2MjY4Zjk1ZjdiNjBiYzE1MjM0NDE2N2E3YzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIJFSkAH2gAyMzc5MTgwNDUzOmNlMjljNDdmYmRkY2M1ZTQ2ZDM3MDA1Njg3ZDhlYjJiYzUzMGZhOGM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "18b7dceeba21d6268f95f7b60bc152344167a7c3", "author": {"user": {"login": "karendolan", "name": "Karen Dolan"}}, "url": "https://github.com/opencast/opencast/commit/18b7dceeba21d6268f95f7b60bc152344167a7c3", "committedDate": "2020-02-26T15:19:35Z", "message": "1429 rewrite junit to speed tests and avoid race condition collision with Service Registry Dispatch loop (ref #1281)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "27b045c2f26d22a95ab0542f06ca185a7927c4d4", "author": {"user": {"login": "karendolan", "name": "Karen Dolan"}}, "url": "https://github.com/opencast/opencast/commit/27b045c2f26d22a95ab0542f06ca185a7927c4d4", "committedDate": "2020-02-24T19:27:36Z", "message": "#1429 rewrite ServiceRegistryJpaImplTest for happier TravisCI (ref #1281)"}, "afterCommit": {"oid": "18b7dceeba21d6268f95f7b60bc152344167a7c3", "author": {"user": {"login": "karendolan", "name": "Karen Dolan"}}, "url": "https://github.com/opencast/opencast/commit/18b7dceeba21d6268f95f7b60bc152344167a7c3", "committedDate": "2020-02-26T15:19:35Z", "message": "1429 rewrite junit to speed tests and avoid race condition collision with Service Registry Dispatch loop (ref #1281)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "372006da4bd6237b281aca1a831c7e3a8f716989", "author": {"user": {"login": "karendolan", "name": "Karen Dolan"}}, "url": "https://github.com/opencast/opencast/commit/372006da4bd6237b281aca1a831c7e3a8f716989", "committedDate": "2020-02-26T15:59:08Z", "message": "update host fairness test with longer wait and omit creating unneeded heartbeat scheduler"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MDMzMjAy", "url": "https://github.com/opencast/opencast/pull/1430#pullrequestreview-365033202", "createdAt": "2020-02-26T16:09:54Z", "commit": {"oid": "372006da4bd6237b281aca1a831c7e3a8f716989"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNjowOTo1NFrOFux8wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNjowOTo1NFrOFux8wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5NzE4NA==", "bodyText": "Maybe safer and more consistent to use JOB_BARRIER_TIMEOUT here... it'll make the test take longer, but less likely for TravisCI to choke.", "url": "https://github.com/opencast/opencast/pull/1430#discussion_r384597184", "createdAt": "2020-02-26T16:09:54Z", "author": {"login": "karendolan"}, "path": "modules/serviceregistry/src/test/java/org/opencastproject/serviceregistry/impl/ServiceRegistryJpaImplTest.java", "diffHunk": "@@ -252,69 +334,89 @@ public void testCancelUndispatchablesOrphanedByActivatingNode() throws Exception\n \n   @Test\n   public void testHostAddedToPriorityList() throws Exception {\n-    if (serviceRegistryJpaImpl.scheduledExecutor != null)\n-      serviceRegistryJpaImpl.scheduledExecutor.shutdown();\n-    serviceRegistryJpaImpl.scheduledExecutor = Executors.newScheduledThreadPool(1);\n-    serviceRegistryJpaImpl.activate(null);\n-    Hashtable<String, String> properties = new Hashtable<>();\n-    properties.put(\"dispatch.interval\", \"1\");\n-    serviceRegistryJpaImpl.updated(properties);\n-    registerTestHostAndService();\n     Job testJob = serviceRegistryJpaImpl.createJob(TEST_HOST, TEST_SERVICE, TEST_OPERATION, null, null, true, null);\n     JobBarrier barrier = new JobBarrier(null, serviceRegistryJpaImpl, testJob);\n+    launchDispatcherOnce(false);\n     try {\n-      barrier.waitForJobs(2000);\n-      Assert.fail();\n+      barrier.waitForJobs(JOB_BARRIER_TIMEOUT);\n+      Assert.fail(\"Did not recieve a timeout exception\");\n     } catch (Exception e) {\n       Assert.assertEquals(1, serviceRegistryJpaImpl.dispatchPriorityList.size());\n     }\n   }\n \n   @Test\n   public void testHostAddedToPriorityListExceptWorkflowType() throws Exception {\n-    if (serviceRegistryJpaImpl.scheduledExecutor != null)\n-      serviceRegistryJpaImpl.scheduledExecutor.shutdown();\n-    serviceRegistryJpaImpl.scheduledExecutor = Executors.newScheduledThreadPool(1);\n-    serviceRegistryJpaImpl.activate(null);\n-    Hashtable<String, String> properties = new Hashtable<>();\n-    properties.put(\"dispatch.interval\", \"1\");\n-    serviceRegistryJpaImpl.updated(properties);\n-    registerTestHostAndService();\n     serviceRegistryJpaImpl.registerService(TEST_SERVICE_3, TEST_HOST, TEST_PATH_3);\n     Job testJob = serviceRegistryJpaImpl.createJob(TEST_HOST, TEST_SERVICE_3, TEST_OPERATION, null, null, true, null);\n     JobBarrier barrier = new JobBarrier(null, serviceRegistryJpaImpl, testJob);\n+    launchDispatcherOnce(false);\n     try {\n-      barrier.waitForJobs(2000);\n-      Assert.fail();\n+      barrier.waitForJobs(JOB_BARRIER_TIMEOUT);\n+      Assert.fail(\"Did not recieve a timeout exception\");\n     } catch (Exception e) {\n       Assert.assertEquals(0, serviceRegistryJpaImpl.dispatchPriorityList.size());\n+    } finally {\n+      // extra clean up\n+      serviceRegistryJpaImpl.unRegisterService(TEST_SERVICE_3, TEST_HOST);\n     }\n-\n   }\n \n   @Test\n   public void testHostsBeingRemovedFromPriorityList() throws Exception {\n-    if (serviceRegistryJpaImpl.scheduledExecutor != null)\n-      serviceRegistryJpaImpl.scheduledExecutor.shutdown();\n-    serviceRegistryJpaImpl.scheduledExecutor = Executors.newScheduledThreadPool(1);\n-    serviceRegistryJpaImpl.activate(null);\n-    Hashtable<String, String> properties = new Hashtable<>();\n-    properties.put(\"dispatch.interval\", \"1\");\n-    serviceRegistryJpaImpl.updated(properties);\n-    registerTestHostAndService();\n     serviceRegistryJpaImpl.dispatchPriorityList.put(0L, TEST_HOST);\n     Job testJob = serviceRegistryJpaImpl.createJob(TEST_HOST, TEST_SERVICE_2, TEST_OPERATION, null, null, true, null);\n     JobBarrier barrier = new JobBarrier(null, serviceRegistryJpaImpl, testJob);\n+    launchDispatcherOnce(false);\n     try {\n-      barrier.waitForJobs(2000);\n-      Assert.fail();\n+      barrier.waitForJobs(JOB_BARRIER_TIMEOUT);\n+      Assert.fail(\"Did not recieve a timeout exception\");\n     } catch (Exception e) {\n       Assert.assertEquals(0, serviceRegistryJpaImpl.dispatchPriorityList.size());\n+    } finally {\n+      logger.debug(\"end testHostsBeingRemovedFromPriorityList\");\n+    }\n+  }\n+\n+  @Test\n+  public void testIgnoreHostsInPriorityList() throws Exception {\n+    Job testJob = serviceRegistryJpaImpl.createJob(TEST_HOST, TEST_SERVICE_2, TEST_OPERATION, null, null, true, null);\n+    Job testJob2 = serviceRegistryJpaImpl.createJob(TEST_HOST, TEST_SERVICE, TEST_OPERATION, null, null, true, null);\n+    serviceRegistryJpaImpl.dispatchPriorityList.put(testJob2.getId(), TEST_HOST);\n+    JobBarrier barrier = new JobBarrier(null, serviceRegistryJpaImpl, testJob, testJob2);\n+    launchDispatcherOnce(false);\n+    try {\n+      barrier.waitForJobs(JOB_BARRIER_TIMEOUT);\n+      Assert.fail(\"Did not recieve a timeout exception\");\n+    } catch (Exception e) {\n+      logger.debug(\"job1: '{}'\", serviceRegistryJpaImpl.getJob(testJob.getId()));\n+      logger.debug(\"job2: '{}'\", serviceRegistryJpaImpl.getJob(testJob2.getId()));\n+      for (Long jobId :serviceRegistryJpaImpl.dispatchPriorityList.keySet()) {\n+        logger.debug(\"job in priority queue: {}, {}\", jobId, serviceRegistryJpaImpl.dispatchPriorityList.get(jobId));\n+      }\n+      // Mock http client always returns 503 for this path so it won't be dispatched anyway\n+      testJob = serviceRegistryJpaImpl.getJob(testJob.getId());\n+      Assert.assertTrue(\"First job should not have a processing host\", StringUtils.isBlank(testJob.getProcessingHost()));\n+      Assert.assertEquals(\"First job is queueued\", Job.Status.QUEUED, testJob.getStatus());\n+\n+      // Mock http client always returns 204 for this path, but it should not be dispatched\n+      // because the host is in the dispatchPriorityList\n+      testJob2 = serviceRegistryJpaImpl.getJob(testJob2.getId());\n+      Assert.assertTrue(\"Second job should not have a processing host\", StringUtils.isBlank(testJob2.getProcessingHost()));\n+      Assert.assertEquals(\"Second job is queueued\", Job.Status.QUEUED, testJob2.getStatus());\n+\n+      Assert.assertEquals(1, serviceRegistryJpaImpl.dispatchPriorityList.size());\n+      String blockingHost = serviceRegistryJpaImpl.dispatchPriorityList.get(testJob2.getId());\n+      Assert.assertEquals(TEST_HOST, blockingHost);\n+    } finally {\n+      logger.debug(\"end testIgnoreHostsInPriorityList\");\n     }\n   }\n \n   private void assertHostloads(Job j, Float a, Float b, Float c) throws Exception {\n-    Thread.sleep(1100); //1100 is 100ms more than the minimum job dispatch interval.  Setting this lower causes race conditions.\n+    // launch the  dispatcher and wait a little longer for dispatch to complete before getting job\n+    launchDispatcherOnce(false);\n+    Thread.sleep(3 * DISPATCH_START_DELAY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "372006da4bd6237b281aca1a831c7e3a8f716989"}, "originalPosition": 344}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce29c47fbddcc5e46d37005687d8eb2bc530fa8c", "author": {"user": {"login": "karendolan", "name": "Karen Dolan"}}, "url": "https://github.com/opencast/opencast/commit/ce29c47fbddcc5e46d37005687d8eb2bc530fa8c", "committedDate": "2020-02-26T16:12:24Z", "message": "More consitent use of JOB_BARRIER_TIMEOUT param"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1911, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}