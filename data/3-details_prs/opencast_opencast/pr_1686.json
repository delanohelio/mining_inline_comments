{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2MDM2NTIz", "number": 1686, "title": "Workflow Operation \"CutMarksToSmil\"", "bodyText": "This operation parses a JSON containing cut marks into a SMIL that can be used by the VideoEditorWorkflowOperation. It does this by attributing the given times to the tracks in the given presentation and presenter flavors. This is useful in case you have cutmarks that need to be applied to files that are created during a workflow.\nUse-case example: Sending raw recording data from a web-conferencing application to Opencast, where Opencast should first concatenate the data and then cut the concatenated video file by user-defined cut marks.\nAn example workflow of how this can be used can be found in the bbb-upload.xml in this repo.\nYour pull request should\u2026\n\n have a concise title\n close an accompanying issue if one exists\n be against the correct branch (features can only go into develop)\n include migration scripts and documentation, if appropriate\n pass automated testing\n have a clean commit history\n have proper commit messages (title and body) for all commits\n have appropriate tags applied", "createdAt": "2020-07-08T06:55:52Z", "url": "https://github.com/opencast/opencast/pull/1686", "merged": true, "mergeCommit": {"oid": "6cf7fd699a54b9f1cbbcc4bc3d8eb2665bed62be"}, "closed": true, "closedAt": "2021-01-25T17:09:28Z", "author": {"login": "Arnei"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc1JKvqgFqTQ0ODg3NDE5Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdzphtZABqjQyNDY1MjE2MjQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4ODc0MTkz", "url": "https://github.com/opencast/opencast/pull/1686#pullrequestreview-448874193", "createdAt": "2020-07-15T11:44:56Z", "commit": {"oid": "da003feccf9d4004a8060800ad27c066dc131439"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTo0NDo1N1rOGx6Xzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTo0NDo1N1rOGx6Xzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk4OTc3NQ==", "bodyText": "Naming this configuration key source-smil-flavor is confusing. Based on this name I would expect a smil file, which is xml. However, you expect a JSON with the cut marks from BBB. Therefore I suggest to name it source-json-flavor and to amend the description with the information that these are the cut marks from BBB.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r454989775", "createdAt": "2020-07-15T11:44:57Z", "author": {"login": "ebbertd"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,66 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the \n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the \n+given presentation and presenter flavors. \n+\n+## Parameter Table\n+\n+|configuration keys         |example                |description                                                    |\n+|------------------         |-----------            |---------------------------------------------------------------|\n+|source-presenter-flavor    |`presenter/prepared`   |The flavor of the presenter video track. Must contain exactly one file.                   |\n+|source-presentation-flavor |`presentation/prepared`|The flavor of the presentation video track. Must contain exactly one file.                  |\n+|source-smil-flavor         |`smil/times`           |The flavor of the JSON. Must contain exactly one file.|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da003feccf9d4004a8060800ad27c066dc131439"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MTkxMDEy", "url": "https://github.com/opencast/opencast/pull/1686#pullrequestreview-454191012", "createdAt": "2020-07-23T14:30:43Z", "commit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozMDo0M1rOG2NSEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNTowMTowOFrOG2Orrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5MzkwNw==", "bodyText": "Can we not hard-code presentation and presenter but just use source-flavors where you can define a list of flavors in the form a/x,b/x or a wildcard like */source? That should be negligently harder to do and makes this far more flexible.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459493907", "createdAt": "2020-07-23T14:30:43Z", "author": {"login": "lkiesow"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,66 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the \n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the \n+given presentation and presenter flavors. \n+\n+## Parameter Table\n+\n+|configuration keys         |example                |description                                                    |\n+|------------------         |-----------            |---------------------------------------------------------------|\n+|source-presenter-flavor    |`presenter/prepared`   |The flavor of the presenter video track. Must contain exactly one file.                   |\n+|source-presentation-flavor |`presentation/prepared`|The flavor of the presentation video track. Must contain exactly one file.                  |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5NTY2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            *begin* marks the start of a segment, *duration* its duration. Times are in milliseconds.\n          \n          \n            \n            The JSON structure specifies all segments which should be kept after cutting.\n          \n          \n            \n            The property `begin` marks the start of a segmen while `duration` its duration.\n          \n          \n            \n            The values are specified in milliseconds.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459495665", "createdAt": "2020-07-23T14:33:09Z", "author": {"login": "lkiesow"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,66 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the \n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the \n+given presentation and presenter flavors. \n+\n+## Parameter Table\n+\n+|configuration keys         |example                |description                                                    |\n+|------------------         |-----------            |---------------------------------------------------------------|\n+|source-presenter-flavor    |`presenter/prepared`   |The flavor of the presenter video track. Must contain exactly one file.                   |\n+|source-presentation-flavor |`presentation/prepared`|The flavor of the presentation video track. Must contain exactly one file.                  |\n+|source-json-flavor         |`smil/times`           |The flavor of the JSON. Must contain exactly one file.|\n+|target-smil-flavor         |`smil/cutmarks`        |The flavor of the resulting SMIL.|\n+\n+## JSON Format\n+*begin* marks the start of a segment, *duration* its duration. Times are in milliseconds.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5ODYwNg==", "bodyText": "Keep the example as simple as possible\nDirectly generate smil/cutting\nUse an XML code block\n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    <operation\n          \n          \n            \n                        id=\"cut-marks-to-smil\"\n          \n          \n            \n                        description=\"Process ingested cutmarks by applying them to current tracks\"\n          \n          \n            \n                        fail-on-error=\"true\"\n          \n          \n            \n                        exception-handler-workflow=\"partial-error\">\n          \n          \n            \n                      <configurations>\n          \n          \n            \n                        <configuration key=\"source-presenter-flavor\">presenter/prepared</configuration>\n          \n          \n            \n                        <configuration key=\"source-presentation-flavor\">presentation/prepared</configuration>\n          \n          \n            \n                        <configuration key=\"source-json-flavor\">smil/times</configuration>\n          \n          \n            \n                        <configuration key=\"target-smil-flavor\">smil/cutmarks</configuration>\n          \n          \n            \n                      </configurations>\n          \n          \n            \n                    </operation>\n          \n          \n            \n            ```xml\n          \n          \n            \n            <operation\n          \n          \n            \n                id=\"cut-marks-to-smil\"\n          \n          \n            \n                description=\"Process ingested cutmarks by applying them to current tracks\">\n          \n          \n            \n              <configurations>\n          \n          \n            \n                <configuration key=\"source-presenter-flavor\">presenter/prepared</configuration>\n          \n          \n            \n                <configuration key=\"source-presentation-flavor\">presentation/prepared</configuration>\n          \n          \n            \n                <configuration key=\"source-json-flavor\">smil/times</configuration>\n          \n          \n            \n                <configuration key=\"target-smil-flavor\">smil/cutting</configuration>\n          \n          \n            \n              </configurations>\n          \n          \n            \n            </operation>", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459498606", "createdAt": "2020-07-23T14:37:03Z", "author": {"login": "lkiesow"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,66 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the \n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the \n+given presentation and presenter flavors. \n+\n+## Parameter Table\n+\n+|configuration keys         |example                |description                                                    |\n+|------------------         |-----------            |---------------------------------------------------------------|\n+|source-presenter-flavor    |`presenter/prepared`   |The flavor of the presenter video track. Must contain exactly one file.                   |\n+|source-presentation-flavor |`presentation/prepared`|The flavor of the presentation video track. Must contain exactly one file.                  |\n+|source-json-flavor         |`smil/times`           |The flavor of the JSON. Must contain exactly one file.|\n+|target-smil-flavor         |`smil/cutmarks`        |The flavor of the resulting SMIL.|\n+\n+## JSON Format\n+*begin* marks the start of a segment, *duration* its duration. Times are in milliseconds.\n+\n+    [\n+      {\n+        \"begin\": 1672,\n+        \"duration\": 7199\n+      }\n+    ]\n+\n+## Operation Example\n+\n+        <operation\n+            id=\"cut-marks-to-smil\"\n+            description=\"Process ingested cutmarks by applying them to current tracks\"\n+            fail-on-error=\"true\"\n+            exception-handler-workflow=\"partial-error\">\n+          <configurations>\n+            <configuration key=\"source-presenter-flavor\">presenter/prepared</configuration>\n+            <configuration key=\"source-presentation-flavor\">presentation/prepared</configuration>\n+            <configuration key=\"source-json-flavor\">smil/times</configuration>\n+            <configuration key=\"target-smil-flavor\">smil/cutmarks</configuration>\n+          </configurations>\n+        </operation>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5OTgyMw==", "bodyText": "Not sure if we need half a workflow here\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                    <operation\n          \n          \n            \n                        id=\"clone\"\n          \n          \n            \n                        exception-handler-workflow=\"partial-error\">\n          \n          \n            \n                      <configurations>\n          \n          \n            \n                        <configuration key=\"source-flavor\">smil/cutmarks</configuration>\n          \n          \n            \n                        <configuration key=\"target-flavor\">smil/cutting</configuration>\n          \n          \n            \n                      </configurations>\n          \n          \n            \n                    </operation>\n          \n          \n            \n            \n          \n          \n            \n                    <operation\n          \n          \n            \n                        id=\"editor\"\n          \n          \n            \n                        fail-on-error=\"true\"\n          \n          \n            \n                        exception-handler-workflow=\"error\"\n          \n          \n            \n                        description=\"Waiting for user to review / video edit recording\">\n          \n          \n            \n                      <configurations>\n          \n          \n            \n                        <configuration key=\"source-flavors\">*/prepared</configuration>\n          \n          \n            \n                        <configuration key=\"skipped-flavors\">*/prepared</configuration>\n          \n          \n            \n                        <configuration key=\"smil-flavors\">smil/cutting</configuration>\n          \n          \n            \n                        <configuration key=\"target-smil-flavor\">smil/cutting</configuration>\n          \n          \n            \n                        <configuration key=\"target-flavor-subtype\">trimmed</configuration>\n          \n          \n            \n                      </configurations>\n          \n          \n            \n                    </operation>", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459499823", "createdAt": "2020-07-23T14:38:37Z", "author": {"login": "lkiesow"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,66 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the \n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the \n+given presentation and presenter flavors. \n+\n+## Parameter Table\n+\n+|configuration keys         |example                |description                                                    |\n+|------------------         |-----------            |---------------------------------------------------------------|\n+|source-presenter-flavor    |`presenter/prepared`   |The flavor of the presenter video track. Must contain exactly one file.                   |\n+|source-presentation-flavor |`presentation/prepared`|The flavor of the presentation video track. Must contain exactly one file.                  |\n+|source-json-flavor         |`smil/times`           |The flavor of the JSON. Must contain exactly one file.|\n+|target-smil-flavor         |`smil/cutmarks`        |The flavor of the resulting SMIL.|\n+\n+## JSON Format\n+*begin* marks the start of a segment, *duration* its duration. Times are in milliseconds.\n+\n+    [\n+      {\n+        \"begin\": 1672,\n+        \"duration\": 7199\n+      }\n+    ]\n+\n+## Operation Example\n+\n+        <operation\n+            id=\"cut-marks-to-smil\"\n+            description=\"Process ingested cutmarks by applying them to current tracks\"\n+            fail-on-error=\"true\"\n+            exception-handler-workflow=\"partial-error\">\n+          <configurations>\n+            <configuration key=\"source-presenter-flavor\">presenter/prepared</configuration>\n+            <configuration key=\"source-presentation-flavor\">presentation/prepared</configuration>\n+            <configuration key=\"source-json-flavor\">smil/times</configuration>\n+            <configuration key=\"target-smil-flavor\">smil/cutmarks</configuration>\n+          </configurations>\n+        </operation>\n+\n+        <operation\n+            id=\"clone\"\n+            exception-handler-workflow=\"partial-error\">\n+          <configurations>\n+            <configuration key=\"source-flavor\">smil/cutmarks</configuration>\n+            <configuration key=\"target-flavor\">smil/cutting</configuration>\n+          </configurations>\n+        </operation>\n+\n+        <operation\n+            id=\"editor\"\n+            fail-on-error=\"true\"\n+            exception-handler-workflow=\"error\"\n+            description=\"Waiting for user to review / video edit recording\">\n+          <configurations>\n+            <configuration key=\"source-flavors\">*/prepared</configuration>\n+            <configuration key=\"skipped-flavors\">*/prepared</configuration>\n+            <configuration key=\"smil-flavors\">smil/cutting</configuration>\n+            <configuration key=\"target-smil-flavor\">smil/cutting</configuration>\n+            <configuration key=\"target-flavor-subtype\">trimmed</configuration>\n+          </configurations>\n+        </operation>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwMTE2OQ==", "bodyText": "This probably belongs not in here but in the BBB integration documentation at https://github.com/elan-ev/opencast-bigbluebutton-integration/tree/master/post-archive\nThough with no or a sensible description ;p", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459501169", "createdAt": "2020-07-23T14:40:24Z", "author": {"login": "lkiesow"}, "path": "etc/workflows/bbb-upload.xml", "diffHunk": "@@ -0,0 +1,291 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n+<definition xmlns=\"http://workflow.opencastproject.org\">\n+\n+  <id>bbb-upload</id>\n+  <title>BigBlueButton Upload</title>\n+  <tags>\n+  </tags>\n+  <displayOrder>1000</displayOrder>\n+  <description>\n+    Knock! Knock! Who's there? Candice. Candice who? Candice door open, or am I stuck out here?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwMjMwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      logger.warn(\"Unable to delete element {}: {}\", elem, e);\n          \n          \n            \n                      logger.warn(\"Unable to delete element {}\", elem, e);", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459502304", "createdAt": "2020-07-23T14:42:01Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwNDExNA==", "bodyText": "I tend to think we should rather fail here.\nOtherwise, we might accidentally publish uncut material without anyone notiving", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459504114", "createdAt": "2020-07-23T14:44:31Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwNDU4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n          \n          \n            \n                  logger.debug(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459504587", "createdAt": "2020-07-23T14:45:08Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwNjg3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  logger.info(\"Done Adding tracks\");\n          \n          \n            \n                  logger.info(\"Done adding tracks\");", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459506877", "createdAt": "2020-07-23T14:48:06Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    /** Create the new SMIL document **/\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    List<Track> videosPresenter = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presenterFlavor).toFn()).toList();\n+    List<Track> videosPresentation = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presentationFlavor).toFn()).toList();\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Handle more than exactly one track per flavor\n+    if (videosPresenter.size() != 1 || videosPresentation.size() != 1) {\n+      for (Track track : videosPresenter) {\n+        logger.info(\"VideosPresenter track: {}\", track);\n+      }\n+      for (Track track : videosPresentation) {\n+        logger.info(\"VideosPresentation track: {}\", track);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor must be exactly one.\");\n+    }\n+\n+    Track presenterTrack = videosPresenter.get(0);\n+    Track presentationTrack = videosPresentation.get(0);\n+    logger.info(\"PresenterTrack duration: {}, PresentationTrack duration {}\", presenterTrack.getDuration(),\n+            presentationTrack.getDuration());\n+\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        // add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      Smil smil = smilResponse.getSmil();\n+      logger.info(\"Done Adding tracks\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwODIzNA==", "bodyText": "Maybe use Java's try-with-resources statement", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459508234", "createdAt": "2020-07-23T14:49:54Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    /** Create the new SMIL document **/\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    List<Track> videosPresenter = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presenterFlavor).toFn()).toList();\n+    List<Track> videosPresentation = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presentationFlavor).toFn()).toList();\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Handle more than exactly one track per flavor\n+    if (videosPresenter.size() != 1 || videosPresentation.size() != 1) {\n+      for (Track track : videosPresenter) {\n+        logger.info(\"VideosPresenter track: {}\", track);\n+      }\n+      for (Track track : videosPresentation) {\n+        logger.info(\"VideosPresentation track: {}\", track);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor must be exactly one.\");\n+    }\n+\n+    Track presenterTrack = videosPresenter.get(0);\n+    Track presentationTrack = videosPresentation.get(0);\n+    logger.info(\"PresenterTrack duration: {}, PresentationTrack duration {}\", presenterTrack.getDuration(),\n+            presentationTrack.getDuration());\n+\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        // add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      Smil smil = smilResponse.getSmil();\n+      logger.info(\"Done Adding tracks\");\n+      InputStream is = null;\n+      try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxMTI4Mg==", "bodyText": "Why re-define skip as continue? That seems wrong.\nI dont' actually see the purpose of this method at all.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459511282", "createdAt": "2020-07-23T14:53:58Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    /** Create the new SMIL document **/\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    List<Track> videosPresenter = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presenterFlavor).toFn()).toList();\n+    List<Track> videosPresentation = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presentationFlavor).toFn()).toList();\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Handle more than exactly one track per flavor\n+    if (videosPresenter.size() != 1 || videosPresentation.size() != 1) {\n+      for (Track track : videosPresenter) {\n+        logger.info(\"VideosPresenter track: {}\", track);\n+      }\n+      for (Track track : videosPresentation) {\n+        logger.info(\"VideosPresentation track: {}\", track);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor must be exactly one.\");\n+    }\n+\n+    Track presenterTrack = videosPresenter.get(0);\n+    Track presentationTrack = videosPresentation.get(0);\n+    logger.info(\"PresenterTrack duration: {}, PresentationTrack duration {}\", presenterTrack.getDuration(),\n+            presentationTrack.getDuration());\n+\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        // add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      Smil smil = smilResponse.getSmil();\n+      logger.info(\"Done Adding tracks\");\n+      InputStream is = null;\n+      try {\n+        // Put new SMIL into workspace and add to mediapackage\n+        is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\");\n+        URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+        MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+        Catalog catalog = (Catalog) mpeBuilder\n+                .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+        catalog.setIdentifier(smil.getId());\n+        mediaPackage.add(catalog);\n+      } finally {\n+        IOUtils.closeQuietly(is);\n+      }\n+    } catch (Exception ex) {\n+      throw new WorkflowOperationException(\n+              format(\"Failed to create SMIL catalog for mediapackage %s\", mediaPackage.getIdentifier().toString()), ex);\n+    }\n+\n+    return skip(mediaPackage);\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.AbstractWorkflowOperationHandler#skip(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  private WorkflowOperationResult skip(MediaPackage mediaPackage) {\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Partial import operation completed\");\n+    return result;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNDcyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } catch (NotFoundException e) {\n          \n          \n            \n                  throw new WorkflowOperationException(\n          \n          \n            \n                          \"Error finding the media file in the workspace\", e);\n          \n          \n            \n                } catch (IOException e) {\n          \n          \n            \n                } catch (NotFoundException | IOException e) {", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459514722", "createdAt": "2020-07-23T14:58:21Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    /** Create the new SMIL document **/\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    List<Track> videosPresenter = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presenterFlavor).toFn()).toList();\n+    List<Track> videosPresentation = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presentationFlavor).toFn()).toList();\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Handle more than exactly one track per flavor\n+    if (videosPresenter.size() != 1 || videosPresentation.size() != 1) {\n+      for (Track track : videosPresenter) {\n+        logger.info(\"VideosPresenter track: {}\", track);\n+      }\n+      for (Track track : videosPresentation) {\n+        logger.info(\"VideosPresentation track: {}\", track);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor must be exactly one.\");\n+    }\n+\n+    Track presenterTrack = videosPresenter.get(0);\n+    Track presentationTrack = videosPresentation.get(0);\n+    logger.info(\"PresenterTrack duration: {}, PresentationTrack duration {}\", presenterTrack.getDuration(),\n+            presentationTrack.getDuration());\n+\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        // add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      Smil smil = smilResponse.getSmil();\n+      logger.info(\"Done Adding tracks\");\n+      InputStream is = null;\n+      try {\n+        // Put new SMIL into workspace and add to mediapackage\n+        is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\");\n+        URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+        MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+        Catalog catalog = (Catalog) mpeBuilder\n+                .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+        catalog.setIdentifier(smil.getId());\n+        mediaPackage.add(catalog);\n+      } finally {\n+        IOUtils.closeQuietly(is);\n+      }\n+    } catch (Exception ex) {\n+      throw new WorkflowOperationException(\n+              format(\"Failed to create SMIL catalog for mediapackage %s\", mediaPackage.getIdentifier().toString()), ex);\n+    }\n+\n+    return skip(mediaPackage);\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.AbstractWorkflowOperationHandler#skip(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  private WorkflowOperationResult skip(MediaPackage mediaPackage) {\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Partial import operation completed\");\n+    return result;\n+  }\n+\n+  /**\n+   * @param flavorType\n+   *          either \"presenter\" or \"presentation\", just for error messages\n+   */\n+  private MediaPackageElementFlavor parseTargetFlavor(String flavor, String flavorType)\n+          throws WorkflowOperationException {\n+    final MediaPackageElementFlavor targetFlavor;\n+    try {\n+      targetFlavor = MediaPackageElementFlavor.parseFlavor(flavor);\n+      if (\"*\".equals(targetFlavor.getType()) || \"*\".equals(targetFlavor.getSubtype())) {\n+        throw new WorkflowOperationException(format(\n+                \"Target %s flavor must have a type and a subtype, '*' are not allowed!\", flavorType));\n+      }\n+    } catch (IllegalArgumentException e) {\n+      throw new WorkflowOperationException(format(\"Target %s flavor '%s' is malformed\", flavorType, flavor));\n+    }\n+    return targetFlavor;\n+  }\n+\n+  private String getMediaPackageElementPath(MediaPackageElement mpe) throws WorkflowOperationException {\n+    File mediaFile;\n+    try {\n+      mediaFile = workspace.get(mpe.getURI());\n+    } catch (NotFoundException e) {\n+      throw new WorkflowOperationException(\n+              \"Error finding the media file in the workspace\", e);\n+    } catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNTA4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                String filePath = mediaFile.getAbsolutePath();\n          \n          \n            \n                return filePath;\n          \n          \n            \n                return mediaFile.getAbsolutePath();", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459515080", "createdAt": "2020-07-23T14:58:49Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    /** Create the new SMIL document **/\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    List<Track> videosPresenter = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presenterFlavor).toFn()).toList();\n+    List<Track> videosPresentation = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presentationFlavor).toFn()).toList();\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Handle more than exactly one track per flavor\n+    if (videosPresenter.size() != 1 || videosPresentation.size() != 1) {\n+      for (Track track : videosPresenter) {\n+        logger.info(\"VideosPresenter track: {}\", track);\n+      }\n+      for (Track track : videosPresentation) {\n+        logger.info(\"VideosPresentation track: {}\", track);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor must be exactly one.\");\n+    }\n+\n+    Track presenterTrack = videosPresenter.get(0);\n+    Track presentationTrack = videosPresentation.get(0);\n+    logger.info(\"PresenterTrack duration: {}, PresentationTrack duration {}\", presenterTrack.getDuration(),\n+            presentationTrack.getDuration());\n+\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        // add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      Smil smil = smilResponse.getSmil();\n+      logger.info(\"Done Adding tracks\");\n+      InputStream is = null;\n+      try {\n+        // Put new SMIL into workspace and add to mediapackage\n+        is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\");\n+        URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+        MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+        Catalog catalog = (Catalog) mpeBuilder\n+                .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+        catalog.setIdentifier(smil.getId());\n+        mediaPackage.add(catalog);\n+      } finally {\n+        IOUtils.closeQuietly(is);\n+      }\n+    } catch (Exception ex) {\n+      throw new WorkflowOperationException(\n+              format(\"Failed to create SMIL catalog for mediapackage %s\", mediaPackage.getIdentifier().toString()), ex);\n+    }\n+\n+    return skip(mediaPackage);\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.AbstractWorkflowOperationHandler#skip(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  private WorkflowOperationResult skip(MediaPackage mediaPackage) {\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Partial import operation completed\");\n+    return result;\n+  }\n+\n+  /**\n+   * @param flavorType\n+   *          either \"presenter\" or \"presentation\", just for error messages\n+   */\n+  private MediaPackageElementFlavor parseTargetFlavor(String flavor, String flavorType)\n+          throws WorkflowOperationException {\n+    final MediaPackageElementFlavor targetFlavor;\n+    try {\n+      targetFlavor = MediaPackageElementFlavor.parseFlavor(flavor);\n+      if (\"*\".equals(targetFlavor.getType()) || \"*\".equals(targetFlavor.getSubtype())) {\n+        throw new WorkflowOperationException(format(\n+                \"Target %s flavor must have a type and a subtype, '*' are not allowed!\", flavorType));\n+      }\n+    } catch (IllegalArgumentException e) {\n+      throw new WorkflowOperationException(format(\"Target %s flavor '%s' is malformed\", flavorType, flavor));\n+    }\n+    return targetFlavor;\n+  }\n+\n+  private String getMediaPackageElementPath(MediaPackageElement mpe) throws WorkflowOperationException {\n+    File mediaFile;\n+    try {\n+      mediaFile = workspace.get(mpe.getURI());\n+    } catch (NotFoundException e) {\n+      throw new WorkflowOperationException(\n+              \"Error finding the media file in the workspace\", e);\n+    } catch (IOException e) {\n+      throw new WorkflowOperationException(\n+              \"Error reading the media file in the workspace\", e);\n+    }\n+\n+    String filePath = mediaFile.getAbsolutePath();\n+    return filePath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNjg0Nw==", "bodyText": "We passed a rule that we won't accept new code using the Entwine Functional Library unless it really can't be avoided. For this pull request, you can easily use other means to archive the same goal.\nPlease avoid it.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459516847", "createdAt": "2020-07-23T15:01:08Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MTg0Njcx", "url": "https://github.com/opencast/opencast/pull/1686#pullrequestreview-487184671", "createdAt": "2020-09-12T00:30:05Z", "commit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "state": "DISMISSED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDozMDowNVrOHQxDyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0NzowNFrOHQxNlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MzA0OA==", "bodyText": "This is missing from the list of workflow operation handlers", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487343048", "createdAt": "2020-09-12T00:30:05Z", "author": {"login": "lkiesow"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,44 @@\n+CutMarksToSmilWorkflowOperationHandler", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MzM3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                [\n          \n          \n            \n                  {\n          \n          \n            \n                    \"begin\": 1672,\n          \n          \n            \n                    \"duration\": 7199\n          \n          \n            \n                  }\n          \n          \n            \n                ]\n          \n          \n            \n            ```json\n          \n          \n            \n            [\n          \n          \n            \n              {\n          \n          \n            \n                \"begin\": 1672,\n          \n          \n            \n                \"duration\": 7199\n          \n          \n            \n              }\n          \n          \n            \n            ]", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487343377", "createdAt": "2020-09-12T00:31:49Z", "author": {"login": "lkiesow"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,44 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the \n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the \n+given presentation and presenter flavors. \n+\n+## Parameter Table\n+\n+|configuration keys         |example                |description                                                    |\n+|------------------         |-----------            |---------------------------------------------------------------|\n+|source-media-flavors       |`presenter/prepared`   |The flavors containing the video tracks. Each flavor must contain at most one file.                   \n+|source-json-flavor         |`smil/times`           |The flavor of the JSON. Must contain exactly one file.|\n+|target-smil-flavor         |`smil/cutmarks`        |The flavor of the resulting SMIL.|\n+|target-tags                |`archive`              |(Optional) Tags to add to the resulting SMIL. Default is `null`|\n+\n+## JSON Format\n+The JSON structure specifies all segments which should be kept after cutting.\n+The property `begin` marks the start of a segment while `duration` its duration.\n+The values are specified in milliseconds.\n+\n+    [\n+      {\n+        \"begin\": 1672,\n+        \"duration\": 7199\n+      }\n+    ]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDE3Mg==", "bodyText": "Skipping this if there is none may be fine but skipping it if there are multiple catalogs is weird and unexpected. I would expect that they are both converted or that there is an error.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487344172", "createdAt": "2020-09-12T00:37:10Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDM1Ng==", "bodyText": "Use the cause argument of exception constructors:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n          \n          \n            \n                  throw new WorkflowOperationException(\"Could not read JSON\", e);", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487344356", "createdAt": "2020-09-12T00:38:47Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDU2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new WorkflowOperationException(\"Times cannot be negative!\");\n          \n          \n            \n                    throw new WorkflowOperationException(\"Times may not be negative.\");", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487344560", "createdAt": "2020-09-12T00:40:13Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDY1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                logger.info(\"Get Tracks from Mediapackage\");\n          \n          \n            \n                logger.info(\"Get tracks from media package\");", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487344658", "createdAt": "2020-09-12T00:40:50Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get Tracks from Mediapackage\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTEyNw==", "bodyText": "A flavor is no collection. It's an attribute:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Track {} in flavor {}\", track, flavor);\n          \n          \n            \n                    logger.info(\"Track {} with flavor {}\", track, flavor);", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487345127", "createdAt": "2020-09-12T00:44:19Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Track from Flavor {}\", flavor);\n+      Optional<Track> track = getTrackFromFlavor(flavor, mediaPackage);\n+      if (track.isPresent()) {\n+        tracksFromFlavors.add(track.get());\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        logger.debug(\"Segment begin: {}; Segment duration: {}\", mark.begin, mark.duration);\n+        // Add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        tracksFromFlavors.toArray(new Track[tracksFromFlavors.size()]), //new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      smil = smilResponse.getSmil();\n+      logger.info(\"Done adding tracks\");\n+    } catch (SmilException e) {\n+      throw new WorkflowOperationException(\"Failed to create SMIL Catalog\", e);\n+    }\n+\n+    // Put new SMIL into workspace and add it to mediapackage\n+    try (InputStream is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\")) {\n+      URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+      MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+      Catalog catalog = (Catalog) mpeBuilder\n+              .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+      catalog.setIdentifier(smil.getId());\n+      for (String tag : targetTags) {\n+        catalog.addTag(tag);\n+      }\n+      mediaPackage.add(catalog);\n+    } catch (JAXBException | SAXException | IOException e) {\n+      throw new WorkflowOperationException(\"Failed to parse crated SMIL Catalog\", e);\n+    }\n+\n+\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Cut marks to smil operation completed\");\n+    return result;\n+  }\n+\n+  private Optional<Track> getTrackFromFlavor(MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n+          throws WorkflowOperationException {\n+    Optional<Track> result = Optional.empty();\n+\n+    // Get tracks from flavor\n+    TrackSelector trackSelector = new TrackSelector();\n+    trackSelector.addFlavor(flavor);\n+    Collection<Track> tracks = trackSelector.select(mediaPackage, false);\n+\n+    // Get only videos\n+    ArrayList<Track> videos = new ArrayList<Track>();\n+    for (Track video : tracks) {\n+      if (video.hasVideo()) {\n+        videos.add((video));\n+      }\n+    }\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Can we handle more than one track per flavor?\n+    if (videos.isEmpty())\n+      return result;\n+    if (videos.size() > 1) {\n+      for (Track track : videos) {\n+        logger.info(\"Track {} in flavor {}\", track, flavor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTMyMw==", "bodyText": "Is there a reason why there can be only one video with a given flavor in this operation?", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487345323", "createdAt": "2020-09-12T00:45:27Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Track from Flavor {}\", flavor);\n+      Optional<Track> track = getTrackFromFlavor(flavor, mediaPackage);\n+      if (track.isPresent()) {\n+        tracksFromFlavors.add(track.get());\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        logger.debug(\"Segment begin: {}; Segment duration: {}\", mark.begin, mark.duration);\n+        // Add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        tracksFromFlavors.toArray(new Track[tracksFromFlavors.size()]), //new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      smil = smilResponse.getSmil();\n+      logger.info(\"Done adding tracks\");\n+    } catch (SmilException e) {\n+      throw new WorkflowOperationException(\"Failed to create SMIL Catalog\", e);\n+    }\n+\n+    // Put new SMIL into workspace and add it to mediapackage\n+    try (InputStream is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\")) {\n+      URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+      MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+      Catalog catalog = (Catalog) mpeBuilder\n+              .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+      catalog.setIdentifier(smil.getId());\n+      for (String tag : targetTags) {\n+        catalog.addTag(tag);\n+      }\n+      mediaPackage.add(catalog);\n+    } catch (JAXBException | SAXException | IOException e) {\n+      throw new WorkflowOperationException(\"Failed to parse crated SMIL Catalog\", e);\n+    }\n+\n+\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Cut marks to smil operation completed\");\n+    return result;\n+  }\n+\n+  private Optional<Track> getTrackFromFlavor(MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n+          throws WorkflowOperationException {\n+    Optional<Track> result = Optional.empty();\n+\n+    // Get tracks from flavor\n+    TrackSelector trackSelector = new TrackSelector();\n+    trackSelector.addFlavor(flavor);\n+    Collection<Track> tracks = trackSelector.select(mediaPackage, false);\n+\n+    // Get only videos\n+    ArrayList<Track> videos = new ArrayList<Track>();\n+    for (Track video : tracks) {\n+      if (video.hasVideo()) {\n+        videos.add((video));\n+      }\n+    }\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Can we handle more than one track per flavor?\n+    if (videos.isEmpty())\n+      return result;\n+    if (videos.size() > 1) {\n+      for (Track track : videos) {\n+        logger.info(\"Track {} in flavor {}\", track, flavor);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor cannot be more than one.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTU1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  logger.info(\"Start Adding tracks\");\n          \n          \n            \n                  logger.info(\"Start adding tracks\");", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487345558", "createdAt": "2020-09-12T00:47:04Z", "author": {"login": "lkiesow"}, "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Track from Flavor {}\", flavor);\n+      Optional<Track> track = getTrackFromFlavor(flavor, mediaPackage);\n+      if (track.isPresent()) {\n+        tracksFromFlavors.add(track.get());\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f5b252cb5b2cf4a2b9cb709d849da027dac866"}, "originalPosition": 225}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2NDU5MDYw", "url": "https://github.com/opencast/opencast/pull/1686#pullrequestreview-566459060", "createdAt": "2021-01-12T16:38:08Z", "commit": {"oid": "6e9702c9f5dec46d163fe62a22d5c63b4a063d6a"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6e9702c9f5dec46d163fe62a22d5c63b4a063d6a", "author": {"user": null}, "url": "https://github.com/opencast/opencast/commit/6e9702c9f5dec46d163fe62a22d5c63b4a063d6a", "committedDate": "2020-09-28T13:21:37Z", "message": "Removed the \"Exactly one track per flavor\" limitation as suggested by lkiesow.\n\n* Also commented in some test cases that were commented out for no apparent reason."}, "afterCommit": {"oid": "46fa471a935f853b73ac3311fa7089c8c6429118", "author": {"user": {"login": "lkiesow", "name": "Lars Kiesow"}}, "url": "https://github.com/opencast/opencast/commit/46fa471a935f853b73ac3311fa7089c8c6429118", "committedDate": "2021-01-13T18:28:12Z", "message": "Improve Cut Marks to Smil Operation\n\nThis patch fixes and improves the cut-marks to Smil operation. It's\nmainly minor code fixes and a few dependency fixes. This should not have\nchanged the overall functionality."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NTEwNDY2", "url": "https://github.com/opencast/opencast/pull/1686#pullrequestreview-567510466", "createdAt": "2021-01-13T18:34:44Z", "commit": {"oid": "46fa471a935f853b73ac3311fa7089c8c6429118"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxODozNDo0NVrOIS89Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxODozOTozMVrOIS9Ihg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc0Mzk1MQ==", "bodyText": "I'm wondering if something like cut-marks/json wouldn't be a better default name.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r556743951", "createdAt": "2021-01-13T18:34:45Z", "author": {"login": "lkiesow"}, "path": "docs/guides/admin/docs/workflowoperationhandlers/cut-marks-to-smil-woh.md", "diffHunk": "@@ -0,0 +1,57 @@\n+CutMarksToSmilWorkflowOperationHandler\n+===================================\n+\n+Description\n+-----------\n+\n+This operation parses a JSON containing cut marks into a SMIL that can be used by the\n+[VideoEditorWorkflowOperation](editor-woh.md). It does this by attributing the given times to the tracks in the\n+given presentation and presenter flavors.\n+\n+Tracks are assumed to start at 0. Likewise, cut marks are assumed to be specified relative to the beginning\n+of the tracks.\n+\n+\n+Parameter Table\n+---------------\n+\n+|Configuration Keys    |Example              |Description                                                    |\n+|----------------------|---------------------|---------------------------------------------------------------|\n+|source-media-flavors  |`presenter/prepared` |The flavors containing the video tracks.                       |\n+|source-json-flavor    |`smil/times`         |The flavor of the JSON. Must contain exactly one file.         |\n+|target-smil-flavor    |`smil/cutmarks`      |The flavor of the resulting SMIL.                              |\n+|target-tags           |`archive`            |(Optional) Tags to add to the resulting SMIL. Default is `null`|\n+\n+\n+JSON Format\n+-----------\n+\n+The JSON structure specifies all segments which should be kept after cutting.\n+The property `begin` marks the start of a segment while `duration` its duration.\n+The values are specified in milliseconds.\n+\n+```json\n+[\n+  {\n+    \"begin\": 1672,\n+    \"duration\": 7199\n+  }\n+]\n+```\n+\n+Operation Example\n+-----------------\n+\n+```xml\n+<operation\n+    id=\"cut-marks-to-smil\"\n+    description=\"Process ingested cutmarks by applying them to current tracks\"\n+    fail-on-error=\"true\"\n+    exception-handler-workflow=\"partial-error\">\n+  <configurations>\n+    <configuration key=\"source-media-flavors\">presenter/prepared,presentation/prepared</configuration>\n+    <configuration key=\"source-json-flavor\">json/times</configuration>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46fa471a935f853b73ac3311fa7089c8c6429118"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc0NTUwMQ==", "bodyText": "I'm wondering if there is a specific reason to require video streams to be present. This would mean that we cannot cut audio and also that we need to make sure that we run inspect on the media package before we run this operation.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r556745501", "createdAt": "2021-01-13T18:37:17Z", "author": {"login": "lkiesow"}, "path": "modules/smil-workflowoperation/src/main/java/org/opencastproject/workflow/handler/smil/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.smil;\n+\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Type;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(CutMarksToSmilWorkflowOperationHandler.class);\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+  private static final Type timesListType = new TypeToken<List<Times>>() { }.getType();\n+\n+  /** Stores information read from JSON */\n+  static class Times {\n+    private Long begin;\n+    private Long duration;\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length < 1) {\n+      logger.warn(\"No catalogs in the source flavor. Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    } else if (catalogs.length > 1) {\n+      throw new WorkflowOperationException(\"More than one catalog in the source flavor! Make sure there is only catalog.\");\n+    }\n+\n+    // Parse JSON\n+    List<Times> cutMarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutMarks = gson.fromJson(bufferedReader, timesListType);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON\", e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutMarks.size() < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutMarks) {\n+      logger.debug(\"Entry begin={}, duration={}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times may not be negative.\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get tracks from media package\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Tracks from Flavor {}\", flavor);\n+      List<Track> tracks = getTracksFromFlavor(flavor, mediaPackage);\n+      logger.debug(\"Found {} tracks in flavor {}\", tracks.size(), flavor);\n+      if (tracks.size() > 0) {\n+        tracksFromFlavors.addAll(tracks);\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Check for cut marks that would lead to errors with the given tracks and remove them\n+    // Possible TODO: Instead of removing, only apply cut marks to tracks with a long enough duration?\n+    // Get the shortest duration of all tracks\n+    long shortestDuration = Long.MAX_VALUE;\n+    for (Track track : tracksFromFlavors) {\n+      if (track.getDuration() < shortestDuration) {\n+        shortestDuration = track.getDuration();\n+      }\n+    }\n+    // Remove all timestamps that begin after the shortest duration\n+    ListIterator<Times> iter = cutMarks.listIterator();\n+    while (iter.hasNext()) {\n+      long begin = iter.next().begin;\n+      if (begin > shortestDuration) {\n+        logger.info(\"Skipped mark with begin: {}, \", begin);\n+        iter.remove();\n+      }\n+    }\n+    // If the timestamp list is now empty, give up\n+    if (cutMarks.size() < 1) {\n+      logger.warn(\"No timestamps are valid for the given tracks! Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start adding tracks\");\n+      for (Times mark : cutMarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        logger.debug(\"Segment begin: {}; Segment duration: {}\", mark.begin, mark.duration);\n+        // Add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        tracksFromFlavors.toArray(new Track[0]),\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      smil = smilResponse.getSmil();\n+      logger.info(\"Done adding tracks\");\n+    } catch (SmilException e) {\n+      throw new WorkflowOperationException(\"Failed to create SMIL Catalog\", e);\n+    }\n+\n+    // Put new SMIL into workspace and add it to media package\n+    try (InputStream is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\")) {\n+      URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+      MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+      Catalog catalog = (Catalog) mpeBuilder\n+              .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+      catalog.setIdentifier(smil.getId());\n+      for (String tag : targetTags) {\n+        catalog.addTag(tag);\n+      }\n+      mediaPackage.add(catalog);\n+    } catch (JAXBException | SAXException | IOException e) {\n+      throw new WorkflowOperationException(\"Failed to parse crated SMIL Catalog\", e);\n+    }\n+\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Cut marks to smil operation completed\");\n+    return result;\n+  }\n+\n+  private List<Track> getTracksFromFlavor(MediaPackageElementFlavor flavor, MediaPackage mediaPackage) {\n+    // Get tracks from flavor\n+    TrackSelector trackSelector = new TrackSelector();\n+    trackSelector.addFlavor(flavor);\n+    Collection<Track> tracks = trackSelector.select(mediaPackage, false);\n+\n+    // Get only videos\n+    ArrayList<Track> videos = new ArrayList<>();\n+    for (Track video : tracks) {\n+      if (video.hasVideo()) {\n+        videos.add((video));\n+      } else {\n+        logger.debug(\"Skipping track {} since it does not seem to have a vide track.\", video);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46fa471a935f853b73ac3311fa7089c8c6429118"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc0Njg4Ng==", "bodyText": "If anyone else is wondering: It would be nice to not specify this in XML but unfortunately, some methods are contained in the parent class which means we would probably need to change all the operation handlers at once.", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r556746886", "createdAt": "2021-01-13T18:39:31Z", "author": {"login": "lkiesow"}, "path": "modules/smil-workflowoperation/src/main/resources/OSGI-INF/operations/cut-marks-to-smil.xml", "diffHunk": "@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<scr:component xmlns:scr=\"http://www.osgi.org/xmlns/scr/v1.1.0\"\n+               name=\"org.opencastproject.workflow.handler.smil.CutMarksToSmilWorkflowOperationHandler\"\n+               immediate=\"true\">\n+  <implementation class=\"org.opencastproject.workflow.handler.smil.CutMarksToSmilWorkflowOperationHandler\"/>\n+  <property name=\"service.description\" value=\"Cut Marks To Smil Operation Handler\"/>\n+  <property name=\"workflow.operation\" value=\"cut-marks-to-smil\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46fa471a935f853b73ac3311fa7089c8c6429118"}, "originalPosition": 7}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "42103b51c997142866a2cd36024a73e727cd3915", "author": {"user": {"login": "lkiesow", "name": "Lars Kiesow"}}, "url": "https://github.com/opencast/opencast/commit/42103b51c997142866a2cd36024a73e727cd3915", "committedDate": "2021-01-13T19:04:36Z", "message": "Cut Marks to Smil Documentation\n\nThis patch adds some additional documentation about the new workflow\noperation handler."}, "afterCommit": {"oid": "db8b9cbde33636112940a66f4d3f181866e09f3e", "author": {"user": {"login": "lkiesow", "name": "Lars Kiesow"}}, "url": "https://github.com/opencast/opencast/commit/db8b9cbde33636112940a66f4d3f181866e09f3e", "committedDate": "2021-01-13T20:44:26Z", "message": "Cut Marks to Smil Documentation\n\nThis patch adds some additional documentation about the new workflow\noperation handler."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37d032cfc1af079064dcf7a3f12898dbcbfa7a26", "author": {"user": {"login": "Arnei", "name": "Arne Wilken"}}, "url": "https://github.com/opencast/opencast/commit/37d032cfc1af079064dcf7a3f12898dbcbfa7a26", "committedDate": "2021-01-25T16:24:48Z", "message": "WorkflowOperationHandler \"CutMarksToSmil\"\n\nThis operation parses a JSON containing cut marks into a SMIL that can\nbe used by the VideoEditorWorkflowOperation. It does this by attributing\nthe given times to the tracks in the given presentation and presenter\nflavors. This is useful in case you have cutmarks that need to be\napplied to files that are created during a workflow.\n\nUse-case example: Sending raw recording data from a web-conferencing\napplication to Opencast, where Opencast should first concatenate the\ndata and then cut the concatenated video file by user-defined cut marks.\n\nAlso adds a workflow showcasing the functionality.\n\nCo-authored-by: Lars Kiesow <lkiesow@uos.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8863e6904619f7c506ac7f5aba3af1b166bc3c0b", "author": {"user": {"login": "lkiesow", "name": "Lars Kiesow"}}, "url": "https://github.com/opencast/opencast/commit/8863e6904619f7c506ac7f5aba3af1b166bc3c0b", "committedDate": "2021-01-25T16:24:58Z", "message": "Improve Cut Marks to Smil Operation\n\nThis patch fixes and improves the cut-marks to Smil operation. It's\nmainly minor code fixes and a few dependency fixes. This should not have\nchanged the overall functionality."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f33a33873e0df39d32280d69263bc35677c2a6b", "author": {"user": {"login": "lkiesow", "name": "Lars Kiesow"}}, "url": "https://github.com/opencast/opencast/commit/2f33a33873e0df39d32280d69263bc35677c2a6b", "committedDate": "2021-01-25T16:24:58Z", "message": "Cut Marks to Smil Documentation\n\nThis patch adds some additional documentation about the new workflow\noperation handler."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6954fc874503c145c8740c2db762dc44096ccdda", "author": {"user": {"login": "lkiesow", "name": "Lars Kiesow"}}, "url": "https://github.com/opencast/opencast/commit/6954fc874503c145c8740c2db762dc44096ccdda", "committedDate": "2021-01-25T16:29:46Z", "message": "Apply Review Suggestions\n\nThis patch contains some slight improvements to the `cut-marks-to-smil`\noperation handler."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b681c2c44eabfc95cc5b75b7539950edfd2805f7", "author": {"user": {"login": "lkiesow", "name": "Lars Kiesow"}}, "url": "https://github.com/opencast/opencast/commit/b681c2c44eabfc95cc5b75b7539950edfd2805f7", "committedDate": "2021-01-21T19:40:54Z", "message": "Apply Review Suggestions\n\nThis patch contains some slight improvements to the `cut-marks-to-smil`\noperation handler."}, "afterCommit": {"oid": "6954fc874503c145c8740c2db762dc44096ccdda", "author": {"user": {"login": "lkiesow", "name": "Lars Kiesow"}}, "url": "https://github.com/opencast/opencast/commit/6954fc874503c145c8740c2db762dc44096ccdda", "committedDate": "2021-01-25T16:29:46Z", "message": "Apply Review Suggestions\n\nThis patch contains some slight improvements to the `cut-marks-to-smil`\noperation handler."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1855, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}