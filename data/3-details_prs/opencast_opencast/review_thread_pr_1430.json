{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5MTgwNDUz", "number": 1430, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNjowOTo1NFrODjI7sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNjowOTo1NFrODjI7sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTczMTA1OnYy", "diffSide": "RIGHT", "path": "modules/serviceregistry/src/test/java/org/opencastproject/serviceregistry/impl/ServiceRegistryJpaImplTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNjowOTo1NFrOFux8wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNjowOTo1NFrOFux8wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5NzE4NA==", "bodyText": "Maybe safer and more consistent to use JOB_BARRIER_TIMEOUT here... it'll make the test take longer, but less likely for TravisCI to choke.", "url": "https://github.com/opencast/opencast/pull/1430#discussion_r384597184", "createdAt": "2020-02-26T16:09:54Z", "author": {"login": "karendolan"}, "path": "modules/serviceregistry/src/test/java/org/opencastproject/serviceregistry/impl/ServiceRegistryJpaImplTest.java", "diffHunk": "@@ -252,69 +334,89 @@ public void testCancelUndispatchablesOrphanedByActivatingNode() throws Exception\n \n   @Test\n   public void testHostAddedToPriorityList() throws Exception {\n-    if (serviceRegistryJpaImpl.scheduledExecutor != null)\n-      serviceRegistryJpaImpl.scheduledExecutor.shutdown();\n-    serviceRegistryJpaImpl.scheduledExecutor = Executors.newScheduledThreadPool(1);\n-    serviceRegistryJpaImpl.activate(null);\n-    Hashtable<String, String> properties = new Hashtable<>();\n-    properties.put(\"dispatch.interval\", \"1\");\n-    serviceRegistryJpaImpl.updated(properties);\n-    registerTestHostAndService();\n     Job testJob = serviceRegistryJpaImpl.createJob(TEST_HOST, TEST_SERVICE, TEST_OPERATION, null, null, true, null);\n     JobBarrier barrier = new JobBarrier(null, serviceRegistryJpaImpl, testJob);\n+    launchDispatcherOnce(false);\n     try {\n-      barrier.waitForJobs(2000);\n-      Assert.fail();\n+      barrier.waitForJobs(JOB_BARRIER_TIMEOUT);\n+      Assert.fail(\"Did not recieve a timeout exception\");\n     } catch (Exception e) {\n       Assert.assertEquals(1, serviceRegistryJpaImpl.dispatchPriorityList.size());\n     }\n   }\n \n   @Test\n   public void testHostAddedToPriorityListExceptWorkflowType() throws Exception {\n-    if (serviceRegistryJpaImpl.scheduledExecutor != null)\n-      serviceRegistryJpaImpl.scheduledExecutor.shutdown();\n-    serviceRegistryJpaImpl.scheduledExecutor = Executors.newScheduledThreadPool(1);\n-    serviceRegistryJpaImpl.activate(null);\n-    Hashtable<String, String> properties = new Hashtable<>();\n-    properties.put(\"dispatch.interval\", \"1\");\n-    serviceRegistryJpaImpl.updated(properties);\n-    registerTestHostAndService();\n     serviceRegistryJpaImpl.registerService(TEST_SERVICE_3, TEST_HOST, TEST_PATH_3);\n     Job testJob = serviceRegistryJpaImpl.createJob(TEST_HOST, TEST_SERVICE_3, TEST_OPERATION, null, null, true, null);\n     JobBarrier barrier = new JobBarrier(null, serviceRegistryJpaImpl, testJob);\n+    launchDispatcherOnce(false);\n     try {\n-      barrier.waitForJobs(2000);\n-      Assert.fail();\n+      barrier.waitForJobs(JOB_BARRIER_TIMEOUT);\n+      Assert.fail(\"Did not recieve a timeout exception\");\n     } catch (Exception e) {\n       Assert.assertEquals(0, serviceRegistryJpaImpl.dispatchPriorityList.size());\n+    } finally {\n+      // extra clean up\n+      serviceRegistryJpaImpl.unRegisterService(TEST_SERVICE_3, TEST_HOST);\n     }\n-\n   }\n \n   @Test\n   public void testHostsBeingRemovedFromPriorityList() throws Exception {\n-    if (serviceRegistryJpaImpl.scheduledExecutor != null)\n-      serviceRegistryJpaImpl.scheduledExecutor.shutdown();\n-    serviceRegistryJpaImpl.scheduledExecutor = Executors.newScheduledThreadPool(1);\n-    serviceRegistryJpaImpl.activate(null);\n-    Hashtable<String, String> properties = new Hashtable<>();\n-    properties.put(\"dispatch.interval\", \"1\");\n-    serviceRegistryJpaImpl.updated(properties);\n-    registerTestHostAndService();\n     serviceRegistryJpaImpl.dispatchPriorityList.put(0L, TEST_HOST);\n     Job testJob = serviceRegistryJpaImpl.createJob(TEST_HOST, TEST_SERVICE_2, TEST_OPERATION, null, null, true, null);\n     JobBarrier barrier = new JobBarrier(null, serviceRegistryJpaImpl, testJob);\n+    launchDispatcherOnce(false);\n     try {\n-      barrier.waitForJobs(2000);\n-      Assert.fail();\n+      barrier.waitForJobs(JOB_BARRIER_TIMEOUT);\n+      Assert.fail(\"Did not recieve a timeout exception\");\n     } catch (Exception e) {\n       Assert.assertEquals(0, serviceRegistryJpaImpl.dispatchPriorityList.size());\n+    } finally {\n+      logger.debug(\"end testHostsBeingRemovedFromPriorityList\");\n+    }\n+  }\n+\n+  @Test\n+  public void testIgnoreHostsInPriorityList() throws Exception {\n+    Job testJob = serviceRegistryJpaImpl.createJob(TEST_HOST, TEST_SERVICE_2, TEST_OPERATION, null, null, true, null);\n+    Job testJob2 = serviceRegistryJpaImpl.createJob(TEST_HOST, TEST_SERVICE, TEST_OPERATION, null, null, true, null);\n+    serviceRegistryJpaImpl.dispatchPriorityList.put(testJob2.getId(), TEST_HOST);\n+    JobBarrier barrier = new JobBarrier(null, serviceRegistryJpaImpl, testJob, testJob2);\n+    launchDispatcherOnce(false);\n+    try {\n+      barrier.waitForJobs(JOB_BARRIER_TIMEOUT);\n+      Assert.fail(\"Did not recieve a timeout exception\");\n+    } catch (Exception e) {\n+      logger.debug(\"job1: '{}'\", serviceRegistryJpaImpl.getJob(testJob.getId()));\n+      logger.debug(\"job2: '{}'\", serviceRegistryJpaImpl.getJob(testJob2.getId()));\n+      for (Long jobId :serviceRegistryJpaImpl.dispatchPriorityList.keySet()) {\n+        logger.debug(\"job in priority queue: {}, {}\", jobId, serviceRegistryJpaImpl.dispatchPriorityList.get(jobId));\n+      }\n+      // Mock http client always returns 503 for this path so it won't be dispatched anyway\n+      testJob = serviceRegistryJpaImpl.getJob(testJob.getId());\n+      Assert.assertTrue(\"First job should not have a processing host\", StringUtils.isBlank(testJob.getProcessingHost()));\n+      Assert.assertEquals(\"First job is queueued\", Job.Status.QUEUED, testJob.getStatus());\n+\n+      // Mock http client always returns 204 for this path, but it should not be dispatched\n+      // because the host is in the dispatchPriorityList\n+      testJob2 = serviceRegistryJpaImpl.getJob(testJob2.getId());\n+      Assert.assertTrue(\"Second job should not have a processing host\", StringUtils.isBlank(testJob2.getProcessingHost()));\n+      Assert.assertEquals(\"Second job is queueued\", Job.Status.QUEUED, testJob2.getStatus());\n+\n+      Assert.assertEquals(1, serviceRegistryJpaImpl.dispatchPriorityList.size());\n+      String blockingHost = serviceRegistryJpaImpl.dispatchPriorityList.get(testJob2.getId());\n+      Assert.assertEquals(TEST_HOST, blockingHost);\n+    } finally {\n+      logger.debug(\"end testIgnoreHostsInPriorityList\");\n     }\n   }\n \n   private void assertHostloads(Job j, Float a, Float b, Float c) throws Exception {\n-    Thread.sleep(1100); //1100 is 100ms more than the minimum job dispatch interval.  Setting this lower causes race conditions.\n+    // launch the  dispatcher and wait a little longer for dispatch to complete before getting job\n+    launchDispatcherOnce(false);\n+    Thread.sleep(3 * DISPATCH_START_DELAY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "372006da4bd6237b281aca1a831c7e3a8f716989"}, "originalPosition": 344}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3262, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}