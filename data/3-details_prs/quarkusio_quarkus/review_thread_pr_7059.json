{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyMjk0NDQ3", "number": 7059, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwODo0Njo0NlrODd8xrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDo1OTowNVrODeaTNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzMxMDU0OnYy", "diffSide": "RIGHT", "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/DotNames.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwODo0Njo0NlrOFm16jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwODowNDowMlrOFncyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI3MzU1MA==", "bodyText": "Minor complaint: Maybe all this old stuff should be renamed to deprecated?", "url": "https://github.com/quarkusio/quarkus/pull/7059#discussion_r376273550", "createdAt": "2020-02-07T08:46:46Z", "author": {"login": "geoand"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/DotNames.java", "diffHunk": "@@ -10,17 +10,19 @@\n import io.smallrye.reactive.messaging.annotations.Emitter;\n import io.smallrye.reactive.messaging.annotations.Merge;\n import io.smallrye.reactive.messaging.annotations.OnOverflow;\n-import io.smallrye.reactive.messaging.annotations.Stream;\n \n public final class DotNames {\n \n     static final DotName VOID = DotName.createSimple(void.class.getName());\n     static final DotName INCOMING = DotName.createSimple(Incoming.class.getName());\n     static final DotName OUTGOING = DotName.createSimple(Outgoing.class.getName());\n-    static final DotName CHANNEL = DotName.createSimple(Stream.class.getName());\n-    static final DotName STREAM = DotName.createSimple(Channel.class.getName());\n-    static final DotName EMITTER = DotName.createSimple(Emitter.class.getName());\n-    static final DotName ON_OVERFLOW = DotName.createSimple(OnOverflow.class.getName());\n+    static final DotName CHANNEL = DotName.createSimple(org.eclipse.microprofile.reactive.messaging.Channel.class.getName());\n+    static final DotName OLD_CHANNEL = DotName.createSimple(Channel.class.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bba9a75be5159974866ea8c50da2406411a5858"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI4MDg1OQ==", "bodyText": "I was wondering, \"legacy\" vs. \"old\" vs. \"deprecated\". I'm good with all of them. Any opinion?", "url": "https://github.com/quarkusio/quarkus/pull/7059#discussion_r376280859", "createdAt": "2020-02-07T09:04:23Z", "author": {"login": "cescoffier"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/DotNames.java", "diffHunk": "@@ -10,17 +10,19 @@\n import io.smallrye.reactive.messaging.annotations.Emitter;\n import io.smallrye.reactive.messaging.annotations.Merge;\n import io.smallrye.reactive.messaging.annotations.OnOverflow;\n-import io.smallrye.reactive.messaging.annotations.Stream;\n \n public final class DotNames {\n \n     static final DotName VOID = DotName.createSimple(void.class.getName());\n     static final DotName INCOMING = DotName.createSimple(Incoming.class.getName());\n     static final DotName OUTGOING = DotName.createSimple(Outgoing.class.getName());\n-    static final DotName CHANNEL = DotName.createSimple(Stream.class.getName());\n-    static final DotName STREAM = DotName.createSimple(Channel.class.getName());\n-    static final DotName EMITTER = DotName.createSimple(Emitter.class.getName());\n-    static final DotName ON_OVERFLOW = DotName.createSimple(OnOverflow.class.getName());\n+    static final DotName CHANNEL = DotName.createSimple(org.eclipse.microprofile.reactive.messaging.Channel.class.getName());\n+    static final DotName OLD_CHANNEL = DotName.createSimple(Channel.class.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI3MzU1MA=="}, "originalCommit": {"oid": "2bba9a75be5159974866ea8c50da2406411a5858"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI4MjcwMw==", "bodyText": "I like legacy! I didn't think of that one, excellent!", "url": "https://github.com/quarkusio/quarkus/pull/7059#discussion_r376282703", "createdAt": "2020-02-07T09:08:47Z", "author": {"login": "geoand"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/DotNames.java", "diffHunk": "@@ -10,17 +10,19 @@\n import io.smallrye.reactive.messaging.annotations.Emitter;\n import io.smallrye.reactive.messaging.annotations.Merge;\n import io.smallrye.reactive.messaging.annotations.OnOverflow;\n-import io.smallrye.reactive.messaging.annotations.Stream;\n \n public final class DotNames {\n \n     static final DotName VOID = DotName.createSimple(void.class.getName());\n     static final DotName INCOMING = DotName.createSimple(Incoming.class.getName());\n     static final DotName OUTGOING = DotName.createSimple(Outgoing.class.getName());\n-    static final DotName CHANNEL = DotName.createSimple(Stream.class.getName());\n-    static final DotName STREAM = DotName.createSimple(Channel.class.getName());\n-    static final DotName EMITTER = DotName.createSimple(Emitter.class.getName());\n-    static final DotName ON_OVERFLOW = DotName.createSimple(OnOverflow.class.getName());\n+    static final DotName CHANNEL = DotName.createSimple(org.eclipse.microprofile.reactive.messaging.Channel.class.getName());\n+    static final DotName OLD_CHANNEL = DotName.createSimple(Channel.class.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI3MzU1MA=="}, "originalCommit": {"oid": "2bba9a75be5159974866ea8c50da2406411a5858"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkwOTkyNg==", "bodyText": "Changed!", "url": "https://github.com/quarkusio/quarkus/pull/7059#discussion_r376909926", "createdAt": "2020-02-10T08:02:23Z", "author": {"login": "cescoffier"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/DotNames.java", "diffHunk": "@@ -10,17 +10,19 @@\n import io.smallrye.reactive.messaging.annotations.Emitter;\n import io.smallrye.reactive.messaging.annotations.Merge;\n import io.smallrye.reactive.messaging.annotations.OnOverflow;\n-import io.smallrye.reactive.messaging.annotations.Stream;\n \n public final class DotNames {\n \n     static final DotName VOID = DotName.createSimple(void.class.getName());\n     static final DotName INCOMING = DotName.createSimple(Incoming.class.getName());\n     static final DotName OUTGOING = DotName.createSimple(Outgoing.class.getName());\n-    static final DotName CHANNEL = DotName.createSimple(Stream.class.getName());\n-    static final DotName STREAM = DotName.createSimple(Channel.class.getName());\n-    static final DotName EMITTER = DotName.createSimple(Emitter.class.getName());\n-    static final DotName ON_OVERFLOW = DotName.createSimple(OnOverflow.class.getName());\n+    static final DotName CHANNEL = DotName.createSimple(org.eclipse.microprofile.reactive.messaging.Channel.class.getName());\n+    static final DotName OLD_CHANNEL = DotName.createSimple(Channel.class.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI3MzU1MA=="}, "originalCommit": {"oid": "2bba9a75be5159974866ea8c50da2406411a5858"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkxMDM4Ng==", "bodyText": "Lovely! Now that the naming has been addressed, the hard part is over \ud83d\ude06", "url": "https://github.com/quarkusio/quarkus/pull/7059#discussion_r376910386", "createdAt": "2020-02-10T08:04:02Z", "author": {"login": "geoand"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/DotNames.java", "diffHunk": "@@ -10,17 +10,19 @@\n import io.smallrye.reactive.messaging.annotations.Emitter;\n import io.smallrye.reactive.messaging.annotations.Merge;\n import io.smallrye.reactive.messaging.annotations.OnOverflow;\n-import io.smallrye.reactive.messaging.annotations.Stream;\n \n public final class DotNames {\n \n     static final DotName VOID = DotName.createSimple(void.class.getName());\n     static final DotName INCOMING = DotName.createSimple(Incoming.class.getName());\n     static final DotName OUTGOING = DotName.createSimple(Outgoing.class.getName());\n-    static final DotName CHANNEL = DotName.createSimple(Stream.class.getName());\n-    static final DotName STREAM = DotName.createSimple(Channel.class.getName());\n-    static final DotName EMITTER = DotName.createSimple(Emitter.class.getName());\n-    static final DotName ON_OVERFLOW = DotName.createSimple(OnOverflow.class.getName());\n+    static final DotName CHANNEL = DotName.createSimple(org.eclipse.microprofile.reactive.messaging.Channel.class.getName());\n+    static final DotName OLD_CHANNEL = DotName.createSimple(Channel.class.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI3MzU1MA=="}, "originalCommit": {"oid": "2bba9a75be5159974866ea8c50da2406411a5858"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMjE0NzcyOnYy", "diffSide": "RIGHT", "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/SmallRyeReactiveMessagingProcessor.java", "isResolved": true, "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDo1OTowNVrOFnh4qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNDoyODo0OVrOFqmVvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5Mzk2MQ==", "bodyText": "I'm trying it and it looks like the MetricDecorator is included always (!), even without this line for some reason. And if the Metrics dependency is not present on the application, then it fails to boot due to a ClassNotFoundException: org.eclipse.microprofile.metrics.MetricRegistry because the MetricDecorator references that class. We need to find out why this bean is being included even when we don't want it.", "url": "https://github.com/quarkusio/quarkus/pull/7059#discussion_r376993961", "createdAt": "2020-02-10T10:59:05Z", "author": {"login": "jmartisk"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/SmallRyeReactiveMessagingProcessor.java", "diffHunk": "@@ -143,54 +149,98 @@ void validateBeanDeployment(\n \n         for (InjectionPointInfo injectionPoint : validationPhase.getContext()\n                 .get(BuildExtension.Key.INJECTION_POINTS)) {\n-            if (injectionPoint.getRequiredType().name()\n-                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n+            // New emitter from the spec.\n+            if (injectionPoint.getRequiredType().name().equals(\n+                    io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n                 AnnotationInstance instance = injectionPoint\n                         .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.CHANNEL);\n                 if (instance == null) {\n-                    instance = injectionPoint\n-                            .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.STREAM); //@Channel is the replacement of deprecated @Stream\n-                }\n-                if (instance != null) {\n-                    // Stream.value() is mandatory\n-                    String name = instance.value().asString();\n-                    Optional<AnnotationInstance> maybeOverflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n                             .stream()\n                             .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.ON_OVERFLOW\n                                     .equals(ai.name()))\n                             .filter(ai -> {\n-                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint.isParam()) {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n                                     return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n                                 }\n                                 return true;\n                             })\n                             .findAny();\n-                    LOGGER.debugf(\"Emitter injection point '%s' detected, stream name: '%s'\",\n-                            injectionPoint.getTargetInfo(), name);\n-\n-                    if (maybeOverflow.isPresent()) {\n-                        AnnotationInstance annotation = maybeOverflow.get();\n-                        AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n-                        int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n-                        emitters.produce(\n-                                EmitterBuildItem.of(name,\n-                                        annotation.value().asString(),\n-                                        bufferSize));\n-                    } else {\n-                        emitters.produce(EmitterBuildItem.of(name));\n-                    }\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n+                }\n+            }\n+\n+            // Deprecated Emitter from SmallRye (emitter, channel and on overflow have been added to the spec)\n+            if (injectionPoint.getRequiredType().name()\n+                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_EMITTER)) {\n+                AnnotationInstance instance = injectionPoint\n+                        .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_CHANNEL);\n+                if (instance == null) {\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                            .stream()\n+                            .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_ON_OVERFLOW\n+                                    .equals(ai.name()))\n+                            .filter(ai -> {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n+                                    return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n+                                }\n+                                return true;\n+                            })\n+                            .findAny();\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n                 }\n             }\n         }\n     }\n \n+    @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\n+    private void createEmitter(BuildProducer<EmitterBuildItem> emitters, InjectionPointInfo injectionPoint,\n+            String channelName,\n+            Optional<AnnotationInstance> overflow) {\n+        LOGGER.debugf(\"Emitter injection point '%s' detected, channel name: '%s'\",\n+                injectionPoint.getTargetInfo(), channelName);\n+        if (overflow.isPresent()) {\n+            AnnotationInstance annotation = overflow.get();\n+            AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n+            int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n+            emitters.produce(\n+                    EmitterBuildItem.of(channelName, annotation.value().asString(), bufferSize));\n+        } else {\n+            emitters.produce(EmitterBuildItem.of(channelName));\n+        }\n+    }\n+\n     @BuildStep\n     public List<UnremovableBeanBuildItem> removalExclusions() {\n         return Arrays.asList(\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+    }\n+\n+    @BuildStep\n+    public void enableMetrics(Capabilities capabilities, ReactiveMessagingConfiguration configuration,\n+            BuildProducer<AdditionalBeanBuildItem> beans) {\n+        if (capabilities.isCapabilityPresent(Capabilities.METRICS) && configuration.metricsEnabled) {\n+            beans.produce(new AdditionalBeanBuildItem(MetricDecorator.class.getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b30a826ca93685fb0b7e5a8e9a230d489666725f"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAxNDY4Mg==", "bodyText": "Hm, I think it's because SR-RM provider jar contains a beans.xml so all its beans are automatically picked up:\nhttps://github.com/smallrye/smallrye-reactive-messaging/blob/master/smallrye-reactive-messaging-provider/src/main/resources/META-INF/beans.xml\nNot sure if we can specifically exclude MetricDecorator without having to get rid of that beans.xml, but generally I have a feeling that it shouldn't be there", "url": "https://github.com/quarkusio/quarkus/pull/7059#discussion_r377014682", "createdAt": "2020-02-10T11:46:50Z", "author": {"login": "jmartisk"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/SmallRyeReactiveMessagingProcessor.java", "diffHunk": "@@ -143,54 +149,98 @@ void validateBeanDeployment(\n \n         for (InjectionPointInfo injectionPoint : validationPhase.getContext()\n                 .get(BuildExtension.Key.INJECTION_POINTS)) {\n-            if (injectionPoint.getRequiredType().name()\n-                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n+            // New emitter from the spec.\n+            if (injectionPoint.getRequiredType().name().equals(\n+                    io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n                 AnnotationInstance instance = injectionPoint\n                         .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.CHANNEL);\n                 if (instance == null) {\n-                    instance = injectionPoint\n-                            .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.STREAM); //@Channel is the replacement of deprecated @Stream\n-                }\n-                if (instance != null) {\n-                    // Stream.value() is mandatory\n-                    String name = instance.value().asString();\n-                    Optional<AnnotationInstance> maybeOverflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n                             .stream()\n                             .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.ON_OVERFLOW\n                                     .equals(ai.name()))\n                             .filter(ai -> {\n-                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint.isParam()) {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n                                     return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n                                 }\n                                 return true;\n                             })\n                             .findAny();\n-                    LOGGER.debugf(\"Emitter injection point '%s' detected, stream name: '%s'\",\n-                            injectionPoint.getTargetInfo(), name);\n-\n-                    if (maybeOverflow.isPresent()) {\n-                        AnnotationInstance annotation = maybeOverflow.get();\n-                        AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n-                        int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n-                        emitters.produce(\n-                                EmitterBuildItem.of(name,\n-                                        annotation.value().asString(),\n-                                        bufferSize));\n-                    } else {\n-                        emitters.produce(EmitterBuildItem.of(name));\n-                    }\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n+                }\n+            }\n+\n+            // Deprecated Emitter from SmallRye (emitter, channel and on overflow have been added to the spec)\n+            if (injectionPoint.getRequiredType().name()\n+                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_EMITTER)) {\n+                AnnotationInstance instance = injectionPoint\n+                        .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_CHANNEL);\n+                if (instance == null) {\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                            .stream()\n+                            .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_ON_OVERFLOW\n+                                    .equals(ai.name()))\n+                            .filter(ai -> {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n+                                    return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n+                                }\n+                                return true;\n+                            })\n+                            .findAny();\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n                 }\n             }\n         }\n     }\n \n+    @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\n+    private void createEmitter(BuildProducer<EmitterBuildItem> emitters, InjectionPointInfo injectionPoint,\n+            String channelName,\n+            Optional<AnnotationInstance> overflow) {\n+        LOGGER.debugf(\"Emitter injection point '%s' detected, channel name: '%s'\",\n+                injectionPoint.getTargetInfo(), channelName);\n+        if (overflow.isPresent()) {\n+            AnnotationInstance annotation = overflow.get();\n+            AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n+            int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n+            emitters.produce(\n+                    EmitterBuildItem.of(channelName, annotation.value().asString(), bufferSize));\n+        } else {\n+            emitters.produce(EmitterBuildItem.of(channelName));\n+        }\n+    }\n+\n     @BuildStep\n     public List<UnremovableBeanBuildItem> removalExclusions() {\n         return Arrays.asList(\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+    }\n+\n+    @BuildStep\n+    public void enableMetrics(Capabilities capabilities, ReactiveMessagingConfiguration configuration,\n+            BuildProducer<AdditionalBeanBuildItem> beans) {\n+        if (capabilities.isCapabilityPresent(Capabilities.METRICS) && configuration.metricsEnabled) {\n+            beans.produce(new AdditionalBeanBuildItem(MetricDecorator.class.getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5Mzk2MQ=="}, "originalCommit": {"oid": "b30a826ca93685fb0b7e5a8e9a230d489666725f"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE0NDk5MQ==", "bodyText": "It contains a bean.xml as it was requested. But yes, I can see the issue... Not sure how I can work around this issue. Dropping the beans.xml in reactive messaging would be seen as a breaking change.", "url": "https://github.com/quarkusio/quarkus/pull/7059#discussion_r377144991", "createdAt": "2020-02-10T15:46:52Z", "author": {"login": "cescoffier"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/SmallRyeReactiveMessagingProcessor.java", "diffHunk": "@@ -143,54 +149,98 @@ void validateBeanDeployment(\n \n         for (InjectionPointInfo injectionPoint : validationPhase.getContext()\n                 .get(BuildExtension.Key.INJECTION_POINTS)) {\n-            if (injectionPoint.getRequiredType().name()\n-                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n+            // New emitter from the spec.\n+            if (injectionPoint.getRequiredType().name().equals(\n+                    io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n                 AnnotationInstance instance = injectionPoint\n                         .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.CHANNEL);\n                 if (instance == null) {\n-                    instance = injectionPoint\n-                            .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.STREAM); //@Channel is the replacement of deprecated @Stream\n-                }\n-                if (instance != null) {\n-                    // Stream.value() is mandatory\n-                    String name = instance.value().asString();\n-                    Optional<AnnotationInstance> maybeOverflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n                             .stream()\n                             .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.ON_OVERFLOW\n                                     .equals(ai.name()))\n                             .filter(ai -> {\n-                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint.isParam()) {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n                                     return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n                                 }\n                                 return true;\n                             })\n                             .findAny();\n-                    LOGGER.debugf(\"Emitter injection point '%s' detected, stream name: '%s'\",\n-                            injectionPoint.getTargetInfo(), name);\n-\n-                    if (maybeOverflow.isPresent()) {\n-                        AnnotationInstance annotation = maybeOverflow.get();\n-                        AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n-                        int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n-                        emitters.produce(\n-                                EmitterBuildItem.of(name,\n-                                        annotation.value().asString(),\n-                                        bufferSize));\n-                    } else {\n-                        emitters.produce(EmitterBuildItem.of(name));\n-                    }\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n+                }\n+            }\n+\n+            // Deprecated Emitter from SmallRye (emitter, channel and on overflow have been added to the spec)\n+            if (injectionPoint.getRequiredType().name()\n+                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_EMITTER)) {\n+                AnnotationInstance instance = injectionPoint\n+                        .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_CHANNEL);\n+                if (instance == null) {\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                            .stream()\n+                            .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_ON_OVERFLOW\n+                                    .equals(ai.name()))\n+                            .filter(ai -> {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n+                                    return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n+                                }\n+                                return true;\n+                            })\n+                            .findAny();\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n                 }\n             }\n         }\n     }\n \n+    @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\n+    private void createEmitter(BuildProducer<EmitterBuildItem> emitters, InjectionPointInfo injectionPoint,\n+            String channelName,\n+            Optional<AnnotationInstance> overflow) {\n+        LOGGER.debugf(\"Emitter injection point '%s' detected, channel name: '%s'\",\n+                injectionPoint.getTargetInfo(), channelName);\n+        if (overflow.isPresent()) {\n+            AnnotationInstance annotation = overflow.get();\n+            AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n+            int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n+            emitters.produce(\n+                    EmitterBuildItem.of(channelName, annotation.value().asString(), bufferSize));\n+        } else {\n+            emitters.produce(EmitterBuildItem.of(channelName));\n+        }\n+    }\n+\n     @BuildStep\n     public List<UnremovableBeanBuildItem> removalExclusions() {\n         return Arrays.asList(\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+    }\n+\n+    @BuildStep\n+    public void enableMetrics(Capabilities capabilities, ReactiveMessagingConfiguration configuration,\n+            BuildProducer<AdditionalBeanBuildItem> beans) {\n+        if (capabilities.isCapabilityPresent(Capabilities.METRICS) && configuration.metricsEnabled) {\n+            beans.produce(new AdditionalBeanBuildItem(MetricDecorator.class.getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5Mzk2MQ=="}, "originalCommit": {"oid": "b30a826ca93685fb0b7e5a8e9a230d489666725f"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE1MjQ0NA==", "bodyText": "What's the purpose of it being there? What's the use case it was needed for?", "url": "https://github.com/quarkusio/quarkus/pull/7059#discussion_r377152444", "createdAt": "2020-02-10T15:58:02Z", "author": {"login": "kenfinnigan"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/SmallRyeReactiveMessagingProcessor.java", "diffHunk": "@@ -143,54 +149,98 @@ void validateBeanDeployment(\n \n         for (InjectionPointInfo injectionPoint : validationPhase.getContext()\n                 .get(BuildExtension.Key.INJECTION_POINTS)) {\n-            if (injectionPoint.getRequiredType().name()\n-                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n+            // New emitter from the spec.\n+            if (injectionPoint.getRequiredType().name().equals(\n+                    io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n                 AnnotationInstance instance = injectionPoint\n                         .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.CHANNEL);\n                 if (instance == null) {\n-                    instance = injectionPoint\n-                            .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.STREAM); //@Channel is the replacement of deprecated @Stream\n-                }\n-                if (instance != null) {\n-                    // Stream.value() is mandatory\n-                    String name = instance.value().asString();\n-                    Optional<AnnotationInstance> maybeOverflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n                             .stream()\n                             .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.ON_OVERFLOW\n                                     .equals(ai.name()))\n                             .filter(ai -> {\n-                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint.isParam()) {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n                                     return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n                                 }\n                                 return true;\n                             })\n                             .findAny();\n-                    LOGGER.debugf(\"Emitter injection point '%s' detected, stream name: '%s'\",\n-                            injectionPoint.getTargetInfo(), name);\n-\n-                    if (maybeOverflow.isPresent()) {\n-                        AnnotationInstance annotation = maybeOverflow.get();\n-                        AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n-                        int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n-                        emitters.produce(\n-                                EmitterBuildItem.of(name,\n-                                        annotation.value().asString(),\n-                                        bufferSize));\n-                    } else {\n-                        emitters.produce(EmitterBuildItem.of(name));\n-                    }\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n+                }\n+            }\n+\n+            // Deprecated Emitter from SmallRye (emitter, channel and on overflow have been added to the spec)\n+            if (injectionPoint.getRequiredType().name()\n+                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_EMITTER)) {\n+                AnnotationInstance instance = injectionPoint\n+                        .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_CHANNEL);\n+                if (instance == null) {\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                            .stream()\n+                            .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_ON_OVERFLOW\n+                                    .equals(ai.name()))\n+                            .filter(ai -> {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n+                                    return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n+                                }\n+                                return true;\n+                            })\n+                            .findAny();\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n                 }\n             }\n         }\n     }\n \n+    @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\n+    private void createEmitter(BuildProducer<EmitterBuildItem> emitters, InjectionPointInfo injectionPoint,\n+            String channelName,\n+            Optional<AnnotationInstance> overflow) {\n+        LOGGER.debugf(\"Emitter injection point '%s' detected, channel name: '%s'\",\n+                injectionPoint.getTargetInfo(), channelName);\n+        if (overflow.isPresent()) {\n+            AnnotationInstance annotation = overflow.get();\n+            AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n+            int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n+            emitters.produce(\n+                    EmitterBuildItem.of(channelName, annotation.value().asString(), bufferSize));\n+        } else {\n+            emitters.produce(EmitterBuildItem.of(channelName));\n+        }\n+    }\n+\n     @BuildStep\n     public List<UnremovableBeanBuildItem> removalExclusions() {\n         return Arrays.asList(\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+    }\n+\n+    @BuildStep\n+    public void enableMetrics(Capabilities capabilities, ReactiveMessagingConfiguration configuration,\n+            BuildProducer<AdditionalBeanBuildItem> beans) {\n+        if (capabilities.isCapabilityPresent(Capabilities.METRICS) && configuration.metricsEnabled) {\n+            beans.produce(new AdditionalBeanBuildItem(MetricDecorator.class.getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5Mzk2MQ=="}, "originalCommit": {"oid": "b30a826ca93685fb0b7e5a8e9a230d489666725f"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTg2Ng==", "bodyText": "We could potentially \"remove\" the @ApplicationScoped annotation from that bean by an annotation transformer, but that's ugly. Or add a build-time mechanism for Arc for excluding a particular bean, if there's no such thing yet. Also quite ugly.\nI feel we should get rid of the beans.xml if possible. If it's needed during testing for example, it can be added using ShrinkWrap. Removing it could be a breaking change from the PoV of the runtime that imports SR-RM, but if implemented properly it shouldn't be of any concern to user applications, I guess", "url": "https://github.com/quarkusio/quarkus/pull/7059#discussion_r377471866", "createdAt": "2020-02-11T07:16:25Z", "author": {"login": "jmartisk"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/SmallRyeReactiveMessagingProcessor.java", "diffHunk": "@@ -143,54 +149,98 @@ void validateBeanDeployment(\n \n         for (InjectionPointInfo injectionPoint : validationPhase.getContext()\n                 .get(BuildExtension.Key.INJECTION_POINTS)) {\n-            if (injectionPoint.getRequiredType().name()\n-                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n+            // New emitter from the spec.\n+            if (injectionPoint.getRequiredType().name().equals(\n+                    io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n                 AnnotationInstance instance = injectionPoint\n                         .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.CHANNEL);\n                 if (instance == null) {\n-                    instance = injectionPoint\n-                            .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.STREAM); //@Channel is the replacement of deprecated @Stream\n-                }\n-                if (instance != null) {\n-                    // Stream.value() is mandatory\n-                    String name = instance.value().asString();\n-                    Optional<AnnotationInstance> maybeOverflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n                             .stream()\n                             .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.ON_OVERFLOW\n                                     .equals(ai.name()))\n                             .filter(ai -> {\n-                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint.isParam()) {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n                                     return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n                                 }\n                                 return true;\n                             })\n                             .findAny();\n-                    LOGGER.debugf(\"Emitter injection point '%s' detected, stream name: '%s'\",\n-                            injectionPoint.getTargetInfo(), name);\n-\n-                    if (maybeOverflow.isPresent()) {\n-                        AnnotationInstance annotation = maybeOverflow.get();\n-                        AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n-                        int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n-                        emitters.produce(\n-                                EmitterBuildItem.of(name,\n-                                        annotation.value().asString(),\n-                                        bufferSize));\n-                    } else {\n-                        emitters.produce(EmitterBuildItem.of(name));\n-                    }\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n+                }\n+            }\n+\n+            // Deprecated Emitter from SmallRye (emitter, channel and on overflow have been added to the spec)\n+            if (injectionPoint.getRequiredType().name()\n+                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_EMITTER)) {\n+                AnnotationInstance instance = injectionPoint\n+                        .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_CHANNEL);\n+                if (instance == null) {\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                            .stream()\n+                            .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_ON_OVERFLOW\n+                                    .equals(ai.name()))\n+                            .filter(ai -> {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n+                                    return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n+                                }\n+                                return true;\n+                            })\n+                            .findAny();\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n                 }\n             }\n         }\n     }\n \n+    @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\n+    private void createEmitter(BuildProducer<EmitterBuildItem> emitters, InjectionPointInfo injectionPoint,\n+            String channelName,\n+            Optional<AnnotationInstance> overflow) {\n+        LOGGER.debugf(\"Emitter injection point '%s' detected, channel name: '%s'\",\n+                injectionPoint.getTargetInfo(), channelName);\n+        if (overflow.isPresent()) {\n+            AnnotationInstance annotation = overflow.get();\n+            AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n+            int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n+            emitters.produce(\n+                    EmitterBuildItem.of(channelName, annotation.value().asString(), bufferSize));\n+        } else {\n+            emitters.produce(EmitterBuildItem.of(channelName));\n+        }\n+    }\n+\n     @BuildStep\n     public List<UnremovableBeanBuildItem> removalExclusions() {\n         return Arrays.asList(\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+    }\n+\n+    @BuildStep\n+    public void enableMetrics(Capabilities capabilities, ReactiveMessagingConfiguration configuration,\n+            BuildProducer<AdditionalBeanBuildItem> beans) {\n+        if (capabilities.isCapabilityPresent(Capabilities.METRICS) && configuration.metricsEnabled) {\n+            beans.produce(new AdditionalBeanBuildItem(MetricDecorator.class.getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5Mzk2MQ=="}, "originalCommit": {"oid": "b30a826ca93685fb0b7e5a8e9a230d489666725f"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDExNjQ1NQ==", "bodyText": "Removing the beans.xml is a dead end. It breaks too many things (such as the Java SE support).\nOne approach would be to move the metric decorator to its own module - without a beans.xml, and add the bean only in Quarkus. That potentially means more work to pass the TCK (mandating the metric support) and providing an implementation that would only be compliant in Quarkus. So not sure about this approach either.", "url": "https://github.com/quarkusio/quarkus/pull/7059#discussion_r380116455", "createdAt": "2020-02-17T11:01:11Z", "author": {"login": "cescoffier"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/SmallRyeReactiveMessagingProcessor.java", "diffHunk": "@@ -143,54 +149,98 @@ void validateBeanDeployment(\n \n         for (InjectionPointInfo injectionPoint : validationPhase.getContext()\n                 .get(BuildExtension.Key.INJECTION_POINTS)) {\n-            if (injectionPoint.getRequiredType().name()\n-                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n+            // New emitter from the spec.\n+            if (injectionPoint.getRequiredType().name().equals(\n+                    io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n                 AnnotationInstance instance = injectionPoint\n                         .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.CHANNEL);\n                 if (instance == null) {\n-                    instance = injectionPoint\n-                            .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.STREAM); //@Channel is the replacement of deprecated @Stream\n-                }\n-                if (instance != null) {\n-                    // Stream.value() is mandatory\n-                    String name = instance.value().asString();\n-                    Optional<AnnotationInstance> maybeOverflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n                             .stream()\n                             .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.ON_OVERFLOW\n                                     .equals(ai.name()))\n                             .filter(ai -> {\n-                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint.isParam()) {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n                                     return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n                                 }\n                                 return true;\n                             })\n                             .findAny();\n-                    LOGGER.debugf(\"Emitter injection point '%s' detected, stream name: '%s'\",\n-                            injectionPoint.getTargetInfo(), name);\n-\n-                    if (maybeOverflow.isPresent()) {\n-                        AnnotationInstance annotation = maybeOverflow.get();\n-                        AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n-                        int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n-                        emitters.produce(\n-                                EmitterBuildItem.of(name,\n-                                        annotation.value().asString(),\n-                                        bufferSize));\n-                    } else {\n-                        emitters.produce(EmitterBuildItem.of(name));\n-                    }\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n+                }\n+            }\n+\n+            // Deprecated Emitter from SmallRye (emitter, channel and on overflow have been added to the spec)\n+            if (injectionPoint.getRequiredType().name()\n+                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_EMITTER)) {\n+                AnnotationInstance instance = injectionPoint\n+                        .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_CHANNEL);\n+                if (instance == null) {\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                            .stream()\n+                            .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_ON_OVERFLOW\n+                                    .equals(ai.name()))\n+                            .filter(ai -> {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n+                                    return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n+                                }\n+                                return true;\n+                            })\n+                            .findAny();\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n                 }\n             }\n         }\n     }\n \n+    @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\n+    private void createEmitter(BuildProducer<EmitterBuildItem> emitters, InjectionPointInfo injectionPoint,\n+            String channelName,\n+            Optional<AnnotationInstance> overflow) {\n+        LOGGER.debugf(\"Emitter injection point '%s' detected, channel name: '%s'\",\n+                injectionPoint.getTargetInfo(), channelName);\n+        if (overflow.isPresent()) {\n+            AnnotationInstance annotation = overflow.get();\n+            AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n+            int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n+            emitters.produce(\n+                    EmitterBuildItem.of(channelName, annotation.value().asString(), bufferSize));\n+        } else {\n+            emitters.produce(EmitterBuildItem.of(channelName));\n+        }\n+    }\n+\n     @BuildStep\n     public List<UnremovableBeanBuildItem> removalExclusions() {\n         return Arrays.asList(\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+    }\n+\n+    @BuildStep\n+    public void enableMetrics(Capabilities capabilities, ReactiveMessagingConfiguration configuration,\n+            BuildProducer<AdditionalBeanBuildItem> beans) {\n+        if (capabilities.isCapabilityPresent(Capabilities.METRICS) && configuration.metricsEnabled) {\n+            beans.produce(new AdditionalBeanBuildItem(MetricDecorator.class.getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5Mzk2MQ=="}, "originalCommit": {"oid": "b30a826ca93685fb0b7e5a8e9a230d489666725f"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NTk2NQ==", "bodyText": "One more option would be to make the decorator a no-op when the metrics extension is not available. To not trigger a ClassNotFoundException we would have to get rid of the MetricRegistry injection in it, and instead retrieve the registry by using static methods of the SmallRye-specific MetricRegistries class, when it's available.\nNot that it's nice, but it's possible.", "url": "https://github.com/quarkusio/quarkus/pull/7059#discussion_r380145965", "createdAt": "2020-02-17T12:10:09Z", "author": {"login": "jmartisk"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/SmallRyeReactiveMessagingProcessor.java", "diffHunk": "@@ -143,54 +149,98 @@ void validateBeanDeployment(\n \n         for (InjectionPointInfo injectionPoint : validationPhase.getContext()\n                 .get(BuildExtension.Key.INJECTION_POINTS)) {\n-            if (injectionPoint.getRequiredType().name()\n-                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n+            // New emitter from the spec.\n+            if (injectionPoint.getRequiredType().name().equals(\n+                    io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n                 AnnotationInstance instance = injectionPoint\n                         .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.CHANNEL);\n                 if (instance == null) {\n-                    instance = injectionPoint\n-                            .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.STREAM); //@Channel is the replacement of deprecated @Stream\n-                }\n-                if (instance != null) {\n-                    // Stream.value() is mandatory\n-                    String name = instance.value().asString();\n-                    Optional<AnnotationInstance> maybeOverflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n                             .stream()\n                             .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.ON_OVERFLOW\n                                     .equals(ai.name()))\n                             .filter(ai -> {\n-                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint.isParam()) {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n                                     return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n                                 }\n                                 return true;\n                             })\n                             .findAny();\n-                    LOGGER.debugf(\"Emitter injection point '%s' detected, stream name: '%s'\",\n-                            injectionPoint.getTargetInfo(), name);\n-\n-                    if (maybeOverflow.isPresent()) {\n-                        AnnotationInstance annotation = maybeOverflow.get();\n-                        AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n-                        int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n-                        emitters.produce(\n-                                EmitterBuildItem.of(name,\n-                                        annotation.value().asString(),\n-                                        bufferSize));\n-                    } else {\n-                        emitters.produce(EmitterBuildItem.of(name));\n-                    }\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n+                }\n+            }\n+\n+            // Deprecated Emitter from SmallRye (emitter, channel and on overflow have been added to the spec)\n+            if (injectionPoint.getRequiredType().name()\n+                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_EMITTER)) {\n+                AnnotationInstance instance = injectionPoint\n+                        .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_CHANNEL);\n+                if (instance == null) {\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                            .stream()\n+                            .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_ON_OVERFLOW\n+                                    .equals(ai.name()))\n+                            .filter(ai -> {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n+                                    return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n+                                }\n+                                return true;\n+                            })\n+                            .findAny();\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n                 }\n             }\n         }\n     }\n \n+    @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\n+    private void createEmitter(BuildProducer<EmitterBuildItem> emitters, InjectionPointInfo injectionPoint,\n+            String channelName,\n+            Optional<AnnotationInstance> overflow) {\n+        LOGGER.debugf(\"Emitter injection point '%s' detected, channel name: '%s'\",\n+                injectionPoint.getTargetInfo(), channelName);\n+        if (overflow.isPresent()) {\n+            AnnotationInstance annotation = overflow.get();\n+            AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n+            int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n+            emitters.produce(\n+                    EmitterBuildItem.of(channelName, annotation.value().asString(), bufferSize));\n+        } else {\n+            emitters.produce(EmitterBuildItem.of(channelName));\n+        }\n+    }\n+\n     @BuildStep\n     public List<UnremovableBeanBuildItem> removalExclusions() {\n         return Arrays.asList(\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+    }\n+\n+    @BuildStep\n+    public void enableMetrics(Capabilities capabilities, ReactiveMessagingConfiguration configuration,\n+            BuildProducer<AdditionalBeanBuildItem> beans) {\n+        if (capabilities.isCapabilityPresent(Capabilities.METRICS) && configuration.metricsEnabled) {\n+            beans.produce(new AdditionalBeanBuildItem(MetricDecorator.class.getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5Mzk2MQ=="}, "originalCommit": {"oid": "b30a826ca93685fb0b7e5a8e9a230d489666725f"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE2NjkyNw==", "bodyText": "That would require a change in SR Reactive Messaging that would use an SR specific API? Unfortunately, it's not possible as this implementation is used in other environments (that do not use SR Metrics)", "url": "https://github.com/quarkusio/quarkus/pull/7059#discussion_r380166927", "createdAt": "2020-02-17T12:58:08Z", "author": {"login": "cescoffier"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/SmallRyeReactiveMessagingProcessor.java", "diffHunk": "@@ -143,54 +149,98 @@ void validateBeanDeployment(\n \n         for (InjectionPointInfo injectionPoint : validationPhase.getContext()\n                 .get(BuildExtension.Key.INJECTION_POINTS)) {\n-            if (injectionPoint.getRequiredType().name()\n-                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n+            // New emitter from the spec.\n+            if (injectionPoint.getRequiredType().name().equals(\n+                    io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n                 AnnotationInstance instance = injectionPoint\n                         .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.CHANNEL);\n                 if (instance == null) {\n-                    instance = injectionPoint\n-                            .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.STREAM); //@Channel is the replacement of deprecated @Stream\n-                }\n-                if (instance != null) {\n-                    // Stream.value() is mandatory\n-                    String name = instance.value().asString();\n-                    Optional<AnnotationInstance> maybeOverflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n                             .stream()\n                             .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.ON_OVERFLOW\n                                     .equals(ai.name()))\n                             .filter(ai -> {\n-                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint.isParam()) {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n                                     return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n                                 }\n                                 return true;\n                             })\n                             .findAny();\n-                    LOGGER.debugf(\"Emitter injection point '%s' detected, stream name: '%s'\",\n-                            injectionPoint.getTargetInfo(), name);\n-\n-                    if (maybeOverflow.isPresent()) {\n-                        AnnotationInstance annotation = maybeOverflow.get();\n-                        AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n-                        int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n-                        emitters.produce(\n-                                EmitterBuildItem.of(name,\n-                                        annotation.value().asString(),\n-                                        bufferSize));\n-                    } else {\n-                        emitters.produce(EmitterBuildItem.of(name));\n-                    }\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n+                }\n+            }\n+\n+            // Deprecated Emitter from SmallRye (emitter, channel and on overflow have been added to the spec)\n+            if (injectionPoint.getRequiredType().name()\n+                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_EMITTER)) {\n+                AnnotationInstance instance = injectionPoint\n+                        .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_CHANNEL);\n+                if (instance == null) {\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                            .stream()\n+                            .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_ON_OVERFLOW\n+                                    .equals(ai.name()))\n+                            .filter(ai -> {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n+                                    return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n+                                }\n+                                return true;\n+                            })\n+                            .findAny();\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n                 }\n             }\n         }\n     }\n \n+    @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\n+    private void createEmitter(BuildProducer<EmitterBuildItem> emitters, InjectionPointInfo injectionPoint,\n+            String channelName,\n+            Optional<AnnotationInstance> overflow) {\n+        LOGGER.debugf(\"Emitter injection point '%s' detected, channel name: '%s'\",\n+                injectionPoint.getTargetInfo(), channelName);\n+        if (overflow.isPresent()) {\n+            AnnotationInstance annotation = overflow.get();\n+            AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n+            int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n+            emitters.produce(\n+                    EmitterBuildItem.of(channelName, annotation.value().asString(), bufferSize));\n+        } else {\n+            emitters.produce(EmitterBuildItem.of(channelName));\n+        }\n+    }\n+\n     @BuildStep\n     public List<UnremovableBeanBuildItem> removalExclusions() {\n         return Arrays.asList(\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+    }\n+\n+    @BuildStep\n+    public void enableMetrics(Capabilities capabilities, ReactiveMessagingConfiguration configuration,\n+            BuildProducer<AdditionalBeanBuildItem> beans) {\n+        if (capabilities.isCapabilityPresent(Capabilities.METRICS) && configuration.metricsEnabled) {\n+            beans.produce(new AdditionalBeanBuildItem(MetricDecorator.class.getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5Mzk2MQ=="}, "originalCommit": {"oid": "b30a826ca93685fb0b7e5a8e9a230d489666725f"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE2OTgyNw==", "bodyText": "I discussed with @mkouba and it seems that using a transformer to veto the bean is the best approach.", "url": "https://github.com/quarkusio/quarkus/pull/7059#discussion_r380169827", "createdAt": "2020-02-17T13:04:15Z", "author": {"login": "cescoffier"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/SmallRyeReactiveMessagingProcessor.java", "diffHunk": "@@ -143,54 +149,98 @@ void validateBeanDeployment(\n \n         for (InjectionPointInfo injectionPoint : validationPhase.getContext()\n                 .get(BuildExtension.Key.INJECTION_POINTS)) {\n-            if (injectionPoint.getRequiredType().name()\n-                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n+            // New emitter from the spec.\n+            if (injectionPoint.getRequiredType().name().equals(\n+                    io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n                 AnnotationInstance instance = injectionPoint\n                         .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.CHANNEL);\n                 if (instance == null) {\n-                    instance = injectionPoint\n-                            .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.STREAM); //@Channel is the replacement of deprecated @Stream\n-                }\n-                if (instance != null) {\n-                    // Stream.value() is mandatory\n-                    String name = instance.value().asString();\n-                    Optional<AnnotationInstance> maybeOverflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n                             .stream()\n                             .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.ON_OVERFLOW\n                                     .equals(ai.name()))\n                             .filter(ai -> {\n-                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint.isParam()) {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n                                     return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n                                 }\n                                 return true;\n                             })\n                             .findAny();\n-                    LOGGER.debugf(\"Emitter injection point '%s' detected, stream name: '%s'\",\n-                            injectionPoint.getTargetInfo(), name);\n-\n-                    if (maybeOverflow.isPresent()) {\n-                        AnnotationInstance annotation = maybeOverflow.get();\n-                        AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n-                        int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n-                        emitters.produce(\n-                                EmitterBuildItem.of(name,\n-                                        annotation.value().asString(),\n-                                        bufferSize));\n-                    } else {\n-                        emitters.produce(EmitterBuildItem.of(name));\n-                    }\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n+                }\n+            }\n+\n+            // Deprecated Emitter from SmallRye (emitter, channel and on overflow have been added to the spec)\n+            if (injectionPoint.getRequiredType().name()\n+                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_EMITTER)) {\n+                AnnotationInstance instance = injectionPoint\n+                        .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_CHANNEL);\n+                if (instance == null) {\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                            .stream()\n+                            .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_ON_OVERFLOW\n+                                    .equals(ai.name()))\n+                            .filter(ai -> {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n+                                    return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n+                                }\n+                                return true;\n+                            })\n+                            .findAny();\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n                 }\n             }\n         }\n     }\n \n+    @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\n+    private void createEmitter(BuildProducer<EmitterBuildItem> emitters, InjectionPointInfo injectionPoint,\n+            String channelName,\n+            Optional<AnnotationInstance> overflow) {\n+        LOGGER.debugf(\"Emitter injection point '%s' detected, channel name: '%s'\",\n+                injectionPoint.getTargetInfo(), channelName);\n+        if (overflow.isPresent()) {\n+            AnnotationInstance annotation = overflow.get();\n+            AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n+            int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n+            emitters.produce(\n+                    EmitterBuildItem.of(channelName, annotation.value().asString(), bufferSize));\n+        } else {\n+            emitters.produce(EmitterBuildItem.of(channelName));\n+        }\n+    }\n+\n     @BuildStep\n     public List<UnremovableBeanBuildItem> removalExclusions() {\n         return Arrays.asList(\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+    }\n+\n+    @BuildStep\n+    public void enableMetrics(Capabilities capabilities, ReactiveMessagingConfiguration configuration,\n+            BuildProducer<AdditionalBeanBuildItem> beans) {\n+        if (capabilities.isCapabilityPresent(Capabilities.METRICS) && configuration.metricsEnabled) {\n+            beans.produce(new AdditionalBeanBuildItem(MetricDecorator.class.getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5Mzk2MQ=="}, "originalCommit": {"oid": "b30a826ca93685fb0b7e5a8e9a230d489666725f"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5MzQwNg==", "bodyText": "Hm, yes that would be using SmallRye-specific API.\nVetoing sounds like a good idea!", "url": "https://github.com/quarkusio/quarkus/pull/7059#discussion_r380193406", "createdAt": "2020-02-17T13:52:20Z", "author": {"login": "jmartisk"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/SmallRyeReactiveMessagingProcessor.java", "diffHunk": "@@ -143,54 +149,98 @@ void validateBeanDeployment(\n \n         for (InjectionPointInfo injectionPoint : validationPhase.getContext()\n                 .get(BuildExtension.Key.INJECTION_POINTS)) {\n-            if (injectionPoint.getRequiredType().name()\n-                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n+            // New emitter from the spec.\n+            if (injectionPoint.getRequiredType().name().equals(\n+                    io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n                 AnnotationInstance instance = injectionPoint\n                         .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.CHANNEL);\n                 if (instance == null) {\n-                    instance = injectionPoint\n-                            .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.STREAM); //@Channel is the replacement of deprecated @Stream\n-                }\n-                if (instance != null) {\n-                    // Stream.value() is mandatory\n-                    String name = instance.value().asString();\n-                    Optional<AnnotationInstance> maybeOverflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n                             .stream()\n                             .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.ON_OVERFLOW\n                                     .equals(ai.name()))\n                             .filter(ai -> {\n-                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint.isParam()) {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n                                     return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n                                 }\n                                 return true;\n                             })\n                             .findAny();\n-                    LOGGER.debugf(\"Emitter injection point '%s' detected, stream name: '%s'\",\n-                            injectionPoint.getTargetInfo(), name);\n-\n-                    if (maybeOverflow.isPresent()) {\n-                        AnnotationInstance annotation = maybeOverflow.get();\n-                        AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n-                        int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n-                        emitters.produce(\n-                                EmitterBuildItem.of(name,\n-                                        annotation.value().asString(),\n-                                        bufferSize));\n-                    } else {\n-                        emitters.produce(EmitterBuildItem.of(name));\n-                    }\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n+                }\n+            }\n+\n+            // Deprecated Emitter from SmallRye (emitter, channel and on overflow have been added to the spec)\n+            if (injectionPoint.getRequiredType().name()\n+                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_EMITTER)) {\n+                AnnotationInstance instance = injectionPoint\n+                        .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_CHANNEL);\n+                if (instance == null) {\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                            .stream()\n+                            .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_ON_OVERFLOW\n+                                    .equals(ai.name()))\n+                            .filter(ai -> {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n+                                    return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n+                                }\n+                                return true;\n+                            })\n+                            .findAny();\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n                 }\n             }\n         }\n     }\n \n+    @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\n+    private void createEmitter(BuildProducer<EmitterBuildItem> emitters, InjectionPointInfo injectionPoint,\n+            String channelName,\n+            Optional<AnnotationInstance> overflow) {\n+        LOGGER.debugf(\"Emitter injection point '%s' detected, channel name: '%s'\",\n+                injectionPoint.getTargetInfo(), channelName);\n+        if (overflow.isPresent()) {\n+            AnnotationInstance annotation = overflow.get();\n+            AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n+            int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n+            emitters.produce(\n+                    EmitterBuildItem.of(channelName, annotation.value().asString(), bufferSize));\n+        } else {\n+            emitters.produce(EmitterBuildItem.of(channelName));\n+        }\n+    }\n+\n     @BuildStep\n     public List<UnremovableBeanBuildItem> removalExclusions() {\n         return Arrays.asList(\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+    }\n+\n+    @BuildStep\n+    public void enableMetrics(Capabilities capabilities, ReactiveMessagingConfiguration configuration,\n+            BuildProducer<AdditionalBeanBuildItem> beans) {\n+        if (capabilities.isCapabilityPresent(Capabilities.METRICS) && configuration.metricsEnabled) {\n+            beans.produce(new AdditionalBeanBuildItem(MetricDecorator.class.getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5Mzk2MQ=="}, "originalCommit": {"oid": "b30a826ca93685fb0b7e5a8e9a230d489666725f"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIxMjY2OQ==", "bodyText": "I've implemented the veto approach.", "url": "https://github.com/quarkusio/quarkus/pull/7059#discussion_r380212669", "createdAt": "2020-02-17T14:28:49Z", "author": {"login": "cescoffier"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/SmallRyeReactiveMessagingProcessor.java", "diffHunk": "@@ -143,54 +149,98 @@ void validateBeanDeployment(\n \n         for (InjectionPointInfo injectionPoint : validationPhase.getContext()\n                 .get(BuildExtension.Key.INJECTION_POINTS)) {\n-            if (injectionPoint.getRequiredType().name()\n-                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n+            // New emitter from the spec.\n+            if (injectionPoint.getRequiredType().name().equals(\n+                    io.quarkus.smallrye.reactivemessaging.deployment.DotNames.EMITTER)) {\n                 AnnotationInstance instance = injectionPoint\n                         .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.CHANNEL);\n                 if (instance == null) {\n-                    instance = injectionPoint\n-                            .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.STREAM); //@Channel is the replacement of deprecated @Stream\n-                }\n-                if (instance != null) {\n-                    // Stream.value() is mandatory\n-                    String name = instance.value().asString();\n-                    Optional<AnnotationInstance> maybeOverflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n                             .stream()\n                             .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.ON_OVERFLOW\n                                     .equals(ai.name()))\n                             .filter(ai -> {\n-                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint.isParam()) {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n                                     return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n                                 }\n                                 return true;\n                             })\n                             .findAny();\n-                    LOGGER.debugf(\"Emitter injection point '%s' detected, stream name: '%s'\",\n-                            injectionPoint.getTargetInfo(), name);\n-\n-                    if (maybeOverflow.isPresent()) {\n-                        AnnotationInstance annotation = maybeOverflow.get();\n-                        AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n-                        int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n-                        emitters.produce(\n-                                EmitterBuildItem.of(name,\n-                                        annotation.value().asString(),\n-                                        bufferSize));\n-                    } else {\n-                        emitters.produce(EmitterBuildItem.of(name));\n-                    }\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n+                }\n+            }\n+\n+            // Deprecated Emitter from SmallRye (emitter, channel and on overflow have been added to the spec)\n+            if (injectionPoint.getRequiredType().name()\n+                    .equals(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_EMITTER)) {\n+                AnnotationInstance instance = injectionPoint\n+                        .getRequiredQualifier(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_CHANNEL);\n+                if (instance == null) {\n+                    validationPhase.getContext().addDeploymentProblem(\n+                            new DeploymentException(\n+                                    \"Invalid emitter injection - @Channel is required for \" + injectionPoint\n+                                            .getTargetInfo()));\n+                } else {\n+                    String channelName = instance.value().asString();\n+                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n+                            .stream()\n+                            .filter(ai -> io.quarkus.smallrye.reactivemessaging.deployment.DotNames.LEGACY_ON_OVERFLOW\n+                                    .equals(ai.name()))\n+                            .filter(ai -> {\n+                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n+                                        .isParam()) {\n+                                    return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n+                                }\n+                                return true;\n+                            })\n+                            .findAny();\n+                    createEmitter(emitters, injectionPoint, channelName, overflow);\n                 }\n             }\n         }\n     }\n \n+    @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\n+    private void createEmitter(BuildProducer<EmitterBuildItem> emitters, InjectionPointInfo injectionPoint,\n+            String channelName,\n+            Optional<AnnotationInstance> overflow) {\n+        LOGGER.debugf(\"Emitter injection point '%s' detected, channel name: '%s'\",\n+                injectionPoint.getTargetInfo(), channelName);\n+        if (overflow.isPresent()) {\n+            AnnotationInstance annotation = overflow.get();\n+            AnnotationValue maybeBufferSize = annotation.value(\"bufferSize\");\n+            int bufferSize = maybeBufferSize != null ? maybeBufferSize.asInt() : 0;\n+            emitters.produce(\n+                    EmitterBuildItem.of(channelName, annotation.value().asString(), bufferSize));\n+        } else {\n+            emitters.produce(EmitterBuildItem.of(channelName));\n+        }\n+    }\n+\n     @BuildStep\n     public List<UnremovableBeanBuildItem> removalExclusions() {\n         return Arrays.asList(\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.INCOMING)),\n                 new UnremovableBeanBuildItem(\n-                        new BeanClassAnnotationExclusion(io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+                        new BeanClassAnnotationExclusion(\n+                                io.quarkus.smallrye.reactivemessaging.deployment.DotNames.OUTGOING)));\n+    }\n+\n+    @BuildStep\n+    public void enableMetrics(Capabilities capabilities, ReactiveMessagingConfiguration configuration,\n+            BuildProducer<AdditionalBeanBuildItem> beans) {\n+        if (capabilities.isCapabilityPresent(Capabilities.METRICS) && configuration.metricsEnabled) {\n+            beans.produce(new AdditionalBeanBuildItem(MetricDecorator.class.getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5Mzk2MQ=="}, "originalCommit": {"oid": "b30a826ca93685fb0b7e5a8e9a230d489666725f"}, "originalPosition": 173}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1121, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}